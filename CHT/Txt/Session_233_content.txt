彼得·崔：大家好 下午好
歡迎參加《iOS高級手寫輸入》講座
我是彼得
在Apple的iOS性能小組工作
今天和朋友UIKit小組的雅各布
準備給大家介紹更多有關
手寫輸入在iOS怎樣運行 
以及怎樣用它讓自己的應用對手寫輸入更爲靈敏
今天要講的內容可是不少
正如前一個幻燈片所講要想讓自己的應用 
反應靈敏的話 
減少延遲是關鍵
我們將介紹延遲是什麼
以及爲什麼要關注應用中的延遲
以及iOS中的一般性延遲問題
爲了探討延遲是來自哪裏
我們將探討並剖析iOS中
在手指下負責處理
手寫輸入和繪製像素圖之間
對觸控做出各種反應的主要內容
去年我們對iOS 9的系統
做了許多改進我們將向大家
介紹這些改進以及大家可以
用到的部分API 以便充分利用我們所做的這些改進
最後 我們會告訴大家一些技巧
和最佳實踐 以便發現 分析
和解決在應用中出現的性能瓶頸
爲何要關注降低應用中的延遲問題呢？
iOS手寫輸入是建立在直接操縱的理念上
也就是說用戶實際上用手指
觸碰物理對象 並在虛擬空間中做移動
例如 如果用戶想要把這個圓
從A點移動到B點那麼預期的結果
就是圓感覺被粘在手指指尖
你會注意到在本例中
這個圓會準確靈敏地隨着
用戶手指移動
但是一旦降低延遲
也就是手指移動和圓的移動
二者間的滯後這種直接
操縱的感覺就會開始被打破
在本例中 你可以看到圓在跟隨手指而動而且並不像
是你是在手指周圍移動圓
當用戶手指移動
速度非常快時情況會越發嚴重
這樣 手指與圓之間會形成相當距離
而且不再感覺手指與圓是處於粘合狀態
圓此刻是在跟着手指移動
這類延遲會影響到iOS的各方面
從按下按鈕到移動對象
到滾動任何內容甚至是網頁都不可避免
但是我們可以確定有兩三個應用
可以顯著增加延遲作用
一種應用類型是繪圖應用 
不僅是藝術家會被線條末端
和用戶指尖的距離搞得心神不寧
藝術家通常要依賴應用
或用戶界面的快速靈敏更新
以便及時調整物理行爲
才能獲得希望的結果
此外 遊戲這類應用中的延遲
可能會讓遊戲很難繼續
並會影響到應用的感知質量
這個延遲是從哪裏來的呢？
是來源自許多不同地方
爲了探討哪裏會產生延遲我們會聊聊
在處理觸控和相應繪製 
觸控當中系統中的所有不同部分
在講座接下來的內容中
我們會用到很多這些管路圖
我們要確保大家對其中的含義理解相同
在屏幕上 你會看到5個不同的盒子
每個盒子都代表顯示器上
顯示一幀內容所用的時間
我們的產品刷新屏幕是60赫茲
也就是每秒60次
那麼每個盒子所代表的時間
大約爲1/60秒
大家可能聽到了每個盒子都代表顯示幀
顯示間隔或顯示週期
這些都是一個意思
現在分割每個盒子的垂直線代表顯示刷新
這個時間點上顯示器上的一幀
和接下來要顯示的幀進行交換
我接下來會用顯示刷新
或同步刷新來表示這兩個基本上也是相同內容
顯示刷新在iOS中很重要
因爲許多重要系統進程
都是由這個顯示刷新來啓動或觸發
我們來具體看看在管線中在發生了些什麼
管線的第一階段是Multi-Touch
在這一個進程中硬件將掃描
顯示器表面尋找觸控
在我們的多數產品中這部分用時
會小於整個顯示幀但在我們的部分產品中
這會佔用整個顯示幀
爲了更直觀我們用綠盒子來填充整個盒子
Multi-Touch一旦完成掃描顯示器
會過濾掉屏幕上
所出現的任何噪音
UI應用的UITouch的回調將在靠近下一個
觸控幀開始時被調用通常是在顯示刷新開始後
這個點出現在應用應
該對手寫輸入做出反應時在繪圖應用中
也許是標定點並連接這些點
你也許想做平滑處理令線條更流暢
在不是繪圖應用的應用中
這裏需要通過按下按鈕或按鍵
來做出反應也許是生成視圖 
視圖控制器 並向用戶呈現
這裏所花費的時間是個變量
但可以佔據一個顯示幀
那麼我再來填充整個盒子
一旦應用完成與觸碰事件做出反應並相應更新狀態
在下一個顯示刷新時 Core Animation 就會啓動
開始將視圖和圖層
翻譯成GPU指令這可以被GPU渲染
你會注意到GPU不必等到下一個顯示刷新開始的時候
它在Core Animation
給出它需要渲染幀的指令時候就會立即開始
同樣 這些階段的時間根據應用中的
視圖複雜程度不同也是變量
最後一旦GPU完成渲染幀
這個幀就會在下一個顯示刷新
開始時排隊在顯示器上顯示
大家都明白在顯示器上感知觸控
直至畫圖需要佔用若干幀數本例中 需要佔用4幀
因此不是即刻完成
此外 這是管線
在應用處理之前正發生的觸控時
其他的觸控也會發生
這就是在管線不同的點經過的進程
我們來談談作爲開發人員該怎樣控制
並沒有API可以改變Multi-Touch的行爲
或顯示器硬件圖層
這是系統做出的處理
根據應用中的視圖複雜程度你對Core Animation
渲染服務器和GP進行間接控制
但是你可以對應用幾乎完全控制
我們就從這裏開始
我剛說過在這個點上
要根據手寫輸入更新應用的狀態
例如 在繪圖應用中可以標定點
並彼此連接或是根據按下按鈕創建視圖
這裏也許是發佈OpenGL或Metal指令的位置
這裏所花費的時間量是個變量
可以進行優化減少所用時間
我們鼓勵大家這麼做
但是當我們優化應用時你會注意到這點
Core Animation並不會進入填充UIKit
或應用所留下的空間
這是因爲之前在iOS如何更新視圖所導致
當你在iOS上更新視圖狀態時 
如果用UIMethods更新A CATransaction
視圖屬性的話可以顯性提交
或UIKit將隱性爲你生成一個
我們用紅點來表示CATransaction提交
現在Core Animation 沒有填入時間
是因爲應用允許在一個
顯示幀中多次升級狀態
在本例中用第二個點表示
現在 爲減少冗餘任務量
或永遠不會在顯示器上出現的任務
Core Animation分批處理所有更新
並在顯示刷新中進行一次渲染
那麼我們將渲染這些
Core Animation事務的綜合狀態
一旦Core Animation在顯示刷新時
快照視圖它將會開始把所有你爲之生成的邏輯視圖
和圖層翻譯成GPU指令以便由GPU進行渲染
我剛說過一接到Core Animation
的必要指令GPU就會立刻啓動
因此 如果優化Core Animation
或GPU的用時數量GPU就會填充所留下的空間
Xcode的視圖調試器是理解視圖層次複雜度的很好方法
也是找到可以取出的視圖的很好方法從而可以優化應用
不過我們認識到 對視圖的需求非常複雜
在一個顯示幀中很難完全體現
那麼iOS管線可以靈活處理這點
如果應用需要花費額外的時間渲染視圖
我們可以把CoreAnimation
和GPU任務分到兩個顯示幀
當然 這增加了額外的延遲幀數
但是還可以在應用的各處獲得
每秒60幀的流暢動畫視圖還更爲複雜
並無手動觸發選擇快慢模式
這又是視情況而定而且是系統任意選定
所以重要的是我們理解什麼內容可以觸發進入更快模式
什麼內容可以觸發進入更慢模式
更快模式叫做雙緩衝 
這麼叫是因爲有兩個緩衝一個是爲了引入GPU 
一個是爲了LCD向用戶顯示
在顯示刷新中大家回憶一下
Core Animation爲自己和GPU抓取緩衝
並開始輸出該幀的GPU指令
一旦GPU獲得指令GPU就開始渲染
如果渲染在下一個顯示刷新
發生前結束我們就把這個幀放入隊列
在下一個顯示刷新中顯示
一旦到達顯示刷新
這個幀就會進入屏幕
我們開始處理下一個幀
同樣 GPU將做渲染再把這一幀放入隊列
爲下一個顯示刷新進行顯示
一旦開始顯示刷新
這兩個幀將交換位置
我們會回收綠色緩衝繼續這一進程
只要應用有需要渲染的視圖即可
現在都沒問題
我們已經在一個顯示幀完成Core
Core Animation和GPU任務
性能很好
可是如果無法做到所有這些 會怎樣？
如果無法在一幀中完成呢？
那我們就進入了三重緩衝模式
同樣Core Animation會輸出GPU指令
GPU隨後會渲染不過在本例中
在開始顯示刷新時GPU並沒有完成綠色幀的渲染
在本例中 因爲我們還無法展示 
爲了額外的幀藍色幀延伸到屏幕上的情景
Core Animation現在需要分配第三個緩衝
開始處理下一個幀通過生成
第三個緩衝來實現這一點
Core Animation將開始爲之輸出GPU指令
同時GPU完成前一幀的渲染
然後前一幀將進入隊列
在下一個顯示刷新中顯示
這一進程隨後
和Core Animation渲染服務器輸出GPU指令一起重複
GPU會對它們進行渲染
思路就是我們交換緩衝回收緩衝
然後進程重複進行
大家可能會想 所有這些幻燈片都在說Core Animation
我如果不用CoreAnimation會怎樣？
如果我要優化應用
使用 Metal orOpenGL 會怎樣？
大家可能會想與其讓管線變成這樣
讓顯示的幀變成4幀延遲
不如改作3幀延遲
不過這裏不行
在iOS 8如果用Metal或OpenGL
Core Animation仍會作爲仲裁器 確保你對...
Core Animation 內容在屏幕上所做的
任何更新 都與這些圖層上的GPU 
OpenGL和Metal更新保持同步
在使用iOS 8的 OpenGL
或Metal時你仍有4幀延遲
那麼我們談到過iOS管線非常靈活
可以處理更爲複雜的視圖
可以實現每秒60幀動畫
但是在5幀延遲中會怎樣
怎樣優化應用通過優化繪圖 
把延遲降爲4幀
但是 在本例中沒有辦法
可以實現更快 因爲Core Animation
需要等到顯示刷新開始
生成GPU指令才行
在iOS 9中我們去除了這種依賴性
現在可以在應用完成應用狀態升級後 
立刻啓動 CoreAnimation 任務
爲了充分利用這些功能我們在iOS系統中引入了
一些新的API和新技巧
爲了更多介紹這方面內容
有請雅各布
雅克布·肖：謝謝 彼得
我將向大家
介紹我們在iOS 9中新增的內容
以及怎樣用它們實現app的更低延遲
今天我來講三個問題
第一 低延遲支持Core Animation
然後是用戶觸控接合的新系統
最後是個很酷的系統可以在UIKit構建
觸控預測
我們現在先從Core Animation低延遲開始
彼得講過在iOS 8中
即便是最優化的app延遲的降低程度也是非常有限的
通過使用iOS 9的低延遲Core Animation
可以把app的幀和Core Animation的幀相結合
這會實現更低的延遲
這種功能的最好一點在於
它是自動發生的
你不必在app上做任何改變
除了優化你的性能表現之外
不過 還需要牢記一點
當app中的動畫激活時 
低延遲模式是自動關閉的
這包括CA動畫和UIKit動畫
因此 如果需要app中 延遲是絕對最低水平
在顯示器上觸控激活時一定確保要
關閉這些動畫功能
現在 系統還可以與MetalOpenGL內容配合使用
因此正如之前在iOS 8中所見
我們必須等額外的幀以便讓GPU內容得以顯示
但是有了新的低延遲模式 
我們可以在緊鄰的下一幀
儘快顯示這些內容
這些都是自動完成
使用CAeagllayer或CAMetalLayer即可
不過 如果有想和OpenGL或Metal內容
一起顯示的CoreAnimation 內容的話
在app中還需要記住一點
這樣 GPU內容 會盡快拉到
顯示器上但是 coreAnimation內容
則需要更長時間才能過去
如果是這種情況那麼默認狀態
不會確保GPU內容會到達Core Animation
內容的同一幀
如果你希望二者同步的話這就會出現問題
例如如果你希望把UIKit內容繪製
在OpenGL視圖上面就會出現這樣的情況
這種情況下 你希望同步更新
類似這樣這裏有個屬性
可實現這一功能
叫做PresentsWith Transaction
是在CAeagllayer和CAMetalLayer上面
當設置這個爲False時這是默認值
那就可以儘快獲得顯示的GPU內容
但是當設置爲True的時候
我們可以將GPU內容
和Core Animation內容同步 因此它們會同時
出現在顯示器上
好 接下來 我們談談觸控接合
在這之前
我先介紹一下 iPad Air 2
去年 我們推出iPad Air 2
顯示屏更新速率爲60赫茲
也就是說顯示器每秒更新60次
和其他的iOS設備一樣
它有個很酷的功能可以影響觸控
和觸控延遲我今天很興奮能向大家介紹這點
這樣它可實現120赫茲觸控掃描更新速率
太酷了
這意味着掃描觸控的速率是其他iOS設備的兩倍
這非常棒因爲你可以獲得
用戶手指和顯示器互動時的更多信息
我們來看這會在實踐中怎樣影響app
使用60赫茲的觸控掃描速率在用戶手指
在顯示器上移動時我們會定期採樣
手指的位置並把這個信息提供給app
使用120赫茲掃描速率時也會發生同樣的事情
但是因爲是兩倍的速率你會獲得兩倍的樣本
這會讓你掌握用戶行爲的更多信息
現在 一旦獲得這些樣本我們就會把它們轉給app
通過這些 你會瞭解用戶想要用觸控做些什麼
例如 在繪圖app中你可能會把這些
連接起來 顯示出用戶想要實現的繪圖
120赫茲的信息會提供更多信息量
以便會繪圖有着更好的表示
現在我們看到了使用120赫茲的觸控掃描速率所帶來的好處
我們先來看它會怎樣影響觸控對顯示管線的作用
這是60赫茲的觸控掃描速率管線我們之前見過
我們主要來看管線的Multi-Touch階段
在60赫茲水平上 我們每幀會獲得一個新觸控樣本
在120赫茲水平上我們每次會獲得兩個樣本
不過 要注意顯示幀依然相同
因爲顯示器本身的更新速率相同
現在我們可以用這些新的觸控樣本 
並將其轉至app而且app可以用它來更新繪圖
而繪圖會把在Core Animation
和顯示器顯示的內容做更新
但是你會注意到如果我們這麼做
app的更新次數實際是顯示器更新的兩倍 這會導致app在做
無用功
我們介紹了觸控接合系統來或者兩方面的最好效果
這樣可以從120赫茲觸控掃描速率中獲得更多信息 
但是不會在app中取消太多無用功
我們來看管線如何與接合一起改變
現在我們只能向app
每個顯示幀交付一個觸控
當首個觸控出現時我們會把它交付給你
然後是下一幀我們會交付這一幀
的觸控 同時還有上次我們發送觸控
到app上時所出現的任何中間觸控
每次用戶要顯示更多觸控時這些都會重複一遍
我們提供當前的觸控和任何接合觸控
只要觸控激活這些就會繼續
現在 API使用這些接合觸控就非常簡單
這是UIEvent上的新方法叫做Coalesce Touches
For Touch
把這個方法轉至正在看的觸控
在上次我們交付 觸控到app上之後
會返回一組所有的接合觸控
爲更好了解這個API該怎樣使用
我們來看看觸控處理一般在iOS上怎樣運作
當用戶首先觸控顯示屏時
我們會調用app上的Touches Began 
他們的手指移動時我們將調用Touches Moved
當手指從顯示屏拿開時
我們會調用Touches Ended
現在 我們談論這些觸控回調時
另一個非常重要的回調是Touches Canceled
當通往app的觸控流中斷時 就會調用它
例如 如果用戶從底部滑動
來激活Control Center
在這種情況下 當接收到系統手勢 app將
獲得部分初始觸控回調
我們將獲得Touches Canceled
用這種方法來清理之前的觸控
回調所開始的任何內容
以及回退所做的任何改變都很重要
例如 在繪圖app中你可能想清除用戶所畫的線條
現在我們瞭解了這些觸控回調是怎麼起作用
我們來看它們怎樣和接合觸控互動
我們交付給所有回調的觸控我們稱之爲主觸控
這部分在120赫茲掃描速率和60赫茲設備上都完全相同
但是 有了Coalesce
Touches For Touch方法
你可以通過這些接合觸控瞭解更多信息
接合觸控互動不僅有着中間觸控的相關信息
它們還會提供主觸控本身的副本
這其中最棒的一點是你可以進行選擇
你可以來看主觸控
如果不需要app的更高觸控掃描速率
所增加的信息量
或者如果如果想要這些信息
可以來看接合觸控而且你不必擔心主觸控
現在 我們再來看觸控序列 
看它如何與主觸控和接合觸控相配合
隨着用戶手指的下滑
我們會給app一個主觸控並將其副本作爲接合觸控
隨着手指的移動
我們會交付新的主觸控
和各自的一組接合觸控
最後 隨着手指離開
我們將提供最後的主觸控
和任何其餘的接合觸控
這裏我希望只展示每個主觸控的一兩個接合觸控
需要注意的是app可以收到不同的數量這點很重要
如果app花費長時間處理一個觸控
然後我們給你些時間跟進並等着跟進之後發送新的觸控
如果出現這樣的情況
那麼未交付給你的觸控稍後會作爲接合觸控發送給你
因此 確保你的代碼對所收到的接合觸控
數量 不存在任何依賴性
現在 在這些接合 觸控的行爲方式
和主觸控的行爲方式之間存在一些區別
其中之一與之前的位置有關
之前的位置可以通過Previous
Location In Viewfrom UITouch方法來獲得
對主觸控而言 這可以爲app提供該觸控
在交付時的最後位置
對接合觸控而言其行爲也非常相似
它可以提供針對app的
最後接合觸控的位置
這就是需要只關注主觸控
或只關注接合觸控很重要的原因之一
這樣 你就不會對之前的位置產生任何混淆
因此不要過界非常重要
在主觸控和接合觸控之間還有一個區別
就是UITouch對象本身如何行爲
和主觸控一起 每次觸控交付
給app時 UITouch  實例就會再次使用
這樣做很有用因爲如果用戶
立刻在顯示器上使用多個手指的話這可以讓你區別不同的觸控
對接合觸控而言這會有所不同
每次 向app交付接合觸控時
我們交付一個新的具有新屬性的
UITouch實例
所以你可以把這些當作是快照
而不是主觸控的共享身份
現在 你理解了觸控接合是如何工作的
讓我們研究一下某些代碼如何使用接合觸控
這就是在app中可能用到的部分代碼
可以用於繪圖在移動的觸控中可以用這類內容
這裏我們會重複我們已有的觸控
我們在抓取每個觸控對應的代碼行
然後 我們把最後的觸控作爲新樣本加入該行的末尾
爲了增加觸控的接合支持我們只需要加上這一小部分代碼
這裏我們爲給定的主觸控
重複所有的接合觸控
對於各個接合觸控我們把它加爲該行的樣本
注意 我們只添加樣本接合觸控
而不是主觸控
這就是觸控接合
現在我想談談觸控預測
這是我們剛加入UIKit中的很酷的系統
用它可以實現app中的更低延遲
正如我們交付的app新觸控也會讓你瞭解到未來
我們可以預測到用戶觸控在稍後會做些什麼
這裏的API和接合觸控的API工作效果很相似
這是UIEvent上的新方法叫做Predicted Touches
For Touch
同樣 經過主觸控進入這個方法
然後返回一組預測觸控
可以使用這些預測觸控來更新繪圖
或者是你用用戶觸控所做的其他任務
來獲取更低的延遲
之前我們看到主觸控和接合觸控是如何相關聯
而且預測觸控的運行方法也非常相似
它們是與主觸控相關的另一組觸控
而且和接合觸控一樣作爲快照發揮作用
現在 和接合觸控相比預測觸控
有一點不同那就是在發生新觸控時的表現
當你獲得新的主觸控時你會獲得一組新的
預測觸控 然後你只想使用新的預測觸控
任何之前的預測觸控都不再有用
因爲我們現在掌握了當時用戶實際在哪裏觸控
因此 你一般想扔掉那些舊的預測觸控
現在視圖中之前的位置對預測觸控進行類似的處理
它對其他觸控類型也是如此對待
它指出之前的預測觸控
所在的位置或者是針對第一個
預測觸控它指出交付給app的最後位置
因此你可能會奇怪我們怎麼會獲得這些預測觸控 其實相當簡單
我們在每個iOS設備中都加上了時間機器
其實不是這樣的
我們實際上是來看交付給app的
觸控 並使用一套高度精密的算法來確定用戶手指此刻
即將會做些什麼
當我們獲得新的觸控樣本時我們會更新預測
並把新的預測觸控交付給app
現在每個預測觸控都是完整的UITouch
對象 而且都填寫了所有的屬性
例如位置和時間標記
現在我們來看 預測觸控對我們在看的管線會有什麼影響
這是我們之前看到的主觸控和接合觸控我們可以輕鬆加入預測觸控
每一幀 正如app獲得主觸控
你也可以獲得一組預測觸控
如果你獲得主觸控和接合觸控
那麼預測觸控是可以獲得的更多信息
在新觸控交付時會重複這一進程
要注意的是接合觸控的和預測觸控是獨立的
你可以用其中一個而不用另一個
60赫茲和120赫茲觸控掃描速率設備
均可支持預測觸控
我們先來看怎麼把觸控預測
加入我們剛纔看的代碼之中
只需要加上這一小部分代碼
我們要做的是首先刪除我們加入
代碼行中的之前的任何預測觸控
這很重要 因爲我們現在有了這些觸控的實際位置
然後 我們會重複運行已有的預測觸控
對於每個預測觸控我們把它加爲代碼行的樣本
但是注意 我們這裏加入預測樣本
調用的方法不同於調用常規樣本的方法
這樣我們可以將樣本標記爲下次運行該代碼時需要將之刪除
這就是觸控接合和觸控預測
大家現在看到了所有這些技巧
我們來看看把它們結合起來會是什麼效果
在iOS 8中 有個優化的app 
這就是你可以獲取的觸控延遲視圖
在觸控首次出現和顯示器
更新觸控信息之間 
我們測量延遲的時間
因此 你可以看到在iOS 8中
我們會有4幀延遲
通過使用低延遲Core Animation和iOS 9
我們可以從中刪除一幀延遲
通過使用觸控接合並在高觸控
掃描速率設備上運行
你不僅可以獲得用戶觸控的更多信息量還可以從一開始
就刪除半幀延遲
但是不僅如此！
通過使用觸控預測你可以獲得
未來用戶觸控將往何處去的大約一幀延遲
這會讓你爲用戶提供有效延遲
也可以減少一幀以上延遲
那麼算在一起在 iOS 9 你可以爲用戶降低
約1.5幀延遲這要比iOS 8
中的4幀延遲提高很多
那麼我們覺得這的確了不得
我很希望大家在app中運用這些技術
爲用戶提供更低的延遲體驗
現在我想把講臺交回給彼得
請他來講講怎樣調試app
彼得·崔：謝謝 雅各布
現在我們瞭解了一些iOS 9中的最新低延遲模式
我們還將介紹一些如何利用
這些來調試應用這樣就可以滿足
時間的一個顯示幀的要求還可以把幀快速地顯示出來
首先 要確保應用在完成最少量的任務
則要將應用需要完成的任務量最小化
通過雅各布剛介紹的接合觸控API
你可以享用到iPad Air 2
高保真手寫輸入的好處同時確保
完成的任務量將在屏幕上顯示的圖像
此外 要記住用戶只會關心
在設備顯示器上可以看到的內容
應用可以跟蹤屏幕
以外的環境狀態
但是 最終 你需要確保渲染工作要僅限於
那些最終要在屏幕上
生成顯示圖像的必要工作
如果準備構建應用
計算應用在CPU上
所花費時間 Time Profiler是個不錯的辦法
Time Profiler將通過
在固定間隔取樣 顯示應用在CPU中所用的時間
在本例中在Time Profiler
我選用的是16毫秒間隔
這基本和一個顯示幀相對應
你可以看出本例中的應用
只用了其中一小塊時間 
在本例中 是3毫秒
如果是要測量並簡要介紹
在CPU方面的表現這也沒問題
那麼GPU會怎樣呢？
在Xcode調試會話中GPU
報告中的每秒傳輸幀數工具會爲應用的GPU
表現給出高層視圖
在本例中 你可以看到這個應用是60幀每秒
這是相對較低的GPU幀時
在本例中僅爲3.8毫秒
不過要記住這是關於應用運行的高層概視圖
其中並未提供也許會導致
掉幀的單獨幀的詳細信息
如果需要此類精度
可以使用新的GPU驅動工具
我們今年在Xcode中就有包括
GPU驅動工具可以在你使用應用的同時
顯示GPU激活的準確時間
在本例中 你可以看到我的應用中
在頂點和片段着色器所用時間相對較少
實際上 這只是在顯示器上
顯示一幀內容所用時間的一小部分
注意這裏只有兩種顏色
這兩種顏色代表着使用雙緩衝方案的兩個緩衝器
如果應用在Core Animation
和GPU中花費更多時間你會在這裏
看到三種顏色代表系統裏正在進行的三重緩衝
我們談了很多降低延遲的內容
並讓應用靈敏度更高不過最終
實現出色的iOS 體驗是用戶
自然和本能的體驗
而讓應用感覺更生動則是實現這一目標的另一種不錯的方法
去年 我們對系統的每個部件都進行了認真的思考 
想方設法使其比以前更快更好
在這一過程中我們改進了API
爲大家提供更多控制和信息
來瞭解系統的運行狀況
有了OpenGL Metal和 Core Animation
的最新低延遲模式你可以在向用戶顯示幀 
以及如何與屏幕上的其他內容 
同步的時候 實現更多控制
利用觸控接合你可以利用
所有硬件及其所有出色的功能 向用戶
提供出色體驗
使用觸控預測我們可以讓你少許窺探未來預測觸控即將往何處去
最後我們構建並生成部分不錯的工具
以便你瞭解應用的性能表現這樣你可以對之進行改進 
以便向用戶提供更好的體驗
在Apple 我們致力於讓我們的產品
使用體驗比以往更出色
我們認爲通過降低延遲是實現這一點的不錯方法
我們願意邀請各位朝這方面努力
大家在developer.apple.com
可以瞭解到我們今天探討的技術工具和API等更多詳情
我們還想邀請大家參加開發者
論壇中的開發者
技術對話
我們今天介紹了許多不同的新技術
今年和往年有過許多
與這一講座相關話題的出色討論
例如 如果你非常感興趣簡要介紹應用的GPU性能
如果非常非常想着手嘗試
新的GPU工具我將向大家推薦
《Metal性能優化技術》講座
這是今天早些時候的一場講座
其中介紹了一整套不同的技術 
可以用來優化GPU運行而不只是說使用Metal
此外如果Time Profiler常出問題 可以試試去聽
《深度剖析》講座這是昨天的一場講座
其中深度剖析了該怎樣使用Time Profiler
並瞭解你的應用完成任務的情況
最後 如果大家的確感興趣
在Core Animation和 管線的GPU階段究竟在做些什麼
這部分內容我們今天講過
我將向大家推薦去年WWDC的
《高級圖形和動畫》講座
所有這些講座和許許多多其他講座
都可以在開發人員門戶網站找到developer.apple.com
希望大家今天收穫很多在本週的全部環節中
我希望大家喜歡WWDC的內容
謝謝