00:00:20.120 --> 00:00:24.825 
用GCD構建具有響應性的高效app

00:00:27.528 --> 00:00:28.362 
早上好

00:00:30.898 --> 00:00:33.834 
歡迎來到本次講座 題目爲
用GCD構建具有響應性的高效app

00:00:34.301 --> 00:00:37.504 
我們非常高興看到這麼多的人有興趣

00:00:37.571 --> 00:00:40.541 
學習如何利用
多線程優化技術來幫助你們的

00:00:40.874 --> 00:00:43.443 
應用程序適應我們所有的平臺

00:00:43.577 --> 00:00:47.548 
我是Anthony我將和我的隊友
Daniel一起呈現這段演講

00:00:48.315 --> 00:00:50.851 
多線程優化技術或者叫GCD是
與OS X Snow

00:00:50.918 --> 00:00:53.587 
Leopard
操作系統一起引入的一種技術

00:00:54.021 --> 00:00:56.523 
當時我們的最新版的Mac

00:00:56.590 --> 00:00:59.459 
還是使用Core II
Duo的MacBook Pro

00:00:59.593 --> 00:01:02.596 
當時GCD的賣點之一是

00:01:02.663 --> 00:01:05.065 
它讓你可以使用雙核

00:01:05.132 --> 00:01:07.534 
同時運行應用程序的不同部分

00:01:07.601 --> 00:01:10.070 
並使線程變得非常非常容易

00:01:10.370 --> 00:01:13.841 
我們認爲GCD的使用真的
經受住了時間的考驗

00:01:14.708 --> 00:01:19.046 
今天我們最先進
的Mac Pro有多得多的內核

00:01:19.613 --> 00:01:22.382 
而GCD仍然是利用這些所有計算資源

00:01:22.449 --> 00:01:23.617 
的好方法

00:01:24.585 --> 00:01:27.988 
但正如GCD有助於利用所有高端

00:01:28.055 --> 00:01:30.891 
資源一樣 它還可以幫助你的應用程序

00:01:30.991 --> 00:01:32.593 
適應較小的環境

00:01:34.494 --> 00:01:37.598 
比如最近發佈的新MacBook是

00:01:37.664 --> 00:01:39.099 
第一個無窗格的設計

00:01:39.333 --> 00:01:42.769 
雖然就機型體積而言

00:01:44.304 --> 00:01:47.274 
這是一個優勢 但如何管理熱性能而言

00:01:47.341 --> 00:01:49.476 
它也帶來一些獨特的挑戰

00:01:49.943 --> 00:01:53.113 
稍後我會談到
你們的app如何利用GCD

00:01:53.180 --> 00:01:55.148 
從而在這種環境下更有效地運行

00:01:56.817 --> 00:01:59.520 
我們iOS 9也有了 新多任務功能

00:01:59.953 --> 00:02:02.923 
這是第一次你們的
應用程序必須肩並肩地

00:02:02.990 --> 00:02:06.827 
這種說法毫不誇張與其他
應用程序一起在系統中運行

00:02:06.894 --> 00:02:09.930 
GCD可以告訴系統你正在做什麼

00:02:09.997 --> 00:02:12.599 
並能夠更好地在你的應用程序和其他

00:02:12.666 --> 00:02:15.035 
出現在屏幕上應用程序之間分配資源

00:02:16.837 --> 00:02:21.642 
有了Watch OS系統
即便我們最小的平臺都能識別你的代碼

00:02:22.643 --> 00:02:26.280 
GCD可以幫助
系統知道你應該運行哪些部分

00:02:26.346 --> 00:02:28.849 
的代碼才能讓你在這麼大的設備上

00:02:28.916 --> 00:02:34.154 
構建起具有響應性能的應用程序

00:02:39.359 --> 00:02:41.361 
所以我要先簡要概述
我們今天將要討論的內容

00:02:42.029 --> 00:02:45.199 
我首先會介紹所謂的服務質量類別

00:02:45.632 --> 00:02:49.503 
我們與iOS 8和OS X 
Yosemite發佈的一款API

00:02:50.838 --> 00:02:53.207 
Daniel來講解它針對GCD使用

00:02:53.273 --> 00:02:54.641 
一些設計模式以及

00:02:54.708 --> 00:02:56.577 
如何整合QLS與這些模式

00:02:57.678 --> 00:03:00.280 
然後我會詳細講解線程 隊列

00:03:00.347 --> 00:03:03.217 
並運行可以使GCD更便於使用的循環

00:03:03.717 --> 00:03:06.620 
最後我們會就如何理解使用GCD時

00:03:06.687 --> 00:03:09.089 
的崩潰報告得出一個簡短的結論

00:03:12.192 --> 00:03:13.827 
但首先需要一點背景

00:03:14.661 --> 00:03:16.964 
你們構建起非常棒的app

00:03:17.030 --> 00:03:20.200 
然後開始執行這款app
用戶觸碰它的圖標

00:03:20.267 --> 00:03:21.835 
從finder中進行下載

00:03:22.102 --> 00:03:24.304 
我們將開始執行主函數中的代碼

00:03:24.571 --> 00:03:26.306 
那麼你們將得到每個app用以開始的

00:03:26.373 --> 00:03:27.708 
最初的主線程

00:03:28.342 --> 00:03:32.212 
你們調用應用程序UI函數 
或者NS應用程序函數

00:03:32.279 --> 00:03:34.281 
接着會彈出一個線程上的運行循環

00:03:34.348 --> 00:03:35.816 
和框架代碼

00:03:37.284 --> 00:03:39.887 
然後線程會停在那裏等待事件

00:03:40.320 --> 00:03:41.889 
在某一時刻會有事件發生

00:03:42.389 --> 00:03:44.124 
也許你會得到一個調出的委派模式

00:03:44.191 --> 00:03:45.993 
到你的應用程序委託UI

00:03:46.660 --> 00:03:48.362 
這時你的代碼開始運行

00:03:48.428 --> 00:03:51.198 
需要完成某項任務
比方說從數據庫讀取信息

00:03:52.132 --> 00:03:54.535 
你發出指令訪問磁盤上的該文件

00:03:55.669 --> 00:03:57.070 
就會返回相應數據

00:03:58.372 --> 00:03:59.973 
你會更新用戶界面

00:04:02.776 --> 00:04:05.612 
最後返回控制到框架

00:04:05.679 --> 00:04:07.514 
並繼續等待線程上的事件

00:04:08.348 --> 00:04:10.117 
這些進展都很順利 只是

00:04:10.184 --> 00:04:12.186 
從數據庫讀取信息需要一點兒時間

00:04:13.754 --> 00:04:18.791 
在OS X系統
此時你可能會看到一個旋轉的等待光標

00:04:18.858 --> 00:04:21.661 
iOS系統裏
app會暫停甚至被終止運行

00:04:22.429 --> 00:04:25.799 
這種用戶體驗不僅糟糕而且未得到響應

00:04:28.068 --> 00:04:30.037 
出現這種情況GCD就可以參與進來

00:04:30.103 --> 00:04:31.972 
幫助提高運行效率

00:04:32.039 --> 00:04:33.774 
你會得到調出的委派模式

00:04:33.841 --> 00:04:38.478 
但是不要立即開始進行操作
而要創建一個GCD隊列

00:04:39.947 --> 00:04:42.583 
使用異步分派把任務移動到尾接

00:04:43.650 --> 00:04:47.387 
你的代碼與主線程異步執行

00:04:48.989 --> 00:04:50.190 
等你們得到了數據

00:04:50.257 --> 00:04:53.861 
就可以異步分派回主線程更新用戶界面

00:04:54.795 --> 00:04:58.498 
這樣做的優勢在於
當你的任務在GCD隊列運行時

00:04:59.233 --> 00:05:01.368 
主線程可以繼續等待事件

00:05:01.435 --> 00:05:02.503 
它始終保持響應狀態

00:05:02.569 --> 00:05:04.605 
用戶可以獲得持續的良好體驗

00:05:05.339 --> 00:05:06.573 
大家都感到滿意

00:05:08.308 --> 00:05:09.376 
我希望這是一個

00:05:09.443 --> 00:05:10.711 
大家都熟悉的模式

00:05:10.777 --> 00:05:12.212 
我們不會詳細談論

00:05:12.279 --> 00:05:13.514 
如何做到這一點

00:05:14.014 --> 00:05:16.517 
如果你們不熟悉 
我強烈建議各位在今天的

00:05:16.583 --> 00:05:19.853 
演講之後去一趟去普西迪
聽一聽那裏的講話

00:05:19.920 --> 00:05:21.922 
裏面將詳細講述這種模式

00:05:23.757 --> 00:05:25.792 
有一點你們之前可能沒有想過

00:05:25.859 --> 00:05:29.263 
我們現在有兩個線程兩個都要執行代碼

00:05:29.329 --> 00:05:31.265 
主線程要處理新事件

00:05:31.331 --> 00:05:32.466 
GCD隊列要

00:05:32.533 --> 00:05:34.568 
執行你派遣的任務

00:05:35.235 --> 00:05:37.371 
也許這兩個任務都在一個核心設備上

00:05:38.038 --> 00:05:40.374 
在這種情況下我們要執行哪個線程呢

00:05:45.145 --> 00:05:47.881 
這裏服務質量類別
就要發揮作用了

00:05:49.049 --> 00:05:53.086 
這是一個在iOS 8和10
Yosemite系統中的新的API

00:05:53.153 --> 00:05:54.555 
於去年發佈

00:05:55.455 --> 00:05:58.959 
我們有四個服務質量類別：
用戶交互模式

00:05:59.026 --> 00:06:01.628 
用戶發起模式效用和背景

00:06:02.796 --> 00:06:05.766 
通過這些方法你可以
告訴系統你們正在進行哪種任務

00:06:06.433 --> 00:06:10.404 
它也使系統能夠提供各種資源控制

00:06:10.704 --> 00:06:12.706 
以最有效地執行你的代碼

00:06:14.341 --> 00:06:16.376 
說到資源控制什麼是資源控制

00:06:16.944 --> 00:06:20.214 
我們的系統支持CPU調度優先級

00:06:20.414 --> 00:06:22.382 
我們要運行哪些線程以什麼順序運行

00:06:23.217 --> 00:06:26.086 
說到I / O優先級
當系統中有多個I / O時

00:06:26.153 --> 00:06:27.321 
應該以什麼順序執行呢

00:06:28.088 --> 00:06:30.657 
計時器聚合技術是一個省電的功能

00:06:31.325 --> 00:06:33.760 
無論我們按照吞吐量還是以效率

00:06:33.827 --> 00:06:35.429 
導向模式運行CPU

00:06:35.495 --> 00:06:37.364 
我們想要獲得最佳的性能還是想要

00:06:37.431 --> 00:06:39.867 
以最節能的方式執行的代碼

00:06:41.268 --> 00:06:45.305 
在理想情況下爲每個平臺或設備優化

00:06:45.372 --> 00:06:48.308 
這些配置值或設備運行的代碼

00:06:49.243 --> 00:06:51.178 
但顯然這種做法很快會難以爲繼

00:06:51.445 --> 00:06:54.448 
許多配置值很難調整 而代碼

00:06:54.515 --> 00:06:56.283 
運行的平臺數量衆多

00:06:58.185 --> 00:07:00.254 
服務質量類別被設計成

00:07:00.320 --> 00:07:03.156 
一個抽象參數你們可以使用

00:07:03.223 --> 00:07:06.727 
這個參數描述任務的目的和類別

00:07:07.194 --> 00:07:08.495 
不要試圖調整所有

00:07:08.562 --> 00:07:11.665 
具體的配置值
你們要明白自己所做的都

00:07:11.732 --> 00:07:13.433 
“由將要執行工作的用戶啓動”

00:07:13.667 --> 00:07:15.602 
而系統將自動爲平臺和設備

00:07:15.669 --> 00:07:17.571 
選擇正確的配置值

00:07:20.641 --> 00:07:22.776 
我前面提到過我們有四個服務質量類別

00:07:23.043 --> 00:07:25.479 
接下來我要對它們進行簡要介紹
它們分別有什麼用途

00:07:26.079 --> 00:07:27.548 
第一個是用戶交互模式

00:07:28.081 --> 00:07:29.583 
這是主線程

00:07:30.250 --> 00:07:33.353 
假設有一個iOS應用程序用戶的手指

00:07:33.420 --> 00:07:34.688 
正在屏幕上拖動

00:07:35.088 --> 00:07:37.891 
主線程需要響應以便在

00:07:37.958 --> 00:07:39.693 
用戶手指拖動時交付

00:07:39.760 --> 00:07:40.727 
下一幀動畫

00:07:41.695 --> 00:07:45.799 
主要用戶交互代碼是保持動畫

00:07:45.866 --> 00:07:49.236 
以每秒60幀的
速度平穩運行的專門代碼

00:07:52.206 --> 00:07:55.342 
所以你們需要問自己
這項工作是否積極參與

00:07:55.409 --> 00:07:56.376 
到更新UI之中

00:07:56.443 --> 00:07:59.179 
在決定是否需要進行用戶交互式設計時
這一點一定要加以考慮

00:08:00.113 --> 00:08:04.384 
這不是在加載可能成爲滾動視圖的內容

00:08:04.985 --> 00:08:07.921 
這就是在畫新的動畫

00:08:08.589 --> 00:08:11.792 
我們所說的用戶發起模式
是指加載由用戶

00:08:11.859 --> 00:08:13.861 
完成的動作結果

00:08:14.328 --> 00:08:15.662 
比如當我翻動滾動視圖

00:08:15.729 --> 00:08:18.532 
爲下一個單元加載數據時

00:08:19.166 --> 00:08:23.270 
或我在使用照片或郵件
應用程序並點擊電子郵件或照片

00:08:23.604 --> 00:08:26.173 
加載全尺寸照片或電子郵件時

00:08:26.673 --> 00:08:29.243 
這些行爲就是我們
所說的用戶發起的動作

00:08:30.744 --> 00:08:33.145 
問題是要繼續進行用戶交互

00:08:33.212 --> 00:08:34.715 
是否需要這項工作

00:08:35.414 --> 00:08:36.717 
對其中任何一個都沒有幫助

00:08:36.783 --> 00:08:38.852 
作爲用戶發起而不是用戶攔截

00:08:39.385 --> 00:08:41.755 
如果用戶不能通過你們的應用程序繼續

00:08:41.822 --> 00:08:44.591 
取得有意義的進展
就應該選擇用戶發起模式

00:08:46.226 --> 00:08:49.329 
效用是指用戶本來可能已經開始進行

00:08:49.596 --> 00:08:51.098 
或已經自動啓動任務

00:08:51.164 --> 00:08:54.101 
這些任務長時間運行但是並不阻礙用戶

00:08:54.168 --> 00:08:55.702 
繼續使用你們的應用程序

00:08:57.171 --> 00:08:59.072 
你們要問問自己用戶是否瞭解

00:08:59.139 --> 00:09:00.407 
這項工作的進展

00:09:00.841 --> 00:09:03.911 
如果一個雜誌app正在下載新刊物

00:09:04.344 --> 00:09:07.881 
那麼用戶可以繼續使這個app
下載任務可以同時進行彼此互不幹擾

00:09:07.948 --> 00:09:10.517 
他們可以閱讀往期刊物或隨意瀏覽

00:09:10.584 --> 00:09:12.152 
你們可以設計一個進度條

00:09:12.419 --> 00:09:13.987 
幫助用戶瞭解進展情況

00:09:14.521 --> 00:09:16.757 
效用是一個很好的類別

00:09:18.892 --> 00:09:21.395 
最後其餘的一切都可以歸爲背景

00:09:21.528 --> 00:09:23.163 
用戶不會主動關注的一切

00:09:23.230 --> 00:09:25.432 
任何類型的維護任務 清理工作

00:09:26.767 --> 00:09:29.770 
數據庫清空都屬於背景

00:09:31.638 --> 00:09:32.739 
根本問題是

00:09:32.806 --> 00:09:34.408 
用戶有沒有意識到這項工作

00:09:35.309 --> 00:09:37.177 
背景工作很有趣 因爲你要

00:09:37.244 --> 00:09:38.645 
考慮何時處理背景

00:09:39.379 --> 00:09:41.281 
我強烈建議你們去看一看

00:09:42.282 --> 00:09:44.651 
去年關於編寫節能代碼的那部分演講

00:09:44.718 --> 00:09:47.421 
該演講討論瞭如何有效地做好背景工作

00:09:47.521 --> 00:09:49.556 
如何判斷你們
的應用程序背景是否表現出色

00:09:56.663 --> 00:09:58.165 
所以我提到了我們的新MacBook

00:09:59.299 --> 00:10:01.768 
就像我說的這是第一款無風扇的Mac

00:10:02.336 --> 00:10:05.205 
在之前有風扇的Macbook裏

00:10:05.672 --> 00:10:08.842 
機器處理的工作越來越多 產生的熱量

00:10:08.909 --> 00:10:11.712 
也越來越多 那麼我們可以加快

00:10:11.778 --> 00:10:14.781 
風扇轉速來幫助熱量更快消散

00:10:15.682 --> 00:10:18.185 
新版MacBook非常節能令人驚訝

00:10:18.252 --> 00:10:22.456 
我們不需要風扇散熱在大多數情況下

00:10:23.423 --> 00:10:26.827 
但全速運轉該機器仍然會

00:10:26.894 --> 00:10:29.329 
產生一些熱量我們需要驅散

00:10:30.264 --> 00:10:32.432 
但是我們驅散熱量的能力是有限的

00:10:33.367 --> 00:10:37.738 
我們有其他技術確保我們能讓

00:10:37.804 --> 00:10:40.007 
機器保持適當的溫度適合使用者使用

00:10:40.841 --> 00:10:44.144 
假設你有一款正在使用的app
然後你已經完成工作

00:10:44.211 --> 00:10:46.013 
按服務類的四項質量指標而言

00:10:46.847 --> 00:10:50.117 
你正很努力的開動機器用了很多的能量

00:10:50.184 --> 00:10:52.853 
而我們需要幫忙控制控制熱量的多少

00:10:52.920 --> 00:10:55.189 
這樣能讓機器在合理的溫度中工作

00:10:56.423 --> 00:10:58.926 
好了我們能做的是我們能
開始擠出我們的工作量

00:10:58.992 --> 00:11:00.394 
我們將要做的是

00:11:00.460 --> 00:11:02.663 
比較不重要的服務質量標準

00:11:03.397 --> 00:11:06.600 
這就允許我們管理
這個系統能量的使用

00:11:07.901 --> 00:11:10.337 
保持機器
響應及時確保了

00:11:10.404 --> 00:11:13.841 
沒有無反應情況 讓使用者看到

00:11:14.675 --> 00:11:16.043 
這個方式很重要

00:11:16.109 --> 00:11:17.811 
因爲你讓你的工作正確分類了

00:11:17.878 --> 00:11:19.646 
在運行一個像這樣的機器時

00:11:22.015 --> 00:11:24.852 
我還提到iOS
以及新的多元任務的特點

00:11:25.552 --> 00:11:28.355 
你可以想象在古老的
世界裏我們可能會有你的app

00:11:28.422 --> 00:11:31.758 
的主要思路而且可能
它還有另外的分派線程

00:11:31.825 --> 00:11:35.162 
在使用但是現在
我提出了另外一款app

00:11:38.198 --> 00:11:40.067 
那款app也將會有一個主要思路

00:11:41.235 --> 00:11:43.570 
然後我也有Picture in
Picture

00:11:43.637 --> 00:11:45.205 
那款也有一個思路解碼視頻

00:11:46.039 --> 00:11:48.976 
好了但是我也只是擁有兩個CPUs

00:11:49.910 --> 00:11:52.346 
所以如果我不得不使用其中之一
來解碼視頻

00:11:52.412 --> 00:11:54.181 
對於下一個我該做些什麼呢

00:11:54.281 --> 00:11:55.616 
這是另外一個領域對於質量

00:11:55.682 --> 00:11:57.351 
服務標準來說能真正幫你解決問題

00:11:57.851 --> 00:12:01.655 
表明了操作系統的服務質量標準的

00:12:01.722 --> 00:12:03.957 
每一個線程我們都可以準確決定

00:12:04.024 --> 00:12:06.226 
在哪裏安排那些可用的資源

00:12:07.928 --> 00:12:10.130 
通過那些我會轉交東西給Daniel

00:12:10.197 --> 00:12:14.301 
他會檢查特定的設計模式
以及對那些類型如何應用服務質量標準

00:12:21.275 --> 00:12:22.943 
早上好 謝謝 Anthony

00:12:23.010 --> 00:12:24.945 
本章我們會看幾個

00:12:25.012 --> 00:12:29.616 
關於GCD設計和QOS是如何應用的
具體的例子

00:12:30.617 --> 00:12:34.154 
首先我們從最基本的開始 先看GCD

00:12:34.221 --> 00:12:38.325 
和QoS 在每個獨立模塊的層次上

00:12:38.392 --> 00:12:41.862 
是怎樣被細分的
例如QoS 從提交線程到

00:12:42.462 --> 00:12:44.364 
異步運行模塊

00:12:44.431 --> 00:12:47.668 
有一個整體功能模塊

00:12:47.734 --> 00:12:49.036 
和一個異步分派模塊

00:12:49.102 --> 00:12:50.838 
以及相關的自動傳播QoS模塊

00:12:51.505 --> 00:12:54.575 
那麼這個系統是怎樣爲你

00:12:54.641 --> 00:12:56.143 
自動切換一些優先級別的呢？

00:12:56.210 --> 00:13:00.247 
沒有時間深入地討論具體的API命令

00:13:00.781 --> 00:13:05.452 
如果你想了解更多的細節 我建議你

00:13:05.519 --> 00:13:07.454 
看看去年的演講內容
"功率 性能

00:13:07.521 --> 00:13:09.389 
和診斷: GCD和XPC的新內容"

00:13:09.456 --> 00:13:13.293 
那麼你就能在開發者的網站看到

00:13:13.360 --> 00:13:17.231 
我們在如何使用API的
問題上已經講了很多具體內容

00:13:17.297 --> 00:13:18.665 
這是去年的新課程

00:13:20.334 --> 00:13:23.136 
第一個例子是
 Anthony很早就有了的

00:13:23.203 --> 00:13:26.139 
在主線程的提示下執行了一些異步工作

00:13:26.206 --> 00:13:31.211 
在GCD上做了些I/O

00:13:32.546 --> 00:13:37.251 
這個例子怎樣適應於QoS？

00:13:37.317 --> 00:13:38.986 
什麼是可以被應用在這裏的

00:13:39.052 --> 00:13:40.587 
適當質量的服務等級呢？

00:13:41.088 --> 00:13:44.525 
當然在左手邊我們有主線程

00:13:44.591 --> 00:13:47.461 
Anthony說過是UI呈現的地方

00:13:47.528 --> 00:13:48.862 
這裏是事件處理的地方

00:13:49.396 --> 00:13:51.865 
合適的調用服務命令是用戶互動命令

00:13:52.566 --> 00:13:54.101 
這些都是無條件獲得的

00:13:54.201 --> 00:13:57.571 
應用程序的主線程就在這種質量
的服務等級下服務等級下出現

00:13:58.872 --> 00:14:00.474 
在屏幕右手邊

00:14:00.541 --> 00:14:03.243 
是沒有出現在主線程的異步工作

00:14:03.777 --> 00:14:07.014 
很明顯我們不應該啓動用戶互動

00:14:07.147 --> 00:14:09.049 
這裏我們不是在做UI呈現

00:14:09.183 --> 00:14:12.419 
而是在說正盯住文件圖標

00:14:12.486 --> 00:14:16.723 
正在等待他的文件打開的用戶

00:14:16.924 --> 00:14:18.792 
用戶已經在使用此app前就被絆住了

00:14:18.892 --> 00:14:21.795 
他仍然能和用戶界面互相影響
但是並不能做所有他想做的事情

00:14:21.862 --> 00:14:24.631 
比如編輯文件或者查看文件

00:14:24.798 --> 00:14:27.901 
用戶初始化是服務的最佳質量

00:14:30.270 --> 00:14:33.173 
如何通過GCDAPI達到這個目標

00:14:34.141 --> 00:14:37.644 
其實你不需要做任何事情

00:14:37.978 --> 00:14:39.546 
它就會自動實現

00:14:39.613 --> 00:14:41.582 
但重要的是理解爲什麼會這樣

00:14:41.648 --> 00:14:43.050 
讓我們詳細來看一下

00:14:44.785 --> 00:14:47.387 
所有程序都起源於初步調動async

00:14:47.454 --> 00:14:50.357 
它能從主線程消除異步工作

00:14:50.757 --> 00:14:53.594 
正如我在前一個幻燈片裏講的那樣

00:14:53.660 --> 00:14:55.963 
async異步分派會從你提交塊執行

00:14:56.029 --> 00:14:59.566 
服務線程隊列

00:14:59.633 --> 00:15:02.736 
自動傳播服務質量

00:15:04.838 --> 00:15:07.174 
在這個例子中有一個特殊的規則適用於

00:15:07.241 --> 00:15:12.713 
我們自動轉譯的
用戶交互用戶發起的服務質量

00:15:13.280 --> 00:15:15.883 
這樣做我們就避免了過度傳播

00:15:15.949 --> 00:15:18.151 
應該受到限制的服務質量

00:15:18.218 --> 00:15:20.153 
到主要的線程和呈現的用戶界面

00:15:20.654 --> 00:15:22.356 
我們可以好好利用此法

00:15:22.422 --> 00:15:24.258 
因爲這正是我們想要的

00:15:24.358 --> 00:15:26.360 
通常情況下

00:15:26.527 --> 00:15:30.030 
在用戶發起的服務質量隊列上

00:15:30.464 --> 00:15:33.967 
都是通過自動傳播來運行

00:15:34.735 --> 00:15:38.472 
當你用自動傳播也試着進行的結果

00:15:38.539 --> 00:15:40.607 
回到主線程去更新

00:15:40.674 --> 00:15:42.009 
用戶界面

00:15:42.075 --> 00:15:47.281 
因爲用戶主線程是服務用戶交互的質量

00:15:47.581 --> 00:15:48.649 
所優先考慮的

00:15:48.715 --> 00:15:51.451 
如果你去一個線程 它不會降低

00:15:51.518 --> 00:15:52.786 
那些主線程上指定的

00:15:52.853 --> 00:15:54.254 
服務質量

00:15:54.855 --> 00:15:56.890 
這裏我們將忽略傳播的價值

00:15:57.324 --> 00:16:01.328 
來在用戶交互
服務質量底部運行用戶界面修改塊

00:16:01.395 --> 00:16:02.863 
運行用戶界面修改塊

00:16:05.566 --> 00:16:09.369 
我們調用QoS傳播屬性推斷QoS

00:16:09.503 --> 00:16:14.208 
這是塊被提交
至一個隊列時被捕獲的QoS

00:16:14.274 --> 00:16:15.576 
和特殊規則

00:16:15.642 --> 00:16:17.211 
我們轉譯用戶交互至用戶初始化

00:16:17.311 --> 00:16:19.079 
正如上文提到的

00:16:20.414 --> 00:16:22.716 
如果目的地提交之處

00:16:22.783 --> 00:16:24.751 
沒有自己的指定的服務質量

00:16:24.818 --> 00:16:27.154 
在分配自己的
高質量的服務主線程的情況下

00:16:28.288 --> 00:16:34.127 
也不降低QoS
就將用到這種傳播的服務質量

00:16:37.097 --> 00:16:42.569 
下一個例子是不能自動開啓任務的情況

00:16:42.636 --> 00:16:45.038 
長期運行的任務
比如說在一個異步調用的長期

00:16:45.105 --> 00:16:48.408 
的運算中 關閉主線程

00:16:48.475 --> 00:16:53.080 
用戶界面就不能更新
它正在處理主線程的當前隊列

00:16:53.146 --> 00:16:58.919 
可能會更新UI 通過一個異步

00:16:58.986 --> 00:17:00.454 
返回塊的進程

00:17:00.554 --> 00:17:02.589 
這個塊包含了更新一些用戶界面元素

00:17:05.826 --> 00:17:08.662 
那麼什麼纔是合適的服務質量類呢？

00:17:08.729 --> 00:17:11.865 
在你左手邊是用戶互動

00:17:11.932 --> 00:17:14.902 
右手邊是之前描述過的Anthony

00:17:14.968 --> 00:17:16.970 
這就是適合質量服務

00:17:17.037 --> 00:17:18.939 
程序運行的情景

00:17:19.339 --> 00:17:20.741 
它是長期運行的

00:17:20.807 --> 00:17:22.442 
用戶可以繼續使用用戶界面

00:17:22.509 --> 00:17:24.310 
不用等待就會得到想要的畫面

00:17:24.377 --> 00:17:27.981 
他也可以看一些進程 以某種方式發起

00:17:28.048 --> 00:17:31.685 
的進程 
但是這並不會影響到之前的界面

00:17:34.421 --> 00:17:38.192 
我們怎麼用GCD API實現它呢？

00:17:38.258 --> 00:17:40.394 
最簡單的解決方法是關注

00:17:40.460 --> 00:17:42.529 
任務的產生和發起

00:17:43.063 --> 00:17:44.998 
這是異步調用的開始

00:17:45.599 --> 00:17:48.202 
我們以標記我們提交

00:17:48.669 --> 00:17:50.537 
的帶有合適的質量服務類的塊

00:17:50.604 --> 00:17:54.041 
通過調用塊生成質量服務類的接口

00:17:54.441 --> 00:17:57.377 
我們傳入想執行的塊或者

00:17:57.477 --> 00:17:58.579 
我們想要的質量服務類

00:17:58.679 --> 00:18:00.714 
應用程序就有了

00:18:00.781 --> 00:18:02.616 
這就是生成的異步調用的

00:18:02.683 --> 00:18:06.753 
塊對象 當它被執行的時候

00:18:06.820 --> 00:18:08.589 
會在質量服務類的應用程序裏運行

00:18:09.223 --> 00:18:12.693 
通過查找最初

00:18:12.759 --> 00:18:14.995 
質量服務類變化的點

00:18:15.062 --> 00:18:17.998 
就會自動傳遞給下一步執行

00:18:18.065 --> 00:18:21.268 
如果那個塊發生變化 就會利用

00:18:21.335 --> 00:18:22.870 
自動執行這個特性

00:18:22.936 --> 00:18:25.339 
因此產生的

00:18:25.405 --> 00:18:27.474 
任何異步線程將會自動運行

00:18:27.541 --> 00:18:29.676 
相對應的質量服務類

00:18:29.743 --> 00:18:32.613 
並繼續作爲應用程序
這期間你不需要做任何事

00:18:34.848 --> 00:18:39.419 
在前面的幻燈片上我們可以看到這個

00:18:39.486 --> 00:18:42.356 
質量服務塊被創建
通過顯示的給塊對象添加質量

00:18:42.422 --> 00:18:45.726 
服務屬性的方式來實現
你只需要提供合適的調用時間

00:18:45.792 --> 00:18:50.531 
當任務產生不同的類的時候

00:18:51.398 --> 00:18:54.334 
另一個質量服務應用在塊對象中的案例

00:18:54.668 --> 00:18:58.639 
當你需要捕獲你提供塊的

00:18:58.705 --> 00:19:00.774 
質量服務類時

00:19:00.841 --> 00:19:05.112 
就是說在一個回調塊的方案中
你正在寫一個接口

00:19:05.312 --> 00:19:07.981 
別人提供給你一個回調塊 你想

00:19:08.048 --> 00:19:11.318 
在另一個隊列或者線程中保存並提交它

00:19:11.385 --> 00:19:13.287 
但是你很想讓它

00:19:13.353 --> 00:19:16.023 
像異步調用

00:19:16.089 --> 00:19:18.058 
質量服務程序那樣被執行

00:19:18.125 --> 00:19:21.895 
你可以去分派現有指定模塊

00:19:21.962 --> 00:19:24.064 
由創立分配模塊標識並通過

00:19:24.131 --> 00:19:27.434 
它會捕捉到現有的QOS和執行狀態

00:19:27.501 --> 00:19:30.504 
在提交模塊後把它保存到快速模塊中

00:19:30.571 --> 00:19:33.507 
它會按分配值在一個隊列上運行

00:19:37.144 --> 00:19:40.280 
看看另外一個我們的應用程序案例

00:19:40.347 --> 00:19:41.982 
它執行了一個UI操作

00:19:42.049 --> 00:19:42.983 
在操作測試性能時

00:19:43.050 --> 00:19:45.285 
它通告顯示處於維護狀態中

00:19:45.352 --> 00:19:47.254 
並即將執行清除狀態

00:19:47.321 --> 00:19:49.489 
還說裏面有一個數據庫
有太多的鬆散區

00:19:49.556 --> 00:19:53.560 
不得不進行一些壓縮程序和清除任務

00:19:53.927 --> 00:19:59.099 
還有一個GCD應用的典型例子

00:20:01.235 --> 00:20:04.037 
在執行異步分配運行的地方

00:20:04.104 --> 00:20:07.641 
後臺列隊上的維護任務

00:20:07.708 --> 00:20:09.676 
當然是在左手邊的

00:20:10.077 --> 00:20:13.714 
作爲用戶會重新啓動用戶界面

00:20:14.081 --> 00:20:16.850 
在這裏相應的服務質量等級

00:20:17.150 --> 00:20:19.086 
將用於服務背景質量上

00:20:19.820 --> 00:20:22.189 
目前鑑於幻燈片的標題

00:20:22.322 --> 00:20:23.724 
這只是一個維護操作

00:20:23.790 --> 00:20:25.392 
與用戶做了些什麼不相關係

00:20:25.459 --> 00:20:27.995 
你通告出此時你正在進行的狀態

00:20:28.595 --> 00:20:31.298 
用戶此時並未察覺發生了什麼

00:20:31.431 --> 00:20:33.967 
你要做的工作是關於APP的工作

00:20:34.034 --> 00:20:35.435 
基於此處自已利益上的工作

00:20:36.637 --> 00:20:39.540 
我們怎樣才能取得服務後臺的運行質量

00:20:39.940 --> 00:20:43.343 
我們能做的一件事
就是早點看到API模塊的應用

00:20:43.410 --> 00:20:47.748 
讓初始異步此隊列成爲

00:20:47.848 --> 00:20:49.316 
後臺服務的質量

00:20:49.616 --> 00:20:52.186 
也許這件事在APP中是比較多樣性的

00:20:52.252 --> 00:20:53.820 
以此而成清除工作的類型

00:20:53.887 --> 00:20:55.255 
同時你也有多樣的方法

00:20:55.656 --> 00:20:58.992 
可以在這個模式下的數據庫上進行操作

00:20:59.059 --> 00:21:02.329 
這要用一個適當並特別的隊列

00:21:02.396 --> 00:21:05.165 
精確地完成此任務 你纔可能創立起

00:21:05.232 --> 00:21:07.734 
有指定服務質量的隊列

00:21:07.801 --> 00:21:10.771 
你可以用QOS等級分派隊列屬性

00:21:11.171 --> 00:21:13.674 
通過如範例中後臺

00:21:13.740 --> 00:21:16.376 
所生成屬性通過並分配到創立隊列上

00:21:16.810 --> 00:21:19.546 
創立一個如範例中清除隊列

00:21:20.547 --> 00:21:23.217 
通過服務等級質量被指定到隊列上

00:21:23.617 --> 00:21:26.787 
得到了異步分派的自動傳播

00:21:27.254 --> 00:21:31.859 
用戶再次從主流程啓動

00:21:31.992 --> 00:21:34.161 
我們實際上忽略了傳播的價值

00:21:34.228 --> 00:21:36.763 
因爲你正在提交
一個自身擁用指定服務等級質量的隊列

00:21:36.830 --> 00:21:39.499 
並說可以用此隊列來替代

00:21:40.000 --> 00:21:43.170 
所以你提交的模塊將在後臺運行

00:21:43.370 --> 00:21:44.638 
代替已經如果有的

00:21:44.705 --> 00:21:46.673 
自動系統

00:21:47.641 --> 00:21:50.210 
對於這樣的情況

00:21:50.277 --> 00:21:55.015 
某處有一個與執行流程無關的維護任務

00:21:55.315 --> 00:21:59.953 
考慮調度程序塊分離
的標記是否有用是合適的

00:22:00.420 --> 00:22:04.424 
這是一種告訴操縱系統

00:22:04.491 --> 00:22:06.193 
你正對這個程序塊所做的事情

00:22:06.260 --> 00:22:08.028 
與執行流程無關的方式

00:22:08.095 --> 00:22:11.598 
而且它尤其不參與QoS的傳播

00:22:11.665 --> 00:22:16.069 
也不捕捉事物 如活動ID

00:22:16.136 --> 00:22:20.741 
如果你正在去年我們會上介紹過的
活動追蹤特性中使用它

00:22:22.142 --> 00:22:25.179 
和其它一些執行上下文的性質

00:22:27.714 --> 00:22:30.384 
當然即使你有工作

00:22:30.450 --> 00:22:32.619 
它總是應該在QoS背景裏

00:22:32.686 --> 00:22:34.621 
那是些清理性的工作 是可例外的

00:22:34.688 --> 00:22:38.825 
如一些退出特性 用戶退出他的賬戶

00:22:38.892 --> 00:22:41.995 
你應該刪除數據庫

00:22:42.062 --> 00:22:44.431 
及用戶的私人數據

00:22:44.498 --> 00:22:47.134 
那是一些用戶希望能看到它完成的事情

00:22:47.201 --> 00:22:48.902 
這不該是後臺任務

00:22:49.069 --> 00:22:54.541 
你有必要在後臺屬性中重寫

00:22:54.608 --> 00:22:56.944 
或退出你這裏已經設置過的

00:22:57.010 --> 00:22:58.545 
這個隊列或這個運行

00:22:58.979 --> 00:23:01.582 
如果這裏你僅用自動傳播特性

00:23:01.648 --> 00:23:04.718 
像以前一樣除了這裏 我們應該忽略

00:23:04.785 --> 00:23:06.587 
用戶初始的QoS

00:23:06.820 --> 00:23:09.590 
當然這是可用的合適的QoS

00:23:09.656 --> 00:23:10.824 
這是我們真正期望的

00:23:10.891 --> 00:23:12.926 
用戶正在等待這個退出結束

00:23:13.327 --> 00:23:14.461 
如何達成呢？

00:23:14.528 --> 00:23:19.333 
利用調度程序塊執行QoS分類標誌

00:23:19.399 --> 00:23:22.102 
程序塊創建和你想執行的程序塊

00:23:22.169 --> 00:23:23.737 
那是在告訴系統

00:23:23.804 --> 00:23:26.773 
你真的希望程序塊中的數值

00:23:26.840 --> 00:23:27.908 
與隊列中的相反

00:23:27.975 --> 00:23:30.911 
這樣你可以重寫隊列的數值顯示

00:23:32.212 --> 00:23:36.917 
如果你這樣做程序塊將在本例中

00:23:36.984 --> 00:23:39.386 
用戶初始的QoS分類中執行

00:23:41.088 --> 00:23:42.022 
但是 當然 在圖中

00:23:42.089 --> 00:23:44.057 
你可以看到現在的情況：

00:23:44.124 --> 00:23:47.027 
你有個別潛在含兩個程序塊的隊列

00:23:47.094 --> 00:23:49.830 
兩程序塊是同時的且有不同的優先級別

00:23:50.264 --> 00:23:53.467 
這就是異步優先級反轉翻轉

00:23:53.534 --> 00:23:56.136 
一個高級QoS程序塊
可能被提交給一個串行隊列

00:23:56.203 --> 00:23:58.539 
但是隊列中已有工作

00:23:58.605 --> 00:24:00.207 
或在更低級的QoS中運行

00:24:00.274 --> 00:24:01.975 
你有優先權翻轉

00:24:03.177 --> 00:24:05.646 
GCD會幫助你如果你通過提升

00:24:05.712 --> 00:24:08.882 
串行隊列中的工作來使用串行隊列

00:24:08.949 --> 00:24:12.252 
運行或是入隊
直到你達到高級別的QoS程序塊

00:24:12.986 --> 00:24:17.224 
這是後臺QoS覆蓋出現問題

00:24:17.624 --> 00:24:23.163 
並非重寫塊調用自身的問題
或者如果將任務非同步傳輸下去

00:24:23.230 --> 00:24:28.268 
程序塊將以原始QoS狀態傳輸

00:24:28.468 --> 00:24:32.539 
但程序塊將以更高優先級
執行從而消除塊的反轉執行

00:24:34.408 --> 00:24:38.612 
概括說QoS隊列排序大多適合那些

00:24:38.679 --> 00:24:41.615 
在應用程序中排序是唯一用途的場景

00:24:41.682 --> 00:24:44.818 
或者輸入的指令
不需要考慮登錄優先級的重要性

00:24:44.885 --> 00:24:48.555 
而需要考慮的是指令用途的優先級

00:24:48.622 --> 00:24:50.824 
QoS隊列排序還可用於

00:24:50.891 --> 00:24:54.895 
爲這種類型的工作
負載所開發的獨立的程序塊API

00:24:54.962 --> 00:24:56.964 
當這種負載處於維護或後臺模式時

00:24:59.333 --> 00:25:03.504 
在隊列中使用QoS會使我們忽略

00:25:03.570 --> 00:25:06.773 
異步block(塊)中的QoS除非

00:25:06.840 --> 00:25:08.742 
我們在程序中使用強制執行標記

00:25:12.412 --> 00:25:16.483 
最後是利用串行隊列
實現lock(鎖)的功能

00:25:16.550 --> 00:25:18.886 
這在GCD當中是很常見的用法

00:25:18.952 --> 00:25:22.055 
在程序當中你有一些共享的數據結構

00:25:22.122 --> 00:25:25.125 
而你想要鎖定對這些數據結構的訪問

00:25:25.192 --> 00:25:29.930 
你可以通過
在數據結構中創建一個帶有調用隊列

00:25:30.030 --> 00:25:34.601 
標記的串行隊列的方法來使用GCD

00:25:35.068 --> 00:25:39.339 
然後用同步調用來執行關鍵的區段塊

00:25:39.406 --> 00:25:43.410 
在隊列中只有這個block（塊）
有訪問數據結構的權限

00:25:46.079 --> 00:25:50.083 
QoS在這個過程中是如何運行的呢
註明”同步調用”函數很重要

00:25:50.150 --> 00:25:54.388 
當調用”同步調用”函數的線程

00:25:54.454 --> 00:25:57.624 
被鎖定時執行塊

00:25:57.691 --> 00:26:00.727 
返回block（塊）的同時釋放線程

00:26:01.228 --> 00:26:03.764 
這種情況下我們不需要任何額外的線程

00:26:03.830 --> 00:26:07.835 
我們只需要執行調用同步調用的線程

00:26:07.901 --> 00:26:10.971 
然後在所調用線程的QoS中執行塊

00:26:11.038 --> 00:26:12.773 
此處指用戶交互進程

00:26:13.440 --> 00:26:15.075 
當你可以使用同步

00:26:15.142 --> 00:26:16.243 
因爲有其他的線程或隊列

00:26:16.310 --> 00:26:18.378 
也在訪問此數據結構

00:26:18.445 --> 00:26:22.382 
或許當執行一個QoS線程時
在隊列內調用”同步調用”函數

00:26:22.449 --> 00:26:25.285 
從而可以獨佔訪問

00:26:25.352 --> 00:26:26.553 
數據結構

00:26:26.620 --> 00:26:28.856 
如果隨後返回線程 同樣的事情將出現

00:26:28.922 --> 00:26:32.960 
他將停止等待線程以獲取獨佔訪問權限

00:26:33.026 --> 00:26:36.163 
然後在調用QoS的線程中

00:26:36.230 --> 00:26:37.397 
執行自身

00:26:37.464 --> 00:26:40.300 
QoS線程中的塊

00:26:41.435 --> 00:26:47.374 
我們就又會碰到
如果這個獨佔訪問以別的順序獲得

00:26:47.441 --> 00:26:50.377 
優先權翻轉的問題

00:26:50.444 --> 00:26:52.880 
如果實用程序效用先進入鎖死

00:26:52.946 --> 00:26:55.616 
主線程就必須等待效用線程

00:26:56.450 --> 00:26:58.719 
這當然是我們不期望的

00:26:59.086 --> 00:27:00.654 
所以QoS繼承

00:27:01.188 --> 00:27:04.691 
異步優先級翻轉會幫助你去解決

00:27:04.758 --> 00:27:08.328 
一個高級的優先級服務線程正在等待
較低級別的進程工作

00:27:08.395 --> 00:27:12.533 
我們可以通過爲等待期間

00:27:13.166 --> 00:27:15.135 
提高等待工作的QoS來解決 

00:27:15.202 --> 00:27:18.639 
如果你用串行隊列和同步調用

00:27:18.705 --> 00:27:20.274 
或調用程序塊等待API

00:27:20.908 --> 00:27:22.910 
如果你用多線程互斥鎖

00:27:23.110 --> 00:27:26.413 
或任何建立在其上的API
如NSLock也可實現

00:27:28.015 --> 00:27:31.818 
值得注意的是
有些API在這裏是不可用的

00:27:31.885 --> 00:27:35.255 
調度信號量不承認認同所有權概念

00:27:35.322 --> 00:27:37.157 
所以系統無法決定

00:27:37.224 --> 00:27:38.759 
誰最終將向信號量發信號

00:27:38.825 --> 00:27:42.829 
那種情況下
沒有任何優先權翻轉的解決方案

00:27:42.896 --> 00:27:44.631 
如果你有優先級翻轉

00:27:44.698 --> 00:27:50.003 
你在某調度信號
等待中發現高級優先級等待者

00:27:50.070 --> 00:27:53.774 
低級別優先級工作者正在執行某些工作

00:27:53.841 --> 00:27:57.377 
你可能必須轉變成調度程序塊等待 

00:27:57.444 --> 00:28:00.814 
在我們能夠進行提升的外顯實體處等待

00:28:01.915 --> 00:28:06.286 
下面請Anthony
講一下隊列線程和運行循環

00:28:12.826 --> 00:28:13.861 
謝謝 Daniel

00:28:14.695 --> 00:28:17.564 
希望這激起了你們對服務質量的興趣

00:28:17.664 --> 00:28:19.967 
並願回頭看看這些應用

00:28:20.033 --> 00:28:22.035 
及思考一下如何應用服務質量

00:28:22.569 --> 00:28:26.974 
現在我們講一下隊列、線程及運行循環

00:28:27.975 --> 00:28:32.179 
希望能使GCD的
更廣泛被應用變得更簡單

00:28:32.246 --> 00:28:34.915 
併爲你調試應用程序提供一些背景

00:28:36.917 --> 00:28:40.220 
提醒我們自己我們的應用程序與

00:28:40.287 --> 00:28:41.788 
我們的主線程相關

00:28:41.855 --> 00:28:44.057 
GCD線程池

00:28:44.124 --> 00:28:47.427 
服務於GCD隊列中的所有程序塊

00:28:47.694 --> 00:28:49.663 
在應用程序中也有某些隊列

00:28:50.931 --> 00:28:54.034 
想象一下你在主線程上執行代碼

00:28:54.101 --> 00:28:56.537 
你異步調度到某隊列

00:28:58.872 --> 00:29:02.209 
一程序塊
且我們會爲此程序塊啓動一個線程

00:29:02.910 --> 00:29:04.411 
開始執行你的代碼

00:29:04.478 --> 00:29:07.681 
在Delay之後我們將同時
執行Object和Selector

00:29:08.382 --> 00:29:10.250 
且這將在當前線程的運行循環上

00:29:10.317 --> 00:29:11.752 
加入定時源

00:29:12.586 --> 00:29:14.855 
現在讓我們想一下一秒後會發生什麼？

00:29:16.657 --> 00:29:18.825 
結果是：當程序塊完成時

00:29:18.892 --> 00:29:20.894 
線程可能會消失

00:29:20.961 --> 00:29:23.830 
這些是我們臨時線程池裏的線程

00:29:23.897 --> 00:29:25.999 
他們沒有任何可確保的有效期

00:29:26.066 --> 00:29:27.668 
我們可能會破壞這個線程

00:29:28.335 --> 00:29:30.571 
當然即使線程保留了下來 

00:29:31.038 --> 00:29:32.973 
也沒人在實際地運行那個運行循環

00:29:33.307 --> 00:29:35.242 
那個計時器將永遠不會被觸發

00:29:36.043 --> 00:29:38.745 
這是一個有趣的互動

00:29:38.812 --> 00:29:43.550 
當你混合基於運行
循環與調度隊列的API時發生的

00:29:45.819 --> 00:29:48.522 
簡單的總結一下運行循環與

00:29:48.589 --> 00:29:52.559 
串行隊列的區別：運行循環束縛於

00:29:52.626 --> 00:29:53.927 
某一特定線程

00:29:54.761 --> 00:29:58.031 
一般看到API通過委託方式被回調

00:29:59.199 --> 00:30:01.835 
他們擁有在整個運行循環源中的

00:30:01.902 --> 00:30:03.737 
每次迭代後出現的自動釋放池

00:30:04.471 --> 00:30:06.640 
且運行循環可以被重新進入使用

00:30:06.707 --> 00:30:09.943 
通過調出運行循環
以使運行循環自旋也是可能的

00:30:10.944 --> 00:30:13.380 
另一方面串行隊列

00:30:13.447 --> 00:30:16.149 
或調度隊列可利用

00:30:16.950 --> 00:30:19.987 
來自Grand Central
Dispatch線程池的臨時線程

00:30:20.053 --> 00:30:22.556 
它們一般將程序塊作爲它們的回調

00:30:22.990 --> 00:30:25.459 
或應用它們的API
一般將程序塊作爲它們的回調

00:30:26.660 --> 00:30:29.129 
僅在一線程完全空閒時

00:30:29.196 --> 00:30:30.964 
串行隊列的自動釋放池纔會出現

00:30:31.732 --> 00:30:34.835 
如果你的應用在持續忙碌中
自動釋放池將絕不會出現

00:30:35.602 --> 00:30:38.939 
所以當你用調度時 不依賴於

00:30:39.006 --> 00:30:40.807 
免費的自動釋放池是很重要的

00:30:41.208 --> 00:30:43.243 
如果你要自動釋放大量的項目

00:30:43.310 --> 00:30:45.412 
你需確保你的自動釋放池是合適的

00:30:46.180 --> 00:30:50.117 
最後串行隊列不是一個重入鎖

00:30:50.684 --> 00:30:52.119 
或遞歸鎖結構

00:30:53.053 --> 00:30:55.756 
你需要確保當你設計你應用的隊列時

00:30:55.956 --> 00:30:57.157 
不要使自己陷入需重入地

00:30:57.224 --> 00:30:58.325 
使用它們的情況

00:30:59.326 --> 00:31:01.895 
這些規則被捆綁在一起 其意義在於

00:31:01.962 --> 00:31:05.165 
主線程的運行循環也作爲主隊列被公開

00:31:05.632 --> 00:31:09.203 
相對於主線程
在這些領域間來回跳轉

00:31:09.269 --> 00:31:10.604 
是非常容易的

00:31:12.439 --> 00:31:14.274 
所以如果你回到計時器那個例子

00:31:14.341 --> 00:31:16.210 
我們是有點在比較不同的API

00:31:16.310 --> 00:31:17.945 
說到運行循環 我們有

00:31:18.011 --> 00:31:21.215 
NSObjects—在Delay後
運行Selector和Object

00:31:21.281 --> 00:31:23.917 
或NSTimer—安排TimerW
ithTimeInterval

00:31:23.984 --> 00:31:26.420 
可在當前運行循環上安裝計時器

00:31:26.753 --> 00:31:29.556 
在調度領域我們有
dispatchafter和

00:31:29.623 --> 00:31:32.860 
dispatch sources
用其設置計時器

00:31:32.926 --> 00:31:35.929 
這樣就創建一個通過隊列上加入程序塊

00:31:35.996 --> 00:31:37.965 
就可激活的計時器

00:31:40.501 --> 00:31:44.972 
我提到過GDC利用臨時線程

00:31:45.739 --> 00:31:48.041 
現在讓我說明一下它是如何運作的

00:31:48.442 --> 00:31:51.879 
想象一下我正在做大量的異步調度

00:31:53.347 --> 00:31:55.749 
我將那些放入全局隊列

00:31:57.918 --> 00:32:00.587 
系統正從線程池中取出一個線程

00:32:00.654 --> 00:32:02.022 
並將它分配給第一個程序塊

00:32:02.322 --> 00:32:03.624 
使其按自己的方式運行

00:32:04.091 --> 00:32:05.826 
取出另一個線程給第二個程序塊

00:32:05.893 --> 00:32:07.361 
並使其按自己的方式運行

00:32:07.895 --> 00:32:09.563 
這樣我們就有一個兩核設備

00:32:09.997 --> 00:32:12.266 
這些線程在同時運行

00:32:12.366 --> 00:32:13.534 
我們先停在這裏

00:32:13.600 --> 00:32:17.137 
理想情況下每核有一個線程

00:32:17.771 --> 00:32:20.274 
當第一個程序塊結束執行時

00:32:20.340 --> 00:32:23.443 
我們將取出線程
分配給下一個以此類推

00:32:24.478 --> 00:32:25.879 
這樣運作非常好

00:32:25.946 --> 00:32:29.716 
直到我們程序中的某個需要訪問

00:32:29.783 --> 00:32:30.984 
現在還不可獲得的資源

00:32:32.352 --> 00:32:33.687 
我們把這叫做等待

00:32:33.754 --> 00:32:37.024 
線程將等待並暫緩執行

00:32:37.090 --> 00:32:40.427 
當它需要像是I/O或鎖定資源時

00:32:41.195 --> 00:32:43.664 
你或許聽說過這個被稱作阻塞

00:32:43.764 --> 00:32:45.098 
但今天我們叫它等待

00:32:45.165 --> 00:32:49.403 
所以在接下來的五分鐘
如果談論程序塊阻塞你會覺得非常困惑

00:32:49.469 --> 00:32:52.472 
但在許多其它的情況下 你會聽到它被
稱作阻塞

00:32:54.007 --> 00:32:56.643 
從GCD的角度看這裏非常有趣的是

00:32:56.710 --> 00:33:02.583 
我們想要設備上
每核的程序塊或是線程都在主動地執行

00:33:03.083 --> 00:33:06.420 
所以當一線程等待時
我們將提出線程池中的另一個線程

00:33:06.486 --> 00:33:08.822 
直到受到限制

00:33:09.623 --> 00:33:11.758 
這樣就有每核都有一個線程在運行

00:33:13.727 --> 00:33:15.829 
來想象一下我們有四個這樣的程序塊

00:33:15.896 --> 00:33:18.365 
正在兩個不同的線程上執行前兩個

00:33:19.233 --> 00:33:22.402 
前一個說：嘿 我需要執行I/O

00:33:22.970 --> 00:33:24.872 
我們說：好我們將發佈I/O到磁盤上

00:33:25.272 --> 00:33:29.910 
但之後我們必須等待I/O迴歸返回 

00:33:30.177 --> 00:33:31.778 
然後纔可提出另一個線程

00:33:31.845 --> 00:33:35.816 
執行下一個程序塊等等 當線程等待時

00:33:35.883 --> 00:33:39.119 
當仍有工作需要被做時
找另一線程來執行隊列上的下一程序塊

00:33:40.487 --> 00:33:44.191 
這裏的問題是：
如果僅有四個程序塊時運行沒有問題

00:33:44.258 --> 00:33:48.161 
如果我有許多程序塊且它們都想等待

00:33:48.562 --> 00:33:50.330 
我們就會遇到線程激增

00:33:51.965 --> 00:33:54.001 
當然這就會有點低效

00:33:54.067 --> 00:33:56.637 
有大量的線程都在佔用資源

00:33:57.337 --> 00:33:59.106 
如果它們同時停止等待

00:33:59.173 --> 00:34:00.507 
就會有大量的資源衝突

00:34:01.708 --> 00:34:03.977 
所以這對性能來說是非常不好的

00:34:04.745 --> 00:34:05.979 
同時它也有一點危險性

00:34:06.046 --> 00:34:08.514 
因爲這對可提出的程序數量有所限制

00:34:08.581 --> 00:34:11.851 
當我們耗盡極限時對於新的工作

00:34:11.918 --> 00:34:13.219 
我們該怎麼辦？

00:34:13.754 --> 00:34:15.222 
這就導致了死鎖

00:34:16.623 --> 00:34:22.262 
我想舉一個死鎖的例子 是在
我們的一個內部應用程序裏碰到的

00:34:22.862 --> 00:34:25.799 
這個例子有點複雜但
我希望我能一步步給你解釋 因爲

00:34:26.400 --> 00:34:28.034 
此例很好的說明 應用程序不同部分間

00:34:28.101 --> 00:34:30.670 
是如何以一種意料外的方式互動的

00:34:33.172 --> 00:34:37.244 
我們有主線程
並且主線程有大量的工作需要去做

00:34:37.811 --> 00:34:41.014 
它會異步調度大批程序塊

00:34:41.081 --> 00:34:42.416 
到某一併發隊列

00:34:42.815 --> 00:34:45.518 
我們爲這些程序塊提出線程

00:34:45.719 --> 00:34:47.353 
這些程序塊立即轉向

00:34:47.420 --> 00:34:49.422 
同步調度回主線程

00:34:50.357 --> 00:34:52.059 
這時我們已經提出了

00:34:52.125 --> 00:34:53.393 
我們需要的所有線程

00:34:53.493 --> 00:34:55.429 
在這裏的這個簡單例子中 是四個

00:34:55.963 --> 00:34:57.264 
我們達到了線程限制

00:34:57.865 --> 00:35:00.734 
我們將不能
再爲線程池提出任何更多的線程

00:35:03.403 --> 00:35:07.074 
那麼 好的
我們需要主線程再次變成可使用的

00:35:07.140 --> 00:35:09.076 
以使那些程序塊可以獲取它

00:35:09.243 --> 00:35:11.345 
繼續運行 至完成

00:35:11.745 --> 00:35:13.247 
現在它使我們重新回到限制下

00:35:14.648 --> 00:35:17.117 
僅在某些情況下
這可能發生但是讓我們試想一下

00:35:17.818 --> 00:35:21.688 
主線程進入異步調度成爲某一串行信號

00:35:22.589 --> 00:35:24.024 
到目前爲止一切順利

00:35:24.091 --> 00:35:25.792 
那個程序塊仍不會開始執行

00:35:26.126 --> 00:35:28.195 
因爲沒有可利用的額外的主線程

00:35:28.262 --> 00:35:29.663 
來執行那個程序塊

00:35:29.730 --> 00:35:32.933 
它會呆在那裏 等待着某一線程返回

00:35:32.999 --> 00:35:34.334 
然後我們可將其再度利用

00:35:35.903 --> 00:35:38.405 
但是之後我們的主線程決定同步調度

00:35:38.472 --> 00:35:39.940 
成相同的串行隊列

00:35:41.208 --> 00:35:43.410 
問題是對於串行隊列

00:35:43.477 --> 00:35:44.511 
沒有可用的線程

00:35:44.745 --> 00:35:48.615 
主調用將永遠阻塞

00:35:48.682 --> 00:35:50.584 
這就是經典的死鎖情況

00:35:51.251 --> 00:35:53.020 
我們的主線程正在等待資源

00:35:53.687 --> 00:35:55.923 
在此案例中是我們線程池中的一個線程

00:35:55.989 --> 00:35:58.392 
所有來自線程池中的線程都在等待資源

00:35:58.458 --> 00:36:01.328 
主線程都在互相等待 但沒有一個會

00:36:01.395 --> 00:36:04.164 
放棄那個資源 所以導致了死鎖

00:36:05.132 --> 00:36:07.601 
這似乎非常匪夷所思不自然

00:36:07.801 --> 00:36:12.906 
但是當你的應用程序有許多不同的部分
不同的模塊同時運行的框架時

00:36:13.307 --> 00:36:15.108 
死鎖會比你想象中更容易碰到

00:36:15.909 --> 00:36:18.078 
並且實際情況中會更復雜

00:36:19.313 --> 00:36:21.014 
所以當你在用GCD時

00:36:21.081 --> 00:36:22.416 
這是你需要時刻銘記的

00:36:22.482 --> 00:36:24.818 
以保證你可以避免這種情況

00:36:25.085 --> 00:36:26.019 
這很容易做到

00:36:26.086 --> 00:36:29.122 
下面我會講一些可適當避免這個問題的

00:36:29.189 --> 00:36:30.657 
設計應用程序的方法

00:36:32.626 --> 00:36:34.294 
首先是一些基礎的東西

00:36:34.361 --> 00:36:35.262 
在任何可能的情況下

00:36:35.329 --> 00:36:37.231 
儘可能利用異步API

00:36:37.297 --> 00:36:38.665 
尤其是對於I/O

00:36:39.299 --> 00:36:42.503 
如果你這樣做你可以避免程序塊等待

00:36:43.136 --> 00:36:45.272 
這樣你就不用提出更多的線程

00:36:45.339 --> 00:36:46.540 
更高效

00:36:48.008 --> 00:36:50.577 
對這類的情況 你也可以用串行隊列

00:36:50.644 --> 00:36:53.647 
如果調度所有此類工作到串行隊列上

00:36:53.714 --> 00:36:56.283 
我們就不會遇到線程激增

00:36:56.350 --> 00:36:58.285 
我們每次將僅執行一個程序塊

00:36:59.086 --> 00:37:01.955 
我並不是在告訴你們
串行化你們全部的應用程序

00:37:02.623 --> 00:37:05.459 
但是當你建立你的應用程序

00:37:05.526 --> 00:37:09.329 
並創建不同的隊列
在你的應用程序中處理不同的模塊時

00:37:09.763 --> 00:37:11.932 
除非你知道對特別的模塊你需要

00:37:11.999 --> 00:37:13.967 
平行運行某些東西

00:37:14.034 --> 00:37:16.303 
取而代之地爲達到你的性能目標

00:37:16.370 --> 00:37:18.539 
請考慮從串行隊列開始

00:37:19.239 --> 00:37:25.012 
在串行隊列上同時運行你應用程序中
的各部分從中你可獲得很多性能

00:37:25.078 --> 00:37:29.283 
之後你可以給出你應用程序的輪廓

00:37:29.349 --> 00:37:32.286 
看什麼地方需要額外的平行運行的性能

00:37:32.352 --> 00:37:34.821 
並對這些地方進行特別設計

00:37:34.888 --> 00:37:37.658 
以避免線程激增

00:37:38.859 --> 00:37:41.461 
當然你也可以用有併發限制的

00:37:41.528 --> 00:37:42.963 
NSOperation隊列

00:37:45.332 --> 00:37:47.634 
最後不要產生無限的工作

00:37:47.701 --> 00:37:51.705 
如果你可以按照
你需要的程序塊數量來約束你的工作

00:37:51.772 --> 00:37:52.906 
就會避免線程激增

00:37:54.441 --> 00:37:57.077 
讓我們來看看更具體的

00:37:57.477 --> 00:37:58.779 
在這是出現問題的實例代碼

00:38:00.047 --> 00:38:03.317 
第一個是我們混合異步和同步

00:38:04.651 --> 00:38:09.423 
如果我只是對某隊列進行同步調度
會非常的快

00:38:09.489 --> 00:38:11.291 
大體上是得到鎖

00:38:11.892 --> 00:38:14.761 
如果我進行異步調度也會非常的快

00:38:14.828 --> 00:38:16.230 
大體上是原子入隊

00:38:17.030 --> 00:38:19.700 
如果我有一個隊列且僅用兩個中的某個

00:38:19.766 --> 00:38:23.504 
其性能與這些基本體是非常相近的

00:38:24.771 --> 00:38:29.243 
如果我將這些混合異步到某隊列
並做同步調度

00:38:29.610 --> 00:38:32.379 
同步調度就必須等待一線程被建立

00:38:32.446 --> 00:38:35.315 
並執行那個程序塊
然後程序塊纔會被完成

00:38:36.049 --> 00:38:38.385 
現在我們多了創建線程的時間

00:38:38.452 --> 00:38:40.420 
但其實本來僅一個鎖就足夠了

00:38:41.121 --> 00:38:43.357 
混合這些基本體當然是安全的

00:38:43.824 --> 00:38:46.960 
但是當你設計應用程序的時候
想一下是否你真的需要這麼做

00:38:47.561 --> 00:38:50.264 
在主線程中混合它們的時候
需要特別的小心

00:38:53.967 --> 00:38:58.972 
現在下一個問題是我們嘗試一次調度許
多程序塊到某一併發隊列

00:39:00.007 --> 00:39:05.112 
如果你這麼做
在我們的這個情況中你只需

00:39:05.179 --> 00:39:06.880 
避開主線程嘗試繼續執行

00:39:07.347 --> 00:39:09.616 
但是試想一下
在你異步的地方做一些相似的事情

00:39:09.683 --> 00:39:10.784 
之後做一個同步屏障

00:39:11.485 --> 00:39:16.456 
任何一個都是危險的
因爲它將引起線程激增和死鎖

00:39:17.324 --> 00:39:19.893 
但是我們有一個基本體叫做調度使用

00:39:19.960 --> 00:39:23.864 
這兩段代碼對你來說基本上是一模一樣

00:39:23.931 --> 00:39:25.732 
從語義上來看

00:39:26.300 --> 00:39:28.502 
通過轉換爲調度應用 你通過GCD

00:39:28.569 --> 00:39:32.039 
來管理並行性和避免線程激增

00:39:36.143 --> 00:39:38.011 
當然你也可以用調度信號量

00:39:38.312 --> 00:39:41.348 
你們中的許多對用信號量作鎖非常熟悉

00:39:42.115 --> 00:39:44.918 
取而代之的是這裏
我們將信號量用做計數信號量

00:39:45.452 --> 00:39:47.788 
我們從對它進行初始化着手

00:39:47.855 --> 00:39:50.224 
通過使用我們想執行的併發任務數

00:39:50.290 --> 00:39:51.992 
比如說我們想要運行四個

00:39:53.360 --> 00:39:57.464 
每次我們的程序塊完成
它會向信號量發出信號

00:39:58.165 --> 00:40:01.268 
每次我們提交 我們需要等待信號量

00:40:02.269 --> 00:40:05.906 
結果是：提交線程將進行四次提交

00:40:05.973 --> 00:40:08.542 
之後阻塞那個信號量 直到

00:40:08.609 --> 00:40:10.978 
它們中的一個
可以完成併發信號給信號量

00:40:11.445 --> 00:40:13.313 
這個模式非常好 如果你的應用程序中

00:40:13.380 --> 00:40:15.115 
你可能在多個地點提交

00:40:15.182 --> 00:40:17.951 
某些東西像是調度應用是不合適的

00:40:23.090 --> 00:40:26.393 
希望這些幫助你們對線程激增有了解

00:40:26.460 --> 00:40:28.128 
並知道如何去避免它

00:40:28.195 --> 00:40:30.430 
我還想簡短地談一下崩潰報告

00:40:31.965 --> 00:40:33.800 
不幸的是
某些時候你們中的大多數都必須

00:40:33.867 --> 00:40:35.402 
處理一份崩潰報告

00:40:35.469 --> 00:40:37.004 
這裏有許多信息

00:40:37.437 --> 00:40:40.607 
如果你在用GCD就更是這樣

00:40:44.144 --> 00:40:46.513 
隨着你有更多的線程
就會有更多的東西需要被剖析

00:40:46.580 --> 00:40:47.881 
及理解到底是怎麼回事

00:40:49.783 --> 00:40:51.585 
所以我想介紹給你們一對堆棧

00:40:51.652 --> 00:40:53.720 
它們可以幫助你瞭解應用程序中

00:40:54.855 --> 00:40:57.090 
不同線程的作用

00:40:57.591 --> 00:40:59.092 
第一個是管理線程

00:41:00.360 --> 00:41:02.095 
你幾乎在所有使用GCD的應用程序中

00:41:02.162 --> 00:41:04.798 
都可以看到管理線程

00:41:04.865 --> 00:41:06.767 
它負責幫助進程調度來源

00:41:07.167 --> 00:41:10.070 
你會注意到調度管理線程是根框架

00:41:10.737 --> 00:41:12.105 
一般來說你可以忽略它

00:41:13.674 --> 00:41:15.375 
我們有空閒的GCD線程

00:41:16.009 --> 00:41:17.811 
這些是線程池裏空閒的線程

00:41:17.878 --> 00:41:20.614 
在堆棧的底部
你可以看到開始工作隊列線程

00:41:20.681 --> 00:41:22.583 
有跡象指出它是一個GCD線程

00:41:22.683 --> 00:41:25.252 
工作隊列當前返回指出它正在處在空閒

00:41:27.955 --> 00:41:30.057 
另一方面一個活躍的GCD線程仍將從

00:41:30.123 --> 00:41:32.960 
開始工作隊列線程開始 
但你會看到一些

00:41:33.026 --> 00:41:36.396 
調度客服端調用和
調度調用程序塊及釋放類的東西

00:41:36.763 --> 00:41:37.931 
跟隨着你的代碼

00:41:38.198 --> 00:41:41.735 
你也會看到當你創建隊列時
曾輸入的調度隊列名稱

00:41:41.802 --> 00:41:43.971 
給出描述性隊列名稱是非常重要的

00:41:46.740 --> 00:41:49.309 
當主線程空閒時 你會看到其列席在

00:41:49.376 --> 00:41:53.814 
虛擬信息陷阱 
CF運行循環端口及CF運行循環運行

00:41:54.548 --> 00:41:57.751 
你也會看到com.apple主線程

00:41:59.486 --> 00:42:02.055 
另一方面如果你的主線程是活躍的

00:42:02.122 --> 00:42:05.259 
由於主隊列GCD隊列
你可能會看到CF運行循環

00:42:05.325 --> 00:42:09.730 
正在服務主調度隊列—如果它是活躍的

00:42:10.664 --> 00:42:13.467 
並且在這種情況下有我們
正調出的NSBlock操作

00:42:14.701 --> 00:42:17.171 
當你不能依賴於事物不會改變

00:42:17.237 --> 00:42:19.907 
今天有些內部的細節我也會談及

00:42:19.973 --> 00:42:23.110 
爲了能給你一個崩潰報告的指南

00:42:23.710 --> 00:42:25.612 
希望能提供給你一些有用的信息

00:42:27.548 --> 00:42:31.318 
至此總結一下 記住一個有效的

00:42:31.385 --> 00:42:34.588 
有響應的應用程序必須接受不同的環境

00:42:34.655 --> 00:42:36.823 
不管是Watch還是Mac Pro

00:42:36.890 --> 00:42:40.527 
這些不同的平臺有各種各樣的可用資源

00:42:40.594 --> 00:42:43.163 
GCD是可以幫助你
合理管理它們的一種非常好的方式

00:42:44.331 --> 00:42:47.334 
QoS分類允許操作系統

00:42:47.401 --> 00:42:49.870 
以最有效的方式安排你的資源

00:42:51.505 --> 00:42:54.007 
所以你應該回家想想如何將QoS分類

00:42:54.074 --> 00:42:55.876 
整合進你的應用程序

00:42:55.943 --> 00:42:57.544 
及既存的GCD使用中

00:42:59.479 --> 00:43:02.149 
最後想一下應用程序是如何使用GCD

00:43:02.216 --> 00:43:03.317 
並嘗試避免線程激增

00:43:04.818 --> 00:43:05.886 
更多的信息 請查看

00:43:05.953 --> 00:43:10.691 
Mac和iOS應用程序併發程序指導
或能源效率指導

00:43:10.757 --> 00:43:13.360 
iOS應用程序的那個是這周剛出的

00:43:13.560 --> 00:43:19.266 
看看吧 它很棒
有開發者論壇和我們的宣傳員Paul

00:43:20.200 --> 00:43:21.668 
幾個相關的場次：

00:43:21.768 --> 00:43:26.473 
《獲得整日電池壽命》給出了更多關於

00:43:26.540 --> 00:43:27.741 
我提到的能源話題的信息

00:43:28.642 --> 00:43:31.778 
《爲多任務iOS9優化你的app》

00:43:32.913 --> 00:43:36.850 
《高級的NSOperations》
和在這之後的

00:43:37.184 --> 00:43:39.052 
《iOS及Watch OS性能》

00:43:39.119 --> 00:43:44.725 
如果那些你沒有看過 
我強烈的建議你去看一下 謝謝