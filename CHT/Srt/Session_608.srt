00:00:20.087 --> 00:00:25.926 
GameplayKit介紹

00:00:32.064 --> 00:00:33.767 
大家好 歡迎光臨

00:00:35.169 --> 00:00:37.871 
我的名字叫布魯諾·薩默
是Apple公司遊戲技術工程師

00:00:38.172 --> 00:00:39.573 
今天我非常高興

00:00:39.840 --> 00:00:43.210 
能爲您介紹GameplayKit

00:00:43.944 --> 00:00:46.880 
Apple公司第一個
專用的遊戲開發框架

00:00:48.916 --> 00:00:52.486 
我們有多種解決方案
可以處理製作遊戲的視覺部分

00:00:52.786 --> 00:00:55.722 
在像SpriteKit SceneKit
和Metal的平臺工具上

00:00:56.590 --> 00:00:59.426 
在遊戲開發難題中
遊戲設置是另一個非常重要的部分

00:01:01.028 --> 00:01:03.764 
事實證明 遊戲設置方面存在難題

00:01:04.131 --> 00:01:07.301 
像AI 尋路算法和自主運動這些工具

00:01:08.969 --> 00:01:11.705 
我們堅信不應當故步自封

00:01:12.573 --> 00:01:16.009 
應當鼓勵開發人員設計出更優秀的遊戲

00:01:17.678 --> 00:01:21.014 
我們希望你們能夠
更加專注爲生活帶來好點子

00:01:21.548 --> 00:01:24.117 
我們將挑起重擔在後端實現

00:01:26.486 --> 00:01:29.389 
所以開始製作GameplayKit時
我們的使命非常清晰

00:01:30.123 --> 00:01:33.760 
我們想要設計一個具有遊戲設置
且簡單功能強大的API解決方案

00:01:34.494 --> 00:01:39.933 
現在這就像普通的設計模式和架構
因此我們開始先講講遊戲語言

00:01:41.134 --> 00:01:45.973 
另外還有一些標準的遊戲算法
適用於多種多樣的遊戲類型

00:01:47.441 --> 00:01:50.644 
並且對我們很重要的是
這隔斷圖形和引擎的聯繫

00:01:50.744 --> 00:01:54.081 
因此雖然GameplayKit
與很多我講到的那些視覺框架分隔

00:01:54.681 --> 00:01:55.782 
它和其它框架運作得很好

00:01:56.049 --> 00:01:59.653 
它和SpriteKit SceneKit Metal
及更多的軟件也運作得很好

00:02:03.056 --> 00:02:06.693 
所以此時我們有GameplayKit
和七個GameplayKit的重要特性

00:02:07.261 --> 00:02:11.298 
並且這些組件可以說說是非常好
可用於構建你的遊戲對象和遊戲邏輯

00:02:12.499 --> 00:02:17.137 
狀態機描述了我們遊戲中的狀態化
和遊戲對象的各種狀態變化

00:02:18.438 --> 00:02:23.510 
主體是自主運動的實體
由現實行爲和目標控制

00:02:24.745 --> 00:02:28.682 
路徑找尋解決了導航圖形生成
和我們如何移動實體的問題

00:02:29.082 --> 00:02:30.984 
在遊戲世界的可通行區域中

00:02:31.919 --> 00:02:33.520 
我們也有一個極好的
MinMax AI解決方案

00:02:33.587 --> 00:02:36.823 
它是非常好的解決方法
讓反對計算機控制者看到了希望

00:02:38.392 --> 00:02:42.362 
有許多遊戲質量隨機源
和隨機分佈可以任意使用

00:02:42.863 --> 00:02:45.032 
最後我們有一個規則系統
也是個很好的途徑

00:02:45.098 --> 00:02:47.301 
對模擬謹慎和模糊邏輯很有用

00:02:49.303 --> 00:02:53.607 
今天還涉及到很多
讓我們繼續看看接着講實體和組件

00:02:55.843 --> 00:02:57.845 
我想要提幾個繼承的經典問題

00:02:58.846 --> 00:03:01.215 
從普通遊戲對象中得到的

00:03:01.648 --> 00:03:05.919 
此時我們有一個塔防遊戲
帶有簡單的彈塔和弓箭手類

00:03:07.254 --> 00:03:08.922 
這有一些共享的功能

00:03:09.723 --> 00:03:13.293 
我們有射擊 有移動
還有被攻擊的目標

00:03:14.561 --> 00:03:15.629 
讓我們以射擊爲例

00:03:15.963 --> 00:03:18.398 
我們想讓塔和弓箭手都能夠射擊

00:03:18.866 --> 00:03:20.200 
那麼我們在哪放置射擊功能呢

00:03:21.668 --> 00:03:25.272 
一種選擇可能是在塔和弓箭手類之間
簡單地複製並粘帖它

00:03:25.906 --> 00:03:28.542 
但現在在我的分享功能代碼中有兩個點

00:03:28.609 --> 00:03:30.544 
並且如果我想要更新這個功能

00:03:30.811 --> 00:03:32.412 
現在我也需要更新那兩個點

00:03:32.513 --> 00:03:35.883 
如果我只是更新一個
那麼會導致一些很奇怪的行爲

00:03:37.284 --> 00:03:40.287 
所以在我所描述的這種繼承模型中

00:03:40.687 --> 00:03:43.590 
我們的唯一正確的選擇就是
在樹狀圖中把分享功能往更高的層級放

00:03:43.657 --> 00:03:44.691 
此時我們有個射擊功能

00:03:44.758 --> 00:03:48.095 
可以將它置於遊戲對象類
或某些基於普通的類

00:03:49.296 --> 00:03:50.464 
現在這種方法的問題是

00:03:50.631 --> 00:03:53.634 
當我們在遊戲中獲得
越來越多的共享功能

00:03:53.867 --> 00:03:56.270 
我們不得不將它移到越來越高的層次

00:03:56.703 --> 00:03:59.106 
並且我們的基礎遊戲對象
變得根本不基礎了

00:03:59.706 --> 00:04:04.378 
他們變得很大 難以理解
並且很難維護 協作

00:04:05.846 --> 00:04:09.349 
讓我們看下怎麼樣
用實體和組件解決這個問題

00:04:10.651 --> 00:04:13.921 
你看我們仍然有三個對象
彈 塔 弓箭手

00:04:14.655 --> 00:04:18.158 
但現在取而代之的是有了功能
在繼承意義上

00:04:18.358 --> 00:04:21.394 
成爲移動者 成爲射手
成爲被擊中者

00:04:22.095 --> 00:04:24.498 
它們反而有這些對象
我們稱之爲組件

00:04:24.565 --> 00:04:27.000 
裏麪包含遊戲邏輯的個別元素

00:04:27.334 --> 00:04:29.770 
所以此時我們有移動組件
可以解決移動問題

00:04:29.937 --> 00:04:31.672 
有射擊組件可以解決射擊問題

00:04:32.105 --> 00:04:34.274 
還有目標組件
這表示可命中目標

00:04:36.944 --> 00:04:40.280 
所以我們獲得這些很好的小黑盒
具有特定功能鬆散結構的盒子

00:04:40.347 --> 00:04:43.150 
而不是與層次緊密結合的結構

00:04:46.486 --> 00:04:48.655 
所以我們現在看見的實體
和組件是的很好方法

00:04:48.722 --> 00:04:50.023 
可用於組織我們的遊戲邏輯

00:04:51.325 --> 00:04:52.759 
舉個例說他們很容易維護

00:04:52.826 --> 00:04:56.196 
因爲他們是極好的黑盒子
具有壓縮功能

00:04:56.330 --> 00:04:57.364 
他們傾向於更簡單

00:04:59.533 --> 00:05:01.969 
我們也可以讓實體
和組件進行良好的協作

00:05:02.135 --> 00:05:04.204 
現在我可以讓一個開發人員
在一個組件上操作

00:05:04.471 --> 00:05:06.573 
另一個開發人員
在另一個組件上操作

00:05:06.840 --> 00:05:10.344 
並且他們不一定需要知道
這些組件間的具體細節

00:05:12.279 --> 00:05:14.281 
我可以隨着複雜性的高低
得到很好的縮放比例

00:05:14.348 --> 00:05:18.685 
我的意思是 在那個類和繼承模型中
我的層級越來越寬 越高

00:05:18.752 --> 00:05:20.153 
隨着我的遊戲變得越複雜

00:05:20.554 --> 00:05:22.823 
有了實體和組件
它只是在寬度中變得更寬

00:05:23.490 --> 00:05:25.292 
而不再有其他變化

00:05:25.659 --> 00:05:26.827 
真的是個好工具

00:05:27.828 --> 00:05:29.396 
無論何時想在遊戲中製作個新實體

00:05:29.463 --> 00:05:31.198 
我只要簡單地看下可用的組件

00:05:31.598 --> 00:05:34.168 
選擇合適的或執行新的組件

00:05:35.669 --> 00:05:38.972 
有了實體和組件
我們可以輕易獲取動態行爲

00:05:39.673 --> 00:05:41.141 
讓我們回想塔防例子

00:05:41.208 --> 00:05:45.412 
我想要實現施放魔咒使弓箭手固定不動
這樣他們不再移動

00:05:46.346 --> 00:05:49.917 
一種典型的方法可能是
暫時刪除它的移動組件

00:05:50.384 --> 00:05:52.019 
間接地告訴遊戲剩下的部分

00:05:52.386 --> 00:05:53.520 
停止移動

00:05:53.620 --> 00:05:57.991 
並且在這裏還有其他的優勢
即不需要知道魔咒的細節

00:05:59.826 --> 00:06:01.295 
那麼讓我們繼續往下
看一下類

00:06:02.129 --> 00:06:03.430 
此時我們有GKEntity

00:06:03.797 --> 00:06:04.898 
這是基於實體的類

00:06:04.965 --> 00:06:07.334 
這是個簡單的組件集合

00:06:07.868 --> 00:06:10.871 
隨着實體功能改變

00:06:11.171 --> 00:06:13.407 
它可以動態增加和刪除組件

00:06:14.241 --> 00:06:17.144 
同時也讓我通過獨特類的類型
訪問現有的組件

00:06:18.378 --> 00:06:22.549 
當我在GKEntity上調用更新時
自身擁有的組件將自動更新

00:06:23.584 --> 00:06:27.888 
所以回想之前的例子 彈 塔 弓箭手
都隨着GKEntities而更新

00:06:31.592 --> 00:06:33.160 
現在講GKComponent類

00:06:33.227 --> 00:06:37.598 
現在當你要在遊戲中添加功能時
你可以把這編入子集

00:06:37.664 --> 00:06:39.066 
並且有多種方法可以實現

00:06:39.967 --> 00:06:43.270 
你的組件屬性成爲那些組件的狀態信息

00:06:43.904 --> 00:06:46.707 
所以你可以想象
射擊組件此時很可能有一個傷害屬性

00:06:46.940 --> 00:06:49.042 
描述了炮彈能造成多大的傷害

00:06:50.477 --> 00:06:53.046 
你也可以執行自定義選擇器
進行功能擴展

00:06:53.547 --> 00:06:55.782 
也可以告訴遊戲的剩餘部分
如何與組件進行通訊

00:06:56.783 --> 00:06:59.987 
同樣舉個例子 移動組件此時可能
有能移動到某位置的功能

00:07:00.187 --> 00:07:02.956 
你可以調用輸入或調用遊戲控制器代碼

00:07:04.191 --> 00:07:07.327 
正如我之前所提到的
組件是通過它實體更新實現自動更新

00:07:07.394 --> 00:07:11.465 
並且你可以隨意地在
updateWithDeltaTime中執行時間邏輯

00:07:14.968 --> 00:07:19.840 
因此你需要更好地控制命令
或控制組件的更新

00:07:20.240 --> 00:07:22.543 
爲此我們提供
GKComponentSystem

00:07:23.143 --> 00:07:25.612 
這是不同實體的組件集合

00:07:25.879 --> 00:07:29.149 
但他們都是同類的類型

00:07:29.616 --> 00:07:32.653 
並且在當更新命令對遊戲內部
起到重要作用的情況下調用

00:07:33.086 --> 00:07:35.322 
在更新移動代碼後
我可能想要更新AI

00:07:35.389 --> 00:07:39.359 
因爲我想讓我的AI
處理最新的位置信息

00:07:40.928 --> 00:07:45.599 
需要留意的是放置在組件系統中的組件
不會隨着實體更新而更新

00:07:45.832 --> 00:07:48.235 
而取決於在正確的時間
調用組件系統更新

00:07:48.402 --> 00:07:50.571 
以便更新所有的實體

00:07:51.538 --> 00:07:53.106 
所以再一次回想我們的例子

00:07:53.407 --> 00:07:57.811 
我們可能有一個移動系統
能夠移動遊戲中的組件

00:07:58.312 --> 00:08:01.448 
並且我可以用來
同步多種實體間的移動

00:08:04.651 --> 00:08:08.455 
最後我有一個代碼例子 看看如何使用
GameplayKit的實體和組件

00:08:09.156 --> 00:08:11.091 
你看下此處的上方
我將製作我的弓箭手實體

00:08:11.725 --> 00:08:14.428 
然後我將製作三個組件
構成一個弓箭手移動組件

00:08:14.761 --> 00:08:17.531 
射擊組件和目標組件

00:08:17.831 --> 00:08:19.233 
並且給我的弓箭手增加這些組件

00:08:20.534 --> 00:08:23.971 
然後我將製作談到的移動系統
進入移動組件的類

00:08:24.037 --> 00:08:26.673 
指示這個組件系統只處理移動組件

00:08:28.008 --> 00:08:30.310 
然後我將增加弓箭手的移動組件
到移動系統

00:08:30.544 --> 00:08:34.280 
然後繼續進行
弓箭手和移動系統準備就緒可以使用了

00:08:38.284 --> 00:08:39.586 
所以接下來是實體和組件

00:08:39.886 --> 00:08:41.655 
因此讓我們轉移到狀態機

00:08:43.789 --> 00:08:45.092 
此時我將講解其它例子

00:08:45.325 --> 00:08:47.895 
讓我們想象一些遊戲
遊戲中玩家被鬼魂追捕

00:08:48.395 --> 00:08:52.099 
有時他獲得力量加成
然後追趕並擊敗鬼魂

00:08:53.500 --> 00:08:57.037 
這有一個狀態機的例子
說明如何控制鬼魂的

00:08:58.071 --> 00:09:00.841 
此時你看 我們有四個鬼魂狀態

00:09:01.241 --> 00:09:02.976 
當鬼魂追逐玩家時可以逃跑

00:09:03.777 --> 00:09:05.445 
當玩家追逐鬼魂時可以被追趕

00:09:06.079 --> 00:09:08.582 
當鬼魂被抓住且被打敗時可以被擊敗

00:09:09.249 --> 00:09:13.220 
並且在擊敗後和復活前
有時候可以復位

00:09:14.621 --> 00:09:17.457 
現在重要的事情是
請注意只有一部分狀態轉換是有效的

00:09:18.292 --> 00:09:20.661 
你可以看到 我在追趕和逃跑之間轉換

00:09:20.794 --> 00:09:22.729 
根據我剛纔描述的這是合理的

00:09:22.963 --> 00:09:26.366 
有時候是鬼在追趕玩家
有時候是玩家在追趕鬼

00:09:27.534 --> 00:09:29.469 
當然只有在逃跑的時候會打敗鬼

00:09:29.536 --> 00:09:33.640 
這是玩家可以真正打敗鬼的唯一時刻
當獲得力量後就可以追趕鬼

00:09:34.675 --> 00:09:37.044 
然後復活再被打敗
這是同樣的道理

00:09:37.344 --> 00:09:39.246 
在我們重生之後
我們就開始追趕鬼

00:09:39.313 --> 00:09:40.247 
這是我們的初始狀態

00:09:40.314 --> 00:09:43.250 
當鬼重生之後
它們就變回追趕玩家

00:09:46.053 --> 00:09:48.522 
因此爲什麼說狀態機
對遊戲開發是如此重要

00:09:49.323 --> 00:09:52.359 
對於很多遊戲來說
這是遊戲設置元素的重要部分

00:09:53.160 --> 00:09:55.462 
許多常見的遊戲設置
元素都充滿了狀態

00:09:55.529 --> 00:09:58.966 
例如動畫製作AI UI 等級

00:10:00.434 --> 00:10:02.202 
想要在遊戲中賦予讓人物類角色以生命

00:10:02.269 --> 00:10:04.471 
毫無疑問地
開發者必須對狀態機非常熟悉

00:10:04.905 --> 00:10:06.273 
我們通常有個IdleAnimation

00:10:06.340 --> 00:10:08.709 
和MoveAnimation
及AttackAnimation

00:10:08.775 --> 00:10:10.344 
並在它們之間進行合理切換

00:10:12.379 --> 00:10:15.148 
因此由於這種模式
在我們的代碼中是很普遍的

00:10:15.816 --> 00:10:16.650 
我們會執行多次

00:10:16.950 --> 00:10:22.022 
與部分樣板文件一樣
採用個開關語句或者樹狀結構

00:10:23.557 --> 00:10:25.626 
是否有一些常見的方法

00:10:25.692 --> 00:10:28.662 
用於刪除樣板文件
添加一些可維護性

00:10:29.062 --> 00:10:32.566 
讓我們可以在整個遊戲中
從使用狀態和狀態機得益呢

00:10:33.700 --> 00:10:35.702 
這就是我們在
GameplayKit裏做的

00:10:35.769 --> 00:10:36.870 
讓我們來看看類

00:10:38.305 --> 00:10:39.773 
這裏我們有
GKStateMachine

00:10:39.840 --> 00:10:42.009 
這是你的總體目標限定狀態機

00:10:42.075 --> 00:10:45.946 
我的意思是說
任何給定的狀態均只有一個狀態

00:10:46.647 --> 00:10:49.049 
它擁有所有的狀態

00:10:50.250 --> 00:10:54.521 
你可以調用狀態機裏的
enterState進行狀態轉換

00:10:54.988 --> 00:10:59.560 
具體發生了什麼呢
如果轉換是有效的 它會檢查改變

00:11:00.260 --> 00:11:02.663 
它調用許多狀態目標的回調函數

00:11:02.729 --> 00:11:05.999 
退出狀態 進入狀態等

00:11:06.200 --> 00:11:08.368 
並更新狀態機裏的現有狀態

00:11:09.303 --> 00:11:11.939 
在那個鬼的例子中
我們可能有個GhostStateMachine

00:11:12.005 --> 00:11:14.208 
它將依次有四個狀態

00:11:17.578 --> 00:11:19.379 
這裏我們有
GKState抽象類

00:11:20.514 --> 00:11:23.617 
然後調用回調函數
執行狀態基礎邏輯

00:11:23.684 --> 00:11:25.786 
當你鍵入狀態的時候
我們給你一個進入回調函數

00:11:26.019 --> 00:11:27.921 
當你離開狀態時
我們給你個退出回調函數

00:11:28.121 --> 00:11:30.691 
當狀態機裏是現有狀態的時候
我們給你一個更新回調函數

00:11:30.891 --> 00:11:34.428 
正如我之前所提
它們會在何時的時間自動被狀態機調用

00:11:35.762 --> 00:11:38.165 
你可以選擇性地重寫
isValidNextState功能

00:11:38.232 --> 00:11:41.735 
從而控制狀態圖邊緣
就是那些我說的有效轉換

00:11:42.436 --> 00:11:44.471 
現在通過默認值
所有這些邊緣都是有效的

00:11:44.538 --> 00:11:49.776 
但毫無疑問的是你想要調用
狀態的內部動態決定哪個轉換是有效的

00:11:51.144 --> 00:11:54.281 
我們討論的四個鬼狀態
追趕 被打敗 逃跑 重生

00:11:54.581 --> 00:11:56.250 
全部會隨着GKState被執行

00:11:58.886 --> 00:12:00.888 
因此我想要在這裏通過一個例子
結束這個問題

00:12:01.321 --> 00:12:04.024 
讓我們執行剛剛討論的
GhostStateMachine

00:12:04.191 --> 00:12:06.326 
一開始我要說說我的四個狀態

00:12:06.660 --> 00:12:09.062 
追趕 逃跑 被打敗以及重生

00:12:10.430 --> 00:12:12.966 
然後我將使我的狀態機
經歷這四種狀態

00:12:13.033 --> 00:12:15.269 
這四種狀態是狀態機裏有的狀態

00:12:16.637 --> 00:12:19.740 
然後我將繼續並在例子中
進入追趕的初始狀態

00:12:20.040 --> 00:12:22.342 
我們開始這個狀態機
它已爲我們的遊戲做好了準備

00:12:22.409 --> 00:12:24.444 
並且鬼將做我們希望它做的

00:12:28.048 --> 00:12:28.982 
這就是狀態機

00:12:29.983 --> 00:12:32.319 
讓我們轉向主體 目標和行爲

00:12:33.987 --> 00:12:35.789 
在我們開始之前先說一些概念

00:12:37.591 --> 00:12:39.626 
我們說的主體 目標和行爲

00:12:39.893 --> 00:12:41.962 
都是真正的自主移動實體

00:12:42.563 --> 00:12:45.432 
由現實的行爲和目標所控制

00:12:45.799 --> 00:12:50.170 
它們受制於許多客觀約束
如掩碼 加速度和慣性

00:12:51.805 --> 00:12:57.044 
控制這些主體的行爲反過來
組成一定的目標並附上適當的權重

00:12:57.277 --> 00:13:00.647 
從而在遊戲中
完成一些有意義的自主運動

00:13:03.984 --> 00:13:06.253 
因此爲什麼主體
在遊戲發展中如此重要

00:13:06.720 --> 00:13:10.657 
我想許多遊戲
都是以現實情況爲出發點

00:13:11.225 --> 00:13:13.026 
當我們的遊戲實體呈直線運動

00:13:13.293 --> 00:13:18.031 
然後再轉彎後撞上環境障礙物
這樣看起來就不是很真實

00:13:19.132 --> 00:13:20.934 
現實世界的運動有諸如慣性

00:13:21.335 --> 00:13:22.636 
質量和加速度這類的因素

00:13:23.136 --> 00:13:25.973 
這樣它就可以準確地
避開附近的障礙物和其它實體

00:13:27.274 --> 00:13:30.344 
當實體知道如何從點A到點B
它們通常跟隨一條路徑

00:13:30.410 --> 00:13:32.746 
並且路徑通常是筆直的而非曲折的

00:13:36.283 --> 00:13:38.619 
以上就是對主體系統的簡單概述

00:13:38.986 --> 00:13:41.722 
我們有主體類
由一個行爲控制

00:13:42.055 --> 00:13:44.892 
也有一個指派
讓你可以迴應 主體中的變化

00:13:46.193 --> 00:13:51.198 
這些行爲反過來組成一定的權重目標
從而實現有意義的功能

00:13:51.999 --> 00:13:57.104 
你可以設置許多目標
如尋找 攔截 避免障礙物及跟隨路徑

00:14:00.374 --> 00:14:01.842 
讓我們繼續看看類

00:14:02.609 --> 00:14:05.245 
GKAgent
是一個簡單的自主質點

00:14:05.679 --> 00:14:07.080 
也是個
GKComponent

00:14:07.247 --> 00:14:09.416 
和實體 組件系統配合得非常出色

00:14:10.184 --> 00:14:13.854 
當你在GKAgent上調用更新
它將應用當前行爲

00:14:13.987 --> 00:14:17.624 
具體的是查看組成行爲的目標

00:14:18.592 --> 00:14:25.465 
然後計算權重及所有必須的加速變化
從而達成目標

00:14:26.834 --> 00:14:28.602 
然後運用加速中的變化

00:14:29.169 --> 00:14:31.972 
改變主體速度和旋轉位置

00:14:33.440 --> 00:14:36.043 
正如我說的 現在GKAgent受制
於許多客觀約束

00:14:36.109 --> 00:14:39.646 
例如質量 反彈半徑
最大速度和最大加速度

00:14:40.514 --> 00:14:44.484 
很重要的是請注意
這些單元式無標度且只適用於遊戲世界

00:14:45.252 --> 00:14:49.056 
因此你可以想象以公里爲單位的遊戲
相對於英尺爲單位的遊戲

00:14:49.656 --> 00:14:51.124 
二者將有非常大的差異

00:14:51.825 --> 00:14:54.161 
因此要確保遊戲世界選擇合適的數值

00:14:56.797 --> 00:14:58.398 
這裏我們有GKBehavior類

00:14:58.465 --> 00:15:01.068 
它是一個像字典一樣的簡單目標容器

00:15:01.768 --> 00:15:05.606 
它讓你隨着遊戲
動態修改行爲

00:15:06.039 --> 00:15:09.910 
你可以添加新的行爲
添加新的目標

00:15:10.310 --> 00:15:13.447 
移動已有目標
改變已有目標的重量

00:15:14.381 --> 00:15:16.383 
正如我之前提過的
在主體設置了一個行爲

00:15:16.483 --> 00:15:17.484 
主體將很好地執行

00:15:17.584 --> 00:15:21.688 
下次你更新主體時
它將正確遵循該行爲

00:15:23.156 --> 00:15:26.326 
舉幾個關於行爲例子
可能你想執行羣集行爲

00:15:26.693 --> 00:15:28.662 
以模仿現實世界中鳥類的羣集

00:15:29.296 --> 00:15:32.065 
我們可以通過合適權重
將一個凝聚目標 一個分離目標

00:15:32.366 --> 00:15:33.834 
和一個匹配目標結合在一起

00:15:35.502 --> 00:15:38.872 
或者我可能正在做一個賽車遊戲
我想要做一個競賽行爲控制賽車

00:15:39.606 --> 00:15:41.475 
這就像結合跟隨路徑那樣簡單

00:15:41.542 --> 00:15:43.410 
我想要我的賽車跟隨賽道

00:15:44.011 --> 00:15:45.379 
避開其他主體目標

00:15:45.612 --> 00:15:48.382 
我想要我的賽車避免和其他賽車相撞

00:15:51.218 --> 00:15:53.453 
這代碼樣本看起來像室行爲代碼的樣子

00:15:54.221 --> 00:15:55.822 
看上面 我將創建尋找行爲

00:15:55.889 --> 00:15:58.058 
我想在我的環境裏找一些敵方的主體

00:15:59.426 --> 00:16:02.162 
我將創建一個迴避目標
用來避開附近的障礙

00:16:02.763 --> 00:16:07.100 
然後我將創建一個targetSpeed目標
我想要我的主體加速並達到目標速度

00:16:08.502 --> 00:16:12.840 
然後用一套合適的權重
讓我的行爲通過這三個目標

00:16:13.307 --> 00:16:15.209 
你可以看到我把迴避目標權重加到5

00:16:15.275 --> 00:16:18.111 
因爲我真的不想讓我的主體
撞到附近的障礙

00:16:19.479 --> 00:16:20.547 
然後我將創建我的主體

00:16:20.881 --> 00:16:22.950 
初始化 設置行爲

00:16:23.450 --> 00:16:24.418 
主體已經準備好了

00:16:24.484 --> 00:16:28.288 
下次我更新主體時
它將完全按照我的要求來做

00:16:31.325 --> 00:16:32.860 
現在來講講主體指派

00:16:33.694 --> 00:16:36.730 
在你需要使用基礎指派模仿

00:16:36.830 --> 00:16:39.266 
同步你的外觀
事物如圖形 動畫 物理時

00:16:39.600 --> 00:16:41.602 
GKAgentDelegate
就很有用了

00:16:42.503 --> 00:16:44.137 
我們提供兩個回調函數對其進行操作

00:16:44.338 --> 00:16:47.741 
在主體更新前
調用agentWillUpdate

00:16:48.408 --> 00:16:50.878 
在設備更新後
調用agentDidUpdate

00:16:52.012 --> 00:16:54.815 
在你的遊戲中
這或許就像是SpriteKit節點

00:16:55.215 --> 00:16:57.584 
或SceneKit節點 或渲染組件

00:16:59.987 --> 00:17:02.756 
我們來看看SpriteKit遊戲中
這個指派看起來像什麼

00:17:03.457 --> 00:17:06.292 
你可以看到這裏有個自定義圖形節點
MyAgentSpriteNode

00:17:06.627 --> 00:17:09.796 
我將繼續操作
並執行我剛說過的兩個回調函數

00:17:10.864 --> 00:17:13.901 
在agentWillUpdate中
我將在循環裏設置主體的位置

00:17:13.967 --> 00:17:15.801 
它們的節點位置一樣

00:17:15.969 --> 00:17:18.672 
我想讓基礎主體模仿和我的外觀相匹配

00:17:19.906 --> 00:17:21.108 
然後我將做一些更新

00:17:21.508 --> 00:17:23.743 
然後在agentDidUpdate中
做的事情剛好相反

00:17:23.810 --> 00:17:25.878 
我將在循環中設置節點位置

00:17:26.213 --> 00:17:30.384 
它的位置和循環中主體的位置一樣
外觀將和基本主體模擬相匹配

00:17:33.520 --> 00:17:34.821 
我將簡要的爲你展示一下

00:17:35.455 --> 00:17:38.492 
主體運動的樣子
和你可以自行處理的一些目標

00:17:49.203 --> 00:17:53.307 
有個簡單的SpriteKit情景
我們用一個圓圈裏的三角形來代表主體

00:17:53.674 --> 00:17:55.209 
他們按照三角形的指向調整方向

00:17:56.176 --> 00:17:57.377 
這裏我有一個座位目標

00:17:57.978 --> 00:18:00.714 
中間的主體會試圖尋找鼠標的位置

00:18:01.782 --> 00:18:03.784 
可以看到
移動看起來很流暢自然

00:18:03.884 --> 00:18:08.021 
因爲它是受真實物理約束
比如質量 加速度和慣性

00:18:14.061 --> 00:18:15.963 
這裏有個相反的事例 逃跑目標

00:18:16.063 --> 00:18:19.032 
主體試圖
逃離鼠標的位置

00:18:25.706 --> 00:18:27.140 
這是漫步行爲的事例

00:18:27.708 --> 00:18:31.678 
我的主體正在環境裏任意移動
任意左轉 右轉

00:18:40.020 --> 00:18:41.922 
這是一個障礙迴避目標事例

00:18:42.122 --> 00:18:44.191 
我的主體又在試圖
尋找鼠標的位置

00:18:44.258 --> 00:18:46.693 
但我在情景裏
增加了一些循環障礙物

00:18:47.060 --> 00:18:48.729 
主體的目標之一是迴避障礙

00:18:49.062 --> 00:18:53.500 
所以在他試圖尋找鼠標位置時
同時也在避免和障礙物相撞

00:19:02.843 --> 00:19:04.278 
這是一個分離目標事例

00:19:04.344 --> 00:19:07.080 
我有三個主體正在試圖尋找鼠標位置

00:19:07.347 --> 00:19:09.016 
但他們同時有一個分離目標

00:19:09.283 --> 00:19:11.752 
他們之間試圖保持最小距離

00:19:12.586 --> 00:19:17.257 
這對遊戲中編隊飛行或各組保持在一起
真的很有用

00:19:22.529 --> 00:19:24.131 
這裏有個對齊目標事例

00:19:24.565 --> 00:19:27.534 
右邊的主體試圖
與左邊主體的標籤相對齊

00:19:29.369 --> 00:19:32.539 
這對於在遊戲中同步單位
真的很有用

00:19:40.914 --> 00:19:42.449 
這裏有一個羣集目標事例

00:19:43.584 --> 00:19:46.486 
領導主體是在場景裏漫步的紅色

00:19:47.521 --> 00:19:50.224 
但是在一個羣集行爲裏
同樣還有一組藍色主體

00:19:50.290 --> 00:19:52.826 
它們結合了一個凝聚目標
一個分離目標 和一個陣營目標

00:19:53.026 --> 00:19:55.996 
形成了一個集體
同時試圖追逐領導實體

00:19:57.397 --> 00:20:00.133 
分離目標 維護他們之間的最小距離

00:20:00.334 --> 00:20:03.470 
凝聚目標讓它們
以結合塊的形式待在一起

00:20:03.804 --> 00:20:07.074 
而對齊目標想讓它們達到一個均等狀態

00:20:11.178 --> 00:20:14.147 
最後是一個跟隨路徑的事例

00:20:14.615 --> 00:20:17.451 
我的主體正試圖跟隨簡單的多線路徑

00:20:18.652 --> 00:20:21.555 
請注意它並不會突然轉彎

00:20:22.256 --> 00:20:25.859 
他正處於我們說過的真實物理約束下
比如質量和加速度

00:20:26.360 --> 00:20:30.898 
所以儘管基本路徑是固定的
但是主體會被迫以曲線的跟隨目標

00:20:37.804 --> 00:20:39.673 
以上就是主體 目標 和行爲

00:20:49.516 --> 00:20:50.817 
我們現在繼續來說說搜索路徑

00:20:53.187 --> 00:20:55.656 
我很確定
在遊戲開發中我們對此都很熟悉

00:20:56.256 --> 00:20:59.259 
在我的遊戲世界裏
有一些實體想從A點移到B點

00:20:59.593 --> 00:21:00.761 
但路徑中有一個障礙

00:21:01.995 --> 00:21:05.999 
我不想這些實體穿過障礙
我不想她碰到障礙

00:21:06.600 --> 00:21:09.870 
我想讓她像人類一樣
準確地找到路徑 繞過障礙

00:21:11.171 --> 00:21:13.740 
我正在尋找的是這些東西

00:21:13.874 --> 00:21:19.213 
我想讓她找到障礙周圍
最短的路線 越過障礙 繼續前往目標

00:21:21.215 --> 00:21:24.318 
我們調用遊戲設置搜索路徑

00:21:25.686 --> 00:21:27.221 
開始之前 說一些概念

00:21:28.288 --> 00:21:30.457 
導航圖上的路徑搜索操作

00:21:31.225 --> 00:21:35.863 
導航圖是一個節點集合
體現的是遊戲世界裏可通行的區域

00:21:36.096 --> 00:21:38.432 
允許實體呆着以及移動的地方

00:21:39.700 --> 00:21:44.771 
這些節點依次連接在一起
體現在可通行區域是如何移動的

00:21:45.639 --> 00:21:48.475 
這些連接可以是單向的
也可以是雙向的

00:21:49.610 --> 00:21:53.780 
在連接圖中
任何兩個節點之間總是存在最佳路徑

00:21:54.314 --> 00:21:56.850 
這是在路徑搜索中
我們通常會找到的路徑

00:21:58.986 --> 00:22:00.521 
我們繼續來看看類

00:22:01.989 --> 00:22:04.858 
我們有GKGraph
這是抽象圖基礎類

00:22:05.192 --> 00:22:09.663 
它僅是圖節點的容器
圖節點是遊戲世界裏可通行區域的描述

00:22:10.797 --> 00:22:15.068 
在遊戲世界有變動時
它有個功能可用來增加以及移除節點

00:22:15.769 --> 00:22:20.674 
它也可以讓我將新節點連接到圖上
與我希望的現有的節點做恰當的連接

00:22:22.075 --> 00:22:25.112 
當然我們也可以讓
你在節點和一個圖之間尋找路徑

00:22:26.113 --> 00:22:28.015 
我們提供兩個專門化

00:22:28.482 --> 00:22:31.952 
一個是GKGraph和網格配合使用
一個是GKGraph和障礙配合使用

00:22:32.252 --> 00:22:33.720 
我們現在來看下這兩個東西

00:22:36.156 --> 00:22:37.291 
GKGridGraph

00:22:37.357 --> 00:22:39.893 
這是GK圖
2D網格專用的

00:22:40.227 --> 00:22:43.830 
它所做的是自動創建所有節點
用來代表格框

00:22:44.565 --> 00:22:46.667 
既定的初始位置
網格 寬度網格以及高度網格

00:22:47.835 --> 00:22:51.004 
它將在網格節點間
自動創建基本連接

00:22:51.371 --> 00:22:53.073 
同樣在在對角線之間
隨意創建基本連接

00:22:53.640 --> 00:22:56.977 
它也有很簡單的功能
在你的遊戲中

00:22:57.044 --> 00:23:00.514 
網格空間變得不可通行時
可對其進行增加以及移除

00:23:03.016 --> 00:23:05.118 
接下來我們講
GKObstacleGraph

00:23:05.185 --> 00:23:09.423 
這是GK圖
遊戲世界中 障礙周圍路徑搜索專用

00:23:09.690 --> 00:23:12.192 
障礙可以是任意的多邊形

00:23:13.560 --> 00:23:18.699 
我們提供一些在遊戲世界變化時
不斷地增加以及移除障礙的功能

00:23:19.233 --> 00:23:21.602 
它也可以讓你不斷地
將新節點連接到圖上

00:23:21.668 --> 00:23:27.641 
對於爲一個單位尋找路徑而在圖中插入
一個開始以及結束節點來說很有用

00:23:28.976 --> 00:23:30.811 
我們通過一個緩衝區半徑實現

00:23:30.878 --> 00:23:32.913 
這是障礙周圍的安全地帶

00:23:33.146 --> 00:23:34.648 
這裏我的實體是進不去的

00:23:34.815 --> 00:23:36.583 
它通常是由遊戲來決定大小

00:23:36.850 --> 00:23:40.220 
與我想要做導航的實體邊界框半徑有關

00:23:41.388 --> 00:23:44.291 
我們來說說
這些障礙圖是如何被創建的

00:23:45.058 --> 00:23:47.661 
這裏是一個簡單的情景
有兩個方形障礙

00:23:48.395 --> 00:23:52.032 
左下角的一個實體
想要到達右下角的橋上

00:23:52.766 --> 00:23:55.302 
我的實體受一些邊界框半徑約束

00:23:56.503 --> 00:24:00.307 
我們將它當做緩衝區半徑
人爲增大障礙

00:24:01.642 --> 00:24:06.513 
高級選項下
障礙圖將在網格節點間創建合適的連接

00:24:07.447 --> 00:24:11.818 
它將不會創建違反障礙空間性的連接

00:24:12.219 --> 00:24:14.922 
從這裏可以看到
我們找到了最短的路徑了

00:24:15.122 --> 00:24:16.990 
它將不會和障礙相撞

00:24:22.663 --> 00:24:25.065 
這是最後示例的代碼

00:24:25.232 --> 00:24:26.500 
但這個示例中只有一個障礙

00:24:26.900 --> 00:24:30.671 
在頂端我將創建一個
只有四個點的簡單多邊形障礙

00:24:31.972 --> 00:24:35.843 
我將創建障礙圖進入障礙
以及一些緩衝區半徑

00:24:37.377 --> 00:24:38.879 
然後我將創建一個開始和結束節點

00:24:39.179 --> 00:24:42.182 
一個是現在我的英雄所在地
另一個是她想去的地方

00:24:43.750 --> 00:24:48.488 
我不斷地將這些節點
連接到我的障礙圖上

00:24:48.722 --> 00:24:53.427 
它將做的是將這些節點插到圖中
並再一次自動創建合理的連接

00:24:53.760 --> 00:24:57.097 
但它並不創建那些
會違反障礙空間性的節點

00:24:58.832 --> 00:25:01.335 
最後我爲開始和結束節點尋找一個路徑

00:25:01.435 --> 00:25:03.704 
我取回一個簡單的
圖節點NSArray

00:25:03.770 --> 00:25:06.974 
我可以用它來激活角色

00:25:10.744 --> 00:25:13.547 
GKGraphNode
是圖節點類的先進節點

00:25:13.914 --> 00:25:15.916 
毫無疑問
你會想對其進行劃分子類

00:25:15.983 --> 00:25:21.388 
在你執行高級或非空間操作
或在需要精確控制路徑搜索時

00:25:22.890 --> 00:25:24.491 
將非常好用

00:25:25.259 --> 00:25:27.628 
你可以設想一個擁有各種
版圖類型的戰略遊戲

00:25:27.694 --> 00:25:29.096 
或許你想要一個森林版圖類型

00:25:29.563 --> 00:25:31.732 
可以向其他版圖類型一樣做雙倍挪動

00:25:32.099 --> 00:25:34.234 
我需要考慮路徑搜索

00:25:34.301 --> 00:25:36.870 
我不想它返回可見的最短路徑

00:25:37.137 --> 00:25:39.306 
我只想它在森林周圍進行導航

00:25:39.706 --> 00:25:42.943 
因爲事實上
在我的遊戲世界裏這是最短的路徑

00:25:44.344 --> 00:25:47.281 
在你想手動創建自己的圖時
GKGraphNode同樣也很有用

00:25:47.381 --> 00:25:50.484 
你通過手動管理節點間的連接
手動創建自己的圖

00:25:50.918 --> 00:25:54.021 
對於一些像抽象或非空間圖的東西
這真的是好東西

00:25:54.454 --> 00:25:59.593 
或許你想要你的遊戲有個端口
想要單位讓這些端口爲路徑搜索負責

00:26:00.127 --> 00:26:02.729 
儘管這些端口在空間上並不相連

00:26:04.331 --> 00:26:07.835 
Grid/GraphNode和使用
障礙節點的GraphNode2D

00:26:07.901 --> 00:26:09.970 
正如你所看到的都很合適

00:26:13.273 --> 00:26:14.808 
對於這個特性
我真的很興奮

00:26:14.875 --> 00:26:16.810 
我們和SpriteKit組
配合做了一些工作

00:26:16.877 --> 00:26:19.346 
可讓你從現有的
SpriteKit Scenes中

00:26:19.413 --> 00:26:21.281 
很容易地創建這些障礙圖

00:26:21.782 --> 00:26:26.153 
你可以爲這些類似節點邊界
節點實體和節點材質的東西創建障礙圖

00:26:27.221 --> 00:26:28.922 
這個意思是說只要極少的代碼

00:26:28.989 --> 00:26:32.192 
你就可以獲得一個現有的SpriteKit場景
創建一個障礙圖

00:26:32.559 --> 00:26:34.394 
並動地在其周圍路徑搜索

00:26:35.996 --> 00:26:37.931 
現在我們爲你稍微展示一下

00:26:38.699 --> 00:26:40.567 
我們用SpriteKit來搜索路徑

00:26:52.246 --> 00:26:54.314 
這裏有一個我們講過的塔防遊戲

00:26:54.548 --> 00:26:56.416 
我們將它作爲
SpriteKit場景來執行

00:26:57.684 --> 00:27:00.787 
我在左邊創建實體
它們想移到右邊的橋上

00:27:01.522 --> 00:27:02.823 
因爲這是個塔防遊戲

00:27:02.890 --> 00:27:07.794 
我將在右邊放置一些塔
而這佔用了它們現在的路徑

00:27:07.928 --> 00:27:08.896 
我們繼續 放置一個

00:27:10.264 --> 00:27:12.432 
你將看到它們在它的周圍
正確地搜索路徑

00:27:12.499 --> 00:27:14.668 
那是因爲我們正在用剛講過的
SpriteKit集成

00:27:14.735 --> 00:27:17.271 
自動地從節點創建一個障礙

00:27:17.971 --> 00:27:19.873 
更基本的
GKObstacleGraph

00:27:20.040 --> 00:27:20.941 
以及更新我們的路徑

00:27:21.508 --> 00:27:23.677 
我們轉向調試程序
迅速的將塔移開

00:27:24.444 --> 00:27:27.247 
你可以看到從開始
和結束節點間的簡單路徑

00:27:28.015 --> 00:27:29.583 
當我在這裏插入一個障礙時

00:27:30.184 --> 00:27:32.719 
我們重新計算了基本的
GKObstacleGraph

00:27:33.020 --> 00:27:35.722 
這就允許我們的實體
在障礙周圍找一條新路徑

00:27:36.790 --> 00:27:38.091 
我們繼續增加一些東西

00:27:41.662 --> 00:27:45.666 
因爲有那個SpriteKit集成
每次我們增加或移除障礙時

00:27:46.133 --> 00:27:48.902 
基本GKObstacleGraph
總能進行更新

00:27:53.607 --> 00:27:55.609 
以上就是使用
SpriteKit的路徑搜索

00:28:04.852 --> 00:28:06.920 
現在有請我的同事蘿絲·德克斯特

00:28:07.087 --> 00:28:09.223 
爲我們講講MinMax AI

00:28:09.690 --> 00:28:10.524 
蘿絲

00:28:16.430 --> 00:28:17.264 
謝謝你 布魯諾

00:28:19.967 --> 00:28:24.771 
布魯諾剛講的很多特性
可以用來創建AI

00:28:25.739 --> 00:28:28.509 
但它們更多的是在你的遊戲中
給於實體生命

00:28:29.376 --> 00:28:34.181 
許多遊戲也需要同等的AI對手
用人類玩家同樣的規則來玩整個遊戲

00:28:34.248 --> 00:28:38.352 
這對於有些遊戲來說是很關鍵的
如象棋 西洋棋 一字棋等等

00:28:39.086 --> 00:28:40.821 
所以我們想爲你提供解決方案

00:28:42.122 --> 00:28:45.225 
我們選擇實現經典
AI解決方案MinMax

00:28:45.292 --> 00:28:47.194 
將它當做GameplayKit
關鍵部分

00:28:47.294 --> 00:28:50.130 
MinMax會查看
所有適合玩家的移動

00:28:50.397 --> 00:28:55.936 
然後它根據每個移動及每個移動
能產生的所有排列建立一個決策圖標

00:28:56.837 --> 00:29:00.374 
當你請求一個移動
它就搜索決策圖標最大化潛在收穫

00:29:00.641 --> 00:29:04.878 
同時最小化潛在損失

00:29:05.379 --> 00:29:06.847 
在這個一字棋事例中

00:29:07.281 --> 00:29:12.219 
AI爲X玩家選擇了右邊的一步
因爲是在最好的情況下 結果是勝利

00:29:12.486 --> 00:29:14.454 
在最差的情況下 結果是平局

00:29:14.821 --> 00:29:17.224 
其他兩個布則會導致失敗

00:29:19.960 --> 00:29:23.497 
MinMax AI給你
控制對手的能力

00:29:23.730 --> 00:29:27.601 
當人類玩家陷入困局時
它也可以爲人類玩家提供建議

00:29:27.868 --> 00:29:31.071 
這對於遊戲來說非常好
甚至都不需要其他的AI請求

00:29:32.272 --> 00:29:33.774 
它尤其適合以轉彎類的遊戲

00:29:33.841 --> 00:29:38.846 
但也同樣適合對於需要玩家
操作的不連續移動的遊戲

00:29:40.180 --> 00:29:46.787 
但你也可以通過改變對未來的預測程度
調整AI的難度

00:29:47.421 --> 00:29:48.889 
事先預測10步

00:29:48.956 --> 00:29:52.359 
當然要比事先
只預測2 3步要來的更有效

00:29:52.993 --> 00:29:57.531 
此外你可以隨意指揮它
任意挑選最不適宜的一步

00:29:57.598 --> 00:29:59.266 
給它一些類似人類的錯誤

00:30:00.834 --> 00:30:02.369 
我們來看看它如何整合到遊戲之中

00:30:03.337 --> 00:30:06.807 
MinMax非常棒的地方是
你不需要知道遊戲的任何細節

00:30:06.907 --> 00:30:10.511 
你不需要告訴它你的規則
它也不需要知道該如何執行

00:30:11.078 --> 00:30:12.312 
所有的這些都是抽象的

00:30:12.446 --> 00:30:15.349 
你所需做的只是提供遊戲中的玩家清單

00:30:15.883 --> 00:30:17.117 
他們可能會走的步

00:30:17.718 --> 00:30:21.922 
每個玩家的分數
用來顯示他們目前位置的相對強弱

00:30:23.257 --> 00:30:27.661 
當你向AI請求一步
它會考慮所有這些數據 創建決策圖標

00:30:27.794 --> 00:30:30.030 
返回一個最佳策略供你使用

00:30:33.667 --> 00:30:34.568 
我們來看看類

00:30:34.835 --> 00:30:38.572 
有三個所需的關鍵協議
以便與MinMax AI配合使用

00:30:38.805 --> 00:30:40.507 
第一個是GKGameModel

00:30:40.841 --> 00:30:42.876 
指的是對目前遊戲狀態進行抽象

00:30:44.811 --> 00:30:51.685 
比如你在創建一個象棋遊戲
執行該類的較佳的是板類

00:30:51.952 --> 00:30:55.822 
因爲它追蹤板上所有的位置
以及目前在玩的所有塊

00:30:56.557 --> 00:30:57.858 
正如我在前面的幻燈片提到的

00:30:58.158 --> 00:31:01.962 
所需做的是提供遊戲中活躍的玩家清單

00:31:02.229 --> 00:31:05.265 
目前的玩家
每個玩家的分數

00:31:05.499 --> 00:31:08.468 
然後是每個玩家可能會下的每一步

00:31:09.503 --> 00:31:11.538 
同樣也需要一個應用這些步的方法

00:31:11.972 --> 00:31:14.374 
AI用這個方法創建出決策圖標

00:31:14.441 --> 00:31:17.644 
在它已經被AI選中後
你也可以用它來應用每一步

00:31:18.178 --> 00:31:21.215 
當採用該步後
它將改變目前遊戲狀態

00:31:21.448 --> 00:31:23.784 
可能改變玩家目前的行動

00:31:24.218 --> 00:31:25.786 
每個玩家的分數

00:31:25.919 --> 00:31:26.954 
以及適合他們的下一步

00:31:28.455 --> 00:31:30.591 
接下來的協議是
GKGameModelUpdate

00:31:30.657 --> 00:31:32.526 
這是遊戲裏的動作抽象

00:31:33.260 --> 00:31:37.364 
它應該有你爲遊戲模型
應用每一步的全部數據

00:31:38.031 --> 00:31:41.201 
正如我們所說的
MinMax用它創建決策圖標

00:31:41.268 --> 00:31:44.137 
在它被選中後
你可以用它來做出下一步行動

00:31:45.272 --> 00:31:47.374 
最後是
GKGameModelPlayer

00:31:47.608 --> 00:31:49.443 
是遊戲玩家抽象

00:31:49.910 --> 00:31:53.180 
AI用它來區分不同玩家的行動

00:31:56.316 --> 00:31:59.720 
現在來說說AI
它屬於GKMinMaxStrategist類

00:32:00.120 --> 00:32:01.955 
在GKGameModel上運作

00:32:02.155 --> 00:32:04.558 
在你創建
MinMaxStrategist示例後

00:32:04.625 --> 00:32:06.527 
你將把它連接到
gameModel屬性中

00:32:07.995 --> 00:32:12.799 
當你從AI請求下一步時
maxLookAheadDepth就是能進行預測

00:32:13.734 --> 00:32:17.871 
正如我們前面提到的
較高的數字比較低的數字更有效

00:32:18.338 --> 00:32:19.806 
開始使用之前
這是你所需要做的

00:32:20.107 --> 00:32:23.744 
當你調用bestMoveForPlayer時
AI將創建它的決策圖標

00:32:24.244 --> 00:32:28.549 
按照從優到劣的順序列出所有適合的步
然後返回最優的步

00:32:29.249 --> 00:32:31.118 
這可能會出現在這些情況中

00:32:31.185 --> 00:32:33.153 
你有不止一個有利的步
需要由AI作出決定

00:32:33.587 --> 00:32:37.624 
以及這些情況中
你可以直接指揮AI隨機打破連接

00:32:38.692 --> 00:32:41.662 
若你想調用randomMoveForPlayer
它就會出現

00:32:42.095 --> 00:32:44.031 
你有10個適合玩家的移動

00:32:44.765 --> 00:32:48.335 
但你只想從3個最佳移動中
隨機挑選出一個

00:32:48.669 --> 00:32:52.573 
它將按照你的要求操作
從3個最佳中隨機挑選出一個

00:32:53.140 --> 00:32:54.875 
而選出的這個可能是次優的

00:32:54.942 --> 00:32:58.145 
如果你想要讓AI看起來
更人性化 會犯錯誤

00:32:58.212 --> 00:32:59.646 
這或許就是最令人滿意的結果了

00:33:01.215 --> 00:33:03.984 
bestMoveForPlayer
和randomMoveForPlayer

00:33:04.051 --> 00:33:05.319 
都返回GKGameModelUpdate

00:33:05.385 --> 00:33:09.823 
你可以將GKGameModelUpdate
應用到GKGameModel以創建一個移動

00:33:11.725 --> 00:33:13.193 
這是個簡單的代碼樣本

00:33:13.594 --> 00:33:15.796 
我正在創建象棋遊戲模型

00:33:16.129 --> 00:33:17.397 
不幸的是

00:33:17.764 --> 00:33:21.702 
審查你將如何執行遊戲模型細節
不在這個會話範圍裏

00:33:21.768 --> 00:33:23.670 
但我們有很棒的樣本代碼

00:33:23.971 --> 00:33:26.573 
你可以用來展示將如何做這些事

00:33:27.241 --> 00:33:28.442 
我們創建象棋模型

00:33:28.842 --> 00:33:31.912 
然後創建MinMax AI

00:33:32.112 --> 00:33:35.382 
通過在gameModel屬性上
設置遊戲模型將它聯繫起來

00:33:36.450 --> 00:33:38.452 
我們爲
LookAheadDepth選擇6

00:33:38.752 --> 00:33:41.488 
當你創建決策圖標時
你將提前看到6個轉彎

00:33:42.222 --> 00:33:43.123 
這就是我們所需做的

00:33:43.657 --> 00:33:46.560 
我們調用當前活躍玩家的
bestMoveForPlayer

00:33:46.660 --> 00:33:50.130 
它將利用所給信息
爲玩家找出最優移動

00:33:50.797 --> 00:33:53.367 
你可以在遊戲中應用那個移動
用它來創建移動

00:33:56.036 --> 00:33:57.137 
我們來看一個簡單的演示

00:34:12.652 --> 00:34:15.856 
有一個只有兩個玩家的簡單遊戲
黑色和白色

00:34:15.922 --> 00:34:19.860 
它們在棋盤上儘可能的收集
和它們同顏色的塊

00:34:20.494 --> 00:34:26.199 
當它們在棋盤上放置塊時

00:34:26.300 --> 00:34:28.936 
它們將反轉兩塊之間的屬於對手的塊
使之變成屬於己方顏色

00:34:30.304 --> 00:34:33.407 
我們有兩個AI控制的玩家

00:34:33.706 --> 00:34:35.943 
黑色玩家可提前預測5個移動

00:34:36.009 --> 00:34:38.579 
而白色玩家
只能提前預測3個移動

00:34:38.946 --> 00:34:43.583 
在遊戲過程中使得黑色玩家
可以很容易的打敗白色玩家

00:34:44.650 --> 00:34:47.855 
這裏你可以看到
有雙方玩家的分數

00:34:47.955 --> 00:34:49.156 
這個很簡單

00:34:49.422 --> 00:34:53.627 
我們來看一下玩家在棋盤上擁有的塊
減去對手在棋盤上的塊

00:34:54.061 --> 00:34:58.565 
再通權重碼進行調整
就得到分數了

00:34:59.066 --> 00:35:01.301 
這裏你可以看到
黑色玩家很容易就打敗了白色玩家

00:35:01.668 --> 00:35:06.073 
我們來詳細看下分數

00:35:07.007 --> 00:35:08.108 
看這裏

00:35:09.376 --> 00:35:11.879 
在中間的塊
他們的權重是1

00:35:12.112 --> 00:35:14.414 
棋盤邊緣位置
權重略高

00:35:14.481 --> 00:35:16.216 
在角落的權重就更高了

00:35:16.483 --> 00:35:19.052 
因爲對於玩家來說
這些位置更有利

00:35:19.286 --> 00:35:24.658 
我們通過改變這些位置如何影響分數
來指揮AI選擇這些地方

00:35:26.660 --> 00:35:29.196 
我來互換一下這些人的預測

00:35:29.263 --> 00:35:31.632 
白色將會預測4步
取代先前的預測3步

00:35:32.332 --> 00:35:38.138 
儘管只是小變動
這也會讓AI更有效率

00:35:38.205 --> 00:35:40.507 
事實上
遊戲中白色AI略佔上風

00:35:41.108 --> 00:35:44.745 
但是黑色AI將犧牲短期利益
換取長期勝利

00:35:45.112 --> 00:35:47.314 
這樣最後就可以戰勝白色

00:35:53.620 --> 00:35:54.821 
以上就是MinMax AI

00:36:03.197 --> 00:36:05.098 
現在讓我們來討論隨機源

00:36:06.133 --> 00:36:07.935 
起初這個話題可能看起來不必要

00:36:08.001 --> 00:36:10.771 
因爲我們已經有了隨機函數
爲什麼我們不能僅僅使用它就好呢

00:36:11.572 --> 00:36:12.973 
好的 隨機函數給我們隨機序號

00:36:13.040 --> 00:36:15.209 
但是遊戲有獨特的隨機序號需求

00:36:15.275 --> 00:36:18.178 
隨機函數可能無法給我們想要的一切

00:36:19.279 --> 00:36:22.716 
首先每個系統中由隨機函數生成的序號
可能是不相同的

00:36:22.783 --> 00:36:26.320 
不能保證不同的計算機平臺產生的
結果是相同的

00:36:27.154 --> 00:36:28.956 
這對網絡遊戲來說
會是一個大問題

00:36:29.022 --> 00:36:33.560 
因爲我們不能依靠任何一方
以相同順序生成的數據集合

00:36:33.627 --> 00:36:35.028 
否則爲了使兩方是數據同步

00:36:35.295 --> 00:36:36.463 
我們不得不浪費關鍵帶寬

00:36:37.231 --> 00:36:39.166 
因此我們需要平臺獨立性和確定性

00:36:40.200 --> 00:36:43.170 
無論我們什麼調用隨機函數
都取自單一來源

00:36:43.704 --> 00:36:46.473 
如果我對AI代碼中的隨機函數
有一串請求

00:36:46.840 --> 00:36:48.842 
然後我在我的物理代碼中添加一項請求

00:36:49.209 --> 00:36:54.281 
物理代碼中的這個請求就會影響
在我的AI代碼中生成的數字

00:36:54.448 --> 00:36:55.616 
這可能會導致意外行爲

00:36:55.916 --> 00:36:58.485 
我們真正想做的事情是
可以把這兩個系統分開

00:36:58.819 --> 00:37:03.657 
這樣兩個系統分別生成的數字
就不會互相影響

00:37:04.424 --> 00:37:08.295 
我們不僅想要控制生成的數字範圍

00:37:08.529 --> 00:37:11.131 
而且還要控制這些數字
在該範圍內是如何分佈的

00:37:11.331 --> 00:37:12.766 
這就是隨機源的由來

00:37:14.401 --> 00:37:17.504 
我們爲你提供一系列
具有確定性的遊戲優質隨機源

00:37:17.938 --> 00:37:20.874 
因此當你有同樣的種子時
你就可以獲取相同順序號

00:37:20.941 --> 00:37:22.009 
無論你在什麼平臺上

00:37:22.576 --> 00:37:25.179 
它們是可序列化的
因此它們可以爲你保存遊戲數據

00:37:25.412 --> 00:37:27.314 
這對阻止欺騙程序是非常實用的

00:37:28.448 --> 00:37:30.450 
人們用行業標準算法執行

00:37:30.517 --> 00:37:34.221 
衆所周知這些行業標準算法
具有可靠性和卓越的隨機性

00:37:35.255 --> 00:37:38.058 
此外我們爲你提供一套隨機分佈槓桿

00:37:38.492 --> 00:37:43.497 
這使你可以在給定的範圍內
控制序號的分佈

00:37:43.864 --> 00:37:47.134 
我們有一個真隨機
它的每個值都有同等的發生可能

00:37:47.601 --> 00:37:53.307 
高斯通過平均值
分佈中它的值以鐘形曲線分佈

00:37:53.807 --> 00:37:56.577 
而非邊緣值以及反聚類
或恰當的隨機分佈

00:37:56.810 --> 00:37:58.512 
這樣有助於消除運行的數據

00:37:59.146 --> 00:38:01.014 
最後我們有NSArray排列

00:38:01.348 --> 00:38:04.184 
對洗牌這類事情是超級實用的

00:38:05.285 --> 00:38:06.153 
讓我們來看看類

00:38:06.753 --> 00:38:09.556 
GKRandomSource
是隨機源的基礎類

00:38:09.823 --> 00:38:13.360 
採用NSSecureCoding
和NSCopying以便被安全地序列化

00:38:15.095 --> 00:38:17.631 
同樣的種子保證了確定性

00:38:17.798 --> 00:38:18.932 
無論你在哪個平臺上

00:38:18.999 --> 00:38:22.302 
因此如果你想要同樣的順序號
你可以依靠它生成

00:38:23.036 --> 00:38:27.274 
如果沒有種子
可以從安全的系統源獲取一個

00:38:28.108 --> 00:38:30.143 
我們繼續說說共享隨機

00:38:30.210 --> 00:38:32.546 
它是系統隱含的
共享隨機源

00:38:32.913 --> 00:38:36.183 
它不具有確定性
但是很多例子說明它值得擁有

00:38:36.483 --> 00:38:40.554 
例如你在洗牌的時候
你希望每個結果都是唯一的

00:38:42.322 --> 00:38:45.392 
讓我們看看
我們爲你提供的AI隨機源運算法

00:38:45.692 --> 00:38:46.560 
我們有ARC4

00:38:46.960 --> 00:38:51.398 
它低消耗並具有卓越的隨機性
並且它即將成爲你的Goldielocks隨機源

00:38:51.798 --> 00:38:55.169 
我們有線性
意味它比ARC4更低消耗

00:38:55.435 --> 00:39:00.274 
但它的隨機性並不那麼好
你可能會更頻繁地看見重複的順序號

00:39:00.774 --> 00:39:04.211 
最後我們有馬特賽特旋轉演算法
高質量但佔用大量內存

00:39:04.845 --> 00:39:06.580 
可以發現沒有一個適合密碼系統

00:39:06.647 --> 00:39:09.583 
但Apple提供其它單獨的
API來滿足這些需求

00:39:11.919 --> 00:39:13.320 
現在我們開始討論隨機分佈

00:39:13.387 --> 00:39:17.891 
在基礎類中GKRandomDistribution
執行一個純粹的隨機分佈

00:39:18.192 --> 00:39:23.163 
意味着每個在最低值和最高值之間的值
都有同等的發生可能性

00:39:23.897 --> 00:39:25.866 
你可以通過操縱nextInt

00:39:26.200 --> 00:39:28.068 
nextUniform
及rextBool來獲取數值

00:39:29.102 --> 00:39:34.675 
我們也提供一套骰子默認構造函數
用於創建6面 20面和自定義骰子

00:39:37.544 --> 00:39:39.279 
然後我們有
GKGaussianDistribution

00:39:39.346 --> 00:39:42.950 
來執行鐘形曲線高斯分佈

00:39:44.218 --> 00:39:49.590 
這些值偏向於均值
而距離均值較遠的值是不太可能發生

00:39:49.656 --> 00:39:51.525 
這就是在樣板分佈裏所發生的一切情況

00:39:52.226 --> 00:39:55.662 
我們已經生成了一個由1到5之間
數字組成的15位順序號

00:39:55.896 --> 00:39:59.933 
我們可以看到均值3發生的可能性
遠遠大於其他任意數

00:40:01.602 --> 00:40:04.304 
事實上和其它任何數字一樣
它發生兩次以上

00:40:04.371 --> 00:40:06.039 
邊緣數1和5

00:40:06.306 --> 00:40:07.641 
每個只發生一次

00:40:08.375 --> 00:40:11.378 
可以發現在一個
標準高斯分佈中它是無限的

00:40:11.745 --> 00:40:13.680 
但它不被隨機源需要

00:40:13.847 --> 00:40:18.085 
因此我們操縱每個均值
三個標準差之外的每個值

00:40:20.687 --> 00:40:21.688 
接下來我們看看

00:40:21.788 --> 00:40:25.826 
在GKShuffledDistribution類中
執行反聚類分佈

00:40:26.260 --> 00:40:31.265 
這是隨機分佈
有助於減少或消除運行的數字

00:40:31.498 --> 00:40:32.633 
但它隨着時間是隨機的

00:40:33.267 --> 00:40:35.636 
你運用
uniformDistance來控制這些

00:40:36.103 --> 00:40:40.007 
在0.0
所有數字都有同等的發生概率

00:40:40.274 --> 00:40:44.778 
這是無法從一個隨機分佈中
真隨機源中區分的

00:40:45.646 --> 00:40:47.281 
在1.0
所有值都是不同的

00:40:47.347 --> 00:40:50.884 
在你開始看到任何重複值之前
它會遍及範圍內的每個值

00:40:51.952 --> 00:40:53.954 
這就是在我們的分佈中的情況

00:40:54.021 --> 00:40:56.757 
再重複一下 我們生成了
由1-5之間的數字組成的15爲數值

00:40:57.124 --> 00:41:02.296 
在我們開始發現任何重複值之前
我們會命中每一個數值

00:41:03.330 --> 00:41:06.500 
實際上每個數值都生成了三次

00:41:09.069 --> 00:41:10.470 
讓我們來看一個簡單的代碼例子

00:41:11.905 --> 00:41:14.708 
我們可以很容易地創建一個
6面骰子隨機源

00:41:14.775 --> 00:41:18.245 
你僅需運用默認構建函數
GKRandomDistribution然後搖動骰子

00:41:18.712 --> 00:41:22.449 
如同調用nextInt一樣簡單

00:41:24.418 --> 00:41:26.587 
類似的
創建一個20面骰子也很容易

00:41:30.290 --> 00:41:33.393 
創建自定義骰子也同樣簡單

00:41:33.493 --> 00:41:35.095 
我們正創建一個256面骰子

00:41:35.162 --> 00:41:37.664 
如果你試着在現實世界中擲這樣的骰子
情況將完全不一樣

00:41:39.900 --> 00:41:44.238 
前面的三個例子
都運用真隨機分佈執行

00:41:44.304 --> 00:41:46.573 
但你可以使用我們提供給你的任何分佈

00:41:46.974 --> 00:41:49.877 
我們正使用高斯分佈

00:41:50.110 --> 00:41:52.246 
創建了一個20面骰子
因此它的均值大約是11

00:41:52.613 --> 00:41:55.115 
因此當你轉骰子的時候
你最有可能得到一個約值

00:41:57.251 --> 00:42:01.588 
在這裏我們創建一個20面骰子
使用洗牌分佈

00:42:02.689 --> 00:42:07.995 
在默認情況下
統一的洗牌分佈距離是1.0

00:42:08.228 --> 00:42:09.363 
因此當我們轉動的時候

00:42:09.696 --> 00:42:13.200 
在我們看見任何重複值之前
我們將擊中範圍內的每個值

00:42:13.400 --> 00:42:15.135 
我們第一次轉的時候可能得到了5

00:42:15.569 --> 00:42:18.705 
然後我們知道下一次我們轉動它的時候
我們一定不會再轉到5

00:42:18.939 --> 00:42:21.575 
直到我們轉出範圍內的其他所有值

00:42:23.710 --> 00:42:26.413 
最後我們有數組洗牌

00:42:27.047 --> 00:42:30.484 
我們運用早前在GKRandomSource
提到過的共享隨機源

00:42:30.551 --> 00:42:32.586 
它讓我們獲得系統隱含的隨機源

00:42:32.953 --> 00:42:34.788 
它不具有確定性

00:42:35.222 --> 00:42:37.858 
但在這個情況下是有利的

00:42:38.192 --> 00:42:41.461 
我們希望每一個卡鏟都是唯一的

00:42:42.296 --> 00:42:45.899 
你可以看到讓隨機源
成爲你遊戲的一部分是很容易的

00:42:46.333 --> 00:42:48.402 
僅僅是幾行代碼就可以實現

00:42:49.369 --> 00:42:50.437 
這就是隨機源

00:42:51.705 --> 00:42:54.908 
現在我想邀請橋什·伯格斯
和我們談談規則系統

00:43:01.615 --> 00:43:02.482 
謝謝 羅斯

00:43:07.054 --> 00:43:08.121 
你們好 我是橋什

00:43:08.755 --> 00:43:13.961 
我一直和布魯諾和諾斯並肩工作
進行GameplayKit收尾工作

00:43:15.863 --> 00:43:18.398 
我在這裏講講這些系統中的
一個規則系統

00:43:19.666 --> 00:43:23.871 
在我開始降解規則系統之前
我想要說說遊戲總有的一些常見要素

00:43:24.938 --> 00:43:26.707 
遊戲往往由三個元素組成

00:43:27.641 --> 00:43:32.713 
這像是名詞之類的東西
位置 速度 生命值

00:43:33.413 --> 00:43:34.448 
已經穿上身的裝備

00:43:36.049 --> 00:43:38.018 
第二是類似動詞的東西

00:43:38.819 --> 00:43:42.923 
這些玩家可執行的動作
例如跑 跳

00:43:43.757 --> 00:43:47.127 
使用一件物品
或者如果你在一輛車上 加速

00:43:48.662 --> 00:43:50.564 
最後是規則

00:43:51.632 --> 00:43:55.736 
規則是極其重要的
因爲要界定名詞和動詞是如何相互作用

00:43:57.171 --> 00:44:00.641 
規則給你的遊戲添加了質感
絕好的遊戲有絕好的規則

00:44:02.276 --> 00:44:03.510 
讓我們來看一個例子規則

00:44:07.047 --> 00:44:08.048 
在這裏我們有一項規則

00:44:08.215 --> 00:44:11.685 
司機可以用來決定什麼時候剎車
什麼時候加速

00:44:13.353 --> 00:44:14.988 
運用距離的輸入屬性

00:44:15.689 --> 00:44:17.558 
玩家要麼將減速 要麼將加速

00:44:18.926 --> 00:44:20.160 
在這個例子中我們可以看到

00:44:20.394 --> 00:44:22.896 
如果距離小於5 他們將剎車

00:44:23.096 --> 00:44:24.665 
當大於或等於的時候 他們將加速

00:44:26.667 --> 00:44:29.102 
這個邏輯很不錯
但這裏有一個不易察覺的問題

00:44:30.037 --> 00:44:33.774 
在距離爲5左右
我們的動作非常不穩定

00:44:34.174 --> 00:44:38.779 
因爲汽車將在剎車
和加速之間不斷徘徊

00:44:41.215 --> 00:44:42.983 
這將使我們的動作非常不穩定

00:44:43.317 --> 00:44:46.653 
因此想要更多自然的動作
我們需要一些更加真實的東西

00:44:50.757 --> 00:44:52.292 
運用一個更加模糊的解決方法

00:44:53.327 --> 00:44:58.232 
我們輸出的情況而不是立即執行動作

00:44:58.765 --> 00:45:01.268 
我們在這裏輸出了兩種情況 近和遠

00:45:01.635 --> 00:45:02.703 
兩者都是基於距離的

00:45:03.570 --> 00:45:05.539 
重要的事情是

00:45:07.374 --> 00:45:09.676 
現在你既可以是遠也可以是近

00:45:10.210 --> 00:45:11.745 
與其執行一個或另外一個

00:45:12.212 --> 00:45:14.982 
這讓我們把兩者融合在一起
獲得更加自然的動作

00:45:15.716 --> 00:45:20.454 
這對之前的例子尤爲重要
現在當距離在5左右

00:45:21.054 --> 00:45:23.924 
我們可以更加自然地加速

00:45:28.529 --> 00:45:30.063 
這就是規則系統的動機作用

00:45:30.931 --> 00:45:32.432 
事實是可以劃分等級的

00:45:32.633 --> 00:45:35.469 
這允許我們用模糊的邏輯
執行更加複雜的演算

00:45:37.437 --> 00:45:39.206 
模糊邏輯處理近似值

00:45:41.608 --> 00:45:44.444 
它也允許我們把
我們做什麼和我們如何做分開

00:45:45.479 --> 00:45:47.014 
而不是馬上執行動作

00:45:47.080 --> 00:45:51.585 
我們只是說明關於世界的情況
然後基於這些情況採取推遲操作

00:45:52.853 --> 00:45:54.254 
讓我們來看看這些類的其中之一

00:45:56.557 --> 00:45:57.691 
這裏我們有GKRule

00:45:59.126 --> 00:46:02.129 
GKRule包含
一個布爾預測和一個動作

00:46:03.830 --> 00:46:09.770 
預測與事實和系統狀態相匹配
如果預測爲真 將觸發動作

00:46:10.871 --> 00:46:15.442 
動作則如斷言事實那樣簡單
也可以如複雜塊一樣複雜

00:46:17.211 --> 00:46:19.413 
重要的是現在可以運用

00:46:21.081 --> 00:46:23.750 
NSPredicate序列化方法
進行序列化

00:46:28.288 --> 00:46:31.925 
重要的事情是記住
規則系統提供近似值答案

00:46:32.626 --> 00:46:34.761 
回答類似前面的車有多遠這樣的問題

00:46:35.762 --> 00:46:37.297 
在第一個例子中

00:46:37.764 --> 00:46:40.534 
我們可以相當自信認爲
我們還很遠

00:46:41.368 --> 00:46:43.403 
在其他兩個例子中
事情有點模糊

00:46:44.071 --> 00:46:47.541 
我們在做出答案後
真實情況是介於兩者之間的

00:46:50.110 --> 00:46:52.679 
讓我們來看看管理這些規則的系統

00:46:56.083 --> 00:46:58.252 
這裏我們有其它類
GKRuleSystem

00:46:59.786 --> 00:47:02.356 
它是規則和事實的有序集合

00:47:03.924 --> 00:47:07.594 
如要陳述世界事實
只需要進行調用即可

00:47:08.462 --> 00:47:09.897 
這將在序列中運行規則

00:47:10.464 --> 00:47:14.134 
這些規則將使用一個狀態字典作爲輸入

00:47:14.468 --> 00:47:16.770 
然後基於此插入事實

00:47:17.804 --> 00:47:19.640 
事實將輸入到事實序列

00:47:20.807 --> 00:47:23.310 
重要的是要了解陳述事實後

00:47:24.311 --> 00:47:27.514 
評價將返回到開端
然後繼續評價

00:47:28.582 --> 00:47:30.350 
這是因爲當你明確一個事實的時候

00:47:30.717 --> 00:47:32.352 
它可能會影響其它規則的運行

00:47:34.788 --> 00:47:39.927 
這可以確保當評價結束的時候
你可以有最簡明和精確的遊戲視圖

00:47:41.662 --> 00:47:42.696 
如要重新開始

00:47:42.763 --> 00:47:45.632 
比如在一個更新循環末尾或計時器上

00:47:46.033 --> 00:47:46.934 
只需調用重置

00:47:47.434 --> 00:47:50.704 
這樣你就可以重複評價

00:47:54.241 --> 00:47:55.409 
讓我們看一個代碼例子

00:47:56.910 --> 00:47:59.546 
在開始的時候
我們初始化規則系統

00:48:00.347 --> 00:48:04.451 
然後我們獲取狀態
並明確基於此的兩個事實

00:48:06.653 --> 00:48:09.423 
稍後在遊戲代碼中

00:48:09.823 --> 00:48:13.160 
我們抓取這兩種等級並求出兩者之和

00:48:13.660 --> 00:48:15.929 
來獲取關於我們可以加速多少
的模糊近似值

00:48:16.430 --> 00:48:17.664 
然後填入遊戲代碼中

00:48:22.135 --> 00:48:24.071 
看看我們正在做的一個小例子

00:48:43.557 --> 00:48:46.627 
我們在高速公路上開車

00:48:48.061 --> 00:48:51.865 
汽車在十字路口使用一套規則
而在高速公路上使用一套不同的規則

00:48:53.166 --> 00:48:56.803 
高速公路上使用的規則是基於
與前方車輛的距離

00:48:56.870 --> 00:48:58.872 
決定它們要加速多少或減速多少

00:48:59.973 --> 00:49:01.375 
它們明確世界的兩個事實

00:49:01.975 --> 00:49:04.611 
分別是距離和相對速度

00:49:05.979 --> 00:49:10.150 
車輛在十字路口使用另一套規則
明確誰有通行權的事實

00:49:13.120 --> 00:49:15.422 
現在綜合在一起的話

00:49:16.223 --> 00:49:20.561 
我們獲得非常複雜的仿真世界

00:49:21.728 --> 00:49:23.263 
這就是規則系統的力量

00:49:37.778 --> 00:49:40.147 
所以在我運用規則系統
作一些最佳實踐之前

00:49:40.914 --> 00:49:43.550 
很重要的是請記住
GKRuleSystem是孤立的

00:49:44.284 --> 00:49:46.787 
你必須使用狀態字典
作爲遊戲世界的快照

00:49:48.322 --> 00:49:52.392 
你同樣必須要運用許多簡單規則
並明確許多關於遊戲世界的事實

00:49:52.693 --> 00:49:54.561 
作爲對抗大型複雜規則以及少數事實

00:49:56.463 --> 00:49:58.532 
同樣重要的是
請注意事實是一些近似值

00:49:58.599 --> 00:50:00.701 
如何使用它們取決於你

00:50:01.635 --> 00:50:03.504 
事實的等級是系統的置信度

00:50:04.004 --> 00:50:07.908 
這允許我們使用模糊邏輯
來完成更復雜的推理

00:50:11.411 --> 00:50:14.147 
那樣 我想把這交回給我的同事布魯諾

00:50:20.487 --> 00:50:21.321 
謝謝 喬什

00:50:24.057 --> 00:50:25.425 
這就是GameplayKit

00:50:25.826 --> 00:50:28.629 
今天我們講了
GameplayKit裏的七個主要系統

00:50:29.162 --> 00:50:32.232 
實體和組件是構建
遊戲邏輯的好方法

00:50:33.066 --> 00:50:37.471 
狀態機處理遊戲中的狀態性
及我們的目標經歷的各種各樣狀態變化

00:50:39.139 --> 00:50:44.077 
主體即自主移動的實體
由真實行爲和目標控制

00:50:45.379 --> 00:50:49.383 
路徑搜索 處理導航圖的生成
以及找到我們遊戲世界中的路徑

00:50:50.751 --> 00:50:52.719 
我們也討論了MinMax AI解決方法

00:50:53.020 --> 00:50:55.255 
它讓計算機控制的對手
表現出生命力

00:50:56.256 --> 00:51:01.061 
同樣可以提供給你許多
隨機源和分佈

00:51:01.862 --> 00:51:06.834 
最後我們討論了規則系統
是用於描述謹慎和模糊邏輯的絕好方法

00:51:08.302 --> 00:51:10.370 
我們很期待發布GameplayKit

00:51:10.437 --> 00:51:12.406 
我們迫不及待地想看到你們會如何使用

00:51:15.943 --> 00:51:17.444 
一些很好的代碼例子本週發佈了

00:51:17.511 --> 00:51:20.247 
如果你想了解更多東西
你一定要看看

00:51:20.714 --> 00:51:24.818 
Demobot是一個SpriteKit遊戲
涵蓋了GameplayKit各種API

00:51:25.152 --> 00:51:28.055 
FourInARow是
實操MinMax AI的絕佳示例

00:51:28.255 --> 00:51:32.025 
AgentsCatalog表現
主體行爲和目標的好例子

00:51:32.226 --> 00:51:34.228 
因此如果你想學習
一定要看看

00:51:36.630 --> 00:51:40.100 
同樣還有一些環節
如果你想要了解更多相關技術

00:51:40.167 --> 00:51:43.604 
例如SpriteKit ReplayKit
Game Center SceneKit

00:51:44.104 --> 00:51:46.173 
今天午飯之後
有一個DemoBots的深入研究

00:51:46.240 --> 00:51:47.508 
就是我說到的那個例子

00:51:47.708 --> 00:51:50.844 
如果你想了解更多關於
GameplayKit或SpriteKit的資料

00:51:51.111 --> 00:51:51.945 
就一定要來看看

00:51:53.947 --> 00:51:56.884 
我們有實驗室
歡迎來遊戲控制器實驗室

00:51:57.184 --> 00:51:59.686 
今天午飯之後同樣
有個關於GameplayKit實驗

00:51:59.753 --> 00:52:03.924 
大家可以來會面成員 發問
討論任何關於代碼的問題

00:52:05.926 --> 00:52:09.162 
如果你需要更多信息
請登錄偉大的開發者網站

00:52:09.897 --> 00:52:13.834 
有任何一般詢問
聯繫我們的遊戲技術專員艾倫·沙菲爾

00:52:15.569 --> 00:52:17.871 
謝謝
會議中間請休息片刻