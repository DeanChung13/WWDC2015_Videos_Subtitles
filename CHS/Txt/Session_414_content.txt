在Swift中 如何使用数值类型来打造更好的app
大家好 我是道格·格雷戈尔
今天我和我的同事比尔·达德利
我们会讲讲在Swift中 如何使用数值类型来打造更好的app
首先我们来谈谈
引用语义 
然后我们会深入探讨下不变性 把它作为引用语义提出的某些问题的
解决方案
深入探讨数值语义、数值类型
尤其是它在Swift的工作原理数值类型在实践中的应用
然后探讨引用类型和数值类型
在Swift中的混合
让我们开始吧
引用语义
引用语义在Swift中就是用来定义一个类
这是一个很简单的温度组别
我们以摄氏度来存储我们的温度数值
想得到这个不错的计算华氏温度属性
这样我们可以始终以正确的单位得到它
温度的简单、抽象版本
让我们试着把它用到一些简单的代码上
我们创建一个家庭 实例再创建一个温度实例
把我们的恒温器设置成温和的七十五华氏摄氏度
现在我们来决定...晚餐时间快到了
我想烤一些鲑鱼肉
因此我把烤箱的温度设置成425度然后点击“烤制”
走开一点
为什么这里这么烫？出了什么事？
你知道发生了什么事我们实现的就是非有意的共享
想想对象图表
我们有自己的房子
里面有一个恒温器和烤箱
我们还有这个温度指向的温度对象
当我们设置我们的恒温器时
我们把它作为温度连接到相同的对象
事情看起来不错直到我们进行转变
现在这个非有意的或者意想不到的分享
让我们把我们的恒温器设置成了
四百二十五华氏摄氏度
此时已经玩完了
但是为了度量起见让我们把我们的恒温器连接到烤箱
因为我们已经搞砸了
那么我们做错了什么呢？
在这个有引用语义的世界里
你想要阻止分享 你就要进行复制
知道了吗？让我们来这样试试
好的 把温度设置成七十五
华氏摄氏度
当我设置我的恒温器的温度时我就会生成一个副本
我就得了一个全新的对象
我的恒温器的温度指向的也就是它
当我改变我的温度变量的温度时
并不会对它产生影响 很好
现在我来设置烤箱的温度
我又生成了一个副本
现在从技术上来讲我并不需要最后的这个副本
在堆上浪费时间分配内存创建这个另外的副本效率很低
但是这样更安全因为上次我错过了一个副本
结果把我烤熟了！
给点力吧 这是周五的会议让我喘口气吧
我们把这个称之为“保护性拷贝”
我们进行拷贝并不是因为
我们知道我们需要它 而是因为偶尔
或者过一段时间后需要用它
调试这些问题是相当困难的
无论我们什么时候
把一个温度指定到我们的烤箱某处忘记进行点拷贝太容易了
我要在我自己的烤箱中烤一烤这个行为
好 我完了 我完了 对不起 对不起
通常来说我需要给恒温器做同样的事
不是吗？
有了一大堆样本我们正在进行复制粘贴
你迟早会来敲我的门问我借
一项语言特征
我们先来谈复制Cocoa和Objective-C
在Cocoa有一个NSCopying协议的概念
它对复制的意义进行了编码
你有很多的数据类型这NSstring NSArray
NSURLRequest etcetera
这些都遵从NSCopying因为你需要安全地对它们
进行复制
我们的系统中需要大量的复制
因此你有足够的理由看到大量的“保护性拷贝”
NSDictionary会对你放到字典中的键进行保护性拷贝 为什么？
若要递给NSDictionary一个键 进行插入
然后又做了变更改变了它的hash值
打断NSDictionary内部变度
然后埋怨我们让你出了bug
这可不是我们想要的
想要的是在NSDictionary保护性拷贝
在这个系统中 这是正确的答案但是不幸的是
进行这些额外的复制会让我们损失性能
我们会把这些都弄到Objective-C
带有复制属性的语言层面
来对每个单一的赋值进行保护性拷贝
以此来避免这些问题 这确实有用
这个保护性拷贝确实有用
不过还不够好
你仍然会有一堆的bug
因此这些引用语义有问题
出现了变异
也许这里的问题不在于引用语义
而在于变异本身
也许应该移动到带有引用语义的不可变数据结构
如果你和函数式语言社区某个人谈一谈
他们会说 是的
几十年前我们就开始这么做了
它确实可以提高那里的情况
因此如果没有副效用你就不会出现非有意的副效用
不可变引用语义是一种在系统中工作的
一致的方法
它没有那些我们在我们的温度小示例中出现的意外后果
问题在于不变性也有不足
它可能导致不佳的界面
语言工作的方式就是 它的一部分
我们生活在一个我们可以让事情产生变异的世界中
这也是它的一部分 我们想到状态
变异的状态 因此单纯在一个
不可变的世界中进行思考有时候对我们来说
是比较怪的
有效映射到机器模型
也是问题
最后你还是不得不着手处理机器码
在一个有状态寄存器、状态缓存、
状态内存、
状态存储的CPU上运行
把一个不可变算法映射到那个层级效率并不总是那么容易
我们来讲一讲其中的几点
我们把我们的这个温度类拿出来
通过让它成为不可变的增加它的安全性
我们把摄氏度存储属性从一个var变成一个let 你不能再改了
然后华氏温标计算器属性的设值函数没有了
因此无论你做什么
你都不能再改变温度状态
为了方便起见我们添加一些初始化程序
好的 我们来谈谈不优美的...
不优美的不可变界面
要是我说我把我的烤箱温度调整
十华氏温度 这是一个简单的操作
加号就是十度 可以了 好了
如果我们把变化去掉我们又该怎么做？
我们就必须抓住烤箱的温度对象
创造另外一个有新值的温度对象
对吧？这就有点不太好看了代码更多
也浪费时间在堆上分配另一个对象
我们并没有在这里拥抱不变性
因为我们是做了一个使烤箱本身发生变化的赋值
如果我们在这里自始至终
拥抱不可变引用的概念
我们就可以创建一个新的温度放到一个新的烤箱中
然后放到一个新家中
不美观！让我们再搞点理论知识做一些数学题
埃拉托色尼选筛法是一种计算质数的古老的算法
它使用了变异 非常适合在地上用棍子
画出事情
这是Swift中变异版本的执行
我们来演示下以便你明白它背后的想法
你首先要做的是：创建一个阵列
注意var 因为我们要改变这个阵列
注意这个阵列来源于两个、三个质数
是从你计算的数字中求出来的
我们这里是二十
现在每次通过外层循环
我们就会选择阵列中的下一个数字
那个数字是一个质数P
内循环要做的就是走过P的所有倍数
把它们设为零将它们从阵列中抹除
如果是一个质数的倍数
那么你就不是质数
再回到外层循环
我们获取下一个数字 这是一个质数
我们从阵列中把它所有的倍数抹除
这是一个非常简单的算法
想想地上的棍子
你就是在把事情划掉
一旦我们迭代
完毕我们就到这里
进行最后一个简单的操作 也就是说
阵列中所有我们未归零的东西
就是我们的结果的一部分
我们用一个过滤器来处理它
算法非常简单 完全基于变异的
但不是不能在没有变异的
世界里表达它
你当然可以的
为此 我们要使用Haskell
因为它是一个单纯的函数式语言
是的 我知道大家都爱它 好的
这是Haskell的公式化
如果你读过Haskell 它很美
它是函数式的 它一点也不会发生变异
这是个类似执行它对Swift做了变动
因此也能是函数式的如果你想让它懒一点
对于读者来说这是一个练习
没有那么难
我们来演示下这个算法的工作原理
因为非常相似
我们的阵列就从二开始 直到二十
在这个简单的例子中 如果没有数字
那里没有质数
那是第一个“If语句”这是小事情
你要做的就是我们把第一个数字取出来
它就始终是质数
把它和其余的数字分割开来
Haskell通过模式匹配实现它
我们在这里可以分层
我们把那个质数拿出来在这个阵列其余的元素这里
运行一个过滤器操作
仅仅复制那些不是
那个质数的倍数的东西
现在我们递归 再来一次
把“三”拆分 这是我们的新质数
然后运行这个过滤器
把所有三的倍数消除等等
这里发生的
就是你以构建这个左斜 实际质数来结束
这样它们就都会连接在一起
理念是相似的
非常相似
但是算法不同
因为它的性能特征不同
这个结果来源于梅莉莎·欧内尔发表的
一篇绝妙的论文 她称之为“真实的埃拉托色尼筛选法”
她向Haskell社区展示了他们挚爱的筛选法
并不是真实的筛选法
因为它并不会作为真实的筛选法来运行
她仔细查看了Haskell中非常复杂的执行
那又回朔到了性能特征
读一下那篇论文 看一看 非常酷
我想让你们尝试下为什么会出现这种情况
看看这个Haskell列表推导
或者下面等价的Swift过滤器
在这个不变版本中这个操作会遍历阵列中的
每个单一元素
然后执行一个除运算看看下一步中
它是否还应该在那里看看它是否是P的倍数
在原始的变异算法中我们只会遍历质数的
倍数以及那些...当然了
随着你得到越来越大的数字 就会变得越来越稀疏
你访问的元素更少 此外
你只需要在到达下个元素进行一次加法
这样你每个元素所做的工作就更少了
这是有关系的
不变版本不像变异版本的效率那样高
后者无需做很多的功
我们再回到Cocoa
你看到了在Cocoa中使用不变性Cocoa Touch框架
它们有很多日期 Ui图片 NSNumber等
它们是不可变类型
有了这些不可变类型安全性就可以得到提高
这是件好事因为你就无需
担心复制了
你无需担心你的共享会产生非有意的副效用
但是当你用它工作时你也会看到缺点
在Objective-C中给自己一个小任务
我想从我的主目录开始通过添加逐次路径元件
获得某些目录的方式 来创建一个
NSURL
我想在引用语义世界中 无需变异
就可以实现这一点
因此我创建了一个NSURL
每次通过循环时 我就通过附加下一个
路径元件 来创建一个新的URL
这个算法并不是非常好 真的
每通过一次我就创建一个NSURL另一个对象
旧的对象就会消失然后NSURL就会在每次通过
循环时 复制所有的串式数据
那里的效率不是很高
道格 你按错了
你应该把所有的这些元件收集到一个NSArray
然后使用带路径元件的文件URL
就这样吧 不过要记住我们是在这里拥抱不变性
这样当我创建我的阵列时我会创建一个带有特定
对象的NSArray 好的
这是主目录
每次通过时我创建一个新的阵列
多加一个对象
我仍然是二次的
我仍然是在复制元素
我复制的不是串式数据
这样好一点
我仍然是在复制元素
这就是为什么我们不在Cocoa世界中完全拥抱
不变性的原因 因为这样说不通
而如果你在更加本地化的
地方使用易变性 就说得通了
把你所有的元件收集到一个NSMutable阵列
然后使用带路径元件的文件URL返回到那个
不可变NSURL
因此不变性是件好事
它让引用语义世界的推论更加容易了
但是你又不能完全选择不变性
否则你会疯掉
这样我们就到了数值语义
对于数值语义我们想采用一个不同的方法
我们喜欢变异
它很有价值 如果正确使用的话用起来很容易
问题在于正如我们看到的在于共享
你已经知道了数值语义的工作原理无论你是在
Objective-C中还是在Swift中你都应该始终用它
道理很简单：如果你有两个变量
从逻辑上来讲这些变量中的数值是不同的
我有一个整数A我把它复制到一个整数B
当然了它们是等价的 它是一个副本
我来改变B
如果我告诉你A也会变 你会说我疯了
这些是整数
它们在我们用过的
每种语言中都有数值语义
到CGPoint中举例来说
从A复制到B改变B 对A不会产生
任何影响
你已经习惯这一点了
如果CGPoint的行为不是这样
你肯定会大吃一惊
数值语义的理念就是把我们已经知道并且理解为
最基本类型的事物像数字以及包含数字的
小的结构把它向外扩展
让它能够兼容更多、更丰富的类型
在Swift中字符串属于数值类型
你创建了A从B复制到A然后对B做出某种改变
这不会对A产生任何影响
因为它是一个数值类型
A和B是不同的变量
因此从逻辑上来说它们是不同的
知道了吗？那么为什么阵列表现的方式也是一模一样呢
创建A复制到B 然后改变B
对A没有影响
它们是完全不同的值
最后一点是字典 当然了
它就是一个集合
你把数值语义放进去然后向你返回的
也是数值语义
这里很棒的一点是数值类型的构成非常漂亮
因此你就可以在数值语义的世界中非常容易地构建
非常丰富的抽象物
在Swift中所有的基本类型整数、两倍数、
字符串、字符等等它们都是数值类型
它们都有这个基本行为
从逻辑上说 这两个变量它们是不同的
我们在它们顶部构建的全部集合...
阵列、集合、字典...
当给予它们数值类型时它们都是数值类型
你用来构建自己的类的语言抽象
这里的类包括元组、结构和枚举
当你把数值类型放进去时你得到的仍然是数值类型
再说一遍 在数值语义世界中构建
丰富的抽象物十分容易
数值类型上还有重要的一点
就是你有一个两个值等价两个数值类型
变量等价的概念
它们保持同样的值
重要的是那个恒等式并不重要
因为可有任何数字的复制
重要的是存储在那里的实际值
你怎样拿到那个值并不重要
我给你们讲几件非常愚蠢的事
我们这里有A把它设置成五还有B
我们把B设置成二加三
当然了 A和B是等价的
你一直是这么用的
如果整数不是这么用的你就理解不了了
因此把那个概念扩展一点
当然了对CGPoints来说也是如此
如果不是这种方式的话 你也理解不了
为什么字符串的行为方式不是一模一样呢？
我怎样得到“你好 苹果全球开发者大会”这个串不重要
字符串是数值相同运算符需要把它表示出来
你可能会让它非常疯狂非常愚蠢
这里我要进行一些排序操作
归根结底我有整数的两个阵列
整数有同样的值
因此这些东西是等价的
当构建一个数值类型 非常重要的点是
要遵从“相等”协议
因为那里的每个数值类型都是相等
这就意味着它有等于操作符
来进行对比 但是操作符的运作方式
必须合乎情理
它需要是反身的、对称的、及物的
为什么这些属性很重要？
除非你拿到你的代码 否则你不理解
如果我从A复制到B 
那么我期待A等于B B等于A
当然了 为什么不相等呢？
如果我之后又从B复制到C那么C、B、A 
它们都是等价的 我有哪个数字不重要因为唯一重要的是值
而不是恒等式
幸运的是 实现这些非常容易
让我说就是拿出CGPoints
用“相等”协议扩展实现相同运算符
当你在其它数值类型上构成数值类型时
一般来说你只需要使用
下面的所有数值类型的
等号操作
好的让我们把它弄回我们的温度类型
我们现在生成一个结构
我们要把摄氏度切换回一个var我们就可以改变它
它现在就有了数值语义
很明显 我们给了它相同运算符
我们来把它用到我们之前的例子中很好
创建家庭 创建温度 把温度设为华氏
七十五度 哇！
编译器停在这里了 发生什么了？
我们试着改变温度的一个属性
这项属性的描述是“let”
它是一个常量 不能更改
我们来满足编译器
把它改成var 现在可以改变它了
一切都进展顺利
为什么呢？家庭指向了烤箱内的恒温器
恒温器和烤箱都有了各自的温度数值
实例
它们是完全不同的不会共享
它们在结构中碰巧也是内联的
你的内存使用情况以及性能都更好了
这很棒 数值语义让我们的生活更容易
有了我们的例子让我们继续
把所有的事情都变得有数值语义
房子的结构里面有一个恒温器结构
一个烤箱结构 整个世界都是数值语义
我们需要对我们的代码做的变更就是 现在家庭是可变化的了
因为我们改变了家庭的恒温器的温度
对 那是家庭、恒温器的一个变异温度的一个变异
好的 现在就到了一个非常重要的地方
因为Swift的不变性工作模型数值语义在Swift中
运行的天衣无缝
如果在Swift中有一个“let”那么它就是数值类型
这意味着当某个东西损坏了你的进程的内存时
这个值不会很快发生改变
这是一个健壮的语句
它意味着推论出“let”的事情非常容易
不过我们仍然允许有变异
你可使用var 说这个变量是能变的
对于我们的算法来说 这就非常有用
注意这个变更是非常本地的
我可以变更这个变量但是除非我告诉它
除非我在其它地方做出改变否则它是不会影响到
我的项目中的其它地方的
这样就有了这个非常漂亮的受控易变性
其它地方有了可靠的保证
这里有趣的一件事是当你使用数值类型、把它们
传递到线程边界时你就可以避免这些类型
出现竞态条件
我创建数字
把它们传递给某些会异步处理
事情的进程
我本地改变数字 然后再来一次
有了一个引用语义阵列这是一个竞态条件
有时候 它会把你吹炸
有了数值语义 你每次都能得到复件
每次都能得到逻辑复件
因此 就没有竞态条件
它们不会同时到达相同的阵列
好的这个听起来像一个性能问题 不是吗？
每次我们通过一个参数传递数字时我们就会进行一次拷贝
好的 关于数值语义另外重要的一点是
复制很“廉价”
这里的“廉价”我的意思是时间常数“廉价”
我们从基础开始构建这个app
当你有基本类型时
那些低层次的东西 整数、两倍数、浮点数等等
复制它们很“廉价”
你复制的只是几个字节
除非是在处理器中进行复制的
你就可以用两倍数、整数等等构建结构
就像CG点是由两个CG浮点数构建的一样
任何这种结构 枚举或者元组
它们的字段数量是固定的在那里复制每个东西
都是时间常数的
因此复制整个东西也是时间常数的
好的
对于定长的东西来说 这很棒
那么对于可扩展的东西来说字符串、阵列、字典
又是怎样呢？
我们在Swift中处理这些东西的方式是“写入时复制”
这样就可以让复制很“廉价”
就是一些固定数量的引用计数操作来对“写入时复制”
值进行复制
当你进行改变时 你有了一个var
然后你就可以变更它我们也就制作一份副本
并且在其上工作
因此你就是背后分享
但并不是逻辑分享
从逻辑上来说 这些仍然是不同的值
这样你的数值语义的性能特征
就很棒 编程模型也很棒
我们非常喜欢数值语义编程模型
从逻辑上说 不同的变量始终是不同的
你想让它是本地控制时 就有变异概念
一个有效的变异
但是你还有这些严格的“let”保证
意味着它不会在其它地方改变
复件很“廉价”我们就可以一起工作
好的 我想交给我的同事
比尔·达德利他会谈谈数值类型和实践
谢谢 道格 大家好
刚才道格已经给我们讲了数值类型的工作原理
它们如何与引用语义进行对比
我们来谈谈使用数值类型构建一个真实的实例
我们要做的就是把一个实例组织在一起
然后我们通过几个不同的值、一个圈和一个多边形
构建一个简单的图表
让我们从圆开始吧
这是圆心 这是半径
都是取自标准库的几个
数值类型
当然了我们想要实现相同运算符
equals相等操作符
我们只需要对比这些类型就可以实现
同样地因为它们是内置于标准库的
我们只需要把它们用起来就行这是因为我们用的是取自库的
简单类型来构建
下一个是多边形
它有一个角落阵列
每个角落都是一个另一个CG点同样地
这些CG点也是数值类型
因此我们的阵列也是一个数值类型
我们的比较也很直接
只要在那使用equals相等操作符
确保我们实现了“相等”操作符即可
现在我们要做的就是把这些类型放入我们的图表
把多边形和圆都放进去
制作一个圆的阵列也很直接
制作一个多边形的阵列 同样也很直接
因此我们可以制作任何类型的阵列
我们要做的 就是制作一个两者都包含的阵列
在Swift中这样做的机制是使用一项协议
我们会创建一个叫做Drawable的协议
我们的子类型都会实施
那个协议 然后我们把它们放到
我们的图表中的一个阵列中
“Swift中面向协议编程”这场会议中有很多信息
今天3:30会再次召开
若你还没有看过的话
我强烈建议你们去看看
或者看看视频
这是我们的Drawable协议
很直接 也很简单上面有一种方法即“绘制”
当然了 我们想在我们的两种类型上实施它
我们会创建一个多边形扩展
实施那个绘制方法 然后它会调用
Core Graphics绘制多边形
圆也是 同样的情况
那么我们要做的就是调用Core Graphics
构建圆的表示
现在再回到我们的图表
得到了这个可绘制的被调项目阵列
我们需要创建一个方法 添加项目
它被标记为了“变异的”因为那会改变它自身
我们要实现这个绘制方式来对那个项目列表进行
简单迭代并且调用列表上的
每个项目的绘制方式
我们来以图解的方式 看看它
我们创建一个图表称之为doc
我们创建一个多边形然后把它添加到阵列上
我们再创建一个圆也把它添加到阵列上
现在我们的阵列内有了两项可绘制物
注意它们的类型是不同的
当我们再创建一个文档并且说doc2等于doc
得到了一个逻辑上不同的、全新的实例
从逻辑上说它和第一个实例是分开的
我现在可以返回doc2进行更改 当我进行更改时
当然了它对doc没有影响
我把那个圆改成一个多边形
阵列有数值语义即使集合是
即使是不纯一的
那么它的内部就有了多边形那个阵列内的圆
也是一个值
当然了 我们想把我们的图表的结构做成“相等”的
因此我们把协议实现
我们看到的这是一个非常直接的
实现
但 如果我们那样做编辑器就会说
“等等方程式两边的两个值 我没有equals相等操作符”
对于在该方程式的两边这两个值
再说一次 我推荐你们去看面向协议的编程
我们在那里讲了它的所有的原理细节
我们本次会议专注的是数值语义
可绘制物有个叫做“绘制”的单一方法
图表也有一个叫做“绘制”的方法
把我们的图表变成一个可绘制物
我们只需要把那个声明加到它上面
现在我们的图表像鸭子一样嘎嘎叫 那它就是一只鸭子了
那么接下来的就非常有趣了
我可以创建一个新的图表并把它添加到我现有的图表
那里有了三种不同的类型
不过它们都包含在那个阵列中
它是图表的一个新的实例
但是我还可以再进一步
把那个文档加到阵列中
如果这些是引用语义
我们来看看绘制方法
如果这个是引用语义
它就会无限递归
因为当我在我的图表上调用“绘制”时 它就会遍历
项目列表并且在列表上找到它自己
然后就会再次调用“绘制”出现无限递归
不过我们用到是值
因为它是一个值添加到我的图表的
一个完全分开的、不同的实例
而不是doc
因此不会出现无限递归
我刚刚绘制了两个多边形以及两个圆
既然已经讲过了 纯粹由数值类型构建
一个对象树
我们来讲怎样混淆数值类型和引用类型
在Objective-C中
你已经习惯了始终把原始数据类型放到你的引用类型中
在Objective-C中就是这样构建东西的
但是另一方面这会产生一些有趣的问题
我们必须仔细考虑这些问题
如果我们构建一个数值类型我们就想要确保
那个数值类型维持自身的数值语义
哪怕它里面有一个引用
如果我们要那么做
我们就必须仔细考虑那个问题
我们该怎样处理这个事实：
它里面有一个引用 两个不同的值可能
指向了同一件事？
我们就必须解决那个问题
我们要仔细考虑的
另一件事是：它会对等式产生什么样的影响？
让我们从一个带有不可变类的
简单例子开始 UIImage
创建一个要成为 可绘制物的图片结构
它对UIImage有一个引用
我们用旧金山的这幅美丽的
照片来创建一个实例
如果我们再创建一个“图片2”现在
“图片”和“图片2”就都指向了同一个对象
如果你看这个你会想比尔骗我们了
这肯定会出问题 就像那个
温度一样
但是这不是因为UIImage是不可变的
因此我们不用担心“图片2”会改变位于它下方的
“图片”
不要担心第一个图片会猝不及防受到
改变的影响
我们想要确保我们实现这个等式
你可能会看到这个然后想“没问题”
我要使用三元组相等操作符
它会对比引用看看
那些引用是否相同
对于这个例子来说当然没问题 不过我们还必须
认真考虑下 当我们使用
同样的底层位图创建两个UI图片时会发生什么？
我们想让它们也相等、同等 在这个例子中
因为我们是在对比引用 它们就不会相等
因此 说这两个图片
不相同 就错了
想要使用我们从UIImage上的NSObject继承“是等效方法”
来进行对比
这样不管是否在相同的对象上
我们都可以确信引用类型获得正确的回复
我们来谈谈如何使用可变的对象
在这里有一个BezierPath
它也会实现“可绘制物”
但是整个实现是由这个可变的
引用类型UIBezierPath构成的
在这个读取实例中当我们进行“Is Empty”时
一起都正常
没有进行任何改变因为不会和任何其它的
实例混杂到一起
但是下面的这个我们有这个“向点添加线”方法
如果我们有两个BezierPaths指向这个方法
它就会造成问题
我们在那里并没有“改变中”这个关键字
那是一个符号 表明我们知道我们正在进行改变
“向点添加线”在那里但是编译器并没有对着
大喊大叫 告诉我们这一点这是因为路径是一种引用类型
我们很快会再看看它
如果有两个BezierPath实例并且都通过这个改变
指向了同一个UIBezierPath实例
如果我做出改变 那么
它就会让另一个实例措手不及
这种情况可不妙
我们就没法维持数值语义
我们需要修复它
我们修复的方式是使用“写入时复制”
我们需要确保在我们写入那个路径之前
已经制作了它的一个副本
因此要向我们的BezierPath中
引入一些新事物
首先我们想要让我们的路径实例是私有的
其次想要实现这个读取计算路径属性
并从那里返回我们的私有实例变量
我们也想为写入计算属性
创建一个路径路径标记为“改变中”
那么它就会 事实上改变状态
我们把它标记为“改变中”把路径设为与我们现有路径的
新副本等同
现在我们有了一个读取副本我们还可以获得一个写入副本
那么我们改变我们的实现来反映这一点
在“Is Empty”方法中我们会调用我们的读取副本
在下面的改变方法那里
我们会调用写入路径
关于这个 很棒的一点是编译器会对我们大喊大叫
说：“写入属性路径标记为了
改变中 这个方法没有
标记为改变中 ”
我们就从编译器得到了帮助在我们搞错时
帮助我们弄明白
在一个图表中浏览下它 浏览下路径
我通过说“Path To”又创建了一个
当然 我可以读取它
没问题 当我对它写入时
建了另一个BezierPath实例
路径二还是不明白已经发生了一次变异
因此我不会在路径二后面引入一些意料之外的变异
现在我们来谈谈如何在实践中使用这些东西
这里我们有我们的多边形类型 我们要通过
添加一个会返回给我们对那个多边形进行描述的
BezierPath的方法对它进行扩展
我们创建BezierPath通过点进行迭代
向这些点中添加线二
现在缺点就是那个“添加线到点”方法
会复制每次调用
因此它的表现可能不那么好
因此我们应该创建一个UIBezierPath实例
然后就地改变那个可变的引用类型
当我们弄完后用那个BezierPath创建一个
数值类型新的实例且返回那个BezierPath
这样生成UIBezierPath副本
或者生成个UIBezierPath实例而不是生成多个副本、实例
在Swift中 有一个很棒的特性
可以通过它知道对象是否被惟一地引用
这样我们就可以利用它
这个结构和BezierPath中看到的类似
我们可以利用我们有这个惟一引用属性这一事实
我们就可以肯定
有些东西是被惟一引用的
如果我们知道那个引用类型是惟一引用
我们就可以避免制作副本
标准库会自始至终使用那个特性
使用那个特性也可以进行很多很棒的性能优化
这样酒吧数值类型以及引用类型混合了
尽管事实是通过使用“写入时复制”
你在可变类型上有这些引用你也想要确保你可以维持数值语义
现在我想看一个非常酷的特性  我们现在能做的
就是把一个模型类型当做一个值来实现
然后实现一个撤销栈
那么我要创建一个图表以及一个图表阵列
有了各个变异 我会把我的doc添加到我的图表阵列中
那么我创建并附加它
我添加了一个多边形并且把它附加到了撤销栈
我创建了一个圈并且把它附加到了撤销栈
现在在我的撤销栈里我有三个不同的图表实例
它们没有引用同一件事情
这些是三个不同的值
因此可用它来实现一些很酷的特性
假设这个位于一个app内我有一个“历史”按钮
我点击这个“历史”按钮我得到了返回到
我的撤销栈的我的图表的全部状态列表
我就可以允许用户点击其它东西
并且及时返回
我就不用在某个阵列中保存如何撤销添加那个属性
或者撤销添加其它东西
它会直接返回上一个实例
也就是刚刚绘制的那个实例
这是一项超级强大的特性 事实上
Photoshop大量使用这一特性以便实现他们的各个
与历史相关的东西
当在Photoshop打开一幅图片
幕后发生了什么？
Photoshop会对那个照片分层、切块
不论照片有多大切分成一堆小的图块
每个这种图块都是数值 含图块的文档
同样也是一个数值
如果我进行改变比如说把这个人的衬衫
从紫色变成绿色在那个图表的两个实例中唯一
被复制的就是包含了这个人的衬衫的
图块
这样即使我有两个不同的文档
旧状态和新状态 我唯一需要当成那个
结果来使用的新数据
就是包含了这个人的衬衫的图块
小结一下 我们讲了数值类型
讲了它给你们的应用程序带来的很棒的特性
把它和引用类型做了对比向你们演示了数值类似
是如何修复某些问题的
期间我们演示了一个实例让你们看了一些你们可以
通过使用数值类型添加到你们的应用程序上的
很酷的特性
我迫不及待想看到这些东西在你们的app中是如何发挥作用的
有一些相关的会议 你可以观看视频
或者如果你有时间的话 今天3:30
有关于面向协议编程的会议
如果需要更多信息你总可以给斯蒂芬发邮件
或者访问我们的论坛资料中也有一些
很棒的信息
谢谢 祝你们在苹果全球开发者大会的剩余部分愉快