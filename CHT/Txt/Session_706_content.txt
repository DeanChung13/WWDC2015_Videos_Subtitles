Apps的安全
你們好 謝謝
我是伊凡是Apple公司安全及隱私策略小組的負責人
今天我們來談一談安全
事實上今天將主要談的是設備安全
現在你們也知道我們設備的安全性能非常高
有些安全性能是OSX或IOS所特有的是兩個平臺兼有的
我們將繼續開發這些性能
你們也將看到我們在這領域會不斷地創新
今天我會抽些時間和你們簡單談談網絡安全
一談到網絡安全你們大部分人都會想到
HTTPS我們多數也是在瀏覽器的鎖定圖標中見過它
在過去網站會使用HTTPS和TLS
來傳輸一些敏感信息
在我們看來信用卡信息已算不上敏感信息
所有的用戶信息纔是真正的敏感信息
而作爲開發者認爲不敏感的信息在用戶看來可能就是敏感信息
TLS真正重要的一點也是我們通常想不到的
就是它不僅會保護網絡運行的信息安全
而且還保護連接的完整性
網絡面臨的威脅已經變了
已不再是戴着黑色面罩躲藏
在網絡的某些角落去竊取你信用卡數字那些人
事實上 用戶是想保護自己免受其他威脅攻擊
例如 網絡服務供應商
他們向每個應用中插入跟蹤標頭信息 
或直接記錄瀏覽歷史以進行廣告定向投放
所以 我們認爲TLS在2015年的最主要職責就是保護消費者
網絡信息安全
但是TLS仍有漏洞
很多服務器仍使用TLS 1版本
這個版本太老了已有16年的歷史了
連最新版本TLS 1.2也已經有7年的歷史了
TLS 1.2包含了很多重要的協議加密升級功能能夠抵抗我們
正面臨或未來要面臨的各種威脅
事實上 連TLS1.2版本也有漏洞
根據TLS的運作方式如果黑客
黑掉一個服務器並竊取你的TLS密鑰
那麼他們就可以破解服務器曾經加載過的加密數據
毫無疑問這是非常恐怖的
不過有個正向加密的軟件可解決這一問題
有了正向加密即使黑客黑掉一個
服務器竊取了TLS密鑰他們也只能用密鑰
破解服務器未來加密傳輸的數據
不能破解已加密的歷史數據
這樣非常棒 因爲它能減少龐大的網絡
加密數據負荷
TLS支持正向加密正向加密過程通過
使用密碼組完成而密碼組是由啓動
服務器所必須的加密基元組合而成
所以 你們的服務器無需運行TLS只需運行TLS 1.2
爲了獲得正向加密你們必須對其進行設置
我爲什麼告訴你這些呢引用蒂姆的話我會讓你們讀一下
我們必須修正這問題
爲了幫助你們不出問題
我們將向你們介紹AppTransport Security
它是這樣運行的
在OSX EI Capitan或ISO9打開你們的應用
默認它這樣就不會連接到不受保護的HTTP鏈接   
它們會連接失敗而且程序生成的任何TLS連接
也不會按照我剛纔描述的最優做法
這就是帶有正向加密的TLS 1.2
任何已知的不安全加密基元均無法被允許
密鑰尺寸也有最低要求
現在你可能不會完全按照這些要求去做
立即遵守這些要求不過沒關係
你可以在Info plist中根據每種情況
指定例外情況或進行全局覆蓋
但是就整個行業而言我們必須儘快做到
讓用戶信息無法接觸到未加密網絡
我們需要你們的幫助
謝謝大家下面由我的同事皮埃爾給你們談談
System IntegrationProtection
謝謝伊凡
嗨 大家好 我是皮埃爾•奧利佛•馬特爾
擔任Apple公司沙盒技術部的技術經理
今天我和大家談談 SystemIntegration Protection
這是我們在El Capitan引進的
新型硬化機理
在探究細節之前我想退一步
給大家說說我們要達成什麼目標
在Apple公司 我們團隊的使命是確保用戶能享受到
產品帶來的極致體驗我們相信
我們可以保護他們的
個人資料即使資料被
惡意軟件甚至更糟糕的
編寫軟件攻擊傷害也會很小
爲了達到這個目的我們已設計和集成
各項安全技術正如伊凡上面所提到的
這些年研發的iOS和 OS X
研發所採用的一種
配額和原則就是深度防禦概念
使用的關鍵原則你可能也
有所耳聞 那就是安全與層有關
你不能把所有雞蛋都放在同一個籃子裏
不要指望單層保護設備就完事大吉了
因爲不管這個保護層
防彈性 防水性 抗震性有多好
一旦壞掉就
功虧一簣
相反 你們應該依靠多層保護
原則上有了多層安全保護
不僅能推遲黑客入侵時間
還能限制被攻擊範圍
到現在爲止 深度預防
這個古老的軍事概念被用來捍衛世界
各地城池已有幾百年歷史了
我知道你們很喜歡瑣事
所以 我可以告訴你們這個概念是
塞巴斯蒂安•德•沃邦在17世紀70年代正式提出的
那時 他受法國國王邀請
在全國建造堡壘
以保衛王國安全
你們可能不熟悉這個人
但你們肯定見過他的作品
這就是他其中的一個城堡設計圖
你們可以清楚地看到這幾個保護層是
用來抵擋不同的襲擊 
它們可以拖住入侵者然後通過
易守難攻的窄道把入侵者抵擋在外面
我們來看看如何把這個原理用到OS X的安全模型上
我不知道你們是不是這樣反正我是經常夢想着
建造自己的堡壘就是這樣
我們在這之上設置自己的安全層
我們從底部的網閘開始
網閘要確保從網上下載到
用戶設備上的應用是經開發者簽字的
開發者擁有Apple公司發佈的開發者身份證明
否則程序將無法運行
網閘要配合系統的其他機制運行
如惡意軟件檢測機制
這樣纔能有效
防止惡意軟件大規模地入侵我們生態系統
第二層是沙盒
回到Lion 我們引入了App沙盒
我們強制性規定所有從App Store下載的應用都要使用App沙盒
對於從App Store以外下載的應用
比如開發者ID程序也強推薦使用App沙盒
沙盒是一種控制機制
它能確保即使你們的程序被入侵了
攻擊者也只能訪問用戶提供的資料
而不能竊取用戶資料
也不能破壞其他系統
如果你們成功繞開前兩層那麼就來到了第三層
經典的POSIX權限方案
在這裏 你們的應用
只能在系統授予用戶的權限下運行
所以它既不能訪問不同用戶資料
也不能修改root用戶對系統進行的配置設置
最後 我們把Keychain 看成第三層上面的一層
它是用來保護用戶密鑰的
它通過加密和應用分離
確保只有在第一層存儲祕密的應用
纔可以返回此層
所以當你們看到整個方案後
你們會明白很多事情
首先 網閘阻止下載到機器上的不信任代碼
但是它還不是真正的控制機制
因爲啓動網閘不會阻止任何應用運行
而且它也不會保護機器已有代碼
例如它不會保護OS自帶的代碼
所以 雖然它可能是
我們平臺最有效的控制機制
但沙盒機制是OS X的唯一選擇
我們沒有要求規定每個過程都
必須在沙盒中運行
最後當你們看到POSIX層時
會發現大部分的Mac系統 都是單用戶系統
而系統的用戶實際上是臨時管理員
一直在行使管理特權
root賬戶通常要麼處於保護狀態
要麼保護密碼較弱甚至沒有密碼
事實上如果真的有密碼而且你想要的話
用戶也可能會給你
而且 當你最後root之後實際上已經能控制
整個機器 因爲root文件可以禁用設備上所有的安全措施
它能替換內核擴展
替代提供其他安全服務
甚至可以擾亂運行中的Keychain層
所以 事實就是一旦代碼在Mac運行
那麼很容易進行root
一旦root成功你就可以完全控制機器
也就是說
任何一段惡意代碼實際上就是一個密碼
或一個可以完全
控制你機器的漏洞
這表明我們還需要另一個層
一個能消除機器root權限的層
從而在默認情況下保護系統
好像是Apple安裝到機器上的一樣
硬盤和runtime都進行安裝
因爲我們現在正討論限制root權限
所以我們需要提供一套配置機制
防止root被入侵
而且還能重設root權限
這就是SystemIntegration Protection
這是一個新的安全策略
適用於系統中的每個進程
不管這個進程是否
具備附加特權或者在沙箱外運行
該策略能爲磁盤或runtime中的
系統組件提供額外保護
而且系統如果安裝Apple簽字安裝包
二進制只能被安裝程序
或者軟件更新機制修改
這樣系統二進制文件就能免受
runtime附件和代碼注入的風險
在探究細節之前
我們先看一下這是如何影響開發者的
好消息是如果你的應用
是App Store下載的 那麼應用就不會受到此類風險
<br/> 因爲App Store指南
和沙箱策略可以加以保護
阻止此類行爲
然而 如果你們的應用不是來自App Store
而且需要修改系統的二進制文件
或修改磁盤框架如果需要將儲存信息安裝到系統位置
那麼應用就會受到影響
我將在這裏解釋一下
什麼是系統位置
最後如果你們的應用需要檢查系統進程中
任一進程的的內存狀態
或需要在系統運行的進程中或跨進程
插入庫或進行調試
那麼讓我們看看新機制的核心
首先我會瞭解下新文件系統限制
我們在Capitan系統引入該文件系統
然後再看一下它是如何擴展到
新runtime保護進程
最後瞭解一下該系統與
內核擴展開發流程的關係
以及它是如何影響kext開發者的
然後由於這個功能是能夠被完全禁用的
接下來向你們展示一下如何禁用
那就得首先講講文件系統
我們想做到的就是保護系統存儲信息不被修改
爲達到這一目的 安裝程序會標在文件安裝過程中
標記系統內容
我們在Capitan系統中加入了新的文件系統標記
之後在運行過程中內核能阻止任何
企圖篡改受保護文件
或文件夾的行爲除非該行爲是
特別授權的進程發出的
Capitan系統只有幾種此類進程
內核還會防止儲存私密內容的塊設備被讀寫
而且還會阻止
私密內容被篡改
現在 必須記住一點是
這隻適用於root文件和
當前運行OS的啓動卷
所以你應該把它看成系統運行時的
一種自我保護機制
因爲我們現在要保護磁盤上的系統存儲信息
所以你們必須明確區分
系統內容和第三方內容
在Capitan 這張圖標左側
所有位置都被默認爲系統位置
這意味着系統會阻止你在那裏進行讀寫
即使是安裝程序包下載的也一樣
因爲多年來我們一直建議你們
不要讀寫到這些位置
所以你們當中受影響的人應該不多
如果你們的安裝包把存儲信息放到這裏
Capitan應該不會出現大的故障
如果你想把所有的軟件都安裝在/System路徑下
那麼你需要將此存儲信息移到subfolder of /Library下
如果是系統內的存儲信息或(tilde)/Library
如果是用戶存儲信息
或者如果你想把軟件都安裝到/bin或者/sbin
或者/usr目錄下
比如/usr/bin, /usr/lib或者usr/libexec
那麼你要把儲存信息移到
/usr/文件夾下的適當位置 因爲這裏是
第三方唯一可訪問的路徑
然後需要注意的是
最佳的存儲信息位置仍是/Applications路徑
這是因爲這個位置是用戶可見位置
方便用戶把應用拖入
垃圾箱並刪除存儲信息
要注意的是 當用戶升級 
Yosemite install到Capitan install時
安裝程序會會把系統內
發現的第三方存儲信息移到系統外
所以爲了不影響這些用戶
務必確保把存儲內容儘快轉移出去
現在我們看一下runtime保護
能夠改變runtime中的進程行爲
就相當於能夠改變
改變磁盤上的二進制文件
如果想保護磁盤上的二進制文件
或系統存儲信息我們必須保證
不能插入代碼或改變
這些系統進程的行爲
爲了實現該目的我們在進程結構中
引入一種新的限定標記這種標記的內核適用於每個單一進程
如果磁盤上的
主要可執行文件受程序保護
或寫入Apple特別授權的主要可執行文件
那麼內核將在準確時刻做出標記
之後系統將自動區別
該受限進程和常規進程
一方面如果task-for-pid
和processor-set-tasksSPI需要調用受限進程
那麼它們將無法運行
並且會設置EPERM爲0
這意味着你的產品需要依靠
系統進程才能運行
例如Finder 你需要向Finder插入代碼
否則它再也無法運行了
如果你插入exec 那麼二進制文件將導致子進程受限
然後系統將自動重新設置
子進程的mach特殊接口
這樣意味着你將 
無法控制子進程
如果你插入一個特權工具
然後想要保持控制那麼它也將不能運行
連接器將忽視所有保護二進制文件的dyld環境變量
所以在執行過程中如果你在進程中
將庫插入二進制文件
連接器忽視新庫
最終如果使用dtrace的話所有針對
受限進程的dtrace探針將無法匹配
這樣就無法看到進程和內核的互動過程
你們也將檢測不到受限進程存儲空間
也就無法檢測到內核內存
當然這適用於調試器LLDB
如果你們試圖調用LLDB作爲root
並連接到Finder這樣也無濟於事
現在接下來是kext簽字程序
你們肯定也知道所有帶Kexts開發者ID證書的擴展
都是Apple公司發行的
擴展必須安裝到/Library/Extensions路徑下
新鮮的是因爲我們把kext簽字程序放置在
System IntegrityProtection之下進行保護
所以kext-dev-modeboot-arg就被淘汰了
如果你是kext開發者你就需要用
未簽字的內核擴展進行測試
你需要禁用保護我馬上給你們演示一下
這也意味着爲了禁用kext簽字
你在那裏可能也看不到這個註釋行 
它已經無法運行了
下面我們來談一下配置機制
我們堅信這個新機制對保護對我們的用戶至關重要
話雖這麼說但我們也意識到
人無法完全操控他們的機器
因爲我之前就說過
它保護着磁盤上的內核
需要所有的內核擴展都必須被簽字
而且因此kext開發者
也不能如願以償地測試未簽字kext
正因如此它被完全棄用了
配置存放在NVRAM配置中
這意味着可以適用於整個機器
所以如果你有幾個Capitan安裝程序
它們都會有同樣的配置 
而且OS安裝程序也是如此
所以當你從seed 1升級到seed 2再升級到GM之後
配置也將保持不變
我們安裝時不用每次都進行重新配置
現在 因爲root實際上已經設置了NVRAM
在這裏我們不能相信root
也就是我們不能在OS系統上安裝配置機制
我們要進行轉移 把它安裝在Recovery OS下
所以NVRAM也就只能在Recovery下進行配置設置
如果你想改變配置
你需要在機器的Recovery OS中進行重啓
在引導畫面下按Command+R鍵進行開機啓動
然後在Utilities菜單中 
運行安全配置應用
檢測SystemIntegrityProtection盒
應用 然後重啓
記住我剛纔描述的那些類型很有可能
在以後的seed版本中會發生變化
所以務必閱讀註釋瞭解新的操作步驟
我們總結一下到到目前爲止所談論的內容
System Integrity Protection是一種新的策略
適用於系統的每個進程
Apple公司將其安裝在磁盤和runtime上
通過限制讀寫系統位置訪問權限
以及防止runtime連接和代碼插入
從而保護系統
安裝程序能有效地把第三方存儲內容
轉移到系統位置之外
所以要確保儘快轉移你的存儲內容
否則 就只能自認倒黴了因爲 你會找不到內容
最後可使用Recovery OS配置機制禁用該功能
這就是我爲大家呈現的內容謝謝大家
下面我把舞臺交給安德魯
謝謝你 皮埃爾
我是安德魯·惠利在Core OS 安全功能組負責管理數據安全組
你可能聽過app傳輸安全
以及app在連接狀態下
是它如何保護傳輸中的數據的
我將會討論數據安全的不同保護方式
我會點擊Keychain然後存儲用戶信息
之後看一下Touch ID看看你是如何權衡
程序安全與程序便捷的
在這個過程中我將體驗一下現有的技術
和iOS 9的新功能以及如何配合使用
從而提供適合你們app的安全保護等級
我們首先快速瀏覽一下Keychain
你可以把它看作是專業的數據庫
通過增加行數來儲存數據我們稱爲Keychain項目
然後通過屬性進行查詢
爲了優化隱私我這裏說的隱私包括密碼
標記 cookie或祕鑰
如果你有成千上萬兆字節信息要儲存
那麼可以考慮使用基於文件的數據保護或者通過API進行
批量加密方法 如Common Crypto
然後將密鑰存儲在Keychain中
儘管這些SecItem API已經存在很長時間了
但它仍是最好的祕密存儲工具
包括新Swift apps中的密碼
這裏我們這裏有個祕密 想通過SecItemAdd
把它存在Keychain中
爲了這麼做我們構建了一個字典
這個字典包括祕密信息
還有今後查詢所必須的某些屬性
和應當採取的保護措施
這種創建包括描述項目查詢方式字典的方式
也可用於查詢刪除 
更新條目和其他API我後面會談到這一點
有關Keychain API的信息
2013年的WWDC的709會議還有很多
所以在編寫訪問Keychain代碼的時候你們要注意以下幾點
首先處理用戶隱私信息是代碼安全信息當中
真正敏感的一個環節
所以你們應該把它分成小而簡單又可測試的小單元
通常可以使用wrapper class
不管是直接使用還是使用wrapper
請確保你的應用
受到最高級別的保護
我們描述和討論的數據保護級別
指的是通過加密訪問項目的次數
例如當設備在iOS8系統上
被鎖定的時候我們添加了After First Unlock
再說一遍這功能早就有了當你必須在背景下
訪問這些項目時候你就可以使用它
比例你開發的是一款VoIP應用
iOS 9不支持隨時訪問
所以你們必須着手把這些項目移到到更高級別位置
我們已開發出WatchKit 2所以你的Watch app現在可以
訪問SecItem API雖然在Watch上
輸入用戶全名和密碼的這種用戶體驗並非是你想要的
如果你的Watch app顯示的是配對iOS設備的數據
那麼你只需發送內容
而無需使用永久證書
如果你的Watch app確實需要直接訪問證書
那麼與其保存完整的用戶名和密碼
不如讓服務器發送一個許可證或cookie
從而獲得權限訪問
那些Watch app所需要的主要功能內容
不僅僅在Watch上提示用戶名
和密碼非常不方便
在過去的幾個版本我們引入了幾種技術減少密碼提示的頻率
第一個就是共享web證書
我們都瞭解也都喜歡Safari保存的密碼
以及提示和儲存密碼的方式
有了iCloud Keychain密碼就可以同步 自動保存
到所有設備上
但是 常見的是一個服務器
同時擁有一個網站和一個iOS app
所以 如果這些程序都能共享
Safari保存密碼那就太棒了
有了共享web證書就可以辦到
這些是你們在登錄
或註冊程序要添加的代碼
SecCreate SharedWebCredential Password將
返回一個隨機字符串和Safari保存的密碼格式一樣
用於提示密碼
你們能調用SecAddSharedWeb Credential
告知Safari需要將新用戶名和密碼
自動輸入到特定域中
在iOS 9我們已經實現這個功能
方式是在模擬器上運行時
降低安全檢查等級
我們來體驗一下
我從註冊程序開始
然後添加剛剛展示過的代碼
然後進入Safari設置
確保已啓用名稱和密碼自動輸入
搜索Safari等待結果
我們回到程序上來
頁面上顯示用戶名稱和密碼提示
共享網絡憑據允許應用
顯示一個選擇器這個選擇器列出了Safari在這個域中
保存的所有賬號
每當用戶選擇一個賬號 用戶名
和密碼就會根據Shared Web Credential
返回到已完成處理的程序中然後就可以登錄了
如果你想要在設備上使用這個功能
而不是隻在模擬器上使用你就需要在你的應用上
添加一個授權你可以在Xcode的權限標籤頁的
相關域部分中進行該操作
你需要將JSON文件放在服務器中
不過你可能已經有了
畢竟它跟Handoff和iOS 9應用鏈接中
所用的是同一個
我們對iOS 9做了一個改變
讓適應性更好這個改變是
你不再需要分別簽署該文件
它將由安全TLS連接所保護
我提到過Safari通過iCloud Keychain保存密碼
但是你們也可以在自己的應用中直接使用它
想象你有一個iOS iPad
iPhone和OS X App Store app
你想要只登陸一個就同時登陸所有這些程序
對於能夠用於多種設備的應用密碼
你們可以考慮將同步性屬性
添加到所有的SecItem調用
你還需要考慮幾件事情
比如 刪除一個項目就會將所有位置的該項目同時刪除掉
所以請確保你只在正確的情況下進行該操作
這裏還有幾個注意事項你可以在SecItem.h.
查看如果你有興趣想了解更多
關於iCloud Keychaine安全性的信息
或者想知道同步的密碼如何保護個人隱私
不被其他用戶看到請查看iOS 安全白皮書
會議結束有個鏈接
我重申下 Keychain存着你所有的祕密
而純文本文件或plist文件已經沒有密碼
所有請儘可能保護好它們
並且如果合適的話請使用SharedWedCredentials
比如我們的Keychain 以便在用戶的設備上將進行同步
同時儘量不用密碼提示
所以雖然有些祕密能在多臺設備上同步但你只想它們
在一臺設備上安全待着
這時候iCloudKeychain就派上大用場了
安全通訊應用就是一個例子
這種應用的加密是設備對設備而不是用戶對用戶
我已經提到過的不同保護級別中
有一個ThisDeviceOnly級別
項目會被備份但只能被
恢復到它們最初始的設備中
去年 我們增加了WhenPassCodeSet級別
確保項目始終處於
本地設備密碼保護之下
你可以使用AccessControl表
以對項目進行更爲嚴密的控制
既然我們在談論
保護特定設備證書的事情
那麼讓我們來看一看iOS設備的安全域
用戶空間也就是應用運行的空間
以及皮埃爾提到過的能夠提供進程分離和
其它安全功能的內核
不過它也提供了很多很多其它OS工具
這意味着它有着一個相當強大的防攻擊服務
我們在iPhone 5s中加入了Secure Enclave
Secure Enclave是獨立運行的在設計之時
始終將安全性視爲最高原則
我們在其中放置了Touch ID來保護隱私
以及你的指紋信息的安全
我們將KeyStore從內核
移進Secure Enclave就是它
控制着Keychain項目的密碼
以及數據保護
所以讓我們現在着重瞭解一下Touch ID
我們把它視爲一種安全技術
但它真正出色的是它的便利性
你可以不用總是輸入密碼就可以解鎖你的設備
不過它本身也可以帶給我們一些安全上面的好處
比如如今擁有複雜的長密碼變得更加容易了
它能夠提高數據保護的安全性
或者現在你的手機能夠立即上鎖
從而減少被攻擊和解鎖狀態的時間
在iOS 8我們提供了一些API所以當你在安全性和便利性之間
做權衡的時候你可以使用應用裏的Touch ID
但爲何是這兩者它們如何不同？
若想知道首先你得了解Touch ID
和生物特徵識別的工作機制
幸運的是 這很簡單它可以歸結爲一個條件句
如果伸出的手指和登記的手指相匹配
就要做出反應
造成差別的原因是這種反應是什麼
以及反應在哪裏發生
讓我們從LocalAuthentication開始談起
當一根手指被放在Touch ID感應器下
在Secure Enclave裏得到匹配
匹配的消息
會通過Local Authentication發送到你的應用
從而成功計算出布爾值 
你的應用就是這樣對那條信息的做出反應的
進程雖然在Secure Enclave開始
但最終安全決策卻是
用戶空間裏的應用做出
所以你什麼時候可能想要通過Local Authentication
使用Touch ID呢
想想你的應用如果你有任何安全障礙
比如輸入密碼來確認一項操作
即使用戶已經登錄了
使用Touch ID會更容易
或者你可能不想要總是使用Touch ID 
但在驗證過程中採取額外的措施這會是一個大障礙
比如你可以在查看敏感數據前
做出提示
或者在某個操作之前做出提示比如永久性刪除賬戶
一種模式是在你的應用流中
做出一個Touch ID提示
但這可能導致這種情況發生那就是 用戶剛剛用Touch ID解鎖
但沒過多久應用又會發來提示
在iOS9 我們添加了TouchIDAuthentication
AllowableReuseDuration這是在Local Authentication
環境下的一項屬性
你可以使用它來指定一個窗口
如果用戶最近剛用Touch ID
來解鎖他們的設備在期間
你就不需要再次提示
那是讓你的策略寬鬆一些的一種辦法
但或許你想讓你的策略在某些情況下
更嚴格一些
比如 對一個新登記的指紋做出反應
同樣也是一項新技術我們有evaluatedPolicyDomainState屬性
這是一個完全隱祕的值
代表了已登記指紋的當前情況
你真正能做的是實時做一下比較
如果它改變了那就是設置裏的已登記指紋中
有一個指紋信息已經被添加或移除
如果你察覺到並且它適合
你的應用或許你可以再次提示
看看用戶是否還想使用應用上的Touch ID
或者輸入一個密碼來重新啓動它
那麼我們來看看iOS 9的本地授權有哪些新功能
我已經提到了AllowableReuseDuration
和PolicyDomainState
另外你可以取消本地授權功能 
並且如果用戶現在會收到Touch ID提示 
那麼取消後系統會自動爲用戶選擇取消
並關閉對話框
evaluateAccessControl讓本地授權可以
和Keychain Access ControlLists一同使用我將稍後介紹 
也會給出很多示例和示例代碼
所以說起Keychain AccessControl Lists
這是第二種方式你可以在應用內使用Touch ID
然後用來保護特定的Keychain項目
這是我們的結構圖
和之前一樣 Touch ID在安全區域內發生匹配
但是這次匹配信息會從安全區域內
發送到Keystore
只有在此之後你的Keychain項目纔會
被釋放回到應用中
所以如果你想要對特定的文件進行保護的話
這麼這種方式非常有用
另外這也充分利用了安全區域的
額外保護功能
也許有時候你在權衡應用的安全性
然後你發現有些東西你實在不想要保留
不要每次或者經常收到提示
你可以使用AccessControl Lists進行保存
然後使用Touch ID進行保護從而提供更好的用戶體驗
或者你可以將其用來
增加已經保存的項目的安全性
你可以通過指定兩項安全屬性創建訪問控制列表
第一是數據有效保護類型
指的是需要使用密碼
才能訪問安全區域裏的數據接下來你可以制定一項策略
該策略指定了一種情況 
只有這種情況滿足後安全區域纔會釋放項目
單單訪問密碼是無法查閱的
因此我們來看看策略類型
第一種是UserPresence
這種策略會提示需要Touch ID匹配 
然後返回到設備密碼
另外你也可以直接跳轉到DevicePasscode
iOS 9的新功能是TouchIDAny
這種策略需要Touch Id匹配但是不會有反饋
另外更爲嚴格的新策略是TouchIDCurrentSet
使用該策略只有在保存項目時候使用的登記指紋組
不發生變化的情況下
項目纔會釋放
我想要詳細談談這種策略
因爲你的應用可能用得着
因爲這種策略提供多要素授權
當談到多要素的時候你可能經常會想到
比如像是密碼還有其他一些你可以想到的東西
比如物理標記智能卡
或者是iOS設備的安全區域和Touch ID
如果你保存一個文件 
然後使用TouchIDCurrentSet策略進行保護 
如果無法成功進行Touch ID匹配那麼是無法訪問文件的
而且沒有其他方式可以訪問
另外如果對手有設備密碼 
他們無法訪問設置登記指紋 
這樣對手就無法訪問文件了
最後的兩種策略ApplicationPassword
和PrivateKeyUsage
讓你可以執行高級功能這是Touch ID之上的高級功能
第一個是ApplicationPassword
爲了說明讓我們看看WhenUnlocked類別的項目
是如何被加密保護的
同樣的即使是最好的門鎖如果你忘帶鑰匙還是白塔
因此如果加密數據和祕鑰保存在同一個地方
那麼數據實際上沒有得到保護
數據保護和Keychain安全實質上是使用設備密碼保護
而且密碼已經保存在我們已知的
最爲複雜的系統之中即用戶的大腦
用戶記得密碼可以使用密碼訪問設備
在我們輸入密碼然後會生成一把密碼鑰匙
這把祕鑰能破解項目密碼
現在讓我們看看受ApplicationPassword保護的項目
只有設備密碼往往是不夠的
你的應用還必須有自己的密碼
因此我們生成了密碼鑰匙
而且只有在設備密碼和應用密碼都正確後
密碼鑰匙纔會授權給Keychain訪問項目
正如我提到的如果你將密碼保存到設備上或者應用中
這實際上並沒有提供額外的保護功能
因此你必須考慮除了設備你還可以將密碼保存在哪裏
也許是服務器服務器可以執行自己的策略
決定何時反饋密碼到你的應用上
或者也許你有物理配件而且你也覺得用戶有物理配件
如果配件無法向你的應用提供密碼 
那麼就無法破解Keychain項目
而你也無法訪問數據
如要使用ApplicationPasswords 你需要創建AccessControl列表
和本地授權指令
第一個列表會要求你使用應用密碼
第二指令會自行設定密碼
然後你可以取下這二者然後添加到
Secltem Call字典之中
這是使用本地授權指令
和Keychain項目的例子
那麼這就是ApplicationPassword
最後的新策略指的是私人祕鑰用途
這是比較早的表格 
在這裏我們可以看到一個Keychain項目從安全區域內的KeyStore
被釋放出來返回到了應用中
很明顯如果你將密碼用於登錄服務器的話就需要它了 
但是這暴露了你的密碼讓用戶空間存在潛在危險
所以如果有辦法在安全區域內 
保存密碼的話就不妙了
那麼這還有用嗎？ 
而且這裏使用的是不對稱加密技術 
這裏我們有的不僅僅是單一的祕鑰 而是一組祕鑰
公共祕鑰並不需要任何保護 
但是私人祕鑰就必須要好好保護了
使用這種策略會用到SecKey APi 
而且具體說的話幾分鐘說不完 
這裏就略過了但是這裏有概括圖可以看看流程
如果你設定某些新的額外參數的話 
調用SecKeyGeneratePair會讓
私人祕鑰保存到安全區域中
但是公共祕鑰仍會返回到應用中保存
如果你嘗試檢索使用SecItemCopyMatching的私人祕鑰 
那麼你會得到一個參數 
但是無法在安全區域之外獲得實際的數據
因此實際上該如何使用呢？
好 你也許有一些數據是需要保留的
因此你可以調用SecKeyRawSign然後將數據傳輸到安全區域
如果你已經設置了使用Touch ID保護私人祕鑰
那麼只有在成功指紋匹配後
私人祕鑰才能用於訪問數據
之後再返回到應用中
因此也許你會想使用該策略作爲第二要素加強Touch ID的安全性
我會給你看個示例流程但是請注意
在編寫加密協議的時候這裏有很多複雜的細節
所以請別把這個示例當成標準
首先在登記流程中
你會生產一個密鑰對
然後將公共祕鑰和用戶一般登錄信息發送到服務器上
服務器會將公共祕鑰和用戶信息相關聯並記錄
這就是登錄流程
之後當服務器想要驗證你是
從同一臺物理設備登錄的 
服務器會嚮應用發送一個挑戰 
挑戰反過來會調用SecKeyRawSign
用戶這時候會進行指紋識別 
然後匹配Touch ID
這樣挑戰就通過了然後應用會將挑戰返回到服務器
之後服務器會使用之前保存的公共祕鑰
進行驗證簽字
再具體展開看一下細節
通過驗證的祕鑰是Elliptic Curve P256
私人祕鑰則無法提取即使在保護情況下亦不可
然後應用是RawSign和RawVerify
總結一下 我已經大概講解了Keychain的情況
以及大家可能會用到Keychain的情況
我談論的技術是我們應當避免讓用戶被密碼提示反覆騷擾
看看這兩個TouchID API 本地授權
和KeychainAccess Controls
另外之前說的新的高級功能大家可以開發出新的東西
我們已經添加到iOS 9的新API之中了
App密碼以及安全區域保護的私人祕鑰
我總是非常期待
看看大家會如何利用新的API
開發出什麼更好玩的
也想看看大家是如何在應用中權衡安全性和便捷性的
另外線上還有其他更多的資料
包括我之前提到的iOS安全白皮書
週四的NSURL網絡會議上還會有更多的關於
應用傳輸安全的內容
另外歡迎明早和週四上午來到
安全私人實驗室會見我們
非常感謝大家