Core Data 新中的内容
下午好！欢迎收看第 220 课
我叫瑞西 卫尔玛稍后斯克特 佩瑞将跟我一道
为您展示今年Core Data 中的新内容
不过 在我们进入正题之前
我想给大家讲一下什么是Core Data
现在 你们中的很多已经开发了这些很棒的有漂亮 UI 的 app
你们已经把它与从外部数据源获取的
或者来自于提供给你们的
资源框架的数据结合起来
那么当你处理那些对象的时候
你将创建一个复杂的图形并将所有的那些更改向UI传递
然后当你的用户对 UI 做出更改的时候
您将把所有的那些改动推送回到您的对象图
并推送回到您的数据源
那么 Core Data让这个变得容易
Core Data将为您管理对象图
简单告诉我们一点关于您的 Cocoa 模型
以及对象模型编辑器的信息告诉我们一点
关于您的对象和它们的属性的信息
以及它们的相互关系而我们将负责剩下的工作
而且我们也将在您选择的后台维持它
不管它是 SQLite或是您自己设定的存储方式
于是 随着你不断导入对象你的各种关系将发生改变
而Core Data将为您维护这些关系
因此如果您在您的对象模型设置任何通用删除规则
我们将删除一个对象
并将按照你的定义根据规则统一删除
在你的对象图里找到对象也是特别容易的
只须使用一个NSFetchRequest
并赋给它一个 predicate
来找到你在寻找的对象
我们将为你扎到它们
批处理也很方便
这让你从读取请求得到的数据集里面
仅提取一小部分对象
让您在检查数据集的时候需要处理的数据变少
此外NSFetchRequest 的
另一个特性是关系的预读取
告诉我们一个需要读取的对象
我们会预读取所有与其相关的对象所以当你遍历那一关系的时候
你将仍然在内存中进行
然后你只须把所有这些绑定到 UI
你把一个NSFetchResultController
绑定到一个餐桌视图就像我们这里所做的一样
而当我删除苹果酱时
我的 UI 会相应地更新
然后当我插入更多对象时我添加了香蕉面包
我的 UI 也会相应更新
这些都为你处理所有的关键视图行为
以及更改通知 Core Data都会为你进行处理
抱歉
不过可能有一种情况
您的用户正在主上下文操作一个对象
而在背景上下文也在导入同样的新对象
而且可能正在更新目前用户
正在操作的对象
这就引入了“多写入者冲突”的概念
在 Core Data 中这里它也为您进行了处理
我们为所有对象进行版本描述并让您设定合并策略
如果您不舍得合并策略我们将在您将其存入上下文时
默认出错
并提示您出现了冲突错误
让您以自己认为合适的方式处理冲突
或者您可以从我们已提供的策略中
选择多个合并策略
不管它是在内存中还是在持久存储中
不管是持久存储优于内存还是相反
选择最适合您的最适合您的特定情况的
一旦您选用了 Core Data你会有几大好处
我要给特别大家讲两个
真正最大的好处
出色的内存可升级性以及积极的延迟加载
那是什么意思呢？就是说我们仅当您在内存中
需要那些对象的时候我们才加载它们
采用Core Data会导致占用空间的大幅减小
您需要维护的代码减少 50 到 70%
让您有更多的时间
开发您的 app 的新特性
然后您就可以加入
App Store中已在使用Core Data的
40多万个 app 了
Core Data 的概述到此为止
现在让我们进入新内容
我们为您准备的所有新的 API
首先让我们从NSManagedObject
和一个新的属性
hasPersistentChangedValues开始
以前您可能已经用过hasChanges
这是一个相当基础的脏标志如果你碰了这个对象
我们会将其标志为脏的 dirty
但是通过hasPersistentchangedValues
我们将确保对象的属性
与持久存储中的不同确保您不会有任何误报
NSManagedObject的新特性还包括
objectIDsForRelationshipNamed
这个非常适合用于大型关系
因为将不会在内存内将整个关系实体化
而是会将已经归类的
一系列对象的ID返还给您
这让您能够以更小的规模检查这些对象的ID
并且以处理您的更小的对象
让我快速地为您展示一个代码示例
这里是我的人物对象
而我请求它的关系对象ID“family”
这会给我全部关系然后我可以
去读取这些关系每批 100 个
然后以每次100个的速度遍历这些关系
这让我把向内存的输入维持在相当小的水平
而且易于管理
让我们继续往下讲NSManagedObjectContext
和一个名为refreshAllObjects的新方法
RefreshAllObjects所做的事情和你料想的完全一样
它把您的上下文中的对象更新
但是保留未被保存的更改
而且与reseton the context不同的是
您对对象的引用仍然有效
因此 您不必重取任何引用
而它最适合用于打破可能已出现的循环引用
循环引用是当你遍历一个双向关系时
你陷入循环中
此外NSManagedObjectContext的新特性还包括：
对于那些在您的存储中使用多个协调程序的朋友
MergeChangesFromRemoteContextSave
将从一个协调程序接收通知
并将其用于另一个协调程序的上下文
这让您在您的上下文中有最新的行数据
而我们将为您照看
所有必要的上下文
在 Core Data 中偶尔你会遇到某个特别的例外
而那对于开发者
将是非常容易识别的
那就是无法加载某个错误
为什么Core Data无法加载这个错误呢?
好了 正如我早些时候提到的在延迟加载对象方面
Core Data 是非常积极的您在内存中
将只有对象图中的一部分而且当我们试图遍历一个关系时
我们将可以回到磁盘
并发现那个对象已经被删除了
什么是比遇到例外更好的事情？
有很多
我们已经在
NSManagedObjectContext上面
推出了一个新的属性
它让你能够设置一些基础的
faultingDelegatedAPI
目前
shouldDeleteInaccessibleFaults
默认为 yes
如果我们遇到一个错误我们将把它标记为deleted
而任何缺失的属性都将是null或0
这让您的app持续这一对象
并将其当作一个已被删除的对象处理
您将不会再崩溃但是您将可以继续下去
并且向用户展示他们预期将会看到的东西
现在关于
NSPersistentStoreCoordinator
我们要介绍两个新的 API
我们推出了这两个新的API是因为我们发现开发者
在如何清理他们的持久存储方面存在问题
你们中的一些人做过这样的事情
您已经经过或绕过Core Data API 层
而直接操作你的数据库
不幸的是带来了意想不到的后果
您可能让坏卷描述符保持开放状态
所以我们为您提供了
destroyPersistentStoreAtURL
就像 addPersistent StoreAtURL一样
你做出了同样的选择
而且你可以破坏那一持久存储区
而我们将遵守所有的锁定协议
并将所有相关文件清理出来放到您已选择使用的
特定类型的存储区
以那种同样的方式
我们推出了replacePersistentStoreAtURL
这和破坏的模式类似而如果目标数据库并不存在
我们将只须把它复制到位即可
一个大家都曾遇到的问题是副本
一个带有副本的数据库是无用的
你已经写了大量的代码
来确保你没有副本
这里 Core Data也可以帮你
首先让我们看下为了发现副本
你们可能已用过的常见模式
即“寻找或创建”模式
在这里 如你所见我建立了一个读取请求并且
我必须寻找一个特别的对象
看它是否存在然后才能创建它
如果它确实存在 我就更新它
不过这种模式可能是相当有风险的而且如果我有
来自于多个数据源的线程的话它可能导致多个副本
而Core Data今年已为您提供了保护
只须告诉我们在一个实体内的哪些属性应是唯一的
我们就将确保该实体的所有实例
都保持那一唯一属性不管它是电子邮件 零部件编号
通用产品代码 等等我们将确保它在
它在所有实例中都是唯一的
当唯一实例唯一约束条件
被用于对象创建后的未被修改的数值时
是最佳的
通常当你创建对象的时候这些唯一约束条件
应被一次性设定然后在对象存续期间永不更改
更改它们可能导致冲突
因为您的唯一属性可能会与
有同样的唯一属性的另一个对象冲突
那时候您就可以使用我们之前
在合并策略中讲到的恢复方法
来解决那些问题
此外 任何从具有唯一约束条件的父实体
继承的实体也将继续那些约束条件
在上面的例子中您可以看出父实体有一个已被确认的
UUID约束条件作为唯一约束条件
子实体已经添加了电子邮件
作为对其唯一约束条件的补充
现在我想为您快速展示一下
如何利用唯一约束条件
那么这里我们将使用食谱 app我们前些年一直在为您展示
可以在开发者门户将其下载
我们增加了一个新性能即右下方的 import 导入
这让我可以导入任何我喜欢的
与苹果相关的食谱
这里我们回退你看到我增加了
所有我喜欢的苹果食谱然而我的 UI 并不是非常直观
用户在点击的时候
可能会怀疑哪里出错了
不幸的是他们已复制了他们的数据
这里我们可以有很大的改善
让我们回到 Xcode并看一下我们的对象模型
而这里我们在设置我们的实体我将选择一个食谱
而现在我这里有了一个新选择
就在右边叫做 unique 唯一
这让我指定那些属性
对于这个特定实体是唯一的
在此例中我们将有源 ID 和永久性 ID
那么现在当我运行这个食谱app时
我们将看到我有一个原始清单
我可以把它导入然后选择我的苹果食谱
但是我也缺乏耐心
没看到任何 UI所以我不断点击
这次我们有了单一对象代表它们全部
不必寻找或创建任何副本任何代码
您的唯一约束条件确保了您的唯一性
然而有了所有那些副本并不是理想的
删掉副本可能需要做大量工作
这时候就要斯克特 佩瑞出场了
他将向我们展示我们对此能做些什么
谢谢 瑞西！
那么假如您已经有了一个app
而且您已经有了所有这些已被复制的数据
现在您必须把它们全部删除
今天您必须要做的是将它们全部从内存中提取出来
抱歉 是从存储中...一旦它们进入内存
你将它们标记以便删除然后您必须将其
存储到持久性存储中如果您有很多对象
您将不得不一次又一次地删除
以维持足够低的内存占用
让您的 app 维持活跃状态
若只是为了将它们删除而将对象加载到内存中
似乎有点愚蠢
今年我们已推出了一种新的 API
它的形式是NSBatchDeleteRequest
NSBatchDeleteRequest的工作原理
类似于NSBatchUpdateRequest
在于它直接在持久性存储中发挥作用而无须向内存中加载任何对象
你可以使用NSFetchRequest的一个实例创建它
指定一个实体一个或更多的存储
并使用predicate来源或限制来分割数据
以您希望的任何方式
批删除请求会返回一个方框型
NSBatchDeletesResult
而你可以对请求进行配置
以便返回一个默认的成功或失败
被删除的对象的总数
或该方框中的对象的对象ID
这样的做法有几个限制
因为对象都没有被加载到内存中
更改并没有别反映到上下文中
而且您的验证规则都没有被运行
各种关系将被酌情删除或作废
但是那是你得到的所有保证
也有“无对象通知”
我们认为这对有大量副本的人们
将确实是有帮助的
现在我想为大家展示它如何工作
那么我这里有同样的食谱 app
而且带有一份从我的经理那里拷贝来的数据库
他说他的一个孩子拿到了它
并且添加了大量的食谱比如数以千计
如果我们以旧的方法检查它
那么我们将只是用一个读取请求
读取我们想要删除的所有对象
然后对它们全部进行迭代删除它们
然后以我们设置的每批1000的规模
保存更改
如果您试着这么做
我们可以在这里的控制台看到它会耗费一点时间
你可以看到我们在...
由于我们在进行以成千上万计算的批处理
我们现在正在进行第一批现在仍在进行中
这会耗费一点时间我们将不会站在这里等着它
如果我们在一个合适的点闯入我们可以强制停止app
并再次尝试使用批删除
让我们把这些删了
使用与我们之前使用的同样的读取请求
建立一个重复删除请求然后我们
将选择一个计数器resultType
以便我能够看到我们做了些什么
这里我们将执行它
它的代码少得多而且只有一个执行请求
没有循环没有与对象的互动
如果我们运行这段代码
...我们将回到这里
这里你可以看到在查询语句中编辑器
建立了一个触发器它删除了所有
需要被清理的关系我们也就完成了这点工作
回到下边简单地看一些食谱
那么现在我们就可以应用这些唯一约束条件了
那就是NSBatchDeleteRequest
接下来我想谈一下模型的版本控制model versioning
当我们创建新版本的食谱app时
为了支持“导入”这一特性
我们不得不对食谱实体添加两个属性
来源以及外部 ID瑞西 早些时候给大家演示过了
在进行这个工作期间我们打开了模型
添加了两个属性然后构建并运行
我们立刻就遇到了错误
我突出显示了最重要的部分
我们遇到了一个迁移问题因为版本已经发生了变化
但是我忘记加入起初的源模型
因为我们就是在它基础上做出更改的
而为了创建新模型而复制旧模型的模式
确实不方便
进行您的app的迭代
而如果您忘记将某个模型部署到运行该版本的客户手中
那确实是危险的
这似乎就是自动的轻量级迁移为您发挥作用的时候了
现在我们的 iOS 9和 OS X11
有模型缓存功能
不管你何时创建或迁移存储
或者仅是在新的 iOS 上
打开较旧的模型用来创建它的受管理的对象模型
被缓存到存储内并且当轻量级迁移任务
它们无法找到合适的源模型的时候
这可以作为一种最后一搏的尝试
有几个限制
这只适用于 SQLite 存储
而且对重量级迁移
不提供缓存版本
如果您在进行重量级迁移那您就该让您的版本准备就绪
因为您需要知道您的迁移是来自何方 去往何处
瑞西 稍早时谈到了我们添加的 API
而我现在想谈的是一些变化
对于 iOS 9 和iOS X 1010
Core Data采用了您已经在
Objective-C中看到的所有语言特性
包括泛型和空值
我们也利用了一个调用的新属性它让向下转换变得容易一些
您在其他讲座里面可能没有看到
但这对Core Data来说确实是方便的
因为如果你正在与一个对象类型ID互动
您可以将其向下转换到甚至完全不适合的类型
你可以为某个类型设置属性
但是它只能被向下转换到该种类型的子类型
这将会在编译器上为您的代码增加很多安全性
因为当一个缓存似乎毫无意义时
它会限制发出警报
为了使用泛型已生成的子类也已被更新
以便满足大量的关系以及空值的需求
而且我们已经对子类的生成机制
做出了一些其他的更改
在 Xcode 6 中您会有一个执行文件
和一个头文件用于使用同时包含Core Data声明
和放置您的所有代码的空位的Objective-C
它被用过之后就被扔掉了
但是如果你更改了自己的版本
更新日期就会变得有些不方便
因此在 Xcode 7 中我们增加了一个新的文件
这个文件是一个扩展或类别
取决于头文件中
包含所有你熟悉的声明的语言
那么现在 头文件和执行文件是属于你自己的
不管你何时更新模型你所需做的就是更新这个文件
关于变化就说那么多
我想谈一下我们弃用的东西
我们将在 iOs9 和OS 1010 中
去掉confinementConcurrency
它已经被标为“弃用”我们将在以后去掉它
因为对于新的受管理的对象上下文
Confinement是默认行为因此我们也已经将其弃用
因此未来您将使用init concurrencyType
为您的上下文使用
专用队列或主队列
如果您已经
进行到了区块 API这确实是一个不错的主义
封装操作大大简化了您对
自己的模型代码的推演而对CoreData的并发性调试支持
也增强了很多
我强烈建议查看在线文稿
今年 Core Data指南已被彻底更新
而 亞當·斯威夫特 也介绍了区块 API
他在 WWDC 2011 中的
《Core Data on iOS中的新内容》
讲得确实不错
最后我想谈一下性能
随着时间推移我们开始为模型增加属性
由于这些年对我们的app不离不弃您的用户携带的数据量在增大
而我们试图查询和显示数据的方式
也在变得更加有趣 更加先进
我们的 app 也在维持很快的速度
但是您怎样避免突然出现性能问题呢？
在开发过程中您处理的是
已知的可能较小的数据集
比您的客户将要处理的要小
而模拟器又比仅仅维持设备运行所需快得多
尽管它对开发非常有帮助
用户将会使用带有生产数据的设备
幸运的是我们提供一些工具
让您发现能够表明性能问题的模式
因此在它们在您的客户手里成为问题之前
您就可以解决它们
我想讲三个需要注意的事情
首先是关系错误
这是 Core Data 工具
我们刚刚运行了食谱 app
在缓存缺失的工具项目下我们立刻看见
我们在三个想要显示的对象上的缓存丢失了
如果我们查看中间的那一列我们会看到它们的食谱类型
而现在你还记得我们今年开发这个食谱 app 时
我们对其进行了更新以便让主列表视图
在显示食谱本身的同时显示食谱的类型
但是我们从未更改读取请求
我们可以通过向我们用来查看
NSFetchResultsController的
查询命令增加一个
relationshipKeypathsForPrefetching
来解决这个问题
现在 那些-那第一组
丢失的缓存将不再是个问题
如果我们回到同样的工具
并且在稍后时再看下app里面
我们可以看到当我们查看一个食谱的详情时
我们也引发了几个
对数据库的查询
这是因为详情查询控制器从列表获得模型对象
然后在详细视图里面我们显示
那个食谱中的所有原料
我们不能使用预读取操作
因为那样我们将预读取列表视图中显示的
所有食谱的所有原料
在详细视图中在控制器中
我们必须执行另一个读取请求以便让那些原料出现在内存中
现在我们已经将9个查询变成1个
而我们仍能在食谱上使用这一关系
对其遍历并且与它返回的数据集互动
因为数据是在多个对象间共享的
最后如果我们看一下Core Data 工具视图中的
读取工具我们可以看到
第一个读取请求花费的时间超过了我们的预期
它读取了 85 个对象
当时我们只有 85 个对象
如果我们有3万个对象的话就像我在的示范中演示的那样
这将确实是糟糕app 甚至很可能不会启动
在 Mac Pro上它花费了15 毫秒
那在 iOS 上会有大量的掉帧
那么为解决这个问题我们能做的就是增加
我们向读取结果控制器输入的读取请求的批的大小
以便让对象仅按显示的需要从存储读取
我想展示的最后一项内容是...sequence blocking
如果您的读取确实复杂且耗费大量时间
那么您可以通过在程序上使用这个参数找到它们
而它会在您的读取请求运行的同时
开始输出相关数据
这种情况下我们有一个查询而它所花费的时间
大约是十分之一秒
返回了 85 行结果
那是相当慢的
我们将看一下如何做得更好
如果我们向控制台的更高处滚动
我们看到它输出了我们正在使用的文件
我们可以使用SQLite连接那个文件
以便弄清楚正在发生的情况
如果我们把查询粘贴进去
在 EXPLAIN QUERYPLAN之后
SQlite将告诉我们它将试图做些什么
以便用这个图表来回答我们的查询
这里有几个需要注意的事情
我们可以将其作为衡量性能如何的度量指标
第一个是扫描表扫描表就是说SQLite
将触探每行内容 检查每行内容以完成查询
而在食谱表里面就像是稍早些时候一样
我们有 3 万行内容而我们将进行两次检查
因此那将不会太快
我们将进行考查 让它变得更好
此外 我们还使用临时 B 树
在这一步 SQLite利用数据创建其自身的内存架构
以便实现排序或快速搜索
现在使用临时 B-树是因为这里的这个group by
如果我们更仔细地看一下
它是因为外部 ID 中的来源
通过使用复合索引我们应能够让这个过程加快
在Core Data模型编辑器中我们可以在这里的右侧
添加一个复合索引
现在如果我们退出 SQLite重建我们的项目
执行迁移并且用SQLite连接到新的数据库
我们会发现我们正在使用索引
使用索引意味着搜索将会很快
使用覆盖索引更快这意味着那一步的结果
是按照下一步需要的自然顺序排列的
因此我们已经完全清除了临时 B 树
但我们仍有这个扫描表
在这种情况下我们将匹配重复对象
这是我们在示范中使用的查询目的是找到需要删除的对象
它必须扫描整个表格它的速度是可以更快的
剩下的唯一要做的事是确保我们不碰主线程
在此例中我们将使用一个专用队列上下文
但是如果您打算创建某些复合数据
以便向用户展示
您可能希望使用这个同步读取请求
它将在主线程工作的时候离开主线程
然后当得到结果的时候再返回
那么这些就是在您的 app 中需要留意的三种主要模式
它们让您能够在性能问题
真正成为问题之前解决它们
关于今年CoreData中的新内容就讲到这里
如果您发现任何问题请将其提交
对立刻重新写出的示例app代码有一个奖励
它的错误会最先得到修复
但是我们也有兴趣听到
你们希望在Core Data中看到的东西
功能上的要求 改善方面的想法而如我所言
今年的文稿指南已全部经过修改因此如果您发现任何相关问题
我们也将乐于了解
如需更多信息请访问开发者门户
我们的文稿以及示例代码
您可以在开发者论坛或通过 DTS 获得支持
感谢您的莅临！