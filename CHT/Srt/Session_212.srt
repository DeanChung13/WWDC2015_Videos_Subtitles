00:00:29.863 --> 00:00:30.964 
大家好

00:00:31.031 --> 00:00:32.698 
我的名字是布蕾特妮·佩因

00:00:32.766 --> 00:00:36.003 
接下來你們將和喬恩·德拉蒙德見面

00:00:36.336 --> 00:00:38.372 
我們是
SpringBoard團隊的工程師

00:00:38.739 --> 00:00:41.542 
今天我們主要想
和你們聊聊怎麼調整你的app 

00:00:41.608 --> 00:00:44.478 
以運用iPad和
iOS 9上多任務處理功能

00:00:46.513 --> 00:00:49.883 
這是多任務處理系列中的第三個講座

00:00:50.317 --> 00:00:52.786 
很可惜前面兩個已經結束了

00:00:52.853 --> 00:00:56.290 
如果你們還沒來得及收看的話 
應該去看一下

00:00:58.392 --> 00:01:00.694 
那麼我今天有很多話要說
喬恩也是

00:01:00.761 --> 00:01:02.663 
我們會講得很快

00:01:02.729 --> 00:01:03.730 
請注意聽

00:01:05.566 --> 00:01:07.367 
所以這就是你的app

00:01:07.568 --> 00:01:13.307 
在iOS 8中你的app 
支配了你的整臺儀器

00:01:13.373 --> 00:01:16.944 
它可以儘量
使用儀器上所應許的系統資源分量

00:01:17.878 --> 00:01:21.782 
但在iOS 9中多任務處理
已經不再像往常一樣了

00:01:22.482 --> 00:01:26.787 
它可以也可能
在同一個屏幕裏出現更多的app

00:01:27.287 --> 00:01:30.757 
而在所有屏幕上的app
現在必須共享同一個系統資源

00:01:32.092 --> 00:01:36.730 
像是CPU GPU DISK
I/O之類的一些系統資源

00:01:36.897 --> 00:01:40.200 
隨着多個程序互相爭奪
CPU的容量而退化

00:01:40.901 --> 00:01:42.870 
讓我們以CPU爲例子

00:01:44.404 --> 00:01:46.273 
現在這個是爲了我們講座上的
新開發者們

00:01:46.340 --> 00:01:50.844 
app響應性的Holy Grail
在於能夠將你的UI更新於

00:01:50.911 --> 00:01:54.014 
每秒顯示幀數爲60幀或者60幀率

00:01:54.781 --> 00:01:57.818 
這意味着你只需大概16毫秒

00:01:57.885 --> 00:02:00.254 
來完成你所有需要的工作
並對用戶作出反應

00:02:02.990 --> 00:02:04.424 
所以如果這是你的app

00:02:04.858 --> 00:02:07.728 
比如說它在60 幀率上渲染得很好

00:02:08.027 --> 00:02:10.663 
它可以在僅僅十秒內將所有工作完成

00:02:11.665 --> 00:02:14.101 
這其中的每一幀代表一毫秒

00:02:15.536 --> 00:02:18.138 
之後 用戶將
增加另一個附帶的app

00:02:18.639 --> 00:02:21.975 
-這個app
同樣在60幀率上更新得很好

00:02:22.042 --> 00:02:25.012 
而且它在6毫秒內完成所有的工作

00:02:25.913 --> 00:02:30.017 
兩個app結合在一起
像你看到的 已經用了

00:02:30.083 --> 00:02:32.152 
我們所擁有的全部16毫秒

00:02:32.219 --> 00:02:33.921 
以能夠在60幀率上渲染

00:02:35.722 --> 00:02:37.724 
此時用戶打開一個PIP

00:02:38.058 --> 00:02:40.027 
而這個PiP也同樣運行得很好

00:02:40.093 --> 00:02:42.629 
之後他需要八毫秒來渲染他的UI

00:02:43.297 --> 00:02:45.532 
這三個apps結合在一起

00:02:45.599 --> 00:02:50.637 
在屏幕上24毫秒 而這意味着

00:02:50.704 --> 00:02:53.540 
渲染過程其實是大概在40FIPS
而不是

00:02:53.607 --> 00:02:55.242 
我們想要的60 FIPS

00:02:55.776 --> 00:02:57.277 
用戶會意識到卡頓

00:02:58.579 --> 00:03:00.614 
同樣的問題也適用於GPU

00:03:01.782 --> 00:03:05.953 
但一些系統資源比如內存會產生

00:03:06.019 --> 00:03:07.788 
一個更加不好的用戶體驗

00:03:07.855 --> 00:03:09.723 
當很多程序一起爭取它的容量時

00:03:10.591 --> 00:03:11.892 
我們再來看一下這個例子

00:03:12.492 --> 00:03:13.961 
還是這個app

00:03:14.394 --> 00:03:17.030 
這個iPad下的系統內存佔用

00:03:17.097 --> 00:03:20.234 
你可以看到在最左邊 
我們的系統正在使用用一些檔案儲存

00:03:20.734 --> 00:03:22.870 
在中間這是你的app藍色的app

00:03:22.936 --> 00:03:23.971 
也在使用一些檔案儲存

00:03:24.538 --> 00:03:26.473 
然後這些剩餘空間

00:03:26.840 --> 00:03:29.209 
這裏有很多使用空間

00:03:29.476 --> 00:03:30.677 
你可以做各種各樣的事情

00:03:32.813 --> 00:03:35.549 
之後 用戶增加了一個二級app

00:03:35.749 --> 00:03:37.718 
而這個附帶app也需要內存

00:03:38.352 --> 00:03:39.553 
但我們狀態依然很好

00:03:39.620 --> 00:03:41.855 
我們還有一點點剩餘儲存空間

00:03:42.990 --> 00:03:45.158 
然後猜猜接下來會發生什麼

00:03:46.627 --> 00:03:47.661 
PiP出現了

00:03:47.995 --> 00:03:49.196 
現在我們沒有記憶體了

00:03:49.429 --> 00:03:51.632 
當系統無法找到空間記憶體時

00:03:51.698 --> 00:03:52.999 
它必須停止一個app運行

00:03:53.600 --> 00:03:58.539 
在這種情況下
用戶被活生生地從他/她 

00:03:58.739 --> 00:04:00.374 
可以說是她的當前處境中拉出來

00:04:00.941 --> 00:04:03.210 
然後我們
又把它帶回到SpringBoard

00:04:03.544 --> 00:04:06.680 
在我看來這是一個更糟糕的用戶體驗

00:04:07.080 --> 00:04:12.553 
相比之下和當多個程序爲CPU
或者GPU競爭UI將停頓

00:04:15.289 --> 00:04:17.858 
所以你現在可能在問自己
SpringBoard是什麼

00:04:18.158 --> 00:04:22.529 
以及爲什麼SpringBoard
工程師今天會在這裏和你談多任務處理

00:04:23.030 --> 00:04:25.332 
其實
SpringBoard代表很多東西

00:04:26.366 --> 00:04:28.001 
它是主屏幕

00:04:28.068 --> 00:04:29.069 
鎖屏

00:04:29.436 --> 00:04:34.208 
圖標 壁紙 姿態系統 通知中心

00:04:34.775 --> 00:04:35.709 
控制中心

00:04:36.376 --> 00:04:37.878 
我有點兒混亂了

00:04:38.478 --> 00:04:42.683 
好吧 除此之外還有更多

00:04:43.050 --> 00:04:46.887 
但是最重要的一點
如同所有人我們是一個UI應用程序

00:04:49.089 --> 00:04:52.159 
SpringBoard
最初是多任務處理app

00:04:53.260 --> 00:04:57.231 
在iOS 9和iOS 9之前

00:04:57.464 --> 00:05:00.601 
SpringBoard 
一直被認爲在前臺操作

00:05:00.667 --> 00:05:02.769 
即使你的app可能被用戶看到

00:05:04.238 --> 00:05:09.543 
因此 我們面對和你們一樣關於
新多任務處理環境中的挑戰

00:05:11.345 --> 00:05:13.514 
應此我們一路走來學到了很多

00:05:15.215 --> 00:05:18.986 
我們想和你們分享其中一些學到的內容
這樣你們就不會犯同樣的錯誤

00:05:20.687 --> 00:05:21.855 
我們開始吧

00:05:21.922 --> 00:05:25.359 
最簡單的
第一部分是優化你的app

00:05:26.627 --> 00:05:31.465 
第一件事用泄露工序找到
並修復電腦的內存泄露問題

00:05:33.233 --> 00:05:35.435 
你們當中
有多少人忘記寫DIALEK了

00:05:36.937 --> 00:05:38.338 
應該有更多的人舉手

00:05:39.540 --> 00:05:41.208 
好吧 我忘了

00:05:41.275 --> 00:05:42.709 
發生在我們大多數人身上

00:05:42.876 --> 00:05:45.712 
而泄露工具可以幫助你找到這些問題

00:05:45.779 --> 00:05:47.214 
然而它們通常很容易被修復

00:05:48.982 --> 00:05:52.085 
但防止內存泄露問題
的最好方式是用Swift

00:05:52.419 --> 00:05:53.520 
你們應該用那個

00:05:55.656 --> 00:05:58.825 
最後 你應該用定位工具來尋找

00:05:58.892 --> 00:06:01.662 
並修復保留週期和無限內存增長

00:06:02.729 --> 00:06:06.200 
最後 你應該用實時分析工具來尋找

00:06:06.266 --> 00:06:07.467 
和修復低效的電腦算法

00:06:08.802 --> 00:06:11.572 
我不會在今天討論這些問題

00:06:11.638 --> 00:06:15.042 
這些問題
都會發生在所有的apps不僅是

00:06:15.142 --> 00:06:16.577 
多任務處理的apps而已

00:06:17.878 --> 00:06:19.379 
反之 我們會注重於

00:06:19.446 --> 00:06:22.049 
新的多任務處理環境中最重要的事情

00:06:22.749 --> 00:06:26.887 
在我們的經驗裏我們學到最深的一課是

00:06:26.954 --> 00:06:29.256 
良好的表現需要權衡

00:06:30.090 --> 00:06:32.926 
你是打算預期計算你的數據
然後存在記憶體裏

00:06:33.460 --> 00:06:36.263 
還是打算聯機計算並使用CPU

00:06:37.264 --> 00:06:40.501 
你是打算把所有資源都存在
本地的磁盤裏

00:06:40.834 --> 00:06:43.904 
還是把它們存在cloud裏
然後想用的時候隨時都可以取得

00:06:44.638 --> 00:06:48.775 
你想要在CPU還是GPU上
運行動畫

00:06:50.410 --> 00:06:52.446 
我們來看一個關於我們之前做過的一個

00:06:52.513 --> 00:06:54.448 
叫IconReel樣本app的例子

00:06:56.483 --> 00:06:58.185 
所以這是我們app最開始的狀態

00:06:58.952 --> 00:07:00.754 
它最初有很多圖標

00:07:01.221 --> 00:07:04.258 
當用戶點擊某圖標時 我們將圖標放大

00:07:04.324 --> 00:07:05.559 
來呈現一個更詳細的視圖

00:07:06.460 --> 00:07:08.896 
底部有一個dock欄

00:07:08.962 --> 00:07:11.498 
用戶可以在這裏保存他們 喜歡的圖標

00:07:11.999 --> 00:07:15.068 
當一個用戶添加更多的圖標時
我們會添加更多的頁面

00:07:15.135 --> 00:07:17.070 
這時用戶可以頁面之間滑動

00:07:18.372 --> 00:07:19.907 
有人覺得這個很眼熟嗎

00:07:21.942 --> 00:07:23.177 
是的 是故意的

00:07:24.378 --> 00:07:26.713 
所以 我們可以保留所有的圖標

00:07:26.780 --> 00:07:29.983 
內存中是因爲每個圖標僅爲約60KB

00:07:30.417 --> 00:07:33.153 
我們會將它們全部存在一個擴展裏面

00:07:34.087 --> 00:07:35.656 
結果就是滑動很棒

00:07:36.323 --> 00:07:38.692 
爲什麼呢 
因爲我們沒有其它可以滑動的屏幕

00:07:39.660 --> 00:07:42.262 
所以我們部分用戶喜歡添加更多的圖標

00:07:42.763 --> 00:07:46.333 
所以我們向記憶體中添加更多的圖標

00:07:46.667 --> 00:07:48.368 
目前爲止滑動還是可以的

00:07:49.570 --> 00:07:51.672 
那麼 這個動畫可能看起來眼熟

00:07:51.905 --> 00:07:53.507 
那是因爲有很多apps 

00:07:53.574 --> 00:07:55.209 
有像這樣的一個動畫

00:07:55.709 --> 00:07:59.246 
想一下在一個照片
或開發視頻app中的照片滑動

00:08:00.214 --> 00:08:02.149 
你的app裏也許有一個類似的動畫

00:08:03.851 --> 00:08:04.852 
一切都很好

00:08:04.918 --> 00:08:07.421 
一些我們很好的用戶甚至下載了

00:08:07.487 --> 00:08:08.622 
更多圖標

00:08:09.089 --> 00:08:12.759 
我們現在的擴展裏有更多的圖標

00:08:13.160 --> 00:08:15.829 
且結果是滑動依然很完美

00:08:16.930 --> 00:08:20.901 
也就是說 直到我們在
某時看到IconReel死機

00:08:21.368 --> 00:08:24.538 
以及在一個多任務處理環境下
我們有時能看到彼此的

00:08:24.605 --> 00:08:26.306 
前臺apps死機

00:08:27.040 --> 00:08:29.443 
我們來看一看這裏發生了什麼

00:08:30.711 --> 00:08:33.614 
我們用一個實時分析器追蹤看到CPU

00:08:33.679 --> 00:08:35.515 
和磁盤I/O在滑動時最小化了

00:08:36.582 --> 00:08:39.886 
但定位工具告訴我們我們的記憶體使用

00:08:39.953 --> 00:08:43.490 
其實是非常高的
因爲我們所有圖標都在記憶體裏

00:08:45.993 --> 00:08:50.130 
這裏的情況是IconReel在快速
地消耗可用的系統記憶體

00:08:50.497 --> 00:08:52.633 
而當系統內存短缺時

00:08:53.300 --> 00:08:54.434 
它試圖釋放一些空間

00:08:54.501 --> 00:08:57.571 
如果它找不到任何空間
那麼它必須終止程序

00:08:58.405 --> 00:09:00.607 
有時這意味會終止IconReel

00:09:01.141 --> 00:09:03.877 
而有的時候這意味着
終止其它前臺app

00:09:04.344 --> 00:09:07.214 
但上述所有的情況
都是一個非常糟糕的用戶體驗

00:09:07.314 --> 00:09:08.682 
我們想避免這個情況

00:09:10.317 --> 00:09:12.853 
作爲一個良好的多任務管理
公民IconReel需要

00:09:12.920 --> 00:09:14.955 
管理好它的記憶體使用這樣的話所有

00:09:15.222 --> 00:09:19.493 
屏幕上的apps可以共存
並創造很好的用戶體驗

00:09:19.560 --> 00:09:20.894 
這也是我們用戶所期望的

00:09:22.462 --> 00:09:25.332 
這就將我們帶到了工作集的概念上來

00:09:27.267 --> 00:09:29.436 
你可以做的最重要的一件

00:09:29.503 --> 00:09:32.272 
優化你記憶體使用的事就是理解

00:09:32.339 --> 00:09:33.540 
並管理你的工作集

00:09:35.242 --> 00:09:37.744 
你的工作集應該只由重要的東西

00:09:37.811 --> 00:09:40.113 
和你的app目前所需資源組成

00:09:42.216 --> 00:09:43.684 
你應該讓它保持小一些

00:09:43.750 --> 00:09:45.118 
來確保你的低記憶體使用

00:09:46.987 --> 00:09:48.889 
它有可能會根據環境變化

00:09:48.956 --> 00:09:51.625 
比如 你的工作集可能包含不同對象

00:09:52.092 --> 00:09:53.427 
當一個在前臺的app

00:09:53.760 --> 00:09:56.964 
和一個在後臺的app相比它可以改變

00:09:57.030 --> 00:09:58.365 
當你改變視圖控制器時

00:09:59.933 --> 00:10:02.202 
最後 你不應該讓其無限增長

00:10:02.636 --> 00:10:04.638 
我們看過當系統沒有記憶體時候的情況

00:10:05.138 --> 00:10:06.573 
我們不想你成爲那個app

00:10:08.408 --> 00:10:10.577 
讓我們
看一下IconReel的工作集

00:10:11.044 --> 00:10:12.246 
在最後一個例子的尾端

00:10:12.312 --> 00:10:16.550 
IconReel的工作集就是
我們在記憶體中保留的那個圖標

00:10:17.017 --> 00:10:19.052 
這是最好的工作集嗎

00:10:20.387 --> 00:10:21.221 
不是

00:10:21.788 --> 00:10:23.824 
那麼我們現在真正需要做什麼

00:10:25.225 --> 00:10:29.496 
現在我們真正需要的是
用戶正在看的圖標屏幕

00:10:30.197 --> 00:10:31.832 
所以這是一個更優秀的工作集

00:10:33.333 --> 00:10:36.436 
那麼現在我們來試一下滑動我們

00:10:36.703 --> 00:10:38.372 
只有一頁圖標的工作集

00:10:41.708 --> 00:10:43.644 
噢 噢 好吧

00:10:43.944 --> 00:10:44.978 
這太糟了

00:10:45.145 --> 00:10:47.147 
而且如果你因爲我站着
擋住了你沒有看到

00:10:48.815 --> 00:10:50.250 
那個滑動十分糟糕

00:10:50.317 --> 00:10:52.619 
有一個多秒的停留在

00:10:52.686 --> 00:10:54.421 
滑到下一頁看到圖標時

00:10:55.989 --> 00:10:58.091 
我們來看看發生了什麼

00:11:00.127 --> 00:11:02.129 
我們用另外一個實時分析器

00:11:02.529 --> 00:11:06.300 
然後我們看到CPU
而磁盤I/O 事實上在滑動中非常高

00:11:06.934 --> 00:11:10.470 
而分配顯示我們的記憶體使用非常低

00:11:11.405 --> 00:11:14.508 
這個恰恰是我們剛剛發生相反的問題

00:11:15.709 --> 00:11:19.112 
就像我說的
良好的運行包括進行一系列的權衡

00:11:19.947 --> 00:11:21.615 
我們如何能修復這個

00:11:22.950 --> 00:11:25.219 
答案是更好的管理我們CPU的時間

00:11:26.720 --> 00:11:28.255 
所以你能做的最重要的事

00:11:28.322 --> 00:11:30.357 
就是能夠讓你的app反應做的工作

00:11:30.457 --> 00:11:32.993 
在你的主流程上越少越好

00:11:34.061 --> 00:11:37.097 
主流程最優先的事情
就是對用戶時間做出反應

00:11:37.464 --> 00:11:39.800 
在你的主流程上做不必要的工作意味着

00:11:39.867 --> 00:11:43.003 
主流程有更少的時間來響應用戶事件

00:11:44.605 --> 00:11:46.940 
因爲你在分享CPU
時間給所有的apps

00:11:47.007 --> 00:11:49.276 
在屏幕上你需要特別謹慎

00:11:49.343 --> 00:11:50.711 
應對你的主線程在幹什麼

00:11:51.645 --> 00:11:54.615 
所有在主線程上進行的沒有直接

00:11:54.681 --> 00:11:57.484 
響應用戶事件的工作應在別的地方進行

00:11:59.419 --> 00:12:02.990 
什麼工序是
我們可以用來保證我們不斷地響應

00:12:03.056 --> 00:12:04.992 
用戶時間但同時確保我們可以

00:12:05.058 --> 00:12:06.159 
及時地做其它工作

00:12:07.828 --> 00:12:10.764 
那麼
答案就是我們可以用GCD和服務質量

00:12:12.165 --> 00:12:15.269 
在WWDC
2014時有一個很棒的演講

00:12:15.736 --> 00:12:19.339 
而在來臨的週五會有一個
關於GC和服務質量很棒的演講

00:12:19.406 --> 00:12:21.208 
所以我不會在這裏細說

00:12:21.775 --> 00:12:23.443 
它們是非常重要的兩個東西

00:12:24.044 --> 00:12:26.713 
第一件事是你的主流程正在

00:12:26.780 --> 00:12:29.683 
最高優先地運作
而那個就是用戶交互優先權

00:12:30.918 --> 00:12:33.120 
另外一件事是

00:12:33.187 --> 00:12:34.788 
服務質量的頻率在

00:12:34.855 --> 00:12:36.590 
所有前臺應用中分享

00:12:37.257 --> 00:12:41.094 
這樣每個人的用戶發起的隊列
將有相同的機會接觸到CPU 

00:12:41.161 --> 00:12:44.198 
而每個前臺隊列
也有相同的機會接觸CPU

00:12:44.565 --> 00:12:48.735 
沒有一個前臺的app比
另外的跟有優先權

00:12:49.203 --> 00:12:51.405 
如果你能適度的優先你係統的工作

00:12:51.705 --> 00:12:54.942 
那麼系統就可以保證我們能夠

00:12:55.008 --> 00:12:57.144 
在屏幕上
有多重apps操作時得到最佳運作

00:12:58.946 --> 00:13:00.714 
所以這個和IconReel有何關係

00:13:01.682 --> 00:13:06.119 
我們會在一個不同的流程上
使用GCD加載圖標

00:13:06.186 --> 00:13:08.222 
在用戶發起的服務質量上

00:13:09.156 --> 00:13:12.092 
我們要做的第一件事 建立調度隊列

00:13:12.459 --> 00:13:15.362 
這個叫做圖標生成隊列

00:13:16.129 --> 00:13:19.566 
當我們在主流程時我們會異步調度

00:13:19.633 --> 00:13:22.836 
在我們的圖標隊列中生成
在下一個界面生成每個圖標隊列

00:13:23.904 --> 00:13:26.240 
雖然在代碼片段中並不明顯

00:13:26.507 --> 00:13:29.776 
但是從主流程中異步調度工作到一個

00:13:29.843 --> 00:13:33.247 
像這樣給質量服務降級的隊列

00:13:33.480 --> 00:13:38.018 
到第二高的服務質量
的用戶發起服務質量中去

00:13:39.720 --> 00:13:44.525 
所以這個代碼能夠有效地
在用戶發起服務質量中加載所有圖標

00:13:45.859 --> 00:13:47.694 
好 現在讓我們再試着滑動一下 

00:13:50.764 --> 00:13:52.466 
好的 這好多了

00:13:53.433 --> 00:13:54.868 
如果你的設計行得通

00:13:54.935 --> 00:13:57.938 
這樣你和你apps就能使用這個方案

00:13:58.238 --> 00:14:01.074 
比如說你可以一邊展示你的佔位圖片

00:14:01.175 --> 00:14:02.543 
一邊等待真正的內容加載出來

00:14:03.277 --> 00:14:06.313 
但IconReel的設計不允許這樣

00:14:06.380 --> 00:14:10.317 
我們必須有已經加載好的圖標
在它已經在屏幕上滑動之前

00:14:11.718 --> 00:14:14.087 
所以我們真正需要的是找到一個方式

00:14:14.221 --> 00:14:17.191 
來暫時促進圖標生成隊列

00:14:17.491 --> 00:14:19.860 
在主流程中達到同樣優先權

00:14:20.194 --> 00:14:22.262 
就在界面滑動圖標之前

00:14:22.329 --> 00:14:24.998 
這樣它可以更快地完成圖標生成

00:14:26.166 --> 00:14:27.734 
還有另一種方法是

00:14:28.535 --> 00:14:30.838 
使用服務質量覆蓋

00:14:32.606 --> 00:14:38.645 
當我們有這一類型的倒置時
例如有個高優先權流程或隊列被阻礙而

00:14:38.712 --> 00:14:42.049 
等待一個低優先權流程或列隊來完成一
些工作這個會非常好用

00:14:42.983 --> 00:14:45.385 
而最酷的部分是

00:14:45.452 --> 00:14:47.921 
如果你給系統提供足夠的信息

00:14:47.988 --> 00:14:49.957 
服務質量覆蓋便可以自動生成

00:14:50.858 --> 00:14:54.228 
你可能在想 布蕾特妮
我怎樣才能給系統

00:14:54.294 --> 00:14:55.329 
提供足夠的信息

00:14:56.563 --> 00:14:57.831 
這裏有一個好用的表格

00:14:58.966 --> 00:15:00.701 
再說一遍 去年的演講和

00:15:00.767 --> 00:15:03.303 
這週五的演講會更深入地講解這個

00:15:04.004 --> 00:15:06.707 
但今天講的是調度組等和

00:15:06.773 --> 00:15:09.743 
調度信號等不會是你們要的東西

00:15:10.210 --> 00:15:12.980 
你應該爲了這些功能的使用
審計你的代碼

00:15:13.313 --> 00:15:15.282 
然後意識到他們不會

00:15:15.349 --> 00:15:16.850 
在優先倒置中修復這些類型

00:15:18.719 --> 00:15:21.154 
那麼讓我們看一下我們
在IconReel上會怎麼做

00:15:21.688 --> 00:15:26.560 
當在屏幕上圖標滑動的 第一行之前

00:15:27.361 --> 00:15:28.562 
在主流程上我們會

00:15:28.629 --> 00:15:32.132 
同步調度這個空阻塞到
我們的圖標隊列中區

00:15:32.766 --> 00:15:37.371 
我們需要做的是
增強圖標隊列的優先權

00:15:37.437 --> 00:15:39.373 
來和主流程的優先權匹配

00:15:39.439 --> 00:15:41.241 
直到阻塞被執行

00:15:41.341 --> 00:15:43.377 
在圖標隊列的點

00:15:43.443 --> 00:15:45.012 
會回到其正常優先權

00:15:46.079 --> 00:15:48.982 
現在我們來看一下滑動
以及它們是什麼樣的

00:15:54.488 --> 00:15:58.192 
對 很好 一個很好的慢滑

00:15:59.459 --> 00:16:03.163 
我們現在來試一下慢滑之後快滑

00:16:07.601 --> 00:16:10.904 
我的天 我們又回到最初的狀況了

00:16:11.038 --> 00:16:12.406 
就是當到了下一頁的時候

00:16:12.472 --> 00:16:14.575 
在屏幕上有一個停頓

00:16:15.509 --> 00:16:16.410 
現在怎麼辦

00:16:18.011 --> 00:16:19.813 
這裏有一個規律

00:16:20.080 --> 00:16:23.217 
將工具再次拿出來
我們拿出另外一個追蹤

00:16:23.417 --> 00:16:25.419 
這次我們還有一個計算器

00:16:25.953 --> 00:16:29.857 
而且我們要做一點兒計算
然後我們要找到我們不能加載

00:16:30.257 --> 00:16:34.061 
讀取圖標圖片從磁盤中 解碼圖標圖片

00:16:34.127 --> 00:16:37.397 
然後讓圖標變得好看且有時間

00:16:37.464 --> 00:16:40.167 
讓一個快速地用戶滑動到下一頁

00:16:41.435 --> 00:16:42.736 
現在做什麼

00:16:43.804 --> 00:16:46.039 
我想我們應該等更快的設備了

00:16:50.210 --> 00:16:51.612 
一些掌聲是給它們的

00:16:54.548 --> 00:16:55.482 
開個玩笑

00:16:55.649 --> 00:16:56.550 
我們可以做得更好

00:16:56.617 --> 00:16:57.651 
我們必須更聰明

00:16:58.352 --> 00:17:02.022 
數學計算告訴我們可以達到更好

00:17:02.089 --> 00:17:03.790 
的運行如果我們讓

00:17:03.857 --> 00:17:05.791 
下一頁的圖標已經在記憶體中運行

00:17:06.960 --> 00:17:09.630 
這個確保及時當你

00:17:09.695 --> 00:17:12.866 
在多重頁面中快速滑動
我們有足夠的時間

00:17:12.933 --> 00:17:15.769 
讓用戶可以再次滑動之前
加載下一頁的圖標

00:17:17.738 --> 00:17:20.707 
現在我們來增加
我們的工作集從第一頁

00:17:20.773 --> 00:17:23.609 
到第三頁 你們現在所看到的

00:17:23.676 --> 00:17:25.145 
頁面不是前一頁也不是後一頁

00:17:25.811 --> 00:17:27.381 
而我們沒有一個神奇的八球

00:17:27.481 --> 00:17:30.150 
來知道用戶會滑向哪一頁

00:17:30.484 --> 00:17:33.954 
所以擁有前後兩頁會是最佳的選項

00:17:35.722 --> 00:17:37.257 
現在讓我們試着滑動

00:17:43.096 --> 00:17:44.798 
很好 這看起來好多了

00:17:45.165 --> 00:17:47.201 
當用戶到達下一頁時

00:17:47.267 --> 00:17:50.838 
我們已經在加載下一頁的圖標了

00:17:50.904 --> 00:17:54.141 
但是 這其實增加了我們的記憶體使用

00:17:54.208 --> 00:17:56.977 
當我們有僅僅一頁的工作集時

00:17:57.044 --> 00:17:58.412 
我們有記憶體佔用

00:17:58.478 --> 00:18:00.647 
現在我們有了這個記憶體的佔用

00:18:00.714 --> 00:18:03.917 
我們應該清楚
這將會如何影響其它apps

00:18:05.652 --> 00:18:10.591 
現在來看當用戶用IconReel在
屏幕上打開某二級app時會發生什麼

00:18:11.658 --> 00:18:16.196 
IconReel調整了大小
只展示了三行而不是四行

00:18:17.097 --> 00:18:20.901 
這是個重新評估我們的工作集的好機會

00:18:21.201 --> 00:18:26.273 
我們依然需要同時有三頁的
四行圖標在內存中嗎

00:18:27.140 --> 00:18:32.045 
不
我們僅僅需要同時有三頁三行的內存

00:18:32.980 --> 00:18:35.282 
高效到它看起來有點兒像這樣

00:18:36.416 --> 00:18:38.719 
現在我會手動

00:18:38.785 --> 00:18:41.788 
刪除這些多餘的圖標行

00:18:41.855 --> 00:18:43.457 
就是我們不需要用的 但是

00:18:43.624 --> 00:18:45.926 
需要很多工作來生成它們

00:18:45.993 --> 00:18:48.061 
如果不是特別需要 我不想重新做

00:18:49.029 --> 00:18:50.998 
如果有一個地方

00:18:51.064 --> 00:18:53.400 
讓我我能夠擺放這些圖標那該多好

00:18:53.500 --> 00:18:56.670 
如果系統需要內存 我們可以丟掉它們

00:18:56.737 --> 00:18:59.806 
如果系統不需要內存 
那麼它們可以留在內存中

00:18:59.873 --> 00:19:02.376 
然後我們可以再次使用它們
當我們需要它們的時候

00:19:03.043 --> 00:19:04.745 
有一種方法

00:19:04.811 --> 00:19:07.080 
就是讀取內存發出的警告

00:19:09.483 --> 00:19:13.086 
當系統低於內存限制時
會出現內存發出的警告

00:19:13.153 --> 00:19:15.722 
說你的程序正在達到它的內存限度

00:19:18.058 --> 00:19:21.728 
我非常想給你一個數字
這樣你可以選擇你的內存限度代碼

00:19:22.129 --> 00:19:23.830 
不幸的是 沒有這樣一個數字

00:19:24.464 --> 00:19:28.268 
對於每臺設備和
每個應用上下文的限制是不同的

00:19:28.569 --> 00:19:30.737 
所以我能給出的最好建議就是

00:19:30.804 --> 00:19:33.974 
讀取系統發出的警告然後採取行動

00:19:34.041 --> 00:19:36.276 
所以你應該做什麼

00:19:37.277 --> 00:19:39.780 
你應該把不在工作集的東西清理出來

00:19:39.847 --> 00:19:43.150 
這包括清理緩存數據釋放圖片

00:19:43.217 --> 00:19:44.518 
和釋放視圖控制器

00:19:46.720 --> 00:19:50.591 
這是你可以
用來讀取內存警告的APIs

00:19:50.657 --> 00:19:52.559 
然後我想說明一點

00:19:52.626 --> 00:19:54.628 
這些都不是第一次在iOS 9中出現

00:19:55.095 --> 00:19:56.496 
它們存在一段時間了

00:19:56.563 --> 00:19:58.665 
希望你們都已經使用它們了

00:20:00.234 --> 00:20:02.836 
現在
我可以檢查一個內存警告

00:20:02.903 --> 00:20:05.105 
然後手動去除那些圖標

00:20:05.205 --> 00:20:07.741 
我很懶而且我不想那麼做

00:20:07.975 --> 00:20:11.912 
如果有一個工具可幫我管理那些玩意兒

00:20:11.979 --> 00:20:13.013 
讓我不用去做就太好了

00:20:14.448 --> 00:20:17.484 
而我們也有一個這樣的工具
它叫做NSCache

00:20:18.151 --> 00:20:19.786 
它和NSDictionary很像

00:20:19.853 --> 00:20:22.389 
但它對於可以被
快速重塑的對象來說很好

00:20:23.557 --> 00:20:25.359 
它還幫你處理內存發出的警告

00:20:25.425 --> 00:20:27.861 
自動清理東西然後它

00:20:28.262 --> 00:20:32.132 
也知道應用上下文比如前臺和後臺

00:20:32.432 --> 00:20:33.901 
然後在必要的時候清理東西

00:20:35.202 --> 00:20:38.839 
它還能做很多很酷的東西
但我們今天沒有時間展開討論

00:20:38.906 --> 00:20:41.275 
不要忘了看NSCache上的資料

00:20:43.210 --> 00:20:46.847 
現在在拆分視圖上
我們可以看到IconReel

00:20:47.281 --> 00:20:49.149 
這次不把這些圖標刪除

00:20:49.683 --> 00:20:51.585 
我們把
它們放到一個NSCache裏面

00:20:52.352 --> 00:20:56.990 
實施上我們只把我們生成的每個不在
工作集中的圖標放進NSCache裏

00:20:57.724 --> 00:20:59.459 
而當我們有一個內存發出的警告時

00:20:59.726 --> 00:21:04.198 
我們可以讓NSCache做所有
清除那些不在我們工作集的圖標

00:21:06.233 --> 00:21:07.100 
讓我們回顧一下

00:21:07.601 --> 00:21:10.737 
我們從這裏開始
每個圖標都在內存裏面

00:21:10.938 --> 00:21:15.576 
所以我們的內存使用很高 且
滑動很流暢而CPU和磁盤I/O很低

00:21:16.009 --> 00:21:17.811 
但我們有時看到app崩潰

00:21:18.045 --> 00:21:19.012 
而這並不好

00:21:20.047 --> 00:21:22.382 
所以我們調整我們的工作集

00:21:22.449 --> 00:21:25.652 
到只有一頁圖標中
然後內存使用很低

00:21:25.986 --> 00:21:28.755 
但是我們的CPU
和磁盤I/O在滑動時很高

00:21:28.822 --> 00:21:30.958 
而這會產生很差勁的滑動操作

00:21:33.493 --> 00:21:36.997 
現在我們將工作集的大小變爲三頁圖標

00:21:37.464 --> 00:21:39.466 
這會給我們的內存增加一點點

00:21:39.867 --> 00:21:41.902 
然後每一個我們生成的圖標

00:21:41.969 --> 00:21:45.339 
不在工作集中我們就把它們
丟到NSCache裏面

00:21:46.006 --> 00:21:48.308 
我們增加了整體的內存的使用

00:21:48.375 --> 00:21:50.277 
但是大量增加內存的使用

00:21:50.344 --> 00:21:51.745 
已經使它能夠適應內存的限度

00:21:53.347 --> 00:21:54.882 
對於你們很多人來說 這已經很好了

00:21:55.749 --> 00:21:58.418 
如果你的app可以在
一個多任務處理的環境下運行

00:21:58.552 --> 00:22:03.090 
且在地圖上交叉運行
那麼你的狀態應該不錯

00:22:04.291 --> 00:22:07.194 
我今天展示了
一些你們的app可以做到的事情

00:22:07.261 --> 00:22:08.996 
來成爲一個優秀而多任務處理的公民

00:22:09.062 --> 00:22:12.065 
但是有些時候只靠這些事情還是不夠的

00:22:12.132 --> 00:22:14.001 
爲了和你們聊聊你們接下來可以做什麼

00:22:14.067 --> 00:22:15.836 
我想請出喬恩德拉蒙德

00:22:23.911 --> 00:22:25.679 
謝謝你布蕾特妮 大家好

00:22:27.514 --> 00:22:30.350 
看來你們已經掌控
如何使用你的app的內存

00:22:30.851 --> 00:22:32.753 
來極大地幫助你的app和

00:22:32.819 --> 00:22:33.921 
其餘系統的運行

00:22:34.188 --> 00:22:36.223 
但有些時候只靠這些知識並不足夠

00:22:36.590 --> 00:22:38.292 
如果你已經做了我們說過的所有事情

00:22:38.358 --> 00:22:41.528 
並且做得很正確 但是情況還是不對

00:22:42.296 --> 00:22:44.097 
我們將談談一些方法

00:22:44.298 --> 00:22:47.801 
讓你們的apps可以更好地
管理它們的內存佔用

00:22:49.136 --> 00:22:52.239 
首先 我想回到那個多任務管理的例子

00:22:52.306 --> 00:22:54.341 
假如我們有一個初級和一個二級app

00:22:55.142 --> 00:22:57.277 
而現在已經達到內存的極限了

00:22:57.344 --> 00:22:58.912 
接着系統會發出一個內存警告

00:22:58.979 --> 00:23:01.949 
身爲良好多任務公民apps會管理好

00:23:02.015 --> 00:23:04.117 
並清理它們的緩存和其它不需要的東西

00:23:04.518 --> 00:23:08.021 
好的 那麼現在用戶引進了一個PiP

00:23:08.355 --> 00:23:10.090 
我們有足夠的內存 這樣不錯

00:23:10.157 --> 00:23:12.426 
雖然我們還沒到達內存的極限
但我們已經接近了

00:23:13.393 --> 00:23:15.996 
現在用戶將調整那個二級app

00:23:16.063 --> 00:23:17.698 
讓其達到和初級擁有一對一的比例

00:23:19.399 --> 00:23:22.736 
因此 這將造成CPU的內存突增

00:23:22.803 --> 00:23:24.905 
這會使系統不能及時做出反應

00:23:25.172 --> 00:23:26.573 
很不幸地被逼把

00:23:26.640 --> 00:23:29.443 
初級的app終止即使它不是

00:23:29.510 --> 00:23:31.345 
內存增長的正真原因

00:23:32.045 --> 00:23:34.615 
迴歸到SpringBoard
從來就不是一個好的體驗

00:23:34.681 --> 00:23:35.983 
就像布蕾特妮剛剛展示的那樣

00:23:37.751 --> 00:23:39.152 
在我繼續講或者結束之前

00:23:39.219 --> 00:23:41.088 
我想跟你們分享一句話

00:23:43.724 --> 00:23:47.027 
那就是在
你程序之外的東西都應該被視爲

00:23:47.094 --> 00:23:49.396 
有敵意並且會毀滅你的可能

00:23:50.731 --> 00:23:52.766 
我不是故意說不吉利的話

00:23:52.833 --> 00:23:55.302 
且我也不想讓你們覺得我瘋了

00:23:55.869 --> 00:23:58.772 
但身爲一個良好的多任務管理
公民就應該適應

00:23:58.939 --> 00:24:00.641 
你身邊所有會發生的事情

00:24:00.741 --> 00:24:03.810 
有時你身邊發生的事情會很離譜

00:24:04.678 --> 00:24:06.180 
你可能覺得一切都操作得很好

00:24:06.246 --> 00:24:08.916 
但是系統可能在密謀着終結你

00:24:08.982 --> 00:24:10.984 
事情雖然不是這樣 但如果你有所準備

00:24:11.051 --> 00:24:14.354 
這將會幫助你生存

00:24:16.523 --> 00:24:17.991 
所以首先

00:24:18.492 --> 00:24:20.594 
內存是在iOS中最被約束的資源

00:24:20.994 --> 00:24:23.597 
這不是說其它資源不被約束

00:24:23.664 --> 00:24:25.832 
它們會被約束 只是它們
降級的不同而已

00:24:26.099 --> 00:24:27.601 
當系統沒有內存的時候

00:24:27.701 --> 00:24:28.869 
它就像在砸一堵牆

00:24:28.936 --> 00:24:29.803 
有些東西必須離開

00:24:29.870 --> 00:24:31.471 
它必須將內存拿回來

00:24:32.472 --> 00:24:34.141 
就像我們之前看到的例子

00:24:34.541 --> 00:24:38.679 
有時侯系統能夠
以比釋放內存更快的速度還原內存

00:24:39.112 --> 00:24:41.682 
即使我們有時間發佈一個內存警告 

00:24:41.748 --> 00:24:43.750 
並且三個apps全部都在運行

00:24:43.817 --> 00:24:46.119 
且都有時間去相應那個警告
但我們不能夠知道

00:24:46.186 --> 00:24:47.754 
它們是否有足夠的CPU循環

00:24:47.821 --> 00:24:49.756 
來做一些有意義且

00:24:49.823 --> 00:24:52.426 
可以清除足夠內存來還原內存

00:24:53.594 --> 00:24:55.796 
爲了瞭解系統是否能夠收回內存

00:24:55.863 --> 00:24:58.699 
我們需要知道內存是如何被分類

00:24:59.333 --> 00:25:01.535 
我會將其分爲三個不同的組別

00:25:01.602 --> 00:25:03.604 
第一個類別我們把它叫做髒的

00:25:04.271 --> 00:25:06.673 
這是你的程序使用時活躍的內存

00:25:06.807 --> 00:25:09.309 
這些是你的對象這些是你的堆式分配

00:25:09.576 --> 00:25:11.845 
靜態 球態和所有你緩存的東西

00:25:11.912 --> 00:25:13.413 
其實差不多所有的東西

00:25:13.514 --> 00:25:15.115 
而且這不能被系統召回

00:25:15.182 --> 00:25:16.783 
因爲這是你在用的

00:25:18.185 --> 00:25:19.720 
第二個類別叫做可清除的

00:25:20.020 --> 00:25:23.357 
這是除了髒的內存以外被明確標註

00:25:23.590 --> 00:25:25.893 
不被app使用的

00:25:25.959 --> 00:25:28.562 
這樣系統知道
當有需要的時候它可以被召回

00:25:29.563 --> 00:25:30.864 
第三種我們叫乾淨的

00:25:30.931 --> 00:25:33.800 
這是在磁盤上備份的

00:25:33.867 --> 00:25:35.669 
系統可以召回這些內存

00:25:35.769 --> 00:25:38.639 
因爲它永遠可以召回
因爲文件已經在這兒了

00:25:40.641 --> 00:25:42.543 
回到我們的系統內存條

00:25:42.609 --> 00:25:43.744 
這看起來怎麼樣

00:25:43.844 --> 00:25:46.847 
我們有一個非常非常小的內存局面

00:25:47.247 --> 00:25:48.982 
但是系統不這麼看

00:25:49.616 --> 00:25:55.088 
系統知道當它想釋放一些內存來增長時
它可以有餘地使用

00:25:55.422 --> 00:25:57.324 
而不用發佈內存警告

00:25:57.391 --> 00:25:59.126 
或要求apps來幹預

00:26:00.327 --> 00:26:05.232 
你的app的目標和適應內存的使用

00:26:05.299 --> 00:26:07.034 
就是最小化你髒的內存

00:26:07.768 --> 00:26:10.537 
而最大化你的可清除的和乾淨的內存

00:26:11.004 --> 00:26:12.573 
我們從最小化髒的開始

00:26:14.341 --> 00:26:16.009 
首先 對 少用它

00:26:16.710 --> 00:26:18.846 
我知道我站在這裏說的很容易

00:26:18.912 --> 00:26:21.281 
但如果你管理你的工作集

00:26:21.348 --> 00:26:24.017 
然後追溯你在定位的對象使用工具

00:26:24.084 --> 00:26:27.654 
來做所有的事情一旦你做好這些事下一

00:26:27.721 --> 00:26:30.357 
重新分類髒的內存爲可清除的

00:26:31.291 --> 00:26:34.461 
如果你做了這些
它可以被系統自動召回

00:26:34.962 --> 00:26:37.097 
然後這是可有可無的數據中最好的

00:26:37.364 --> 00:26:39.733 
你現在不需要的數據
也許會在未來需要

00:26:39.800 --> 00:26:42.402 
所有你可能放到一個緩存裏的事情 
比如說

00:26:43.804 --> 00:26:45.539 
我們把
這個應用到IconReel上

00:26:46.373 --> 00:26:48.308 
這個和我們中斷的情況相似

00:26:48.375 --> 00:26:51.144 
我們在工作集的兩旁有圖標的緩存

00:26:51.445 --> 00:26:52.513 
另外 只是

00:26:54.248 --> 00:26:57.484 
對於這個例子 我將再重新
把我們的數據分一下類

00:26:57.551 --> 00:26:59.253 
比起在一個每個-圖標塊上工作

00:26:59.319 --> 00:27:01.421 
我會將圖標羣分成集列

00:27:01.488 --> 00:27:04.091 
就因爲它可以在這兒變得比較輕鬆

00:27:04.491 --> 00:27:07.227 
這並不意味着會
改變我們app的動態

00:27:07.294 --> 00:27:09.563 
當用戶來回滑動
我們更新我們的工作集

00:27:09.630 --> 00:27:11.865 
有些被緩存了 有些被拉出了緩存

00:27:12.199 --> 00:27:13.233 
這都是一樣的

00:27:13.734 --> 00:27:15.335 
我們來給這個內存使用分一下類

00:27:16.737 --> 00:27:19.106 
首先 我們正在使用的內存

00:27:19.573 --> 00:27:20.541 
應被分類爲髒的

00:27:20.908 --> 00:27:21.775 
這是我們的工作集

00:27:23.243 --> 00:27:26.346 
我們所有在緩存的對象都是可以清除的

00:27:27.181 --> 00:27:29.816 
這爲我們展示了一個有趣的機會

00:27:30.851 --> 00:27:33.854 
來讓我們跟高級地分類內存

00:27:34.721 --> 00:27:40.727 
比如說 標記更多在用着的數據

00:27:40.794 --> 00:27:42.863 
或是髒的甚至有一些是在緩存裏的

00:27:43.697 --> 00:27:47.301 
這介紹了一個另一種緩存的方式

00:27:48.302 --> 00:27:50.470 
第一個那個最外的圖標

00:27:50.904 --> 00:27:52.906 
是我們最遲使用到的

00:27:52.973 --> 00:27:55.909 
我們會讓系統在它需要的時候重新召回
我們不在乎

00:27:56.810 --> 00:27:58.378 
但是我們想要確保有能力來控制

00:27:58.445 --> 00:27:59.980 
我們可能馬上用到的圖標

00:28:00.614 --> 00:28:02.983 
即使它們依然在緩存中
我們會標記它們爲被使用中

00:28:03.050 --> 00:28:05.319 
這樣系統就不會隨意拿走它們

00:28:05.719 --> 00:28:08.121 
這些是我們在
應對一個內存警告的時可釋放的

00:28:09.423 --> 00:28:10.757 
這就給了我們一個工作集

00:28:10.824 --> 00:28:12.192 
一個我們現在絕對會需要

00:28:12.259 --> 00:28:14.061 
但我們卻無法爲那個工作集做任何東西

00:28:15.395 --> 00:28:17.598 
這在多任務處理例子中是什麼樣的

00:28:18.365 --> 00:28:21.335 
我們回到那個出錯的情況

00:28:21.802 --> 00:28:22.669 
PiP進來了

00:28:22.736 --> 00:28:23.604 
我們沒有內存了

00:28:23.871 --> 00:28:25.906 
但現在系統知道初級和

00:28:25.973 --> 00:28:28.509 
二級的app是良好的多任務處理公民

00:28:28.809 --> 00:28:31.345 
它們有可以清除的內存的能力

00:28:31.545 --> 00:28:34.748 
這個系統 不用應對任何人

00:28:34.815 --> 00:28:36.517 
就可以從app中拿走

00:28:36.850 --> 00:28:38.819 
然後讓系統迴歸到一個好的狀態

00:28:40.988 --> 00:28:43.290 
但當然了 如果用戶繼續使用設備

00:28:43.357 --> 00:28:44.625 
內存將會重新增加

00:28:44.691 --> 00:28:46.093 
我們又收到了一個內存警告

00:28:46.593 --> 00:28:49.363 
但因爲那些apps只失去了
可清除的數據

00:28:49.429 --> 00:28:51.632 
它們可以自由地響應內存警告

00:28:51.698 --> 00:28:55.769 
然後清除緩存
這樣還系統一個好的狀態

00:28:57.604 --> 00:28:59.673 
在你的apps中應該怎麼用你的
可清除數據

00:28:59.740 --> 00:29:00.941 
這很簡單

00:29:01.074 --> 00:29:02.609 
這裏有一個等級是可清除的數據

00:29:02.676 --> 00:29:05.245 
然後它是一個NS不可變數據的子類別

00:29:05.312 --> 00:29:07.181 
它沒有別的性能它很簡單

00:29:07.614 --> 00:29:09.316 
唯一的分別是這三個方式

00:29:09.483 --> 00:29:11.285 
第一個就是Begin Content Access

00:29:11.351 --> 00:29:13.554 
這個告訴系統你正在使用內存

00:29:13.787 --> 00:29:15.122 
不要把它拿走

00:29:15.622 --> 00:29:18.325 
第二個方式Begin
Content Access

00:29:18.392 --> 00:29:20.027 
現在內存被認爲是可清除的

00:29:20.093 --> 00:29:21.328 
而你可能隨時都會失去它

00:29:21.962 --> 00:29:25.666 
第三個方式是斷定系統是否在你不用的
時候把它拿走

00:29:27.034 --> 00:29:29.069 
回到系統資源條上 這差不多是

00:29:30.804 --> 00:29:32.840 
布蕾特妮結束的部分

00:29:32.906 --> 00:29:33.907 
我沒有改變任何東西

00:29:33.974 --> 00:29:35.475 
這些圖形差不多一樣

00:29:35.676 --> 00:29:38.779 
不同的是我們抽取了一部分自適應內存

00:29:38.979 --> 00:29:40.581 
然後重新分類爲可清除的

00:29:41.281 --> 00:29:44.318 
這使得我們成爲一個更好的多任務公民

00:29:44.384 --> 00:29:46.920 
因爲系統可以代替我們做工作

00:29:47.454 --> 00:29:50.290 
但是有相同的本質表現性能

00:29:50.357 --> 00:29:52.125 
就是如果我失去我的可清除內存

00:29:52.292 --> 00:29:55.229 
然後我清除了我的緩存 我現在怎麼辦

00:29:55.295 --> 00:29:57.164 
我需要重塑所有 我需要的數據

00:29:57.231 --> 00:29:59.099 
及我曾經建造的但這很昂貴

00:29:59.233 --> 00:30:02.169 
磁盤I/O和CPU出現尖峯 
這樣不好

00:30:03.837 --> 00:30:06.373 
我們分析在app中使用的數據來

00:30:06.507 --> 00:30:09.343 
看是否我們可以做更多的事情

00:30:10.911 --> 00:30:13.514 
那麼IconReel使用什麼數據呢

00:30:13.981 --> 00:30:16.617 
它們是圖標 然後第一個特性就是

00:30:16.683 --> 00:30:18.085 
它們絕對重要

00:30:18.151 --> 00:30:19.820 
我們沒有圖標就沒有一個app

00:30:20.020 --> 00:30:21.788 
某時 用戶會滑動到它們

00:30:21.855 --> 00:30:23.590 
我們需要它們 無法避免

00:30:24.758 --> 00:30:26.360 
第二個它們生成用到很多內存

00:30:27.127 --> 00:30:31.231 
從磁盤中讀取它們破解它們並潤色

00:30:31.298 --> 00:30:34.134 
你想幹什麼就幹什麼
這樣費用浩大的內存

00:30:35.335 --> 00:30:37.571 
第三點 其實它們可以被預期計算的

00:30:37.638 --> 00:30:40.140 
我們將提前知道這些圖片會怎樣

00:30:40.507 --> 00:30:43.744 
如果我們有多餘的空間
我們便可以計算它們

00:30:45.045 --> 00:30:47.381 
最後一點是它們非常靜態

00:30:48.282 --> 00:30:49.616 
有很大的可能性

00:30:49.683 --> 00:30:52.352 
如果我提前生成一些東西
它會和我想要用它的時候一樣

00:30:52.519 --> 00:30:55.022 
因爲它不怎麼經常改變

00:30:55.489 --> 00:30:56.790 
這些所有的觀點結合起來

00:30:57.724 --> 00:31:01.662 
使得這個數據是一個
用於文件緩存的最佳選擇

00:31:02.696 --> 00:31:03.764 
在我說別的之前

00:31:03.830 --> 00:31:07.367 
我想說這個依然是一個緩存
即使它是一個文件

00:31:07.434 --> 00:31:10.938 
不要將這些緩存寫到用戶的文件夾中

00:31:11.004 --> 00:31:12.639 
在你的app的緩存文件中保存

00:31:12.706 --> 00:31:14.007 
或在系統的臨時目錄中保存

00:31:15.843 --> 00:31:16.977 
回到我們的系統資源

00:31:17.311 --> 00:31:18.879 
我們剛介紹了一個新的題目

00:31:19.479 --> 00:31:20.414 
那就是磁盤空間

00:31:22.216 --> 00:31:25.085 
我們可以交換一些CPU
循環來生成這個數據

00:31:25.786 --> 00:31:28.355 
保存之後 當我們需要的時候
我們再把它拉出來用

00:31:28.889 --> 00:31:32.593 
我們事實上
完全去除了CPU的使用功能

00:31:33.493 --> 00:31:36.230 
現在
你也許已經注意到I/O已經運行了

00:31:36.296 --> 00:31:38.799 
因爲完全渲染的圖片會比

00:31:38.866 --> 00:31:41.201 
那些資源文件大 這沒關係

00:31:41.502 --> 00:31:42.603 
這些都是和權衡有關

00:31:43.770 --> 00:31:47.241 
這就直接到了被淨化最大的內存

00:31:48.242 --> 00:31:50.944 
你可能會記得我之前說過
被一個文件備份的內存

00:31:51.011 --> 00:31:52.746 
在磁盤上是被視爲乾淨的

00:31:53.247 --> 00:31:56.083 
那麼現在我們在磁盤上有一個文件
多巧啊

00:31:56.617 --> 00:31:58.352 
這樣一個文件的數據可以被內存映射

00:31:58.418 --> 00:32:00.821 
系統會定位一塊內存給你

00:32:00.888 --> 00:32:03.857 
然後直接映射磁盤中文件的位置和內容

00:32:04.992 --> 00:32:06.994 
這絕對值得注意內存

00:32:07.060 --> 00:32:10.197 
在文件內容上必須完全一致

00:32:10.264 --> 00:32:13.834 
你不能內存映射一個需要更多破解文件

00:32:13.901 --> 00:32:15.636 
或者當它已經加載了的

00:32:17.070 --> 00:32:19.740 
這對於只讀數據來說很理想就像我說的

00:32:19.806 --> 00:32:20.807 
它不怎麼經常改變

00:32:22.309 --> 00:32:24.845 
這裏最酷的地方就是

00:32:24.912 --> 00:32:26.780 
以可清除的內存

00:32:26.880 --> 00:32:30.450 
系統可以在當你需要時
重新召回一些空閒的內存

00:32:31.285 --> 00:32:33.153 
但是 它沒有消失

00:32:33.620 --> 00:32:35.622 
當你再次需要它時你再次取數它時

00:32:35.789 --> 00:32:37.925 
系統從磁盤中再次加載回來

00:32:37.991 --> 00:32:39.159 
就像它從沒消失過一樣

00:32:40.727 --> 00:32:42.896 
而且它有很大的隨機存取性能

00:32:42.963 --> 00:32:45.065 
只因爲你的工作集在這而你需要的一塊

00:32:45.132 --> 00:32:46.733 
數據在別處並不重要

00:32:47.034 --> 00:32:49.002 
系統可以只讀那塊的部分文件

00:32:49.069 --> 00:32:50.838 
然後交給你 你就可以工作了

00:32:52.940 --> 00:32:54.007 
這個看起來是什麼樣的

00:32:54.074 --> 00:32:55.375 
我們從內存的數據開始

00:32:57.177 --> 00:32:58.745 
然後你在磁盤上寫出來

00:32:58.812 --> 00:33:01.248 
系統現在把它當成 內存映射

00:33:01.515 --> 00:33:03.417 
如果你存取一部分的數據然後它

00:33:04.818 --> 00:33:07.387 
就會把它加載好 然後交給你

00:33:07.454 --> 00:33:09.990 
當你不再用它的時候 它就被拿走了

00:33:12.593 --> 00:33:14.728 
我們如何能
將此功能應用到IconReel上

00:33:14.895 --> 00:33:17.464 
我們從這個工作集開始
但是事實上我們是把

00:33:17.531 --> 00:33:21.468 
我們生成的每個圖標去合拼工作集

00:33:21.535 --> 00:33:25.506 
創建一個大的數據文件然後寫到磁盤上

00:33:29.476 --> 00:33:33.313 
現在回到我們的app中來
我們再次拿出我們的工作集 三頁

00:33:34.548 --> 00:33:36.383 
我們訪問這三頁內存

00:33:36.450 --> 00:33:39.219 
然後系統只加載文件的那一部分

00:33:39.286 --> 00:33:41.722 
到內存中然後保持其它部分乾淨

00:33:41.788 --> 00:33:44.424 
不管那文件是不是上百MB

00:33:44.825 --> 00:33:45.993 
它其實並不在內存中

00:33:46.126 --> 00:33:48.128 
當我們四處滑動時 一樣的事情發生了

00:33:48.762 --> 00:33:50.330 
系統加載了我們需要的數據

00:33:50.631 --> 00:33:53.367 
加入我們引進一個會顯示通知的功能

00:33:53.433 --> 00:33:55.636 
用於在主界面上的其它圖標

00:33:55.836 --> 00:33:57.471 
我們可以把它們拉出來然後

00:33:57.538 --> 00:33:59.139 
不用擔心它們在哪和它們是什麼

00:33:59.406 --> 00:34:02.509 
虛擬內存系統爲我們做了大部分工作

00:34:05.112 --> 00:34:07.214 
這會如何改變我們的資源條

00:34:07.648 --> 00:34:09.315 
這裏我們已經將CPU中斷了

00:34:09.382 --> 00:34:12.085 
但是我們現在的緩存實際上在磁盤上

00:34:12.152 --> 00:34:13.687 
那麼這個也消失了

00:34:14.487 --> 00:34:16.924 
然後我們現在唯一內存佔用就是工作集

00:34:17.157 --> 00:34:18.692 
其它地方都被認爲是乾淨的

00:34:19.193 --> 00:34:20.661 
所以不算是反對我們

00:34:21.495 --> 00:34:25.632 
且值得注意的是我們有效地消除CPU

00:34:25.699 --> 00:34:29.837 
對前端和後端的需求
對於我們的數據生命循環來說

00:34:30.170 --> 00:34:33.607 
我們不需要CPU來生成數據來展示給

00:34:33.674 --> 00:34:36.710 
用戶或者我們也不用CPU來清理
乾淨來應對內存警告

00:34:36.777 --> 00:34:38.911 
系統都爲我們做了

00:34:40.179 --> 00:34:42.049 
你如何能用內存映射數據

00:34:42.114 --> 00:34:45.085 
在一次 它是一個在NS數據上的
簡單API

00:34:45.152 --> 00:34:46.719 
這裏有些選擇你可以

00:34:46.786 --> 00:34:48.388 
用來開始數據對象

00:34:48.789 --> 00:34:51.625 
如果你在初始化器中標註映射選項

00:34:52.092 --> 00:34:54.494 
你就會得到一個內存映射數據文件

00:34:56.563 --> 00:34:59.266 
如果我沒有提到
我會被看做是玩忽職守

00:34:59.333 --> 00:35:01.235 
用這個系統時有一些警告

00:35:02.202 --> 00:35:04.004 
第一個就是它不適用於

00:35:04.071 --> 00:35:05.172 
少量的數據

00:35:05.472 --> 00:35:07.441 
在頁面上自己工作的虛擬內存

00:35:07.508 --> 00:35:09.176 
也就是少量數據

00:35:09.409 --> 00:35:13.780 
如果你的甚至更小你會遇到

00:35:13.847 --> 00:35:16.383 
覆蓋在你原有問題上的新問題

00:35:16.717 --> 00:35:20.187 
還有從內存映射文件中

00:35:20.254 --> 00:35:22.656 
如果你的內存映射一千個圖標文件
比如

00:35:22.723 --> 00:35:25.792 
這其實有一個對於任何系統可以有的
打開文件的限制

00:35:25.859 --> 00:35:27.461 
這樣你會惹上麻煩

00:35:27.928 --> 00:35:29.162 
這是其中一個主要原因

00:35:29.229 --> 00:35:31.665 
爲什麼我們將數據集合成大塊

00:35:31.732 --> 00:35:33.867 
使其對於VM系統更加好管理

00:35:35.469 --> 00:35:38.238 
或者你也可以只是濫用虛擬內存系統

00:35:38.305 --> 00:35:40.974 
你所創造的每個可清除的數據對象創造

00:35:41.041 --> 00:35:42.442 
在你虛擬內存中的一個區域

00:35:42.809 --> 00:35:45.312 
如果你創造了太多那些內存映射文件

00:35:45.379 --> 00:35:47.447 
你會將你整個空間碎片化

00:35:47.881 --> 00:35:49.349 
你同樣會使其耗盡

00:35:49.483 --> 00:35:51.752 
如果你決定來內存映射一個
10GB內存的文件

00:35:51.818 --> 00:35:53.754 
那麼你會完全用光內存

00:35:53.954 --> 00:35:58.725 
不幸的是
虛擬內存系統的濫用會導致

00:35:58.792 --> 00:36:00.194 
你的程序被終結

00:36:00.260 --> 00:36:02.796 
而這是我們最初想要避免的 對嗎

00:36:04.731 --> 00:36:07.301 
爲了提供最好的多任務處理體驗

00:36:07.367 --> 00:36:10.170 
對於用戶理解你的app使用的數據

00:36:10.237 --> 00:36:13.407 
和數據性能是非常重要的

00:36:14.074 --> 00:36:16.844 
你現在必須能夠分辨出可有可無的數據

00:36:17.177 --> 00:36:19.513 
和你需要的重要數據

00:36:20.247 --> 00:36:21.582 
你的數據可以被預計算嗎

00:36:21.782 --> 00:36:23.550 
重新建立有多貴

00:36:24.184 --> 00:36:25.385 
它長時間改變一下

00:36:26.019 --> 00:36:28.856 
瞭解關於你使用的數據可以幫助你找到

00:36:28.922 --> 00:36:32.259 
讓你的內存變得最大適用性的正確工具

00:36:33.160 --> 00:36:36.964 
我們可以一起
改善我們apps的適用性

00:36:37.030 --> 00:36:40.334 
和提供更好的多任務體驗給我們的用戶

00:36:42.202 --> 00:36:43.971 
在接下來的幾周你會更新你的apps

00:36:44.037 --> 00:36:45.706 
爲了iOS9的多任務處理

00:36:45.772 --> 00:36:47.741 
我希望你們把這些話題記住

00:36:48.475 --> 00:36:53.747 
首先用工具來識別並修復程序錯誤

00:36:54.281 --> 00:36:55.182 
這是簡單的東西

00:36:55.249 --> 00:36:57.651 
你的內存泄露無效率的數據構造 算法

00:36:57.851 --> 00:36:58.986 
廢棄的內存等

00:36:59.319 --> 00:37:00.487 
把它們都修好

00:37:00.988 --> 00:37:03.323 
其次適當優先化你的工作

00:37:03.390 --> 00:37:04.658 
然後別阻隔到主流程

00:37:04.992 --> 00:37:07.494 
我不知道你們多少人在
這個系列的第一階段記住了

00:37:07.561 --> 00:37:09.563 
就是系統會真的終端

00:37:09.630 --> 00:37:11.632 
如果你阻隔主流程太長時間

00:37:11.832 --> 00:37:13.200 
最好了解

00:37:13.267 --> 00:37:15.102 
你的工作應該在哪然後將其歸位

00:37:16.370 --> 00:37:18.672 
第三點就是辨別並管理你的工作集

00:37:18.939 --> 00:37:21.141 
然後瞭解工作集會改變

00:37:21.341 --> 00:37:23.644 
根據應用的目前執行環境

00:37:23.911 --> 00:37:26.813 
你是前臺 後臺 PiP

00:37:27.047 --> 00:37:28.315 
瞭解你現在的位置

00:37:28.382 --> 00:37:30.551 
因爲你的工作集不應該是相同的

00:37:31.852 --> 00:37:34.588 
第四個是使用緩存 然後響應內存警告

00:37:34.655 --> 00:37:39.226 
這個是作爲一個多任務處理
好公民的基本

00:37:39.626 --> 00:37:40.460 
請回應它們

00:37:42.362 --> 00:37:44.064 
下一個利用虛擬內存系統

00:37:44.131 --> 00:37:45.132 
也就是我們說過的

00:37:45.532 --> 00:37:47.734 
瞭解你的app的數據性能

00:37:47.801 --> 00:37:49.269 
然後看如果你可以利用那些工具

00:37:49.336 --> 00:37:51.939 
來讓系統爲你管理內存

00:37:53.807 --> 00:37:56.310 
最後就是良好的表現需要權衡

00:37:56.610 --> 00:37:57.678 
你的app是有需求的

00:37:57.878 --> 00:37:59.513 
apps在你旁邊運行的有需求

00:37:59.580 --> 00:38:00.948 
系統也有侷限

00:38:01.982 --> 00:38:05.519 
辨別你的app如何可以適應環境

00:38:06.086 --> 00:38:08.488 
用更約束的資源因爲這是

00:38:08.555 --> 00:38:11.792 
改善所有人用戶體驗的關鍵

00:38:12.593 --> 00:38:14.862 
因爲我由一句話開始
那麼我就由一句話結束

00:38:15.596 --> 00:38:16.663 
我在網上找到的這句話

00:38:16.730 --> 00:38:18.565 
據查爾斯·達爾文

00:38:18.932 --> 00:38:21.602 
稱不是最強
或者最智慧的生存

00:38:21.935 --> 00:38:23.704 
是那些最會改變的生存

00:38:24.271 --> 00:38:26.173 
多任務處理和適應有關

00:38:26.273 --> 00:38:29.376 
然後最能適應的apps將會

00:38:30.077 --> 00:38:32.312 
帶來最佳的用戶體驗

00:38:34.248 --> 00:38:36.083 
獲取更多的信息 我非常推薦你們去

00:38:36.149 --> 00:38:37.417 
看一看文件

00:38:37.484 --> 00:38:40.220 
這裏有一個新的採取多任務的指南
它很棒

00:38:40.721 --> 00:38:42.823 
去論壇討論有技術支持

00:38:43.390 --> 00:38:44.925 
如果你有任何問題

00:38:44.992 --> 00:38:47.427 
找柯特盧·瑟特 聯繫他吧

00:38:47.494 --> 00:38:49.630 
他也是一個
SpringBoard的前任工程師

00:38:49.696 --> 00:38:51.331 
所以我相信他很願意聆聽你們的想法

00:38:54.468 --> 00:38:56.069 
我們關於這個有兩個之前的講座

00:38:56.136 --> 00:38:58.138 
我建議你們也去看它們

00:38:58.205 --> 00:39:00.674 
接下來也有性能和GCD講座

00:39:01.341 --> 00:39:02.643 
謝謝大家 今天的到來

00:39:03.277 --> 00:39:04.711 
我等不及要看你們的apps了