在Metal中有什么新内容第二部分
谢谢
早上好 欢迎来到第二部分的讲座Metal展示中有什么新内容
我叫丹·大町市
我是苹果GPU软件架构团队的工程师
今天我的同事 安娜·吉洪诺夫和我将会谈一谈
基于Metal的技术
有助于在iOS 和OS X上向你提供令人
惊叹的渲染体验
因此这是三个讲座中的第二部分
在本年度讨论Metal的WWDC上
第一个讲座中
罗布·多啦夫 谈论了去年对Metal的开发
他还描述了我们刚刚发布的Metal的新功能
他还描述了它的瘦身功能如何与Metal应用完美匹配
在本次讲座中 我首先要谈到
Metalkit方便的APIs使你更快捷地使用Metal应用
然后 安娜 将会谈论Metal性能着色器架构
在具有A8处理器的iOS设备上
它可为可用的公用数据并行操作
提供很好的着色器
明天你将有机会
来听取Metal性能优化技术讲座
在那里将介绍Metal系统追踪工具
且向你提供一些有效的Metal应用的最好的范例
现在就开始介绍用于Metal应用的
Metalkit实用功能
因为Metal是一个低级的API你要做许多事情来建立和运行
MetalKit希望使用这个
来为经常使用的场景
提供有效的实现
这样你就可以很容易创建和渲染
并且我们对标准的库存代码
增强了性能和稳定性
你自己就可以实现
你需要很少的维护
因为维护的负担从你转到了我们
这样MetalKit由三部分组成
第一部分是MetalKit视图
一个介于iOS和OSX之间的统一的视图类
用于渲染你的Metal场景
第二部分是纹理载入器
用于创建磁盘上的图像文件的纹理对象
最后Metal Kit的模块I/O集成
上载和管理来自Metal渲染的网格数据
MetalKit视图是获Metal视频渲染的最简单的方法
它是iOS和OS X的统一类
它在这个两个操作系统上提供了几乎相同的接口
但是它本身是iOS的UI视图的子类以及OSX上的NS视图的子类
它的主要工作是为你管理可显示渲染目标
并且为这些渲染目标
自动产生渲染路径描述符
它的超级灵活之处在于
它可以执行你的绘制代码
你可以使用一个基于定时器的模式
该模式可以在有规律的间隔内
与显示同步执行你的绘制代码
或者你可以使用基于事件的模式
每当发生触摸或UI事件时该模式在就将触发你的绘制代码
这样你就可以对那个事件做出响应
最后也许你可以在
你的帧频率下第二线程上的开放环路下
驱动你的绘制代码
因此有两种方法使用MetalKit视图
最简单的方法是执行一个代表
来处理你的绘制及重新调整运行的大小
在这个实例中你可以执行在视图中绘制方法
来处理你的包括对任何渲染命令编码
的每帧的更新
你还可以执行按尺寸布局视图的方法
来处理你的视图的尺寸的改变
在这里你可以更新投影矩阵
或者改变纹理的大小
以更好地匹配你的显示区域
如果你有其它的需要改写的视图
可将MetalKit视图设为子类
在iOS的这个实例中
你将要改写绘制矩形方法
来处理你的每帧更新
以及布局视图方法来处理大小调整
同样的在OSX上你要处理
你要改写这两种方法绘制矩形
和设置桢大小方法
在这里有个设置视图控制器的例子
也可以作为我们视图的代表
在视图无法加载方法中我们在接收到针对视图的一个引用后
我们将我们自己指定为代表
在OS上特别重要的是我们需要选择
和设置一个Metal设备
一旦我们完成了 我们就可以配置
一些视图的功能包括
针对色彩、深度和模板缓冲
的自定义像素格式
我们还可以通过将
采样计数功能增加到数值1以上来使用多重采样
或者我们还可以设置我们的自定义清除色彩
这里有个实现每帧更新的
MetalKit视图的最基本的使用方法
在我们的绘制视图方法中我们叫做视图渲染
是renderpast descriptor
你首次访问每个画面的这个功能
该视图就会调用核心动画
并且获得一个可绘制返回
在这里你可以对渲染命令编码来进行渲染
这样我们就渲染了我们最终的render pass
就会在这个可绘制中展现出来
然后我们就将展现这个可绘制
它保存在视图的当前的可绘制功能中
并且我们将提交我们的指令缓冲器
因为构建你的每帧更新很重要
让我花一分钟
来说说管理这些可绘制
这样这个系统中有有限的可绘制
都由核心动画来管理
由于它们通常只有几个 因为
它们的大小占用了一些空间
这些可绘制通过许多级别的
显示管道层被同时使用
这里大致说下它是如何工作的
首先你的应用程序对要在可绘制上渲染的
指令进行编码
当你的应用程序对下个帧进行编码时
它将那个可绘制向下发送到GPU
GPU对那个画面进行渲染 核心动画
在这个阶段可以和其他层一起
对那个可绘制进行合成
最后显示器获取了可绘制
把它放在屏幕上
显示器不能用任何东西来替代它
直到可获得另一个可绘制
如果前面的任何阶段花费了很长时间
它只能等一会儿
显示器不能将那个可绘制反向循环
直到你的帧上有它有可用的东西
让我们来看看你的带有这些可绘制的应用框架
首先你调用保留有一个 可绘制的
MetalKit视图当前渲染描述符
然后用你想要的渲染指令对那个可绘制进行编码
最后你呈现和提交那个会将它发回到核心动画中的可绘制
一切都好如果我们只是渲染一个单独的render pass
但是很有可能我们将做其他的操作
如一些应用逻辑对
无须可绘制 用offscreenrender pass进行编码
或运行一些物理计算核心程序或其他程序
在这种情况下我们本质上是在占用我们未来可绘制
因为在后续帧中
我们会调用这个当前的渲染描述符
它会呆在那儿
等待成为可用的 可能等不到
因为我们正在做其它的操作并且将它
保留了比我们所需的更长的时间
因此要解决这个问题
让我们在访问当前渲染描述符之前进行这些操作
我们注意到这不是
MetalKit特有的问题
如果你在直接访问核心动画的时候滚动视图 你会注意到这个问题
因此在任何情况下这种信息都很有用
这里有个每帧渲染更新的更完整的例子
首先 如所述我们想要更新我们的应用程序的渲染状态
对任何的offscreenpasses进行编码
做任何我们不需要 可绘制的东西
然后我们就能够继续像以前那样
获取当前渲染通道描述符
为最终的pass的指令进行编码然后呈现和提交我们的指令缓冲器
关键点是这两个阶段
越靠近越好
它是我们保持资源的临界区段
我们不想将它保留时间过长
关于视图的就说这么多
让我们开始讨论纹理载入器
纹理载入很简单
你给一个引用然后你就得到一个成形
的Metal纹理
它不只是简单而且功能齐全
它异步解码文件
并且在分别的线程上创建纹理
它支持许多通用图像文件格式包括
JPG、TIF和PNG还支持PVR
和KTX纹理文件格式
这些格式的有趣之处
是它们以原始形式保存数据
并且可以上传到你的Metal纹理中
不需要任何的改变
另你可以将MIT maps数据编码
成其他类型的纹理
包括3D纹理、立体地图和纹理数组
它的用法很简单
首先我们通过提供一个设备
来创建了一个纹理上载器对象
然后一旦我们有了那个纹理上载器对象我们就能用它创建许多的纹理
首先提供一个图像文件的URL地址
然后就可提供许多的选项 
包括 如何处理文件中的sRGB信息
或者是我们是否想在创建这个纹理的时候
为MIT maps分配内存
最后我们要提供一个完成处理块
只要纹理载入器已经完成了
上载纹理并且创建了它就会执行块
它会将纹理处理器发回给你你可以将它保存在以后
需要时用来渲染
纹理载入器非常简单
让我们继续进行Model I/O
模型I/0是一个新的结构是与
iOS 9和OS XEl Capitan一块引入的
它的一个关键特点是
它可以为你上载许多的模型文件格式
如果你需要可以为你专门格式创建
你自己的导入器和导出器
这里非常酷的特点是
做offline baking操作
可创建静态环境光遮蔽地图生成光照图
它还包括你的网格的立体像素化
它提供了一种集中于你的渲染代码
和写入你的着色器的方法
你不需要创建一些parchers
来将一些东西从磁盘中取出
你必须少和串行打交道
你只需要上载一个带有Model I/O的模型文件
把它放入你可用它做渲染的一些构成中
开始写入你的着色器
MetalKit在这种情况下提供了什么
它的程序有效使用Metal的Model I/O
它提供了将Model I/O网格优化上载到Metal缓冲器中
MetalKit对象内部的网格数据封装
有许多函数用于为网格数据
的Metal管道做准备
让我来指导
如何用Model I/O来上载一个模型文件的步骤
并且用Metal来将它渲染到屏幕上
这里就是我们要采取的步骤
首先创建一个Metal渲染状态管道
我们将用来创建我们的网格来渲染我们的网格
然后通过初始化Model I/O asset
用asset来上载模型文件
我们就可以创建MetalKit网格
以及子网格对象
最后用Metal来渲染那些对象
因此集中于创建一个Metal渲染状态管道
我们要特别注意
创建一个顶点描述器
该描述器将会对需要的网格提供给管道的顶点的布局进行描述
这里是顶点着色器的基本内容
它使用限制符级基本上
说明了我们每个顶点的输入它们的布局
用我们的objective-C代码使用顶点描述符
对着色器以外进行描述
它使用了这里所定义的
顶点输入架构
这个顶点输入架构的主要部分是
这些功能我们要使用这些指数来连接
Objective-C编码的外部和内部
注意这些浮点矢量类型定义了数据在着色器中的样子
不是实际上数据从我们的
Objective-C编码送入
着色器的样子
对此需要创建一个顶点描述符
我将把这个顶点输入结构
放在这作为参考但是我要提醒你
它定义的不是被送入到着色器时
的数据的布局
我们实际上创建的是下面的Metal顶点描述符
我们要做的是针对属性0
用三个浮点 三个浮点值
来定义这个位置
对于属性1 色彩将由
四个无符号的字符组成
不是上面的四个浮点 四个无符号字符
它紧接在位置数据之后
有12个比特的相位差
对于属性2的纹理坐标
我们将定义它用了两个半浮点
它紧跟在位置和颜色数据之后
有16比特的相位差
通过将缓存器的stride设置设为20
将每个顶点的大小
规定为20比特
这样就定义了我们的顶点阵列
内的每个顶点的布局
这样我们就得到了我们的Metal顶点描述符
我们能够将它分配到我们的渲染状态管道
并且用渲染对不起 用渲染管道描述符
我们就能够创建一个Metal渲染状态管道
现在我们开始上载我们的asset
用Model I/O来完成那个任务
我们实际上使用我们在
前一步创建的顶点描述符
一个MetalKit网格缓冲器对象
一个网格缓冲器分配器对象
在我们继续向下讲时
我多说几句强调一下它的重要性
Model I/O顶点描述器
以及Metal顶点描述器非常类似
但是尽管Model I/O顶点描述器描述了
网格内的顶点属性的布局
但是Metal顶点描述器描述了
作为渲染状态管道的输入
的顶点属性的布局
它们专门设计成看起来相似
因为它们包含属性和缓冲器布局对象
原因是这样就简化了将一个对象翻译成另一个的过程
在Model I/O顶点描述器中的每个属性
都有一个可识别的字符串库名称
Model I/O分配了一个缺省的名称 如果模型内不存在
或者是那个模型文件不支持这些名称
这些名称包括位置、法向量、纹理、坐标颜色等
Model I/O用基于MDLVertex
属性常数的字符串来定义这些
有许多文件包括你可以自定义那些名称的
Alembic文件格式
注意 如果你要改变名称
你需要用那些自定义名称来访问这些属性
所以我们建议你创建一个自定义Model I/O顶点描述器
因为在缺省下Model I/O上载的顶点
为高精度
而且占用大量内存的浮点类型
这是使用Model I/O的优势之一
你实际上可以上载一个模型格式
具有你所喜爱的任何形式的顶点数据
将那个数据变成你能够实际使用的格式
在这种情况下我们想用最小的类型
提供给管道
以满足你们的精确性要求
这将提高你们的顶点带宽效率
当你们在将每个顶点提供给管道的时候
你实际上不想要一个膨胀的顶点
这里就是我们前面定义的
当创建我们的Metal顶点描述符时的布局
现在我们通过从Metal中调用MTKModel I/O顶点格式
来创建我们的Model I/O顶点描述符
我们所提供我们的Metal顶点描述符
就构建了这个Model I/O顶点描述符的大部分
然而我们还需要为每个属性标个名字
这样Model I/O就知道我们谈论的是什么
因此对于属性0我们用顶点
属性位置名称来标记
类似地如属性1和2 我们用
颜色和纹理坐标属性来做标记
这里我们要做的另外的事是我们要创建
一个MetalKit并且我们会提供一个Metal设备
这个对象所做的就是允许Model I/O来
直接将顶点数据上载到GPU备份内存中
你不一定要使用一个MetalKit网格缓冲器分配器
但是它所做的是为网格内的
这些顶点和指标缓冲器分配系统内存
当你想真的要渲染它我们需要从系统内存拷贝到
GPU备份内存中
因此为了更有效最好使用这些网格
缓存分配器中的一个这里我们要说下如何使用它
我们要上载我们的asset文件
我们将提供URL地址
将会告诉Model I/O如何对
每个顶点进行布局的Model I/O顶点描述符
我们还将提供该网格缓存分配器
这样Model I/O就能直接上载数据到
GPU备份内存中
现在我们获得的我们的asset
让我们真正地来创建一些MetalKit网格
以及一些网格对象
这里是通过Model I/O
来创建asset的一个例子
在asset的内部我们可能会有相机对象
光照对象...
以及对我们目前非常重要的网格对象
MetalKit首先与这些网格对象相关
它并不直接与光线和相机对象打交道
因为那种数据取决于你的自定义的着色器和你的引擎
你可以真的探究这个对象或者向内查看这个对象
取出相机和光亮信息插入到你的着色器中
但是MetalKit并不直接参与到那个过程中
因此我们所能做的就是直接将这个asset
传到这个网格中网格来自asset类函数
将会创建MetalKit网格的阵列
让我们看看这个网格对象内部都有什么
首先是这些顶点缓存器
包括位置属性
法向量属性 纹理属性等等
在我们的例子中 我们只需要一个阵列
因为我们对所有我们的数据进行交错
然而我们用多重阵列来定义布局
因此你就会有多重顶点缓存器
你可以定义那个属性0可以在
一个单独阵列的内部这样你就会在一个阵列
中有一阵列的位置在下一个中有一阵列的纹理坐标
下一个是色彩阵列等等
该网格还包括一个定义了这个
布局的顶点描述符
与我们初始化我们的asset时
刚刚创建的和送入的是相同的对象
网格包含有许多的子网格对象
每个子网格对象的主要部分是这个变址缓存器
它引用顶点缓存器内部的顶点
另外你能够使用许多属性
来用Metal调用一个绘制
获得了Metal kit网格和子网格对象
让我们继续来渲染它们
首先我们要循环访问每个顶点缓冲器
可能有稀疏阵列 因此需要确定
每个缓存器里真的有东西
但是一旦我们确定了我们就可以继续
并且在我们的渲染编码器中设置顶点缓存器
顶点缓存器实际上有两个属性
缓存器本身以及缓存器内部的相位差
它是你的顶点数据驻留的地方
我们还需要提供一个缓冲索引告诉管道
数据的精确位置
就可以真正地渲染我们的网格了
我们将循环访问每个子网格
并且调用我们的绘制指数基元
注意这个子网格具有
这个绘制指数参数的所有参数
今天将这个MetalKit基本样本
发布到WWDC 2015网站上
我希望你们将它下载下来
它描述了许多我介绍的技术
它使用Model I/O来上载这个塞入一个OBJ文件中的
小型飞机对象并且创建一了个MetalKit网格
并且将它在屏幕上进行渲染
这样你就能明白究竟如何去做
我鼓励你们多看看
我的就这么多我叫丹·大町市
如果对我今天讨论的题目有什么问题
我明天就在Metal实验室
我想要欢迎我的同事安娜·吉洪诺夫
上台来谈Metal性能着色器架构谢谢
早晨好
谢谢你 丹谢谢你的介绍 我叫 安娜
我将和你们谈谈Metal性能着色器
让我们开始
首先Metal性能着色器是什么
它是Metal内 的用于GPU的
优化性能数据并行算法
你什么时候和为什么要使用它？
如果你在写C代码并且你要
填加一个C代码排序算法
到你的CPU应用中
你肯定不会抓来一个就用除非出于你自身的利益
你更有可能使用函数库提供给你的实现
因为它已经经过了调试和优化
同样如果你想要在我们的平台上
添加一个图像处理操作到你的CPU应用程序中
你将会使用加速架构
因为它使用了vlmage
它是一个强大的
高性能的调整图像处理架构
因为它使用了CPU的向量处理
这只是几个例子
重要的是可以为你的CPU应用程序
提供丰富的环境
对于GPU情况有些不同
你的选择变少
但是我们将会改变这种情况
我们的目标是丰富我们的Metal编程环境
我们选择了一系列的通用过滤器
我们知道这些通用过滤器通常使用
在你的图像处理应用和游戏中
这些算法为iOS进行了优化并且
可以使用于A8处理器的IOS 9中
Metal性能着色器架构有两个目标
性能和容易使用
将它设计成容易融合到
你的Metal应用中
让它直接在Metal资源上进行操作
它们是输入和输出
我们不只是给你提供一批的这些高性能
优化的极好的核心程序
我们还十分关注
启动这些核心程序的必要的宿主代码
我们对如何将并行计算分离
的决策流程也很重视
你所要做的工作就是将这个架构的优势
应用到你的应用程序中
通常只需要几行的代码
它简单地就像是调用一个库函数
现在我就像你们介绍这个架构
让我们看看可用的操作
这里是个完整的列表 我们从头开始
实际上我只是挑几个说
并且我还要举例说明
首先该架构支持直方图过滤器
直方图均衡和规格过滤器
均衡和规格过滤器
允许你改变你的图像
中的色彩强度的分布
均衡过滤器是个很特殊的例子
它将当前的分布
改变为统一的分布
而规格过滤器使你能够设置
你所选择的任何分布
你指定将要在过滤器中使用的直方图
这是均衡过滤器的一个例子
它增加了图像的整体对比度
这里它描绘的天空中的彩虹非常美丽
我想提醒的一件事是
这些过滤器并不是其本身的结束
它们可以在一个更加复杂的算法中
用作中间步骤
直方图过滤器可以用来实现
tune mapping的中间步骤
这种技术常用于图形开发者来
接近高动态范围的外观继续
我们还支持Lancos重采样
它是高质量的重采样算法
可以用来缩减 放大压缩和拉伸图像
在这个例子中 我垂直地拉伸图片
并且水平地挤压图片同时还保存
图像的内容
你还可以支持阀值过滤器
如果与Sobel过滤器链接在一起
它还可以被用来查找图像的边缘
让我们来看个例子
这是阀值过滤器的输出
现在它进入Sobel过滤器来给你提供图像的边缘
最后支持整个范围的卷积核
包括通用卷积在这里你可以指定你自己的
卷积矩阵
我们还支持高斯模糊
box tent和Sobel过滤器
我最后的例子将是高斯模糊
你们都应该很熟悉
我们想在我们的UL中使用
你想要在你自己的应用程序中
使用高斯模糊会怎么样呢
性能着色器架构会使它非常简单
你要问有多简单？
我预先告诉你
只有两行代码
首先你必须创建一个模糊过滤器对象
然后你必须将这个过滤器编码到指令缓存器中
谢谢大家
有一件事我想再次指出和提醒的是
API将你的通用Metal资源看作是输入
你的设备、你的指令缓存器、你的纹理
这些都是你已经在你的应用程序中
创建的Metal资源
现在我已经向你展示了这两行代码
让我们看看它们插入到你
当前的Metal工作流程的哪个位置
这是你的指令缓存器的图解表示法
它包括你将要提交到
设备中的所有命令
你就像平时那样操作就行了
你通过发送绘制调用来渲染你的屏幕
你通过发送核心程序来进行效果处理
现在你已经决定你的处理效果之一是模糊过滤器
正好是这个地方
不要忘记你还要像平时那样提交你的命令到设备中
这里什么都没有改变
现在如果你想要看我刚才完成的例子中的示例代码
你可以上网developer.Apple.com
下载叫做Metal性能着色器的例子世界你好
我前面已经提到过
Metal性能着色器架构有两个目的性能和易于使用
我刚才展示了它是多么容易使用
让我们快速地看看幕后
将要告诉你的性能的秘密
对于这些过滤器的每一个
包括高斯模糊过滤器我们要选择恰当的算法
恰当的这里的意思是正确的并且是最快的
对于输入数据、输入参数
设备GPU的特别组合是最快的
我这样说是什么意思
有许多方法可以实现高斯模糊
有constant costlog 2 linear
以及强力运算
所有这些方法的启动费用和
日常开支都不相同
一种方法可能对于小的核半径
非常好但在大的核半径上表现不佳
重要的是我们要实现每一种方法
并且通过实验来发现哪个
对于一个特别的输入问题、输入参数
和设备GPU的组合是最快的
在这个过程之后
所有的核都被调整成为你的核半径
你的像素格式
你的基础硬件结构的存储层次的参数
以及每个线程的像素数目
以及线程组规模的参数
这决定了如何将你的工作并行分离
最后我将会提到
该架构还为你做CPU优化工作
它优化了程序上载速度
它还重复使用中间纹理
它还为你做计算编码优化
特别的是它还能察觉
你是否是在连续使用多重计算编码器
如果是这样它就会将它们合并
我们为你完成了所有的这些步骤
非常酷但以代码的角度来看是什么样子
如对于我刚刚向你们展示的
优化高斯模糊着色器
好了 你准备好了么？
这就是代码
现在你们都知道了
如何实现你们自己的优化高斯模糊
对么我敢打赌 你没想到
在这个讲座中能学到这个
言归正传这是49 Metalkernels
2,000行的kernel代码
以及821个不同的Metal高斯模糊实现
每个实现都是这些49个Metalkernels一些组合
因此看起来我们做了很多的工作
现在不必由你来做
让我们看看
运行中的Metal性能着色器架构
首先我将演示一个简单的
可分离高斯模糊实现的教科书
只需要1分钟就可写入到Metal
这可能是你刚开始时应该使用的东西
如果你要实现你的模糊
并且你手头没有Metal性能着色器
现在我们非常愉快地在每秒60帧在运行着
但是我们实际上还没有做任何工作
sigma数值是0
让我们改变sigma数值到6
我们就降到了每秒8帧
我们还敢继续么
让我们试着sigma 20
好了 现在我们降到了每秒3帧
那样就无法工作了
让我们转换到Metal性能
着色器实现
现在我们返回到了每秒60帧
没有做任何工作sigma为6
每秒仍然是60帧
Sigma为20
仍然是每秒60帧
我们还得继续 真的模糊它
仍然是每秒60帧
看起来我们赢了
这样你的屏幕刷新速率是60赫兹
这就意味着我们以每秒60帧在运行
这样你在演示中所看到的优化高斯模糊着色器
的性能最高是每秒60帧
这就意味着你有16.6毫秒来画你的帧
这还包括你的系统可能要做的
合成工作
这个图表显示你在不同的sigma值
的优化高斯模糊过滤器的执行时间
你可以看到执行时间
要比16.6毫秒少得多
这就意味着你仍然有额外的时间
来做多余的GPU工作
而且仍然能达到希望的每秒60帧
现在还有一些细节需要说明
有时候你需要在很大的图片上工作
你需要并列式显示
有时候你需要只在你的
图像的一部分上工作
针对那个有个机制
它叫做源偏移和destination剪裁矩形
剪裁矩形有起始点和大小
它决定了目的纹理的区域
将由过滤器来进行更新
源偏移只有起始点
大小是隐含的由剪裁矩形来决定的
它只是你的目的纹理的左上角的一个相位差
它们共同工作给你提供了最后的图像
在Metal性能着色器架构中
你的来源和目的是相同纹理中的一个
在这种情况下剪裁矩形
以同样的方式工作
当来源和目的是相同的
我们管它叫in-place操作
用它来节约内存
你怎样做才能对这些in-place过滤器进行编码呢
你必须要使用编码命令缓冲区方法
和一个分配器fall by back copy
有一件事要记住的是着色器并不总是可能
运行in place
它取决于你的过滤器
过滤器参数和性能
如果你希望这个操作永远成功
使用一个复制分配器
它就会被自动调用
除非在in place操作不可能的情况下
我们将为你创建一个新的目的纹理
这样在必要情况下操作
可在out of place 进行
有简单fall back copy分配器的例子
这个例子只是创建了一个新的具有相同的像素格式和大小
的目的纹理
因为源纹理非常简单
之前我向你们展示了一个in place 操作
在这个操作中 你只对目的纹理的
一部分进行了更改
在剪裁矩形之外的任何东西都没有改变
在复制分配器中你还可以这样做
只需要用你的源纹理的环境
来初始化你的目的纹理
我还想提到的是所有常见
的Metal资源如你的设备和
你的指令缓冲器
你都可在复制分配器中获得
现在我对细节进行了说明
让我们来总结一下
我想说的是请使用Metal支持架构
MetalKit和Metal性能着色器
它们非常强健它们经过优化
正如我向你们展示的
它们很容易融入你们的Metal的应用程序中
它们会给你的应用程序带来更多的时间
你可以把时间用在制作独特的应用程序上
而不是浪费在一般的工作上
另外的好处是
你可以花更少的代码来编写和维护
到我们的实验室来向我们提出反馈意见让我们知道如何开始或者向我们提问
让我们知道是否想让新的工具或着色器添加到支持架构中
你随时可以在网上发现更多的信息
我们可以提供文档视频
充分利用苹果开发论坛和技术支持
对于一般的疑问
请联系我们的游戏技术大师阿伦·谢弗
你可以在网上观看以前的讲座
但如果你想学习新Metal性能优化技术
明天上午11:00来听我们的讲座
谢谢