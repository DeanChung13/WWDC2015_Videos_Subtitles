00:00:20.220 --> 00:00:23.857 
改善全屏窗口體驗

00:00:23.924 --> 00:00:24.758 
嗨！

00:00:25.392 --> 00:00:27.895 
歡迎蒞臨《改善全屏窗口體驗》
專題講座

00:00:28.495 --> 00:00:31.298 
我叫 Corbin Dunn
是一名 AppKit 軟件工程師

00:00:31.365 --> 00:00:34.568 
今天我將與我的同事Taylor Kelly一起
完成這個講座

00:00:34.701 --> 00:00:36.069 
就讓我們直入主題吧！

00:00:36.637 --> 00:00:38.405 
那麼我們今天要講些什麼呢?

00:00:38.472 --> 00:00:40.240 
首先我要講的是全屏幕

00:00:40.307 --> 00:00:42.276 
它將包括三個部分

00:00:42.676 --> 00:00:44.711 
我將討論全屏幕的採用

00:00:44.778 --> 00:00:45.979 
以及如何正確採用

00:00:46.313 --> 00:00:49.183 
我將談到標題欄附件視圖控制器

00:00:49.316 --> 00:00:50.884 
它們是什麼以及如何使用它們

00:00:51.318 --> 00:00:53.720 
然後我將講一下全屏幕平鋪 API

00:00:53.787 --> 00:00:55.556 
查看並利用一些大家已在

00:00:55.622 --> 00:00:57.524 
Mac OS 10.11中
看到的新特性

00:00:58.292 --> 00:01:00.294 
Taylor將會上臺 並講一下

00:01:00.360 --> 00:01:03.530 
Split View控制器內的
靈活佈局 自動佈局 堆疊視圖

00:01:03.997 --> 00:01:06.099 
並在最後講下
關於集合視圖方面的內容

00:01:07.668 --> 00:01:09.036 
那麼 全屏幕

00:01:09.903 --> 00:01:11.138 
全屏幕的目的是什麼？

00:01:11.205 --> 00:01:14.641 
它是爲了讓您的用戶將注意力
集中到某個單一任務上

00:01:14.875 --> 00:01:16.944 
您可以充分利用您的屏幕空間

00:01:17.311 --> 00:01:18.946 
其他一切都靠邊站

00:01:19.012 --> 00:01:21.882 
您要全神貫注於一個窗口

00:01:23.083 --> 00:01:26.019 
那麼我們爲何使其
成爲一個系統特性呢？

00:01:26.687 --> 00:01:27.988 
我們使其成爲一個系統特性

00:01:28.055 --> 00:01:31.291 
因爲它一種非常一貫的用戶體驗

00:01:31.625 --> 00:01:33.026 
你進入全屏幕的方式

00:01:33.093 --> 00:01:35.462 
你退出全屏幕的方式
都是一樣的

00:01:35.729 --> 00:01:37.898 
你在不同的位置之間
導航定位的方式等等

00:01:39.166 --> 00:01:42.636 
那麼 什麼是
“可全屏化的窗口”？

00:01:43.036 --> 00:01:45.172 
這裏有一個Safari窗口的例子

00:01:45.606 --> 00:01:48.542 
我肯定您知道
只要點擊綠色按鈕

00:01:48.809 --> 00:01:50.110 
它就會把您帶入全屏狀態

00:01:51.345 --> 00:01:53.814 
一旦您進入全屏狀態
您可以將鼠標移到窗口的上方

00:01:53.881 --> 00:01:56.717 
標題欄和工具欄將會向下展開

00:01:57.251 --> 00:01:59.019 
而你可以再次點擊綠色按鈕

00:01:59.086 --> 00:02:00.687 
它將把你帶回全屏狀態

00:02:02.890 --> 00:02:05.125 
那麼爲了採用全屏幕
需要做些什麼呢？

00:02:05.325 --> 00:02:06.793 
希望大家已經對此有所瞭解

00:02:07.060 --> 00:02:08.228 
不過它是相當容易的

00:02:08.529 --> 00:02:11.698 
您將指定哪些窗口
是您希望可以全屏化的

00:02:11.765 --> 00:02:13.967 
您將爲它增加一個菜單項

00:02:14.034 --> 00:02:16.503 
而且你很可能會
做些額外的事情

00:02:16.570 --> 00:02:17.638 
你可能希望做的額外的事情

00:02:17.704 --> 00:02:21.708 
是自動隱藏您的工具欄
修改您的內容

00:02:21.842 --> 00:02:25.746 
以便更充分地利用
全屏幕帶來的空間

00:02:25.812 --> 00:02:28.048 
利用新的標題欄

00:02:28.115 --> 00:02:28.982 
輔助視圖控制器

00:02:29.049 --> 00:02:31.118 
而我將談一下如何
以及爲何我要那麼做

00:02:31.852 --> 00:02:33.987 
當然 您希望進行很好的全屏平鋪操作

00:02:34.254 --> 00:02:36.557 
因此我將討論一些我們已有的API
來實現那種效果

00:02:37.424 --> 00:02:40.627 
首先 有兩種類型的窗口

00:02:41.562 --> 00:02:44.932 
或者實現全屏化有兩種可選窗口

00:02:45.699 --> 00:02:47.401 
通常當一個窗口是全屏時

00:02:47.935 --> 00:02:49.503 
就不允許對其進行進一步操作了

00:02:49.570 --> 00:02:52.272 
而那樣的窗口也是
我們所謂的“主窗口”

00:02:52.673 --> 00:02:55.309 
它是您的應用的

00:02:55.375 --> 00:02:56.210 
主文件窗口

00:02:56.643 --> 00:02:59.012 
它是您能夠使其全屏化的東西

00:02:59.880 --> 00:03:02.349 
然而還有另一種選擇
如果你已經看到它的話

00:03:02.583 --> 00:03:05.886 
那就是“輔助窗口”
通常你並不需要這個

00:03:06.086 --> 00:03:09.189 
它的目的是什麼？
如果你在某個應用中有一個窗口

00:03:09.256 --> 00:03:11.758 
想要佔據另一個應用的全屏空間

00:03:11.825 --> 00:03:12.993 
它允許你那麼做

00:03:13.060 --> 00:03:15.095 
我不會討論這方面

00:03:15.696 --> 00:03:18.599 
而我鼓勵您查閱幾年前的
AppKit  版本說明

00:03:18.665 --> 00:03:20.801 
瞭解關於它的一些細節

00:03:21.368 --> 00:03:23.971 
那麼您如何採用全屏窗口呢？

00:03:24.037 --> 00:03:27.341 
在Xcode和Interface
Builder中它非常簡單

00:03:27.407 --> 00:03:30.410 
您選擇您的窗口有一個Full
Screen(全屏)部分

00:03:30.477 --> 00:03:31.612 
您將菜單項下拉

00:03:31.678 --> 00:03:33.814 
就有主窗口和輔窗口的選項

00:03:33.881 --> 00:03:35.782 
那麼您將很可能希望

00:03:35.849 --> 00:03:38.285 
在您作爲主窗口的全屏窗口上
設置主窗口

00:03:39.486 --> 00:03:43.490 
當然您也可以用代碼實現,而在Int
erfaceBuilder選項下

00:03:43.557 --> 00:03:46.193 
它所做的不過是修改

00:03:46.260 --> 00:03:48.529 
window.collectionBehavior

00:03:48.695 --> 00:03:51.398 
而它將向窗口添加
.FullScreenPrimary

00:03:51.498 --> 00:03:53.600 
或.FullScreenAuxiliary

00:03:53.667 --> 00:03:57.371 
以便讓那些選項進入窗口
並讓窗口實現全屏化

00:03:59.239 --> 00:04:02.142 
一旦您進入全屏狀態
您可能需要

00:04:02.209 --> 00:04:05.012 
做各種基於全屏幕的事情

00:04:05.512 --> 00:04:08.415 
而且您可以通過查看樣式蒙板
進行檢查

00:04:09.049 --> 00:04:10.584 
就是當您的窗口進入全屏的時候

00:04:10.918 --> 00:04:12.653 
我們添加

00:04:12.719 --> 00:04:14.988 
NSFullScreen
WindowMask

00:04:15.055 --> 00:04:16.757 
而且您可以在樣式蒙板中查看

00:04:16.822 --> 00:04:18.492 
您的窗口是否處於全屏狀態

00:04:18.926 --> 00:04:20.226 
並有可能做其他的事情

00:04:22.663 --> 00:04:25.966 
現在讓我們談下
如何自動隱藏工具欄

00:04:26.433 --> 00:04:28.035 
通常如果您在窗口內
有一個工具欄

00:04:28.202 --> 00:04:30.537 
它總是可見的
就像這裏顯示出來的一樣

00:04:31.104 --> 00:04:33.407 
當您把鼠標移到窗口的上部

00:04:33.473 --> 00:04:35.075 
菜單欄會向下展開

00:04:35.142 --> 00:04:36.710 
標題欄的控制按鈕向下展開

00:04:37.211 --> 00:04:38.946 
從而露出了工具欄

00:04:40.147 --> 00:04:42.549 
有一個選項可以讓您
將工具欄自動隱藏

00:04:42.916 --> 00:04:45.452 
所以當你進入全屏的時候
其他什麼都看不到

00:04:45.519 --> 00:04:47.588 
而你可以最充分
利用您的屏幕的空間

00:04:48.856 --> 00:04:50.457 
當您將鼠標
向上移動到菜單欄的時候

00:04:50.858 --> 00:04:54.228 
工具欄會與菜單欄
和標題欄一起

00:04:54.294 --> 00:04:55.929 
同時向下展開

00:04:55.996 --> 00:04:57.764 
這確實是很容易做的

00:04:58.298 --> 00:04:59.900 
有一個
windowdelegate方法

00:04:59.967 --> 00:05:04.438 
Window.WillUse
FullScreenPresentationOptions

00:05:04.671 --> 00:05:06.340 
再加上 
proposedOptions

00:05:06.440 --> 00:05:11.211 
您選擇那些建議的選項並且增加
AutoHideToolbar並將其返回

00:05:11.278 --> 00:05:12.946 
而工具欄將自動隱藏

00:05:13.413 --> 00:05:15.115 
因此是非常容易的

00:05:16.550 --> 00:05:20.354 
那麼然後是自定義動畫
您可以創建全屏進入和退出

00:05:20.420 --> 00:05:22.523 
自定義動畫

00:05:22.589 --> 00:05:24.525 
我們有兩種
delegate方法實現它

00:05:24.591 --> 00:05:26.593 
customWindows
ToEnter

00:05:26.660 --> 00:05:28.829 
FullScreen
ForWindow

00:05:28.896 --> 00:05:31.098 
這種方法可以返回一系列的窗口
來實現您的動畫

00:05:31.231 --> 00:05:33.433 
然後我們把您叫回來
說 嗨！

00:05:33.500 --> 00:05:35.469 
開始您的自定義動畫
進入全屏狀態吧

00:05:35.702 --> 00:05:36.837 
並請指定持續時間

00:05:37.571 --> 00:05:40.307 
關於這些操作
我們需要注意的一點是

00:05:40.374 --> 00:05:42.809 
在 Mac OS 10.11 中
通過我們進入全屏的方式

00:05:42.876 --> 00:05:44.411 
您可能不會讓這些參數得到調用

00:05:44.478 --> 00:05:46.446 
因此重要的一點是

00:05:46.513 --> 00:05:49.349 
不要依賴這些參數一直被調用
並設置狀態

00:05:49.716 --> 00:05:52.586 
相反 有更好的方式實現
過一會兒我將講到這些方式

00:05:55.355 --> 00:05:58.892 
好了 關於全屏幕以及
如何正確採用就講這麼多

00:05:59.259 --> 00:06:00.594 
讓我們繼續往下進行

00:06:01.094 --> 00:06:03.363 
談一下標題欄輔助視圖控制器

00:06:05.032 --> 00:06:08.335 
那麼在我講標題欄
輔助控制器之前

00:06:08.602 --> 00:06:10.604 
讓我們先看一下全屏幕窗口

00:06:10.871 --> 00:06:14.474 
而且我將對標題欄區域突出顯示
以便於您覺察到它

00:06:14.942 --> 00:06:16.410 
那麼這就是全屏中的標題欄

00:06:17.144 --> 00:06:19.546 
在標題欄下面是工具欄

00:06:19.613 --> 00:06:24.184 
而在工具欄下面是我們所謂的
“輔助視圖”

00:06:24.585 --> 00:06:27.788 
那麼您可以在窗口中的這個位置
增加您自己的標題欄

00:06:27.855 --> 00:06:29.990 
輔助視圖控制器

00:06:30.357 --> 00:06:33.694 
好在窗口不是全屏狀態下

00:06:33.760 --> 00:06:35.329 
也能添加它們

00:06:35.863 --> 00:06:38.699 
那麼這就是在窗口不是全屏狀態下
它們看上去的樣子

00:06:39.032 --> 00:06:40.767 
然後它們被自動地反覆管理

00:06:41.535 --> 00:06:44.171 
爲了理解這種模式的重要性

00:06:44.238 --> 00:06:47.574 
最好先理解
我們爲什麼會用這種模式

00:06:47.674 --> 00:06:49.443 
那麼讓我們看下您的窗口

00:06:50.143 --> 00:06:54.515 
通常 在工具欄和標題欄
下方的區域

00:06:54.581 --> 00:06:57.150 
是內容被替換的地方

00:06:57.384 --> 00:06:58.719 
您的內容就在它下面

00:06:59.620 --> 00:07:01.755 
但是從Mac OS X.10 開始

00:07:02.556 --> 00:07:07.361 
您可實際利用一個完整的內容區

00:07:07.961 --> 00:07:11.164 
它可以在標題欄
和工具欄下面擴展

00:07:11.498 --> 00:07:12.599 
那麼您的標題欄

00:07:12.666 --> 00:07:16.537 
和工具欄將會在它後面
自動爲您進行模糊化處理

00:07:16.603 --> 00:07:18.772 
而您可以在這個位置爲您的視圖

00:07:18.839 --> 00:07:21.441 
放置全屏輔助視圖控制器

00:07:23.210 --> 00:07:25.913 
那麼您怎樣才能實現
那種全屏蒙板效果呢？

00:07:25.979 --> 00:07:28.482 
它真的是很容易的
您只需在window.styleMask後面

00:07:28.549 --> 00:07:30.918 
加上NSFullSize
ContentViewWindowMask

00:07:30.984 --> 00:07:34.421 
而那將讓您的內容在標題欄下
以全尺寸顯示

00:07:35.622 --> 00:07:38.825 
用於使用標題欄
輔助視圖控制器的實際API

00:07:38.892 --> 00:07:41.228 
這些控制器是
NSViewController的

00:07:41.295 --> 00:07:42.362 
一個非常簡單的子類

00:07:42.696 --> 00:07:44.765 
因此所有的標準視圖控制器

00:07:44.831 --> 00:07:46.333 
將會與它互動
決定如何加載它們

00:07:46.400 --> 00:07:49.603 
而它增加了兩個屬性一個是
layoutAttribute

00:07:49.670 --> 00:07:51.972 
另一個是FullScreenMin
Height

00:07:52.039 --> 00:07:53.907 
過一會我將談到它們

00:07:53.974 --> 00:07:55.475 
但是讓我們看一下

00:07:55.542 --> 00:07:58.278 
標題欄輔助視圖控制器
能爲您做的幾件事情

00:07:58.946 --> 00:08:00.113 
正如我以前所說的

00:08:00.180 --> 00:08:04.484 
它們將自動爲您模糊化處理
它們後面的一切東西

00:08:04.551 --> 00:08:05.953 
您無須做任何特別的事情

00:08:06.687 --> 00:08:08.789 
它自動以某種視覺效果爲您呈現

00:08:08.989 --> 00:08:10.691 
那就是實際的模糊化處理

00:08:11.191 --> 00:08:13.227 
它們自動以全屏狀態顯示

00:08:13.594 --> 00:08:15.729 
因此當您的窗口進入全屏
或退出全屏時

00:08:15.796 --> 00:08:17.264 
它們被放置在正確的位置

00:08:17.965 --> 00:08:20.200 
而且在某種程度上
它的大小也是自動爲您管理的

00:08:20.267 --> 00:08:22.569 
而我們稍後將討論這個內容

00:08:23.370 --> 00:08:27.975 
那麼讓我們看一下第一個屬性layo
utAttribute（佈局屬性）

00:08:29.743 --> 00:08:34.313 
那麼這裏就是佈局屬性
當它被設置爲“.bottom”時

00:08:34.881 --> 00:08:36.783 
“.bottom”的意思是您的視圖

00:08:36.850 --> 00:08:39.720 
將被放在標題欄的下方

00:08:40.554 --> 00:08:43.590 
它的高度是您在NIB文件中
爲該視圖實際指定的任何高度

00:08:43.657 --> 00:08:45.859 
或者是您以任何方式指定的高度

00:08:45.926 --> 00:08:48.962 
而寬度會隨着窗口大小的更改
而自動變化

00:08:51.365 --> 00:08:52.900 
另一個選項是 “.right”

00:08:53.467 --> 00:08:55.269 
這是一個 Safari 的例子

00:08:55.669 --> 00:08:57.871 
他們在使用 “.right” 選項

00:08:57.938 --> 00:09:00.274 
以便當Safari窗口
處於非全屏或全屏時

00:09:00.340 --> 00:09:02.543 
向Safari窗口添加 
“+” 按鈕

00:09:03.477 --> 00:09:06.213 
寬度是視圖已經指定的任何寬度

00:09:06.580 --> 00:09:10.350 
而高度則是自動設定爲
標題欄或工具欄的高度

00:09:11.852 --> 00:09:16.557 
Mac OS 10.11 的新特性
還包括指定一個“.left”的能力

00:09:17.191 --> 00:09:20.093 
通過它 你可以把項目

00:09:20.160 --> 00:09:21.862 
放在窗口按鈕旁邊

00:09:22.029 --> 00:09:24.998 
所以您可以在這裏
添加一個註冊按鈕

00:09:25.065 --> 00:09:27.734 
或者您希望
向用戶展示的其他備註

00:09:28.569 --> 00:09:32.806 
而這就是X.11的另一個新特性

00:09:34.274 --> 00:09:36.910 
接下來我們有全屏幕最小高度

00:09:38.145 --> 00:09:39.446 
讓我們看一下那個屬性

00:09:40.380 --> 00:09:42.749 
那麼全屏幕最小高度
是什麼意思呢？

00:09:43.016 --> 00:09:45.519 
這個屬性僅當您

00:09:45.719 --> 00:09:47.855 
已處於全屏狀態時才適用

00:09:48.388 --> 00:09:50.524 
而這就是您在全屏狀態下

00:09:50.724 --> 00:09:52.125 
能夠看見的最小高度

00:09:53.093 --> 00:09:55.529 
當您將鼠標移動到
工具欄之上時

00:09:55.596 --> 00:09:58.232 
任何未被顯示的內容
將被自動顯示

00:09:58.298 --> 00:10:00.601 
過一會兒我將向您展示
那種情況的一些屏幕快照

00:10:01.068 --> 00:10:02.669 
工具欄的默認高度爲 0

00:10:03.670 --> 00:10:05.372 
那麼讓我們看一下
它的意思是什麼

00:10:06.173 --> 00:10:07.908 
那麼 全屏幕最低高度爲 0

00:10:08.442 --> 00:10:09.576 
這裏是一個工具欄

00:10:09.943 --> 00:10:13.914 
那裏是一個輔助視圖控制器
但它是隱藏的

00:10:13.981 --> 00:10:15.215 
因爲高度爲 0

00:10:15.849 --> 00:10:17.184 
如果高度不是 0

00:10:17.451 --> 00:10:20.821 
您在那裏將總是會看到
您設定的任何值

00:10:21.788 --> 00:10:23.023 
用戶讓其顯示的方式是

00:10:23.090 --> 00:10:27.160 
當你把鼠標移到菜單欄上部時
標題欄將被顯示

00:10:27.594 --> 00:10:31.798 
而您的全屏輔助視圖也將隨其
自動顯示

00:10:33.834 --> 00:10:35.202 
那樣將把該部位突出顯示

00:10:37.471 --> 00:10:40.841 
如果您已經用過 NSToolbar
您可能已經熟悉了

00:10:40.908 --> 00:10:43.110 
NSToolbar實現的
全屏輔助視圖

00:10:43.477 --> 00:10:47.548 
而這個新的標題欄輔助視圖控制器
取代了這個舊的 API

00:10:47.814 --> 00:10:50.050 
因此我們不鼓勵您再使用它

00:10:50.684 --> 00:10:53.120 
但是最小高度和最大高度屬性的
工作原理

00:10:53.187 --> 00:10:56.123 
與標題欄輔助視圖控制器裏面的
非常類似

00:10:58.926 --> 00:11:00.460 
那麼您如何實際添加它們呢?

00:11:00.527 --> 00:11:02.863 
我們在 NSWindow 
上有四種方法

00:11:02.930 --> 00:11:06.200 
我們有一系列的
標題欄輔助視圖控制器

00:11:06.266 --> 00:11:08.068 
您可以讀取窗口的附件

00:11:09.036 --> 00:11:09.870 
您可以添加它們

00:11:10.871 --> 00:11:12.372 
您可以將它們
作爲特殊索引插入

00:11:13.106 --> 00:11:15.008 
而且您也可以將其
作爲特殊索引刪除

00:11:15.142 --> 00:11:17.611 
但它確實是容易
添加和刪除的

00:11:17.678 --> 00:11:19.913 
那麼這裏是您通常將要做的事情

00:11:20.247 --> 00:11:23.383 
您將調用Window.AddTitleBar
AccessoryViewController

00:11:23.717 --> 00:11:26.987 
將您的輔助視圖控制器傳遞給它
然後當您希望去掉它時

00:11:27.054 --> 00:11:29.857 
您將使用默認的
NSViewController API

00:11:29.923 --> 00:11:32.593 
將其從父視圖控制器中移除
父視圖控制器自動確定它的位置

00:11:32.659 --> 00:11:34.795 
並將其移除

00:11:36.897 --> 00:11:40.067 
關於標題欄輔助視圖控制器
就講那麼多

00:11:40.133 --> 00:11:41.969 
讓我們談一下全屏幕平鋪

00:11:42.336 --> 00:11:45.072 
以及 Mac OS 10.11
裏面的一些新特性

00:11:46.406 --> 00:11:49.243 
那麼全屏幕平鋪的目的是什麼？

00:11:49.576 --> 00:11:51.512 
它們仍然讓您或用戶的注意力

00:11:51.578 --> 00:11:53.680 
集中在某個單一任務上

00:11:53.747 --> 00:11:55.782 
但是它可能涉及到多個窗口

00:11:56.617 --> 00:11:58.552 
您必須利用屏幕的全部空間

00:11:58.952 --> 00:12:01.889 
那麼在這個屏幕快照上
我們有Safari瀏覽器窗口

00:12:01.955 --> 00:12:06.293 
在邊上有提示信息
讓我們同時關注幾個任務

00:12:06.360 --> 00:12:09.196 
那麼讓我們看一下
當您實際處於這一狀態

00:12:09.263 --> 00:12:12.366 
並調整分割器大小的時候
會發生些什麼

00:12:12.766 --> 00:12:16.637 
請注意 隨着我改變其大小
Safari窗口達到了最小狀態

00:12:17.204 --> 00:12:18.639 
並且提醒欄也達到最小狀態

00:12:18.705 --> 00:12:23.577 
而且對於一個給定窗口
不會讓它收縮得太厲害

00:12:23.744 --> 00:12:26.547 
因此它有一個可以達到的
最小和最大狀態

00:12:27.915 --> 00:12:29.149 
那麼我將談一下如何實現

00:12:29.716 --> 00:12:30.717 
以及您需要做些什麼

00:12:31.485 --> 00:12:34.988 
但是讓我們先討論一下
什麼樣的窗口

00:12:35.055 --> 00:12:36.323 
可以進行全屏幕平鋪

00:12:37.724 --> 00:12:40.827 
我們將明確允許任何窗口

00:12:40.894 --> 00:12:46.033 
進入全屏平鋪
只要它的大小可調並且不是面板

00:12:46.200 --> 00:12:48.302 
那意味着你的窗口不必

00:12:48.368 --> 00:12:49.903 
一定是可全屏化的

00:12:50.270 --> 00:12:52.439 
但是它仍可以被添加並平鋪到

00:12:52.673 --> 00:12:54.474 
另一個可全屏化的窗口內

00:12:55.008 --> 00:12:57.244 
具體我們做些什麼

00:12:57.311 --> 00:12:59.246 
以及如何確定都會隨時間改變

00:13:00.013 --> 00:13:02.449 
因此您可能希望
讓這個過程更明確

00:13:03.417 --> 00:13:06.587 
那麼讓我們假定
您有一個可調整大小的窗口

00:13:06.687 --> 00:13:09.289 
它無法被放入平鋪窗口
而你希望將它放入平鋪窗口

00:13:09.356 --> 00:13:12.025 
您可以在collection 
Behavior後

00:13:12.092 --> 00:13:15.162 
明確添加FullScreenAll
owsTiling

00:13:15.229 --> 00:13:17.297 
使其能夠被放入平鋪窗口

00:13:18.465 --> 00:13:21.034 
類似地 您可能有一個窗口

00:13:21.101 --> 00:13:22.669 
您希望它永遠不被放入平鋪

00:13:23.136 --> 00:13:26.139 
那麼我們就規定...
它可以被放入平鋪

00:13:26.206 --> 00:13:27.508 
但是您不希望它被放入平鋪

00:13:27.774 --> 00:13:30.143 
因此您可以讓
FullScreenDisallowsTiling

00:13:30.210 --> 00:13:31.044 
來防止它被平鋪

00:13:32.112 --> 00:13:35.148 
此外 您可能有一個窗口
您讓它全屏化

00:13:35.215 --> 00:13:37.751 
而且希望它總是獨立狀態
您可以在那個窗口上設置

00:13:37.818 --> 00:13:40.654 
FullScreen
DisallowsTiling

00:13:40.721 --> 00:13:43.657 
以防止任何其他窗口
與它放在一起

00:13:45.025 --> 00:13:47.995 
那麼現在您瞭解瞭如何

00:13:48.061 --> 00:13:49.062 
讓一個窗口進入平鋪

00:13:49.463 --> 00:13:50.797 
讓我們談一下那個窗口的

00:13:50.864 --> 00:13:52.633 
最小和最大尺寸

00:13:52.999 --> 00:13:55.836 
通常 當您的窗口
未處於全屏狀態時

00:13:56.136 --> 00:13:59.540 
您可以調整其大小
並且自動受到

00:13:59.606 --> 00:14:00.574 
其最小和最大尺寸限制

00:14:00.641 --> 00:14:04.778 
而當你使用 AutoLayout 
時那通常是由 AutoLayout

00:14:04.845 --> 00:14:06.146 
自動確定的

00:14:06.980 --> 00:14:08.982 
如果您沒有使用
 AutoLayout

00:14:09.349 --> 00:14:12.486 
那麼窗口的最大和最小尺寸
就發揮作用了

00:14:12.553 --> 00:14:13.987 
那些只是顯示的

00:14:14.054 --> 00:14:15.455 
您在窗口內設置的屬性

00:14:15.522 --> 00:14:17.858 
或者是內容的最小尺寸
或者是內容的最大尺寸,

00:14:17.925 --> 00:14:19.459 
都取決於您使用的API

00:14:19.993 --> 00:14:22.229 
如果您選中一個窗口
並準備將其全屏化

00:14:22.296 --> 00:14:26.066 
或者您準備全屏平鋪
那些就是您

00:14:26.133 --> 00:14:27.568 
通常應該使用的API

00:14:28.101 --> 00:14:29.803 
但是那個規則也會有例外

00:14:29.870 --> 00:14:32.339 
而我們有更多的API來解決例外

00:14:33.073 --> 00:14:36.176 
首先讓我們談一下該規則的一個例外
以及您將做些什麼

00:14:36.376 --> 00:14:38.011 
那麼這裏是可能是一個小的

00:14:38.078 --> 00:14:39.479 
計算器應用

00:14:39.546 --> 00:14:41.215 
它的尺寸是不可調整的

00:14:41.648 --> 00:14:44.351 
那麼這位開發者就可能說
好吧 我們將讓它

00:14:44.418 --> 00:14:45.385 
放入平鋪

00:14:46.320 --> 00:14:49.756 
但是當它被放入平鋪的時候
如這裏所示

00:14:50.123 --> 00:14:52.926 
現在那個計算器應用的高度
比以前高了很多

00:14:52.993 --> 00:14:55.796 
即使它是不可調整大小的

00:14:56.196 --> 00:14:58.532 
因此它需要對其進行處理
並做些特殊的事情

00:14:59.333 --> 00:15:02.202 
您可能還會在那裏加些額外視圖
以便在其全屏平鋪時

00:15:02.269 --> 00:15:04.771 
向用戶顯示更多信息

00:15:05.372 --> 00:15:06.874 
因此您可以動態實現這種效果

00:15:06.940 --> 00:15:09.643 
而且您只是使用一些
window delegate方法

00:15:09.710 --> 00:15:12.246 
WindowWillEnter
FullScreen

00:15:12.312 --> 00:15:14.548 
而在這種特定情況下
當我們進入全屏模式時

00:15:14.615 --> 00:15:16.383 
我們將取消一些視圖的隱藏狀態

00:15:16.450 --> 00:15:17.951 
更改一些約束優先級

00:15:18.018 --> 00:15:20.153 
當窗口處於全屏化時
它們讓系統對窗口大小

00:15:20.220 --> 00:15:21.688 
實際進行調整

00:15:22.022 --> 00:15:24.525 
而當它退出全屏幕時
它再將那些工作取消

00:15:24.591 --> 00:15:27.160 
重要的一點是知道
你實際可能必須

00:15:27.227 --> 00:15:31.832 
使用這些 delegate 方法
即使您的窗口

00:15:31.899 --> 00:15:33.700 
通常並不構成一個全屏幕主窗口

00:15:34.168 --> 00:15:36.270 
因此這可能是爲一個平鋪窗口調用

00:15:38.305 --> 00:15:42.576 
現在那些窗口
在進入全屏狀態之前

00:15:42.643 --> 00:15:43.944 
它們的尺寸是尤其厚的

00:15:44.011 --> 00:15:46.013 
但是當它們處於全屏狀態時
尺寸就不同了

00:15:46.747 --> 00:15:49.783 
當它將進入全屏狀態時
您很可能

00:15:49.883 --> 00:15:51.351 
需要告訴系統那些尺寸

00:15:51.418 --> 00:15:53.187 
那麼我們有一個
顯式API來實現

00:15:53.253 --> 00:15:56.190 
我們有一個minFull
ScreenContentSize

00:15:56.356 --> 00:15:59.526 
和一個maxFullScreen
ContentSize來實現

00:15:59.593 --> 00:16:02.095 
您需要及早設置這些參數
因爲如果您

00:16:02.162 --> 00:16:04.865 
曾經嘗試 Mac OS 10.11
您可能注意到當您點擊並

00:16:04.932 --> 00:16:07.568 
按住綠色按鈕不放的時候
系統會爲您提供

00:16:07.634 --> 00:16:10.771 
尺寸符合可用空間的
其他備選窗口供您選擇

00:16:11.538 --> 00:16:14.808 
因此 作爲開發者
您需要及早設置這些最小值

00:16:15.409 --> 00:16:16.476 
以便讓系統能夠確定

00:16:16.543 --> 00:16:18.879 
適合該區域的潛在備選窗口

00:16:20.013 --> 00:16:22.049 
正如我以前所言
通常您不需要使用這些設置

00:16:22.115 --> 00:16:24.117 
當您的窗口正好
是通常的尺寸可調窗口的話

00:16:24.184 --> 00:16:25.986 
它們在很大程度上是自動的

00:16:26.787 --> 00:16:28.555 
那麼這就會導致一種兩難困境

00:16:28.722 --> 00:16:32.292 
如果您的窗口尺寸
比如說是1200

00:16:32.359 --> 00:16:36.563 
而另外一個窗口
窗口 B 的尺寸是 300

00:16:36.630 --> 00:16:38.699 
會發生什麼?

00:16:40.100 --> 00:16:41.201 
那麼系統將不會

00:16:41.268 --> 00:16:44.137 
讓這兩個窗口在一起

00:16:44.538 --> 00:16:48.108 
它們的minFullScreenC
ontentSize值太大

00:16:48.342 --> 00:16:49.409 
而無法實現

00:16:50.511 --> 00:16:52.980 
那麼作爲開發者
您需要做些什麼呢？

00:16:54.515 --> 00:16:56.950 
對於這方面我將請上我的同事
Taylor Kelly

00:16:57.017 --> 00:16:59.253 
他將會討論如何通過靈活佈局

00:16:59.319 --> 00:17:00.420 
而解決那個問題

00:17:00.487 --> 00:17:01.922 
謝謝大家！

00:17:14.201 --> 00:17:15.035 
大家好！

00:17:15.102 --> 00:17:16.603 
在這下半個環節中
我們將討論

00:17:16.670 --> 00:17:19.106 
如何讓您的佈局更靈活

00:17:19.173 --> 00:17:22.409 
尤其當它們處於新的Split
View中時可以被調整到多窄

00:17:23.609 --> 00:17:26.713 
在 Mac 平臺上我們有
多種顯示尺寸

00:17:26.780 --> 00:17:27.948 
供您的應用在其上運行

00:17:28.015 --> 00:17:31.251 
而在全屏狀態下
用戶能夠將其自身全部浸入

00:17:31.451 --> 00:17:32.686 
佔據整個顯示空間

00:17:33.820 --> 00:17:36.390 
在Split View下
用戶現在可以讓另外一個窗口

00:17:36.456 --> 00:17:39.326 
進入這個環境
從而營造一種更豐富的體驗

00:17:40.093 --> 00:17:43.163 
但是這要求兩個窗口靈活的

00:17:43.263 --> 00:17:45.499 
其尺寸大小可以調整

00:17:45.966 --> 00:17:47.334 
以防止出現衝突的情況

00:17:47.401 --> 00:17:49.102 
Corbin 早些時候
也談到了這一點

00:17:49.803 --> 00:17:52.739 
這對於較小顯示尺寸
如Retina MacBook

00:17:52.940 --> 00:17:54.241 
可能是尤其嚴格的

00:17:55.008 --> 00:17:58.579 
它的默認分辨率爲1280*800

00:17:59.046 --> 00:18:00.747 
表示在Split View中

00:18:00.814 --> 00:18:03.917 
當平均分割時
每個窗口大約被分配638

00:18:03.984 --> 00:18:05.552 
每個窗口大約被分配638個點

00:18:05.619 --> 00:18:07.955 
如果您的應用的最小寬度

00:18:08.021 --> 00:18:10.791 
目前比這個大
這些顯示尺寸的用戶

00:18:10.858 --> 00:18:12.459 
通常將不能將您的應用平鋪

00:18:13.727 --> 00:18:17.030 
因此我將談一下
您可以使用的四種技巧

00:18:17.097 --> 00:18:19.566 
以確保您的窗口在全屏狀態下
有令人滿意的表現

00:18:20.400 --> 00:18:22.636 
首先 是使用自動佈局和優先條件

00:18:23.504 --> 00:18:26.306 
其次是自動摺疊的新側欄行爲

00:18:27.341 --> 00:18:30.110 
然後是使用 NSStackView
輕易地構建

00:18:30.177 --> 00:18:32.679 
您的界面的各個部分
同時將靈活性內置其中

00:18:33.213 --> 00:18:35.849 
最後是更新過的
NSCollectionView

00:18:35.916 --> 00:18:37.918 
它有了強大的佈局支持

00:18:40.954 --> 00:18:43.223 
那麼自動佈局是一個
我們在OSX Lion和iOS 6中

00:18:43.290 --> 00:18:45.926 
推出的基於約束條件的佈局系統

00:18:46.360 --> 00:18:49.062 
它讓您聲明不同的
UI 元素之間的關係

00:18:49.129 --> 00:18:51.398 
比如它們的間隔或者對齊

00:18:52.266 --> 00:18:53.634 
而它確實是強大的

00:18:53.700 --> 00:18:55.369 
窗口的視圖尺寸被動態調整

00:18:55.636 --> 00:18:56.770 
比如在進行本地化的時候

00:18:57.771 --> 00:18:59.740 
您可以在這些約束條件之間
建立優先順序

00:18:59.806 --> 00:19:01.975 
讓級別高的優先於級別低的

00:19:03.043 --> 00:19:04.811 
對此我將不去過多討論細節

00:19:04.878 --> 00:19:06.346 
今天早些時候有兩個講座

00:19:06.413 --> 00:19:08.282 
《自動佈局的奧祕》的
第一和第二部分

00:19:08.348 --> 00:19:10.117 
不管您在自動佈局方面
是初次接觸還是已有接觸

00:19:10.184 --> 00:19:11.652 
它都有一些確實不錯的內容

00:19:12.186 --> 00:19:14.054 
相反 在這個 UI 例子中

00:19:14.121 --> 00:19:15.222 
我將重點關注優先順序

00:19:16.190 --> 00:19:18.625 
我們在中部有一個標籤
它的左右兩側

00:19:18.692 --> 00:19:20.127 
都有固定按鈕

00:19:20.360 --> 00:19:22.829 
這些可能是您會用來創建
那種效果的水平約束

00:19:23.630 --> 00:19:26.466 
僅僅使用這些約束的話
如果視圖的尺寸動態調整

00:19:26.800 --> 00:19:29.369 
您最後可能會
讓標籤和較寬的按鈕相互重疊

00:19:30.037 --> 00:19:31.371 
這是非常容易解決的

00:19:31.438 --> 00:19:34.107 
您可以在按鈕和標籤之間
增加一個最小間隔約束

00:19:34.741 --> 00:19:36.310 
而現在
當容器的尺寸調整時

00:19:36.510 --> 00:19:37.744 
它的尺寸只能調整到

00:19:37.811 --> 00:19:41.081 
它能同時滿足
居中對齊和最小間隔的程度

00:19:41.882 --> 00:19:44.518 
這是一個完美的佈局
除非這個視圖

00:19:44.585 --> 00:19:46.486 
能夠變得更緊湊

00:19:46.720 --> 00:19:49.590 
去掉較窄按鈕和標籤之間的
	那些空白就太好了

00:19:50.958 --> 00:19:54.194 
回過來 我們可以讓這個
居中對齊成爲可選條件

00:19:54.494 --> 00:19:56.864 
意思是它可以
被更優先的約束條件打破

00:19:57.531 --> 00:19:59.600 
此外 我們將會
在標籤和較窄按鈕之間

00:19:59.666 --> 00:20:02.302 
增加一個最小間隔
以防在那一側出現重疊

00:20:03.170 --> 00:20:05.639 
這次 標籤儘可能居中

00:20:05.973 --> 00:20:08.008 
直到它觸及了最小間隔的填充

00:20:08.075 --> 00:20:11.044 
而如果我們繼續調整容器的大小
我們可以打破居中條件

00:20:11.111 --> 00:20:12.813 
以便最大化地壓縮佈局

00:20:12.880 --> 00:20:17.484 
直到我們
滿足兩側的最小填充

00:20:18.185 --> 00:20:20.187 
您可以僅僅
通過設置優選順序屬性

00:20:20.254 --> 00:20:21.955 
來爲您的約束條件
進行這樣的設置

00:20:22.022 --> 00:20:24.992 
而這也通過Interface
Builder暴露出來

00:20:25.726 --> 00:20:27.761 
默認情況下 
需要滿足約束條件

00:20:27.928 --> 00:20:29.096 
就是說它們必須被滿足

00:20:29.162 --> 00:20:32.132 
但是任何低於那個的
約束條件將成爲可選的

00:20:32.933 --> 00:20:35.002 
我們有些要點
幫您決定您的約束條件

00:20:35.068 --> 00:20:36.303 
優先順序應該是什麼樣子

00:20:36.370 --> 00:20:38.572 
另外還有Default Low
它是一個優先條件

00:20:38.639 --> 00:20:41.074 
通常您的約束條件
弱於大多數其他約束軟件

00:20:41.141 --> 00:20:43.944 
還有DragThatCannot
ResizeWindow

00:20:44.011 --> 00:20:45.112 
它是一個特定的優先條件

00:20:45.179 --> 00:20:47.648 
在此條件下一個Split
View分割線會被拖動

00:20:47.714 --> 00:20:49.216 
如果您希望自己的約束條件

00:20:49.283 --> 00:20:51.618 
比這種行爲更加強大
您應讓您的優先條件級別更高,

00:20:51.685 --> 00:20:52.886 
否則更低

00:20:52.953 --> 00:20:55.689 
您通常永遠不會
設置跟這個完全一樣的優先條件

00:20:55.756 --> 00:20:58.458 
此外還有WindowsSize
StayPut

00:20:58.525 --> 00:21:00.427 
這個優先條件規定
一個窗口維持當前的尺寸

00:21:00.494 --> 00:21:03.730 
最後是DragThatCanRes
izeWindow

00:21:03.797 --> 00:21:05.432 
在這個條件下一個窗口被拖拽

00:21:05.499 --> 00:21:08.702 
但是還有 Default High
它是另外一個優先條件

00:21:08.769 --> 00:21:10.571 
在此條件下您的約束條件

00:21:10.637 --> 00:21:11.972 
通常高於多數其他條件

00:21:12.539 --> 00:21:14.608 
那麼這就是Auto Layout的
優先條件

00:21:14.675 --> 00:21:16.844 
在此後的幾個部分內

00:21:16.910 --> 00:21:18.579 
我將回過頭來
參考一下優先權的概念

00:21:18.645 --> 00:21:22.082 
但是接下來我想談一下NSSplit
ViewController

00:21:22.149 --> 00:21:24.985 
這是我們在Yosemite中
推出的一個容器視圖控制器類

00:21:25.052 --> 00:21:27.187 
它讓您的子視圖控制器

00:21:27.254 --> 00:21:28.989 
被安排在
 NSSplitView 內

00:21:29.389 --> 00:21:31.525 
並且暴露了
NSSplitView 項目的概念

00:21:31.692 --> 00:21:34.828 
它概括了那些在Split
View中的子類的狀態

00:21:34.895 --> 00:21:37.064 
這些子類包括
holdingpriority

00:21:37.130 --> 00:21:41.235 
Collapsed狀態而且它允許以
一種真正簡單的方式獲得動態摺疊效果

00:21:41.301 --> 00:21:44.505 
去年的OSX Storyboard
和控制器講座更多地討論了

00:21:44.571 --> 00:21:46.373 
這個特性以及其他
視圖控制器特性

00:21:46.440 --> 00:21:49.176 
但是我想重點談一下
OS 10.11中的新內容

00:21:50.143 --> 00:21:52.479 
首先是側邊欄的顯式概念

00:21:52.546 --> 00:21:54.281 
及其伴隨的特殊行爲

00:21:54.815 --> 00:21:57.184 
以及spring loading
它是當一個項目

00:21:57.251 --> 00:22:00.053 
被在Split View中拖拽時
可能發生的行爲

00:22:00.387 --> 00:22:02.089 
以及幾個新的度量指標

00:22:02.155 --> 00:22:06.026 
它們讓您在調整大小期間
精確地聲明

00:22:06.093 --> 00:22:07.361 
Split View的行爲

00:22:08.662 --> 00:22:11.198 
我們看一個例子
這裏是 Safari 中的側邊欄

00:22:11.899 --> 00:22:14.835 
隨着窗口尺寸的調整
一旦它達到某個點

00:22:14.902 --> 00:22:16.436 
側邊欄將會自動摺疊

00:22:16.603 --> 00:22:19.306 
而如果它在全屏狀態被重新顯示

00:22:19.373 --> 00:22:21.842 
它將覆蓋其他窗口內容

00:22:22.543 --> 00:22:24.945 
這個過程是短暫的
類似於彈出框

00:22:25.012 --> 00:22:26.914 
因此點擊其外側將使其自動消失

00:22:26.980 --> 00:22:28.282 
這真的是容易理解的

00:22:28.348 --> 00:22:30.417 
您只須在
NSSplitViewItem上

00:22:30.484 --> 00:22:33.921 
使用sidebarWithView
Controller這一構造函數

00:22:33.987 --> 00:22:36.924 
或者在Interface
Builder中將行爲傳遞給側邊欄

00:22:36.990 --> 00:22:39.359 
這將返回給您
一個split view項目

00:22:39.426 --> 00:22:41.762 
您可以把它添加到
您的split view控制器上

00:22:41.828 --> 00:22:44.531 
而且它也伴隨一些特殊行爲
比如 Yosemite 中將推出的

00:22:44.598 --> 00:22:47.134 
內置的半透明材質背景
和醒目的分割線

00:22:47.201 --> 00:22:48.969 
您不必再加入您自己的
視頻效果視圖

00:22:49.036 --> 00:22:50.637 
才能獲得這種效果

00:22:50.871 --> 00:22:53.607 
NSSplitViewItem
將會爲您進行添加和管理

00:22:53.774 --> 00:22:55.609 
此外還有您剛纔看到的

00:22:55.676 --> 00:22:58.712 
autocollapse
和autouncollapse行爲

00:22:58.779 --> 00:23:00.514 
通過它 覆蓋層將佔據整個屏幕

00:23:01.915 --> 00:23:03.851 
此外還有另外幾個默認屬性

00:23:03.917 --> 00:23:05.352 
以及側邊欄的標準值

00:23:05.686 --> 00:23:08.288 
因此您的側邊欄對系統的行爲
正如其他要素一樣

00:23:09.022 --> 00:23:11.325 
伴隨它的
還有一個split view方面的

00:23:11.391 --> 00:23:13.393 
新的行爲方法
即 toggleSidebar

00:23:13.460 --> 00:23:15.562 
它將具有動畫效果地摺疊或

00:23:15.629 --> 00:23:17.564 
展開它包含的第一個側邊欄

00:23:18.532 --> 00:23:20.667 
通過這種方式 
無須書寫一行代碼

00:23:20.734 --> 00:23:24.004 
您就可以關聯菜單項
使其具有這種效果 或切換按鈕

00:23:25.539 --> 00:23:28.408 
另外一個確實很酷的行爲
是spring loading

00:23:28.475 --> 00:23:31.144 
這是當用戶在您的split
view邊緣上存在摺疊窗格

00:23:31.211 --> 00:23:34.781 
並將一個項目向該邊緣拖拽時
發生的行爲

00:23:35.516 --> 00:23:38.085 
我們將平移並讓側邊欄展開

00:23:38.151 --> 00:23:41.154 
讓它們與其互動在它們的動作完成之後
讓側邊欄再次摺疊

00:23:41.221 --> 00:23:44.591 
您可通過將springLoaded
設爲True來達到此效果

00:23:44.658 --> 00:23:47.160 
在您的split view項目中
您將獲得此行爲效果

00:23:47.227 --> 00:23:49.830 
且對側邊欄和非側邊欄同樣適用

00:23:50.163 --> 00:23:52.566 
區別在於
側邊欄將默認爲 True

00:23:52.866 --> 00:23:54.635 
我們認爲大多數的側邊欄
將希望這種行爲

00:23:54.701 --> 00:23:58.572 
接下來我想談一下我們在NSSpli
tViewItem控制器上的

00:23:58.739 --> 00:24:00.374 
幾個新的度量指標

00:24:00.440 --> 00:24:02.042 
我將每次講兩個

00:24:02.109 --> 00:24:04.478 
首先是
minimumThickness

00:24:04.545 --> 00:24:06.413 
和maximumThickness

00:24:06.480 --> 00:24:08.649 
這些與split view項目
正在自我管理的

00:24:08.715 --> 00:24:10.217 
約束條件直接相關

00:24:10.284 --> 00:24:13.287 
它們描述了這個項目
可以實際變得多大或多小

00:24:14.021 --> 00:24:15.989 
側邊欄將默認將這些值
設爲標準值

00:24:16.290 --> 00:24:17.424 
但這的確是一個

00:24:17.491 --> 00:24:20.694 
您自己設置約束條件的
非常方便的方式

00:24:22.262 --> 00:24:25.632 
HoldingPriority是OS 10.11中
惟一的一個不是新的度量指標

00:24:25.832 --> 00:24:26.900 
它描述了split view 項目

00:24:26.967 --> 00:24:29.002 
維持其當前大小的一個優先權

00:24:29.636 --> 00:24:31.305 
在本例中
側邊欄被默認設置爲

00:24:31.371 --> 00:24:33.640 
一個略高的值
因此這意味着它們比其他項目

00:24:33.707 --> 00:24:35.375 
被調整尺寸的可能性更小

00:24:36.243 --> 00:24:38.212 
那麼作爲一個例子
當它調整此窗口大小時

00:24:38.312 --> 00:24:40.280 
尺寸調整的全部權重
都分配給了內容區

00:24:40.347 --> 00:24:42.316 
而側邊欄的寬度保持不變

00:24:43.884 --> 00:24:45.085 
回顧一下 你可能也將這個

00:24:45.152 --> 00:24:46.820 
設置爲在兩個項目間

00:24:46.920 --> 00:24:48.021 
具有同樣的保持優先權

00:24:48.722 --> 00:24:50.691 
如果您熟悉自動佈局
您可能將這種情況

00:24:50.757 --> 00:24:51.959 
認爲是一種模棱兩可的情況

00:24:52.025 --> 00:24:54.595 
但是NSSplitView
會對這種情況進行特殊處理

00:24:54.661 --> 00:24:55.996 
這次當您調整其大小時

00:24:56.430 --> 00:24:58.365 
兩個視圖會根據
它們在尺寸調整之前的大小

00:24:58.432 --> 00:25:00.701 
按比例地調整大小

00:25:00.767 --> 00:25:02.803 
因此兩個視圖都尺寸
都被調整得稍微大一點

00:25:03.270 --> 00:25:05.339 
那就是
 holdingPriority

00:25:05.405 --> 00:25:08.876 
下一個度量指標是preferred
ThicknessFraction

00:25:08.942 --> 00:25:11.645 
它描述了某個split
view項目希望佔據的空間

00:25:11.712 --> 00:25:13.313 
佔split view的理想百分比

00:25:13.380 --> 00:25:15.582 
例如 側邊欄被默認爲15 %

00:25:16.383 --> 00:25:18.986 
當用戶進入全屏狀態
或雙擊分割線的時候

00:25:19.052 --> 00:25:21.722 
該項目將自動跳到那個首選厚度

00:25:21.922 --> 00:25:24.091 
它們的確非常容易地
就能恢復到那一標準值

00:25:25.459 --> 00:25:28.195 
作爲一個限值 自動最大厚度
對所有這些尺寸調整行爲

00:25:28.262 --> 00:25:30.197 
都發揮作用

00:25:30.631 --> 00:25:32.866 
如果15%對應於350的話

00:25:32.933 --> 00:25:35.335 
那麼它將被限制爲不超過280

00:25:35.802 --> 00:25:38.172 
那些是NSSplit
ViewItem度量指標

00:25:38.238 --> 00:25:41.508 
在NSSplitViewContr
oller上還有另一個度量指標

00:25:41.575 --> 00:25:46.346 
那就是用於內嵌側邊欄的
minimumThicknessForinlineSidebars

00:25:46.413 --> 00:25:49.483 
它描述了您的split view
控制器中側邊欄將自動摺疊的寬度

00:25:49.550 --> 00:25:51.752 
因此 將尺寸調整到那一數值
將讓它們保持內嵌狀態

00:25:51.818 --> 00:25:55.122 
進一步拖拽將讓您的側邊欄摺疊

00:25:55.189 --> 00:25:57.124 
這也適用於全屏幕狀態

00:25:57.624 --> 00:25:59.593 
關鍵區別在於
當處於全屏幕狀態時

00:25:59.660 --> 00:26:02.162 
如果它總是被明確重新顯示
它就被顯示爲疊加狀態

00:26:03.163 --> 00:26:05.065 
這說明瞭全屏狀態下的
一個重要概念

00:26:05.132 --> 00:26:07.534 
在全屏狀態下
我們希望避免讓窗口運行

00:26:07.634 --> 00:26:09.303 
以防止和相鄰元素的可能的衝突

00:26:09.903 --> 00:26:11.872 
在您的窗口內重新安排各個元素

00:26:11.939 --> 00:26:14.508 
總是比擴大窗口要好

00:26:14.575 --> 00:26:17.444 
爲支持NSSplit
ViewController中的

00:26:17.511 --> 00:26:19.880 
這樣一些新特性
我們已經對 NSSplitView

00:26:19.947 --> 00:26:23.150 
做出了一些改進
具體而言是通過對子視圖的排列

00:26:24.651 --> 00:26:25.953 
在 El Capitan 之前

00:26:26.220 --> 00:26:29.122 
split view中的所有子視圖
都被視爲分割開來的窗格

00:26:30.090 --> 00:26:31.358 
這意味着管理它的 API

00:26:31.425 --> 00:26:33.894 
只是從NSView繼承來的
子視圖 API

00:26:34.428 --> 00:26:36.997 
這是方便的但是也帶來了
兩個確實很大的問題

00:26:37.831 --> 00:26:39.967 
一個問題是您不能增加

00:26:40.033 --> 00:26:41.768 
您不希望被視爲分割窗格的子視圖

00:26:42.436 --> 00:26:43.904 
例如 分割線

00:26:44.204 --> 00:26:46.340 
在此模型中
分割線不可以由視圖表示

00:26:47.307 --> 00:26:49.676 
此外 您不能將 Z-順序

00:26:49.977 --> 00:26:51.512 
與子視圖的排列順序區別開來

00:26:51.845 --> 00:26:55.215 
因此您的零索引子視圖
是按Z順序的第一個也是最下的

00:26:55.282 --> 00:26:57.651 
而沒有辦法將它們區別

00:26:58.385 --> 00:27:00.721 
因此 現在在10.11中
您可以指定一定的子視圖

00:27:00.787 --> 00:27:04.324 
作爲使用NSSplitView的新
API而創建的split view

00:27:04.391 --> 00:27:05.559 
所排列的子視圖

00:27:05.626 --> 00:27:09.062 
在管理已被排列的子視圖方面這個AP
I與NSStackView的API

00:27:09.363 --> 00:27:11.732 
和UIStackView的
API精確匹配

00:27:11.798 --> 00:27:14.568 
此外還有這個屬性ArrangesA
llSubviews

00:27:14.635 --> 00:27:16.270 
它默認是 True

00:27:16.336 --> 00:27:18.438 
意思是說您的子視圖
仍總與被排列的子視圖相同

00:27:18.505 --> 00:27:20.908 
並且匹配那種遺留行爲

00:27:21.742 --> 00:27:24.912 
即使您將此屬性設爲False
NSSplitView 仍會確保

00:27:24.978 --> 00:27:27.047 
您的已被排列的子視圖

00:27:27.114 --> 00:27:29.149 
永遠是子視圖的一個子集

00:27:29.783 --> 00:27:32.119 
例如 如果您添加了
一個還不是子視圖的

00:27:32.186 --> 00:27:35.255 
被排列的子視圖
它將被添加爲子視圖

00:27:36.823 --> 00:27:39.693 
最後 我們鼓勵您開始使用
被排列的子視圖

00:27:39.760 --> 00:27:41.795 
並將ArrangesAllSubviews
設爲False

00:27:41.862 --> 00:27:42.829 
因爲當您那麼做的

00:27:42.896 --> 00:27:44.798 
時候NSSplitView
現在能夠使用視圖

00:27:44.865 --> 00:27:48.001 
代表分割線
併爲分割線的醒目性

00:27:48.235 --> 00:27:50.470 
和特殊的窗口拖拽行爲
創造條件

00:27:51.572 --> 00:27:53.340 
您可通過Interface 
Builder控制它

00:27:53.407 --> 00:27:55.709 
選中這個Arranges
All Subviews 複選框

00:27:56.009 --> 00:27:58.879 
更新後的 NIB 文件
將選中此複選框以匹配遺留行爲

00:27:59.279 --> 00:28:02.549 
但是從對象庫裏面拖拽出來的
新的split view將不會將其選中

00:28:02.616 --> 00:28:04.351 
這也是將來我們鼓勵的行爲

00:28:07.054 --> 00:28:10.457 
爲了幫研究您目前在split view
上可能有的問題或試圖理解

00:28:10.524 --> 00:28:11.792 
您的split view的工作機制

00:28:11.859 --> 00:28:14.561 
我們已經改進了對調試的描述
以便告訴您

00:28:14.628 --> 00:28:16.396 
諸如它如何執行佈局

00:28:16.463 --> 00:28:18.599 
以及它將用什麼
代表它的分割線

00:28:19.299 --> 00:28:20.968 
關於佈局 有幾種可能性

00:28:21.268 --> 00:28:24.004 
但是我們建議
確保split view使用約束條件

00:28:24.605 --> 00:28:27.641 
這讓它簡單地描述
它的分割窗格之間的關係

00:28:27.708 --> 00:28:29.743 
並與您在窗口中的
其他約束條件互動

00:28:30.377 --> 00:28:34.248 
此外 它將允許對您的
split view窗格的

00:28:34.548 --> 00:28:35.616 
從右到左的翻動

00:28:37.184 --> 00:28:39.920 
而且我們也建議...

00:28:40.387 --> 00:28:43.790 
開始使用視圖代表分割線

00:28:44.358 --> 00:28:45.759 
原因如我以前所述

00:28:46.827 --> 00:28:49.763 
爲了幫助弄清楚爲何您的split view
可以或不可使用約束條件

00:28:49.830 --> 00:28:51.865 
我們已經添加了
這個DebugReasonForLayoutMode

00:28:51.932 --> 00:28:55.903 
它將給您提供具有可讀性的描述以便了
解它是否會使用約束條件及其原因

00:28:56.737 --> 00:28:59.306 
最常見的原因是
Delegate將優先於特定的

00:28:59.373 --> 00:29:00.607 
與自動佈局不相容的方法

00:29:00.674 --> 00:29:02.976 
而且將準確地告訴您
那些方法是什麼

00:29:03.977 --> 00:29:05.779 
它是否在一個
使用自動佈局的窗口內

00:29:05.846 --> 00:29:07.881 
還將決定它是否可以使用約束條件

00:29:07.948 --> 00:29:11.451 
最後如果它正在被NSSplitVi
ew Controller使用

00:29:11.952 --> 00:29:13.554 
則要求它使用約束條件

00:29:15.389 --> 00:29:18.125 
而如果您曾試圖調試split
view的一些佈局問題

00:29:18.192 --> 00:29:20.060 
並已輸出約束條件

00:29:20.127 --> 00:29:21.962 
它很可能看上起像是這樣

00:29:22.563 --> 00:29:23.697 
它是很難解讀的

00:29:23.764 --> 00:29:25.699 
如果您確實希望理解它
您必須畫一張圖

00:29:26.166 --> 00:29:28.535 
您無法很好地辨別
哪些約束條件是您的app添加的

00:29:28.635 --> 00:29:30.971 
哪些約束條件是框架添加的

00:29:31.538 --> 00:29:35.342 
在OS10.11中NSSplitView
目前爲所有它添加的約束條件

00:29:35.409 --> 00:29:36.276 
給出識別符

00:29:36.343 --> 00:29:38.645 
因此您不僅可以辨別
您在使用哪些約束條件

00:29:38.712 --> 00:29:41.048 
而且還可知道它在試圖
用那個約束條件做些什麼

00:29:41.114 --> 00:29:42.182 
您可以快速地辨別

00:29:42.249 --> 00:29:43.917 
您的app添加了哪些約束條件

00:29:43.984 --> 00:29:46.086 
或者是否有怪異的
您無法確定在發生什麼的

00:29:46.153 --> 00:29:48.422 
尺寸調整行爲
您可以快速地看出

00:29:48.488 --> 00:29:50.891 
哪些約束條件可能會
解決那一問題

00:29:50.958 --> 00:29:53.627 
NSStackView有適用於
其每個約束條件的

00:29:53.961 --> 00:29:55.028 
類似的識別符

00:29:55.829 --> 00:29:58.065 
現在我想談一下
NSStackView

00:29:58.765 --> 00:30:00.868 
這是一個我們
在 Mavericks中引入的類

00:30:00.934 --> 00:30:02.836 
它確實簡化了

00:30:02.903 --> 00:30:05.806 
使用自動佈局進行的
水平或垂直視圖堆疊

00:30:06.006 --> 00:30:08.709 
它完全與您在窗口中使用的
其他約束條件相容

00:30:08.775 --> 00:30:10.777 
但是它會管理它使用的所有約束條件

00:30:10.844 --> 00:30:13.013 
來創建堆疊

00:30:13.080 --> 00:30:15.115 
因此您可以添加或移除視圖
而不必擔心

00:30:15.182 --> 00:30:16.583 
對那些約束條件的更新

00:30:17.484 --> 00:30:19.987 
它內置了對齊和分佈的概念

00:30:20.053 --> 00:30:22.189 
因此您可以控制您的視圖

00:30:22.256 --> 00:30:24.391 
在堆疊視圖內的放置方式

00:30:24.458 --> 00:30:26.793 
以及剪裁和附加行爲
因此當堆疊視圖

00:30:26.860 --> 00:30:28.862 
試圖建立比它所包含的視圖
更小的視圖時

00:30:28.929 --> 00:30:30.831 
您可以控制發生的事情

00:30:31.031 --> 00:30:33.100 
此外 在 10.11 中
我們做出了一系列性能改進

00:30:33.166 --> 00:30:34.968 
降低了它使用的約束條件的數量

00:30:35.035 --> 00:30:39.606 
並且從使用內部專用視圖
轉換到使用 NS 佈局指南

00:30:40.307 --> 00:30:42.709 
而我們已經看到一些
非常不錯的性能改進

00:30:43.677 --> 00:30:45.712 
《自動佈局的奧祕》的第一部分
談到了這一點

00:30:45.779 --> 00:30:47.915 
和新的UIStackView 在 iOS

00:30:47.981 --> 00:30:49.850 
以及對我們現在所擁有的

00:30:49.917 --> 00:30:52.619 
新的Interface
Builder的很好的支持

00:30:52.686 --> 00:30:54.721 
我的確想重點談一下
新的分配形式

00:30:54.988 --> 00:30:58.258 
它們描述了堆疊視圖
如何沿着堆疊軸排列

00:30:58.325 --> 00:31:02.095 
您可以通過NSStackView的
Distribution屬性

00:31:02.162 --> 00:31:04.531 
對此進行設置我將逐一說明
它們是如何工作的

00:31:04.598 --> 00:31:07.935 
那麼GravityAreas匹配
10.11 版本之前的行爲

00:31:08.001 --> 00:31:10.938 
通過它您可以指定特定的視圖
被吸引到split view的

00:31:11.004 --> 00:31:12.139 
特定的邊緣

00:31:12.206 --> 00:31:14.208 
對於水平方向
有領先 居中和尾隨

00:31:14.575 --> 00:31:16.210 
對於垂直方向
有頂部 居中和底部

00:31:16.276 --> 00:31:18.445 
那麼在本例中
隨着我們讓堆疊視圖的增加

00:31:18.912 --> 00:31:20.848 
這些視圖將趨向於朝邊緣移動

00:31:22.349 --> 00:31:25.052 
.Fill 是一個新的行爲
它要求各個視圖

00:31:25.118 --> 00:31:26.420 
將堆疊視圖完全填充

00:31:26.520 --> 00:31:29.957 
而通過使用其他約束條件
您可以決定它們的增長方式

00:31:30.023 --> 00:31:30.991 
或尺寸分配方式

00:31:31.892 --> 00:31:35.395 
在本例中 Tiny 已經設置了
最低的拖拽優先權

00:31:35.462 --> 00:31:37.164 
因此隨着我們讓堆疊視圖的增長

00:31:37.364 --> 00:31:39.032 
它獲得了全部的尺寸調整權重

00:31:39.499 --> 00:31:41.502 
.FillEqually 是類似的

00:31:41.568 --> 00:31:43.670 
只是現在堆疊視圖
將增加約束條件

00:31:43.770 --> 00:31:45.472 
各個視圖將有相同的尺寸

00:31:46.206 --> 00:31:48.275 
在本例中 我們將增加
更強的約束條件

00:31:48.342 --> 00:31:49.443 
以便將堆疊視圖向下擠壓

00:31:49.510 --> 00:31:51.311 
而且它將優先於
這些均等填充的約束條件

00:31:51.378 --> 00:31:53.847 
但是隨着我讓堆疊視圖增長

00:31:54.248 --> 00:31:56.216 
它們趨向於朝着尺寸均等化發展

00:31:58.285 --> 00:32:01.188 
.FillProportional
ly也是類似不過它們是

00:32:01.255 --> 00:32:03.757 
根據其自身內容的尺寸
按比例增長

00:32:04.324 --> 00:32:06.393 
那麼在本例中
較大的視圖增長得更大

00:32:06.460 --> 00:32:08.962 
而更小的視圖增長不多

00:32:10.230 --> 00:32:13.233 
.EqualSpacing是一種分
配方式根據此方式

00:32:13.300 --> 00:32:15.302 
獲得額外尺寸的並不是視圖

00:32:15.569 --> 00:32:17.104 
而是視圖之間的間隔

00:32:17.905 --> 00:32:20.541 
在本例中
隨着我們讓邊緣之間的間隔增大

00:32:20.674 --> 00:32:22.543 
各個視圖之間的距離
都被調整到相同大小

00:32:24.244 --> 00:32:27.047 
.EqualCentering也是
類似不過在這裏

00:32:27.514 --> 00:32:30.417 
不是視圖邊緣之間的間隔

00:32:30.751 --> 00:32:32.553 
而是視圖中心的間隔
被調整到相同

00:32:33.720 --> 00:32:35.489 
有了這些新的分配行爲

00:32:35.556 --> 00:32:38.192 
我們認爲您可以將堆疊視圖
用於您的 UI 中的更多地方

00:32:38.258 --> 00:32:40.827 
而且真正從
它所帶來的變化中獲益

00:32:42.329 --> 00:32:45.832 
堆疊視圖的另一個方面是
剪裁行爲

00:32:46.200 --> 00:32:48.936 
堆疊視圖可被默認增大到

00:32:49.002 --> 00:32:51.471 
包含所有其他項目
所需的最小尺寸

00:32:52.239 --> 00:32:54.308 
但是您可能也需要
設置剪裁抵抗優先權

00:32:54.408 --> 00:32:57.277 
讓視圖根據該優先權剪裁其內容

00:32:57.978 --> 00:33:01.315 
所以 現在我們的堆疊視圖
可以被調整到小於它的容器

00:33:03.584 --> 00:33:05.686 
通常您並不希望對視圖
進行這種部分剪裁

00:33:05.752 --> 00:33:08.188 
但這比視圖被完全丟棄
的情況要好

00:33:08.922 --> 00:33:12.326 
您可以通過爲不同視圖
設置可見性優先權進行控制

00:33:13.060 --> 00:33:14.895 
一旦堆疊視圖開始剪裁其中的視圖

00:33:14.962 --> 00:33:18.131 
有最低可見性優先權的視圖
	將被完全丟棄

00:33:19.032 --> 00:33:21.001 
在本例中
我們將設置由高到低的順序

00:33:21.068 --> 00:33:23.170 
以便隨着堆疊視圖
開始剪裁某一視圖

00:33:23.237 --> 00:33:25.706 
它只是暫時性的完全脫離

00:33:26.406 --> 00:33:29.343 
因此在本例中
第6個不再看得見了

00:33:31.011 --> 00:33:32.646 
如果堆疊視圖再次增大

00:33:32.713 --> 00:33:35.582 
它將重新附加這些項目
因爲有了足夠的尺寸容納它們

00:33:36.383 --> 00:33:37.985 
此外 當這種脫離或重新附加發生時

00:33:38.318 --> 00:33:40.621 
您會獲得回調
告訴您脫離或重新附加何時發生

00:33:40.687 --> 00:33:43.123 
以便於您對您的UI的其他部分
做出可能的調整

00:33:43.190 --> 00:33:45.225 
比如增加一個溢出菜單

00:33:46.960 --> 00:33:48.929 
接下來我想快速地概述一下

00:33:48.996 --> 00:33:50.631 
最新更新過的集合視圖

00:33:50.731 --> 00:33:53.567 
現在它與 UI 集合視圖
有等同的特色

00:33:54.268 --> 00:33:55.802 
包括項目的可重用性

00:33:55.869 --> 00:33:57.971 
因此 對那些本部分支持的項目
的大型集合

00:33:58.038 --> 00:34:00.340 
您可以有真正可擴展的呈現方式

00:34:01.241 --> 00:34:03.243 
此外 有一些真正強大的佈局支持

00:34:03.310 --> 00:34:06.580 
所以不管您的集合視圖的尺寸多大
它的行爲都是極其良好的

00:34:06.647 --> 00:34:08.447 
包括內置的網格佈局

00:34:08.849 --> 00:34:11.851 
與 iOS 匹配的流程佈局

00:34:11.918 --> 00:34:13.554 
以及創建您自己的
定製化佈局的能力

00:34:13.820 --> 00:34:15.856 
Troy 將在今天稍晚時
就此做一個很棒的講座

00:34:15.922 --> 00:34:17.324 
名爲《集合視圖中的新特性》

00:34:17.391 --> 00:34:18.824 
我真心建議您看一下

00:34:20.594 --> 00:34:22.663 
與此講座相關聯的還有示例代碼

00:34:23.931 --> 00:34:25.199 
它是一個圖片瀏覽app

00:34:25.666 --> 00:34:29.136 
展示Corbin和我談到的
各種特性 API 以及行爲

00:34:30.070 --> 00:34:32.239 
例如 它展示各種全屏 API

00:34:32.306 --> 00:34:33.974 
尤其是最新的平鋪 API

00:34:34.308 --> 00:34:35.509 
我們這個單獨的小窗口

00:34:35.576 --> 00:34:38.011 
通常被要求
尺寸符合寬高比

00:34:38.245 --> 00:34:39.379 
而且可被全屏化

00:34:39.813 --> 00:34:41.415 
然而 我們讓它可被平鋪

00:34:41.614 --> 00:34:43.684 
且一旦處於平鋪狀態
便會有自定義佈局

00:34:45.052 --> 00:34:46.987 
它還採用了最新的
split view 控制器特性

00:34:47.054 --> 00:34:49.755 
比如帶有覆蓋效果的
自動摺疊側邊欄

00:34:50.791 --> 00:34:52.192 
以及 NSStackView

00:34:52.359 --> 00:34:55.362 
它使用零約束條件
創建了這個底部工具欄

00:34:55.696 --> 00:34:56.730 
的的確確是很棒的

00:34:57.497 --> 00:34:59.066 
它還使用脫離行爲

00:34:59.366 --> 00:35:01.702 
以便能夠讓菜單調整到更小

00:35:02.102 --> 00:35:03.504 
並顯示這個小巧的溢出菜單

00:35:03.570 --> 00:35:05.539 
以便用戶仍能使用
那些被隱藏的菜單項目

00:35:07.307 --> 00:35:10.077 
它還使用經過更新的
NSCollectionView

00:35:10.244 --> 00:35:13.413 
用於顯示這個小圖片網格
它的表現非常可靠

00:35:16.717 --> 00:35:19.987 
那麼 Corbin 帶我們概覽了
Full Screen 的各種特性

00:35:20.187 --> 00:35:22.656 
比如如何在我們的應用中採用全屏

00:35:22.956 --> 00:35:24.625 
以及使用標題欄輔助視圖

00:35:24.892 --> 00:35:28.395 
讓那些在工具欄下方的標題欄
在全屏幕狀態下有真正不錯的表現

00:35:29.363 --> 00:35:31.865 
此外 他還向我們展示了
一些全屏幕平鋪 API

00:35:32.165 --> 00:35:33.333 
以便讓我們能夠確保

00:35:33.567 --> 00:35:36.170 
我們在特定情況下的窗口
是否在全屏狀態下表現正常

00:35:37.538 --> 00:35:40.974 
最後是一些確保我們的佈局
真正具有靈活性的方法

00:35:41.041 --> 00:35:42.676 
尤其是在這種狹窄環境下

00:35:43.343 --> 00:35:46.013 
比如將新的標題欄
與Split View控制器

00:35:46.713 --> 00:35:48.115 
自動佈局和NSStackView配

00:35:48.182 --> 00:35:50.584 
合使用以在您的UI的其他部分
構建靈活性

00:35:51.251 --> 00:35:54.621 
而NSCollectionView
有真正很棒的對佈局的支持

00:35:55.856 --> 00:35:58.058 
若您有任何問題
您可以聯繫 Paul Marcos

00:35:58.125 --> 00:35:59.293 
他樂於接收電子郵件

00:36:00.727 --> 00:36:03.230 
此外我們還有一些相關的講座環節
我早些時候也提到了

00:36:03.297 --> 00:36:05.832 
現在它們已經都講完了
但是您可以在視頻上觀看它們

00:36:06.567 --> 00:36:08.468 
此外 我們今天晚些時候
還有一些實驗室活動

00:36:08.535 --> 00:36:11.038 
有的正在進行中
有的將在今天稍晚和明天進行

00:36:11.438 --> 00:36:12.773 
如果您有任何問題
敬請提出

00:36:13.540 --> 00:36:15.742 
祝您在WWDC上有美妙體驗
敬請歡享盛會！

00:36:16.009 --> 00:36:16.844 
回頭見！