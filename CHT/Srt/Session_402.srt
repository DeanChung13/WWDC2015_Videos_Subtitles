00:00:19.720 --> 00:00:22.990 
《LLDB最新內容》
以自己的方式調試達至名利雙收

00:00:23.056 --> 00:00:23.891 
下午好

00:00:23.991 --> 00:00:26.026 
歡迎參加
《LLDB最新內容》講座

00:00:26.326 --> 00:00:27.361 
我是凱特

00:00:34.001 --> 00:00:36.436 
我負責管理Xcode
的運行時間分析工具

00:00:36.503 --> 00:00:37.771 
也包括LLDB

00:00:38.071 --> 00:00:40.040 
今天我來爲大家介紹
但我還帶來

00:00:40.107 --> 00:00:41.074 
兩位工程師

00:00:41.475 --> 00:00:42.509 
西恩和恩里科

00:00:42.576 --> 00:00:44.611 
他們會更深入
介紹部分內容

00:00:45.345 --> 00:00:47.814 
但是開始之前
我想談談

00:00:47.881 --> 00:00:49.449 
自上次WWDC以來  

00:00:49.516 --> 00:00:51.885 
今年的亮點有些或大

00:00:52.152 --> 00:00:53.487 
或小的改變

00:00:54.354 --> 00:00:55.189 
最著名的是...

00:00:56.423 --> 00:00:58.559 
我們推出首個Swift調試器

00:00:58.926 --> 00:01:01.461 
顯然這是向前邁出了一步
可以編寫和開發

00:01:01.595 --> 00:01:04.298 
Swift代碼 大家一定會
逐漸熟悉並喜愛

00:01:05.666 --> 00:01:08.035 
但更重要的是
不會就此爲止

00:01:08.302 --> 00:01:10.137 
我們會進一步
改善調試器

00:01:10.204 --> 00:01:12.206 
希望大家繼續反饋

00:01:12.272 --> 00:01:13.674 
幫我們實現盡善盡美

00:01:14.208 --> 00:01:15.175 
與此同時

00:01:15.409 --> 00:01:17.110 
我們還
推出了Swift REPL

00:01:17.244 --> 00:01:21.281 
它稍稍不同於標準請求回覆
REPL環境

00:01:21.548 --> 00:01:24.985 
實際上是僞裝的LLDB

00:01:25.219 --> 00:01:28.856 
大家不僅可以通過REPL 
在Swift中提出問題

00:01:28.922 --> 00:01:31.358 
還可以通過它
來調試那些問題

00:01:31.425 --> 00:01:33.126 
你實際上是在REPL中
設置斷點

00:01:33.327 --> 00:01:34.394 
實現想在調試環境下

00:01:34.494 --> 00:01:35.662 
完成的任何事情

00:01:35.829 --> 00:01:37.531 
因爲它是LLDB

00:01:37.898 --> 00:01:39.199 
如果還沒有
這麼深入研究

00:01:39.333 --> 00:01:41.902 
我建議大家看看看
這一問題的相關博客

00:01:43.003 --> 00:01:44.605 
但是 這不是...
最終結果

00:01:44.671 --> 00:01:47.140 
之後 我們做了
無數的改進

00:01:47.207 --> 00:01:48.675 
自從首次推出產品以來

00:01:48.742 --> 00:01:50.244 
我們已經在Swift

00:01:50.310 --> 00:01:51.979 
調試體驗方面
進行了百餘項改進

00:01:52.045 --> 00:01:55.816 
而且我們還在繼續提高
Objective-C的調試體驗

00:01:56.116 --> 00:01:57.518 
我們今天也會
提到部分內容

00:01:57.851 --> 00:02:00.988 
不過只會介紹
自去年起做出的改進

00:02:02.322 --> 00:02:04.291 
Swift類型
起初並未顯示出

00:02:04.358 --> 00:02:05.993 
繼承了Objective-C域

00:02:06.159 --> 00:02:07.294 
我們後來對此作了更正

00:02:07.995 --> 00:02:10.631 
Help現在
包括了指令別名

00:02:10.697 --> 00:02:12.299 
需要理解的是

00:02:12.366 --> 00:02:16.170 
因爲當LLDB看似語法
比較冗長

00:02:16.570 --> 00:02:17.971 
我們可能會讓你輸入help

00:02:18.405 --> 00:02:20.140 
實際上有許多快捷方式

00:02:20.207 --> 00:02:23.677 
在這次講座中
我們會使用下列符號來描述它們

00:02:24.311 --> 00:02:28.382 
Help實際上可以
縮寫爲第一個獨特序列

00:02:28.715 --> 00:02:31.084 
在這種情況下
H就足以調出幫助

00:02:31.852 --> 00:02:34.354 
更重要的是
對於更復雜的例子而言

00:02:34.421 --> 00:02:39.293 
如表達式-O--
是指評價表達式

00:02:39.693 --> 00:02:41.962 
告知結果
就像它是通過發送方法

00:02:42.062 --> 00:02:44.231 
來描述自己的
一個對象

00:02:45.098 --> 00:02:46.667 
隨後在該表達之後

00:02:46.800 --> 00:02:48.268 
並無其他選項

00:02:48.902 --> 00:02:50.170 
但你可以輸入PO

00:02:50.571 --> 00:02:52.739 
PO是個方便的別名
可以對左邊的

00:02:52.806 --> 00:02:54.274 
所有內容進行速記

00:02:54.675 --> 00:02:56.643 
那麼如果你習慣於
用幫助

00:02:56.710 --> 00:02:58.212 
應該學習使用這些別名

00:02:58.278 --> 00:02:59.947 
因爲它們可以最快捷地

00:03:00.013 --> 00:03:03.050 
幫你獲得LLDB中的
部分強大功能

00:03:04.184 --> 00:03:05.786 
我們還改善了
數據格式

00:03:05.986 --> 00:03:08.488 
因爲告知你相關的數據情況

00:03:08.555 --> 00:03:10.257 
對於調試體驗而言
是非常重要的

00:03:10.724 --> 00:03:12.626 
那麼設置

00:03:12.826 --> 00:03:14.261 
和NSNS Index Path

00:03:14.328 --> 00:03:15.729 
目前就有了默認格式

00:03:15.796 --> 00:03:17.364 
可以幫助理解數據

00:03:17.464 --> 00:03:18.966 
而不是僅僅展示

00:03:19.032 --> 00:03:20.801 
底層結構的回收機制

00:03:21.802 --> 00:03:23.670 
表達式的Printf原型

00:03:24.171 --> 00:03:27.608 
如果曾嘗試以Printf對它
進行計算 可能會發現

00:03:27.941 --> 00:03:30.043 
有一些稍微可疑的結果

00:03:30.544 --> 00:03:32.813 
這是因爲調試器對它

00:03:32.880 --> 00:03:34.414 
不瞭解的表達式

00:03:34.481 --> 00:03:36.450 
聲明做了很多假設

00:03:36.650 --> 00:03:39.319 
而之前它在很多情況下
也不瞭解printf

00:03:39.786 --> 00:03:42.022 
因此之前不知道
它是個可變參數函數

00:03:42.089 --> 00:03:44.525 
也就是可以採取
可變數量的特殊參數

00:03:44.825 --> 00:03:47.728 
也不瞭解特別是在
64位設備上

00:03:47.794 --> 00:03:49.530 
如何正確傳遞
這些特殊參數

00:03:49.897 --> 00:03:51.465 
這些都已得到改正
這樣所有的

00:03:51.532 --> 00:03:55.068 
涉及C和Objective-C
的printf表達式

00:03:55.135 --> 00:03:56.970 
都應該另行執行

00:03:57.538 --> 00:03:59.640 
那麼最後
這次是真的最後

00:03:59.873 --> 00:04:01.508 
我們改善了分解格式

00:04:01.575 --> 00:04:03.310 
使其更方便閱讀

00:04:05.412 --> 00:04:07.981 
來深入瞭解
部分更有趣的改進

00:04:08.715 --> 00:04:10.851 
今年春天實現了
斷點改進

00:04:10.918 --> 00:04:12.686 
大家可能還沒有意識到

00:04:12.819 --> 00:04:15.322 
具體而言 大家現在
可以命名斷點了

00:04:15.956 --> 00:04:18.024 
命名的斷點可能
會比其他斷點

00:04:18.091 --> 00:04:20.360 
更易於使用
這可能開始並不明顯

00:04:20.427 --> 00:04:23.063 
不過 這些命名不一定
具備獨特性

00:04:23.163 --> 00:04:25.732 
可以對單個斷點
使用多個名稱 這就很不簡單

00:04:25.999 --> 00:04:28.168 
可以把它們想象成標籤

00:04:29.570 --> 00:04:32.506 
所有的斷點指令
都使用這些名稱

00:04:32.606 --> 00:04:35.843 
那麼設置斷點時
可以提供斷點設置

00:04:36.210 --> 00:04:38.145 
短線N 大寫N

00:04:38.412 --> 00:04:39.613 
加上名稱

00:04:39.680 --> 00:04:41.715 
還可以加上另一個短線大寫N

00:04:41.782 --> 00:04:43.317 
和額外的名稱等等

00:04:44.151 --> 00:04:46.720 
但更重要的是
一旦爲斷點

00:04:46.787 --> 00:04:48.789 
或多個斷點命名

00:04:48.856 --> 00:04:50.390 
我就可以對它們

00:04:50.457 --> 00:04:51.825 
通過所有其他的指令來操作

00:04:51.892 --> 00:04:55.028 
斷點可以命名
這會使得所有斷點

00:04:55.262 --> 00:04:58.632 
都是可以共享命名
或者就把它當作是標籤

00:05:00.033 --> 00:05:02.469 
這其實非常有趣
因爲我們現在可以

00:05:02.536 --> 00:05:05.839 
實現在LLDBinit中
設置斷點

00:05:06.273 --> 00:05:08.008 
如果你還不熟悉
LLDBinit

00:05:08.208 --> 00:05:09.276 
這是一種文件...

00:05:09.676 --> 00:05:11.979 
名前綴有個句號

00:05:12.045 --> 00:05:13.780 
會進入主目錄

00:05:13.847 --> 00:05:16.183 
告知LLDB 這裏有一束指令

00:05:16.250 --> 00:05:19.553 
每次打開LLDB會話都需要執行

00:05:20.254 --> 00:05:22.823 
如果這麼使用
則會在LLDB啓動時

00:05:22.890 --> 00:05:24.992 
生成一組 默認斷點

00:05:25.158 --> 00:05:28.762 
所有設置的斷點
在實際生成目標之前

00:05:29.129 --> 00:05:31.532 
都會被
所生成的每個目標所繼承

00:05:32.633 --> 00:05:33.901 
那麼結合兩方面因素

00:05:34.201 --> 00:05:37.037 
我可以在這些
代碼行編寫LLDBinit

00:05:37.571 --> 00:05:39.540 
一組斷點 -n
都命名爲malloc

00:05:39.706 --> 00:05:41.441 
一個斷點 -n
都命名爲free

00:05:41.642 --> 00:05:43.844 
把所有斷點命名爲
memory

00:05:44.077 --> 00:05:45.245 
然後再關閉

00:05:45.479 --> 00:05:48.015 
這就可以很方便的
獲得所有處理斷點的內存

00:05:48.081 --> 00:05:49.650 
只要在我之後用到的

00:05:49.716 --> 00:05:50.884 
任何會話中輸入

00:05:50.951 --> 00:05:54.988 
"breakpoint
enablememory"即可

00:05:55.422 --> 00:05:58.225 
這樣就有了自己的
一組非常方便的斷點

00:05:58.292 --> 00:05:59.793 
我肯定大家會經常使用

00:06:00.027 --> 00:06:02.262 
現在可以給它們
一些好記的名稱

00:06:05.098 --> 00:06:07.601 
但是 當然大家在這裏
不僅是來學習

00:06:07.668 --> 00:06:09.102 
我們已經完成
並推出的內容

00:06:09.369 --> 00:06:11.705 
還有我們剛開始
預覽的內容

00:06:11.772 --> 00:06:12.873 
Xcode 7

00:06:13.273 --> 00:06:14.775 
是個很重要的版本

00:06:15.108 --> 00:06:16.510 
包括許多改進

00:06:16.643 --> 00:06:18.512 
最重要的是表達式求值

00:06:18.612 --> 00:06:21.348 
西恩會爲大家
詳細介紹這方面內容

00:06:21.682 --> 00:06:23.483 
Swift 2支持...
當然...

00:06:23.550 --> 00:06:26.453 
語言會不斷髮展
以及Objective-C 

00:06:26.520 --> 00:06:29.590 
支持模塊的高級處理

00:06:30.657 --> 00:06:32.292 
這些內容
我們也會深入講解

00:06:32.559 --> 00:06:34.728 
但是部分內容
其實就在後臺

00:06:34.795 --> 00:06:36.463 
如果繼續深入研究
你可能會注意到

00:06:36.530 --> 00:06:37.998 
例如在Xcode 7中

00:06:38.398 --> 00:06:40.267 
大家都知道模塊

00:06:40.734 --> 00:06:44.238 
我們實際上可以
在爲模塊構建調試信息一次後

00:06:44.371 --> 00:06:46.573 
再不必在其他位置重複進行

00:06:46.840 --> 00:06:50.577 
這可以大幅減少調試信息的

00:06:50.744 --> 00:06:54.181 
數量 並提高彙編的
性能表現

00:06:54.681 --> 00:06:56.717 
一旦進入
實際的.dSYM文件 

00:06:56.783 --> 00:06:58.452 
這個.dSYM文件就會

00:06:58.519 --> 00:07:00.053 
將你所需的
所有內容都包括在內

00:07:00.687 --> 00:07:03.023 
但是其中還包括
部分其它優化

00:07:03.090 --> 00:07:06.126 
例如 不爲C++類型
複製信息

00:07:06.360 --> 00:07:07.895 
這多虧了定義法則的規定

00:07:08.128 --> 00:07:10.464 
否則我們會有多個副本

00:07:10.797 --> 00:07:13.033 
實際上 我們看到
調試信息

00:07:13.233 --> 00:07:17.104 
要比Xcode 6中
少了1/6

00:07:18.238 --> 00:07:20.107 
特別是對C++項目更是如此

00:07:20.807 --> 00:07:23.577 
我們還在多方面
改進了數據格式

00:07:23.710 --> 00:07:26.980 
在Objective-C和
Swift中矢量類型有着

00:07:27.047 --> 00:07:28.482 
獨特的自動數據格式

00:07:29.049 --> 00:07:30.651 
也許更重要的是

00:07:30.717 --> 00:07:32.819 
如果有Swift自定義類型

00:07:33.120 --> 00:07:35.088 
現在可以自定義它們的
表現方式

00:07:35.155 --> 00:07:37.057 
只要編寫Swift代碼即可

00:07:37.291 --> 00:07:38.992 
恩里科會介紹更多詳情

00:07:40.260 --> 00:07:43.664 
我們還在LLDB中整合了
地址消毒劑支持

00:07:43.730 --> 00:07:45.999 
那麼地址消毒劑
不只會在

00:07:46.066 --> 00:07:47.701 
參考內存無效時會告知

00:07:47.801 --> 00:07:49.636 
你還可以
針對內存提出問題

00:07:49.837 --> 00:07:52.639 
比如可以問
例如 內存歷史

00:07:52.706 --> 00:07:55.576 
從LLDB控制檯
瞭解它分配到哪裏

00:07:55.776 --> 00:07:57.678 
以及何時釋放

00:07:57.911 --> 00:07:59.780 
那麼你可能想了解更多

00:07:59.980 --> 00:08:02.382 
指令的內存系列
並想知道相關幫助

00:08:03.917 --> 00:08:06.620 
我們還增加了
類型查找指令

00:08:06.820 --> 00:08:08.889 
類型查找指令
可以獲取

00:08:08.956 --> 00:08:10.991 
系統的任何類型信息

00:08:11.425 --> 00:08:13.660 
基本上 
這就是個類似頭文件的表示

00:08:13.727 --> 00:08:15.495 
可以在調試器中獲得

00:08:15.629 --> 00:08:17.798 
以便提醒你類型的內容

00:08:19.132 --> 00:08:20.734 
因此 從LLDB提示中

00:08:21.101 --> 00:08:24.605 
我只需要把類型變爲
"type lookup"隨後加上

00:08:24.838 --> 00:08:26.807 
類型名稱 然後我會
獲得類型快速說明

00:08:26.974 --> 00:08:29.076 
本例中 新的錯誤類型

00:08:29.142 --> 00:08:31.178 
用於Swift錯誤處理機制

00:08:31.345 --> 00:08:33.046 
我知道 在幕後

00:08:33.113 --> 00:08:34.615 
通常會執行一對

00:08:34.748 --> 00:08:38.018 
一般已執行了的屬性
只要使用EDAM類型即可

00:08:38.217 --> 00:08:40.721 
但是不管怎樣 
都可以從控制檯看到細節詳情

00:08:41.221 --> 00:08:44.124 
同理 如果我感興趣
"Comparable"類型

00:08:44.191 --> 00:08:45.025 
是個協議

00:08:45.225 --> 00:08:47.995 
它會告訴這個協議
實際上是來自另外兩個

00:08:48.295 --> 00:08:50.264 
這樣你會看到
我們從Equatable

00:08:50.330 --> 00:08:51.765 
<br/> 
得到了等號運算符

00:08:52.065 --> 00:08:54.935 
下劃線Comparable 
可以提供小於比較

00:08:55.102 --> 00:08:58.438 
而導出運算符是
Comparable協議的一部分

00:08:58.772 --> 00:09:01.341 
這裏還可獲取許多
便捷信息

00:09:01.508 --> 00:09:02.843 
和所有內容一樣

00:09:03.644 --> 00:09:06.680 
提醒你不必輸入完整命令
"type lookup"

00:09:06.847 --> 00:09:10.217 
TY空格L
便足以使用這個指令

00:09:11.251 --> 00:09:12.786 
但是要想知道更多詳情

00:09:12.886 --> 00:09:15.856 
特別是談到
怎樣計算表達式

00:09:15.989 --> 00:09:18.258 
我想有請
西恩•卡拉南[

00:09:19.426 --> 00:09:20.260 
大家好

00:09:21.595 --> 00:09:24.631 
我來講講
LLDB中的LLDB

00:09:25.666 --> 00:09:27.067 
大家可能會覺得

00:09:27.267 --> 00:09:29.036 
有那麼多編譯器會話

00:09:29.303 --> 00:09:30.804 
爲什麼要在乎編譯器？

00:09:31.572 --> 00:09:34.541 
編譯器是
LLDB的關鍵內容

00:09:35.309 --> 00:09:37.945 
會使得LLDB功能強大

00:09:38.345 --> 00:09:40.647 
會令LLDB簡單易用

00:09:41.481 --> 00:09:42.916 
它的強大是

00:09:43.116 --> 00:09:45.719 
因爲編譯器對程序運行

00:09:46.019 --> 00:09:47.955 
對配置數據的方法

00:09:48.388 --> 00:09:49.957 
以及當你說想看看

00:09:51.692 --> 00:09:53.861 
這個變量或調用函數時等 

00:09:53.927 --> 00:09:55.462 
有着獨特的理解

00:09:56.964 --> 00:10:00.067 
編譯器很重要
還有一個原因是

00:10:00.133 --> 00:10:03.070 
它們可以與調試器
輕鬆配合使用

00:10:03.904 --> 00:10:05.372 
如果想要打印

00:10:05.839 --> 00:10:07.774 
只要使用你熟悉

00:10:07.841 --> 00:10:09.109 
輸入的代碼

00:10:10.110 --> 00:10:11.778 
交給表達式指令

00:10:12.646 --> 00:10:14.915 
編譯器就會從中拿到指令

00:10:17.784 --> 00:10:18.619 
今天

00:10:18.719 --> 00:10:20.153 
我來講講在編譯器整合方面

00:10:20.220 --> 00:10:21.421 
有兩個重要

00:10:21.822 --> 00:10:23.490 
相關領域

00:10:23.690 --> 00:10:25.259 
獲得了的改進

00:10:27.094 --> 00:10:27.961 
首先

00:10:28.095 --> 00:10:29.396 
有個好消息要告訴各位

00:10:29.463 --> 00:10:31.665 
長期從事Objective-C 
的開發人員

00:10:32.499 --> 00:10:33.333 
接下來

00:10:33.467 --> 00:10:34.301 
我要告訴...

00:10:34.801 --> 00:10:36.336 
Swift開發人員

00:10:36.670 --> 00:10:38.338 
希望現在各位都是

00:10:39.439 --> 00:10:40.274 
聊聊...

00:10:40.407 --> 00:10:42.042 
我們所做的這些改進

00:10:43.777 --> 00:10:45.679 
現在就開始
講講Objective-C

00:10:48.749 --> 00:10:49.716 
LLDB

00:10:49.850 --> 00:10:50.684 
包括...

00:10:50.784 --> 00:10:52.519 
兩個獨立的編譯器

00:10:54.288 --> 00:10:55.122 
Clang

00:10:55.255 --> 00:10:57.057 
強大的Objective-C
編譯器

00:10:58.025 --> 00:10:59.626 
當然 從去年起

00:10:59.993 --> 00:11:01.128 
是Swift編譯器

00:11:02.596 --> 00:11:04.698 
我們的Objective-C
編譯器支持

00:11:05.365 --> 00:11:06.900 
多年來一直在改進

00:11:07.434 --> 00:11:09.570 
我們加入了非常出色的新功能

00:11:10.771 --> 00:11:11.605 
比如

00:11:11.939 --> 00:11:14.007 
Objective-C
運行時間整合

00:11:14.842 --> 00:11:18.111 
那麼 如果Objective-C
運行時間有部分信息

00:11:18.312 --> 00:11:20.380 
並未顯示在
調試信息中

00:11:21.048 --> 00:11:23.317 
我們知道該向編譯器提供

00:11:23.383 --> 00:11:25.319 
這樣可以使用很多類

00:11:25.619 --> 00:11:27.221 
而不必特別做些什麼

00:11:28.755 --> 00:11:29.723 
當然 去年

00:11:29.923 --> 00:11:31.892 
我們在LLDB中

00:11:32.226 --> 00:11:33.427 
引入了Swift編譯器

00:11:34.294 --> 00:11:36.163 
Swift編譯器已經是

00:11:36.430 --> 00:11:37.831 
是很強的工具

00:11:39.499 --> 00:11:41.101 
我們把從Swift編譯器中

00:11:41.368 --> 00:11:43.570 
整合所學內容都用到其中

00:11:44.505 --> 00:11:46.273 
我們對二者都做了改進

00:11:47.641 --> 00:11:48.509 
我們來談談

00:11:48.575 --> 00:11:50.644 
表達式剖析器與Swift

00:11:51.578 --> 00:11:52.412 
怎麼配合

00:11:52.846 --> 00:11:54.781 
從Objective-C的角度

00:11:57.551 --> 00:11:59.953 
我們現在來看
簡單的打印指令

00:12:00.687 --> 00:12:03.557 
這裏說到打印 
因爲我用了p快捷方式

00:12:04.491 --> 00:12:05.659 
實際上是指

00:12:05.926 --> 00:12:07.327 
表達式

00:12:08.228 --> 00:12:09.530 
注意短線 

00:12:10.330 --> 00:12:11.164 
這是指

00:12:11.231 --> 00:12:14.168 
在p指令編碼後的
所有內容

00:12:14.468 --> 00:12:17.838 
不能這樣把額外的選項
交給指令

00:12:18.405 --> 00:12:20.240 
這裏有其他方法
恩里科會給大家介紹

00:12:20.307 --> 00:12:21.608 
而且凱特剛剛給大家看過

00:12:22.676 --> 00:12:25.712 
這裏是些循環運行的
簡單代碼

00:12:25.879 --> 00:12:27.481 
並會每次打印出
循環計數

00:12:28.048 --> 00:12:29.483 
的確 如果運行它

00:12:30.117 --> 00:12:32.019 
你會得到自己預期的數字

00:12:33.287 --> 00:12:34.254 
這個功能好在哪裏？

00:12:36.523 --> 00:12:39.826 
LLDB和程序
是單獨的進程

00:12:40.761 --> 00:12:43.197 
LLDB內部有
swift編譯器

00:12:44.231 --> 00:12:45.999 
程序已經在運行

00:12:46.633 --> 00:12:48.435 
但是有了LLDB的幫助

00:12:48.869 --> 00:12:52.406 
Swift編譯器可以
把你剛輸入程序運行的

00:12:52.606 --> 00:12:54.041 
代碼添加進來

00:12:55.709 --> 00:12:56.844 
如果喜歡打印...

00:12:57.211 --> 00:12:58.846 
循環計數器 這就相當棒

00:12:59.446 --> 00:13:01.315 
但是還有
要調試的內容

00:13:03.517 --> 00:13:06.086 
Swift可以和
變量配合

00:13:07.721 --> 00:13:09.056 
輸入一些代碼

00:13:10.724 --> 00:13:13.293 
數組的內容就打印出來

00:13:14.628 --> 00:13:15.963 
現在 這裏的數組

00:13:16.363 --> 00:13:18.432 
正好有一些
在程序中的代碼

00:13:19.433 --> 00:13:21.969 
LLDB安排在編譯器上...

00:13:22.436 --> 00:13:23.403 
顯示數據 

00:13:23.637 --> 00:13:25.939 
這樣可以生成
你所需的代碼

00:13:28.242 --> 00:13:31.445 
我還想簡單...介紹一下

00:13:31.745 --> 00:13:34.348 
就是Swift怎麼和SDK配合

00:13:35.415 --> 00:13:39.353 
當你輸入
NSApplication.sharedApplication

00:13:40.621 --> 00:13:41.588 
這樣的表達式時 

00:13:42.556 --> 00:13:44.024 
首先 你會看到

00:13:44.091 --> 00:13:46.460 
NSApplication.sharedApplication

00:13:46.527 --> 00:13:47.394 
是按照預期的方式

00:13:48.395 --> 00:13:50.130 
但是LLDB要去

00:13:50.697 --> 00:13:54.168 
發現包括它的SDK模塊

00:13:55.369 --> 00:13:56.970 
讓編譯器可以訪問它

00:13:57.571 --> 00:14:00.007 
然後編譯器找到
NSApplication

00:14:00.240 --> 00:14:02.543 
並想出如何使用
sharedApplication

00:14:04.244 --> 00:14:05.078 
這非常好

00:14:05.345 --> 00:14:06.780 
而且都是在Swift中...

00:14:06.914 --> 00:14:07.748 
自動完成

00:14:08.682 --> 00:14:09.983 
在Objective-C

00:14:10.851 --> 00:14:11.919 
它並非總是工作

00:14:13.887 --> 00:14:16.957 
讓我們在Objective-C
嘗試所有這些

00:14:17.658 --> 00:14:20.928 
有些人此刻可能有些擔心

00:14:21.595 --> 00:14:24.831 
因爲你知道 
NSLog有時並不像

00:14:24.898 --> 00:14:26.934 
調試器中那麼簡單

00:14:30.103 --> 00:14:32.539 
過去 當輸入NSLog時

00:14:32.773 --> 00:14:34.274 
會看到像這樣的錯誤提示:

00:14:34.341 --> 00:14:36.310 
NS日誌存在未知返回類型

00:14:38.045 --> 00:14:40.013 
這是因爲
在SDK肯定會

00:14:40.080 --> 00:14:41.715 
存在NSLog的定義

00:14:42.115 --> 00:14:43.617 
但是LLDB發現

00:14:43.750 --> 00:14:46.186 
符號中只有調試信息中的內容

00:14:46.486 --> 00:14:48.188 
在本例中
它看到一個符號

00:14:48.822 --> 00:14:51.291 
這個符號 我們不知道
它的返回類型是什麼

00:14:51.391 --> 00:14:53.660 
我們甚至不知道
它還用了格式字符串

00:14:55.362 --> 00:14:57.164 
好消息是
問題已經得到解決

00:14:58.131 --> 00:14:59.833 
NSLog是按照
預期的方式工作

00:15:06.773 --> 00:15:11.545 
我們再做些
更隱祕的內容

00:15:11.612 --> 00:15:13.080 
打印NSMakeRect

00:15:13.514 --> 00:15:14.348 
稍等！

00:15:14.414 --> 00:15:15.649 
爲什麼是隱祕的內容呢？

00:15:15.716 --> 00:15:17.251 
就在這裏框架中

00:15:19.319 --> 00:15:23.090 
可惜的是
看似標識符並不存在

00:15:23.757 --> 00:15:26.693 
現在大家就會瞭解
如果使用NSLog

00:15:26.760 --> 00:15:28.328 
可以轉換結果

00:15:28.395 --> 00:15:29.263 
對 可以這麼用

00:15:30.097 --> 00:15:32.566 
但是NSMakeRect
不能這麼用

00:15:33.667 --> 00:15:34.635 
這是因爲

00:15:34.801 --> 00:15:37.604 
NSMakeRect
是確定的NS-Inline

00:15:37.971 --> 00:15:39.373 
沒有符號

00:15:39.806 --> 00:15:42.276 
LLDB什麼也看不到

00:15:44.044 --> 00:15:44.878 
不錯

00:15:45.345 --> 00:15:47.014 
沒問題了

00:15:53.954 --> 00:15:55.656 
還剩一個問題

00:15:56.790 --> 00:15:57.958 
我們現在來看

00:15:58.725 --> 00:16:00.961 
原先NSApplicationsh
aredApplication

00:16:01.028 --> 00:16:01.862 
的情況

00:16:01.929 --> 00:16:03.463 
當然 若你是自己運行
這個表達式

00:16:03.530 --> 00:16:05.465 
當然會在Objective-C
中運行

00:16:05.532 --> 00:16:08.035 
我們已經在爲
Objective-C運行時間整合

00:16:08.101 --> 00:16:08.936 
做了很多工作

00:16:09.436 --> 00:16:12.272 
但是如果想找出
undo.Manager 

00:16:12.439 --> 00:16:14.608 
你很快會發現運行時間
並未告訴你所有內容

00:16:15.242 --> 00:16:17.744 
特別是你發現的這個
關於undo.Manager的

00:16:17.811 --> 00:16:21.548 
奇怪錯誤提示
在類型id對象中並未發現

00:16:22.549 --> 00:16:23.817 
是什麼情況？

00:16:24.117 --> 00:16:24.952 
在SDK肯定

00:16:25.018 --> 00:16:27.154 
sharedApplication
會返回一個

00:16:27.221 --> 00:16:28.722 
NSApplication星級

00:16:28.789 --> 00:16:30.724 
但如果來看
運行時間

00:16:31.024 --> 00:16:32.693 
返回的是id

00:16:33.060 --> 00:16:33.894 
是個一般的

00:16:34.895 --> 00:16:36.563 
Objective-C對象

00:16:38.966 --> 00:16:39.800 
好消息

00:16:40.200 --> 00:16:41.568 
這不再是問題了

00:16:41.935 --> 00:16:46.607 
實際上 我們會看到
只能從SDK得到的信息

00:16:46.773 --> 00:16:48.942 
例如
指針爲可空值

00:16:49.076 --> 00:16:51.879 
這就是SDK支持Swift的
最新功能

00:16:52.079 --> 00:16:54.515 
也會進入
Objective-C

00:16:57.684 --> 00:17:00.187 
不過信息就在這裏

00:17:00.454 --> 00:17:02.723 
這就是我們
所應用的理念

00:17:03.524 --> 00:17:05.692 
從SDK直接讀出

00:17:06.193 --> 00:17:08.494 
代碼會一直
在LLDB中運行

00:17:08.694 --> 00:17:13.433 
我們瞭解本地變量
函數 自己的類

00:17:15.002 --> 00:17:17.171 
SDK函數
另一方面

00:17:17.671 --> 00:17:19.540 
我們還有更多
問題 如大家所見

00:17:21.241 --> 00:17:24.278 
SDK類就像NSView
和NSApplication

00:17:24.344 --> 00:17:25.746 
我們看到了 但是如你所見

00:17:25.811 --> 00:17:27.414 
因爲運行時間整合

00:17:28.015 --> 00:17:29.716 
這裏有個小星號

00:17:31.185 --> 00:17:33.153 
現在SDK包括
如果你試着在表達式用過

00:17:33.220 --> 00:17:35.522 
NSASCIIStringEnc
oding

00:17:35.822 --> 00:17:37.958 
就會瞭解這永遠不行

00:17:39.126 --> 00:17:42.229 
如果使用宏 如int-max

00:17:42.429 --> 00:17:43.764 
那麼 max

00:17:43.830 --> 00:17:46.200 
利用兩個數字中最大值

00:17:46.600 --> 00:17:48.368 
這樣也不會奏效

00:17:50.537 --> 00:17:53.140 
所有這些在
最新的LLDB中都已解決

00:18:00.280 --> 00:18:02.349 
我們也刪掉了煩人的星號

00:18:05.886 --> 00:18:10.057 
大家可能會說那麼
每月要付多少個39.95才能用上

00:18:10.190 --> 00:18:11.358 
這個功能呢？

00:18:11.425 --> 00:18:13.093 
好消息 這完全免費

00:18:13.160 --> 00:18:15.996 
你只需要
@import AppKit即可

00:18:17.130 --> 00:18:18.966 
運行一個表達式

00:18:19.032 --> 00:18:21.768 
表明輸入
我關心的框架

00:18:22.536 --> 00:18:24.571 
如果用到AppKit 
或是在諸位中間的

00:18:24.638 --> 00:18:25.806 
兩三位...

00:18:26.273 --> 00:18:28.175 
iOS程編寫人員

00:18:28.242 --> 00:18:29.710 
輸入UIKit...

00:18:30.878 --> 00:18:32.112 
就可以了

00:18:34.715 --> 00:18:35.549 
現在

00:18:36.917 --> 00:18:38.986 
我們並未將
Swift放在那裏不管

00:18:40.153 --> 00:18:44.491 
Swift2.0可實現
強大的錯誤處理支持

00:18:44.658 --> 00:18:48.529 
LLDB馬上就可以
支持the bat

00:18:48.862 --> 00:18:50.197 
正如大家所期待的那樣

00:18:52.999 --> 00:18:55.068 
我們可以處理Swift錯誤

00:18:56.236 --> 00:18:58.205 
當調用可能在

00:18:58.272 --> 00:19:00.507 
表達式引發錯誤的函數時

00:19:00.574 --> 00:19:02.543 
你不必調用"try"

00:19:03.410 --> 00:19:04.311 
因爲...

00:19:04.578 --> 00:19:07.047 
我們爲大家抓取內容

00:19:08.515 --> 00:19:09.550 
如果你輸入

00:19:10.083 --> 00:19:11.685 
這個函數"throws"

00:19:12.019 --> 00:19:13.387 
並把它交給表達式

00:19:13.453 --> 00:19:15.522 
注意這和p指令
完全一樣

00:19:16.657 --> 00:19:17.591 
你會獲得

00:19:18.225 --> 00:19:19.660 
爲你生成的...

00:19:19.993 --> 00:19:21.128 
錯誤變量 

00:19:21.261 --> 00:19:23.797 
其中包括函數引發的錯誤

00:19:26.233 --> 00:19:28.735 
也可以在
REPL中...完成這些

00:19:30.571 --> 00:19:32.940 
如果從REPL提示中
你做了同樣的事情

00:19:34.575 --> 00:19:36.710 
則會得到...錯誤變量

00:19:39.780 --> 00:19:42.649 
我們再來看看
LLDB支持的...

00:19:43.183 --> 00:19:44.218 
更多內容

00:19:45.352 --> 00:19:47.554 
也就是說 你不希望
總是看到

00:19:47.621 --> 00:19:49.423 
最後出現的是錯誤

00:19:49.923 --> 00:19:53.160 
你需要了解
產生錯誤的代碼是什麼

00:19:54.561 --> 00:19:56.063 
不過 在Objective-C中

00:19:56.129 --> 00:19:57.564 
你用到了斷點來完成

00:19:58.699 --> 00:20:02.202 
具體而言你在Objective-C
異常中設置了斷點

00:20:03.170 --> 00:20:04.505 
方法是...

00:20:04.671 --> 00:20:06.807 
你用了斷點來設置指令

00:20:08.575 --> 00:20:11.178 
確定了希望爲...

00:20:12.012 --> 00:20:14.314 
異常Objective-C...

00:20:15.115 --> 00:20:15.949 
設置斷點

00:20:16.650 --> 00:20:18.852 
我們來爲你設置了斷點

00:20:19.119 --> 00:20:21.121 
那麼一旦Objective-C代碼

00:20:21.655 --> 00:20:22.956 
要引發異常

00:20:23.290 --> 00:20:24.124 
我們就會停下來

00:20:25.192 --> 00:20:27.494 
在Swift錯誤中
你可以做同樣的事情

00:20:28.195 --> 00:20:30.764 
只要用Swift
替代Objective-C 

00:20:31.498 --> 00:20:33.734 
我們就會停止
程序要...

00:20:33.934 --> 00:20:34.968 
引發的...

00:20:35.335 --> 00:20:36.403 
Swift錯誤

00:20:37.471 --> 00:20:38.605 
但是還可以...

00:20:39.006 --> 00:20:40.974 
做另一件很酷的事

00:20:42.309 --> 00:20:45.646 
你可以停止
具體的錯誤類型

00:20:46.647 --> 00:20:48.549 
這是我們支持
Swift的一個功能

00:20:49.149 --> 00:20:51.151 
這麼做的方法很簡單

00:20:51.218 --> 00:20:54.955 
和你在設置表達式斷點
非常相似

00:20:56.490 --> 00:20:58.825 
可以使用短線O參數

00:20:59.459 --> 00:21:01.628 
來明確你希望捕捉的

00:21:01.929 --> 00:21:03.497 
錯誤類型名稱

00:21:04.831 --> 00:21:09.303 
如果這麼做
那麼只有在出現

00:21:10.003 --> 00:21:12.573 
你感興趣的錯誤類型時

00:21:13.006 --> 00:21:13.907 
纔會停下來

00:21:15.876 --> 00:21:16.844 
最後

00:21:18.312 --> 00:21:19.213 
當然

00:21:20.314 --> 00:21:22.883 
你可以按照
正常代碼中...

00:21:23.217 --> 00:21:24.785 
的方法捕捉錯誤

00:21:24.852 --> 00:21:26.420 
畢竟 部分而言

00:21:26.653 --> 00:21:30.757 
REPL是指了解和發現語言
運行的方法

00:21:32.025 --> 00:21:33.794 
如果輸入Foundation

00:21:34.127 --> 00:21:35.395 
來獲取NSError

00:21:36.330 --> 00:21:39.533 
然後編寫會產生
NSError的代碼

00:21:40.334 --> 00:21:43.704 
就可以捕捉
NSError...並打印出來

00:21:45.439 --> 00:21:46.440 
如果這麼做

00:21:46.707 --> 00:21:48.675 
結果就和你在自己的程序中

00:21:48.742 --> 00:21:50.577 
捕捉的效果完全相同

00:21:52.613 --> 00:21:54.081 
我希望大家...

00:21:54.548 --> 00:21:55.983 
記住兩點

00:21:56.116 --> 00:21:57.117 
首先

00:21:57.684 --> 00:21:58.685 
添加輸入...

00:21:58.886 --> 00:21:59.853 
自己的模塊

00:22:00.754 --> 00:22:01.922 
第二

00:22:02.422 --> 00:22:05.359 
試着用LLDB進行錯誤處理

00:22:05.425 --> 00:22:06.560 
這是個不錯的辦法

00:22:07.694 --> 00:22:09.863 
要想了解更多詳情

00:22:09.930 --> 00:22:12.132 
不是說告訴程序該做什麼

00:22:12.766 --> 00:22:17.304 
而是如何在程序
產生資料完成後打印信息

00:22:17.905 --> 00:22:19.740 
有請恩里科·格拉納塔

00:22:22.709 --> 00:22:23.544 
大家好

00:22:24.378 --> 00:22:26.246 
上午我還在實驗室

00:22:26.313 --> 00:22:29.082 
我們在想辦法
解決一個問題

00:22:29.816 --> 00:22:33.487 
問題是...爲什麼
我看不到這個變量？

00:22:33.787 --> 00:22:34.955 
出什麼事了？

00:22:35.556 --> 00:22:38.125 
爲了幫助大家找到問題

00:22:38.525 --> 00:22:39.860 
我們試了幾個指令

00:22:39.927 --> 00:22:42.896 
試了表達式 還有
PO 我們還試了幀變量

00:22:43.564 --> 00:22:46.166 
此刻 人們通常會問

00:22:46.466 --> 00:22:49.570 
爲什麼有那麼多指令來做幾乎
相同的事情？

00:22:49.636 --> 00:22:52.072 
來看我的數據
看看程序中在發生什麼

00:22:53.373 --> 00:22:56.443 
大家來這裏
就是了解內部消息的

00:22:56.710 --> 00:22:59.847 
我們來看一下
LLDB讓你看數據的指令

00:23:00.614 --> 00:23:02.482 
共有三個

00:23:02.850 --> 00:23:03.884 
幀變量

00:23:04.151 --> 00:23:05.485 
表達式指令

00:23:05.886 --> 00:23:07.187 
是個p指令

00:23:07.721 --> 00:23:09.790 
表達式 
短線大寫O

00:23:09.857 --> 00:23:10.691 
這個...

00:23:10.757 --> 00:23:12.092 
剛纔講過

00:23:12.292 --> 00:23:15.195 
是作爲PO指令

00:23:15.896 --> 00:23:16.730 
首先

00:23:16.864 --> 00:23:18.165 
幀變量指令

00:23:18.699 --> 00:23:22.402 
幀變量指令
可以縮寫爲frv

00:23:22.469 --> 00:23:26.106 
輸入時 
基本是Xcode變量視圖

00:23:26.607 --> 00:23:29.743 
它讓你...看所有的
本地變量

00:23:30.410 --> 00:23:31.612 
讓你看...

00:23:32.012 --> 00:23:33.947 
幾個本地變量

00:23:34.748 --> 00:23:36.083 
此外

00:23:36.250 --> 00:23:37.951 
也可以應用...

00:23:38.118 --> 00:23:40.454 
帶有短線 短線格式旗標的格式

00:23:41.755 --> 00:23:43.156 
要強調的一點是

00:23:43.490 --> 00:23:44.925 
因爲在看到首次輸出時

00:23:45.926 --> 00:23:48.729 
有Tuple的話
我會回到這裏

00:23:48.996 --> 00:23:49.830 
這是個...

00:23:49.963 --> 00:23:50.864 
聚合

00:23:51.098 --> 00:23:53.800 
是包括其他對象的對象

00:23:54.134 --> 00:23:56.737 
聚合當中的內容

00:23:57.004 --> 00:23:58.005 
我們稱之爲...

00:23:58.572 --> 00:23:59.406 
子對象

00:24:01.241 --> 00:24:02.609 
這個表達式指令

00:24:03.577 --> 00:24:05.379 
在本次會話中你會多次看到

00:24:05.479 --> 00:24:06.580 
我會簡要介紹一下

00:24:06.980 --> 00:24:07.814 
當然

00:24:08.215 --> 00:24:09.283 
有了表達式指令

00:24:09.349 --> 00:24:11.919 
可以簡單算一下
正如你猜測的一樣

00:24:12.519 --> 00:24:16.223 
完全可能...使用之前的結果

00:24:16.657 --> 00:24:19.259 
並用它們
完成更多內容

00:24:20.327 --> 00:24:22.462 
當然 表達式指令
也知道如何

00:24:22.529 --> 00:24:24.698 
自定義結果的格式

00:24:25.732 --> 00:24:27.968 
需要再次強調的一點是

00:24:28.836 --> 00:24:29.803 
子對象

00:24:30.771 --> 00:24:31.839 
第三個指令

00:24:32.339 --> 00:24:33.507 
po指令

00:24:34.141 --> 00:24:38.345 
這個可能是...在座各位
Objective-C開發員的指令

00:24:38.545 --> 00:24:40.914 
我猜測
在Objective-C代碼之前

00:24:41.315 --> 00:24:43.383 
大家都知道是PO指令

00:24:43.784 --> 00:24:46.887 
你可以生成對象
把說明打印出來

00:24:47.788 --> 00:24:50.991 
可以生成NSArray
或打印現有的NSArray

00:24:51.058 --> 00:24:52.492 
你就會看到其中的內容

00:24:53.060 --> 00:24:54.461 
要知道

00:24:54.528 --> 00:24:56.763 
對於字符串而言非常簡單

00:24:57.698 --> 00:24:58.532 
那麼

00:24:58.599 --> 00:24:59.533 
三條指令

00:24:59.900 --> 00:25:02.135 
它們並非是完全一樣的功能

00:25:02.202 --> 00:25:04.004 
大家估計此刻也猜到了

00:25:04.705 --> 00:25:05.539 
實際上

00:25:06.540 --> 00:25:07.941 
它們只是有些相似

00:25:08.008 --> 00:25:09.209 
但不是完全相同

00:25:09.409 --> 00:25:10.244 
例如

00:25:10.811 --> 00:25:12.880 
表達式指令和po指令

00:25:13.213 --> 00:25:15.749 
是...
"run my code"指令

00:25:16.083 --> 00:25:17.551 
無論代碼類型是什麼

00:25:17.618 --> 00:25:19.386 
這些指令都會運行

00:25:20.888 --> 00:25:22.990 
但是 接下來的
幀變量指令

00:25:23.056 --> 00:25:25.359 
和表達式指令
第二步則不相同

00:25:25.726 --> 00:25:27.728 
當它們不得不顯示結果時

00:25:27.861 --> 00:25:30.230 
會用到LLDB格式器系統

00:25:31.331 --> 00:25:34.301 
我們在以往的WWDC
講座中

00:25:34.368 --> 00:25:36.603 
介紹過LLDB格式器系統

00:25:37.004 --> 00:25:38.672 
大家應該都去找來看看

00:25:39.072 --> 00:25:40.240 
不過簡單而言

00:25:40.641 --> 00:25:43.744 
LLDB掌握部分嵌入系統類型

00:25:43.944 --> 00:25:45.479 
並對其自動格式化

00:25:45.779 --> 00:25:48.582 
NSArray NSDictionaries
加字符串

00:25:49.116 --> 00:25:53.654 
還可以提供...在Python中
編寫的自己的格式

00:25:54.688 --> 00:25:55.789 
另一方面

00:25:55.989 --> 00:25:58.392 
po指令並不使用
LLDB格式器

00:25:58.659 --> 00:26:02.930 
po指令在...後面
在幕後

00:26:03.130 --> 00:26:04.031 
運行更多的代碼

00:26:04.398 --> 00:26:05.832 
實際上會生成爲

00:26:05.899 --> 00:26:07.301 
爲你顯示的真實結果

00:26:08.202 --> 00:26:10.537 
你可能已經在
一個Objective-C類中

00:26:10.604 --> 00:26:12.272 
至少編寫了一個
說明方法

00:26:12.506 --> 00:26:15.275 
然後意識到
這就是po打印的內容

00:26:16.276 --> 00:26:17.110 
現在

00:26:17.444 --> 00:26:18.946 
我希望大家想一想

00:26:19.213 --> 00:26:20.047 
這兩個模型

00:26:20.113 --> 00:26:23.217 
實際上在用你的對象
併爲之生產數據

00:26:24.151 --> 00:26:26.019 
LLDB格式器模型

00:26:26.220 --> 00:26:27.688 
我們稱之爲

00:26:27.955 --> 00:26:29.857 
"out of process"
格式模型

00:26:29.923 --> 00:26:30.757 
爲什麼呢

00:26:30.824 --> 00:26:33.694 
因爲格式器位於進程之外

00:26:33.961 --> 00:26:36.430 
它或者將
內容構建到調試器中

00:26:36.830 --> 00:26:39.933 
或者你用部分Python
腳本表現對象

00:26:40.267 --> 00:26:42.069 
這是不同的語言
不同的文件

00:26:42.135 --> 00:26:43.904 
存在於不同的作用域中

00:26:44.638 --> 00:26:45.672 
另一方面

00:26:46.306 --> 00:26:48.742 
外部格式器位於調試器中

00:26:48.976 --> 00:26:50.978 
這就很容易...

00:26:51.178 --> 00:26:54.448 
讓他訪問調試器所具備
程序的所有內容

00:26:54.748 --> 00:26:57.384 
就像是可以鳥瞰所有進程

00:26:58.519 --> 00:27:02.189 
因此 這類格式器
也可以很容易...

00:27:02.523 --> 00:27:05.225 
確定程序狀態並未改變

00:27:05.659 --> 00:27:08.028 
你若是看到
調試器中的數據後

00:27:08.095 --> 00:27:10.397 
不想改變程序狀態

00:27:10.764 --> 00:27:12.699 
調試器相當於是階段...

00:27:13.033 --> 00:27:13.867 
檢測器

00:27:13.934 --> 00:27:16.103 
它來看內容
並試圖不做改變

00:27:17.671 --> 00:27:18.839 
在另外的模型中

00:27:19.206 --> 00:27:20.240 
po模型

00:27:20.374 --> 00:27:22.743 
writeadescription
method模型

00:27:23.010 --> 00:27:25.212 
是個進程格式模型

00:27:25.612 --> 00:27:28.415 
你同時編寫數據和格式器

00:27:28.682 --> 00:27:30.617 
再用相同的語言
編寫一遍

00:27:31.118 --> 00:27:33.754 
可能甚至都在相同的
文件中編寫

00:27:34.621 --> 00:27:36.757 
因爲格式器是在應用中

00:27:36.823 --> 00:27:38.625 
運行的代碼

00:27:38.692 --> 00:27:40.661 
可以輕鬆並完全

00:27:40.727 --> 00:27:42.829 
訪問應用的對象模型

00:27:44.031 --> 00:27:45.999 
但是功能更強大

00:27:46.200 --> 00:27:47.901 
責任也更大

00:27:48.535 --> 00:27:51.071 
需要確保格式器

00:27:51.138 --> 00:27:53.040 
並沒有改變程序的狀態

00:27:53.540 --> 00:27:56.710 
要確保並未在
格式器中...

00:27:56.910 --> 00:27:59.680 
對準備表現的對象
做了任何改變

00:28:00.981 --> 00:28:03.750 
那好 Objective-C

00:28:03.817 --> 00:28:05.319 
具備進程進程格式模型

00:28:05.452 --> 00:28:06.787 
我可以編寫說明方式

00:28:06.854 --> 00:28:08.222 
調試器會用到

00:28:08.789 --> 00:28:10.123 
那Swift會怎樣？

00:28:11.358 --> 00:28:13.827 
結果是 演講廳裏
在座的各位

00:28:13.894 --> 00:28:15.195 
又一次知道了內部消息

00:28:15.462 --> 00:28:18.398 
從一開始Swift已有了

00:28:18.632 --> 00:28:20.000 
進程格式模型

00:28:20.701 --> 00:28:21.535 
但是 在哪兒呢？

00:28:21.602 --> 00:28:22.736 
怎麼用呢？

00:28:23.537 --> 00:28:26.673 
希望大家
都用過Swift開發環境

00:28:27.107 --> 00:28:29.142 
如果用過Swift開發環境

00:28:29.510 --> 00:28:32.145 
那就用過進程格式模型

00:28:32.479 --> 00:28:34.147 
從一開始它就在這裏

00:28:35.849 --> 00:28:36.817 
那有什麼新奇的呢？

00:28:37.784 --> 00:28:41.355 
現在 在Xcode 7
我們會採取完全相同的模型

00:28:41.788 --> 00:28:44.024 
把它作爲公共API

00:28:44.791 --> 00:28:46.560 
大家可以使用它

00:28:47.694 --> 00:28:50.230 
它仍然支持...開發環境

00:28:50.664 --> 00:28:54.034 
不過現在也支持
LLDB po指令

00:28:54.501 --> 00:28:56.603 
現在 你有着正確的
Swift格式器

00:28:56.670 --> 00:28:58.071 
針對Swift對象

00:28:58.705 --> 00:28:59.540 
怎麼弄？

00:28:59.806 --> 00:29:01.608 
我們來詳細講一下

00:29:02.476 --> 00:29:04.144 
這個模型基於...

00:29:04.411 --> 00:29:05.746 
4個協議

00:29:06.980 --> 00:29:08.348 
這些是各自的名稱

00:29:09.283 --> 00:29:11.718 
對 我說是四個協議

00:29:12.085 --> 00:29:13.954 
它們的名稱相當長

00:29:14.621 --> 00:29:16.823 
但是...我不會
過分擔心

00:29:16.957 --> 00:29:20.127 
可能是這個模型的可選項

00:29:20.360 --> 00:29:21.595 
4個協議

00:29:21.662 --> 00:29:23.630 
並非是指必須符合所有要求

00:29:23.964 --> 00:29:27.000 
可以選擇子集
來獲得所需要的結果

00:29:27.167 --> 00:29:29.203 
符合使用的協議部分

00:29:29.436 --> 00:29:30.571 
就可以了

00:29:31.471 --> 00:29:32.639 
我們來看一下協議

00:29:33.774 --> 00:29:35.809 
CustomStringConvertible

00:29:35.876 --> 00:29:37.611 
是協議名稱

00:29:37.911 --> 00:29:39.046 
表示...

00:29:39.613 --> 00:29:42.482 
怎樣把對象作爲
字符串打印？

00:29:43.584 --> 00:29:45.419 
它並未告知LLDB

00:29:45.719 --> 00:29:47.354 
它還告知了Swift

00:29:47.855 --> 00:29:48.689 
怎麼弄？

00:29:48.755 --> 00:29:50.457 
Swift打印功函數

00:29:50.824 --> 00:29:53.594 
以及Swift字符串
插值功能

00:29:53.760 --> 00:29:56.697 
二者都用了CustomString
Convertible協議

00:29:57.297 --> 00:29:58.465 
非常好用

00:29:58.599 --> 00:30:00.133 
實現這些很難嗎？

00:30:01.602 --> 00:30:02.436 
非常簡單

00:30:02.836 --> 00:30:05.906 
我有個數據結構
代表啤酒歌的瓶子

00:30:05.973 --> 00:30:08.041 
因爲我自己正在
準備bash腳本

00:30:08.408 --> 00:30:10.210 
我想把歌詞打印出來

00:30:10.878 --> 00:30:12.713 
就生成了一個實例

00:30:12.779 --> 00:30:14.781 
並看牆上有多少啤酒瓶

00:30:15.449 --> 00:30:17.451 
但是要等到
app的...

00:30:17.784 --> 00:30:19.086 
所有內容都沒問題的時候

00:30:19.152 --> 00:30:21.255 
如果我做調試
也許我需要更多信息

00:30:21.788 --> 00:30:25.092 
那就需要Custom Debug
String Convertible

00:30:25.392 --> 00:30:28.729 
這是調試器對這個對象的
具體表示

00:30:29.429 --> 00:30:31.598 
調試器具體表示是什麼

00:30:32.032 --> 00:30:33.834 
則要取決你的app

00:30:33.901 --> 00:30:35.769 
完全取決於對象
模型的語義

00:30:36.503 --> 00:30:37.571 
但是作爲提示

00:30:37.638 --> 00:30:39.206 
debugPrint函數

00:30:39.506 --> 00:30:41.642 
將默認選擇這個協議

00:30:42.242 --> 00:30:43.143 
當然

00:30:43.510 --> 00:30:45.345 
打印和debugPrint 

00:30:45.412 --> 00:30:47.814 
不會滿足其他一致性要求

00:30:48.015 --> 00:30:49.683 
如果它們的興趣點不在此

00:30:50.484 --> 00:30:51.518 
怎麼運行呢？

00:30:51.885 --> 00:30:53.153 
很簡單

00:30:53.954 --> 00:30:55.923 
我們把啤酒瓶進行擴展

00:30:56.423 --> 00:30:58.425 
因爲我們在做調試

00:30:58.492 --> 00:31:00.360 
希望瞭解牆上啤酒瓶的更多信息

00:31:00.594 --> 00:31:03.230 
這樣我們可以確定啤酒類型
是否正確

00:31:03.463 --> 00:31:05.766 
這就會成爲不錯的bash腳本
因爲它們都很出色

00:31:06.967 --> 00:31:08.268 
第三個協議

00:31:08.535 --> 00:31:11.205 
是CustomPlayground
Quick Lookable

00:31:11.772 --> 00:31:13.106 
正如名稱所示

00:31:13.373 --> 00:31:16.376 
這個協議是主要
爲環境而定

00:31:16.977 --> 00:31:20.747 
是指爲環境中的
對象提供

00:31:20.814 --> 00:31:22.916 
豐富的圖形表示

00:31:23.717 --> 00:31:24.651 
想要看舉例嗎？

00:31:24.718 --> 00:31:26.019 
當然有

00:31:26.787 --> 00:31:29.823 
我可以編寫代表一個人的
數據結構

00:31:30.157 --> 00:31:32.259 
然後我可以獲得
一個人的描述

00:31:32.326 --> 00:31:34.394 
在環境的側邊工具欄顯示

00:31:34.695 --> 00:31:36.930 
以此作爲生成這個類型
對象的結果

00:31:38.899 --> 00:31:41.068 
不好意思
讓你們失望了

00:31:41.134 --> 00:31:42.870 
我的確想做成的

00:31:43.136 --> 00:31:45.706 
但是 大會上不會銷售

00:31:45.772 --> 00:31:48.008 
帶有人像的T恤衫

00:31:48.342 --> 00:31:49.376 
不好意思

00:31:50.244 --> 00:31:52.379 
不過 我有個彌補的辦法

00:31:52.679 --> 00:31:54.181 
其中最後的協議

00:31:54.481 --> 00:31:56.416 
Custom
Reflectable協議

00:31:56.483 --> 00:31:58.619 
它可以讓我
生成完全自定義的

00:31:58.685 --> 00:31:59.786 
子對象層次

00:32:00.087 --> 00:32:03.056 
好 我說過 我會回到
"children"這裏 說到做到

00:32:04.024 --> 00:32:07.227 
當我說到完全自定義
子對象層次時

00:32:08.262 --> 00:32:09.730 
我是說

00:32:10.364 --> 00:32:12.199 
我可以
做個新的...

00:32:12.266 --> 00:32:14.801 
我可以爲對象
製作新的結構

00:32:15.135 --> 00:32:17.204 
可以告知語言
可以告知調試器

00:32:17.271 --> 00:32:18.338 
可以告知環境

00:32:18.639 --> 00:32:20.774 
我的對象實際上是用什麼來造的

00:32:20.874 --> 00:32:22.109 
大家會看到

00:32:22.576 --> 00:32:24.044 
你做此事的方法

00:32:24.311 --> 00:32:26.580 
交易用的貨幣

00:32:26.880 --> 00:32:30.083 
在想要對Swift描述
對象的結構時 

00:32:30.417 --> 00:32:31.251 
被稱爲

00:32:31.451 --> 00:32:32.386 
Mirror

00:32:32.486 --> 00:32:33.487 
可反射的鏡像

00:32:35.222 --> 00:32:37.925 
我們來看個例子
不要費時費事

00:32:38.525 --> 00:32:40.727 
我有個應用用來

00:32:40.827 --> 00:32:42.996 
蒐集溫度樣本

00:32:43.864 --> 00:32:45.199 
它有兩個數據結構

00:32:45.699 --> 00:32:46.934 
一個用來描述

00:32:47.267 --> 00:32:48.435 
此刻的時間

00:32:48.735 --> 00:32:51.205 
它說在給定的時刻

00:32:51.538 --> 00:32:53.507 
這就是我得到的溫度信息

00:32:54.508 --> 00:32:56.543 
接着當然我們
獲得溫度樣本

00:32:57.244 --> 00:32:58.745 
現在我來調試app

00:32:59.079 --> 00:33:00.781 
我想看看是什麼情況

00:33:00.848 --> 00:33:02.249 
怎麼來處理樣本

00:33:02.683 --> 00:33:03.584 
所以我提出

00:33:04.251 --> 00:33:05.485 
po溫度

00:33:06.587 --> 00:33:07.654 
我得到的是這個

00:33:08.856 --> 00:33:11.792 
實話講 我看着它
覺得

00:33:12.025 --> 00:33:13.894 
作爲默認值還不錯

00:33:14.394 --> 00:33:17.297 
不過 我立刻發現
我想調整兩個問題

00:33:17.931 --> 00:33:20.133 
爲什麼在把時間堆在兩行？

00:33:20.200 --> 00:33:22.469 
我想把所有內容
都放在一行

00:33:22.836 --> 00:33:24.538 
而且如果是用a.m.
p.m.格式

00:33:24.605 --> 00:33:25.939 
表示上下午最好

00:33:26.573 --> 00:33:28.375 
還有溫度

00:33:28.809 --> 00:33:29.943 
我看着它 覺得

00:33:30.043 --> 00:33:31.678 
標度是什麼呢？

00:33:31.745 --> 00:33:32.579 
我不知道

00:33:32.679 --> 00:33:35.816 
是開氏
列氏還是蘭氏溫標？

00:33:36.016 --> 00:33:39.486 
我們在美國想用的是華氏溫度

00:33:42.022 --> 00:33:45.192 
好消息是
我們可以用兩步驟

00:33:45.859 --> 00:33:47.628 
解決所有這些問題

00:33:48.328 --> 00:33:49.162 
開始

00:33:49.630 --> 00:33:52.633 
第一步 我們把
時間按照一行打印

00:33:54.301 --> 00:33:56.870 
我做了這些
來實現這一點

00:33:57.171 --> 00:33:59.206 
用了NSDate格式器

00:34:00.741 --> 00:34:03.911 
因爲我要在...
自己的應用中運行

00:34:04.178 --> 00:34:07.114 
因爲我運行的對象格式代碼

00:34:07.514 --> 00:34:09.783 
實際就是
正常的Swift代碼

00:34:09.983 --> 00:34:12.553 
就是我通常編寫app

00:34:12.853 --> 00:34:14.087 
所用的代碼不論是什麼框架

00:34:14.288 --> 00:34:15.121 
什麼庫

00:34:15.389 --> 00:34:18.859 
還是我的app完成任務
通常所用的技術

00:34:19.359 --> 00:34:21.428 
我在格式器中用就好了

00:34:21.862 --> 00:34:23.797 
在本例中 是NSDate格式器

00:34:24.931 --> 00:34:25.866 
第二步

00:34:26.400 --> 00:34:28.569 
選用華氏溫度

00:34:29.837 --> 00:34:31.038 
怎麼實現？

00:34:31.705 --> 00:34:33.172 
我們生成鏡像

00:34:33.639 --> 00:34:34.507 
好了

00:34:34.875 --> 00:34:38.045 
現在我們可以說
溫度數據對象

00:34:38.110 --> 00:34:41.815 
是作爲包括三項內容
來構建

00:34:42.248 --> 00:34:44.251 
時間 攝氏溫度

00:34:44.318 --> 00:34:45.585 
以及華氏溫度

00:34:46.219 --> 00:34:48.722 
時間是存儲在
對象內部的

00:34:48.922 --> 00:34:51.757 
真實時間數據的
字符串插值

00:34:52.659 --> 00:34:54.828 
因爲是用字符串插值

00:34:54.895 --> 00:34:57.931 
因爲我們提供了
自定義字符串可轉換一致性

00:34:58.398 --> 00:35:00.567 
這些可以自動提取

00:35:01.835 --> 00:35:03.837 
這裏還要
注意的一點是

00:35:04.304 --> 00:35:08.108 
當我獲得兩種溫標
用攝氏度

00:35:08.175 --> 00:35:10.677 
和華氏度
來進行結果打印

00:35:11.278 --> 00:35:14.114 
我不能改變
存儲在對象內的數值

00:35:14.715 --> 00:35:16.016 
當然 你會說 不要改

00:35:17.050 --> 00:35:19.520 
實際上 
要注意的是

00:35:19.686 --> 00:35:21.522 
不要用編寫
進程格式器的

00:35:21.588 --> 00:35:23.557 
方法改變程序的狀態

00:35:24.892 --> 00:35:27.661 
現在我們做了這麼些工作
得到了這些東西

00:35:28.662 --> 00:35:30.697 
會怎樣從中受益呢？

00:35:31.732 --> 00:35:33.967 
我們可以試着再做po

00:35:35.702 --> 00:35:36.970 
來吧

00:35:37.337 --> 00:35:38.705 
現在我再來看

00:35:38.772 --> 00:35:39.673 
我看到了對象

00:35:40.174 --> 00:35:42.109 
可以看到現在是

00:35:42.176 --> 00:35:44.444 
6:30 p.m.

00:35:44.711 --> 00:35:47.047 
是93.2度

00:35:49.049 --> 00:35:50.951 
大家可能會奇怪 的確

00:35:51.018 --> 00:35:52.753 
昨天庫柏蒂諾是很熱

00:35:54.821 --> 00:35:58.125 
現在我們完成了
但是這麼做

00:35:58.192 --> 00:35:59.927 
是因爲我們很聰明
提前完成了工作

00:36:00.594 --> 00:36:03.497 
有時 我會試着
調試一些內容

00:36:04.631 --> 00:36:07.167 
把自己的程序調試到位

00:36:07.367 --> 00:36:09.803 
結果有這樣一個
很難複製的問題

00:36:10.003 --> 00:36:11.505 
最後發生了

00:36:12.406 --> 00:36:15.008 
不過現在真的
很難找到這數據

00:36:15.309 --> 00:36:17.211 
數據非常令人頭痛
非常很複雜

00:36:17.277 --> 00:36:20.414 
真希望自己
之前做過這事兒

00:36:20.480 --> 00:36:23.217 
這樣我就可以更簡單地
看待我的數據了

00:36:24.051 --> 00:36:25.352 
不過 可惜沒有

00:36:26.186 --> 00:36:27.588 
所有的希望都落空

00:36:28.622 --> 00:36:30.424 
不 沒有

00:36:30.691 --> 00:36:33.427 
還可以添加一致性
和運行時間

00:36:33.493 --> 00:36:36.663 
通過表達式剖析器 
可以添加這些一致性

00:36:36.897 --> 00:36:38.866 
並運轉 同時調試你的app

00:36:39.867 --> 00:36:40.701 
另一方面

00:36:41.401 --> 00:36:42.870 
你還不能改變它們

00:36:43.237 --> 00:36:45.239 
現有的一致性保留

00:36:47.207 --> 00:36:49.476 
你在REPL做嘗試

00:36:50.010 --> 00:36:51.945 
你真希望自己能做po

00:36:52.179 --> 00:36:54.248 
我希望自己能
添加一致性

00:36:55.315 --> 00:36:57.017 
在REPL中也可以這麼做

00:36:58.986 --> 00:37:02.089 
當然 但是我確定
大家都期望這樣

00:37:02.523 --> 00:37:03.357 
爲什麼？

00:37:04.091 --> 00:37:05.759 
在環境中 也是如此

00:37:07.160 --> 00:37:08.428 
來看

00:37:11.298 --> 00:37:12.699 
看似...

00:37:13.967 --> 00:37:15.836 
我們在過去一年
在調試器方面

00:37:15.903 --> 00:37:17.371 
所做了許多動作

00:37:17.604 --> 00:37:20.541 
你們從凱特 西恩和我這裏聽到的

00:37:20.974 --> 00:37:26.713 
這些都離不開要在調試的同時
確保能夠輕鬆訪問

00:37:26.780 --> 00:37:28.815 
儘可能多的相關信息

00:37:30.284 --> 00:37:32.219 
訪問Objective-C
運行時間

00:37:32.352 --> 00:37:36.156 
會讓你在域無法獲取之前
對之有更多瞭解

00:37:37.124 --> 00:37:38.659 
SDK模塊

00:37:39.026 --> 00:37:44.698 
爲應用所運行的操作環境

00:37:44.765 --> 00:37:47.201 
更多類型 更多函數
甚至有宏觀

00:37:47.367 --> 00:37:48.669 
提供了
前所未有的訪問程度

00:37:49.203 --> 00:37:51.471 
還有進程格式

00:37:52.739 --> 00:37:55.175 
進程格式是用來生成

00:37:55.242 --> 00:37:58.879 
跨界應用類型的
編譯表示的

00:37:59.112 --> 00:38:00.848 
極好方法

00:38:01.181 --> 00:38:03.750 
它們可以應用在環境中
在REPL中

00:38:03.817 --> 00:38:05.352 
也可以是在調試器中

00:38:06.620 --> 00:38:08.355 
若要了解更多詳情

00:38:08.755 --> 00:38:09.590 
可以隨時

00:38:09.656 --> 00:38:12.392 
瀏覽我們的網站
Swift語言文件

00:38:12.492 --> 00:38:14.928 
或開發人員論壇
當然還有實驗室

00:38:14.995 --> 00:38:17.798 
還可以給開發顧問
斯特凡發郵件

00:38:19.366 --> 00:38:22.402 
非常感謝
希望大家喜歡WWDC