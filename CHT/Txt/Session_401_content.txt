Swift和Objective-C互操作性
大家下午好 我是約旦·羅斯
哇 謝謝你們我還什麼都沒做
我是約旦·羅斯
過會兒道格·格雷戈爾也會加入我們
我們想要和你們分享一年來我們在Swift和Objective-C語言的改進
特別是在互操作性方面的變化
因爲Objective-C和Swift的類庫都相同
所以這很重要
在Xcode 7中我們更容易看到
這個映射是如何工作的
來到Objective-C的頭文件
在頂部靠左的位置
選擇顯示關聯項按鈕
會跳出關聯項菜單
其中一個是生成的接口
這會顯示SWIFT的對於這個頭文件的映射
這和Xcode 6中用”調到定義
場景中的視圖是完全一樣的
但是現在你可以很容易的在對象中的任意頭文件中得到這個映射關係
今天我們將會講到多種
在Swif和Objective-C混編中
和在Objective-C中的開發的新特性
我們將從一些Swif和Objective-C混編
的基本特性開始重點
討論新的錯誤處理特性和這種特性
跨語言工作原理
然後我們將會
講在過去一年中關於Objective-C的3個
主要改進包括“可空性註釋”
“輕量通用類型”和“種類型”
我們從Swift端開始
我們會看到將Objective-C APIs
嵌入Swift有多容易
但是問題來了
什麼時候把Swift暴露給Objective-C代碼
讓我們複習一下規則
如果你有一個NSObject的子類
那麼默認的它的方法和屬性暴露給Objective-C代碼
在這個例子中我們有一個我的控制器類是
UIViewController的子類
那是NSObject的非直接子類
所以這個刷新方法將暴露給Objective-C
然而如果你把這個方法標記爲私有的
這意味着它僅在當前文件中可見
所以在這裏默認情況下Swift不會將這個方法暴露
給Objective-C
另外如果你僅僅使用
如果使用一些Swift專用的特性
就沒有辦法把這個方法暴露給Objective-C
Swift甚至試都不會試
最後如果不是NSObject的子類
僅粗略的符合Objective-C協議
那麼你必須格外注意
你的方法必須完全的滿足協議要求
在Xcode 7你會得到這樣的告警
在這裏 “頁面視圖開始加載”不是objc
它不能滿足
“UI web視圖代理協議”的要求
這涵蓋了默認值
你把這些默認行爲
變成這樣時會發生什麼？
讓我們回到具有刷新方法的我的控制器版本
我想把它暴露給Objective-C
但是它依賴於
我下一步想做什麼依賴於我需要用刷新方法做什麼
所以如果我想要
用接口生成器或是核心數據屬性
我們有專用屬性
你所要做的就是添加這些屬性
所以如果你使用現在展示的IBAction屬性
你只需要在i接口生成器中將刷新方法設置爲有效行爲
相似的如果你正在使用
全系統基礎關鍵值屬性
或者是Cocoa綁定屬性
你只要添加動態調整器就可以了
這將告訴Swift這個屬性實施過程中
通過全系統關鍵值
可以在線調整
但是如果你想要將某個特殊方法
或是屬性暴露給Objective-C
你總是可以使用plain-oldat-objc調整器
或是objc 屬性 對不起這將會把方法或
objective暴露給Objective-C
這不需要任何附加語義
這個objc屬性在其它事情上也有用
在Objective-C中這個objc屬性會
爲你指出一些不可見的事物
如果我想要非尋常返回類型
的跨版本刷新
那麼我將會看到錯誤信息“因爲返結果類型不能在
Objective-C中體現
所以該方法無法在objc中標識”
所有這些規則都包含在“用cocoa使用Swift
and Objective-C”手冊這本手冊中
可以訪問developer.apple.com/Swift在線查找
現在我們已經介紹了默認值
還介紹瞭如何重新定義這些默認值
以便讓我們的代碼更加符合ObjC
但是如果你碰到相反的問題呢？
讓我們來看看這個類：計算器控制器
它有兩個方法：“執行 操作”
其中一個有一種類型的封閉包
另外一種有不同種類的封閉包
好吧
Swift能夠基於參數類型快速區分這兩個方法
但是Objective-C不是這樣工作的
在Objective-C中不能通過類型
只能通過名稱區分方法
在這裏Swift知道這是個問題
它會給你發送錯誤信息
現在你總是可以使用ObjC屬性的選擇器形式
來修正這個錯誤
所以如果我編寫了這個代碼那麼當我從Objective-C接入它時
我就將按鈕方法
重命名爲執行二進制操作
頂部的方法還是名爲執行操作
在Xcode 7中爲這類問題我們添加了其它解決方案
即non-ObjC屬性
就像你所想到的
這會使用一些非正常暴露給Objective-C的東西
並且防止它被這樣暴露
你可以將non-ObjC賦予任何方法
屬性子腳本或初始化器
那是數量非常龐大的Objective-C和方法
但是低級語言怎麼辦？
來看看C語言
這裏有些人不太高興了
我們有一個函數指針的幻燈片
函數指針是C語言用戶用來回調的
這意味着它們類似於閉包
但是它們不能攜帶任何附加狀態
我說的是什麼意思呢？
我用Swift試圖
調用C函數開放函數
它有很多的參數
你不需要知道所有的參數
其中一個是回調參數
在這個回調中我做自調用
所以它必須儲存在這個閉包後面訪問的某個部分
這是我們所謂的攜帶狀態的閉包
當你試圖使用這個閉包
用這個API你收到一個錯誤信息
現在在Swift1.2中函數指針不是非常有用
在頂部顯示的是C類型
它透明的進入SwiftC函數指針類型
你可以把它傳過來但是不能再做更多的東西了
Swift 2.0中我們只是增加了標識爲convention-C
標識爲convention-C的閉包
你能在Swift中創建傳遞它們
甚至是調用它們
這意味着你可以在Swift中
訪問全部的C APIs
以前你可不行
所以我們做了兩件小事以提升Swift
C和Objective-C之間的橋接能力
但是今年我們還有非常重要的新特性
在語言橋接方面
具有非常巨大的影響
最重要的當然是錯誤處理
如果你還沒聽說過
錯誤處理模型我們準備了很多
關於Cocoa的NSError樣式和規則的課程
以及圍繞這些話題的約定
並分享我們從建立這樣一個新特性
中學到的知識
這個新特性用“throws“關鍵字表示
這會覆蓋今天上午課程的許多內容
“有什麼新Swift”
如果你還沒有使用它
我強烈的建議你以後試試
看看錯誤處理機制是如何工作的
但是我重點要講的是它在兩種語言
混編時的應用
你要明白這並不是僅僅從Objective-C映射到Swift
這也是Swift類庫如何暴露給Objective-C
這是雙向映射
讓我們仔細看看這裏的返回類型
在Objective-C中錯誤約定爲
返回無效值視爲發生錯誤
當填寫“out error“參數時
會這樣
然而在Swift中這完全包含在錯誤處理模型中了
所以在Swift返回類型中你會看到
非選擇性的對象類型
相似的在Objective-C當沒有事務被視爲失敗事務時
你將得到一個布爾返回值
同樣的在Swift的錯誤處理中也有
你將得到一個void返回類型
現在在這些Objective-C的例子中
既有多參數的
也有隻有一個錯誤參數的
但是還有一些case中的方法只有一個參數
你將得到像
“請檢查資源可查到並返回錯誤”這樣的提示
在Swift中如你所見既然我們已經知道
使用“throws”關鍵字
方法可以返回錯誤
我們將砍下最後三個單詞
只爲你!!!
現在所有的都會有的
當你使用NSError-star-star類型
當你真正的使用NSError約定
的基本格式
其它情況下會發生什麼？
我們只是讓事情保持像這樣
在Objective-C如果你有NSError參數通常
它會以可選的NSError參數出現在Swift中
你爲正在使用的任何API
來恰當的處理它
記住NSError參數符合Swift錯誤類型協議
所以你也可以用Swift自己的處理機制使用NSError參數
這些都顯示Swift已經準備好處理
所有來自Objective-C的報錯
但是如果我從Objective-C調用一個方法
並且它是一個Swift方法產生的Swift錯誤呢
現在當然了我們需要這個
然我們看看它的原理
這裏我有一個名爲“請求錯誤”的錯誤類型
它是一個用Swift的錯誤系統定義的新類型
它符合錯誤類型協議在這個案例中
它是一個枚舉只有一種可能性
在方法中使用這個錯誤很容易
我再定義一個“發送請求”方法
用“throws”關鍵字標識它表示
它可以失敗然後當我觸發失敗條件時
實際調用了“throw”
現在我要在Objective-C調用這個方法
它應該能行
怎麼樣
首先是方法的名字
發生了變化
不再只是“發送請求
現在是發送請求錯誤”了
就是你將使用的名稱
前提是你的Objective-C代碼從“發送請求這個方法開始
另外在此基礎上我們剛剛使用了
plain-old NSError類型以及我們在Swift
中產生的錯誤
除此之外錯誤類型確實包括有用的信息
如果我們輸出帶着這個錯誤的域和代碼
我們將會知道它原來是類型
以及我們以前看到的enum類型的原始值
現在這裏將會有一個更加有趣的事情發生
我用ObjC 屬性去標記enum類型的數據
這是我們添加在Xcode 6.3的一個功能
如果你在enum上用ObjC 屬性標記
然後它就會輸出到你所產生的頭文件上
這個頭文件暴露了swift類的Objective-C的一面
在Xcode...抱歉在Xcode 7中
我們已經添加了一個更有趣的小功能在這兒
這是一個包含錯誤類型協議的enum
因此我們也將會產生一個字符串常量去表示錯誤域
現在所有比較的大的錯誤都已經被你在swift中標定了
你可能想爲自己的類去使用和運行這個
但是隨後從 Cocoa
回到其餘的SDKs
感到不足的錯誤
但是別擔心我們將會全力幫助你的
因此如果你出席今天早些時候的演示
你可能已經見過這種
檢查資源的可達性
並且捕捉不同錯誤情況的預檢措施
現在錯誤的類型之一
已經被列爲“NSURLError文件不存在”
那是一個來自Cocoa的錯誤
爲什麼要使用快速符號去顯示？
好了我們已經在整個SDKS中使用了最常見的錯誤類型
這樣可以讓你利用
Swift自己的捕捉語法去使用它們
因此在這兒你可以使用各種各樣的錯誤
你應當遠離的通常的想法就是
當你在使用Objective-C中的時候錯誤就應該會就像NSError
而當你在使用swift的時候它們也就應該想swift的錯誤
事情應該只是工作
因此這只是在過去的一年中
我們在互操作性所做的一些改進
所以說到我們在Objective-C方面所做到的改進
我想把它交給 道格
謝謝你 約旦
那麼今天我們將會討論
我們這一年添加在Objective-C方面的三個特性
這些特性能夠讓你
更好的使用Objective-C去編程
能夠讓Objective-C APIs更加的優秀
讓他們更好的映入到swift中
同時提高你在使用Objective-C的靜態類型的安全性
我們將要討論的第一件事情就是
Objective-C的nullability
來觀察一段Objective-C的代碼
有很多的指針
這裏面哪一個可以是零？
代碼不會告訴你
如果你繼續去閱讀文檔
如果你今天幸運的話它今天可能會告訴你
你應當去寫一些測試
看看它可能的表現的行爲或者可能的猜測
但是那並不是一個好的方法
在這些地方可能會缺少一些信息
當我們去年推出swift的時候
在這些實質上意味着我們不知道的
默認打開的選項中
信息的缺乏表現的更加的明顯
在swift的一面它可能是零
所以我們並沒有感到太高興
在發佈Swift 1.0之後
我們在自己的核心框架內
編寫了成千的指針
去告訴那些指針可能爲零的編譯器
經過編輯之後的接口變得更加的簡潔
現在我們使用可選擇的類型
零是你確實必須處理的一件事情
其它的一切都是不可選擇的
這仍然不是那樣的美好
因爲這些知識被編譯成編譯器
這不是你所能完成的事情
所以對Xcode 6.3來說我們爲Objective-C引入了可空限定符
所以你可以把可空限定符
添加到C/Objective-C的指針中
去描述是否可以接受零狀態
當然你的應用程序
確實可以做更好的通訊
它接受零麼？
這說的通麼？
它能夠幫助我們的工具
做出更好的靜態檢查去捕捉運行時表現出來的bug
它能夠在你的Objective-C APIs中
讓你的swift表現的更好
現在這兒有三個可空限定符
Nullable這表明可能是空的指針
這個當然映射到一個Swift選項中
然後那兒有一個非零
這就表明零並不是一個有意義的值
現在對於一個非零指針來說
它可能最終在Objective-C程序中最終變成0
可能它就是因爲某些時候我們在傳遞0的時候
零通過傳遞
而這個時候已經開始運行過了
編譯器並不會因爲非空的註釋
改變它生成代碼的方式
這就表明了應用程序作者的意圖就是
零在這兒不合情理
我們也有三分之一的null-unspecified限定符
這在無論是nullable還是非零的情況下實際上都是正確的事情
如果我們對於指針一無所知
我們把這些映射到那些你就可能會得到的
相同的默認打開的選項中
關於可空限定符最重要的事情就是
我們已經在我們整個SDKs去推出了
好 所以不是單純的覆蓋幾個核心框架
我們已經覆蓋了 SDKs的絕大部分
所以這給出了一個非常好的
在其他地方都有關係和non-optionals
正確optionals的swift經驗
對於你的Objective-C代碼來說
這意味着你已經開始看到
已經被誤用的APIs的新的警告
因此 比如你看到一個你已經把零傳送到你並不期望的路徑的警告
這不是應用程序協議的一部分
現在可能傳遞過一個以前運行過的零
它可能會繼續工作
但是你應當注意這些警告
因爲這些應用程序的作者已經告訴過你
你不應當在這兒傳遞零這裏必須要小心
因爲它將來可能會改變
現在,比方說你想添加可空限定符到你的頭文件中去
這個開始的地方就是被編輯的區域
因此這些將會被“NS-assume non-null begin”
所描述NS-假設非空結束
包括你用的這些宏的頭文件
這樣做就是允許編譯器
對未註明的指針
去採用默認的假設
所以如果你有一個單級指針
那麼將會被假定爲非空因爲我們發現
對於我們絕大多數的APIs來說零並不是一個有意義的值
另一個有趣的特殊情況下就是
這裏是一個NSError-star-star
參數當你在對Objective-C的錯誤進行處理的時候
這些可以在兩個級別上被認爲是空的
因爲這是你和他們爲空性工作的方式
現在默認是良好的他們應該承擔大部分的情況下
但是這就意味着你必須去註釋異常的情況
所以我們把這些超視圖的屬性標記爲nullable
當然不是每個視圖都有一個超視圖
零在這兒是有意義的
衝擊測試的時間有個可空參數
你不需要通過一個事件去做衝擊測試
當然結果是可空
因爲零在這個地方是有意義的
這意味着我們沒有擊中任何東西
現在這就是null-unspecified出現的地方
說你正在編輯一個頭文件
你將會遇見一些一直都存在的很奇怪的事情
你不知道它
它沒有被記錄下來
可能它正在做一些特別有趣的事情
這些事情傳遞着可能會或者不會工作
它五年之前退役時才能回答的零
仍然有使用空未指明的很大空間
只是要把它標記成空未指明
這就意味着“我考慮過這個問題但是我沒有得出答案”
最好的事情就是在swift中保持它默認未開的選擇
保持它是空未指明的
你可以稍後再回來
所以當編輯的時候嗎你確實像
更早的得到一些好的廣度
去讓你的 APIs 更好更快
現在 當你去到C
事情就會變得有點模糊
所以我們有了所有相同限定符
但是他們之前需要下劃線
現在這些雙下劃線的關鍵字這些限定符
可以被用於任何地方任何指針
這個地方有個重要的規則就是
限定符適用於右指針
constor或者volatile將會去應用那個指針
這對於這樣的參數外指針是nullable的
參數外指針值是nullable的
多級指針是非常重要的
因爲只要參數num的值也是零你就可以在這個參數中傳遞零
內部指針是空的因爲當你傳遞數組時
所有的使用CF數組的值
都必須是非空的
這就是我們要講的關於可空的東西
今年我們已經把它推送到我們的 SDKs 中
所以你能夠在
在Objective-C 和Swift中獲得更好的體驗
我們強烈的推薦你使用它
去提高你自己的Objective-C APIs
特別是爲了一個更好的Swift 體驗
好了 讓我們開始下一個特性
這是一個大的
對於Objective-C來說是一個重量級的泛型
現在這個特性的原型
它其實是相當容易去激勵的
集合
這裏我們有subviews的NSArray
數組中的是什麼？
我們不說在數組中的東西
我們把這個拿入到 Swift中你說
嗯 這是任何對象的數組
它仍然沒有告訴我任何事情
我已經投了很多 那就是他告訴我的
當然我們有這種常見的
請求類型的集合
因爲人們總是說想說我有一個數組的觀點
我有一個從字符串關鍵字映射到
與圖片相關的關鍵字的字典
這可能是過去十年當中
要求最高的Objective-C特性
所以現在我們最終推出
重量級泛型的Objective-C
所以這是一個可以改善你的APIs的表達性
的一個最通用的語言特性
這讓集合的方式更容易去使用
現在我們有了所有靜態安全集合類型
讓我們看一看
所以這是我們的subviews的屬性
這是一組UI視圖
我們只是把UI-view-starUIV指針放置在尖括號中
相同的語法你已經看到過了哎喲 抱歉
相同的語法你可能從swift和C++
或者C-Sharp等語言當中看到過
是的 我們完全清楚
尖角括號是引用協議限定符
別擔心 我們知道這一點
所以這就向 Object-C 中引入了更多的類型信息
當然這一點反映到Swift中
就有了更多優雅的類型信息
但我真正想談談其對Objective-C的影響
因爲這一功能對於Objective-C來講確實有用
現在我們來談談類型安全
下面是一個例子
所以我要取得任何一個URL 或 NSURL 的路徑組件
然後將其放入進入一個陣列的 URLs 之中
如果我不知道這個應用編程接口這種做法看起來就近乎是合理的
而且要等一段時間我才能得到運行錯誤的信息
一個無法確認的選擇器會指出不對
我在使用路徑組件的方式上犯了一個很大的錯誤
有了類型集合體並且 當然
我們在我們的整個軟件開發包中推出了很多類型集合體
現在你就會及時得到一個警告在錯誤發生時
告訴你到底你做錯了什麼
還有許多其他情況比如說我要建立一個 NS 字符串組成的
不可變陣列可我傻傻地又要往那個陣列中加個東西
卻沒有先把它變成一個字符串
編譯器將會告訴我不對
你不能把一個 NSNumber
放到這個 NS 可變字符串陣列中
這不合理
實際上編譯器對於此處與 Cocoa 集合體有關
的語義有着相當深入的瞭解
現在我們看看這裏的例子我們有一個視圖陣列
我們還有一個應答陣列
我們將視圖陣列中的元素一個個分配到應答陣列中
沒有問題 因爲每個視圖也是一個應答
看起來挺好
沒有問題
讓我們用一個可變的變式來做同樣的事情
所以我們用那個存儲的可變視圖陣列將其元素分配給
存儲的可變應答陣列
這裏有個陷阱
這個陷阱是 當然 我可以對
我所存儲的應答進行轉換
在其中放一些不是視圖的應答元素
這樣對之後的某個過程事情就會變得非常混亂
那個它正在查看的視圖陣列
中有個一個視圖控制器元素不是視圖
編譯器也瞭解這一點
它會在程序初始化時抱怨在這裏
雖然用不可變陣列來完成這一任務
很安全因爲他們不會
在你不注意時改變可用其變體可變陣列
來做這些就不安全
好你其實已經親眼見過你需要的一切
使你能夠在你的整個應用程序中
使用輕量泛型且類型化的集合體
但是現在來看看我們怎樣在Foundation 中
使用這一方法
來實際上創造類型化的集合體
因爲這裏的該功能是泛型的
類型化的集合體是其結果之一
所以在這裏我們有 NSArray因爲你習慣於見到它
現在我們要基於存儲在 NSArray 中的
對象的類型將其參數化
這次我們又要使用尖角括號
這裏我們只是引入一個名字
這一名稱 我們可以在整個界面上使用
當然索引處是對象返回的也會是對象類型
如果我們在這裏添加其他的方法
當你用一些對象來將你的陣列初始化
那個 C 陣列就會包含對象
通過添加對象來使用陣列
你放入一個新的對象你獲得一個NSArray陣列的對象
所以它的組造非常非常順利
當然這也適用於類別和擴展
在這裏我們有一個NSDictionary類別以密匙類型和對象類型
進行參數化而且我們還在這裏
使用對象類型替代密匙類型在這裏接受一個密鑰類型
返回一個可以爲 null 的對象類型 因爲這裏
當然空值是有意義的因而我們要使我們的應用程序接口中
包含這一信息
現在當然還有一些現有的在 NSDictionary
和NSArray等等基礎上定義的類別也許你自己就會有一些
那些會和過去一樣可以繼續使用
他們不能以任何方式訪問類型參數
但他們也根本不會改變行爲
他們將會像過去一樣繼續發揮作用
這使我想到了向後兼容性
所以整個輕量泛型功能都基於
一個類型擦除模式之上
這意味着編譯器擁有全部這些
豐富的靜態類型信息但當編譯器要
生成代碼時它就會清除這些信息
這對 Objective-C 來講有很大的好處
我們不需要對Objective-C 的運行
進行任何更改就可實現這一功能
這意味着我們可以在類型集合體中
推出泛型你可以在你的所有應用程序中採用之
這不會影響你將你的應用部署回各種現有的
操作系統上的能力
這些從那個描述中看起來不太明顯
當然我們也不會
以任何方式改變程序共同生成
我們不會在Objective-C中添加運行中的檢查
這種做法在Objective-C中沒有意義
我們只是要保持完全的二進制碼兼容性
因此採用此功能用好那些警告因爲他們能幫助你
避免犯下可怕的錯誤
你可以非常 非常 非常緩慢地採用之
我覺得這是最好的說法
所以除了二進制代碼的兼容性之外
我們還要提供源代碼的兼容性
因爲我們是通過我們的軟件開發包來推出這些功能的
我們不想讓你不得不更新你所有的源代碼
以便在各處都使用這一功能
我們希望你逐步採用它
哪裏你覺得合理你就在那裏使用它
因此我們在該語言中提供這些隱式轉換
使你可以添加類型參數或將其去除
好嗎？另外這樣做不會帶來任何運行成本
但在你需要時 它可以讓你進入和離開泛型系統
因此你所有的新代碼都可以用泛型來編寫
而且如果你不想要去碰你舊的代碼
那完全沒有問題這不會改變
好吧 我們還要談談最後的一個功能這一功能比較酷
是這種的類型
實際上來自於我們在輕量泛型方面所作的工作
於是我們起步之處當然是
將不具類型的集合體用於子視圖
也有這樣的代碼先去抓取一個視圖
之後向其發送一些信息
此代碼是好的今天仍能運行
我們進行下一步做了這些註釋說 好吧
子視圖包含用戶界面視圖所以我們被警告了
編譯器完全有正當理由
來發出這一警告
它現在知道第一個子視圖是個用戶界面視圖
它不可能知道你知道那是一個用戶界面按鈕
且會實際上對這一選擇器做出反應
因此雖然編譯器是正確的
可對所有這些代碼
發出警告並不一定有什麼用處
你會得到大量的警告其中大部分都是良性的
你會需要在各處使用各種轉換
這真的迫使我們考慮 ID
以及如何將它作爲一個應用程序接口合同
所以我們在這方面舉個小的簡單的示例
讓我們來談談 NSApp這是 Cocoa 中的那個全球變量
使你能夠訪問你的NSApplication實例
現在這真正的意味是NSApp是NSApplication的
一個子類別
但我們無法向類型系統解釋這一點
使用 kindof 類型我們可以在Objective-C中準確表達這一點
這意味着什麼？
這意味着NSApp是某種應用程序
所以我們要賦予它一些有限的行爲 如ID
所以我有了一個NSApp當然我可以將它轉換成一個 NSObject
因爲每個NSApplication都是一個 NSObject
在這裏重要的部分也就是類似 ID 的行爲
是將 NSApplication隱式向下轉換成
你的MyApplication子類別
這樣好
我們想要這種行爲模式是因爲這就是NSApp一直的工作模式
現在我們不會允許的是一些愚蠢的交叉轉換
您試過在一個字符串中使用 NSApp 嗎？
這不是一個NSApplication且永遠也不會是
所以你可以在那裏提出一個警告
當然與此同來的是一種想法
你可以與NSApp交換信息 並得到NSApplication中的
所有方法其各種超類別和其各種子類別
現在使用kindof類型我們實際上發現
這比 ID 更有用的多
因爲它會在應用程序接口合同中給你更多的類型信息
這一點對 Swift 和 Objective-C來講都很好
所以在這裏我們有這個NSTableView 方法
有列行和 makeIfNecessary
它總是返回到 ID
因爲這一隱含的向下轉換類型的行爲
是重要的
那麼現在我們可以將其重寫成一個kindof NSView
所以返回某種NSView而從 Swift 來講
現在我們要返回一個選擇性的 NSView
這對 Swift 來講 是個正確的
應用程序接口且它可以在Objective-C中完美地工作
讓我們將其帶回我們最初的
有關輕量泛型的例子
這裏我們有我們的各種子視圖稱爲UIViews的一個NSArray
好吧現在我們可以說它是一個NSArray的kindof UIViews
這樣我們就在Object-C和Swift中得到了一個更強大的
應用程序接口
獲知這一屬性是什麼會容易很多
但你不會造成任何虛假的警告 因爲你依舊會有
從 ID 而來的好的隱式的向下類型轉換行爲
希望這一點兒會讓你提出一個問題
我真的該在應用編程接口中使用 ID 嗎？
多年以來我們實際上一直在推出很多功能
在各種重要的情況下比 ID 能夠給出
更爲具體的類型信息
且在我們推出Arc 的同一年
我們推出了 instance 類型
用於讓你調用的方法返回與 self 相同的
動態類型
今年我們正在推出類型集合體
這將消除 ID 的很多用途
從我們自己的應用編程接口我們一直在推出這些功能
當然當你採用這一功能時在你自己的應用編程接口上也是一樣
我們現在從 kindof X通過隱式向下轉換
談談 X 的任何子類別
所以你可以保持你代碼繼續工作
起碼所有那些實際上起着作用又沒表現怪異的代碼
但是會有一個更好應用編程接口合同
而且各種協議已存在於Objective-C中很長一段兒時間
而使用某個協議的 ID是明白地說
我不在乎一個類別的類型是什麼
它只是必須要符合這一協定
所以有一個大類的用途適合於 ID
那是當你真正的意思
確實是一個任何類型的對象
那就沒有任何靜態類型信息可以把這一點
表達得更好
這樣這方面的一個典型的例子是用戶信息字典
你用字符串做密匙且你用 ID 做值
這完全合理
因爲對不同的密鑰其值會有
不同的類型而這種類型你只能夠
動態地確定
讓我們總結一下
所以我們對Swift和Objective-C都做了大的改進
這些語言是一起設計並一起進化
以使其可以完美地一起工作
而Xcode和其支持工具將會幫助你
在這兩種語言之間遊移這是對你的工作流最好的方法
我們已經爲Objective-C推出了很多強大的功能
我們強烈建議你使你的使用Objective-C的
情況現代化
這些新的語言功能給你提供好得多的應用編程接口
你會在我們的應用編程接口和你自己應用編程接口中看到這一點
這些新功能還會讓你的程序具有更好的類型安全性
讓你能夠儘早找出問題而不用等他們在程序
運行時以可怕的無法確認的選擇器的形式表現出來
且使用這些功能可以真的使你在 Swift 中的
Objective-C接口變得優美
從而讓你編程時獲得最好的 Swift 體驗
如需更多的信息請聯繫我們的傳道人
Stefan Lesser查找相關文檔
或者通過我們的網上論壇與我們聯繫
還有很多有關的課程講授
Swift 和 Cocoa 中有什麼新的東西
這裏有很多很棒的Swift課程
謝謝