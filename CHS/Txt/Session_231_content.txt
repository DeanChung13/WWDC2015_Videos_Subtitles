Cocoa Touch最优方案讲座
大家好 非常感谢你们来参加Cocoa Touch最优方案讲座
我叫 盧克·黑斯特曼是UIKit一名工程师
今天我很荣幸为你演示一些
巧妙的程序片段和各种实用的建议
现在和将来你都可以在所
编写的应用程序中直接地进行应用
所以我将向你展示一系列主题
这些主题都是和开发Cocoa Touch应用程序
密切相关的每个主题
我都会教你们一系列的最佳实用技巧
那些主题分别为第一 应用程序生命周期
之后是视图和视图控制器 自动布局
最后一个是表格和集合视图
当我讲这些主题的时候
有一系列的目标我会随着我要讲授的
巧妙的程序片段传授给你们
因为...
我们所作的一切其目标都是要完成几个基本理念
而一定也都是你希望应用程序所能体现的
第一 你要想办法让你的应用程序实现峰值性能
你要你的应用程序如丝般顺滑
看起来就像一个摇滚明星程序开发员
并且人人都喜欢你
你也想让你所开发应用程序提供一流的用户体验
那样 每人都会觉得
你开发的应用程序看起来精美且令人赞叹
最后 你还要把你的程序代码写好
使之能够最大程度地适应未来的发展
这样当未来版本的iOS 推出时你需要写比较少的
代码就能使你的应用程序适应于这些新版本的iOS
那些就是我们讲解这些主题时
心中要牢记的目标
而现在我首先要谈到应用程序的生命周期
我要向你们讲授的第一个最优方案
与使用者第一次使用应用软件体验有关
也就是软件启动时的体验
因此与应用软件有关的第一个最优方案是要使之能够快速启动
这也就是在用户点击你的图标时你的应用如何能够显得有反应
而且你的应用也能做好准备马上即可与用户进行互动
而使你能够快速启动一个应用程序的方法其实非常简单
就是要能够迅速从ApplicationDidFinishLaunching
这一用户界面应用程序委托事件返回
这个在做法上实在简单
我肯定你们全都知道如何去做了
给所有运行时间长的工作设置一个应用程序
从ApplicationDidFinishLaunching中挪到他处发派以实现延迟执行
因为要完成尽可能少的工作就返回
你要建立起一个基本的用户界面使你的用户可以与之互动
然后返回无论从一个数据库或者网络来加载数据
ApplicationDidFinishLaunching来延迟完成其执行
如果需要太多时间启动当然你的应用程序将被中止
因为你的程序看起来已在系统中停止了运行
所以你确实需要从那个状态尽快返回
做出一个反应良好的应用程序
不是能做到启动快就可以了
我们要完成的比这要多我们要让我们的应用程序一直反应良好
所以我要深入到这一技术中来讲解
反应良好总的来讲意味着什么这样我们才能构造
一种技术方法做到不只在应用程序启动时能快速完成
而且在该程序的整个生命周期中都会反应良好
所以 尽管我刚刚谈过将所有这些工作
从ApplicationDidFinishLaunching去除挪到他处推迟完成执行
但是有关最优方案
我真正想说的并不只是异步执行
真正要做的关键是要将运行时间长的工作区别对待
将它们放到某个后台队列中异步执行
如果你需要从某个数据库加载数据
或者你需要连接网络
那些都是可以放到后台进行的工作
所以如果我们再考虑ApplicationDidFinishLaunching
这一方法而我们有这种非常简单的方法
来调用一个单纯的ApplicationDidFinishLaunching
你知道我们通过ApplicationDidFinishLaunching直接加载数据
而我刚刚说过 推迟执行这一任务
好吧所以我们可以简单地完成这一步
我们将其发派出去 就算做完了
这个任务就不在ApplicationDidFinishLaunching中了
我们就能够迅速启动而启动时一切也就会更好
但是那样仍会产生随后阻断总执行队列的可能性
且会因此阻断与用户之间的互动
事实上最好的做法是时将那个工作转移到
一个后台执行队列中这样当那个任务开始执行时
与用户之间的互动可以继续进行
而你的应用程序看起来也总是反应良好
所以这种讲任务通过后台执行队列发派的技术
可以在应用程序执行的任何时候应用而不仅仅限于启动之时
然后 你把那项在后台进行的数据有关的工作
而当那个工作完成时
其执行就回到主执行队列
与像视图和视图启动器这样的UIKit 元素进行互动
所以这样才是真的反应良好
接着你要做的是
除了在用户第一次启动 应用程序时你要保证程序反应良好之外
还要保证在用户第二次启动程序仍然反应良好
而要实现这一目标就要使
在用户退出你的程序时该应用程序并不简单的结束
而是进入一种iOS上的暂停执行状态
所以要在用户第二次打开你的程序时想要特别快的话
只需要让你的程序能从上次的暂停状态继续执行就行
而这需要那个应用程序仍在内存中
所以 我们要看看系统内存的情况
我们确定系统内存的一部分是由被操作系统内核
和各种操作系统的进程所占用
系统内存的一大块将会是由前台应用程序所占用
之后 还有不少会是由后台应用所占用
现在 你会注意到在整个图像中
会有某个后台应用程序占用比其他任何进程
都多的内存
你的应用程序不要成为那样否则
你不像这样的原因是
程序会第一个结束运行当应用程序需要额外的内存时
所以你要让你的应用程序使用用户界面应用程序
的委托方法获知何时自己要进入后台运行
之后就要释放不需要的内存资源
使其进入后台运行时所需的内存量能够尽可能的小在使用拆分视图时
更加重要的是
同时运行会有多个前台应用程序
当第二个前台应用程序启动时
那种占用很多内存的应用程序不会继续存在下去
所以你不想你的程序是那样的
所以这就是怎样保证做到超级反应良好
且考虑你的应用程序在其整个生命周期中的性能表现
我想要谈的与一般应用程序编程
有关的最优方案是
利用各种框架
这也许是我能给你的最基本的最优方案
这就是：去做！
一定要利用Apple提供的各种框架
经年累月地努力以构建优良的框架结构
使你能够在其上开发应用程序
这样做有几个基本优势
我相信你对此已经熟悉
它可以降低你的维护负担
你知道吗？例如如果你使用用户界面导航控制器
当新的版本推出时你就不需要维护那一导航控制器
但如果你建造你自己的导航控制器那就必须自己对其维护升级
且当我们对那部分进行改进升级时你会免费获得那些改进升级
例如你们知道
两个版本以前导航控制器增加了一个
使用滑动手势的新的功能
在导航控制器上建立的应用都免费获得了这一改进的功能
如果你用自己的导航控制器你就必须自己去实现它
否则 你的应用程序就会感觉起来与系统的其余部分不相符合
所以 你需要这样做因为你需要能够
集中精力于把什么能使你的应用程序真正特别的地方做好
这是我们都想看到的
想要你利用时间写出神奇的应用程序
而不是花费你的宝贵时间做本来可以留给我们的构架很好地完成的事情
这就是我们要鼓励你做的事情
当然在你集中精力做那些时
你需要时刻牢记的是
怎样进行版本控制
所以我们常被问到的最大的问题是：
我们的应用应该能够部署在多少不同的版本上？
我们给你的建议是
以两个最重要的iOS版本为目标
所以 从今秋当iOS 9推出时起
这两个版本就意味着iOS 8和9
这种做法会让你获得这一最佳组合
你既能获得大量的用户又不需要担负过重的维护负担而
必须为过去的好几个iOS版本而进行部署
还不得不处理的有关的之中事宜
在这个过程中您可能会发现你自己
有时需要用特别的程序逻辑来检查程序是在
哪个版本的系统上运行
而另一个的最佳实做法是要确保
你的程序中包含基于不同系统版本的回退应变功能
这意味着绝对不要编写这样的代码
你先检查某个特定的版本
比如iOS 9然后才做某事
如果你做一个这样的检查
就肯定会给你的程序带来一个缺陷
因为当比如iOS 9.1
发布时就会使这一检查返回失败的结果
与此不同你应该知道iOS 9中的一切
都将会在未来的版本之中得以保存在iOS 9版本中实现的任何逻辑
都要在该版本及其后的版本中得以保留
甚至更好如果你是在用Swift来编程
你就可以利用的其新的带有＃号的新的表达法
把您所有的有关版本的代码放到一个代码块中
编译器就可以理解并辨明并最终告知你
你的程序是否对某个版本来讲编译器可以理解和解释的块
把所有特定版本的编码转换成无论你最终使用了哪一种技术
都要考虑清楚你是否需要一个Else子句
因为你不想犯一些
控键逻辑错误
而这又是应用程序系统的核心部分
但是倘若版本不符将导致必要的工作无法进展
同时还会在该版本中出现你意料不到的故障
这对于一般的应用程序的寿命周期而言是基本的最优方案
下面我们来说一下视图和视图控制器的最优方案
我第一个要提出的想法是关于
现代设备的布局的
大家都知到去年秋天我们推出了iPhone 6
和iPhone 6 Plus我敢保证你们也都知道
这次我们运用了全新的四维视图效果
在iOS设备中的手机应用软件
是没有这个视觉效果的
当你把这个维度效果添加到苹果手机上
而早前这项技术已运用到iPad上
可能手机软件也需要四维视图效果
就要运用矩阵在iPad Air 2上拆分视图时
它的矩阵是相当大的
因此 再建立布局就没有意义了
那是用于建立特殊维度的
你的视图控制器已经存在了
相反 作为基础需求布局比例早就完成
我们要专门避免在我们的视图和视图管理器的
布局中的硬编码值
如果我们只是想象一下视图简单地在视图里加入一个标签
如果只是简单把布局设成260点宽其余页边距为30点
那么早在几十年以前就拥有这个技术了
我们没有这么做是因为我们想要考虑
清楚维度比例
任何一个维度都要精确地计算
如果宽度计算了布局遭到破坏
还是无法正常运转是因为相位差没有意义了
所以如果把这个想成一个居中的标签
那么在维数增加的情况下是有意义的
我们还会提到这个例子 在我讲
关于“自动布局”最优方案时
我想提一下有关我们在iOS8中
提到的应用程序界面它能帮你成比例的布局
原因是一定程度上为了摒弃
屏幕旋转的想法
你们知道我们想让你们不再考虑屏幕旋转的问题
事实上我想要告诉你们的是
如果你们在设计app时 有这种想法
考虑横竖屏的问题
或者和设计师讨论这个问题
“横屏”“竖屏”都是他们想出来的
那你就大错特错了
我们只从尺寸的角度考虑问题
所以尺寸类别就是为了帮助我们
从尺寸的角度考虑问题进而成比例地布局
同时我们也意识到并接受
存在一些关于尺寸的阀值
原因是我们的基本用户界面改变了
如iPhone 4S中的设置选项
是一个很简易的单栏桌面视图
到了iPhone 5仍然是一个桌面视图 只是高了一点儿
同样iPhone6的也只是高了一点宽了一点
但基本上还是一个桌面视图
而iPhone6 Plus也只是更大了一些
可是在我们把它过渡到iPad时
我们跨越了一定的宽度阀值
因此这个视图完全变了样
现在变成了两栏的滚动内容
因此我们在这方面有所突破
实际上你会发现我们跨越了同样的阀值
在我们看iPhone6时
而且可能我得用脏话来形容这个阀值
竖屏模式尺寸类别也就是我们说的应用程序界面
对于我们苹果公司为了与你们的app衔接
就会跨过那些基本阀值
而这也是为了让你们能应对阀值并考虑
使用一个彻底改变的用户界面
来应对那些阀值
你将收到那些阈值改变的通知
因为规格类打包在对象中UITraitCollection
视图控制器可访问这些对象
所以这就是布局
我要传授给你的下一个最优方案是
在类中使用属性
作为UI视图标签的替代
所以我的意思是如果你正在使用带有标签的视图
或设置UI视图标签的应用程序接口且正在装载代码
我要鼓励你抛弃这些
原因就是
谢谢我真的很高兴有人为此而开心
所以我的意思是 原因很显然
它只是一个整数它与其他代码有潜在的冲突
也许它是你所写的其它代码
也许它是你团队中的新成员
他还不知道你认真管理的整数
也许它是你所使用的框架
你却看不到
无论这些冲突何时发生
你都接收不到编译器发出的有关警告信息
编译器无法推断出
你的整数管理
如果你既没有收到编译器的警告信息
也没有收到运行错误
无法说明带标签视图使用上的信息
你最多可以收到由未被认出的选择符导致的崩溃
你无法知道发生了什么
作为替代 声明类属性
这样你就可以与之后需要使用的那些视图产生实质性的联系
举一个简单的代码示例假设我写了一些代码
来生成图像视图然后以一千这个标签跟踪这段代码
因为我以我所有的聪明才智确信
别人绝不会用到一千这个标签
但是这之后我看了我的演讲我说不不
让我创建一个实际属性
将它声明为UI图像视图
然后我保持一个指向这个视图的引用
这个引用也有更好的类型信息
因为只带有标签的视图是类型UI视图
由于使用定义属性类型的UI图像视图
编译器事实上可以推断出我做了什么
并且在出现错误时帮我解决问题
请注意
视图和视图控制器的最优方案是
时间设定具备决定性意义
也就是说对于你们那些已经处于某种位置
可以做一些事情沿着系统动画去做
或者你有些工作想要做
而动画已经完成 所以你只能
乖乖地去猜到底那个动画要花多长时间
也许实施起来就像一个NSTimer定时器
老老实实地为你守时
好吧 你并不想那样做 因为
那样的话 App里会产生不确定性
尤其是关于可能性
动画的时间设置可能每一集都不同
你真的是不过时的反义词
如果你真的在做这些事相反
利用UI视图过渡协调器
在UI视图控制器的API去了解何为时间设定
你所拥有的动画有何时间设定
这能够让你
做你想要的任何动画 随便你想要的
视图控制器过渡
你当然知道何时那种过渡会完成
其中内置支持可撤销动画
和交互动画
如果你再想象导航轻扫手势一下
用户可以前后移动手掌来
改变速度、方向 甚至决定不要弹出视图控制器并全部取消
如果你使用过渡协调器 那么你准备好要处理所有这些
我们来谈一谈自动布局的最优方案
自动布局是一种工具我敢肯定大家很多人都知道 也喜欢用
它是一种内置的设计上是
要帮助你适应
并以你的代码实现不过时我们打算现在要谈一谈这方面
不过时是一个目标是自动布局工具的目标之一
但首先 我要简短说一下
有一些最优方案可以带来高性能给你的自动布局工具带来高性能
这就要有个开头管理你自己的约束从这里开始
用最高效的方式去管理效率越高越好
你做事的方式就是把所有约束想象出来想象到你的视图里
然后识别这些约束它们在视图的整个生命时间都可能变化
当识别到发生什么变化时有意义的就是
你就会能够做出有目标的变化
而不是改变事物不是改变不必改变的事物
因为当你保持一些事情恒定不变时
你就让自动布局引擎来最优化这些事情
这些不会变化的事情
因而自动布局工具不必进行若干计算而你的app布局也更快速
这一点尤其重要
如果你在卷轴期间重新布局的话
或者其他有些事情用户交互
部分用户交互 确定无疑的最优方案
而这是最糟实践而最优方案是
要避免最糟实践
把所有约束从视图中清除出去
这点不仅对于App执行自动布局引擎
的性能表现不好
在做尽可能多工作时
它同时还是潜在的兼容性问题
因为未来版本iOS可能有额外的约束
框架已经添加了这些额外的约束
你只要调用删除所有约束 就可以删除
你想要避免调用“删除所有约束”
在视图上尽量避免 越多越好
把这些捆绑在一起这种做法就是能够
高效地管理约束
通过用同样的策略明确地表达
我们刚刚谈过通过替换视图标签
让实际属性指出这些视图
或你可能需要的约束
在视图的整个生命期进行改变
那么让我们看一下这个非常简单的实例
是关于如何写入更新视图的约束码
而且这使最简单的事成为可能
这是在说嘿 我需要更新我的约束
让我只是将它们全部移除
然后我会重新计算 并把它们添加回去
我们并不想这么做
这不是最佳实用方法
最佳实用方法是如果我们有一个约束
如它需要被更改的话 可以移除它
仅需重建那个约束 然后把它添加回去
自动布局引擎再次识别到无法更改的约束
而且它可为我们优化
因此我为您们设计了下一组最佳方法
关于约束是围绕这一思想
就是当您描述约束时您有多具体
总之 您想要您的约束
尽可能准确描述您的布局
也就是说您要说出若要获取您想要的布局
需要做什么以及您不想要又该怎么做
换句话说您说的要详尽
而且关于这个特殊性问题
双方也存在潜在问题我将在此一一讲解
第一个就是执行问题
因此第一个就是添加双重约束到您的视图中
双重视图约束指的是当你删除它们时
布局将会完全相同
因为它们已经隐含在那里
而且当您使用它时它就会引发布局引擎
去完成更多的工作因为它正在为
这些约束解决问题因为它们在那里
但它不需要实际解决
可以在简单的布局中看到这一实例
我在超级视图中获取了一些视图
首先我会通过做一个纵轴描述这个布局
并且说 嘿在我的顶视图和底视图之间有些边界
我在对齐选项中赋值以指明
这两个视图的左侧也是对齐的
然后我说好的 让我们进入横向维度
我为顶视图提供了一些间距
因此现在我了解它的左边界是什么
然后我想 好的我已经指定好这个底视图
同时我也指定好底视图的边界
但是我刚才在按钮视图的左边界制造了
我并不需要的边界
已知顶部视图的边界
我也知道 按钮的左边界
并且顶部视图将对齐
如果我没有指定按钮视图的左边界
这个视图层将准确的成为相同的布局
所以外部约束只会导致
引擎做不需要它做的事
解决了这个问题之后我们可以更快
下一个问题是
过度设定约束将导致
的实际不是性能问题而是适用性问题
这对应用是个潜在的隐患
在约束不够灵活时就会发生适用性问题
如果我们考虑硬编码值我们知道我们不想这么做
让我们回到这个例子
回到视图中的标签
我们可以再一次描述它的约束条件为
距离左边有30点宽260点
但是这些硬编码值
让我们看起来死板和僵化
与作为面向未来的先进工具
的自动布局技术的整体思路相违背
我们真正想做的是用视图所在
本地坐标系中的位置和大小定义约束条件
所以应该使用父视图在本地坐标系的位置和大小
来定义视图边界的最小约束条件
所以来讨论定义约束条件的另一面
设定不足的约束
你也不会想这么做的肯定想已经设定好了所有你需要的约束
考虑下 会发生什么？
如果设定不足约束 我们会引入歧义
让我们回到将要设定的约束
如果我设定这个标签的左右边界
然后再设定一个上边界有些东西不见了
非常明显
我们没有设定底部边界 原本应该设的
因此我们引入了歧义
这意味着我的视图
在不同时间运行程序时将以不同的方式出现
假设这是一个表单元
当我调用刷新数据时
它变了 我很迷惑
它可能随IOS不同版本发生变化
或者因为不同宇宙射线击中手机设备
谁知道呢？
我们不想要未定义的行为
我们不想要我们的视图看起来这样
我们想要它按照我们设定的高度
所以请确定你完全定义了你的约束条件
我想以练习的形式给你一个
调试自动布局代码的最优方案
你可以使用布局歧义检测的UI视图
如果你想在调试时找出
视图未能正确布局的原因
调用布局歧义检测
它帮你找到视图中存在的歧义
你还可以在窗口调用这个方法
它会告诉你视图树上的任意视图是否有歧义布局
这非常方便
你可以调用自动布局跟踪的UI视图
得到一张包含视图树所有约束的图片
使用那些约束去找到歧义
真正有趣的最优方案是
用正确方式的去使用这些方法把它们放在单元实验中
你可以想象在你的应用中的每个视图树每个基本的活动
都可以调用布局歧义检测窗口
如果它有布局歧义
你可以调用UI视图自动布局
跟踪找到存在歧义的约束条件
将它们打包到报告
这既能让你知道这个实验中
什么时候存在歧义
也能为后来学习并发现问题的人提供调试信息
这就是自动布局apps
最优方案
好的
我将转到我们最后一个最优方案的话题
关于表视图和聚合视图
我知道这对几乎所有IOS应用都重要
当然它对我也很重要
最优方案的第一步是使用自适应大小单元格
当你需要单元格中的内容可以变化的时候
或者需要一个随内容变化大小的单元格
我相信你们大多数人在开发生涯中都
会遇到这样的场景
在已有内容的基础表视图中
你突然意识到 哦...
根据不同的内容每一个单元格都需要不同的高度
我不能让每个单元格只有一个高度
iOS8中引入的自适应大小单元格
将会使这些转换工作变得简单
自适应大小单元格在表视图中可以根据内容变化高度
现在我将开始讲解这个最优方案
告诉你如何在你的应用中使用它
它就像我们刚才在
自动布局中说到的那样启动
需要完全设定你的约束
如果你想使用所有我讲过的技巧
考虑到自动布局系统
将宽度作为输入
因为表视图是固定宽度
所以你的单元格将会是这个宽度
随后自动布局系统会输出单元格高度值
如果未完全设定约束条件
这里会存在歧义
就不会得到你想要的那个高度
如果我们使用表视图单元格的简单例子
它真的很简单
我们只需要设定我们内容的边界
在这个例子中只是个标签
它具有固定的内容尺寸
所以当我们设定它的边界时
完全定义了这个单元格的约束条件
我们将得到我们要的尺寸
你可能还有一些更复杂的单元格
我认为这是一个简单的例子
然而有时你会发现 嘿
我已经设定了我所有的约束条件
但是我没有得到我想要的高度
这里有个技巧
关于增加内容视图的约束条件的技巧
这个约束条件用来设定内容视图的高度
实际上你正在使用
内容视图的高度约束条件
然后你就能以内容的形式设定约束条件了
这里我要说 嘿内容视图的高度应当等于
标签高度加上我的顶和按钮的边界
在这里 这是重复工作
我不需要这样做
我会得到同样的东西
但是如果你的应用中你没得到你想要的结果
并且你在视图上加了一个高度约束
导致单元格高度变化
这表明你的约束条件
不符合你所需效果的设计逻辑
这有个伟大的工具你可以用它来找到错误
现在 你可以考虑
如何让单元格变化以动画的方式呈现你知道
使用自适应大小单元格和自动布局
现在你可以想象你如果有一些单元格
需要根据内容变化你可能采取非常原始的方法
更新你的模型然后调用刷新数据
如果你这样做 单元格会变成这样
它会出现在表格的新位置
确实达到了目的 但是这不符合
你想要的用户体验
它看上去不那么精美和平滑
你想要的是单元格高度的变化的动画效果
单元格周围的东西应该以动画的方式
平滑的移动到它们的位置
必须让用户能理解发生了什么
让我们演示下如何做
谢天谢地 它非常简单
任何时候你想要一个类变换
在表视图中以动画显示
可用表视图API来开始更新和更新块
第一步是调用表视图开始更新
不管你是否使用自适应大小单元格都要做这一步
这是在表视图中实现类变换动画效果的通用步骤
然后更新你的模型
很简单
第三步如果你在改变一个屏幕单元格的高度
你可以点击这个单元格
触发索引路径行的表视图单元格
然后改变单元格的内容
需要的话还可以改变约束条件
有些时候人们认为需要
调用重新加载索引路径行
不需要这样做
它不会给你良好的体验
实际上你只需要点击单元格
并改变它的内容
做完这些后
点表视图结束更新
表视图此时重新计算所有行的类
包括调用所有的在屏幕上的行
以从自动布局信息获得它们高度
如你所见 所有的东西以动画效果呈现
开始更新 结束更新是关键
最后一个我想分享给你的最优方案是
自定义聚合视图布局
自己失效 然后非常快的重新绘制
我知道很多人
会写自定义聚合视图布局
在用户滚动的时候 对视图本身
做做这个 改改那个
它们很难跟上布局的改变
恩 我将告诉你图形应用如何
完成这个工作 然后你就能把这项技术
应用到你的自定义布局中了
图形布局有这样的头部
为聚合视图的辅助视图
当用户滚屏 甚至单元格移动时
头视图留在屏幕原来的位置上
这是我所知道的很多人
在聚合视图中完成上述工作的基本思路
图形布局可以
UI CollectionView无效上下文实例做到这个
UI CollectionView中有这个API
这个步骤非常简单
第一步非常明显
坐标改变后图片视图布局重新绘制
所以用户滚屏时
图形布局重新绘制
就变得轻而易举这是简单的部分
问题是我们如何让它变快
答案是图形布局建立目标视图重绘过程
让聚合视图知道只有头视图
会进行重绘
而其它的单元格不会重绘
这让聚合视图能尽快的完成整个操作
它如此快 这个操作只在
帧速率很快的时候重复
尽管每一帧布局都会重绘
所以如果你在使用自定义布局时
有性能要求
你可以在布局时使用这项技术
总的来说
UI CollectionView无效上下文是
克服性能问题的关键
所以我建议你用用这个API
好了 我已经讲了一整套最优方案
我们讨论了性能以及如何让你的应用启动时快速响应
在它的生命周期内如何
让你的自动布局尽可能的快
我们讨论了用户体验是你的最大目标
跨越无数不同设备实现
表视图的动画效果
我还分享了如何编写面向未来版本
代码的技巧
现在我建议你以这些话为参考
你可以回头看看这些视频在你构建你未来的应用时
这里有非常多的最优方案你可以用它们
作为进入相关文档的跳板
查找我提到的API的相关文档
你将能将这些最优方案部署到你未来的应用中
谢谢
很高兴在WWDC与你们分享
希望今天下午你们能得到充分休息