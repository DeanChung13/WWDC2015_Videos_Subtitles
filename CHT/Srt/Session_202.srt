00:00:20.087 --> 00:00:23.223 
Cocoa最新內容

00:00:23.290 --> 00:00:23.957 
下午好

00:00:24.358 --> 00:00:26.059 
歡迎參加《Cocoa最新內容》講座

00:00:30.464 --> 00:00:31.832 
我是阿里•厄澤爾

00:00:32.299 --> 00:00:36.370 
我是來介紹
今年Cocoa新增了什麼內容

00:00:36.570 --> 00:00:37.337 
主要在三方面：

00:00:37.404 --> 00:00:40.707 
Swiftificaiton
AppKit和Foundation

00:00:40.908 --> 00:00:43.243 
我們有許多學習內容
大家一起來深入研究吧

00:00:45.179 --> 00:00:48.549 
Swiftification 是指
剛完成的API增強版

00:00:48.615 --> 00:00:52.853 
在多個框架之間
支持Swift語言

00:00:53.153 --> 00:00:56.590 
這些改進同時完善了
Objective-C API功能

00:00:58.692 --> 00:01:00.494 
要知道 Swift語言
的功能是

00:01:00.561 --> 00:01:02.429 
更準確表達API特性

00:01:02.829 --> 00:01:05.299 
例如可以
聲明這是個數組

00:01:05.364 --> 00:01:07.134 
子視圖屬性
是NSView數組

00:01:07.201 --> 00:01:09.169 
但不僅僅是個數組

00:01:09.736 --> 00:01:12.472 
還可以聲明System Font
Of Size方法

00:01:12.539 --> 00:01:15.309 
返回到NSFont
而且永遠不會返回空

00:01:16.043 --> 00:01:18.345 
例如在Image For
Resource方法中　

00:01:18.412 --> 00:01:20.914 
NSBundle可以返回零值空
因爲它被聲明

00:01:20.981 --> 00:01:22.249 
作爲可選的NSImage

00:01:24.518 --> 00:01:27.020 
我們在Objective-C
啓動這些功能

00:01:27.087 --> 00:01:28.455 
具備通用列的爲空性

00:01:28.922 --> 00:01:31.491 
我會簡要介紹
這兩方面內容

00:01:31.758 --> 00:01:33.961 
接着再做
幾處調整

00:01:34.194 --> 00:01:37.231 
讓我們的Objective-C和
Swift API效果更好

00:01:38.565 --> 00:01:41.335 
我們將這些用於
許多框架的API中

00:01:41.401 --> 00:01:44.605 
不僅是AppKit
和Foundation

00:01:45.072 --> 00:01:48.041 
這樣不僅可以更好地
接觸到Swift語言中的API

00:01:48.108 --> 00:01:51.912 
而且會讓
API更爲清晰

00:01:52.112 --> 00:01:54.114 
還能提供編譯時間
類型檢查功能

00:01:54.181 --> 00:01:55.649 
這一點當然
很重要

00:01:57.551 --> 00:02:00.888 
爲空性是指
值能否爲零

00:02:02.890 --> 00:02:06.093 
若是使用Swift語言
X v10或iOS 8 SDK

00:02:06.159 --> 00:02:09.930 
大家已經瞭解Swift API
具有適當的爲空性

00:02:09.997 --> 00:02:11.431 
和可選的聲明
內容

00:02:11.698 --> 00:02:15.169 
我們已經管理過
手工端數據

00:02:15.235 --> 00:02:16.370 
以及端文件這方面的內容

00:02:16.436 --> 00:02:19.773 
在X v11和iOS 9中我們將這
種能力賦予了Objective-C

00:02:20.040 --> 00:02:23.010 
並有了若干新的關鍵詞這些都加在了O
bjective-C上

00:02:23.443 --> 00:02:27.681 
非零表示永遠不爲零值
可爲零表示可以爲零值

00:02:28.182 --> 00:02:31.652 
可重置零表示
屬性可以設爲零值

00:02:31.718 --> 00:02:33.187 
不過不會返回歸零值

00:02:33.320 --> 00:02:35.956 
馬上會給出
一個例子

00:02:36.023 --> 00:02:38.625 
最後一項也很重要就
是Null Unspecified

00:02:38.692 --> 00:02:39.826 
也就是未指定的意思

00:02:40.194 --> 00:02:43.063 
這個用於
不支持的內容

00:02:43.130 --> 00:02:45.065 
或未經審查的內容

00:02:47.434 --> 00:02:51.471 
由於API大部分
是非零值的狀態

00:02:51.538 --> 00:02:52.906 
我們還有這樣
兩種聲明：

00:02:52.973 --> 00:02:55.475 
Assume Nonnull
Begin and End

00:02:55.542 --> 00:02:57.377 
假設首尾爲零
中間即爲我們的頁眉文件

00:02:57.444 --> 00:02:59.446 
這樣 非零值聲明
就沒有必要

00:02:59.513 --> 00:03:00.547 
繼續存在了

00:03:00.614 --> 00:03:03.150 
非零就沒必要了

00:03:03.217 --> 00:03:05.419 
我們在API上
還有另外的聲明

00:03:05.752 --> 00:03:08.188 
我們建議你在頁眉文件中
這樣使用

00:03:08.255 --> 00:03:10.090 
如果你有很多
自己的頁眉文件

00:03:11.992 --> 00:03:15.262 
來看部分實例
看看這會怎樣影響API

00:03:15.762 --> 00:03:18.265 
你會看到
NSColorWell的顏色屬性

00:03:18.699 --> 00:03:22.102 
我們沒有發佈任何聲明
那它就該是非零值

00:03:22.503 --> 00:03:25.539 
在Swift語言中
作爲非可選值

00:03:25.606 --> 00:03:26.507 
色彩屬性

00:03:27.040 --> 00:03:29.276 
另外一方面
NSImageView的圖像屬性

00:03:29.343 --> 00:03:33.747 
是可以爲零值
也就是說可以設爲零值

00:03:33.814 --> 00:03:36.383 
在Swift語言中
可以作爲可選值

00:03:36.783 --> 00:03:39.553 
最後聲明的是
NSMenu的字體屬性

00:03:39.620 --> 00:03:42.556 
是可重置零
這就會成爲

00:03:42.623 --> 00:03:44.224 
隱式解析
可選值

00:03:44.925 --> 00:03:48.095 
在本例中 這說明
我們可以將值設爲零

00:03:48.595 --> 00:03:50.030 
不過它永遠不會返回零值歸零

00:03:50.230 --> 00:03:53.700 
如果從來都不把它設爲零
那麼NSMenu就會

00:03:53.767 --> 00:03:56.737 
恢復系統已有的
默認字體

00:03:56.803 --> 00:03:58.672 
因此 永遠不會返回零值歸零

00:04:00.407 --> 00:04:03.010 
存在爲空性 你可能會看到
一些建造時間警告

00:04:03.744 --> 00:04:04.878 
我來給大家看一個例子

00:04:05.179 --> 00:04:07.848 
如果你有這樣的代碼
設置顏色屬性

00:04:07.915 --> 00:04:11.151 
ColorWell爲零
編譯器現在就會給出警告

00:04:11.451 --> 00:04:13.153 
因爲我們做過聲明
這個值是非零

00:04:13.720 --> 00:04:16.790 
這非常好 因爲就會成爲
如果你有這個代碼

00:04:16.857 --> 00:04:19.493 
並且經過運行
就應該提出一個

00:04:19.560 --> 00:04:20.459 
參數斷言纔對

00:04:20.861 --> 00:04:22.863 
這種情況下
你會收到有關

00:04:22.930 --> 00:04:23.830 
編譯器的警告

00:04:23.897 --> 00:04:24.565 
非常好

00:04:25.999 --> 00:04:31.071 
你也許知道 一般而言
在我們的API中

00:04:31.138 --> 00:04:32.306 
零不是有效目標值

00:04:32.506 --> 00:04:36.076 
NSString NSArray
NSDictionary等等很容易

00:04:36.143 --> 00:04:40.848 
表達空值
接受或歸零的API

00:04:40.914 --> 00:04:43.951 
應該把零作爲
特殊情況

00:04:44.017 --> 00:04:45.219 
記錄下來

00:04:45.586 --> 00:04:47.721 
我從API中給出
幾個例子來

00:04:48.322 --> 00:04:51.491 
如果將NSTextView目標
背景色設爲零

00:04:51.625 --> 00:04:53.126 
表示不得有
背景顏色

00:04:53.927 --> 00:04:55.429 
在許多API的零區域設置

00:04:55.495 --> 00:04:58.632 
都表示
未經區域設置處理

00:04:58.699 --> 00:04:59.900 
因此 可以確定一個區域設置

00:04:59.967 --> 00:05:02.703 
但是如果確定爲零
則表示未經區域設置處理

00:05:05.272 --> 00:05:07.341 
再來談談泛型

00:05:08.542 --> 00:05:12.312 
泛型正如聽上去那樣
是個輕量級的

00:05:12.379 --> 00:05:16.316 
參數化類型我們將之加到Object
ive-C上

00:05:16.383 --> 00:05:19.720 
這對具體元素種類集合
效果很好

00:05:20.687 --> 00:05:23.123 
這裏是個NSSearchField
方面的例子

00:05:23.190 --> 00:05:26.059 
NSSearchField的
Recent Search屬性

00:05:26.126 --> 00:05:27.794 
是這樣聲明的
X v10

00:05:27.861 --> 00:05:31.598 
Recent Searches這一
名稱並不十分清晰

00:05:31.665 --> 00:05:33.066 
其中包括什麼內容？

00:05:33.133 --> 00:05:34.635 
字符串？URL?

00:05:34.701 --> 00:05:35.903 
搜索目標是什麼？

00:05:36.370 --> 00:05:39.907 
通過X v11 SDK
我們可以進行澄清

00:05:39.973 --> 00:05:42.009 
這裏是NSString數組

00:05:42.376 --> 00:05:45.512 
Swift聲明就是
從任何目標數組

00:05:45.779 --> 00:05:47.281 
到任何字符串數組

00:05:49.650 --> 00:05:53.187 
我們採取的方法就是從Foundat
ion中取得NSArray

00:05:53.520 --> 00:05:56.190 
在加上Object Type數據
等等之類

00:05:56.256 --> 00:05:59.393 
我們把這個目標類型適用於
所有API

00:05:59.893 --> 00:06:02.763 
適當的API
以往都是獲取或恢復ID

00:06:02.829 --> 00:06:06.133 
諸如索引目標
包括目標等等

00:06:06.533 --> 00:06:09.903 
還有許多其他的API
這都適用於NSArray

00:06:10.237 --> 00:06:13.874 
有了這樣的代碼
連同Recent Searches

00:06:14.474 --> 00:06:15.809 
可以說你是有
這樣的代碼

00:06:16.276 --> 00:06:19.012 
Recent Searches包括
目標 部分URL

00:06:19.947 --> 00:06:21.181 
我們在傳遞NSURL

00:06:21.481 --> 00:06:24.551 
編譯器現在就會給出警告
你在傳遞URL

00:06:25.118 --> 00:06:27.321 
這種方式可能會出現
字符串數組

00:06:27.688 --> 00:06:30.190 
這裏非常棒的是
這個代碼永遠不會出問題

00:06:30.257 --> 00:06:32.626 
或是出現崩潰
因爲URL從來不會

00:06:32.693 --> 00:06:33.861 
在之前被發現

00:06:33.927 --> 00:06:36.496 
編譯器在告訴你
編碼中存在潛在的bug

00:06:36.563 --> 00:06:39.233 
我們在Foundation中增加了
泛型支持

00:06:39.299 --> 00:06:40.868 
不僅是對NSArray

00:06:40.934 --> 00:06:43.937 
而是對所有其他集合
NSEnumerator也包括在內

00:06:44.004 --> 00:06:48.108 
嚴格來講 當然
甚至不止是集合

00:06:48.542 --> 00:06:50.477 
將之適用於
非集合也同樣可行

00:06:51.078 --> 00:06:55.249 
現在連同泛型一起
也可以通過不同的聲明

00:06:55.315 --> 00:06:57.451 
使用這些
按照自己的分類

00:06:57.885 --> 00:07:00.854 
如果你拿到Recent
Searches的結果 並將之

00:07:00.921 --> 00:07:04.691 
賦予自己的屬性
那就可以繼續 並且聲明

00:07:04.758 --> 00:07:07.861 
這是NSArray of
NSString 可以將該類型

00:07:07.961 --> 00:07:09.530 
通過自己的代碼
進行傳播

00:07:10.664 --> 00:07:12.065 
你可以聲明
自己的API屬性

00:07:12.132 --> 00:07:14.401 
這裏是文件NSS數組

00:07:14.468 --> 00:07:15.235 
是什麼？

00:07:15.302 --> 00:07:16.403 
字符串還是URL?

00:07:16.904 --> 00:07:17.938 
可以更明確些

00:07:18.605 --> 00:07:21.275 
將通用列適用於
自定義集合

00:07:21.341 --> 00:07:23.610 
如果有任何這樣的集合
甚至是在基礎集合中

00:07:23.677 --> 00:07:24.811 
有你的自定義類別

00:07:25.546 --> 00:07:28.215 
例如
NSArray的類別

00:07:29.082 --> 00:07:32.219 
你可以直接進入添加
就在自己的代碼中即可

00:07:32.286 --> 00:07:34.721 
這些泛型通用列
也同樣適用於類別

00:07:37.991 --> 00:07:43.163 
現在又有一個功能
加在了Objective-C上

00:07:43.630 --> 00:07:46.200 
我們來講解一下
爲什麼需要這麼做

00:07:46.667 --> 00:07:48.235 
這就是子視圖
聲明在

00:07:48.302 --> 00:07:49.837 
X v10中的模樣

00:07:49.903 --> 00:07:54.775 
這是我們第一次嘗試
應用泛型

00:07:55.442 --> 00:07:58.145 
子視圖改變爲
NSArray of NSView

00:07:58.812 --> 00:08:02.482 
那麼代碼就是這樣
即把數組之外的元素

00:08:02.549 --> 00:08:04.117 
賦值給NSButton

00:08:04.952 --> 00:08:07.221 
這就輪到編譯器
着急了

00:08:07.754 --> 00:08:10.991 
編譯器總是替我們擔心
很是操心

00:08:11.458 --> 00:08:12.492 
它會發出警告

00:08:12.960 --> 00:08:15.562 
爲什麼？因爲我們在把外明顯
聲明屬於NSView的內容

00:08:15.629 --> 00:08:18.632 
賦值給了
NSView的子類

00:08:18.832 --> 00:08:20.801 
難怪編輯器會
有所擔心了

00:08:21.335 --> 00:08:23.670 
但是這類代碼
我們使用得很多

00:08:23.737 --> 00:08:25.038 
而且還常常有效

00:08:25.639 --> 00:08:28.575 
因此 添加了這類關鍵字
並且將

00:08:28.842 --> 00:08:33.480 
子視圖屬性的聲明改爲這類NSArr
ay of NSViews的

00:08:33.914 --> 00:08:35.148 
得出的就是...

00:08:39.886 --> 00:08:40.554 
謝謝

00:08:41.621 --> 00:08:44.858 
...感謝大家沒注意
這邊欄目下的內容

00:08:45.626 --> 00:08:48.028 
這是說 調用者
可以訪問

00:08:48.095 --> 00:08:50.764 
數組元素
如具體類的例子

00:08:50.831 --> 00:08:54.101 
或者是說
子類的例子也可

00:08:54.835 --> 00:08:56.937 
現在來看 效果可以

00:08:57.604 --> 00:09:02.042 
注意
這類編譯時功能

00:09:02.109 --> 00:09:04.211 
和我在這裏談到的
大多數其他內容一樣

00:09:04.678 --> 00:09:07.347 
並沒有改變
運行時間代碼

00:09:08.382 --> 00:09:11.185 
例如 並未檢查
運行時間類型

00:09:11.585 --> 00:09:13.987 
有些時候 我們希望
調用者可以考慮一下

00:09:14.054 --> 00:09:16.924 
元素的情況
再去訪問它們

00:09:17.391 --> 00:09:20.460 
我們將在API中
做少量使用

00:09:20.527 --> 00:09:22.162 
並推薦大家
也這麼做

00:09:22.396 --> 00:09:24.398 
當調用者可以安全使用時
它們就應該能用了

00:09:24.464 --> 00:09:25.566 
假設一下

00:09:25.899 --> 00:09:27.434 
如果你希望調用者
審慎行事

00:09:27.501 --> 00:09:29.803 
或是進行運行時間查詢
那就別這麼用

00:09:30.237 --> 00:09:31.872 
舉例來說
NSImage的

00:09:31.939 --> 00:09:33.974 
Representations法
就是這樣

00:09:34.041 --> 00:09:35.876 
它返還成NSImage
數組表示法

00:09:36.076 --> 00:09:40.080 
它經常會被細分成子類
而且幾乎總是如此

00:09:40.547 --> 00:09:42.082 
不過我們不會
在這裏用到這類

00:09:42.149 --> 00:09:44.618 
因爲這類表示法
並非總是能夠

00:09:44.918 --> 00:09:47.621 
具有可預見性
實際上

00:09:47.688 --> 00:09:50.324 
可能會在應用運行時間內
在OS發佈期間

00:09:50.390 --> 00:09:52.159 
發生改變

00:09:52.226 --> 00:09:54.494 
最好是讓調用者
在這裏多加小心

00:09:54.561 --> 00:09:55.863 
進行運行時間檢查

00:09:59.166 --> 00:10:00.968 
我們在來談談
錯誤處理

00:10:01.034 --> 00:10:03.837 
昨天大家聽到了
Swift 2具備神奇的

00:10:03.904 --> 00:10:06.340 
錯誤處理功能

00:10:08.242 --> 00:10:11.345 
對於這種在NSData上
寫入URL選項的錯誤方法

00:10:11.445 --> 00:10:15.349 
具體意思就是
在Swift裏的樣子

00:10:15.415 --> 00:10:18.218 
Boolean迴歸值不見了
現在非常明顯

00:10:18.552 --> 00:10:21.421 
錯誤可以參考
NSError參數

00:10:21.722 --> 00:10:24.525 
也不見了 因爲是被
拋出語句所捕捉

00:10:24.958 --> 00:10:27.861 
這類代碼
就是需要處理的

00:10:28.495 --> 00:10:29.997 
正如你可以在
捕捉語句中所見

00:10:30.063 --> 00:10:32.933 
可以捕捉到錯誤
如果是可以自動

00:10:32.999 --> 00:10:34.835 
被捕獲
或是由你來發出聲明

00:10:34.902 --> 00:10:36.737 
你可以聲明不同的
捕捉語句

00:10:36.803 --> 00:10:38.005 
這也完全可以

00:10:38.071 --> 00:10:39.806 
非常好 直截了當

00:10:39.873 --> 00:10:41.875 
現在還有一點

00:10:42.042 --> 00:10:45.145 
注意這裏的所有術語
拋出 異常捕捉

00:10:45.212 --> 00:10:47.447 
等等 無外乎
就是這些

00:10:47.514 --> 00:10:48.916 
對Objective-C而言

00:10:48.982 --> 00:10:50.551 
我們也不會
特殊對待

00:10:50.617 --> 00:10:53.720 
我們實際是在返回錯誤
通過這樣的堆棧

00:10:53.787 --> 00:10:58.125 
妥善解決問題
就這麼處理NSErrors

00:10:58.825 --> 00:11:01.361 
實際上 NSError指南
還適用於

00:11:01.461 --> 00:11:03.697 
Swift錯誤處理

00:11:03.797 --> 00:11:08.001 
使用NSErrors和Swift
錯誤處理應對運行時間問題

00:11:08.068 --> 00:11:10.604 
準備給用戶展示的錯誤
或是需要處理

00:11:10.671 --> 00:11:12.940 
運行時間 如文件未能找到
等等

00:11:13.006 --> 00:11:16.510 
我們繼續使用例外
或Swift斷言

00:11:16.577 --> 00:11:19.513 
處理編程問題
如界外索引數組

00:11:20.314 --> 00:11:22.683 
當然最後一類
錯誤是

00:11:22.749 --> 00:11:24.751 
不可能被
捕捉到的

00:11:25.752 --> 00:11:28.388 
還有一個Swiftificatio
n項叫做清理

00:11:29.189 --> 00:11:32.326 
你們可能是該走了
我們還有許多名稱可以列舉

00:11:32.392 --> 00:11:35.829 
從很久以前開始
我們用公共後綴

00:11:35.896 --> 00:11:38.498 
而不是公共前綴
在部分情況中

00:11:38.565 --> 00:11:40.501 
我們做了修改 不是全部
有了公共前綴

00:11:40.567 --> 00:11:41.702 
也就是說

00:11:41.768 --> 00:11:43.370 
在Swift語言中
會有更好的名稱

00:11:43.437 --> 00:11:45.405 
不是按照點左邊文本對齊
而是改成了

00:11:45.472 --> 00:11:46.807 
dot.left格式

00:11:46.874 --> 00:11:48.475 
這樣的例子
還有許多

00:11:48.709 --> 00:11:51.378 
注意很多情況下
我們實際上不支持

00:11:51.445 --> 00:11:54.414 
舊名稱 因此你的源文件
將會繼續編譯

00:11:54.481 --> 00:11:56.884 
但是可以改爲新名稱
重寫編碼即可

00:11:59.019 --> 00:12:00.621 
這類還有很多

00:12:01.021 --> 00:12:03.156 
這樣我們就可以
來談AppKit

00:12:04.291 --> 00:12:06.193 
有許多AppKit方面的話題
我都很喜歡

00:12:06.260 --> 00:12:08.028 
來聊聊
先來談一部分

00:12:08.095 --> 00:12:13.600 
說明一點：從這裏
我會更多通過Swift

00:12:13.667 --> 00:12:15.602 
介紹API
和代碼樣本

00:12:16.203 --> 00:12:18.639 
如果你對Swift
還不是很習慣

00:12:19.072 --> 00:12:21.408 
也不必擔心
因爲我提到的代碼

00:12:21.475 --> 00:12:22.643 
不會那麼難

00:12:22.743 --> 00:12:23.911 
畢竟 我不過是個經理

00:12:24.478 --> 00:12:25.612 
需要注意的是...

00:12:26.180 --> 00:12:27.314 
這一點非常重要

00:12:27.381 --> 00:12:31.451 
這些API在Objective-C
和Swift中均可得到

00:12:31.552 --> 00:12:33.253 
那麼 我們就不是隻給
大家展示僅適用於

00:12:33.320 --> 00:12:35.322 
Objective-C或Swift
的東西

00:12:35.389 --> 00:12:37.090 
無論是使用哪種語言
均可以適用

00:12:38.492 --> 00:12:43.630 
要知道 新的Force Touch
觸摸板使用壓力感應的同時

00:12:43.697 --> 00:12:46.700 
也用到了
觸覺反饋

00:12:46.800 --> 00:12:49.636 
這就爲更多有趣應用
帶來了可能

00:12:49.703 --> 00:12:51.471 
來看部分實例

00:12:53.006 --> 00:12:56.877 
例如這裏在部分文字上使用Force
Click

00:12:56.944 --> 00:12:59.713 
可以實現查找
或是自動生成

00:12:59.780 --> 00:13:00.881 
日曆活動

00:13:01.615 --> 00:13:03.617 
這種情況下
通過按壓

00:13:03.684 --> 00:13:05.752 
快進按鈕
就可以讓影片

00:13:05.819 --> 00:13:07.354 
快進速度加快

00:13:08.488 --> 00:13:12.993 
這裏通過劃細線或粗線
進行點壓

00:13:13.260 --> 00:13:16.029 
就可以簽上自己的名字
或是在標記中寫寫畫畫

00:13:17.331 --> 00:13:20.934 
最後 在這種情況下
把目標移到程序

00:13:21.001 --> 00:13:23.937 
比如Xcode的界面
把開發程序或繪圖程序

00:13:24.304 --> 00:13:27.574 
作爲對齊目標
就會得到觸感反饋

00:13:29.243 --> 00:13:32.613 
現在還有部分Force Touch
API在 X v10.3中出現

00:13:32.679 --> 00:13:34.781 
有人可能見過

00:13:35.148 --> 00:13:37.384 
首先 用加速器
控制API

00:13:38.252 --> 00:13:40.888 
這些API詮釋不同壓力
可以用於創建

00:13:40.954 --> 00:13:43.557 
類似快進按鈕
或是在

00:13:43.624 --> 00:13:45.025 
類似地圖應用中
生成放大按鈕

00:13:45.092 --> 00:13:48.629 
還可以在NSButton上在NS
SegmentedControl裏

00:13:48.695 --> 00:13:50.063 
設置加速器控制

00:13:50.230 --> 00:13:51.665 
如果希望再
玩的高深一些

00:13:51.732 --> 00:13:55.235 
我們可以提供一個事件
新的壓力事件類型

00:13:55.302 --> 00:13:57.704 
與 NSResponder
和手勢識別等

00:13:57.971 --> 00:13:59.706 
對應方式相匹配
也同樣可行

00:13:59.773 --> 00:14:01.842 
通過事件實現
Pressure Change

00:14:01.909 --> 00:14:03.410 
可以自己來詮釋
壓力事件

00:14:04.378 --> 00:14:08.215 
在X v11當中
我們引入了諸多新類型

00:14:08.282 --> 00:14:10.117 
一個是壓力配置
分類

00:14:10.517 --> 00:14:12.452 
你來設置壓力配置
通過視圖

00:14:12.519 --> 00:14:13.754 
或手勢識別

00:14:14.021 --> 00:14:16.390 
表明觸摸板
該如何反應

00:14:16.924 --> 00:14:18.926 
一般來說
爲用戶提供的觸感反饋

00:14:18.992 --> 00:14:20.227 
將取決於

00:14:20.294 --> 00:14:22.462 
所確定的
壓力配置

00:14:22.963 --> 00:14:26.033 
還有另外兩個分類
觸感反饋管理器

00:14:26.099 --> 00:14:28.335 
和對齊反饋過濾器
允許你對此類

00:14:28.402 --> 00:14:31.038 
提供給用戶的觸感反饋
進行定製化處理

00:14:34.074 --> 00:14:38.345 
很多人可能都用過
彈簧載荷

00:14:38.745 --> 00:14:41.949 
就是說拖動一下
並且在目標附近

00:14:42.015 --> 00:14:44.651 
圍繞時 目標會
向你開放

00:14:44.818 --> 00:14:46.220 
在Finder中可以這麼使用

00:14:46.687 --> 00:14:47.988 
通過Force Click

00:14:48.055 --> 00:14:51.124 
可以肯定的是
只需用力點擊目標

00:14:51.191 --> 00:14:54.361 
彈簧載荷就會
立即啓動

00:14:55.128 --> 00:14:59.466 
我們還有新的API
讓彈簧載荷更加便捷

00:14:59.533 --> 00:15:02.703 
就是個簡單的Boolean屬性
NSButton和

00:15:02.769 --> 00:15:05.372 
NSSegmentedContro
l就啓用了彈簧載荷

00:15:05.439 --> 00:15:08.408 
可以感知附近的動作或是Force
Click給出的指示

00:15:08.475 --> 00:15:09.576 
非常直觀

00:15:09.943 --> 00:15:14.381 
如果這並不能完全滿足需求
我們還有新的協議

00:15:14.448 --> 00:15:17.651 
NSSpringLoadingDe
stination通過它即可

00:15:17.718 --> 00:15:19.520 
在任意目標上
實現彈簧載荷

00:15:20.020 --> 00:15:22.322 
例如 Finder的那個例子
就很適合這裏

00:15:24.291 --> 00:15:26.827 
手指滑動即可刪除
大家對這都很熟悉

00:15:26.894 --> 00:15:29.663 
昨天在主旨演講中
就見過類似的東西

00:15:29.963 --> 00:15:33.233 
iOS裏這種東西也很常見
可以在桌面視圖

00:15:33.300 --> 00:15:37.971 
例如郵箱信息上
左右滑動

00:15:38.038 --> 00:15:40.908 
標識信息是否讀過
或是否刪除等等

00:15:40.974 --> 00:15:43.477 
我們現在也有這樣的API
也是在EI Capitan中

00:15:43.544 --> 00:15:45.312 
是NSTableView的委託方式

00:15:45.379 --> 00:15:47.047 
Row Action是
用於Row

00:15:47.548 --> 00:15:50.684 
只需返回到
NSTableView行處理數組

00:15:51.051 --> 00:15:55.422 
本類的例子
只是聲明這些項和行

00:15:55.489 --> 00:15:59.193 
應該怎樣拖動
當用戶選擇

00:15:59.259 --> 00:16:01.662 
當用戶選擇通過
代碼塊處理時

00:16:01.762 --> 00:16:02.696 
最後是代碼塊

00:16:04.498 --> 00:16:05.832 
這些話題
簡單講一下即可

00:16:06.233 --> 00:16:08.969 
有個講座
《採用觸控板新功能》

00:16:09.036 --> 00:16:11.772 
是週四上午十點
其中會介紹

00:16:11.839 --> 00:16:14.408 
這類話題的
更多詳細內容

00:16:15.576 --> 00:16:18.178 
全屏部分
昨天已經介紹過了

00:16:18.312 --> 00:16:21.548 
全屏可以將分散注意
的因素去除 便於集中精力

00:16:21.615 --> 00:16:24.218 
處理單項任務
就像現在這樣

00:16:24.484 --> 00:16:28.956 
通過在全屏分割視圖
可以關注一個任務

00:16:29.022 --> 00:16:30.791 
但可以打開
其他窗口

00:16:30.858 --> 00:16:33.961 
例如 你在使用
Xcode 再啓用Safari

00:16:34.027 --> 00:16:36.697 
查詢部分文檔
或其他論壇

00:16:36.997 --> 00:16:38.899 
可以想象
把信息放到Xcode旁邊

00:16:38.966 --> 00:16:41.969 
因爲你想和
一個朋友聊聊

00:16:42.035 --> 00:16:43.070 
正在編的代碼

00:16:43.704 --> 00:16:45.973 
這叫做疊加
窗口放在

00:16:46.540 --> 00:16:47.541 
分割視圖中

00:16:48.642 --> 00:16:51.445 
疊加自動會用於
多個窗口的情況

00:16:52.880 --> 00:16:55.682 
疊加可以自動適用於
可調整窗口的情況

00:16:55.749 --> 00:16:56.984 
也就是說 你的應用

00:16:57.050 --> 00:16:58.318 
應用中
的窗口

00:16:58.385 --> 00:17:01.355 
將自動在全屏狀態
彼此疊加

00:17:01.421 --> 00:17:02.789 
你這邊無需
做任何調整

00:17:03.156 --> 00:17:05.392 
無論是窗口是
可以全屏還是不可

00:17:06.093 --> 00:17:09.162 
不過有個API
可以選擇出入疊加狀態

00:17:09.262 --> 00:17:12.065 
這是NSWindow的
NSWindow集合行爲

00:17:12.132 --> 00:17:13.200 
選項的一部分

00:17:13.700 --> 00:17:15.602 
例如 你有個
不可調整的窗口

00:17:15.669 --> 00:17:17.237 
而你以爲是可以
進行疊加

00:17:17.704 --> 00:17:19.973 
可以使用
Allowd Tiling選項

00:17:20.140 --> 00:17:22.075 
若你有一個非社交窗口

00:17:22.142 --> 00:17:23.277 
而且不希望
被疊加

00:17:23.343 --> 00:17:25.579 
可是設置
Disallows Tiling

00:17:25.646 --> 00:17:28.248 
我不清楚那個例子
不過它就在那裏

00:17:28.649 --> 00:17:31.685 
這些是全屏的
主要設置

00:17:31.752 --> 00:17:34.221 
這些已經在
X v7中都有

00:17:34.288 --> 00:17:37.024 
很重要的是
要注意全屏主要是這樣

00:17:37.090 --> 00:17:41.361 
需要確定
需要全屏的窗口

00:17:41.728 --> 00:17:44.097 
注意還有許多
選擇性加入

00:17:44.698 --> 00:17:47.668 
因爲你需要了解窗口
在全屏的整個

00:17:47.801 --> 00:17:50.003 
屏幕空間
如何反應

00:17:50.337 --> 00:17:53.073 
還有一個可選擇
功能可以考慮

00:17:53.140 --> 00:17:55.142 
怎樣讓你的窗口
在全屏工作

00:17:55.209 --> 00:17:56.743 
這一項仍可以選擇

00:18:00.247 --> 00:18:03.116 
當然也可以在Xcode
屬性檢查器中設置

00:18:03.183 --> 00:18:04.785 
當然可以是設置

00:18:04.852 --> 00:18:06.687 
疊加或窗口是否
該全屏之類

00:18:06.753 --> 00:18:10.190 
我說過 很多窗口都
可以自動疊加

00:18:10.490 --> 00:18:12.159 
不過AppKit可以查看

00:18:12.226 --> 00:18:14.795 
確定窗口是否可以
在同一個屏幕共存

00:18:15.195 --> 00:18:16.964 
設想你的屏幕
相對較小

00:18:17.030 --> 00:18:20.801 
還有兩個很大的窗口
你希望能把它們疊加

00:18:20.868 --> 00:18:22.970 
如果窗口無法
縮小到足夠小

00:18:23.036 --> 00:18:24.838 
AppKit將無法
實現疊加窗口

00:18:24.905 --> 00:18:29.176 
我希望你想想
怎樣讓窗口足夠小

00:18:29.243 --> 00:18:31.812 
如何才能靈活
處理使其

00:18:31.879 --> 00:18:35.582 
能在更小的空間
疊加分割視圖

00:18:36.149 --> 00:18:38.218 
爲實現這一點
我們有一些API

00:18:39.253 --> 00:18:41.855 
例如 分割視圖項
現在是側邊欄的動作

00:18:42.155 --> 00:18:44.725 
側邊欄變小
並消失

00:18:44.791 --> 00:18:47.127 
這樣就可以
實現重疊

00:18:47.561 --> 00:18:48.996 
也可以有適當的震動

00:18:49.830 --> 00:18:53.233 
NSStackView可以自動
查出隱藏的視圖

00:18:53.300 --> 00:18:56.036 
幫你創建類似
NSToolbar的體驗

00:18:56.103 --> 00:18:58.338 
適用於定製化視圖
可以把

00:18:58.405 --> 00:19:00.207 
拖到邊緣的項

00:19:00.340 --> 00:19:04.444 
放入菜單
諸如此類 還有許多

00:19:04.678 --> 00:19:05.679 
你可以去聽聽

00:19:05.746 --> 00:19:07.814 
《改善全屏視窗體驗》
的講座

00:19:07.881 --> 00:19:09.082 
時間是週四下午

00:19:11.885 --> 00:19:14.555 
要知道Auto Layout
也很重要

00:19:14.621 --> 00:19:16.690 
我們做了部分
重要調整

00:19:16.757 --> 00:19:19.626 
極大提高了
Auto Layout的表現

00:19:19.960 --> 00:19:21.161 
首先是堆棧視圖

00:19:21.595 --> 00:19:25.265 
堆棧視圖是個
很重要的分類

00:19:25.532 --> 00:19:28.302 
在滿足Auto Layout需求時
應該首先想到這個

00:19:28.368 --> 00:19:29.970 
如果你可以瞭解
堆棧視圖中

00:19:30.037 --> 00:19:31.104 
可以做什麼

00:19:31.171 --> 00:19:33.140 
而不是直接使用
種種約束會好得多

00:19:33.507 --> 00:19:36.410 
這是很大程度上的抽象
非常強大

00:19:36.844 --> 00:19:39.813 
關於堆棧視圖的好消息是
在iOS上也可以使用

00:19:39.880 --> 00:19:43.116 
因爲UI堆棧視圖
和在API的效果不相上下

00:19:43.183 --> 00:19:46.119 
這和我們一直以來的努力
相一致

00:19:46.186 --> 00:19:49.056 
即在不同平臺間
實現奇偶校驗效果

00:19:49.122 --> 00:19:50.457 
這就是具體的
一個實例

00:19:50.858 --> 00:19:52.759 
第二 現在這方面
比以往做得更好

00:19:52.826 --> 00:19:55.495 
我已經說過
有個分離功能

00:19:55.929 --> 00:19:58.031 
還有幾個
新視圖分佈選項

00:19:58.098 --> 00:19:59.600 
具備這個屬性
叫做分佈

00:20:01.201 --> 00:20:03.203 
這裏有一個值
是重力區

00:20:03.270 --> 00:20:07.441 
在介紹X v9的第一天起
大家就見過

00:20:07.508 --> 00:20:09.309 
堆棧視圖的選項

00:20:09.376 --> 00:20:11.245 
我們已經加上其他設置

00:20:11.311 --> 00:20:12.613 
這些就不必
繼續解釋了

00:20:13.046 --> 00:20:14.548 
給大家看一個短視頻

00:20:15.582 --> 00:20:18.452 
有6個堆棧視圖
構成這些設置

00:20:18.519 --> 00:20:20.954 
我重新調整窗口
稍大一些

00:20:21.021 --> 00:20:22.523 
小一些 再大些

00:20:22.723 --> 00:20:25.292 
你們看 還是有些
強大的功能的

00:20:25.359 --> 00:20:27.861 
比如設定等大
等距這些

00:20:27.928 --> 00:20:31.231 
等等 希望能夠
滿足你們的需要

00:20:31.431 --> 00:20:34.334 
堆棧視圖可以
任意放置

00:20:34.401 --> 00:20:36.336 
方便設置佈局

00:20:36.937 --> 00:20:40.140 
NSLayoutAnchor是個新
類別可以提供

00:20:40.374 --> 00:20:42.643 
邊或尺寸的
精確表示法

00:20:43.043 --> 00:20:44.311 
比如 你有
兩個視圖

00:20:44.378 --> 00:20:45.712 
打算創建
二者間的約束

00:20:46.313 --> 00:20:47.881 
這就是必須
編寫的代碼

00:20:48.549 --> 00:20:51.919 
有着佈局錨點
可以編寫這個代碼

00:20:52.519 --> 00:20:55.355 
注意 這兩項
基本上是佈局錨點

00:20:55.422 --> 00:20:58.292 
是指那些
視圖的邊緣

00:20:58.659 --> 00:21:00.694 
結果不僅更短
更好看

00:21:00.761 --> 00:21:03.964 
而且還提供了
更多編輯時間類型檢查

00:21:04.031 --> 00:21:04.698 
非常好

00:21:10.270 --> 00:21:13.040 
NSLayout Guide 是又一個新分類

00:21:13.674 --> 00:21:15.809 
如果你在做
這類事情

00:21:15.876 --> 00:21:20.514 
創建虛擬視圖
實現視圖間

00:21:20.581 --> 00:21:24.051 
等距效果 那麼
可以試試創建佈局指南

00:21:24.117 --> 00:21:27.187 
這是個輕量級對象
佔據了視圖的位置

00:21:27.254 --> 00:21:29.756 
不過其實它的量級更輕
可以參與

00:21:29.823 --> 00:21:31.792 
Auto Layout
而不會生成視圖

00:21:33.293 --> 00:21:35.863 
我們已經瞭解過
集合視圖

00:21:36.296 --> 00:21:39.666 
要知道 UICollection
View 也有過幾個

00:21:39.766 --> 00:21:41.368 
版本了

00:21:41.802 --> 00:21:44.371 
有着X v11 我們將
NSCollectionView

00:21:44.438 --> 00:21:47.608 
iOS版本進行奇偶校驗
都是保持重要功能

00:21:47.674 --> 00:21:50.210 
用於桌面 例如
拖拽和批量選擇

00:21:50.811 --> 00:21:53.347 
現在是新的集合視圖中
部分功能

00:21:53.814 --> 00:21:56.283 
有些功能如
異構項

00:21:56.350 --> 00:21:58.385 
選擇性分組
可定製佈局

00:21:58.852 --> 00:22:01.622 
我來給大家看個短視頻
是樣本應用

00:22:02.055 --> 00:22:03.490 
會有很多圖像
顯示出來

00:22:03.557 --> 00:22:08.328 
我首先依照頁眉和頁腳
進行分組 會用到

00:22:08.395 --> 00:22:10.497 
部分定製佈局
是本款app所提供

00:22:11.665 --> 00:22:14.935 
來看app的實際應用
瞭解具體功能

00:22:15.002 --> 00:22:17.204 
以及如何用於自己的應用中
《集合視圖最新內容》

00:22:17.271 --> 00:22:20.207 
週四下午4:30
會有介紹

00:22:22.442 --> 00:22:23.877 
在文本方面
我們的改動很多

00:22:24.178 --> 00:22:25.946 
首先是新的系統UI字體

00:22:27.514 --> 00:22:30.384 
新系統的字體
是這樣San Francisco

00:22:30.450 --> 00:22:35.122 
要知道　這和iOS和watchOS
上的字體一樣

00:22:35.822 --> 00:22:39.092 
字體是自動
提供應用的

00:22:39.159 --> 00:22:41.895 
在 El Capitan的
X v11 運行你的應用

00:22:41.962 --> 00:22:42.930 
就會得到這個字體

00:22:42.996 --> 00:22:44.765 
不過可能
你做了什麼

00:22:44.831 --> 00:22:45.966 
阻止了這項功能

00:22:46.033 --> 00:22:49.570 
如果看到這個字體
這是在X v10中推出的

00:22:49.736 --> 00:22:53.540 
還有些內容在繼續
檢查一下是否是你所需

00:22:53.607 --> 00:22:56.343 
確保你是在使用San
Francisco這種字體

00:22:56.443 --> 00:23:00.280 
如果在用這種字體
我們是在X v0當中推出

00:23:00.347 --> 00:23:02.516 
還會有更多內容繼續

00:23:02.983 --> 00:23:05.886 
最後 如果你在
使用這款字體...

00:23:08.088 --> 00:23:09.690 
...那麼會有很多工作要做

00:23:09.756 --> 00:23:10.624 
稍等一下

00:23:11.491 --> 00:23:13.827 
這就是我們不再
使用的Mac OS 9字體

00:23:16.163 --> 00:23:18.332 
這是在API可以使用的
NSFont字體

00:23:18.398 --> 00:23:20.734 
確保自己用的是
最新版本的系統字體

00:23:21.134 --> 00:23:22.769 
還有系統字體大小等等

00:23:22.836 --> 00:23:25.873 
這些字體
這些API

00:23:25.939 --> 00:23:27.274 
我們用了很久

00:23:28.742 --> 00:23:32.212 
可以通過Xcode屬性檢查器
設置系統字體

00:23:32.713 --> 00:23:34.748 
非常簡單
會有彈出窗口

00:23:34.815 --> 00:23:36.683 
選擇適當的
系統字體

00:23:36.750 --> 00:23:37.885 
用於自己的應用

00:23:39.453 --> 00:23:41.922 
我們還有一款新API
可用於不同粗細的系統字體

00:23:42.489 --> 00:23:45.959 
如果設計師讓你
使用不同粗細字體

00:23:46.426 --> 00:23:49.062 
現在就可以用這個
API調整系統字體

00:23:49.263 --> 00:23:51.331 
系統字體大小和粗細

00:23:52.032 --> 00:23:54.635 
有預設的9種
不同粗細

00:23:54.701 --> 00:23:56.403 
我只給大家看
其中三種

00:23:56.603 --> 00:23:58.038 
從超細
到黑體都有

00:23:58.472 --> 00:24:00.574 
常規設置是
系統字體大小

00:24:00.641 --> 00:24:02.109 
默認值

00:24:02.676 --> 00:24:06.914 
我們還有一款API
單距系統字體大小粗細

00:24:07.481 --> 00:24:08.949 
我給大家看看
爲什麼這東西有用

00:24:09.983 --> 00:24:14.221 
如果調用應用中的
字體大小API

00:24:14.288 --> 00:24:16.590 
鏈接是X v11 SDK

00:24:16.657 --> 00:24:19.092 
在寫幾個數字
就是這個效果

00:24:19.626 --> 00:24:24.031 
對字體很敏感的眼睛
估計一下子就會感到不同

00:24:24.131 --> 00:24:26.433 
這些數字
不是定距

00:24:26.500 --> 00:24:27.467 
寬度都不同

00:24:28.068 --> 00:24:31.004 
這就很奇怪了
因爲傳統的系統字體

00:24:31.071 --> 00:24:33.473 
一般都是
等寬數字

00:24:33.941 --> 00:24:39.413 
要確保表格數字
都要井井有條

00:24:39.479 --> 00:24:43.250 
或是UI文本中數字變化時
不會擰成一團

00:24:43.317 --> 00:24:44.685 
因爲數字是不斷變化的

00:24:45.519 --> 00:24:47.154 
不過現在 如果你的app

00:24:47.221 --> 00:24:50.624 
連在 X v11上就會
得到這樣的系統字體

00:24:50.858 --> 00:24:53.260 
如果必須
要定距字體

00:24:53.360 --> 00:24:56.830 
那麼在使用這個
API時 就要放棄

00:24:56.897 --> 00:24:59.266 
等寬數字

00:24:59.733 --> 00:25:02.769 
從活版印刷角度來看
效果不理想 不過問題解決了

00:25:03.203 --> 00:25:05.506 
效果很是不同

00:25:05.772 --> 00:25:08.809 
現在是按比例
也是固定寬度了

00:25:09.009 --> 00:25:10.077 
這就是給大家的工具

00:25:10.711 --> 00:25:13.747 
大家還可以聽到
更多API方面的內容

00:25:13.814 --> 00:25:15.349 
《最新系統字體介紹》

00:25:15.415 --> 00:25:17.284 
講座時間 週五下午
2:30

00:25:19.186 --> 00:25:23.123 
我也提到了新款API
在科技系統有新款API

00:25:23.490 --> 00:25:26.927 
可以實現新功能以及對TextKit
和iOS進行奇偶校驗

00:25:27.427 --> 00:25:28.495 
這裏還有很多項

00:25:28.562 --> 00:25:30.731 
我只介紹其中
兩三種

00:25:31.131 --> 00:25:32.533 
首先是路徑排除

00:25:33.133 --> 00:25:36.203 
這種功能可以
很容易安排路徑

00:25:36.270 --> 00:25:38.739 
在目標周圍
擺好文字 就像這蝴蝶

00:25:38.805 --> 00:25:41.475 
非常簡單

00:25:42.209 --> 00:25:44.845 
還有一個是文本域的
兩個屬性：最大線條數

00:25:44.912 --> 00:25:48.115 
特別適用於
Auto Layout

00:25:48.515 --> 00:25:51.018 
或是允許
默認縮緊截斷

00:25:52.019 --> 00:25:55.389 
這可以確定文字域

00:25:55.455 --> 00:25:59.726 
內容是否應該縮緊
然後再真正將之截斷

00:25:59.793 --> 00:26:02.496 
以前有過控制方法
但是現在是

00:26:02.563 --> 00:26:04.164 
使用Boolean屬性控制

00:26:05.232 --> 00:26:07.634 
還有很多調整變化
以及部分亮點

00:26:10.270 --> 00:26:11.772 
那麼關於AppKit部分

00:26:11.839 --> 00:26:14.641 
最後講一點
視覺原子性

00:26:15.275 --> 00:26:17.611 
大家可能會奇怪
視覺原子性是什麼

00:26:18.278 --> 00:26:19.279 
是山嗎？

00:26:19.713 --> 00:26:21.481 
這和Half Dome
有什麼關係?

00:26:21.582 --> 00:26:25.018 
我給大家看個短片
解釋我所說的

00:26:25.085 --> 00:26:28.422 
視覺原子性或
缺乏視覺原子性是什麼意思

00:26:28.755 --> 00:26:30.557 
兩次看到
打開面板

00:26:31.391 --> 00:26:33.093 
第一次沒問題 還可以

00:26:33.760 --> 00:26:35.429 
第二次 你們自己想

00:26:39.766 --> 00:26:44.938 
除非你們什麼都看不到
否則都明白我的意思

00:26:45.205 --> 00:26:46.740 
我給大家慢動作播放

00:26:47.241 --> 00:26:50.344 
陰影部分面板
面板其他部分

00:26:50.677 --> 00:26:53.780 
這就是打開面板
是在約塞米蒂

00:26:54.548 --> 00:26:57.084 
打開面板很粗糙
因爲是多項進程

00:26:57.150 --> 00:27:00.120 
在帶動
不過這不是藉口

00:27:00.454 --> 00:27:03.257 
這樣的UI讓用戶
感覺彷彿是一次

00:27:03.323 --> 00:27:05.926 
走一步 一次走一幀
不應該是

00:27:05.993 --> 00:27:08.862 
這樣的視覺
步驟的

00:27:09.563 --> 00:27:11.164 
這就是我所說的
視覺原子性的意思

00:27:11.231 --> 00:27:14.434 
需要的時候
一步到位

00:27:15.269 --> 00:27:18.805 
你們當中視窗 視圖

00:27:19.072 --> 00:27:21.575 
還有Core Animation
層次都很清晰

00:27:21.642 --> 00:27:24.111 
要知道實現
視覺原子性並非

00:27:24.178 --> 00:27:25.078 
都那麼簡單

00:27:26.547 --> 00:27:28.715 
這些是API
大家不用仔細

00:27:28.782 --> 00:27:30.217 
看明細
這不是考試

00:27:30.684 --> 00:27:32.886 
這些就是完成這項任務
所需要的API

00:27:32.953 --> 00:27:35.556 
但是不一定要一起
工作才行

00:27:35.923 --> 00:27:37.824 
在X v11中我們解決了問題

00:27:38.258 --> 00:27:41.562 
所以可以用
NSAnimationContex

00:27:41.628 --> 00:27:42.963 
實現視覺原子性

00:27:44.097 --> 00:27:47.000 
可以調用Begin Group
ing或End Grouping

00:27:47.067 --> 00:27:47.801 
或類似功能

00:27:47.868 --> 00:27:50.470 
運行Animation Group
周圍是一系列

00:27:50.838 --> 00:27:53.507 
你在做的獨立畫作
就像這裏這樣

00:27:53.574 --> 00:27:55.442 
這就可以實現
視覺原子性

00:27:55.509 --> 00:27:57.778 
除此之外

00:27:58.011 --> 00:28:00.614 
我們不鼓勵使用Disable
Screen Updates

00:28:00.681 --> 00:28:02.716 
和Enable Screen
Updates

00:28:02.783 --> 00:28:05.352 
以及Disable Screen
until Flush

00:28:05.419 --> 00:28:07.754 
並非是不支持
只是不再推薦使用

00:28:07.821 --> 00:28:09.156 
應該沒必要

00:28:11.124 --> 00:28:15.362 
這樣 我們可以繼續
介紹Foundation

00:28:15.996 --> 00:28:18.298 
關於Foundation
可以講的也很多

00:28:19.700 --> 00:28:20.868 
首先是管理撤銷

00:28:21.835 --> 00:28:25.572 
用過Swift中管理撤銷的
都知道管理撤銷

00:28:25.639 --> 00:28:28.509 
API在Swift中
並不太好用

00:28:29.209 --> 00:28:30.677 
API是這個樣子

00:28:30.978 --> 00:28:34.448 
第一個有個選擇器
部分情況纔會管用

00:28:34.515 --> 00:28:36.149 
第二個是有
指示

00:28:36.550 --> 00:28:39.653 
NSIndication in
Objective-C當然相當棒

00:28:39.887 --> 00:28:42.990 
還是Swift裏面那些
花哨的種類 它不太清楚

00:28:43.590 --> 00:28:45.959 
所以我們加上了
基於代碼塊的撤銷

00:28:46.927 --> 00:28:48.829 
這就是在
Objective-C中的樣子

00:28:48.896 --> 00:28:50.097 
在Swift中
是這個樣子

00:28:50.964 --> 00:28:52.633 
你們看
這有個目標論證

00:28:52.900 --> 00:28:55.135 
也是個代碼塊
基本上就是執行

00:28:55.202 --> 00:28:57.938 
剛做過的
撤銷應用

00:28:59.139 --> 00:29:01.808 
目標方式的不同論證
大家不用

00:29:01.875 --> 00:29:03.443 
去參考
代碼塊的目標

00:29:03.510 --> 00:29:05.245 
以避免循環保留

00:29:05.712 --> 00:29:07.414 
在Swift聲明中
也用到泛型類型

00:29:07.481 --> 00:29:09.616 
我會告訴大家
具體是怎麼工作的

00:29:10.284 --> 00:29:11.251 
這是個例子

00:29:11.552 --> 00:29:13.654 
我們有個類別
名爲Colorful Shape

00:29:13.720 --> 00:29:15.355 
還有個屬性名爲Color

00:29:17.090 --> 00:29:20.060 
我們爲這個屬性
加上Did Set屬性觀察器

00:29:20.427 --> 00:29:22.529 
這不過是可以實現撤銷的
多種方式之一

00:29:22.596 --> 00:29:24.865 
還可以通過其他方式撤銷
不過我們是通過

00:29:24.932 --> 00:29:25.999 
Did Set屬性完成

00:29:26.466 --> 00:29:28.635 
這裏是調用
目標註冊撤銷

00:29:29.369 --> 00:29:32.272 
這裏是實際上執行
撤銷應用的代碼

00:29:32.339 --> 00:29:33.607 
針對我剛做過的事情

00:29:35.042 --> 00:29:38.645 
注意這裏多虧對目標的
註冊撤銷中用了泛型

00:29:38.712 --> 00:29:41.481 
這些都發揮了作用

00:29:41.548 --> 00:29:43.617 
目標被自動識別
爲是彩色形狀

00:29:43.684 --> 00:29:46.253 
這要歸功於
註冊撤銷欄的

00:29:46.320 --> 00:29:48.055 
自參考

00:29:48.121 --> 00:29:50.524 
你不必將目標轉化爲
彩色形狀

00:29:53.026 --> 00:29:55.162 
NSCoder現在就可以處理錯誤

00:29:55.495 --> 00:29:58.699 
用過NSCoders的人們比如NS
KeyedArchiver之類

00:29:58.765 --> 00:30:01.802 
要知道並沒有對這些東西的
錯誤論證

00:30:02.569 --> 00:30:04.638 
我們已經添加了外顯
錯誤處理

00:30:05.405 --> 00:30:07.908 
這類方式包括Decode
Object for Key

00:30:07.975 --> 00:30:10.711 
Decode Object of
Classes for Key

00:30:10.777 --> 00:30:11.612 
都有不同版本

00:30:11.678 --> 00:30:13.981 
都可以在實際中返還錯誤
將錯誤拋入Swift當中

00:30:14.114 --> 00:30:15.916 
這些叫做
Decode Top Level

00:30:15.983 --> 00:30:17.184 
Object for Key

00:30:17.251 --> 00:30:18.952 
以及Decode Top
Level

00:30:19.019 --> 00:30:21.154 
Object of
Classes for Key

00:30:21.221 --> 00:30:23.290 
注意它們拋出聲明表示了
它們在返回還錯誤

00:30:23.624 --> 00:30:25.926 
還要注意它們
返回了可選目標

00:30:25.993 --> 00:30:28.996 
因爲空返回
實際上是有效返回

00:30:29.062 --> 00:30:32.032 
這表明對象
並不在檔案中

00:30:32.999 --> 00:30:33.934 
注意這些名爲

00:30:34.001 --> 00:30:36.603 
Decode Top Level
Object for Key

00:30:36.670 --> 00:30:39.273 
我們有意在
未歸檔的

00:30:39.339 --> 00:30:41.208 
根對象中
將其放在頂層

00:30:41.508 --> 00:30:44.311 
我們不想在你實施代碼期間

00:30:44.378 --> 00:30:45.279 
調用這些

00:30:46.713 --> 00:30:48.615 
請注意 這裏
只有兩種方式

00:30:48.682 --> 00:30:50.951 
我們還有兩三種
方式可以適用

00:30:51.018 --> 00:30:53.921 
所有的解碼對象
類型方式

00:30:56.190 --> 00:30:59.660 
現在由NSError提供值
我們以此爲模型

00:31:00.260 --> 00:31:04.431 
通過這種簡單的方式
可以生成NSError對象

00:31:04.498 --> 00:31:06.633 
相當簡單
直接 不過

00:31:06.700 --> 00:31:08.235 
注意 它不可向
用戶呈現

00:31:08.569 --> 00:31:10.437 
如果用戶
見過了

00:31:10.504 --> 00:31:11.605 
那就是這個樣子

00:31:12.172 --> 00:31:16.210 
不太好你們其實是想給
他們看看

00:31:16.276 --> 00:31:17.978 
是否曾給
用戶見過

00:31:18.245 --> 00:31:20.414 
即便不給用戶提供
要知道

00:31:20.480 --> 00:31:22.516 
除錯器中 有這類東西
也會很有幫助

00:31:22.583 --> 00:31:24.618 
與得到42號錯誤相反

00:31:25.252 --> 00:31:28.355 
因此編寫的代碼
是類似這樣

00:31:29.389 --> 00:31:33.460 
因此要明確各個鍵的值
如果想要給用戶

00:31:33.527 --> 00:31:36.230 
出示 需要對之
進行本地化

00:31:36.864 --> 00:31:38.398 
因此這是
一大堆代碼

00:31:38.932 --> 00:31:41.001 
你就可以永遠地
創建方式

00:31:41.201 --> 00:31:44.137 
代碼不是問題
編寫代碼是我們的工作

00:31:44.204 --> 00:31:46.306 
對 我們就是靠這個掙錢的
不過這不是問題

00:31:46.607 --> 00:31:48.842 
問題是所有這些
都是發生在

00:31:48.909 --> 00:31:51.879 
出現錯誤的時候
即使錯誤的消費端

00:31:51.945 --> 00:31:53.680 
和錯誤沒有任何關係
也是如此

00:31:53.747 --> 00:31:55.816 
因此從性能考慮
這是浪費

00:31:56.450 --> 00:31:58.719 
因此我們加入了
這種功能

00:31:58.785 --> 00:32:01.088 
可以按需創建
並返回所需值

00:32:02.289 --> 00:32:05.592 
我們有這個方式
爲域名提供方的

00:32:05.659 --> 00:32:07.227 
用戶信息值提供方進行設置

00:32:07.461 --> 00:32:11.131 
你基本上在應用中
爲NSError

00:32:11.198 --> 00:32:13.901 
明確域名
並提供提供方

00:32:13.967 --> 00:32:17.137 
即可以將在用戶信息字典中
丟失的任何鍵值

00:32:17.204 --> 00:32:18.238 
返回的代碼塊

00:32:18.305 --> 00:32:20.240 
因此 會按需
惰性生成

00:32:20.574 --> 00:32:24.144 
你可以回去使用這個
漂亮的短小代碼

00:32:24.211 --> 00:32:26.013 
來生成錯誤
用戶信息

00:32:26.079 --> 00:32:27.548 
會動態填寫

00:32:30.751 --> 00:32:32.819 
你也許熟悉
NSProgress

00:32:32.953 --> 00:32:35.222 
這是報告
進度的對象

00:32:35.289 --> 00:32:36.657 
還有個不錯的功能

00:32:36.723 --> 00:32:41.662 
將在多個操作類型層次中
隱形記錄進度

00:32:41.728 --> 00:32:43.564 
並且它會
作爲單獨數字

00:32:43.630 --> 00:32:45.666 
呈現
給用戶

00:32:46.133 --> 00:32:47.968 
相當不錯
但是這是隱形的

00:32:48.669 --> 00:32:52.139 
作爲隱形
你可能會

00:32:52.206 --> 00:32:53.207 
遇到一些問題

00:32:53.540 --> 00:32:55.542 
我們介紹
管理進度報告的

00:32:55.609 --> 00:32:57.110 
線性模式

00:32:57.778 --> 00:33:00.380 
包括兩部分
一個是直接向

00:33:00.447 --> 00:33:03.383 
操作類型層次
添加並去除子進度對象

00:33:03.450 --> 00:33:06.420 
第二個就是這個協議

00:33:06.486 --> 00:33:09.423 
可以讓你
直接聲明對象進度

00:33:09.857 --> 00:33:12.025 
例如 如有
NSOperation子類

00:33:12.092 --> 00:33:16.396 
這可以實現部分一步操作
要知道 它會開始和結束

00:33:16.463 --> 00:33:19.533 
是這個進度屬性
不錯的候選

00:33:19.833 --> 00:33:23.270 
可以實現選擇
外顯進度報告

00:33:24.438 --> 00:33:27.040 
NSProgress也可以
從頭開始

00:33:27.441 --> 00:33:30.477 
以前是可以停頓
我們有加入第二部分

00:33:32.079 --> 00:33:34.815 
NSNotification
Center現在可以

00:33:34.882 --> 00:33:37.451 
自動解除註冊
分配的觀察

00:33:43.657 --> 00:33:45.559 
這就是你們必須
把自己加成

00:33:45.959 --> 00:33:47.394 
觀察者需要
編寫的內容

00:33:47.461 --> 00:33:48.328 
這是需要把自己

00:33:48.395 --> 00:33:49.863 
作爲觀察者刪除
所需編寫的代碼

00:33:49.930 --> 00:33:51.465 
如果想把自己
作爲觀察者刪除

00:33:51.532 --> 00:33:53.367 
作爲觀察者刪除
所需編寫的代碼

00:33:53.867 --> 00:33:57.271 
如果不然 你會被自動
取消註冊

00:33:57.404 --> 00:33:59.540 
相當棒
這樣很好

00:34:01.408 --> 00:34:05.879 
這個類別名稱 就是
Toby 昨天在

00:34:05.946 --> 00:34:07.481 
聯盟會議上不敢提到的

00:34:07.714 --> 00:34:09.683 
NSFirstNameComponentsFormatter

00:34:10.016 --> 00:34:13.053 
規則是 如果它沒有
長到可以在

00:34:13.120 --> 00:34:15.022 
幻燈片標題上封裝起來
那它並不算太長

00:34:15.222 --> 00:34:18.025 
那麼NSFirstName
ComponentsFomatter

00:34:18.091 --> 00:34:20.661 
它可以讓名稱的格式
得以恰當本地化

00:34:20.928 --> 00:34:23.563 
它又和其他
我們過去幾年加入的格式器

00:34:23.630 --> 00:34:26.667 
聯合了起來 比如
日期部件格式器

00:34:27.034 --> 00:34:29.369 
字節數格式器
長度格式器等等

00:34:30.603 --> 00:34:34.208 
它還爲幾種不同形式
提供了樣式

00:34:34.341 --> 00:34:35.809 
讓我舉一個簡單的例子

00:34:36.310 --> 00:34:39.612 
假設你創建了一個基於人名的
實體組件 它有名稱的

00:34:39.679 --> 00:34:42.282 
幾部分 你指定
你有的名稱部分

00:34:42.482 --> 00:34:45.252 
但是還剩很多 比如說
在這裏 我們指定其中三個

00:34:46.719 --> 00:34:49.322 
然後 你在格式器中創建
一個人名 然後把它

00:34:49.389 --> 00:34:50.591 
格式化

00:34:51.190 --> 00:34:54.161 
取決於你
你給的樣式

00:34:54.228 --> 00:34:56.396 
你會得到不同形式的
名稱 如長的

00:34:56.463 --> 00:34:58.298 
默認的、短的等等

00:34:58.699 --> 00:35:01.802 
請注意 如果你需要短的
但在其它語言中

00:35:01.869 --> 00:35:05.506 
你可能會得到一個形式完全不同的
名稱 這個具體取決於

00:35:05.572 --> 00:35:07.374 
這種語言的
本地化規則

00:35:07.441 --> 00:35:09.076 
不要對你會從
這種API得到的

00:35:09.142 --> 00:35:11.345 
名稱的類別
做出假設

00:35:11.912 --> 00:35:14.181 
這個 API 的目的
主要的目的之一就是

00:35:14.248 --> 00:35:16.216 
讓你從編寫全球通用

00:35:16.283 --> 00:35:18.352 
應用的複雜工作中
解放出來

00:35:19.319 --> 00:35:22.456 
NSString 有新的 API
其可以幫助你編寫全球通用

00:35:22.523 --> 00:35:24.191 
國際化的
應用

00:35:24.625 --> 00:35:27.494 
這將促進
有條件的引用

00:35:27.761 --> 00:35:31.565 
不論其是否爲技術詞語
其應由引用包圍

00:35:31.832 --> 00:35:34.401 
而其規則會根據
語言不同而變化

00:35:34.768 --> 00:35:37.571 
更爲簡單的本地化情況
用於變更和搜索的 API

00:35:38.105 --> 00:35:41.241 
音譯API它們之前
都在 CFString 中

00:35:41.308 --> 00:35:44.244 
現在它們在 NSString 中
也能更好地協助

00:35:44.311 --> 00:35:47.281 
自適應字符串
和用戶界面表達

00:35:47.614 --> 00:35:51.351 
在你的字符串文件中
你可以提供多個形式

00:35:51.418 --> 00:35:54.655 
多種長度
並根據你在

00:35:54.721 --> 00:35:57.357 
你在用戶界面上所剩
空間多少來選擇合適的

00:35:58.125 --> 00:36:00.928 
你會在國際化新特性講座中
瞭解到關於名稱部件格式器

00:36:01.295 --> 00:36:03.764 
和所有這些協助方法
的具體信息

00:36:03.830 --> 00:36:06.366 
當然還有更多內容
它在星期五上午9點開始

00:36:08.268 --> 00:36:10.003 
我再談談
關於熱狀況的情況

00:36:10.070 --> 00:36:15.075 
這些 API 是在 X
v10.3 中引入的 也是我們

00:36:15.142 --> 00:36:18.078 
動感新 MacBook 出來之刻
當然 你們也知道

00:36:18.145 --> 00:36:20.280 
沒有多少人真的喜歡
這個新東西

00:36:20.380 --> 00:36:23.550 
而事實上它是
一個很好的 API 案例研究

00:36:23.884 --> 00:36:27.654 
請注意 雖然此 API
和新 MacBook 同時引入

00:36:27.721 --> 00:36:30.757 
它也適用於我們的其它機器

00:36:30.824 --> 00:36:32.326 
而且通常都是
可用並能正常運作的

00:36:32.392 --> 00:36:33.927 
它不僅僅適用於
MacBook

00:36:34.795 --> 00:36:37.831 
此 API 使用
屬性捕獲

00:36:37.898 --> 00:36:40.400 
一種在 NSProcessInfo
上的熱狀況屬性

00:36:40.467 --> 00:36:43.203 
它有四個值：象徵性
普通、 嚴重 、極其嚴重

00:36:43.570 --> 00:36:46.840 
每當值更改時
你都會收到通知

00:36:48.509 --> 00:36:51.411 
如果值爲嚴重
那麼風扇是以

00:36:51.478 --> 00:36:53.780 
最高速度運作
當然 這是假設你的電腦有風扇

00:36:54.248 --> 00:36:56.884 
你可以想象如果你沒有風扇
那會發生什麼事情

00:36:57.184 --> 00:36:59.520 
嚴重通常是要
你採取某些行動的時候

00:36:59.586 --> 00:37:02.389 
例如 你可能
在做自定義的動畫

00:37:03.390 --> 00:37:05.225 
而且幀數達到 60 FIPS
這時你要考慮

00:37:05.292 --> 00:37:07.361 
減少你的幀數到
30 FIPS

00:37:07.861 --> 00:37:10.497 
這就是 NSScrollView
會自動爲你做的事情

00:37:10.564 --> 00:37:13.433 
這樣一來 你就不必擔心有關
NSScrollView 的情況

00:37:13.500 --> 00:37:16.069 
假設你正在應用程序中
使用高解析度的材質

00:37:16.136 --> 00:37:18.105 
而且你收到一個
嚴重的熱狀態的提示

00:37:18.172 --> 00:37:21.108 
也許你需要
使用低解析度的材質

00:37:22.176 --> 00:37:25.245 
此款 API 在
你需要它時很有幫助 但

00:37:25.312 --> 00:37:28.649 
但要注意 此款 API 是
反應性的 並不是主動的

00:37:29.183 --> 00:37:31.985 
此 API 讓
系統提示你 告訴你

00:37:32.052 --> 00:37:35.088 
目前的困難 然後你需要
採取行動 當然

00:37:35.155 --> 00:37:36.890 
你採取的行動
不能反而

00:37:36.957 --> 00:37:38.058 
增加對系統的負載

00:37:38.692 --> 00:37:40.894 
我們有很多其它
主動 API

00:37:40.961 --> 00:37:43.664 
我們已在
最新的講座中介紹

00:37:44.398 --> 00:37:46.900 
這些類型的 API
會告訴系統

00:37:46.967 --> 00:37:51.705 
你在做什麼 然後
系統會基於你

00:37:51.772 --> 00:37:55.676 
目前的操作
優化你的活動和任務

00:37:56.043 --> 00:37:58.045 
例如 計時器
公差

00:37:58.412 --> 00:38:01.582 
處理信息活動
API 並

00:38:01.648 --> 00:38:03.784 
使用 NSURLSession
在後臺進行下載

00:38:03.851 --> 00:38:06.520 
設置服務質量 等等

00:38:07.487 --> 00:38:10.757 
這些 API 不僅可以允許
高效操作

00:38:10.824 --> 00:38:13.093 
但它們還能夠
引導合適的熱行爲

00:38:13.160 --> 00:38:17.497 
它們可以帶來更長的電池
使用壽命 並讓你的系統冷卻

00:38:17.865 --> 00:38:19.833 
無論是表面上的降溫
還是內部降溫

00:38:22.135 --> 00:38:26.340 
最後 我簡單地提及下 Core
Data因爲講座剩下時間不多了

00:38:26.707 --> 00:38:29.076 
Core Data
中有很多強大功能唯一約束

00:38:29.142 --> 00:38:31.812 
批量刪除
和其他 API 增強功能

00:38:32.045 --> 00:38:33.113 
這就是我要說的

00:38:34.181 --> 00:38:35.682 
當然 這不算一個
新特性講座 如果

00:38:35.749 --> 00:38:38.118 
如果我沒有提到很多
新事物

00:38:38.452 --> 00:38:40.587 
這些都是許多其他
我沒時間提到的主題

00:38:40.654 --> 00:38:42.756 
你應該可以在
發佈說明中閱讀到

00:38:43.190 --> 00:38:45.659 
它甚至沒有包括
令人驚訝的新技術

00:38:45.726 --> 00:38:48.095 
比如 Metal 或者
GameplayKit

00:38:50.397 --> 00:38:53.300 
總的來說 我們有很多
泛型通用 API 改進

00:38:53.367 --> 00:38:55.569 
在 Swiftification
各個層面上都有

00:38:55.636 --> 00:38:57.971 
此外 我們有很多
強大的功能和增強功能

00:38:58.672 --> 00:39:03.410 
看看這些材料 想想如何
採用它們

00:39:03.477 --> 00:39:06.113 
如果你有任何問題
就來我們的實驗室來討論吧

00:39:07.748 --> 00:39:10.384 
最後 我
再總結下要點

00:39:10.617 --> 00:39:12.553 
AppKit和Foundation
發佈

00:39:12.619 --> 00:39:13.554 
說明已經可以從

00:39:13.620 --> 00:39:16.223 
developer.apple.
com.osx上獲取

00:39:16.290 --> 00:39:19.526 
發佈說明是爲了拋磚引玉
所以它是一個很好的來源

00:39:20.093 --> 00:39:21.428 
感謝你們今天到場

00:39:21.495 --> 00:39:22.863 
會議後
好好休息吧