WatchKit in Depth第一部分
諸位早上好！
歡迎參加WatchKit in Depth第一部分的講座
講座分爲兩個環節這是第一個環節
進一步探討WatchKit中的變化
我叫安德魯·普拉茲
將與福里斯特·希爾一道講述今天的話題
希望您會感興趣
我將講述三個部分
即架構 手錶 app內部手錶擴展的基本佈局工作原理
我會講述資源和數據的存放地點
因爲它是由兩個部分構成的系統所以開始時可能會有點難以理解
對於那些已經從事過Watch OS 1開發的朋友
WatchOS 1是WatchKit的一個擴展是一個手錶app
我將會講到遷移有哪些變化以及有哪些相同之處
然後福里斯特將繼續談一下
WatchKit中的一些新的API以及新的類 
因此您的手錶 app包含三個部分
它有一個iOS應用
你將會在手機上安裝它
此外你還將提供一個WatchKit擴展
這是你自己寫的代碼
然後是一個手錶OS應用
它包含資源和界面描述
您有了手機下載了您的app
而我們已完成的工作就是增加一批新的數據
一批附帶並與其一道安裝的文件
而那就是手錶app
它包含您對界面的描述或許也有一些資源
然後就是您的WatchKit擴展
它包含代碼和額外的資源
因此當您把它與您的手錶匹配時
我們將所有的那些信息複製過去它就會出現在主屏幕上
作爲一個完整的應用出現
當然手機上仍然留有備份以備以後重新安裝的不時之需
因此我會談到兩個你將要提供的部分
一個是界面另一個是實際代碼以及擴展
當您創建了一個新的WatchKit App
您可以看到實際上有兩個獨立的目標
兩個獨立的組件帶有interface Storyboard的app
和您的代碼這裏的代碼即Swift
而你有多達四個不同的可以向其添加代碼的東西
因此對於storyboard這是它的界面部分
您可以在IB內編輯它正如編輯一個iOS應用一樣
而我們提供相當豐富的一組界面元素 標籤 圖像等等
這就是watchOS 1的全部內容而且我們在watchOS 2裏面
添加了幾個新特性如Picker視圖這將給您一個豐富的界面以及影片視圖
因此 例如這裏有三個帶有你能夠看到所有控制按鈕的標準控件
它們是在interface builder內創建的
我們也有針對特定功能的自定義界面
一個是Glances它有更爲具體的佈局
另兩個是用於通知的界面
一個用於靜態通知另一個用於傳送更爲動態的
您在運行時提供的信息
因此正如我剛纔所言您的擴展有四個功能
有個應用功能
當您的應用從主屏幕啓動的時候我們調用您的擴展
它也被用於從時鐘出現的單頁glance
以及在您接收到通知的時候進行顯示
而且現在也用於complications
對於其中的每一個都有個相關聯的控件
對於Glances以及常規應用有WK Interface Controller
有一個專門的次級類
叫做WK User Notification Interface Controller
對於通知 您應該使用這個次級類
還有一個新的數據源對象
即WK Complication Data Source
關於complications我目前就講這麼多
今天稍後還有一個講座環節對此進行更詳細探討
因此您的WK Interface Controller是與您的界面的主要連接工具
它所做的主要是自動創建界面屬性
因此你會在界面設計中對一個界面元素貼上標籤
並聲稱 類似這是我的標籤
然後我們在控件上創建一個關聯的對象並自動爲您將其連接好
控件也支持菜單處理您可以自定義菜單或者使用靜態菜單
我們提供對控件的導航推送等等或者調度
和模態顯示
以及警告和action sheet
另外一個我們提供的內容是幾個系統UI表單
文本輸入 視頻回放 音頻錄製
那麼 比如說這裏有個非常簡單的界面控件類
它有一個插座變量app圖標而我們在IB中加載它
當我們運行應用時 我們看到它提取了圖標並將其顯示在屏幕上
那麼我想談一下各種東西的位置
你的資源存放在哪裏你從哪裏提取數據
因爲這個手錶app分爲兩個部分
包括手錶app本身以及WatchKit擴展
有兩個地方存放數據
即WatchApp bundle 和WatchKit擴展bundle
而你必須確保記住它存放的位置
比如這裏我創建了另一個對象
和以前一樣它也有一個interface storyboard
和一個名爲application image的圖像文件
以及本地化的字符串文件
而擴展本身也包含同樣的東西
它有另一個png文件和一個可本地化的字符串
那現在如果我們進行個容易理解的操作即創建兩個插座變量
並使用IB插座變量將其連接起來表明這些是屬性
並調用組圖標
哦 我們沒有擴展圖標
原因是當你調用的組圖標是在WK Interface Image上命名的時候
它並不在應用bundle內進行搜索
但是擴展圖標並不存放在應用的bundle內
因此你要做的是直接從正在那個特定的bundle中運行的代碼內提取它
因此在擴展代碼內你調用UI圖標的名稱
而這將在本地提取圖標
因爲它知道如何在它自己的bundle內部進行搜索
然後你在系統內執行同樣操作
你調用組圖標而不是已被命名的組圖標
那將傳遞圖標並讓兩個圖標都出現在您的應用內
那麼現在你希望存儲一些數據
您不會只希望提取一些靜態圖片你擁有一個極其動態的應用
因此有兩個你感興趣的文件夾
一個是文檔文件夾
這是你存儲更爲持久的信息的地方
它是不可刪除的就是說它在重啓之間是一直運行的
但是需要注意的一點是它是不可恢復的
因此你必須檢查手錶是否被擦除否則你就要安裝新的手錶
還有一個緩存文件夾
這個是可以刪除的因此如果系統認爲需要更多空間
存儲音樂 圖片或其他 app
它將刪除這些圖片
因此你可以認爲那些圖片可能隨時消失
這裏有一個例子我們快速地看一下在哪裏找到它
在這個例子中 主要調用的是document directory類
目錄URL的文件管理器
它將請求第一個而那正是需要的 URL
因此我們創建一個包含我們的文件名的URL並向其寫入一些數據
現在媒體出現了另一個有趣的問題
由於應用負責播放媒體
它也負責將音頻錄製在某個地方
因此當你的擴展請求播放一個影片或播放音頻 或錄製音頻的時候
我們將其傳送給應用
另一方面擴展負責
從互聯網上下載或用其他操作生成媒體
它也負責獲取你可能已經設置好的錄製下來的音頻文件
並將它們傳送到你的服務器上
那麼你需要做的就是設置所謂的共享容器
而那主要是爲了讓兩個過程即應用和擴展一個能夠共同訪問的地方
因爲出於安全因素
通常你不能從一個過程進入另一個存儲區域
而你啓用了這種Xcode
你使用了所謂的‘app羣組’
將其用於擴展和你賦予了獨特的識別符的應用
而那就是你的應用羣組
那麼這裏你需要真正擔心的唯一事情仍然是有一個函數
即文件管理器
你可以爲安全應用羣組識別符請求容器URL
並將其通過你創建的羣組識別符進行傳遞
而那將把你的URL賦予到一共享的存儲區域
因此從那裏你可以存儲app
能夠從擴展讀取或者提取的文件
這裏我們有一個例子是當前的音頻錄製控件把URL從共享容器取出
那麼它將把音頻錄製到那個文件內
因此現在我希望談一下如何從手錶提取數據
有兩種方法可以實現
一種是NSURL Session它是在Foundation框架內的
另一種是通過一個新的Watch Connectivity框架
因此NSURL Session是你從互聯網上獲取資源的方法之一
如果你有一個聊天app或類似的東西你會希望與您的服務器對話
它讓你直接通過HTTP和HTTPS訪問互聯網
而有多種配置方式
而且它支持以後臺方式下載
原因是您的擴展經常不處於運行狀態
您的手錶屏幕是關閉的您的擴展是睡眠狀態的
您的擴展甚至不運行的時候
而這都是下載數據所需要的
需要注意的一點是
一旦我們告訴您數據已經在那裏一旦文件已被完全下載
您需要立刻拿到它因爲否則的話它就會被從臨時緩存刪除
因此這裏有一些代碼一共有幾頁
一個簡單的downloader類
我們首先要做的是釋放NSURLSession 
我們慢慢做這件事以防我們永遠不需要調用它
而這裏的調用主要是創建會話
而且只有兩行代碼一行是爲了對後臺進行配置
那麼你可以說這裏是一個後臺會話
而我們希望傳入一個ID過一會兒我會談到它
而我們使用那種配置創建URL會話
而且我們讓downloader類本身成爲delegate之後的實例
以便我們能夠在文件進來時得到通知
然後爲了開始URL下載
我們請求一個新的任務
並讓其運行
而它將發出請求並開始下載
正如我剛纔所言 通常你的擴展是關閉的或不處於喚醒狀態
在它關閉的情況下
你將需要重新連接到已經設置好的所有下載任務
因此你要設置的是個在您的WK擴展中叫做restart的調用的函數
福李斯特之後將談到那一點
啓動調用函數並重新啓動下載以便你能夠知道它們會到來
實際上它們也會消失但是你不會知道它們已經結束了
而這裏是實際的delegate方法
這就是你與NSURLSession連接的方法
當文件完成下載之後就會調用此方法
正如我剛纔所言 我們需要立刻將文件複製以防它消失
以防系統將其刪除
這種情況下我們將獲取緩存目錄
因爲或許我們過一會可能會需要它
我們將生成一個URL
且我們用文件管理器複製從被傳遞進來的原始URL
即從位置URL到緩存目錄的URL
我們已經將其複製並跟蹤它以便以後使用
因此我們可以讀取你下載的任何數據
此外還有WatchKit connectivity框架
它實際上存在於雙方
比如你在它們之間共享數據
你可以在手錶和iPhone之間建立個共享的字典 
它讓你傳輸文件也是後臺運行
它也讓你從手錶直接向作爲父應用的手機app
向父設備iPhone上的父應用發送請求
明天將會有一個關於該話題的環節
我建議大家要去聽因爲它是新內容
而且是手錶和iPhone上都有的
那麼這裏有幾個遷移方面的幻燈片
對於已經開始開發watchOS 1 app的朋友
您多半已經見到過這個內容
watchOS 1的WatchKit擴展
是你們已經創建的東西或是你們的項目內一個目標
但是它使用了SDK中的iOS平臺
因此它存在於iPhone內而不是在手錶內
因此它讓你在手機上共享一個框架
那麼你可能有一些代碼是兩種擴展上通用的
比如從網絡上獲取你的信息
同樣的代碼在iPhone應用和手錶應用中4都能運行
因爲您無法直接讀取手錶存儲器
我們爲您提供了一種緩存圖像的方法即一張圖片和一個名稱
之後當我說“已對上述圖像命名”時
我們已把資源下載到了手錶上而且速度將會快得多
因此我們爲您提供了一種直接與應用對話的方法
顯然是從手機到手機的過程因此它是非常迅速的
藉助watchOS 2 我們已經添加了一種新的SDK
它是完全獨立的與iPhone和OS 10 SDK類似
它確實爲您提供了一套可用的iOS次級框架
雖然您不會獲得和手機上一樣完整的功能性
但是你也獲得很多便利
你可以在你的項目中加入一個框架
正如你在iPhone watchOS 1 app上所做的一樣 
但是這個框架是使用手錶應用和手錶擴展下載的
因此你不會在一個設備上共享代碼
但是它確實讓你仍然把網絡訪問代碼分離到一個單獨的
手錶可以使用的框架內
現在當然 比如說手錶對於你提供的手錶框架
可能使用NSURLSession讀取信息
因此如果您已經開發了一個WatchOS 1應用
您實際上已經做了很多準備以便接觸watchOS 2
它們同樣擁有有變化和添加的API 
但是您應該能夠不做任何改動編譯很大一部分
並且可以將資源複製轉移
因此如果在您的 WatchOS 1擴展內有圖像
您可將其添加到WatchOS2擴展的目標並將其複製到手錶上
但是你必須確保它們的大小被調整到適合於手錶
有幾項新的改進
當然主要的一點是您的手錶app運行於您的手錶上
擴展也是如此
而那意味着UI的反應性好得多了
您點擊一個按鈕它立刻做出反應
當然現在你也可以獨立操作而不必擔心手機就在附近
你不必擔心手機正在連接中或正在上網
我們也增加了幾個UI元素以及一些新的系統UI表單
我們將在本節講座或其他講座上談到它們
我們增加了動畫
因此現在您可以讓切換間的過渡實現動畫效果
如圖表或圖形的大小
或是類似的東西
或字符串的不透明度你可以使其具有動畫效果
就此內容明天會有一節專門講座
因此我建議您也看一下那節講座
那麼對於控件API大體上是相同的
你有相同的界面控件你會使用glance
沒有任何變化
而且通知也是一樣的
你無須做出任何改動
有幾個API已經不存在了
圖像緩存和open parent已被
替代爲直接讀取圖像和Watch Connectivity
福李斯特將提到兩個新的元素是extension delegate 
及在錶盤上顯示被用來爲complications提供圖像和文本的數據源
最後對於那些目前有Xcode項目的朋友
您需要做的是增加一個新的目標
可以在使用WatchOS 1的同時
請求增加WatchOS 2並向其中添加文件
將文件標記爲同一個目標的一部分
添加即將在手錶上被編譯並加載的框架
如果您願意
您可以從Xcode開始啓動一個全新的項目
而它將會自動創建iOS和WatchOS 2 app
因此您可以從那裏啓動填充內容
昨天有一節講座我建議大家看一下視頻
它們對這一過程的描述要詳細得多
我就講這麼多
現在讓福里斯特接替我繼續更詳細地討論新課程
以及現有API上發生的變化
我叫福里斯特是一名WatchKit工程師
我將跟大家談談
我們在面向WatchOS 2的WatchKit中增加的新的API
首先我談一下WK extension delegate
在iOS上我們有UI Application Delegate
作爲衆多方法之一它幫您跟蹤您的app的生命週期
這包括諸如你的啓動你變得活躍
以及你將停止活躍
我們已經添加了WK extension delegate
來跟蹤您的應用的生命週期
首先我將從application Did Finish Launching開始
當程序完成啓動及擴展完全未運行時它被調用一次
這可能是您的應用需要的初始化步驟
設置notification observer並預熱任何今後可能需要的服務的地方
重要的一點是注意此時您的應用尚未進入活躍狀態
接下來我們有application Did Become Active
每次你的應用被從後臺轉移到前臺或在第一次啓動之後
它都會被調用
這是個啓動任何僅需在您應用實際活躍期間運行的代碼的好時機
或激活任何您可能需要的定時器
尤其是更新在後臺或根本未運行期間已經發生變化的狀態
Application Will Resign Active
是在您的app停止活躍狀態並被移動到後臺之前調用的
您希望準備進入不活躍狀態
如果您已經啓動了任何定時器
這是一個使它們暫停的好時點
如果您選擇在此時不將其暫停
它們將不會在後臺運行你不會有後臺運行時間
但是你將會失去對它們的精確運行週期的控制
因此如果您想進行控制
當你不活躍時暫停它們是個不錯的主意
而當你真正變爲活躍時再將其重啓
而你希望在此時保存您的應用的狀態
因爲在此時間點之後系統中的另一進程需要那些內存
您的擴展將被強制終止
因此總的來說
WK extension delegate將跟蹤您的應用的生命週期
需要注意的是
這與通知UI Glance UI或complication數據
毫無任何關係
這僅與跟蹤應用的生命週期有關
接下來我講一下handle User Activity
Handle User Activity是個來自於WatchOS 1的現有調用方法
在WatchOS 1中它被用於應用啓動的時候
通過點擊您的glance而導航到您的應用內的適當位置
那也從glance得到反映
我們將在watchOS 2內以兩種方式構建它
首先它會在應用啓動時被調用
通過點擊您的complication啓動應用
任何你在Complication中反映的狀態將需要導航
到您的應用中該狀態對應的適當位置
此外我們將把它移動到 WK extension delegate
而不是我們過去所做的root Interface Controller
這會給你提供更大的靈活性讓你處理想做的事情從而實現狀態維護
那麼我們在一個名爲WK extension的新對象上進行新的調用
新的調用是root Interface Controller
我必須警告你它將來自於將來的種子而不是在現有的種子內
因此爲了暫時進行估算
您將不得不在您的界面控件的初建之時在其上進行節省
記住這一點後
你可能會暫時在WK extension delegate上
執行handle User Activity
我將通過新的調用取得新的根控件
並將跳轉回到根部然後我將請求根控件繼續運行並做出任何適當的操作
以恢復您的狀態
注意 這裏有很多你能做的其他事情
你可以建立模態警告或進行其他操作
以處理傳遞給你的用戶活動
接下來在IOS上我們有UI application
它是一個單獨的對象代表正在運行中的應用
所以在watchOS 2上我們添加類似WK extension的東西
其中這個是主要的界面用於打開標準的系統URL
因此 您將能夠打開開放系統URL API 
而執行諸如打電話 發送文本消息或顯示PassKit UI等操作
那就是開放系統URL 和WK extension
現在我將講一下關於通知的內容
首先我要說的是遠程通知
遠程通知來自於互聯網
而它們總是先到達你的手機
那時候你的手機將決定是否顯示通知本身內容
或將其繼續轉發直至它被顯示在手錶上
現在手機使用了一套規則而做出決定
而這些規則中的標準包括是否
您的手機屏幕已被上鎖
或是否您的手錶被戴在您的手腕上並且已被解鎖
因此諸如watchOS 1
您的WK用戶通知界面控件在接收到發給不活躍app的通知時便會運行
當發生這種情況的時候
其中的一個調用確實會收到遠程通知或者收到本地通知
它將會在您的控件上被調用
而您自行決定是否及時調用completion handler
如果您花費太長時間您的默認界面將被顯示
它有點不太生動
因此這由您決定是否在合理的時間內進行這個操作
接下來我將講一下本地通知
本地通知必須從手機上由您的iPhone app發出
但是你可以從WatchKit擴展向您的iPhone app發出消息
並請求它發出本地通知
同樣的邏輯也適用於遠程通知
對於遠程通知手機將決定是否顯示通知本身
或是否將其傳回給手錶並將其顯示在那裏
那麼讓我們來查看一個例子看你如何進行該操作
這裏我將使用watch connectivity 消息調用從手錶向手機app發送消息
當我的iPhone app收到那個消息時它可以發出本地通知
啓動常規邏輯 確定在哪裏顯示該警告
這是相對簡單的代碼
那麼現在我們可以在您的手錶上看到警告
我要講一下從您的通知UI啓動您的應用
從這裏可以用兩種方式啓動app
要麼你可以從通知動作按鈕啓動
在這個例子裏我已經通過回覆按鈕進行了設置
用戶也可以通過點擊左上角的應用圖標來啓動應用
當這些動作其中之一發生時
或者當用戶做了這些事情之一時
在您的WK extension delegate上會進行這些調用其中的一個
兩個handle action with identifier 調用之一將被執行發出遠程或本地通知
您將會收到被啓發的動作的識別符
如果它們點擊了應用圖標你將會收到一個 0
而對於遠程通知的情況你將會收到一個含有通知負載的字典
在本地通知的情況下 您將收到一開始就創建的UI notification對象
目的是爲了發出你的通知
那麼 這就是如何從通知啓動你的app
接下來我將談一下內嵌通知的文本回復
在iOS 9和watchOS 2中爲內嵌通知文本回復增加了第三方支持
在此例中 回覆動作已被指定爲發生文本輸入行爲
當用戶啓發此動作
而不是啓動app時
或向您的iPhone app發回一個信號時
用戶將被呈現一個文本輸入UI
因此您在此UI中可以看到用戶能夠啓動麥克風口述回覆
他們可以點擊表情符號圖標
以便從表情符號選擇器內輸入或者從一個提示列表內進行選擇
而你作爲app開發者將可以提供這樣的提示列表
而你實現這個的方式
就是通過執行這個
對suggestions For ResponseTo Action With Identifier的調用
它是在您的WK用戶/通知界面控件上的
因此一旦用戶選擇了
或提供了他們的文本輸入內容不管是通過您的選擇之一
或是其他某種方法
您的應用將被啓動
而你將收到這個handle Action With Identifier調用
它出現在您的WK或您的WK extension delegate上
您將注意到這個變量有一個新的參數即response Info
而response Info將包含
輸入的文本
用戶在UI User NotificationAction Response Typed Text Key內
那麼我將要講的另一個新特性是運行中的語言選擇
這裏您可以看到我們有標準的文本輸入
不管何時用戶啓動了文本輸入UI
他們都能選擇通過力度觸摸調出語言選擇器
語言選擇器將提供所有可用的語言
這些語言根據您在iPhone上提供的鍵盤而選擇的
那麼我將提供英語和西班牙語
那麼我將繼續進行切換到西班牙語
這將把文本輸入UI切換到西班牙語
並可以填充一個西班牙語提示列表而不是英語提示列表
這就是運行中的語言選擇
接下來我會談一下如何通過另一種方式處理通知
在watchOS 1中 不管您的app活躍與否
我們總會將您的WK用戶通知界面控件實例化
而系統將在屏幕的上方顯示出來不管屏幕上是什麼 包括您的app
在watchOS 2中如果您的app是活躍的 我們將不再那麼做
相反WK extension delegate
將會收到Did Receive Notification調用
您的app將決定如何適當處理和顯示通知的內容
比如說 如果你在編寫一個聊天app
您可能會把內容附加到聊天記錄的末尾
同樣系統將不再爲你顯示警告
因此如果您希望用戶瞭解出現了什麼樣的通知
您需要將其呈現在您的UI裏面
這個就是我要說的通知內容
接下來我將講一下模態警告
在WatchOS 1中
您可以取消隱藏羣組的隱藏狀態而顯示警告
在watchOS 2中我們允許使用present Alert Controller With Title 
這會讓對用戶呈現模態警告的操作變得容易得多
在這個調用裏面有三個變量第一個是警告
這是一個簡單的調用告訴用戶發生了某些事情
接下來我們有Side By Side Buttons Alert
這是當前在iOS中向用戶呈現二選一選擇的非常流行的方式
我們認爲第三方開發者也希望在他們的應用中使用它
最後我們談一下 action sheet
action sheet最多有四種動作外加一個可定製的取消動作
您可以看到Nevermind動作
我已經把Cancel動作定製爲Nevermind
各種動作可被選擇標記爲“毀滅性的”
我是通過delete按鈕實現的
目前那意味着它們將以紅色顯示
一旦用戶從Cancel或四個主要動作中做出選擇
您將會收到一個回調表明哪個按鈕被選中
因此總的來說 我們在watchOS 2中有一個新的架構
我們增加了WK extension delegate
幫您管理您的應用的生命週期
我們有大量的新API
而且當然還會有更多的到來
如果您希望瞭解關於安德魯和我剛纔在此所談內容的更多信息
請查閱文稿和示例代碼
而如果你有具體的疑問
請聯繫Jake Behrens地址如下
而且會有大量的相關講座
包括這裏將進行的下一節講座也就是我們的講座的第二部分
那麼非常感謝大家的蒞臨