00:00:20.954 --> 00:00:24.625 
Core Location中有什么新料

00:00:32.633 --> 00:00:35.836 
下午好 欢迎参加“Core
 Location中有什么新料”

00:00:36.703 --> 00:00:39.273 
我的名字是亚当·德里斯科尔
我是Core Location

00:00:39.339 --> 00:00:40.407 
框架团队的一名工程师

00:00:41.108 --> 00:00:43.343 
今天我很高兴为你们呈现这次会议

00:00:43.410 --> 00:00:44.978 
这是因为现在事情越来越复杂了

00:00:45.045 --> 00:00:48.916 
正如你所知道的我们现在有了
Apple Watch和iPhone

00:00:50.184 --> 00:00:53.020 
因此我们认为我们应该重点关注简化

00:00:53.086 --> 00:00:54.855 
我们怎样才能简化你们的任务

00:00:54.922 --> 00:00:57.057 
今天我们想给你们准备了一些好东西

00:00:59.126 --> 00:01:01.995 
你们中可能有人是第一次接触到
Core Location这个框架

00:01:02.062 --> 00:01:05.699 
我想我要先来给你们一个概述
看看我们做的事

00:01:06.366 --> 00:01:07.734 
看看我们的一系列API

00:01:08.535 --> 00:01:12.539 
用户也就是购买
你们的apps的人了解

00:01:12.606 --> 00:01:16.143 
Core Location
决定你们能否使用它的也正是用户

00:01:16.910 --> 00:01:19.112 
你不能冒险访问他们的位置

00:01:19.179 --> 00:01:22.482 
你需要请求权限 我们也有API
可以让你请求权限

00:01:24.751 --> 00:01:27.621 
之后我们还有“生活必需品”
也就是位置更新信息

00:01:27.721 --> 00:01:32.292 
你用来获取用户当前的位置的
就是API的这一部分

00:01:33.627 --> 00:01:37.531 
自从iOS 8开始我们引入了
室内获取地址的能力

00:01:37.598 --> 00:01:41.668 
这里的室内可以是像机场
购物中心这样的大型场所

00:01:43.937 --> 00:01:47.574 
并且我们还有统称为监视APIs

00:01:47.975 --> 00:01:52.646 
这些APIs可以允许你指定一件
你感兴趣的事件

00:01:52.713 --> 00:01:55.182 
这样当这个事件发生时
即使你的应用程序没有处于

00:01:55.249 --> 00:01:58.452 
运行状态也可以运行起来
以便获取相关的信息

00:01:59.520 --> 00:02:01.688 
第一个API是一个区域监视

00:02:01.755 --> 00:02:03.957 
这个API允许你指定一个
地理区域或者指定一个

00:02:04.124 --> 00:02:08.595 
基于iBeacon的区域
这样当用户进入或者离开

00:02:08.662 --> 00:02:10.631 
那个区域时你的
应用程序就可以后台启动

00:02:11.932 --> 00:02:16.170 
我们还有访问监视这是一种互补技术

00:02:16.236 --> 00:02:20.274 
这个API可以允许你指定当用户到达
或者离开某个位置时通知到你

00:02:20.741 --> 00:02:26.346 
而你无需提前知道这个位置是什么

00:02:26.647 --> 00:02:30.050 
它可以提醒多种类型的事项
如果访问监视设为

00:02:30.150 --> 00:02:34.354 
日志类型的事项时那么当我
靠近一个商店时就会提醒我买牛奶

00:02:34.421 --> 00:02:36.557 
我想知道我今天都去了
哪些地方做了哪些事情

00:02:38.091 --> 00:02:42.796 
我们还有其他APIs、
位置、地理编码

00:02:42.863 --> 00:02:46.433 
我今天就不展开讲了

00:02:47.467 --> 00:02:51.271 
我们也对许多这些区域API做了改进

00:02:52.105 --> 00:02:55.475 
不过我想专门提一提室内位置

00:02:55.542 --> 00:02:57.544 
室内位置更精确了

00:02:58.111 --> 00:03:00.013 
检测楼层的变化也更快了

00:03:00.380 --> 00:03:03.984 
最重要的是示例也被重写了

00:03:04.051 --> 00:03:06.553 
使用了MapKit因此就更简便了

00:03:07.054 --> 00:03:09.156 
如果你认为这个与你的用户有关系

00:03:09.223 --> 00:03:12.192 
那就去看看吧
对你来说把它用起来应该是很容易的

00:03:13.794 --> 00:03:17.831 
我们会把会议的大部分时间
用来谈论其中的两点

00:03:18.465 --> 00:03:21.134 
即授权以及位置更新

00:03:22.069 --> 00:03:25.739 
具体来说我们今天会分成四部分来讲

00:03:25.839 --> 00:03:27.941 
第一部分是后台位置

00:03:28.375 --> 00:03:31.011 
你可以用我们的API的
这一部分来记录

00:03:31.411 --> 00:03:32.346 
用户到过的位置

00:03:32.412 --> 00:03:35.482 
你可能开发了一款
跑步追踪app你的用户想要

00:03:35.549 --> 00:03:38.085 
得到一张他们的轨迹地图
或者是一款导航app

00:03:38.151 --> 00:03:39.920 
你想通过开启方向给他们指路

00:03:41.488 --> 00:03:45.959 
针对其它的位置使用案例
我们有了一些新的API

00:03:46.026 --> 00:03:48.228 
你只需要知道用户当前的位置即可

00:03:48.295 --> 00:03:50.831 
你不想有绘图能力
但是却希望用他们的当前

00:03:50.898 --> 00:03:52.999 
位置信息告诉他们最近的商店在哪里

00:03:53.166 --> 00:03:54.001 
诸如此类的事情

00:03:55.469 --> 00:03:58.372 
然后我们要讲讲授权
讲讲授权在OS 8上的变更

00:03:58.438 --> 00:04:02.142 
讲一讲现在有了Apple
Watch它又该怎么用

00:04:03.177 --> 00:04:06.079 
最后我们会深入讲一讲针对
Apple Watch的最佳实践的

00:04:06.146 --> 00:04:09.516 
具体细节希望如果你开始用的话
能给你提供诸多帮助

00:04:11.785 --> 00:04:13.787 
好 背景位置更新

00:04:14.087 --> 00:04:16.055 
我们决定不要了

00:04:16.390 --> 00:04:18.024 
开个玩笑

00:04:18.392 --> 00:04:20.961 
在iOS 2或者3上
幻灯片看起来是这样的

00:04:21.028 --> 00:04:25.032 
如果你是iOS 2或者3的用户
那么你就记得当你在跑步时

00:04:25.098 --> 00:04:28.602 
如果你想获得一张轨迹地图你必须让
手机在你的口袋内处于激活解锁状态

00:04:29.169 --> 00:04:31.805 
自从iOS 4开始借助于我们称之为

00:04:31.872 --> 00:04:36.777 
“后台方式”的操作方式
我们对此做了很大的改进

00:04:36.910 --> 00:04:40.247 
你的应用程序默认仍然是仅在前台运行

00:04:40.480 --> 00:04:45.018 
不过现在你可以在Xcode中
使用这个便利的功能标签

00:04:45.485 --> 00:04:48.188 
说你想在后台保持保持活跃状态

00:04:48.422 --> 00:04:52.426 
不被挂起以便于接受位置更新信息

00:04:53.694 --> 00:05:00.534 
然后它会在你的信息plist中
设置一个数值键

00:05:01.134 --> 00:05:03.136 
静态用于整个app
这个键就是UI后台方式

00:05:04.571 --> 00:05:06.740 
那么之后会发生什么呢？

00:05:06.807 --> 00:05:08.408 
我们稍后会来看一个视频

00:05:09.376 --> 00:05:10.777 
不过在那之前让我们看看...

00:05:10.844 --> 00:05:12.913 
让我来列出视频中需要留意的地方

00:05:13.347 --> 00:05:19.052 
它可以允许你...当用户使用
你的应用程序时启动位置更新

00:05:20.020 --> 00:05:21.989 
然后假如说用户感到无聊了

00:05:22.055 --> 00:05:25.926 
他们又去查看了邮箱
他们的音乐一个小的演示

00:05:25.993 --> 00:05:28.395 
也许他们会盯着主屏幕盯上一阵

00:05:28.896 --> 00:05:31.765 
但是在此期间你还是
可以访问用户的位置

00:05:33.267 --> 00:05:35.802 
之后用户重新启动了你的app

00:05:35.869 --> 00:05:40.040 
你就可以停止会话
停止访问他们的位置

00:05:40.107 --> 00:05:43.410 
这样就可以避免因为使用GPS
而损耗他们的电量

00:05:44.044 --> 00:05:46.180 
视频来了

00:05:47.714 --> 00:05:48.882 
用户启动了我们的app

00:05:49.449 --> 00:05:51.451 
中间那里有一个按钮表明他们希望我们

00:05:51.518 --> 00:05:53.320 
开始记录位置那我们就开始了

00:05:53.854 --> 00:05:57.624 
看视力表注意看正在计算数字

00:05:58.725 --> 00:05:59.826 
他们去过哪里

00:06:00.027 --> 00:06:01.595 
用户把我们的app切换到了后台

00:06:04.565 --> 00:06:07.801 
你可以看到现在顶部那里
就是我们称为蓝条的东西

00:06:08.001 --> 00:06:10.938 
蓝条表明我们的示例app
现在仍然处于运行中

00:06:11.104 --> 00:06:13.440 
这样用户就可以通过点击
这个蓝条返回app

00:06:13.574 --> 00:06:14.708 
用户刚刚点了蓝条

00:06:15.142 --> 00:06:17.578 
注意看视力表中的数字变大了

00:06:18.579 --> 00:06:20.647 
当然在视力表中还不算大

00:06:21.715 --> 00:06:24.017 
这就表明我们持续
接收到了位置更新信息

00:06:24.084 --> 00:06:25.953 
这是统计了我们接收到的位置更新信息

00:06:26.053 --> 00:06:27.788 
我们持续在后台接收到了位置更新信息

00:06:28.222 --> 00:06:32.192 
用户要求我们停下来
那我们就返回到起点

00:06:34.361 --> 00:06:36.797 
App开发者已经用这个打造了

00:06:36.864 --> 00:06:38.599 
很多很棒的体验

00:06:39.933 --> 00:06:42.636 
然后我们在想我们能否
再做些什么来对它进行优化

00:06:42.703 --> 00:06:44.438 
这里是否还有优化的空间？

00:06:45.806 --> 00:06:48.542 
在简化这个主题下你可以看到

00:06:50.511 --> 00:06:54.281 
一旦用户在你的应用程序中
选择了这项功能

00:06:54.581 --> 00:06:57.551 
那么它就有了一项责任
因为如果你持续在后台运行

00:06:57.618 --> 00:07:00.988 
用户就可能不知道这个还在运行

00:07:01.054 --> 00:07:05.058 
那么如果出现一个bug
或者在你的UI中发生一个

00:07:05.125 --> 00:07:09.429 
极端状况那么你就会在用户没有
意识到的情况下用去大量的电量

00:07:10.764 --> 00:07:13.634 
我们认为这个风险很高
我们想要降低风险

00:07:13.700 --> 00:07:19.072 
这样一个bug或者一个意料
之外的状况的后果也可以降低

00:07:20.307 --> 00:07:23.076 
你现在需要立即做的一件事
我们想要改进的一件事

00:07:23.143 --> 00:07:25.846 
就是当你的app
进入或者退出前台的时候

00:07:25.946 --> 00:07:30.484 
你必须与你的app经历的转移

00:07:30.851 --> 00:07:32.019 
进行紧密的耦合

00:07:32.085 --> 00:07:35.889 
一旦你选择开始运行
并且在后台使用用户的位置时

00:07:36.290 --> 00:07:39.159 
你必须告诉我们你不想去后台

00:07:40.127 --> 00:07:44.464 
也只有在这之后你才会进到后台中

00:07:44.531 --> 00:07:47.568 
然后就到了我们在视频这里
看到的这个视图

00:07:48.702 --> 00:07:50.971 
你在你的app中
可能已经看过这个视图了

00:07:51.738 --> 00:07:55.075 
我们对示例做了修改在委托回调中

00:07:55.142 --> 00:07:57.277 
停用了位置更新以便表明

00:07:58.045 --> 00:08:01.648 
它进到了后台中
蓝条一闪而过然后消失了

00:08:03.283 --> 00:08:05.352 
这可能会让用户感到困惑

00:08:05.419 --> 00:08:07.921 
你可以注意到这里的统一特征是

00:08:08.422 --> 00:08:12.125 
你注册要求能够以一种
连续的方式在后台校验

00:08:12.192 --> 00:08:16.830 
访问用户的位置但是这个却是以一种

00:08:16.897 --> 00:08:19.499 
全权委托的方式
为你的整个app永久实现的。

00:08:19.766 --> 00:08:22.402 
实际上你也仅仅希望在特定时候这么做

00:08:22.469 --> 00:08:25.105 
仅仅当用户在后台积极
使用你的app时这么做

00:08:26.373 --> 00:08:30.644 
自从iOS 9开始我们就有了一个
新的API可以帮你进行表达

00:08:31.144 --> 00:08:33.246 
这个API叫做“允许后台位置更新”

00:08:33.313 --> 00:08:36.549 
这是一项你可以在你的
位置管理器中设置的属性

00:08:36.950 --> 00:08:39.152 
如果你有多个位置管理器
那么在适当的时候

00:08:39.419 --> 00:08:41.788 
你就得分别对它们进行设置

00:08:42.722 --> 00:08:45.092 
你可以设置不同的
位置管理器为不同的值

00:08:45.726 --> 00:08:46.727 
设置好后起什么作用？

00:08:46.793 --> 00:08:48.795 
如果你把这个属性设置为“是”

00:08:49.296 --> 00:08:52.332 
那么你就选择了
在你的信息plist中

00:08:52.399 --> 00:08:54.968 
你请求的那种行为

00:08:55.469 --> 00:08:58.038 
如果你说你想要
继续在后台运行这种权限

00:08:58.505 --> 00:09:01.074 
你把这个设置为“是”
然后启动了位置更新

00:09:01.208 --> 00:09:05.012 
那么你就会保持在后台运行
并接受那些位置更新

00:09:05.612 --> 00:09:08.549 
而如果你把它设置为“否”
你就不会在后台继续运行

00:09:10.450 --> 00:09:12.920 
好的 那么关键的问题来了
默认值是什么？

00:09:13.053 --> 00:09:15.222 
设置时我们怎样才能知道？

00:09:15.856 --> 00:09:17.090 
默认值是“否”

00:09:17.925 --> 00:09:19.293 
我想再说一遍

00:09:19.760 --> 00:09:21.061 
这里的默认值是“否”

00:09:21.128 --> 00:09:24.264 
如果你的应用程序需要后台运行

00:09:24.331 --> 00:09:27.768 
以便记录位置轨迹或者以便进行导航

00:09:28.202 --> 00:09:30.771 
那么当你采用iOS 9时
你就必须进行变更才行

00:09:31.338 --> 00:09:33.607 
你必须到app中
看看用户是否同意你做这个

00:09:34.174 --> 00:09:37.978 
看看用户是否真的想让你
在后台记录一个会话

00:09:38.545 --> 00:09:40.914 
然后在那里把这项属性设置为“是”

00:09:41.582 --> 00:09:43.650 
当用户停止后把它设置回“否”

00:09:45.219 --> 00:09:47.554 
一旦你设置好后你就无需担心出现

00:09:47.621 --> 00:09:51.258 
直接案例时如何从前台过度到后台

00:09:51.325 --> 00:09:53.961 
这样当你被切换到后台时
你就无需急匆匆关掉

00:09:54.027 --> 00:09:56.330 
位置更新因为那时你已经配置成了

00:09:56.396 --> 00:09:58.198 
继续后台运行或者停止后台运行

00:10:00.601 --> 00:10:03.270 
好 因此如果你的app使用了
后台位置更新

00:10:03.370 --> 00:10:05.339 
那么你就必须进行变更

00:10:05.405 --> 00:10:06.640 
兼容性怎么样呢？

00:10:06.707 --> 00:10:09.076 
App Store中的app
会被中断么?

00:10:09.877 --> 00:10:13.480 
不会App Store中的app都
不受新规定的约束

00:10:13.914 --> 00:10:17.217 
但是当你采用iOS 9 SDK时
你还是需要尽快完成变更

00:10:19.253 --> 00:10:24.625 
如果你想支持那些不是最新最棒的
iOS上面的用户又该怎么办？

00:10:25.425 --> 00:10:27.127 
他们可能仍然在运行iOS 8

00:10:28.195 --> 00:10:29.930 
对此你可以按标准方式处理

00:10:29.997 --> 00:10:34.301 
在你的app上设置一个最低部署
目标然后运行时进行校验

00:10:34.368 --> 00:10:35.903 
对选择器做出响应，

00:10:35.969 --> 00:10:37.638 
看看你当前运行时遵循的位置管理器

00:10:38.238 --> 00:10:40.541 
是否有这项属性

00:10:41.675 --> 00:10:43.844 
在Objective-C中
看起来是这个样子

00:10:43.911 --> 00:10:45.445 
Swift中对选择器做出响应

00:10:45.512 --> 00:10:48.048 
我们在Swift中
有了一个新的高档属性

00:10:48.115 --> 00:10:49.650 
可以对此做出响应

00:10:50.717 --> 00:10:53.320 
如果运行时你的位置管理器懂得

00:10:53.387 --> 00:10:56.323 
与这项属性相关的知识
你可以把它设置为“是”

00:10:56.757 --> 00:10:58.892 
否则你就可以假定
它已经设置成了“是”

00:10:58.992 --> 00:10:59.860 
你无需再设置它了

00:11:00.294 --> 00:11:02.496 
坏消息是这也意味着
你无法把它设置为“否”

00:11:02.563 --> 00:11:03.463 
以便获取额外的保护

00:11:06.133 --> 00:11:09.436 
好 再简单讲讲侧边栏
因为我知道你们中的很多人

00:11:09.536 --> 00:11:13.574 
都对这种带有听觉提示的
后台位置更新感兴趣

00:11:13.974 --> 00:11:18.278 
当用户把他们的手机放在 
臂环上或者放置在他们的仪表板上时

00:11:18.579 --> 00:11:22.316 
，
这或许是与他们进行沟通的首选方式

00:11:25.085 --> 00:11:29.156 
自从 iOS 9开始core 
audio团队就引入了这个新的

00:11:29.223 --> 00:11:30.724 
长文件名的选项

00:11:31.225 --> 00:11:34.361 
它的作用就是你可以使用
这个选项来表明

00:11:34.428 --> 00:11:35.929 
你即将进行语音输出

00:11:36.296 --> 00:11:40.234 
这样系统就可以把你和用户
可能有的其它输出混合起来

00:11:40.601 --> 00:11:44.171 
这样不会把你混淆起来
但是可以把你和音乐混合起来

00:11:45.405 --> 00:11:47.508 
请去看看“Core 
Audio中有什么新料”

00:11:47.875 --> 00:11:51.411 
就是昨天举行的
如果适合你的话请去看看

00:11:53.447 --> 00:11:54.748 
后台位置

00:11:55.749 --> 00:11:58.418 
如果你不需要持续访问用户的位置时

00:11:58.485 --> 00:12:00.821 
那么，又该怎么办呢？

00:12:01.121 --> 00:12:02.422 
你不是想为他们绘制一幅地图

00:12:02.990 --> 00:12:05.792 
你只是想要告诉他们
他们当前所处的位置

00:12:06.960 --> 00:12:10.831 
自从iOS 9开始
我们就为此引入了一项新的方法

00:12:10.898 --> 00:12:12.132 
叫做“请求位置”

00:12:12.900 --> 00:12:16.303 
从根本上说
它就是把你过去为了实现

00:12:16.370 --> 00:12:19.439 
这个目标需要完成的过程给自动化了

00:12:19.873 --> 00:12:22.042 
如果你接触过
Core Location

00:12:22.109 --> 00:12:23.677 
那么你可能已经知道了规矩

00:12:24.111 --> 00:12:25.345 
你开始更新位置了

00:12:25.913 --> 00:12:28.749 
你看到那些更新信息
进到你的委托中来了

00:12:29.616 --> 00:12:32.352 
你可以注意到这些信息
一开始进来的很快

00:12:32.419 --> 00:12:33.687 
但是精度却不是最高

00:12:34.021 --> 00:12:35.923 
那么你就需要密切关注精确度等级了

00:12:35.989 --> 00:12:39.159 
弄明确什么时候精度足够了
什么时候没有获取更高的

00:12:39.526 --> 00:12:41.962 
精度的空间了
在继续等待和获得收敛精度

00:12:42.029 --> 00:12:45.399 
并使用那个精度的位置之间
进行正确的权衡获得了位置后

00:12:45.465 --> 00:12:47.668 
不要忘记停掉位置更新

00:12:48.969 --> 00:12:51.171 
我们会自动替你停掉位置更新

00:12:51.371 --> 00:12:52.673 
当你调用请求位置时

00:12:53.040 --> 00:12:55.742 
我们会开始自动获取位置更新

00:12:55.809 --> 00:12:57.878 
但是我们不会把它们给到
你的委托回调中

00:12:58.145 --> 00:13:02.783 
我们会根据你要求的精度
在内部取得它们的阈值

00:13:03.250 --> 00:13:06.653 
然后我们会用你需要的位置信息
回调一次你的委托

00:13:07.087 --> 00:13:10.357 
它会使用你的逻辑确定最佳位置是什么

00:13:10.924 --> 00:13:13.794 
在那个时候我们会自动为你停掉

00:13:13.861 --> 00:13:15.896 
位置更新这样你就没用忘掉停掉它

00:13:16.797 --> 00:13:18.298 
或者在那里出现bug的风险

00:13:20.167 --> 00:13:21.001 
好的 那么...

00:13:25.873 --> 00:13:28.141 
我对它的工作原理
对如何解释我们在幕后

00:13:28.208 --> 00:13:30.777 
所做的事有了一个较为直观的了解

00:13:31.044 --> 00:13:33.113 
你不能通过使用这个API来生成它

00:13:33.180 --> 00:13:35.282 
别忘了我们仅仅给了你一次委托回调

00:13:35.816 --> 00:13:37.751 
来看看它是什么样的

00:13:38.385 --> 00:13:41.688 
那个响铃表示的是
你设置的期望的精确度

00:13:42.289 --> 00:13:44.458 
你可以把它当成一个直径来看

00:13:44.558 --> 00:13:47.995 
你想要的固定精度应该比这个更严格

00:13:49.062 --> 00:13:52.933 
当更新信息进来时
我们要在地图顶部这里用曲线图来表示

00:13:53.267 --> 00:13:55.302 
现在你可以看到某个
位置的中心是用一个

00:13:55.369 --> 00:13:57.070 
看起来像是地图的黑色圆圈来表示

00:13:57.404 --> 00:13:59.640 
精确度等级是用一个大直径半透明的圆

00:13:59.706 --> 00:14:03.010 
来表示我们马上就可以看到

00:14:03.310 --> 00:14:05.512 
注意看随时间而发生的变化

00:14:06.680 --> 00:14:09.716 
第一个位置很快进来了
但是精确度不敢恭维

00:14:10.417 --> 00:14:11.852 
随时间推移越来越精确了

00:14:12.219 --> 00:14:16.557 
当精确度等级足够高时
我们就会接受这个精确度

00:14:16.690 --> 00:14:18.892 
给到你的委托回调的就是这个位置

00:14:21.161 --> 00:14:23.697 
好 我之前已经提到过
这个是可以配置的

00:14:23.931 --> 00:14:26.066 
可以配置你期望的精确度

00:14:26.366 --> 00:14:27.634 
那么该怎么设置呢？

00:14:27.768 --> 00:14:30.404 
好消息是我们已经在
位置管理器上有了一项叫做

00:14:30.470 --> 00:14:31.872 
“期望精确度”的属性

00:14:32.439 --> 00:14:33.640 
你可能已经熟悉了这项属性

00:14:33.707 --> 00:14:36.777 
你可以用它来控制开始更新位置时

00:14:36.844 --> 00:14:38.779 
你期望的精确度是什么类型的

00:14:39.279 --> 00:14:41.348 
它也同样适用于请求位置

00:14:41.982 --> 00:14:44.117 
让我们略微调低下

00:14:44.184 --> 00:14:46.653 
把它缩小精确度更高

00:14:47.621 --> 00:14:49.823 
现在可能又太高了

00:14:49.890 --> 00:14:51.825 
我们重新运行下模拟器
看看会发生什么

00:14:53.694 --> 00:14:56.230 
第一个位置我们可以看到继续在收敛

00:14:56.997 --> 00:14:58.765 
有时候你的收敛会出现回归

00:14:59.199 --> 00:15:03.370 
不过整体趋势是收窄直到
你达到某种平衡点

00:15:04.238 --> 00:15:08.809 
在这一点注意看我们尚未真正满足

00:15:09.009 --> 00:15:10.077 
精度标准

00:15:10.143 --> 00:15:12.045 
我们的精度没法再继续提高了

00:15:12.846 --> 00:15:15.782 
那么此时我们就会把这个返回
你的委托回调中

00:15:16.750 --> 00:15:20.921 
这就意味着当你在你的请求位置中
设置了一个期望的精确度时

00:15:20.988 --> 00:15:23.891 
你得到的位置的精确度可能会更高

00:15:23.991 --> 00:15:25.792 
对于精确度来说是一个更小的值

00:15:26.260 --> 00:15:29.162 
或者视我们获取的方式不同
精确度也可能更低

00:15:29.229 --> 00:15:30.764 
你可能运气好遇到了第一种情况

00:15:31.098 --> 00:15:34.201 
也可能出现了第二种情况
遇到了具有挑战性的情况

00:15:35.469 --> 00:15:39.840 
它们是在这个委托回调上发送给你的

00:15:40.073 --> 00:15:42.776 
位置管理器的位置管理器会
对位置进行更新

00:15:43.210 --> 00:15:45.646 
记住最后一个参数是一个阵列

00:15:45.879 --> 00:15:47.214 
我们只会给你一个位置

00:15:47.447 --> 00:15:49.016 
因此它就是阵列中的零元素

00:15:50.417 --> 00:15:53.120 
另一方面如果用户做了
任何他们想做的事

00:15:53.187 --> 00:15:55.856 
如果你请求位置的环境

00:15:55.956 --> 00:15:57.858 
是我们没法建立用户位置的环境

00:15:57.925 --> 00:16:00.861 
可能是在煤矿底部
我们就会在位置管理器上

00:16:00.928 --> 00:16:03.063 
回调失败错误

00:16:03.730 --> 00:16:04.898 
因此我们向你保证

00:16:04.965 --> 00:16:08.468 
只要你不中断请求位置你一定会得到

00:16:08.535 --> 00:16:09.970 
这两种回调中的一种

00:16:10.204 --> 00:16:12.072 
这样如果你愿意的话你就可以断开

00:16:12.272 --> 00:16:13.240 
某些应用程序逻辑

00:16:14.708 --> 00:16:19.813 
你从错误回调中得到的错误是
“KCL错误位置未知”

00:16:20.848 --> 00:16:23.917 
请求位置时还有两件事要记住

00:16:24.518 --> 00:16:27.354 
第一件事是开始更新位置是
和它互相排斥的

00:16:27.821 --> 00:16:29.790 
因为我们使用的是相同的委托回调

00:16:30.791 --> 00:16:33.760 
如果你已经有了一个
开始更新会话已经开始了

00:16:33.827 --> 00:16:37.097 
并且没有停掉那么
请求位置就会被忽略掉

00:16:38.565 --> 00:16:40.934 
另一方面如果你有一个活跃的请求位置

00:16:41.001 --> 00:16:43.403 
但是我们仍在收敛
我们尚未为你选定一个位置

00:16:43.871 --> 00:16:47.207 
而你又调用了开始更新
那么它就会接管过去

00:16:47.274 --> 00:16:49.443 
请求就会被取消

00:16:49.543 --> 00:16:52.045 
你也就会开始向委托回调发送定期更新

00:16:52.679 --> 00:16:55.249 
互相排斥 你一次只能有一个

00:16:55.349 --> 00:16:58.051 
开始有效地更新位置享有优先权

00:16:58.652 --> 00:17:01.121 
此外就是你可以使用停止更新位置

00:17:01.522 --> 00:17:03.056 
来取消一个请求

00:17:03.557 --> 00:17:05.592 
如果用户从你之前已经
请求了他们的位置的

00:17:05.659 --> 00:17:08.462 
地方开始导航
我们希望你停止更新位置

00:17:09.663 --> 00:17:11.698 
你对它们不再感兴趣了
我们也可以省点电

00:17:12.833 --> 00:17:15.868 
很好 我们今天为你们准备的
就是这两个APIs

00:17:15.935 --> 00:17:17.971 
这就是我们首先要讲的两点

00:17:18.771 --> 00:17:21.108 
那么我们现在再来谈论一个

00:17:21.175 --> 00:17:22.742 
你们都非常感兴趣的话题

00:17:22.809 --> 00:17:24.178 
也就是你们到这里要看的

00:17:24.344 --> 00:17:25.811 
就是Apple Watch

00:17:27.948 --> 00:17:32.853 
关于Apple Watch
要知道的第一件事就真的离不开

00:17:32.920 --> 00:17:34.922 
Apple Watch
和iPhone

00:17:36.190 --> 00:17:38.091 
这两种设备它们是一对的

00:17:38.659 --> 00:17:40.861 
它们彼此之间有直接的关系

00:17:41.261 --> 00:17:43.397 
我们想让它们密切配合

00:17:44.565 --> 00:17:47.167 
以便获得尽可能好的用户体验

00:17:48.001 --> 00:17:51.738 
还有一件事在某种程度上反映了
这种情况就是你把你的apps交付给

00:17:51.805 --> 00:17:52.739 
你的用户的方式

00:17:54.041 --> 00:17:57.678 
现在你可以编写watchOS
apps了 但是用户并不是通过一个

00:17:57.744 --> 00:18:01.515 
watchOS App Store来得到它们的
用户是通过现有的App Store

00:18:01.582 --> 00:18:04.084 
在他们的iPhone上得到一个包

00:18:05.385 --> 00:18:10.858 
当他们这样做的时候
如果他们配置系统来这么做

00:18:10.924 --> 00:18:13.927 
或者他们选择这么做
iOS就会把那个元件

00:18:13.994 --> 00:18:15.896 
送到Apple Watch上

00:18:17.231 --> 00:18:21.034 
你从中可以学到的就是
你的watchOS元件

00:18:21.101 --> 00:18:23.904 
和你的iPhone元件之间
同样也有紧密的关系

00:18:24.338 --> 00:18:29.610 
对于Core Location来说
它们就是一个相同的授权身份

00:18:30.511 --> 00:18:33.514 
因此如果你有了授权
无论是什么类型的授权

00:18:33.580 --> 00:18:35.716 
无论你处于什么样的状态
它都适用于两者

00:18:38.785 --> 00:18:40.387 
好 这是它的一个子话题

00:18:41.121 --> 00:18:43.790 
第一个授权有一些难题

00:18:43.957 --> 00:18:44.791 
我们会遇上的

00:18:45.726 --> 00:18:47.394 
第二个是协作

00:18:47.528 --> 00:18:49.830 
既然我们有了两种设备
你的app分成了两块

00:18:50.697 --> 00:18:55.035 
那么我们怎样让它们一起工作呢？
这里有一些最佳实践可以降低复杂性

00:18:57.838 --> 00:19:02.743 
好的 我们来快速小结下
确保我们在授权方面的了解是一致的

00:19:02.809 --> 00:19:04.244 
用户知道他们掌控着一切

00:19:05.212 --> 00:19:10.450 
因此你需要请求访问用户位置的权限

00:19:10.517 --> 00:19:12.686 
要么是通过使用中授权请求

00:19:13.153 --> 00:19:14.821 
要么是通过始终授权请求

00:19:16.056 --> 00:19:17.391 
“使用中”和“始终”

00:19:17.457 --> 00:19:19.092 
这些都是iOS 8上的新名词

00:19:19.526 --> 00:19:21.228 
它们是什么意思呢？

00:19:21.295 --> 00:19:24.364 
当你使用这些不同类型的授权时

00:19:24.431 --> 00:19:27.000 
你使用位置的能力
会发生怎样的改变呢？

00:19:27.634 --> 00:19:30.237 
希望这个表格可以帮助回答那个问题

00:19:31.238 --> 00:19:35.142 
在iOS上我们会考虑
哪个app请求了使用中授权

00:19:35.375 --> 00:19:38.712 
并且被授予了权限哪个app请求了

00:19:38.979 --> 00:19:42.115 
始终授权并且被授予了权限

00:19:42.683 --> 00:19:48.021 
先讲一下当你在测试上
签名后得到的三点东西

00:19:48.388 --> 00:19:51.058 
如果你有这些中的某种授权

00:19:51.124 --> 00:19:53.160 
并且用户点击了你的app

00:19:53.493 --> 00:19:54.895 
那么你能访问他们的位置吗？

00:19:55.128 --> 00:19:56.196 
答案是“能”

00:19:57.464 --> 00:19:58.866 
毫无疑问你已经知道这个了

00:19:59.032 --> 00:20:01.101 
那么我们来个稍微复杂点的例子

00:21:00.861 --> 00:21:02.896 
这个并不适用于需要
“始终”授权的apps

00:21:02.963 --> 00:21:05.132 
因此此类apps中没有事务

00:21:05.199 --> 00:21:06.300 
用户也没有预期

00:21:06.600 --> 00:21:08.335 
如果你请求“始终”授权

00:21:08.402 --> 00:21:11.572 
你基本上就是在请求全权委托

00:21:11.638 --> 00:21:14.575 
当你访问他们的位置时
用户并不期待知道这一点

00:21:14.641 --> 00:21:16.643 
我们不会给用户提示线索

00:21:17.644 --> 00:21:20.747 
好的 在这个例子中
我就是间歇地在后台中调用了

00:21:20.814 --> 00:21:23.884 
此时你就是通过后台
来访问用户的位置的

00:21:24.218 --> 00:21:30.090 
不过这与前台启动
或者与用例中已知的其它情况无关

00:21:30.357 --> 00:21:32.426 
这是一个后台app刷新启动

00:21:32.793 --> 00:21:35.529 
或者一个区域监视启动

00:21:36.797 --> 00:21:38.498 
在这个例子中要访问用户的位置

00:21:38.565 --> 00:21:40.334 
你就需要“始终”授权

00:21:40.701 --> 00:21:41.969 
这是因为用户并不知道

00:21:42.336 --> 00:21:44.805 
如果期待用户在“使用中”考虑你时

00:21:44.872 --> 00:21:47.274 
他们就不能直观地理解当前的情况

00:21:47.841 --> 00:21:50.744 
因此如果是“使用中”授权
你就无法访问Swift

00:21:52.679 --> 00:21:58.519 
好的  简单再现了下监视API
就是为了我们看到的这个

00:22:00.220 --> 00:22:02.823 
有个事实鲜为人知即在两个例子中

00:22:02.890 --> 00:22:04.758 
你都可以访问监控程序API区域监视

00:22:05.359 --> 00:22:08.295 
在使用UI本地通知时
如果你是“始终”授权

00:22:08.362 --> 00:22:12.766 
或者“使用中”授权
那么你就可以访问它

00:22:13.066 --> 00:22:16.537 
这里的通知包括一个触发事件CL区域

00:22:16.970 --> 00:22:19.573 
无论你何时进入或者退出那个区域

00:22:19.640 --> 00:22:22.309 
用户都会得到通知他们就
可以决定是否让你通过

00:22:22.676 --> 00:22:24.077 
用户的消息很灵通

00:22:24.244 --> 00:22:26.213 
他们可以毫无保留地知道当前的情况

00:22:28.148 --> 00:22:30.751 
那么对于watchOS来说
又会发生什么改变呢？

00:22:31.685 --> 00:22:34.488 
记住我们谈论的仅仅是
你的app的watchOS元件

00:22:34.555 --> 00:22:37.591 
而不是iPhone app
和Watch app的复合体

00:22:37.658 --> 00:22:40.961 
那么在Apple Watch上
你能做什么？

00:22:42.563 --> 00:22:47.134 
当用户在你的Watch app上
翻看时你可以访问他们的位置吗？

00:22:47.801 --> 00:22:51.972 
可以 但是还是需要延伸到后台

00:22:52.239 --> 00:22:55.509 
我们仅在watchOS上提供
这个请求位置API

00:22:56.243 --> 00:22:59.313 
你可以访问用户的单一位置

00:22:59.613 --> 00:23:01.515 
但是你不能启动一个后台追踪会话

00:23:01.582 --> 00:23:03.717 
你也不能在前台进行追踪会话

00:23:04.585 --> 00:23:05.419 
为什么？

00:23:05.686 --> 00:23:09.022 
Apple Watch是专门围绕
快速浏览而优化的

00:23:09.857 --> 00:23:13.293 
我们并不希望当用户在街区散步时

00:23:13.360 --> 00:23:16.930 
坐到那里举着他们的胳膊
盯着看很长时间让他们疲惫不堪

00:23:17.431 --> 00:23:21.602 
在Apple Watch上使用
请求位置API再合适不过了

00:23:22.469 --> 00:23:25.138 
这并不意味着你不能通过
Apple Watch

00:23:25.405 --> 00:23:27.207 
启动一个后台会话而是指用户不能仅仅

00:23:27.274 --> 00:23:29.543 
通过与Apple Watch的交互
就可以记录他们的跑步轨迹

00:23:29.610 --> 00:23:33.280 
我们还需要iPhone的配合
我们来谈谈到底该怎样做

00:23:35.482 --> 00:23:36.717 
后台间发

00:23:36.917 --> 00:23:41.221 
你的watch app可以在
后台运行的情况并不多

00:23:41.622 --> 00:23:43.590 
如果你发现你是在后台运行

00:23:44.491 --> 00:23:47.694 
那么只有你获得了“始终”授权
你才访问用户的位置

00:23:48.662 --> 00:23:54.101 
watchOS最常见的情况最常用的
表最相关的行中都没有

00:23:56.003 --> 00:23:58.972 
监控程序API不能用

00:23:59.673 --> 00:24:01.909 
你无法...
我们无法在Apple Watch中

00:24:01.975 --> 00:24:03.777 
后台启动你的app

00:24:04.178 --> 00:24:06.313 
不然要这些APIs就没有意义了

00:24:08.148 --> 00:24:12.052 
好 我多次提到了“使用中”这个概念

00:24:12.252 --> 00:24:15.522 
我们来深挖下看看它具体指什么

00:24:17.024 --> 00:24:21.061 
如果是在前台那么你的app
就被认为是在“使用中”

00:24:21.595 --> 00:24:24.031 
对于iPhone和Apple 
Watch来说都是如此

00:24:24.097 --> 00:24:25.532 
如果用户是正在活跃地翻看它

00:24:26.500 --> 00:24:31.572 
不过因为这种情况不多不需要持续更新

00:24:31.638 --> 00:24:36.810 
没有后台追踪Apple Watch
只在这种情况下才被认为是“使用中”

00:24:37.110 --> 00:24:40.781 
但是在iPhone上如果你有蓝条
那么你也可以被认为是“使用中”

00:24:41.348 --> 00:24:45.085 
蓝条意味着你启动了一个
会话并且会话仍在继续

00:24:47.054 --> 00:24:49.323 
那么这里统一的特征是什么？

00:24:49.389 --> 00:24:51.491 
我们怎样才能扩展到
Apple Watch中？

00:24:51.725 --> 00:24:55.462 
这两者都代表不同类型的你对用户可见

00:24:55.529 --> 00:24:58.966 
是的 更具体地说就是用户意识到了
你在那里处于运行中

00:24:59.032 --> 00:25:01.101 
正在代表他们做一些事

00:25:02.603 --> 00:25:04.905 
如果用户仅仅使用了
Apple Watch

00:25:05.272 --> 00:25:07.574 
Apple Watch就会给
iPhone发一条消息

00:25:07.641 --> 00:25:10.277 
让后者代替它做一些事此时

00:25:10.744 --> 00:25:13.714 
即使iPhone位于用户的口袋内
用户没有使用iPhone

00:25:13.947 --> 00:25:17.251 
使用状态也会传送到
iPhone app上

00:25:17.351 --> 00:25:20.287 
他们使用的是两者的聚集体整个复合体

00:25:20.587 --> 00:25:22.923 
授权是在复合层面进行处理的

00:25:23.423 --> 00:25:25.993 
你需要使用一个API发送消息
从而实现这一点

00:25:26.059 --> 00:25:28.395 
关于这个API我们稍后再讲

00:25:28.929 --> 00:25:31.465 
当你在iPhone上处理来自
Apple Watch的工作时

00:25:31.532 --> 00:25:33.100 
你就会认为是在“使用中”

00:25:35.536 --> 00:25:38.305 
那么首先你是怎样得到授权的呢？

00:25:39.339 --> 00:25:40.841 
授权是需求你请求的

00:25:40.941 --> 00:25:43.410 
我之前提到的两个API
请求“使用中”授权

00:25:43.477 --> 00:25:45.479 
或者请求“始终”授权

00:25:46.079 --> 00:25:49.216 
你可以通过iPhone来实现么？
通过Apple Watch来实现么？

00:25:49.449 --> 00:25:50.584 
还是两者都不行呢？

00:25:51.285 --> 00:25:52.553 
这些都很无趣

00:25:52.953 --> 00:25:55.889 
那么这个在iPhone上
看起来是什么样的呢？

00:25:58.759 --> 00:25:59.927 
用户会启动你的app

00:26:02.896 --> 00:26:04.932 
然后他们会做一些事表明

00:26:04.998 --> 00:26:06.400 
你需要访问他们的位置

00:26:06.466 --> 00:26:08.468 
然后你会意识到你还没有获得授权

00:26:09.002 --> 00:26:11.004 
你会调用请求“使用中”授权

00:26:11.171 --> 00:26:13.941 
你可以在对话框的顶部看到

00:26:14.441 --> 00:26:17.177 
发送给用户的请求

00:26:17.644 --> 00:26:21.248 
下面是你的使用描述键

00:26:21.381 --> 00:26:24.084 
你可以在你的apps信息
plist中对此进行设置

00:26:24.151 --> 00:26:26.153 
解释一下你使用用户位置的目的

00:26:26.220 --> 00:26:28.388 
我们希望你能认真解释一下

00:26:28.455 --> 00:26:31.124 
这样用户可以理解他们为什么
需要授权你们这项权限

00:26:31.191 --> 00:26:33.694 
用户可以理解你的设计折衷

00:26:34.995 --> 00:26:36.830 
在这个例子中你可以看到

00:26:36.897 --> 00:26:38.932 
这里的目的是为了演示

00:26:38.999 --> 00:26:40.467 
这个理由就很充分

00:26:40.834 --> 00:26:42.736 
此时就让我们允许授权

00:26:43.303 --> 00:26:46.607 
你可以立即看到位置更新启动了

00:26:49.910 --> 00:26:54.448 
好 停止后让我们把这个发送到后台

00:26:55.916 --> 00:26:56.984 
总结下我们看到了什么

00:26:57.050 --> 00:27:01.388 
当你通过iPhone请求位置授权时

00:27:01.955 --> 00:27:04.591 
iPhone会显示一个提示
这个提示你们都已经习惯了

00:27:05.826 --> 00:27:08.128 
不过要注意下Apple
Watch却什么也没显示

00:27:08.195 --> 00:27:09.630 
它在那里闲着没事

00:27:10.063 --> 00:27:12.165 
这是因为当用户使用他们的手机时

00:27:12.599 --> 00:27:14.635 
他们不太可能同时使用
他们的Watch

00:27:15.269 --> 00:27:17.371 
如果他们确实是在使用
Watch想看看时间

00:27:17.437 --> 00:27:19.773 
或者看看那里的那个app
我们不想阻止它

00:27:22.576 --> 00:27:23.944 
那么那时又该怎么做？

00:27:24.011 --> 00:27:27.214 
你可以通过Apple Watch
请求位置授权吗？

00:27:27.548 --> 00:27:28.782 
是的 你也可以这么做

00:27:29.016 --> 00:27:30.884 
它的行为略有不同因此你只有在特定的

00:27:30.951 --> 00:27:33.487 
环境中才这么做在其它环境中则不然

00:27:34.488 --> 00:27:35.822 
我们来看看这么做会发生什么

00:27:36.557 --> 00:27:37.791 
用户启动了你的app

00:27:40.961 --> 00:27:43.330 
然后他们导航到了你需要位置授权

00:27:43.397 --> 00:27:45.966 
才能满足用户的要求的地方

00:27:46.633 --> 00:27:49.102 
假设我们没有收到过授权
这是一次新的启动

00:27:51.738 --> 00:27:53.574 
你可以请求“使用中”授权

00:27:53.674 --> 00:27:58.445 
iPhone和Apple
Watch上出现了一个提示

00:27:58.512 --> 00:28:00.414 
Apple Watch
出现了一个告警

00:28:00.814 --> 00:28:03.550 
Apple Watch上的告警说到
“看看你的iPhone

00:28:03.617 --> 00:28:05.385 
你需要在那里处理一条提示”

00:28:05.719 --> 00:28:06.820 
上面也有一个关闭按钮

00:28:07.387 --> 00:28:09.389 
用户可以点它关闭告警

00:28:09.957 --> 00:28:10.791 
它不是模态的

00:28:11.024 --> 00:28:13.660 
当你有一个未处理的请求时
你应该期待看到用户

00:28:13.727 --> 00:28:15.929 
正在和app互动

00:28:17.064 --> 00:28:19.166 
这对iOS来说是陌生的

00:28:19.800 --> 00:28:24.505 
这并不算是对提示问题做出了回答

00:28:24.805 --> 00:28:28.709 
用户并没有放弃他们
在这里做出决定的能力

00:28:29.443 --> 00:28:30.511 
他们只是说“别挡路”

00:28:31.011 --> 00:28:36.316 
还是为了演示起见用户来到
他们的手机上授权给了我们

00:28:36.750 --> 00:28:40.888 
然后它很快就重置了

00:28:41.255 --> 00:28:44.224 
看起来并没有重置不过如果你
快速看一下我们得到了一个位置

00:28:44.391 --> 00:28:47.027 
你可以反复运行直到你得到一个位置

00:28:47.995 --> 00:28:51.465 
那么我们都看到了什么？

00:28:51.632 --> 00:28:52.733 
什么情况呢？

00:28:52.799 --> 00:28:56.103 
Apple Watch在Apple
Watch上启动了一个请求

00:28:56.403 --> 00:28:59.706 
Apple Watch显示了一条报警
这样用户就知道发生了什么

00:28:59.773 --> 00:29:03.377 
用户就理解了这个工作流程需要被中断

00:29:03.710 --> 00:29:07.881 
无论他们想继续什么
他们都需要先答复这个授权

00:29:08.482 --> 00:29:13.187 
同你已经习惯了的一样
iPhone会显示一条提示

00:29:13.320 --> 00:29:15.889 
重要的是用户需要在iPhone上
答复这条提示

00:29:17.758 --> 00:29:18.592 
好的

00:29:18.659 --> 00:29:20.827 
这个看起来有点不便
那么我们为什么这么做呢？

00:29:21.028 --> 00:29:23.730 
两条充分的理由

00:29:24.064 --> 00:29:26.066 
第一条我们真的需要你在那个

00:29:26.133 --> 00:29:29.736 
用途描述键中认真解释下你的用途

00:29:30.003 --> 00:29:32.472 
如果你解释过了那就意味着
用户需要在Apple Watch滚动查看

00:29:32.539 --> 00:29:33.807 
这个用户体验可不好

00:29:34.107 --> 00:29:38.245 
我们宁愿把这条提示的
大型屏幕真实状况显示在iPhone

00:29:39.112 --> 00:29:43.917 
我们想要让用户
控制授权的用户体验很棒

00:29:44.351 --> 00:29:47.554 
现在iPhone就是总体控制

00:29:47.621 --> 00:29:50.858 
位置授权以及隐私授权的根目录

00:29:51.425 --> 00:29:53.794 
我们想把所有的交互
都集中到iPhone上

00:29:53.861 --> 00:29:55.596 
这样用户就不会感到意外

00:29:55.662 --> 00:29:58.966 
如果用户愿意的话
他们之后就可以到设置中

00:29:59.032 --> 00:30:02.469 
隐私中位置服务中对设置机进行变更

00:30:04.838 --> 00:30:07.441 
好的 之前我提到过
请求位置就是我们现在

00:30:07.741 --> 00:30:13.380 
在watchOS上提供的直接通过
watchOS读取用户的交互的API

00:30:14.214 --> 00:30:16.416 
那么你可以期待什么类型的精确度呢？

00:30:17.818 --> 00:30:21.321 
如果你在Apple Watch上
发出了请求

00:30:21.622 --> 00:30:23.924 
那么视你手边是否有iPhone

00:30:24.291 --> 00:30:28.829 
如果你有那么你可以得到一切信息

00:30:28.896 --> 00:30:31.398 
甚至包括精确到米的室内位置

00:30:32.032 --> 00:30:35.569 
另一方面如果你没有
那么你可以据此制作原型

00:30:35.636 --> 00:30:39.006 
理解用户的预期
就像假如你指明了

00:30:39.072 --> 00:30:41.942 
一个请求的位置一样

00:30:42.009 --> 00:30:45.846 
请求期望的KCL一百米位置精确度

00:30:46.346 --> 00:30:50.384 
这个位置精确度不是最佳的
但是要记住

00:30:50.450 --> 00:30:52.819 
它的精确度往往要大于一百米

00:30:53.220 --> 00:30:56.890 
事实上如果环境理想的话
你甚至可以用它来绘制跑步轨迹

00:30:57.157 --> 00:30:58.992 
现在没有更新所以不要试

00:31:01.361 --> 00:31:03.163 
这里还有一件事要知道即“最佳努力”

00:31:03.564 --> 00:31:06.834 
因为Apple Watch的
网络连接状况不是很好

00:31:06.900 --> 00:31:08.836 
它可以处于假如说一个异常位置

00:31:08.902 --> 00:31:10.804 
用户对它的期望不高

00:31:10.938 --> 00:31:14.408 
甚至无法在用户的
环境中确定用户的位置

00:31:14.775 --> 00:31:16.844 
没问题 这是最佳努力的免责声明

00:31:16.910 --> 00:31:18.846 
不过还是很努力了

00:31:19.146 --> 00:31:22.950 
当我们手边有iPhone时
我们就可以加倍努力

00:31:23.283 --> 00:31:27.254 
使用iPhone来更多地了解环境

00:31:27.321 --> 00:31:29.189 
缓存一段较长的距离

00:31:29.523 --> 00:31:31.225 
比如说用户跑步那么除非

00:31:31.491 --> 00:31:34.862 
他们跑的步很远否则就没问题

00:31:35.195 --> 00:31:37.297 
不过当你试图为你的用户确定用途时

00:31:37.364 --> 00:31:39.700 
要把这点考虑进去

00:31:40.100 --> 00:31:42.870 
无论期望用户是
否随身携带iPhone

00:31:43.203 --> 00:31:46.006 
如果用户是在他们的家
工作场所或者某个他们

00:31:46.073 --> 00:31:48.008 
熟悉的场所附近使用你的app

00:31:48.375 --> 00:31:49.576 
那么大概他们就不需要携带

00:31:49.643 --> 00:31:52.746 
另一方面如果你期待
用户在旅行中使用你的app

00:31:52.813 --> 00:31:55.182 
或者任何用户关闭他们的
流量套餐 避免收到

00:31:55.616 --> 00:31:58.085 
天价话费账单时使用你的app

00:31:58.151 --> 00:32:00.921 
你都需要鼓励用户
随时携带iPhone

00:32:02.289 --> 00:32:03.690 
哪怕他们关掉了流量

00:32:05.726 --> 00:32:08.662 
让我们假设我们
手边有一台iPhone

00:32:09.129 --> 00:32:12.366 
如果你需要持续的位置更新

00:32:12.966 --> 00:32:17.437 
这在后台中很常见或者你需要区域监视

00:32:17.504 --> 00:32:21.141 
或者为了任何你能在
iOS上用 但是却不能

00:32:21.208 --> 00:32:26.079 
在watchOS上用的事情你就需要
你的iPhone进行协作来实现了

00:32:27.014 --> 00:32:28.015 
那么我们该怎么做呢？

00:32:28.081 --> 00:32:30.617 
有一个很棒的会议实际上就是在今天的

00:32:30.684 --> 00:32:32.886 
这场会议之前在这里举行的
就是午饭之前举行的

00:32:33.453 --> 00:32:34.588 
不幸的是它已经结束了

00:32:34.655 --> 00:32:37.324 
不过你可以去苹果全球开发者
大会app上面看视频

00:32:37.391 --> 00:32:39.860 
如果你之前参加了 很好

00:32:39.927 --> 00:32:41.228 
那么这就有点像是一个概述了

00:32:41.461 --> 00:32:44.831 
这是一个框架的一部分
与“位置”有很大的关系

00:32:45.966 --> 00:32:47.734 
首先是WC会话

00:32:47.801 --> 00:32:50.470 
这个类代表了Apple
 Watch和iPhone

00:32:50.537 --> 00:32:52.005 
之间的连接

00:32:52.606 --> 00:32:55.909 
上面有两个方法与我们的关系很大

00:32:56.076 --> 00:32:59.112 
第一个是SendMessage回复
处理程序出错处理程序

00:32:59.780 --> 00:33:02.149 
第二个是“更新应用上下文”

00:33:04.117 --> 00:33:06.720 
SendMessage回复处理程序
出错处理程序是双向的

00:33:06.787 --> 00:33:07.855 
你可以从任意一方发送

00:33:08.188 --> 00:33:10.958 
“更新应用上下文”
则必须通过iPhone启动

00:33:11.325 --> 00:33:13.694 
我们来看看它们在实际上
是如何为我们工作的

00:33:15.762 --> 00:33:19.066 
我们首先要使用SendMessage
回复处理程序出错处理程序

00:33:19.867 --> 00:33:23.403 
来从Watch app
向我们的iPhone app

00:33:24.738 --> 00:33:25.606 
进行通讯

00:33:26.006 --> 00:33:28.308 
用户导航到了app中我们需要另一端

00:33:28.375 --> 00:33:30.277 
提供帮助的地方

00:33:31.678 --> 00:33:33.013 
他们要求我们启动起来

00:33:33.747 --> 00:33:36.450 
我们把那个消息发送过去
你可以看到app启动了

00:33:37.451 --> 00:33:39.686 
蓝条也出现在了视频中

00:33:39.753 --> 00:33:43.457 
表明它可以进行持续的后台位置会话了

00:33:45.859 --> 00:33:48.795 
它可以把那个信息发送回去了

00:33:49.696 --> 00:33:52.032 
你就可以看到更新显示到了

00:33:52.232 --> 00:33:54.034 
watch显示器上如果不是太小的话

00:33:55.135 --> 00:33:58.005 
我们把它停下来把东西都收起来

00:33:58.138 --> 00:34:00.974 
可以了吧？然后我们就
可以回头看看那里发生了什么

00:34:02.009 --> 00:34:06.213 
关键一点如果你给iPhone
app发送了一条消息

00:34:06.280 --> 00:34:08.882 
而app当时不是处于运行状态
那么如有必要的话

00:34:09.081 --> 00:34:12.085 
它就可以通过Apple Watch到iPhone的
SendMessage启动起来

00:34:12.553 --> 00:34:15.188 
因此你就无需担心让用户启动app

00:34:15.556 --> 00:34:17.090 
他们可以把手机放到他们的口袋中

00:34:17.157 --> 00:34:18.257 
一切事情都会自动搞定

00:34:19.927 --> 00:34:22.529 
注意“使用中”状态传送出去了

00:34:22.596 --> 00:34:25.632 
我之前提到过这点
你刚才看到它起作用了

00:34:25.966 --> 00:34:28.368 
因为用户正在使用Watch
正在使用你的app

00:34:28.702 --> 00:34:29.937 
这就意味着它就有权在

00:34:30.003 --> 00:34:33.639 
iPhone上启动一个
后台位置追踪持续会话

00:34:34.308 --> 00:34:37.043 
这就意味着要考虑到这一点

00:34:37.110 --> 00:34:40.414 
允许位置更新标记属性

00:34:40.914 --> 00:34:42.983 
如果你想要启动一个持续后台位置会话

00:34:43.050 --> 00:34:44.585 
那就把它设为“是”如果不想

00:34:44.985 --> 00:34:46.119 
则把它设为“否”

00:34:46.453 --> 00:34:51.190 
当用户掏出他们的手机
并且在他们使用他们的

00:34:51.257 --> 00:34:53.994 
watch时偶然看到手机的话
他们就不会看到那个神秘的

00:34:54.194 --> 00:34:55.429 
蓝条进进出出

00:34:58.165 --> 00:34:59.333 
换个方向会怎样呢？

00:34:59.633 --> 00:35:01.935 
也就是从iPhone
到Apple Watch

00:35:03.904 --> 00:35:06.240 
我们还是可以使用SendMessage
回复处理程序出错处理程序

00:35:06.340 --> 00:35:07.841 
因为它是一个双向的API

00:35:08.909 --> 00:35:13.647 
当我们这样做的时候
你可以看到我们出了问题

00:35:13.881 --> 00:35:15.549 
我们的消息没有发送出去

00:35:15.682 --> 00:35:17.851 
实际上 在这个例子中发生的就是

00:35:17.918 --> 00:35:21.588 
因为Watch app尚未运行
我们每次这样做的时候

00:35:21.655 --> 00:35:23.790 
都要在我们的委托上

00:35:23.857 --> 00:35:25.626 
调用出错处理程序

00:35:25.926 --> 00:35:29.730 
SendMessage回复处理程序
出错处理程序是在app到手机

00:35:30.330 --> 00:35:34.568 
这种情况下启动的
而不是在手机到watch

00:35:36.570 --> 00:35:40.541 
这种情况下启动的

00:35:41.341 --> 00:35:45.012 
也许我们应该看看我之前
提到的其他API

00:35:45.212 --> 00:35:46.480 
“更新应用上下文”

00:35:47.214 --> 00:35:48.649 
这个就是手机到watch

00:35:48.715 --> 00:35:50.150 
我们可以使用这个API

00:35:50.551 --> 00:35:52.953 
当我们这样做的时候
就发生了一些不同的事情

00:35:53.720 --> 00:35:56.757 
我们的Apple Watch
app仍然没有运行

00:35:57.357 --> 00:35:59.826 
但是我们发送的消息挂出了

00:36:00.928 --> 00:36:02.496 
尤其是最后一条消息挂出了

00:36:02.763 --> 00:36:04.665 
你不想使用这种方法

00:36:04.731 --> 00:36:07.234 
来发送三角点更新但是你想要

00:36:08.302 --> 00:36:10.737 
发送状态更新整个上下文更新

00:36:11.004 --> 00:36:14.141 
当你这么做的时候系统会为你保持它

00:36:14.208 --> 00:36:17.878 
直到用户进行更新启动了你的app

00:36:21.582 --> 00:36:24.051 
好的你的app就运行了并且得到了

00:36:24.117 --> 00:36:25.452 
一直期待的更新

00:36:25.786 --> 00:36:28.355 
你可以看到如果你自己看
它已经知道启动了

00:36:30.123 --> 00:36:34.294 
你可以稍后通过你的
phone app发送持续

00:36:34.528 --> 00:36:36.096 
定期更新更新UI

00:36:36.697 --> 00:36:38.365 
初始状态已经就位了

00:36:38.765 --> 00:36:41.268 
更新应用上下文同样也适合

00:36:41.335 --> 00:36:43.871 
用来进行后续通信

00:36:46.807 --> 00:36:51.411 
好的 就整条从iPhone到
Apple Watch的路径来说

00:36:51.478 --> 00:36:54.815 
有一件事要提一提看看
我们引入iOS 6上面的

00:36:54.882 --> 00:36:57.050 
Core Location的
这个API叫做

00:36:57.417 --> 00:37:01.088 
“推迟位置更新直到行程超时”

00:37:01.722 --> 00:37:06.527 
这个API就是系统的某种天然补码

00:37:06.593 --> 00:37:09.730 
因为当用户不看
Apple Watch时

00:37:10.063 --> 00:37:11.598 
你就无需让它进行实时更新

00:37:11.865 --> 00:37:13.901 
你只要让它进行某种程度的更新即可

00:37:13.967 --> 00:37:16.503 
实现这一点的最佳方式是
对更新进行批量处理

00:37:16.637 --> 00:37:18.172 
偶然发送一次即可

00:37:18.405 --> 00:37:21.441 
这样你就无需让用户的
蓝牙广播时刻运行

00:37:21.508 --> 00:37:23.343 
我们也可以省点电

00:37:23.810 --> 00:37:28.815 
对于iOS来说
你可以在手机上把这个API

00:37:29.016 --> 00:37:32.085 
用于Core Location
以便表明

00:37:32.152 --> 00:37:35.422 
当前你运行在这样一种延迟容忍模式

00:37:35.856 --> 00:37:38.559 
除非用户经过了一段
特定的距离或者经过了一段

00:37:38.625 --> 00:37:40.260 
特定的时间否则你都无需被唤醒

00:37:40.627 --> 00:37:44.498 
也许他们走了一英里 这是他们的步幅

00:37:44.565 --> 00:37:47.234 
如果按照距离计算你超时了

00:37:47.301 --> 00:37:49.002 
已经过去了五分钟

00:37:49.069 --> 00:37:52.539 
或者你想要给你的Apple
Watch发送一个更新

00:37:55.042 --> 00:37:55.876 
好的 就是这个

00:37:56.376 --> 00:37:59.847 
我们已经允许了后台位置更新
这是一项新的属性

00:38:00.214 --> 00:38:02.683 
你需要对此采取行动
但是它可以让你免去

00:38:02.883 --> 00:38:05.786 
紧耦合和高风险的麻烦

00:38:07.354 --> 00:38:08.922 
之后我们得到了请求位置

00:38:08.989 --> 00:38:10.824 
这是一个新的方法位于C位置管理器上

00:38:11.191 --> 00:38:12.593 
它可以允许你删去一些样本

00:38:13.427 --> 00:38:17.598 
你们可能都用样本
并且在你仅需要一个位置时让你获取到

00:38:19.233 --> 00:38:22.102 
同时使用这两种设备的主题就是协作

00:38:22.469 --> 00:38:24.705 
好消息是我很高兴告诉大家

00:38:25.072 --> 00:38:27.307 
我们有了一个示例叫做potluck

00:38:28.075 --> 00:38:29.943 
其中演示了我们今天讲的所有的东西

00:38:30.010 --> 00:38:32.613 
实际上那个app就是我们用来
给这些视频做演示的

00:38:32.679 --> 00:38:36.183 
你可以自己安装然后运行它

00:38:36.583 --> 00:38:38.752 
希望如果你正在编写的app不工作了

00:38:39.052 --> 00:38:43.757 
potluck会帮到你
你可以找到问题

00:38:44.291 --> 00:38:45.325 
弄清楚是哪里出了错

00:38:47.327 --> 00:38:49.897 
这里有很多信息

00:38:49.963 --> 00:38:51.832 
我相信你们可以很快记一下

00:38:51.899 --> 00:38:54.501 
首先是当然也可能是最重要的
看看potluck

00:38:55.569 --> 00:38:57.971 
你可以通过这个链接看到示例代码

00:38:58.038 --> 00:39:00.474 
向下滚动直到你到达P节
那就是potluck

00:39:01.942 --> 00:39:04.578 
有一些会议我想它们都与你们密切相关

00:39:04.645 --> 00:39:08.515 
这些会议都已经结束了
不过它们的视频都在网上

00:39:08.615 --> 00:39:10.017 
待会儿你可以去看看

00:39:10.250 --> 00:39:14.488 
尤其是从顶端介绍
WatchKIt 2.0

00:39:15.055 --> 00:39:18.292 
以及介绍 Watch
 Connectivity

00:39:18.358 --> 00:39:23.096 
我最后提到的API就是它

00:39:24.198 --> 00:39:25.532 
没错。

00:39:25.732 --> 00:39:27.434 
我希望你们都去看看

00:39:27.501 --> 00:39:31.972 
我迫不及待想看看你们可以用
OS 9 watchOS 2

00:39:32.105 --> 00:39:34.708 
以及Core Location
能打造出什么东西继续加油