《LLDB最新内容》以自己的方式调试达至名利双收
下午好
欢迎参加《LLDB最新内容》讲座
我是凯特
我负责管理Xcode的运行时间分析工具
也包括LLDB
今天我来为大家介绍但我还带来
两位工程师
西恩和恩里科
他们会更深入介绍部分内容
但是开始之前我想谈谈
自上次WWDC以来  
今年的亮点有些或大
或小的改变
最著名的是...
我们推出首个Swift调试器
显然这是向前迈出了一步可以编写和开发
Swift代码 大家一定会逐渐熟悉并喜爱
但更重要的是不会就此为止
我们会进一步改善调试器
希望大家继续反馈
帮我们实现尽善尽美
与此同时
我们还推出了Swift REPL
它稍稍不同于标准请求回复REPL环境
实际上是伪装的LLDB
大家不仅可以通过REPL 在Swift中提出问题
还可以通过它来调试那些问题
你实际上是在REPL中设置断点
实现想在调试环境下
完成的任何事情
因为它是LLDB
如果还没有这么深入研究
我建议大家看看看这一问题的相关博客
但是 这不是...最终结果
之后 我们做了无数的改进
自从首次推出产品以来
我们已经在Swift
调试体验方面进行了百余项改进
而且我们还在继续提高Objective-C的调试体验
我们今天也会提到部分内容
不过只会介绍自去年起做出的改进
Swift类型起初并未显示出
继承了Objective-C域
我们后来对此作了更正
Help现在包括了指令别名
需要理解的是
因为当LLDB看似语法比较冗长
我们可能会让你输入help
实际上有许多快捷方式
在这次讲座中我们会使用下列符号来描述它们
Help实际上可以缩写为第一个独特序列
在这种情况下H就足以调出帮助
更重要的是对于更复杂的例子而言
如表达式-O--是指评价表达式
告知结果就像它是通过发送方法
来描述自己的一个对象
随后在该表达之后
并无其他选项
但你可以输入PO
PO是个方便的别名可以对左边的
所有内容进行速记
那么如果你习惯于用帮助
应该学习使用这些别名
因为它们可以最快捷地
帮你获得LLDB中的部分强大功能
我们还改善了数据格式
因为告知你相关的数据情况
对于调试体验而言是非常重要的
那么设置
和NSNS Index Path
目前就有了默认格式
可以帮助理解数据
而不是仅仅展示
底层结构的回收机制
表达式的Printf原型
如果曾尝试以Printf对它进行计算 可能会发现
有一些稍微可疑的结果
这是因为调试器对它
不了解的表达式
声明做了很多假设
而之前它在很多情况下也不了解printf
因此之前不知道它是个可变参数函数
也就是可以采取可变数量的特殊参数
也不了解特别是在64位设备上
如何正确传递这些特殊参数
这些都已得到改正这样所有的
涉及C和Objective-C的printf表达式
都应该另行执行
那么最后这次是真的最后
我们改善了分解格式
使其更方便阅读
来深入了解部分更有趣的改进
今年春天实现了断点改进
大家可能还没有意识到
具体而言 大家现在可以命名断点了
命名的断点可能会比其他断点
更易于使用这可能开始并不明显
不过 这些命名不一定具备独特性
可以对单个断点使用多个名称 这就很不简单
可以把它们想象成标签
所有的断点指令都使用这些名称
那么设置断点时可以提供断点设置
短线N 大写N
加上名称
还可以加上另一个短线大写N
和额外的名称等等
但更重要的是一旦为断点
或多个断点命名
我就可以对它们
通过所有其他的指令来操作
断点可以命名这会使得所有断点
都是可以共享命名或者就把它当作是标签
这其实非常有趣因为我们现在可以
实现在LLDBinit中设置断点
如果你还不熟悉LLDBinit
这是一种文件...
名前缀有个句号
会进入主目录
告知LLDB 这里有一束指令
每次打开LLDB会话都需要执行
如果这么使用则会在LLDB启动时
生成一组 默认断点
所有设置的断点在实际生成目标之前
都会被所生成的每个目标所继承
那么结合两方面因素
我可以在这些代码行编写LLDBinit
一组断点 -n都命名为malloc
一个断点 -n都命名为free
把所有断点命名为memory
然后再关闭
这就可以很方便的获得所有处理断点的内存
只要在我之后用到的
任何会话中输入
"breakpointenablememory"即可
这样就有了自己的一组非常方便的断点
我肯定大家会经常使用
现在可以给它们一些好记的名称
但是 当然大家在这里不仅是来学习
我们已经完成并推出的内容
还有我们刚开始预览的内容
Xcode 7
是个很重要的版本
包括许多改进
最重要的是表达式求值
西恩会为大家详细介绍这方面内容
Swift 2支持...当然...
语言会不断发展以及Objective-C 
支持模块的高级处理
这些内容我们也会深入讲解
但是部分内容其实就在后台
如果继续深入研究你可能会注意到
例如在Xcode 7中
大家都知道模块
我们实际上可以在为模块构建调试信息一次后
再不必在其他位置重复进行
这可以大幅减少调试信息的
数量 并提高汇编的性能表现
一旦进入实际的.dSYM文件 
这个.dSYM文件就会
将你所需的所有内容都包括在内
但是其中还包括部分其它优化
例如 不为C++类型复制信息
这多亏了定义法则的规定
否则我们会有多个副本
实际上 我们看到调试信息
要比Xcode 6中少了1/6
特别是对C++项目更是如此
我们还在多方面改进了数据格式
在Objective-C和Swift中矢量类型有着
独特的自动数据格式
也许更重要的是
如果有Swift自定义类型
现在可以自定义它们的表现方式
只要编写Swift代码即可
恩里科会介绍更多详情
我们还在LLDB中整合了地址消毒剂支持
那么地址消毒剂不只会在
参考内存无效时会告知
你还可以针对内存提出问题
比如可以问例如 内存历史
从LLDB控制台了解它分配到哪里
以及何时释放
那么你可能想了解更多
指令的内存系列并想知道相关帮助
我们还增加了类型查找指令
类型查找指令可以获取
系统的任何类型信息
基本上 这就是个类似头文件的表示
可以在调试器中获得
以便提醒你类型的内容
因此 从LLDB提示中
我只需要把类型变为"type lookup"随后加上
类型名称 然后我会获得类型快速说明
本例中 新的错误类型
用于Swift错误处理机制
我知道 在幕后
通常会执行一对
一般已执行了的属性只要使用EDAM类型即可
但是不管怎样 都可以从控制台看到细节详情
同理 如果我感兴趣"Comparable"类型
是个协议
它会告诉这个协议实际上是来自另外两个
这样你会看到我们从Equatable
<br/> 得到了等号运算符
下划线Comparable 可以提供小于比较
而导出运算符是Comparable协议的一部分
这里还可获取许多便捷信息
和所有内容一样
提醒你不必输入完整命令"type lookup"
TY空格L便足以使用这个指令
但是要想知道更多详情
特别是谈到怎样计算表达式
我想有请西恩•卡拉南[
大家好
我来讲讲LLDB中的LLDB
大家可能会觉得
有那么多编译器会话
为什么要在乎编译器？
编译器是LLDB的关键内容
会使得LLDB功能强大
会令LLDB简单易用
它的强大是
因为编译器对程序运行
对配置数据的方法
以及当你说想看看
这个变量或调用函数时等 
有着独特的理解
编译器很重要还有一个原因是
它们可以与调试器轻松配合使用
如果想要打印
只要使用你熟悉
输入的代码
交给表达式指令
编译器就会从中拿到指令
今天
我来讲讲在编译器整合方面
有两个重要
相关领域
获得了的改进
首先
有个好消息要告诉各位
长期从事Objective-C 的开发人员
接下来
我要告诉...
Swift开发人员
希望现在各位都是
聊聊...
我们所做的这些改进
现在就开始讲讲Objective-C
LLDB
包括...
两个独立的编译器
Clang
强大的Objective-C编译器
当然 从去年起
是Swift编译器
我们的Objective-C编译器支持
多年来一直在改进
我们加入了非常出色的新功能
比如
Objective-C运行时间整合
那么 如果Objective-C运行时间有部分信息
并未显示在调试信息中
我们知道该向编译器提供
这样可以使用很多类
而不必特别做些什么
当然 去年
我们在LLDB中
引入了Swift编译器
Swift编译器已经是
是很强的工具
我们把从Swift编译器中
整合所学内容都用到其中
我们对二者都做了改进
我们来谈谈
表达式剖析器与Swift
怎么配合
从Objective-C的角度
我们现在来看简单的打印指令
这里说到打印 因为我用了p快捷方式
实际上是指
表达式
注意短线 
这是指
在p指令编码后的所有内容
不能这样把额外的选项交给指令
这里有其他方法恩里科会给大家介绍
而且凯特刚刚给大家看过
这里是些循环运行的简单代码
并会每次打印出循环计数
的确 如果运行它
你会得到自己预期的数字
这个功能好在哪里？
LLDB和程序是单独的进程
LLDB内部有swift编译器
程序已经在运行
但是有了LLDB的帮助
Swift编译器可以把你刚输入程序运行的
代码添加进来
如果喜欢打印...
循环计数器 这就相当棒
但是还有要调试的内容
Swift可以和变量配合
输入一些代码
数组的内容就打印出来
现在 这里的数组
正好有一些在程序中的代码
LLDB安排在编译器上...
显示数据 
这样可以生成你所需的代码
我还想简单...介绍一下
就是Swift怎么和SDK配合
当你输入NSApplication.sharedApplication
这样的表达式时 
首先 你会看到
NSApplication.sharedApplication
是按照预期的方式
但是LLDB要去
发现包括它的SDK模块
让编译器可以访问它
然后编译器找到NSApplication
并想出如何使用sharedApplication
这非常好
而且都是在Swift中...
自动完成
在Objective-C
它并非总是工作
让我们在Objective-C尝试所有这些
有些人此刻可能有些担心
因为你知道 NSLog有时并不像
调试器中那么简单
过去 当输入NSLog时
会看到像这样的错误提示:
NS日志存在未知返回类型
这是因为在SDK肯定会
存在NSLog的定义
但是LLDB发现
符号中只有调试信息中的内容
在本例中它看到一个符号
这个符号 我们不知道它的返回类型是什么
我们甚至不知道它还用了格式字符串
好消息是问题已经得到解决
NSLog是按照预期的方式工作
我们再做些更隐秘的内容
打印NSMakeRect
稍等！
为什么是隐秘的内容呢？
就在这里框架中
可惜的是看似标识符并不存在
现在大家就会了解如果使用NSLog
可以转换结果
对 可以这么用
但是NSMakeRect不能这么用
这是因为
NSMakeRect是确定的NS-Inline
没有符号
LLDB什么也看不到
不错
没问题了
还剩一个问题
我们现在来看
原先NSApplicationsharedApplication
的情况
当然 若你是自己运行这个表达式
当然会在Objective-C中运行
我们已经在为Objective-C运行时间整合
做了很多工作
但是如果想找出undo.Manager 
你很快会发现运行时间并未告诉你所有内容
特别是你发现的这个关于undo.Manager的
奇怪错误提示在类型id对象中并未发现
是什么情况？
在SDK肯定
sharedApplication会返回一个
NSApplication星级
但如果来看运行时间
返回的是id
是个一般的
Objective-C对象
好消息
这不再是问题了
实际上 我们会看到只能从SDK得到的信息
例如指针为可空值
这就是SDK支持Swift的最新功能
也会进入Objective-C
不过信息就在这里
这就是我们所应用的理念
从SDK直接读出
代码会一直在LLDB中运行
我们了解本地变量函数 自己的类
SDK函数另一方面
我们还有更多问题 如大家所见
SDK类就像NSView和NSApplication
我们看到了 但是如你所见
因为运行时间整合
这里有个小星号
现在SDK包括如果你试着在表达式用过
NSASCIIStringEncoding
就会了解这永远不行
如果使用宏 如int-max
那么 max
利用两个数字中最大值
这样也不会奏效
所有这些在最新的LLDB中都已解决
我们也删掉了烦人的星号
大家可能会说那么每月要付多少个39.95才能用上
这个功能呢？
好消息 这完全免费
你只需要@import AppKit即可
运行一个表达式
表明输入我关心的框架
如果用到AppKit 或是在诸位中间的
两三位...
iOS程编写人员
输入UIKit...
就可以了
现在
我们并未将Swift放在那里不管
Swift2.0可实现强大的错误处理支持
LLDB马上就可以支持the bat
正如大家所期待的那样
我们可以处理Swift错误
当调用可能在
表达式引发错误的函数时
你不必调用"try"
因为...
我们为大家抓取内容
如果你输入
这个函数"throws"
并把它交给表达式
注意这和p指令完全一样
你会获得
为你生成的...
错误变量 
其中包括函数引发的错误
也可以在REPL中...完成这些
如果从REPL提示中你做了同样的事情
则会得到...错误变量
我们再来看看LLDB支持的...
更多内容
也就是说 你不希望总是看到
最后出现的是错误
你需要了解产生错误的代码是什么
不过 在Objective-C中
你用到了断点来完成
具体而言你在Objective-C异常中设置了断点
方法是...
你用了断点来设置指令
确定了希望为...
异常Objective-C...
设置断点
我们来为你设置了断点
那么一旦Objective-C代码
要引发异常
我们就会停下来
在Swift错误中你可以做同样的事情
只要用Swift替代Objective-C 
我们就会停止程序要...
引发的...
Swift错误
但是还可以...
做另一件很酷的事
你可以停止具体的错误类型
这是我们支持Swift的一个功能
这么做的方法很简单
和你在设置表达式断点非常相似
可以使用短线O参数
来明确你希望捕捉的
错误类型名称
如果这么做那么只有在出现
你感兴趣的错误类型时
才会停下来
最后
当然
你可以按照正常代码中...
的方法捕捉错误
毕竟 部分而言
REPL是指了解和发现语言运行的方法
如果输入Foundation
来获取NSError
然后编写会产生NSError的代码
就可以捕捉NSError...并打印出来
如果这么做
结果就和你在自己的程序中
捕捉的效果完全相同
我希望大家...
记住两点
首先
添加输入...
自己的模块
第二
试着用LLDB进行错误处理
这是个不错的办法
要想了解更多详情
不是说告诉程序该做什么
而是如何在程序产生资料完成后打印信息
有请恩里科·格拉纳塔
大家好
上午我还在实验室
我们在想办法解决一个问题
问题是...为什么我看不到这个变量？
出什么事了？
为了帮助大家找到问题
我们试了几个指令
试了表达式 还有PO 我们还试了帧变量
此刻 人们通常会问
为什么有那么多指令来做几乎相同的事情？
来看我的数据看看程序中在发生什么
大家来这里就是了解内部消息的
我们来看一下LLDB让你看数据的指令
共有三个
帧变量
表达式指令
是个p指令
表达式 短线大写O
这个...
刚才讲过
是作为PO指令
首先
帧变量指令
帧变量指令可以缩写为frv
输入时 基本是Xcode变量视图
它让你...看所有的本地变量
让你看...
几个本地变量
此外
也可以应用...
带有短线 短线格式旗标的格式
要强调的一点是
因为在看到首次输出时
有Tuple的话我会回到这里
这是个...
聚合
是包括其他对象的对象
聚合当中的内容
我们称之为...
子对象
这个表达式指令
在本次会话中你会多次看到
我会简要介绍一下
当然
有了表达式指令
可以简单算一下正如你猜测的一样
完全可能...使用之前的结果
并用它们完成更多内容
当然 表达式指令也知道如何
自定义结果的格式
需要再次强调的一点是
子对象
第三个指令
po指令
这个可能是...在座各位Objective-C开发员的指令
我猜测在Objective-C代码之前
大家都知道是PO指令
你可以生成对象把说明打印出来
可以生成NSArray或打印现有的NSArray
你就会看到其中的内容
要知道
对于字符串而言非常简单
那么
三条指令
它们并非是完全一样的功能
大家估计此刻也猜到了
实际上
它们只是有些相似
但不是完全相同
例如
表达式指令和po指令
是..."run my code"指令
无论代码类型是什么
这些指令都会运行
但是 接下来的帧变量指令
和表达式指令第二步则不相同
当它们不得不显示结果时
会用到LLDB格式器系统
我们在以往的WWDC讲座中
介绍过LLDB格式器系统
大家应该都去找来看看
不过简单而言
LLDB掌握部分嵌入系统类型
并对其自动格式化
NSArray NSDictionaries加字符串
还可以提供...在Python中编写的自己的格式
另一方面
po指令并不使用LLDB格式器
po指令在...后面在幕后
运行更多的代码
实际上会生成为
为你显示的真实结果
你可能已经在一个Objective-C类中
至少编写了一个说明方法
然后意识到这就是po打印的内容
现在
我希望大家想一想
这两个模型
实际上在用你的对象并为之生产数据
LLDB格式器模型
我们称之为
"out of process"格式模型
为什么呢
因为格式器位于进程之外
它或者将内容构建到调试器中
或者你用部分Python脚本表现对象
这是不同的语言不同的文件
存在于不同的作用域中
另一方面
外部格式器位于调试器中
这就很容易...
让他访问调试器所具备程序的所有内容
就像是可以鸟瞰所有进程
因此 这类格式器也可以很容易...
确定程序状态并未改变
你若是看到调试器中的数据后
不想改变程序状态
调试器相当于是阶段...
检测器
它来看内容并试图不做改变
在另外的模型中
po模型
writeadescriptionmethod模型
是个进程格式模型
你同时编写数据和格式器
再用相同的语言编写一遍
可能甚至都在相同的文件中编写
因为格式器是在应用中
运行的代码
可以轻松并完全
访问应用的对象模型
但是功能更强大
责任也更大
需要确保格式器
并没有改变程序的状态
要确保并未在格式器中...
对准备表现的对象做了任何改变
那好 Objective-C
具备进程进程格式模型
我可以编写说明方式
调试器会用到
那Swift会怎样？
结果是 演讲厅里在座的各位
又一次知道了内部消息
从一开始Swift已有了
进程格式模型
但是 在哪儿呢？
怎么用呢？
希望大家都用过Swift开发环境
如果用过Swift开发环境
那就用过进程格式模型
从一开始它就在这里
那有什么新奇的呢？
现在 在Xcode 7我们会采取完全相同的模型
把它作为公共API
大家可以使用它
它仍然支持...开发环境
不过现在也支持LLDB po指令
现在 你有着正确的Swift格式器
针对Swift对象
怎么弄？
我们来详细讲一下
这个模型基于...
4个协议
这些是各自的名称
对 我说是四个协议
它们的名称相当长
但是...我不会过分担心
可能是这个模型的可选项
4个协议
并非是指必须符合所有要求
可以选择子集来获得所需要的结果
符合使用的协议部分
就可以了
我们来看一下协议
CustomStringConvertible
是协议名称
表示...
怎样把对象作为字符串打印？
它并未告知LLDB
它还告知了Swift
怎么弄？
Swift打印功函数
以及Swift字符串插值功能
二者都用了CustomStringConvertible协议
非常好用
实现这些很难吗？
非常简单
我有个数据结构代表啤酒歌的瓶子
因为我自己正在准备bash脚本
我想把歌词打印出来
就生成了一个实例
并看墙上有多少啤酒瓶
但是要等到app的...
所有内容都没问题的时候
如果我做调试也许我需要更多信息
那就需要Custom DebugString Convertible
这是调试器对这个对象的具体表示
调试器具体表示是什么
则要取决你的app
完全取决于对象模型的语义
但是作为提示
debugPrint函数
将默认选择这个协议
当然
打印和debugPrint 
不会满足其他一致性要求
如果它们的兴趣点不在此
怎么运行呢？
很简单
我们把啤酒瓶进行扩展
因为我们在做调试
希望了解墙上啤酒瓶的更多信息
这样我们可以确定啤酒类型是否正确
这就会成为不错的bash脚本因为它们都很出色
第三个协议
是CustomPlaygroundQuick Lookable
正如名称所示
这个协议是主要为环境而定
是指为环境中的对象提供
丰富的图形表示
想要看举例吗？
当然有
我可以编写代表一个人的数据结构
然后我可以获得一个人的描述
在环境的侧边工具栏显示
以此作为生成这个类型对象的结果
不好意思让你们失望了
我的确想做成的
但是 大会上不会销售
带有人像的T恤衫
不好意思
不过 我有个弥补的办法
其中最后的协议
CustomReflectable协议
它可以让我生成完全自定义的
子对象层次
好 我说过 我会回到"children"这里 说到做到
当我说到完全自定义子对象层次时
我是说
我可以做个新的...
我可以为对象制作新的结构
可以告知语言可以告知调试器
可以告知环境
我的对象实际上是用什么来造的
大家会看到
你做此事的方法
交易用的货币
在想要对Swift描述对象的结构时 
被称为
Mirror
可反射的镜像
我们来看个例子不要费时费事
我有个应用用来
搜集温度样本
它有两个数据结构
一个用来描述
此刻的时间
它说在给定的时刻
这就是我得到的温度信息
接着当然我们获得温度样本
现在我来调试app
我想看看是什么情况
怎么来处理样本
所以我提出
po温度
我得到的是这个
实话讲 我看着它觉得
作为默认值还不错
不过 我立刻发现我想调整两个问题
为什么在把时间堆在两行？
我想把所有内容都放在一行
而且如果是用a.m.p.m.格式
表示上下午最好
还有温度
我看着它 觉得
标度是什么呢？
我不知道
是开氏列氏还是兰氏温标？
我们在美国想用的是华氏温度
好消息是我们可以用两步骤
解决所有这些问题
开始
第一步 我们把时间按照一行打印
我做了这些来实现这一点
用了NSDate格式器
因为我要在...自己的应用中运行
因为我运行的对象格式代码
实际就是正常的Swift代码
就是我通常编写app
所用的代码不论是什么框架
什么库
还是我的app完成任务通常所用的技术
我在格式器中用就好了
在本例中 是NSDate格式器
第二步
选用华氏温度
怎么实现？
我们生成镜像
好了
现在我们可以说温度数据对象
是作为包括三项内容来构建
时间 摄氏温度
以及华氏温度
时间是存储在对象内部的
真实时间数据的字符串插值
因为是用字符串插值
因为我们提供了自定义字符串可转换一致性
这些可以自动提取
这里还要注意的一点是
当我获得两种温标用摄氏度
和华氏度来进行结果打印
我不能改变存储在对象内的数值
当然 你会说 不要改
实际上 要注意的是
不要用编写进程格式器的
方法改变程序的状态
现在我们做了这么些工作得到了这些东西
会怎样从中受益呢？
我们可以试着再做po
来吧
现在我再来看
我看到了对象
可以看到现在是
6:30 p.m.
是93.2度
大家可能会奇怪 的确
昨天库柏蒂诺是很热
现在我们完成了但是这么做
是因为我们很聪明提前完成了工作
有时 我会试着调试一些内容
把自己的程序调试到位
结果有这样一个很难复制的问题
最后发生了
不过现在真的很难找到这数据
数据非常令人头痛非常很复杂
真希望自己之前做过这事儿
这样我就可以更简单地看待我的数据了
不过 可惜没有
所有的希望都落空
不 没有
还可以添加一致性和运行时间
通过表达式剖析器 可以添加这些一致性
并运转 同时调试你的app
另一方面
你还不能改变它们
现有的一致性保留
你在REPL做尝试
你真希望自己能做po
我希望自己能添加一致性
在REPL中也可以这么做
当然 但是我确定大家都期望这样
为什么？
在环境中 也是如此
来看
看似...
我们在过去一年在调试器方面
所做了许多动作
你们从凯特 西恩和我这里听到的
这些都离不开要在调试的同时确保能够轻松访问
尽可能多的相关信息
访问Objective-C运行时间
会让你在域无法获取之前对之有更多了解
SDK模块
为应用所运行的操作环境
更多类型 更多函数甚至有宏观
提供了前所未有的访问程度
还有进程格式
进程格式是用来生成
跨界应用类型的编译表示的
极好方法
它们可以应用在环境中在REPL中
也可以是在调试器中
若要了解更多详情
可以随时
浏览我们的网站Swift语言文件
或开发人员论坛当然还有实验室
还可以给开发顾问斯特凡发邮件
非常感谢希望大家喜欢WWDC