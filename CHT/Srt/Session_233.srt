00:00:25.726 --> 00:00:29.129 
彼得·崔：大家好 下午好

00:00:29.196 --> 00:00:31.832 
歡迎參加《iOS高級手寫輸入》講座

00:00:32.366 --> 00:00:33.300 
我是彼得

00:00:33.500 --> 00:00:35.636 
在Apple的iOS性能小組工作

00:00:36.303 --> 00:00:39.239 
今天和朋友UIKit小組的雅各布

00:00:39.540 --> 00:00:41.108 
準備給大家介紹更多有關

00:00:41.341 --> 00:00:43.510 
手寫輸入在iOS怎樣運行 

00:00:43.877 --> 00:00:48.582 
以及怎樣用它讓
自己的應用對手寫輸入更爲靈敏

00:00:50.117 --> 00:00:51.418 
今天要講的內容可是不少

00:00:51.919 --> 00:00:55.989 
正如前一個幻燈片
所講要想讓自己的應用 

00:00:56.056 --> 00:00:57.391 
反應靈敏的話 

00:00:57.524 --> 00:00:59.560 
減少延遲是關鍵

00:00:59.993 --> 00:01:02.896 
我們將介紹延遲是什麼

00:01:03.030 --> 00:01:04.697 
以及爲什麼要關注應用中的延遲

00:01:05.132 --> 00:01:06.900 
以及iOS中的一般性延遲問題

00:01:08.035 --> 00:01:10.337 
爲了探討延遲是來自哪裏

00:01:10.571 --> 00:01:13.974 
我們將探討並剖析iOS中

00:01:14.274 --> 00:01:16.109 
在手指下負責處理

00:01:16.176 --> 00:01:17.578 
手寫輸入和繪製像素圖之間

00:01:17.911 --> 00:01:21.348 
對觸控做出各種反應的主要內容

00:01:22.983 --> 00:01:25.018 
去年我們對iOS 9的系統

00:01:25.185 --> 00:01:26.720 
做了許多改進我們將向大家

00:01:26.787 --> 00:01:29.289 
介紹這些改進以及大家可以

00:01:29.356 --> 00:01:33.093 
用到的部分API 以便充分
利用我們所做的這些改進

00:01:34.161 --> 00:01:36.597 
最後 我們會告訴大家一些技巧

00:01:36.663 --> 00:01:40.100 
和最佳實踐 以便發現 分析

00:01:40.167 --> 00:01:42.903 
和解決在應用中出現的性能瓶頸

00:01:44.805 --> 00:01:48.141 
爲何要關注降低應用中的延遲問題呢？

00:01:49.343 --> 00:01:53.380 
iOS手寫輸入是
建立在直接操縱的理念上

00:01:53.780 --> 00:01:57.317 
也就是說用戶實際上用手指

00:01:57.384 --> 00:02:01.021 
觸碰物理對象 並在虛擬空間中做移動

00:02:01.955 --> 00:02:06.059 
例如 如果用戶想要把這個圓

00:02:06.260 --> 00:02:10.597 
從A點移動到B點那麼預期的結果

00:02:10.864 --> 00:02:13.834 
就是圓感覺被粘在手指指尖

00:02:14.801 --> 00:02:16.036 
你會注意到在本例中

00:02:16.270 --> 00:02:19.473 
這個圓會準確靈敏地隨着

00:02:19.773 --> 00:02:20.741 
用戶手指移動

00:02:22.075 --> 00:02:24.545 
但是一旦降低延遲

00:02:24.811 --> 00:02:26.947 
也就是手指移動和圓的移動

00:02:27.314 --> 00:02:29.850 
二者間的滯後這種直接

00:02:29.917 --> 00:02:31.852 
操縱的感覺就會開始被打破

00:02:32.686 --> 00:02:36.690 
在本例中 你可以看到
圓在跟隨手指而動而且並不像

00:02:36.757 --> 00:02:38.692 
是你是在手指周圍移動圓

00:02:40.294 --> 00:02:41.695 
當用戶手指移動

00:02:41.762 --> 00:02:43.430 
速度非常快時情況會越發嚴重

00:02:43.997 --> 00:02:47.801 
這樣 手指與圓之間會形成相當距離

00:02:48.368 --> 00:02:51.471 
而且不再感覺手指與圓是處於粘合狀態

00:02:51.572 --> 00:02:54.741 
圓此刻是在跟着手指移動

00:02:57.044 --> 00:03:01.415 
這類延遲會影響到iOS的各方面

00:03:01.481 --> 00:03:03.951 
從按下按鈕到移動對象

00:03:04.384 --> 00:03:06.820 
到滾動任何內容甚至是網頁都不可避免

00:03:07.821 --> 00:03:10.157 
但是我們可以確定有兩三個應用

00:03:10.224 --> 00:03:13.126 
可以顯著增加延遲作用

00:03:14.161 --> 00:03:17.798 
一種應用類型是繪圖應用 

00:03:18.365 --> 00:03:21.335 
不僅是藝術家會被線條末端

00:03:21.401 --> 00:03:24.638 
和用戶指尖的距離搞得心神不寧

00:03:26.240 --> 00:03:29.776 
藝術家通常要依賴應用

00:03:29.843 --> 00:03:33.413 
或用戶界面的快速靈敏更新

00:03:33.480 --> 00:03:36.283 
以便及時調整物理行爲

00:03:36.350 --> 00:03:38.018 
才能獲得希望的結果

00:03:38.986 --> 00:03:41.788 
此外 遊戲這類應用中的延遲

00:03:41.855 --> 00:03:43.857 
可能會讓遊戲很難繼續

00:03:44.491 --> 00:03:47.160 
並會影響到應用的感知質量

00:03:48.595 --> 00:03:49.997 
這個延遲是從哪裏來的呢？

00:03:50.330 --> 00:03:52.165 
是來源自許多不同地方

00:03:52.599 --> 00:03:56.737 
爲了探討哪裏會產生延遲我們會聊聊

00:03:57.004 --> 00:03:59.473 
在處理觸控和相應繪製 

00:03:59.540 --> 00:04:02.709 
觸控當中系統中的所有不同部分

00:04:04.144 --> 00:04:05.612 
在講座接下來的內容中

00:04:05.712 --> 00:04:08.515 
我們會用到很多這些管路圖

00:04:08.815 --> 00:04:11.451 
我們要確保大家對其中的含義理解相同

00:04:12.319 --> 00:04:14.655 
在屏幕上 你會看到5個不同的盒子

00:04:15.022 --> 00:04:17.357 
每個盒子都代表顯示器上

00:04:17.423 --> 00:04:19.660 
顯示一幀內容所用的時間

00:04:20.560 --> 00:04:23.497 
我們的產品刷新屏幕是60赫茲

00:04:23.564 --> 00:04:24.831 
也就是每秒60次

00:04:25.332 --> 00:04:27.734 
那麼每個盒子所代表的時間

00:04:27.801 --> 00:04:30.871 
大約爲1/60秒

00:04:32.272 --> 00:04:36.810 
大家可能聽到了每個盒子都代表顯示幀

00:04:37.044 --> 00:04:39.246 
顯示間隔或顯示週期

00:04:39.580 --> 00:04:40.581 
這些都是一個意思

00:04:42.182 --> 00:04:46.486 
現在分割每個盒子的
垂直線代表顯示刷新

00:04:46.720 --> 00:04:49.256 
這個時間點上顯示器上的一幀

00:04:49.323 --> 00:04:51.792 
和接下來要顯示的幀進行交換

00:04:52.559 --> 00:04:55.996 
我接下來會用顯示刷新

00:04:56.163 --> 00:04:59.132 
或同步刷新來表示
這兩個基本上也是相同內容

00:05:00.501 --> 00:05:02.302 
顯示刷新在iOS中很重要

00:05:02.536 --> 00:05:05.038 
因爲許多重要系統進程

00:05:05.572 --> 00:05:09.109 
都是由這個顯示刷新來啓動或觸發

00:05:10.277 --> 00:05:12.946 
我們來具體看看
在管線中在發生了些什麼

00:05:13.680 --> 00:05:15.949 
管線的第一階段是
Multi-Touch

00:05:16.583 --> 00:05:20.888 
在這一個進程中硬件將掃描

00:05:20.954 --> 00:05:22.923 
顯示器表面尋找觸控

00:05:23.824 --> 00:05:26.126 
在我們的多數產品中這部分用時

00:05:26.193 --> 00:05:29.997 
會小於整個顯示幀
但在我們的部分產品中

00:05:30.063 --> 00:05:32.533 
這會佔用整個顯示幀

00:05:32.933 --> 00:05:36.170 
爲了更直觀我們
用綠盒子來填充整個盒子

00:05:37.571 --> 00:05:42.309 
Multi-Touch一旦完成
掃描顯示器

00:05:42.976 --> 00:05:46.580 
會過濾掉屏幕上

00:05:46.647 --> 00:05:48.582 
所出現的任何噪音

00:05:49.283 --> 00:05:53.120 
UI應用的UITouch
的回調將在靠近下一個

00:05:53.187 --> 00:05:57.691 
觸控幀開始時被調用
通常是在顯示刷新開始後

00:05:58.825 --> 00:06:01.528 
這個點出現在應用應

00:06:01.595 --> 00:06:04.531 
該對手寫輸入做出反應時在繪圖應用中

00:06:04.932 --> 00:06:07.601 
也許是標定點並連接這些點

00:06:08.268 --> 00:06:11.271 
你也許想做平滑處理令線條更流暢

00:06:12.072 --> 00:06:14.141 
在不是繪圖應用的應用中

00:06:14.474 --> 00:06:16.844 
這裏需要通過按下按鈕或按鍵

00:06:16.910 --> 00:06:19.713 
來做出反應也許是生成視圖 

00:06:20.280 --> 00:06:22.349 
視圖控制器 並向用戶呈現

00:06:23.350 --> 00:06:25.986 
這裏所花費的時間是個變量

00:06:26.053 --> 00:06:27.221 
但可以佔據一個顯示幀

00:06:27.454 --> 00:06:29.456 
那麼我再來填充整個盒子

00:06:30.858 --> 00:06:35.762 
一旦應用完成與觸碰
事件做出反應並相應更新狀態

00:06:36.330 --> 00:06:39.800 
在下一個顯示刷新時 Core
 Animation 就會啓動

00:06:40.200 --> 00:06:43.837 
開始將視圖和圖層

00:06:44.471 --> 00:06:47.441 
翻譯成GPU指令這可以被GPU渲染

00:06:48.208 --> 00:06:52.946 
你會注意到GPU不必等到
下一個顯示刷新開始的時候

00:06:53.013 --> 00:06:54.882 
它在Core Animation

00:06:54.948 --> 00:06:59.219 
給出它需要渲染幀的
指令時候就會立即開始

00:07:00.020 --> 00:07:03.290 
同樣 這些階段的時間根據應用中的

00:07:03.824 --> 00:07:07.261 
視圖複雜程度不同也是變量

00:07:08.395 --> 00:07:11.031 
最後一旦GPU完成渲染幀

00:07:11.398 --> 00:07:13.500 
這個幀就會在下一個顯示刷新

00:07:13.867 --> 00:07:16.703 
開始時排隊在顯示器上顯示

00:07:18.705 --> 00:07:23.143 
大家都明白在顯示器上感知觸控

00:07:23.377 --> 00:07:27.848 
直至畫圖需要佔用若干幀數
本例中 需要佔用4幀

00:07:28.582 --> 00:07:29.516 
因此不是即刻完成

00:07:30.851 --> 00:07:32.452 
此外 這是管線

00:07:32.686 --> 00:07:36.356 
在應用處理之前正發生的觸控時

00:07:36.423 --> 00:07:38.825 
其他的觸控也會發生

00:07:39.426 --> 00:07:42.829 
這就是在管線不同的點經過的進程

00:07:44.298 --> 00:07:46.667 
我們來談談
作爲開發人員該怎樣控制

00:07:47.134 --> 00:07:50.437 
並沒有API可以改變
Multi-Touch的行爲

00:07:50.504 --> 00:07:52.005 
或顯示器硬件圖層

00:07:52.272 --> 00:07:54.174 
這是系統做出的處理

00:07:55.075 --> 00:08:00.013 
根據應用中的視圖複雜程度
你對Core Animation

00:08:00.347 --> 00:08:03.050 
渲染服務器和GP進行間接控制

00:08:03.684 --> 00:08:06.620 
但是你可以對應用幾乎完全控制

00:08:07.054 --> 00:08:08.055 
我們就從這裏開始

00:08:10.357 --> 00:08:12.226 
我剛說過在這個點上

00:08:12.292 --> 00:08:16.263 
要根據手寫輸入更新應用的狀態

00:08:16.897 --> 00:08:19.566 
例如 在繪圖應用中可以標定點

00:08:19.900 --> 00:08:22.436 
並彼此連接或是根據按下按鈕創建視圖

00:08:22.836 --> 00:08:25.873 
這裏也許是發佈OpenGL
或Metal指令的位置

00:08:26.940 --> 00:08:28.609 
這裏所花費的時間量是個變量

00:08:28.876 --> 00:08:32.346 
可以進行優化減少所用時間

00:08:32.412 --> 00:08:33.881 
我們鼓勵大家這麼做

00:08:34.581 --> 00:08:37.751 
但是當我們優化應用時你會注意到這點

00:08:38.085 --> 00:08:42.389 
Core Animation
並不會進入填充UIKit

00:08:42.756 --> 00:08:44.124 
或應用所留下的空間

00:08:45.259 --> 00:08:50.697 
這是因爲之前在iOS
如何更新視圖所導致

00:08:51.565 --> 00:08:53.433 
當你在iOS上更新視圖狀態時 

00:08:53.767 --> 00:08:56.570 
如果用UIMethods更新
A CATransaction

00:08:57.237 --> 00:08:59.907 
視圖屬性的話可以顯性提交

00:09:00.274 --> 00:09:03.010 
或UIKit將隱性爲你生成一個

00:09:03.577 --> 00:09:07.347 
我們用紅點來表示
CATransaction提交

00:09:08.749 --> 00:09:12.819 
現在Core Animation 
沒有填入時間

00:09:13.187 --> 00:09:14.988 
是因爲應用允許在一個

00:09:15.189 --> 00:09:18.325 
顯示幀中多次升級狀態

00:09:18.659 --> 00:09:20.994 
在本例中用第二個點表示

00:09:21.962 --> 00:09:24.965 
現在 爲減少冗餘任務量

00:09:25.032 --> 00:09:26.733 
或永遠不會在顯示器上出現的任務

00:09:27.167 --> 00:09:31.338 
Core Animation
分批處理所有更新

00:09:31.405 --> 00:09:33.740 
並在顯示刷新中進行一次渲染

00:09:34.074 --> 00:09:37.010 
那麼我們將渲染這些

00:09:37.077 --> 00:09:39.580 
Core Animation事務的
綜合狀態

00:09:41.782 --> 00:09:45.652 
一旦Core Animation
在顯示刷新時

00:09:46.320 --> 00:09:51.058 
快照視圖它將會開始把
所有你爲之生成的邏輯視圖

00:09:51.592 --> 00:09:54.361 
和圖層翻譯成GPU指令
以便由GPU進行渲染

00:09:54.928 --> 00:09:58.332 
我剛說過
一接到Core Animation

00:09:58.398 --> 00:10:00.801 
的必要指令GPU就會立刻啓動

00:10:01.168 --> 00:10:04.738 
因此 如果優化
Core Animation

00:10:04.805 --> 00:10:08.609 
或GPU的用時數量
GPU就會填充所留下的空間

00:10:10.043 --> 00:10:15.115 
Xcode的視圖調試器是理解
視圖層次複雜度的很好方法

00:10:15.382 --> 00:10:20.420 
也是找到可以取出的視圖的
很好方法從而可以優化應用

00:10:21.955 --> 00:10:26.159 
不過我們認識到 
對視圖的需求非常複雜

00:10:26.326 --> 00:10:29.196 
在一個顯示幀中很難完全體現

00:10:30.297 --> 00:10:33.500 
那麼iOS管線可以靈活處理這點

00:10:34.434 --> 00:10:37.171 
如果應用需要花
費額外的時間渲染視圖

00:10:37.237 --> 00:10:39.540 
我們可以把Core
Animation

00:10:39.606 --> 00:10:41.241 
和GPU任務分到兩個顯示幀

00:10:41.775 --> 00:10:43.977 
當然 這增加了額外的延遲幀數

00:10:44.178 --> 00:10:47.414 
但是還可以在應用的各處獲得

00:10:47.748 --> 00:10:50.517 
每秒60幀的流暢動畫視圖還更爲複雜

00:10:51.852 --> 00:10:56.590 
並無手動觸發選擇快慢模式

00:10:56.890 --> 00:11:00.260 
這又是視情況而定而且是系統任意選定

00:11:00.661 --> 00:11:05.065 
所以重要的是我們理解
什麼內容可以觸發進入更快模式

00:11:05.332 --> 00:11:07.401 
什麼內容可以觸發進入更慢模式

00:11:09.436 --> 00:11:12.439 
更快模式叫做雙緩衝 

00:11:12.639 --> 00:11:16.810 
這麼叫是因爲有兩個緩衝
一個是爲了引入GPU 

00:11:17.010 --> 00:11:19.346 
一個是爲了LCD向用戶顯示

00:11:20.280 --> 00:11:22.983 
在顯示刷新中大家回憶一下

00:11:23.050 --> 00:11:26.086 
Core Animation
爲自己和GPU抓取緩衝

00:11:26.153 --> 00:11:28.755 
並開始輸出該幀的GPU指令

00:11:29.489 --> 00:11:32.693 
一旦GPU獲得指令GPU就開始渲染

00:11:33.093 --> 00:11:36.230 
如果渲染在下一個顯示刷新

00:11:36.330 --> 00:11:40.200 
發生前結束我們就把這個幀放入隊列

00:11:40.434 --> 00:11:41.702 
在下一個顯示刷新中顯示

00:11:42.336 --> 00:11:43.904 
一旦到達顯示刷新

00:11:44.371 --> 00:11:46.406 
這個幀就會進入屏幕

00:11:46.673 --> 00:11:48.876 
我們開始處理下一個幀

00:11:49.877 --> 00:11:52.813 
同樣 GPU將做渲染
再把這一幀放入隊列

00:11:52.880 --> 00:11:54.481 
爲下一個顯示刷新進行顯示

00:11:54.982 --> 00:11:56.416 
一旦開始顯示刷新

00:11:56.650 --> 00:11:59.586 
這兩個幀將交換位置

00:11:59.853 --> 00:12:03.090 
我們會回收綠色緩衝繼續這一進程

00:12:03.257 --> 00:12:06.393 
只要應用有需要渲染的視圖即可

00:12:07.661 --> 00:12:08.795 
現在都沒問題

00:12:09.029 --> 00:12:11.365 
我們已經在一個顯示幀完成Core

00:12:11.431 --> 00:12:12.933 
Core Animation
和GPU任務

00:12:12.999 --> 00:12:14.067 
性能很好

00:12:15.202 --> 00:12:17.738 
可是如果無法做到所有這些 會怎樣？

00:12:18.338 --> 00:12:19.606 
如果無法在一幀中完成呢？

00:12:20.174 --> 00:12:22.176 
那我們就進入了三重緩衝模式

00:12:22.943 --> 00:12:25.712 
同樣Core Animation
會輸出GPU指令

00:12:25.779 --> 00:12:28.882 
GPU隨後會渲染不過在本例中

00:12:29.216 --> 00:12:33.921 
在開始顯示刷新時
GPU並沒有完成綠色幀的渲染

00:12:34.655 --> 00:12:36.823 
在本例中 因爲我們還無法展示 

00:12:37.224 --> 00:12:40.494 
爲了額外的幀藍色
幀延伸到屏幕上的情景

00:12:41.929 --> 00:12:44.331 
Core Animation現在
需要分配第三個緩衝

00:12:44.398 --> 00:12:46.200 
開始處理下一個幀通過生成

00:12:46.600 --> 00:12:48.869 
第三個緩衝來實現這一點

00:12:49.536 --> 00:12:52.039 
Core Animation將
開始爲之輸出GPU指令

00:12:52.105 --> 00:12:54.875 
同時GPU完成前一幀的渲染

00:12:55.876 --> 00:12:58.712 
然後前一幀將進入隊列

00:12:58.879 --> 00:13:00.280 
在下一個顯示刷新中顯示

00:13:01.315 --> 00:13:02.482 
這一進程隨後

00:13:02.883 --> 00:13:06.954 
和Core Animation
渲染服務器輸出GPU指令一起重複

00:13:07.154 --> 00:13:08.622 
GPU會對它們進行渲染

00:13:09.122 --> 00:13:12.492 
思路就是我們交換緩衝回收緩衝

00:13:12.793 --> 00:13:14.127 
然後進程重複進行

00:13:17.197 --> 00:13:20.901 
大家可能會想 所有這些幻燈片都
在說Core Animation

00:13:21.101 --> 00:13:23.303 
我如果不用Core
Animation會怎樣？

00:13:23.370 --> 00:13:24.938 
如果我要優化應用

00:13:25.339 --> 00:13:27.241 
使用 Metal or
OpenGL 會怎樣？

00:13:28.041 --> 00:13:31.678 
大家可能會想與其讓管線變成這樣

00:13:31.845 --> 00:13:35.449 
讓顯示的幀變成4幀延遲

00:13:35.782 --> 00:13:37.951 
不如改作3幀延遲

00:13:39.620 --> 00:13:40.954 
不過這裏不行

00:13:42.489 --> 00:13:45.792 
在iOS 8
如果用Metal或OpenGL

00:13:46.093 --> 00:13:48.862 
Core Animation仍會
作爲仲裁器 確保你對...

00:13:48.929 --> 00:13:52.299 
Core Animation 
內容在屏幕上所做的

00:13:52.633 --> 00:13:54.935 
任何更新 都與這些圖層上的GPU 

00:13:55.402 --> 00:13:58.539 
OpenGL和Metal
更新保持同步

00:13:59.540 --> 00:14:01.608 
在使用iOS 8的 OpenGL

00:14:01.842 --> 00:14:05.245 
或Metal時你仍有4幀延遲

00:14:06.947 --> 00:14:11.685 
那麼我們談到過iOS管線非常靈活

00:14:11.852 --> 00:14:13.520 
可以處理更爲複雜的視圖

00:14:13.787 --> 00:14:16.590 
可以實現每秒60幀動畫

00:14:16.657 --> 00:14:18.759 
但是在5幀延遲中會怎樣

00:14:19.092 --> 00:14:23.664 
怎樣優化應用通過優化繪圖 

00:14:23.897 --> 00:14:25.832 
把延遲降爲4幀

00:14:26.767 --> 00:14:30.003 
但是 在本例中沒有辦法

00:14:30.103 --> 00:14:32.840 
可以實現更快 因爲
Core Animation

00:14:32.906 --> 00:14:34.541 
需要等到顯示刷新開始

00:14:34.942 --> 00:14:37.511 
生成GPU指令才行

00:14:39.713 --> 00:14:42.449 
在iOS 9中
我們去除了這種依賴性

00:14:43.483 --> 00:14:46.386 
現在可以在應用完成應用狀態升級後 

00:14:46.453 --> 00:14:48.889 
立刻啓動 Core
Animation 任務

00:14:49.857 --> 00:14:53.927 
爲了充分利用這些功能
我們在iOS系統中引入了

00:14:53.994 --> 00:14:55.863 
一些新的API和新技巧

00:14:56.196 --> 00:14:57.664 
爲了更多介紹這方面內容

00:14:57.731 --> 00:14:59.399 
有請雅各布

00:15:00.934 --> 00:15:01.935 
雅克布·肖：謝謝 彼得

00:15:03.337 --> 00:15:04.171 
我將向大家

00:15:04.371 --> 00:15:06.740 
介紹我們在iOS 9中新增的內容

00:15:07.341 --> 00:15:10.344 
以及怎樣用它們實現app的更低延遲

00:15:12.179 --> 00:15:13.780 
今天我來講三個問題

00:15:14.448 --> 00:15:17.551 
第一 低延遲
支持Core Animation

00:15:18.519 --> 00:15:21.121 
然後是用戶觸控接合的新系統

00:15:22.155 --> 00:15:24.925 
最後是個很酷的系統
可以在UIKit構建

00:15:25.092 --> 00:15:26.393 
觸控預測

00:15:27.928 --> 00:15:30.731 
我們現在先從Core 
Animation低延遲開始

00:15:32.733 --> 00:15:34.735 
彼得講過在iOS 8中

00:15:35.102 --> 00:15:39.373 
即便是最優化的app
延遲的降低程度也是非常有限的

00:15:40.541 --> 00:15:43.410 
通過使用iOS 9的低延遲
Core Animation

00:15:43.877 --> 00:15:47.014 
可以把app的幀和Core
 Animation的幀相結合

00:15:47.414 --> 00:15:48.849 
這會實現更低的延遲

00:15:49.716 --> 00:15:51.018 
這種功能的最好一點在於

00:15:51.218 --> 00:15:52.519 
它是自動發生的

00:15:52.786 --> 00:15:54.321 
你不必在app上做任何改變

00:15:54.588 --> 00:15:56.190 
除了優化你的性能表現之外

00:15:57.724 --> 00:15:59.493 
不過 還需要牢記一點

00:15:59.726 --> 00:16:02.629 
當app中的動畫激活時 

00:16:02.930 --> 00:16:04.665 
低延遲模式是自動關閉的

00:16:05.866 --> 00:16:09.069 
這包括CA動畫和UIKit動畫

00:16:09.736 --> 00:16:11.939 
因此 如果需要
app中 延遲是絕對最低水平

00:16:12.406 --> 00:16:14.374 
在顯示器上觸控激活時一定確保要

00:16:14.675 --> 00:16:16.643 
關閉這些動畫功能

00:16:22.816 --> 00:16:26.320 
現在 系統還可以與Metal
OpenGL內容配合使用

00:16:26.954 --> 00:16:29.656 
因此正如之前在iOS 8中所見

00:16:30.157 --> 00:16:33.627 
我們必須等額外的
幀以便讓GPU內容得以顯示

00:16:34.595 --> 00:16:36.330 
但是有了新的低延遲模式 

00:16:36.663 --> 00:16:39.233 
我們可以在緊鄰的下一幀

00:16:39.299 --> 00:16:40.367 
儘快顯示這些內容

00:16:41.335 --> 00:16:42.803 
這些都是自動完成

00:16:42.870 --> 00:16:45.706 
使用CAeagllayer
或CAMetalLayer即可

00:16:47.140 --> 00:16:49.243 
不過 如果有想和
OpenGL或Metal內容

00:16:49.309 --> 00:16:51.512 
一起顯示的Core
Animation 內容的話

00:16:51.578 --> 00:16:54.181 
在app中還需要記住一點

00:16:55.349 --> 00:16:58.585 
這樣 GPU內容 會盡快拉到

00:16:58.652 --> 00:17:01.355 
顯示器上但是 core
Animation內容

00:17:01.822 --> 00:17:03.824 
則需要更長時間才能過去

00:17:05.092 --> 00:17:08.127 
如果是這種情況那麼默認狀態

00:17:08.362 --> 00:17:11.098 
不會確保GPU內容
會到達Core Animation

00:17:11.164 --> 00:17:12.432 
內容的同一幀

00:17:13.267 --> 00:17:15.903 
如果你希望二者同步的話
這就會出現問題

00:17:16.369 --> 00:17:18.638 
例如如果你希望把UIKit內容繪製

00:17:18.704 --> 00:17:22.009 
在OpenGL視圖
上面就會出現這樣的情況

00:17:23.477 --> 00:17:25.945 
這種情況下 你希望同步更新

00:17:26.313 --> 00:17:28.582 
類似這樣這裏有個屬性

00:17:28.649 --> 00:17:29.616 
可實現這一功能

00:17:29.683 --> 00:17:32.085 
叫做Presents
With Transaction

00:17:32.152 --> 00:17:34.955 
是在CAeagllayer
和CAMetalLayer上面

00:17:35.322 --> 00:17:37.524 
當設置這個爲False時這是默認值

00:17:38.025 --> 00:17:41.461 
那就可以儘快獲得顯示的GPU內容

00:17:42.229 --> 00:17:43.530 
但是當設置爲True的時候

00:17:44.031 --> 00:17:45.999 
我們可以將GPU內容

00:17:46.166 --> 00:17:48.836 
和Core Animation內容
同步 因此它們會同時

00:17:48.902 --> 00:17:50.737 
出現在顯示器上

00:17:52.372 --> 00:17:55.242 
好 接下來 我們談談觸控接合

00:17:56.176 --> 00:17:56.977 
在這之前

00:17:57.177 --> 00:17:59.813 
我先介紹一下 iPad Air 2

00:18:01.014 --> 00:18:02.950 
去年 我們推出iPad Air 2

00:18:03.650 --> 00:18:05.919 
顯示屏更新速率爲60赫茲

00:18:06.186 --> 00:18:09.189 
也就是說顯示器每秒更新60次

00:18:09.523 --> 00:18:10.891 
和其他的iOS設備一樣

00:18:11.725 --> 00:18:14.394 
它有個很酷的功能可以影響觸控

00:18:14.461 --> 00:18:17.231 
和觸控延遲我今天
很興奮能向大家介紹這點

00:18:18.198 --> 00:18:21.502 
這樣它可實現
120赫茲觸控掃描更新速率

00:18:25.272 --> 00:18:25.939 
太酷了

00:18:27.541 --> 00:18:31.578 
這意味着掃描觸控的
速率是其他iOS設備的兩倍

00:18:31.945 --> 00:18:34.281 
這非常棒因爲你可以獲得

00:18:34.515 --> 00:18:37.384 
用戶手指和顯示器互動時的更多信息

00:18:38.919 --> 00:18:41.922 
我們來看這會在實踐中怎樣影響app

00:18:42.923 --> 00:18:46.326 
使用60赫茲的觸
控掃描速率在用戶手指

00:18:46.393 --> 00:18:48.795 
在顯示器上移動時我們會定期採樣

00:18:48.862 --> 00:18:52.099 
手指的位置
並把這個信息提供給app

00:18:53.400 --> 00:18:56.036 
使用120赫茲掃描速率時
也會發生同樣的事情

00:18:56.370 --> 00:18:59.840 
但是因爲是兩倍的速率
你會獲得兩倍的樣本

00:19:00.741 --> 00:19:03.410 
這會讓你掌握用戶行爲的更多信息

00:19:09.316 --> 00:19:12.186 
現在 一旦獲得這些樣本
我們就會把它們轉給app

00:19:13.086 --> 00:19:16.323 
通過這些 你會瞭解
用戶想要用觸控做些什麼

00:19:16.790 --> 00:19:19.726 
例如 在繪圖app中你可能會把這些

00:19:20.060 --> 00:19:22.362 
連接起來 顯示出用戶想要實現的繪圖

00:19:23.330 --> 00:19:26.800 
120赫茲的信息會提供更多信息量

00:19:26.967 --> 00:19:29.770 
以便會繪圖有着更好的表示

00:19:31.538 --> 00:19:34.608 
現在我們看到了使用120赫茲的
觸控掃描速率所帶來的好處

00:19:35.142 --> 00:19:39.446 
我們先來看它會怎樣
影響觸控對顯示管線的作用

00:19:40.981 --> 00:19:43.951 
這是60赫茲的
觸控掃描速率管線我們之前見過

00:19:44.718 --> 00:19:47.621 
我們主要來看
管線的Multi-Touch階段

00:19:49.022 --> 00:19:52.726 
在60赫茲水平上 我們
每幀會獲得一個新觸控樣本

00:19:53.794 --> 00:19:56.897 
在120赫茲水平上
我們每次會獲得兩個樣本

00:19:57.764 --> 00:20:00.901 
不過 要注意顯示幀依然相同

00:20:01.235 --> 00:20:03.804 
因爲顯示器本身的更新速率相同

00:20:05.606 --> 00:20:08.475 
現在我們可以用這些新的觸控樣本 

00:20:09.243 --> 00:20:11.445 
並將其轉至app而且
app可以用它來更新繪圖

00:20:11.612 --> 00:20:13.647 
而繪圖會把在
Core Animation

00:20:13.714 --> 00:20:15.082 
和顯示器顯示的內容做更新

00:20:16.049 --> 00:20:17.551 
但是你會注意到如果我們這麼做

00:20:17.918 --> 00:20:21.088 
app的更新次數實際是顯示器更新的
兩倍 這會導致app在做

00:20:21.321 --> 00:20:22.856 
無用功

00:20:24.024 --> 00:20:27.327 
我們介紹了觸控接合系統
來或者兩方面的最好效果

00:20:27.995 --> 00:20:31.865 
這樣可以從120赫茲
觸控掃描速率中獲得更多信息 

00:20:32.533 --> 00:20:35.802 
但是不會在app中取消太多無用功

00:20:36.837 --> 00:20:39.673 
我們來看管線如何與接合一起改變

00:20:40.941 --> 00:20:43.410 
現在我們只能向app

00:20:43.877 --> 00:20:45.179 
每個顯示幀交付一個觸控

00:20:45.746 --> 00:20:48.115 
當首個觸控出現時我們會把它交付給你

00:20:49.483 --> 00:20:51.852 
然後是下一幀我們會交付這一幀

00:20:51.919 --> 00:20:54.821 
的觸控 同時還有上次我們發送觸控

00:20:54.888 --> 00:20:57.357 
到app上時所出現的任何中間觸控

00:20:58.725 --> 00:21:03.197 
每次用戶要顯示更多
觸控時這些都會重複一遍

00:21:03.697 --> 00:21:05.866 
我們提供當前的觸控和任何接合觸控

00:21:06.533 --> 00:21:08.468 
只要觸控激活這些就會繼續

00:21:10.103 --> 00:21:13.207 
現在 API使用這些
接合觸控就非常簡單

00:21:13.273 --> 00:21:16.376 
這是UIEvent上的新方法叫做
Coalesce Touches

00:21:16.443 --> 00:21:17.244 
For Touch

00:21:17.978 --> 00:21:20.280 
把這個方法轉至正在看的觸控

00:21:20.781 --> 00:21:23.417 
在上次我們交付 觸控到app上之後

00:21:23.483 --> 00:21:26.520 
會返回一組所有的接合觸控

00:21:28.422 --> 00:21:30.591 
爲更好了解這個API該怎樣使用

00:21:30.657 --> 00:21:33.160 
我們來看看觸控處理
一般在iOS上怎樣運作

00:21:35.028 --> 00:21:36.797 
當用戶首先觸控顯示屏時

00:21:37.264 --> 00:21:39.466 
我們會調用app上的
Touches Began 

00:21:40.133 --> 00:21:42.636 
他們的手指移動時我們
將調用Touches Moved

00:21:43.003 --> 00:21:44.905 
當手指從顯示屏拿開時

00:21:44.972 --> 00:21:46.840 
我們會調用
Touches Ended

00:21:48.008 --> 00:21:50.077 
現在 我們談論這些觸控回調時

00:21:50.377 --> 00:21:52.980 
另一個非常重要的回調
是Touches Canceled

00:21:54.014 --> 00:21:56.917 
當通往app的觸控流中
斷時 就會調用它

00:21:57.518 --> 00:21:59.520 
例如 如果用戶從底部滑動

00:21:59.586 --> 00:22:01.188 
來激活Control Center

00:22:02.055 --> 00:22:04.525 
在這種情況下 當接收到
系統手勢 app將

00:22:04.591 --> 00:22:06.627 
獲得部分初始觸控回調

00:22:07.160 --> 00:22:09.296 
我們將獲得
Touches Canceled

00:22:10.764 --> 00:22:13.800 
用這種方法來清理之前的觸控

00:22:13.867 --> 00:22:16.570 
回調所開始的任何內容

00:22:17.037 --> 00:22:18.605 
以及回退所做的任何改變都很重要

00:22:19.239 --> 00:22:23.177 
例如 在繪圖app中你可能想
清除用戶所畫的線條

00:22:24.945 --> 00:22:27.014 
現在我們瞭解了
這些觸控回調是怎麼起作用

00:22:27.281 --> 00:22:29.383 
我們來看它們怎樣和接合觸控互動

00:22:30.484 --> 00:22:34.121 
我們交付給所有回調的觸控
我們稱之爲主觸控

00:22:34.588 --> 00:22:39.193 
這部分在120赫茲掃描速率
和60赫茲設備上都完全相同

00:22:41.495 --> 00:22:42.696 
但是 有了Coalesce

00:22:42.763 --> 00:22:44.865 
Touches For Touch
方法

00:22:45.098 --> 00:22:47.267 
你可以通過這些接合觸控瞭解更多信息

00:22:48.202 --> 00:22:52.773 
接合觸控互動不僅
有着中間觸控的相關信息

00:22:53.240 --> 00:22:56.176 
它們還會提供主觸控本身的副本

00:22:57.244 --> 00:22:59.680 
這其中最棒的一點是你可以進行選擇

00:23:00.080 --> 00:23:01.782 
你可以來看主觸控

00:23:02.049 --> 00:23:03.851 
如果不需要app的更高觸控掃描速率

00:23:04.284 --> 00:23:06.453 
所增加的信息量

00:23:07.054 --> 00:23:08.622 
或者如果如果想要這些信息

00:23:08.989 --> 00:23:12.593 
可以來看接合觸控
而且你不必擔心主觸控

00:23:17.598 --> 00:23:20.601 
現在 我們再來看觸控序列 

00:23:20.667 --> 00:23:23.837 
看它如何與主觸控和接合觸控相配合

00:23:25.105 --> 00:23:26.573 
隨着用戶手指的下滑

00:23:26.974 --> 00:23:31.178 
我們會給app一個
主觸控並將其副本作爲接合觸控

00:23:32.279 --> 00:23:33.380 
隨着手指的移動

00:23:33.447 --> 00:23:35.015 
我們會交付新的主觸控

00:23:35.315 --> 00:23:37.217 
和各自的一組接合觸控

00:23:37.985 --> 00:23:39.520 
最後 隨着手指離開

00:23:39.720 --> 00:23:41.054 
我們將提供最後的主觸控

00:23:41.455 --> 00:23:42.956 
和任何其餘的接合觸控

00:23:44.458 --> 00:23:48.829 
這裏我希望只展示
每個主觸控的一兩個接合觸控

00:23:49.263 --> 00:23:52.065 
需要注意的是app可以收到
不同的數量這點很重要

00:23:52.966 --> 00:23:55.202 
如果app花費長時間處理一個觸控

00:23:55.602 --> 00:23:59.806 
然後我們給你些時間跟進並等着
跟進之後發送新的觸控

00:24:01.008 --> 00:24:01.942 
如果出現這樣的情況

00:24:02.109 --> 00:24:05.879 
那麼未交付給你的
觸控稍後會作爲接合觸控發送給你

00:24:06.413 --> 00:24:08.515 
因此 確保你的代碼對
所收到的接合觸控

00:24:08.682 --> 00:24:10.551 
數量 不存在任何依賴性

00:24:12.519 --> 00:24:14.922 
現在 在這些接合 觸控的行爲方式

00:24:15.155 --> 00:24:17.658 
和主觸控的行爲方式之間存在一些區別

00:24:18.425 --> 00:24:20.727 
其中之一與之前的位置有關

00:24:21.762 --> 00:24:23.463 
之前的位置可以通過Previous

00:24:23.530 --> 00:24:27.067 
Location In View
from UITouch方法來獲得

00:24:28.635 --> 00:24:32.105 
對主觸控而言 
這可以爲app提供該觸控

00:24:32.172 --> 00:24:33.707 
在交付時的最後位置

00:24:34.441 --> 00:24:36.677 
對接合觸控而言其行爲也非常相似

00:24:37.110 --> 00:24:38.212 
它可以提供針對app的

00:24:38.312 --> 00:24:39.746 
最後接合觸控的位置

00:24:41.715 --> 00:24:43.650 
這就是需要只關注主觸控

00:24:43.717 --> 00:24:46.420 
或只關注接合觸控很重要的原因之一

00:24:47.287 --> 00:24:50.624 
這樣 你就不會對
之前的位置產生任何混淆

00:24:51.058 --> 00:24:52.926 
因此不要過界非常重要

00:24:58.932 --> 00:25:01.668 
在主觸控和接合觸控之間還有一個區別

00:25:01.969 --> 00:25:04.238 
就是UITouch對象本身如何行爲

00:25:05.572 --> 00:25:08.742 
和主觸控一起 每次觸控交付

00:25:08.809 --> 00:25:10.844 
給app時 UITouch  
實例就會再次使用

00:25:12.179 --> 00:25:14.581 
這樣做很有用因爲如果用戶

00:25:14.715 --> 00:25:18.552 
立刻在顯示器上使用多個手指的話
這可以讓你區別不同的觸控

00:25:20.654 --> 00:25:22.856 
對接合觸控而言這會有所不同

00:25:23.724 --> 00:25:26.393 
每次 向app交付接合觸控時

00:25:26.793 --> 00:25:28.462 
我們交付一個新的具有新屬性的

00:25:29.496 --> 00:25:30.631 
UITouch實例

00:25:31.498 --> 00:25:33.166 
所以你可以把這些當作是快照

00:25:33.333 --> 00:25:35.903 
而不是主觸控的共享身份

00:25:37.471 --> 00:25:39.540 
現在 你理解了觸控接合是如何工作的

00:25:39.606 --> 00:25:42.576 
讓我們研究一下某些代碼
如何使用接合觸控

00:25:43.510 --> 00:25:45.245 
這就是在app中可能用到的部分代碼

00:25:45.512 --> 00:25:49.449 
可以用於繪圖在移動的
觸控中可以用這類內容

00:25:50.450 --> 00:25:52.819 
這裏我們會重複我們已有的觸控

00:25:53.420 --> 00:25:55.789 
我們在抓取每個觸控對應的代碼行

00:25:57.024 --> 00:26:00.527 
然後 我們把最後的觸控
作爲新樣本加入該行的末尾

00:26:02.095 --> 00:26:06.099 
爲了增加觸控的接合支持
我們只需要加上這一小部分代碼

00:26:07.034 --> 00:26:09.903 
這裏我們爲給定的主觸控

00:26:09.970 --> 00:26:11.071 
重複所有的接合觸控

00:26:12.005 --> 00:26:15.909 
對於各個接合觸控
我們把它加爲該行的樣本

00:26:16.710 --> 00:26:19.046 
注意 我們只添加樣本接合觸控

00:26:19.346 --> 00:26:20.247 
而不是主觸控

00:26:21.181 --> 00:26:22.382 
這就是觸控接合

00:26:27.454 --> 00:26:29.356 
現在我想談談觸控預測

00:26:30.023 --> 00:26:33.527 
這是我們剛加入
UIKit中的很酷的系統

00:26:33.594 --> 00:26:35.996 
用它可以實現app中的更低延遲

00:26:36.964 --> 00:26:42.169 
正如我們交付的app新觸控
也會讓你瞭解到未來

00:26:42.436 --> 00:26:45.506 
我們可以預測到用戶
觸控在稍後會做些什麼

00:26:46.874 --> 00:26:50.410 
這裏的API和接合觸控的API
工作效果很相似

00:26:50.811 --> 00:26:54.014 
這是UIEvent上的新方法叫做
Predicted Touches

00:26:54.081 --> 00:26:54.882 
For Touch

00:26:55.649 --> 00:26:58.018 
同樣 經過主觸控進入這個方法

00:26:58.352 --> 00:27:00.287 
然後返回一組預測觸控

00:27:01.855 --> 00:27:04.925 
可以使用這些預測觸控來更新繪圖

00:27:05.025 --> 00:27:07.160 
或者是你用用戶觸控所做的其他任務

00:27:07.861 --> 00:27:09.029 
來獲取更低的延遲

00:27:10.564 --> 00:27:13.834 
之前我們看到主觸控和
接合觸控是如何相關聯

00:27:14.668 --> 00:27:16.803 
而且預測觸控的運行方法也非常相似

00:27:17.704 --> 00:27:20.474 
它們是與主觸控相關的另一組觸控

00:27:21.542 --> 00:27:24.178 
而且和接合觸控一樣作爲快照發揮作用

00:27:25.712 --> 00:27:27.948 
現在 和接合觸控相比預測觸控

00:27:28.015 --> 00:27:31.084 
有一點不同那就是
在發生新觸控時的表現

00:27:31.885 --> 00:27:34.988 
當你獲得新的主觸控時
你會獲得一組新的

00:27:35.889 --> 00:27:39.726 
預測觸控 然後你只想
使用新的預測觸控

00:27:40.227 --> 00:27:42.529 
任何之前的預測觸控都不再有用

00:27:42.796 --> 00:27:46.400 
因爲我們現在掌握了
當時用戶實際在哪裏觸控

00:27:46.733 --> 00:27:49.436 
因此 你一般想扔掉那些舊的預測觸控

00:27:51.071 --> 00:27:53.373 
現在視圖中之前的位置
對預測觸控進行類似的處理

00:27:53.440 --> 00:27:55.642 
它對其他觸控類型也是如此對待

00:27:56.476 --> 00:27:57.911 
它指出之前的預測觸控

00:27:57.978 --> 00:28:00.147 
所在的位置或者是針對第一個

00:28:00.514 --> 00:28:04.618 
預測觸控它指出
交付給app的最後位置

00:28:06.220 --> 00:28:09.690 
因此你可能會奇怪我們怎麼會獲得
這些預測觸控 其實相當簡單

00:28:10.390 --> 00:28:12.526 
我們在每個iOS設備中
都加上了時間機器

00:28:14.528 --> 00:28:15.562 
其實不是這樣的

00:28:16.163 --> 00:28:19.132 
我們實際上是來看交付給app的

00:28:19.233 --> 00:28:23.871 
觸控 並使用一套高度精密的
算法來確定用戶手指此刻

00:28:23.937 --> 00:28:27.374 
即將會做些什麼

00:28:28.175 --> 00:28:30.811 
當我們獲得新的觸控
樣本時我們會更新預測

00:28:30.944 --> 00:28:32.913 
並把新的預測觸控交付給app

00:28:34.248 --> 00:28:37.851 
現在每個預測觸控
都是完整的UITouch

00:28:38.185 --> 00:28:39.820 
對象 而且都填寫了所有的屬性

00:28:40.053 --> 00:28:41.622 
例如位置和時間標記

00:28:43.457 --> 00:28:47.394 
現在我們來看 預測觸控對我們
在看的管線會有什麼影響

00:28:49.062 --> 00:28:54.635 
這是我們之前看到的主觸控和
接合觸控我們可以輕鬆加入預測觸控

00:28:56.103 --> 00:28:58.238 
每一幀 正如app獲得主觸控

00:28:58.338 --> 00:29:00.307 
你也可以獲得一組預測觸控

00:29:01.441 --> 00:29:04.111 
如果你獲得主觸控和接合觸控

00:29:04.311 --> 00:29:07.848 
那麼預測觸控是可以獲得的更多信息

00:29:08.916 --> 00:29:11.351 
在新觸控交付時會重複這一進程

00:29:12.352 --> 00:29:16.490 
要注意的是接合觸控的
和預測觸控是獨立的

00:29:16.757 --> 00:29:18.192 
你可以用其中一個而不用另一個

00:29:18.659 --> 00:29:21.195 
60赫茲和120赫茲
觸控掃描速率設備

00:29:21.361 --> 00:29:23.697 
均可支持預測觸控

00:29:25.499 --> 00:29:27.701 
我們先來看怎麼把觸控預測

00:29:28.001 --> 00:29:30.370 
加入我們剛纔看的代碼之中

00:29:32.005 --> 00:29:34.208 
只需要加上這一小部分代碼

00:29:35.008 --> 00:29:38.145 
我們要做的是首先刪除我們加入

00:29:38.212 --> 00:29:39.980 
代碼行中的之前的任何預測觸控

00:29:40.514 --> 00:29:44.284 
這很重要 因爲我們現在
有了這些觸控的實際位置

00:29:50.390 --> 00:29:53.327 
然後 我們會重複運行已有的預測觸控

00:29:54.228 --> 00:29:58.699 
對於每個預測觸控
我們把它加爲代碼行的樣本

00:29:59.633 --> 00:30:01.568 
但是注意 我們這裏加入預測樣本

00:30:01.668 --> 00:30:05.272 
調用的方法不同於調用常規樣本的方法

00:30:05.706 --> 00:30:10.444 
這樣我們可以將樣本標記爲
下次運行該代碼時需要將之刪除

00:30:11.945 --> 00:30:13.847 
這就是觸控接合和觸控預測

00:30:14.915 --> 00:30:16.717 
大家現在看到了所有這些技巧

00:30:16.783 --> 00:30:18.919 
我們來看看把它們
結合起來會是什麼效果

00:30:20.988 --> 00:30:23.524 
在iOS 8中 有個優化的app 

00:30:24.057 --> 00:30:25.792 
這就是你可以獲取的觸控延遲視圖

00:30:26.593 --> 00:30:28.395 
在觸控首次出現和顯示器

00:30:28.462 --> 00:30:30.163 
更新觸控信息之間 

00:30:30.797 --> 00:30:33.433 
我們測量延遲的時間

00:30:34.234 --> 00:30:35.836 
因此 你可以看到在iOS 8中

00:30:36.170 --> 00:30:37.538 
我們會有4幀延遲

00:30:39.072 --> 00:30:42.576 
通過使用低延遲Core 
Animation和iOS 9

00:30:42.776 --> 00:30:44.611 
我們可以從中刪除一幀延遲

00:30:45.746 --> 00:30:48.115 
通過使用觸控接合並在高觸控

00:30:48.215 --> 00:30:50.150 
掃描速率設備上運行

00:30:50.751 --> 00:30:55.956 
你不僅可以獲得用戶觸控的
更多信息量還可以從一開始

00:30:56.190 --> 00:30:56.990 
就刪除半幀延遲

00:30:58.926 --> 00:30:59.626 
但是不僅如此！

00:31:02.296 --> 00:31:03.864 
通過使用觸控預測你可以獲得

00:31:04.264 --> 00:31:08.635 
未來用戶觸控將往何處去的
大約一幀延遲

00:31:09.203 --> 00:31:12.105 
這會讓你爲用戶提供有效延遲

00:31:12.739 --> 00:31:14.942 
也可以減少一幀以上延遲

00:31:15.609 --> 00:31:18.979 
那麼算在一起
在 iOS 9 你可以爲用戶降低

00:31:19.046 --> 00:31:21.048 
約1.5幀延遲這要比iOS 8

00:31:21.281 --> 00:31:24.051 
中的4幀延遲提高很多

00:31:31.592 --> 00:31:32.893 
那麼我們覺得這的確了不得

00:31:32.993 --> 00:31:35.095 
我很希望大家在app中運用這些技術

00:31:35.162 --> 00:31:38.298 
爲用戶提供更低的延遲體驗

00:31:39.233 --> 00:31:41.134 
現在我想把講臺交回給彼得

00:31:41.435 --> 00:31:42.703 
請他來講講怎樣調試app

00:31:48.542 --> 00:31:49.710 
彼得·崔：謝謝 雅各布

00:31:50.444 --> 00:31:53.313 
現在我們瞭解了一些
iOS 9中的最新低延遲模式

00:31:53.480 --> 00:31:56.717 
我們還將介紹一些如何利用

00:31:57.150 --> 00:31:59.520 
這些來調試應用這樣就可以滿足

00:31:59.753 --> 00:32:05.325 
時間的一個顯示幀的要求
還可以把幀快速地顯示出來

00:32:06.260 --> 00:32:11.064 
首先 要確保應用在完成最少量的任務

00:32:11.131 --> 00:32:14.768 
則要將應用需要完成的任務量最小化

00:32:15.536 --> 00:32:18.839 
通過雅各布剛介紹的接合觸控API

00:32:19.373 --> 00:32:22.543 
你可以享用到iPad Air 2

00:32:22.643 --> 00:32:24.811 
高保真手寫輸入的好處同時確保

00:32:24.878 --> 00:32:28.448 
完成的任務量將在屏幕上顯示的圖像

00:32:29.483 --> 00:32:32.119 
此外 要記住用戶只會關心

00:32:32.186 --> 00:32:35.355 
在設備顯示器上可以看到的內容

00:32:35.956 --> 00:32:38.125 
應用可以跟蹤屏幕

00:32:38.659 --> 00:32:41.962 
以外的環境狀態

00:32:42.462 --> 00:32:46.333 
但是 最終 你需要確保
渲染工作要僅限於

00:32:46.667 --> 00:32:49.269 
那些最終要在屏幕上

00:32:49.469 --> 00:32:52.406 
生成顯示圖像的必要工作

00:32:54.875 --> 00:32:57.344 
如果準備構建應用

00:32:57.511 --> 00:33:01.248 
計算應用在CPU上

00:33:01.582 --> 00:33:04.117 
所花費時間 Time 
Profiler是個不錯的辦法

00:33:04.618 --> 00:33:07.321 
Time Profiler將通過

00:33:07.387 --> 00:33:10.724 
在固定間隔取樣 
顯示應用在CPU中所用的時間

00:33:11.358 --> 00:33:14.228 
在本例中在
Time Profiler

00:33:14.294 --> 00:33:17.397 
我選用的是16毫秒間隔

00:33:17.531 --> 00:33:19.700 
這基本和一個顯示幀相對應

00:33:20.634 --> 00:33:23.604 
你可以看出本例中的應用

00:33:23.804 --> 00:33:27.407 
只用了其中一小塊時間 

00:33:28.041 --> 00:33:29.710 
在本例中 是3毫秒

00:33:30.644 --> 00:33:33.080 
如果是要測量並簡要介紹

00:33:33.146 --> 00:33:36.183 
在CPU方面的表現這也沒問題

00:33:36.750 --> 00:33:37.885 
那麼GPU會怎樣呢？

00:33:39.586 --> 00:33:41.922 
在Xcode調試會話中GPU

00:33:41.989 --> 00:33:46.927 
報告中的每秒
傳輸幀數工具會爲應用的GPU

00:33:47.027 --> 00:33:48.829 
表現給出高層視圖

00:33:49.496 --> 00:33:53.267 
在本例中 你可以看到
這個應用是60幀每秒

00:33:53.800 --> 00:33:57.337 
這是相對較低的GPU幀時

00:33:57.638 --> 00:33:59.806 
在本例中僅爲3.8毫秒

00:34:00.774 --> 00:34:06.313 
不過要記住這是關於
應用運行的高層概視圖

00:34:06.780 --> 00:34:09.049 
其中並未提供也許會導致

00:34:09.116 --> 00:34:13.020 
掉幀的單獨幀的詳細信息

00:34:14.188 --> 00:34:16.123 
如果需要此類精度

00:34:16.723 --> 00:34:20.360 
可以使用新的GPU驅動工具

00:34:20.726 --> 00:34:22.462 
我們今年在Xcode中就有包括

00:34:23.597 --> 00:34:26.699 
GPU驅動工具可以
在你使用應用的同時

00:34:27.067 --> 00:34:30.204 
顯示GPU激活的準確時間

00:34:30.838 --> 00:34:33.473 
在本例中 你可以看到我的應用中

00:34:33.540 --> 00:34:37.844 
在頂點和片段着色器所用時間相對較少

00:34:38.145 --> 00:34:41.014 
實際上 這只是在顯示器上

00:34:41.348 --> 00:34:43.650 
顯示一幀內容所用時間的一小部分

00:34:45.118 --> 00:34:48.422 
注意這裏只有兩種顏色

00:34:48.989 --> 00:34:53.360 
這兩種顏色代表着使用
雙緩衝方案的兩個緩衝器

00:34:54.428 --> 00:34:58.031 
如果應用在
Core Animation

00:34:58.098 --> 00:35:01.368 
和GPU中花費更多時間你會在這裏

00:35:01.635 --> 00:35:04.905 
看到三種顏色代表系統裏
正在進行的三重緩衝

00:35:06.840 --> 00:35:09.776 
我們談了很多降低延遲的內容

00:35:09.977 --> 00:35:13.213 
並讓應用靈敏度更高不過最終

00:35:13.480 --> 00:35:16.884 
實現出色的iOS 體驗是用戶

00:35:16.950 --> 00:35:18.986 
自然和本能的體驗

00:35:19.319 --> 00:35:23.457 
而讓應用感覺更生動則是
實現這一目標的另一種不錯的方法

00:35:24.491 --> 00:35:29.796 
去年 我們對系統的
每個部件都進行了認真的思考 

00:35:29.863 --> 00:35:31.932 
想方設法使其比以前更快更好

00:35:32.699 --> 00:35:35.135 
在這一過程中我們改進了API

00:35:35.235 --> 00:35:37.638 
爲大家提供更多控制和信息

00:35:37.738 --> 00:35:39.106 
來瞭解系統的運行狀況

00:35:39.907 --> 00:35:43.277 
有了OpenGL Metal
和 Core Animation

00:35:43.377 --> 00:35:46.246 
的最新低延遲模式
你可以在向用戶顯示幀 

00:35:46.380 --> 00:35:49.950 
以及如何與屏幕上的其他內容 

00:35:50.017 --> 00:35:51.919 
同步的時候 實現更多控制

00:35:52.786 --> 00:35:56.323 
利用觸控接合你可以利用

00:35:56.390 --> 00:35:58.792 
所有硬件及其所有出色的功能 向用戶

00:35:59.126 --> 00:36:00.327 
提供出色體驗

00:36:00.627 --> 00:36:05.632 
使用觸控預測我們可以讓你
少許窺探未來預測觸控即將往何處去

00:36:06.800 --> 00:36:10.270 
最後我們構建
並生成部分不錯的工具

00:36:10.337 --> 00:36:15.042 
以便你瞭解應用的性能表現
這樣你可以對之進行改進 

00:36:15.242 --> 00:36:17.544 
以便向用戶提供更好的體驗

00:36:18.979 --> 00:36:21.782 
在Apple 我們致力於
讓我們的產品

00:36:21.849 --> 00:36:24.685 
使用體驗比以往更出色

00:36:24.751 --> 00:36:27.287 
我們認爲通過降低
延遲是實現這一點的不錯方法

00:36:27.621 --> 00:36:29.489 
我們願意邀請各位朝這方面努力

00:36:29.556 --> 00:36:31.525 
大家在
developer.apple.com

00:36:31.592 --> 00:36:36.997 
可以瞭解到我們今天探討的技術
工具和API等更多詳情

00:36:37.364 --> 00:36:39.733 
我們還想邀請大家參加開發者

00:36:40.000 --> 00:36:43.537 
論壇中的開發者

00:36:43.971 --> 00:36:46.106 
技術對話

00:36:47.708 --> 00:36:50.577 
我們今天介紹了許多不同的新技術

00:36:50.944 --> 00:36:53.614 
今年和往年有過許多

00:36:53.680 --> 00:36:57.784 
與這一講座相關話題的出色討論

00:36:58.452 --> 00:37:03.257 
例如 如果你非常感興趣簡要
介紹應用的GPU性能

00:37:03.690 --> 00:37:07.261 
如果非常非常想着手嘗試

00:37:07.327 --> 00:37:10.764 
新的GPU工具我將向大家推薦

00:37:10.831 --> 00:37:13.166 
《Metal性能優化技術》講座

00:37:13.433 --> 00:37:16.503 
這是今天早些時候的一場講座

00:37:17.137 --> 00:37:20.274 
其中介紹了一整套不同的技術 

00:37:20.340 --> 00:37:23.844 
可以用來優化GPU運行
而不只是說使用Metal

00:37:25.179 --> 00:37:29.216 
此外如果Time Profiler
常出問題 可以試試去聽

00:37:29.283 --> 00:37:32.986 
《深度剖析》講座
這是昨天的一場講座

00:37:33.487 --> 00:37:36.456 
其中深度剖析了該怎樣
使用Time Profiler

00:37:36.523 --> 00:37:38.892 
並瞭解你的應用完成任務的情況

00:37:39.826 --> 00:37:41.862 
最後 如果大家的確感興趣

00:37:41.929 --> 00:37:45.165 
在Core Animation和 
管線的GPU階段究竟在做些什麼

00:37:45.232 --> 00:37:46.600 
這部分內容我們今天講過

00:37:46.834 --> 00:37:48.802 
我將向大家推薦去年WWDC的

00:37:48.869 --> 00:37:51.371 
《高級圖形和動畫》講座

00:37:52.606 --> 00:37:55.442 
所有這些講座和許許多多其他講座

00:37:55.509 --> 00:37:58.612 
都可以在開發人員門戶網站找到
developer.apple.com

00:37:58.679 --> 00:38:02.282 
希望大家今天收穫很多
在本週的全部環節中

00:38:02.349 --> 00:38:05.719 
我希望大家喜歡WWDC的內容

00:38:05.786 --> 00:38:06.520 
謝謝