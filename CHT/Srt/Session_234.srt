00:00:19.753 --> 00:00:24.224 
構建基於文檔的app

00:00:25.893 --> 00:00:26.727 
謝謝

00:00:29.963 --> 00:00:30.797 
下午好

00:00:31.131 --> 00:00:34.635 
我是邁克·赫斯一名來自iOS
Apps和框架團隊的軟件工程師

00:00:35.002 --> 00:00:36.737 
今天我和約翰尼斯·福特曼一起

00:00:36.837 --> 00:00:40.407 
在這裏給大家講講怎樣讓
你的基於文檔的app脫穎而出

00:00:41.708 --> 00:00:43.977 
今天我們給你們寫了一些
示例代碼會展示給你們

00:00:44.211 --> 00:00:48.682 
如何構建一個基於文檔的
app的兩個主要元件

00:00:50.384 --> 00:00:54.288 
首先我們要向你演示如何構建
一個很棒的“文檔瀏覽器”

00:00:54.621 --> 00:00:57.491 
這樣你的用戶就可以很快
找到他們感興趣的文檔

00:00:57.558 --> 00:00:58.926 
需要處理的文檔

00:01:00.360 --> 00:01:03.931 
其次我們要向你們演示如何
構建一個能夠和文檔正確進行交互

00:01:04.397 --> 00:01:09.670 
協調處理併發閱讀程序和寫入程序
比如iCloud驅動守護進程

00:01:09.736 --> 00:01:11.505 
這樣一個很棒的文檔編輯器

00:01:12.439 --> 00:01:14.374 
我們稍後會深入講一下
iCloud驅動守護進程

00:01:14.741 --> 00:01:17.010 
首先我們來看看“文檔瀏覽器”

00:01:18.912 --> 00:01:21.048 
那麼什麼是基於文檔的app？

00:01:22.916 --> 00:01:26.620 
我們認爲一個文檔就是一個
單一的獨立的實體

00:01:26.687 --> 00:01:30.657 
用戶也把它理解爲一個單一的實體

00:01:31.325 --> 00:01:34.394 
那麼基於文檔的app就是一個
能夠管理這些文檔列表、

00:01:34.461 --> 00:01:37.331 
把文檔展示給用戶以便用戶對它們進行

00:01:37.397 --> 00:01:41.702 
查看 編輯 重命名的這樣一個app

00:01:43.003 --> 00:01:45.472 
比如說Keynote
就可以對Keynote文檔列表

00:01:45.539 --> 00:01:46.540 
進行管理

00:01:46.607 --> 00:01:51.378 
而Numbers這個應用程序就可以
管理Numbers電子表格文檔列表

00:01:51.678 --> 00:01:55.415 
就連Garage Band也可以對
Garage Band歌曲文檔進行管理

00:01:55.782 --> 00:01:59.520 
我們把這些都看作基於文檔的app

00:02:01.255 --> 00:02:04.958 
現在我們就來深入講一講
我們如何構建我們的“文檔瀏覽器”

00:02:06.493 --> 00:02:09.496 
一個很棒的“文檔瀏覽器”
有四個主要元件

00:02:11.832 --> 00:02:14.101 
首先我們希望能夠以對我們的用戶

00:02:14.168 --> 00:02:16.737 
有意義的方式列出我們的
文檔就像我們在這個

00:02:16.803 --> 00:02:20.240 
示例代碼中這樣根據文檔名
對文檔進行了分類

00:02:20.407 --> 00:02:23.644 
我們的用戶就可以理解
我們的app的流程

00:02:25.546 --> 00:02:27.581 
其次我們認爲你應該使用
縮略圖這樣文檔可見性

00:02:27.648 --> 00:02:30.317 
可以很棒你的用戶只需要一瞥

00:02:30.384 --> 00:02:34.354 
就可以快速找出他們感興趣的文檔

00:02:34.421 --> 00:02:36.023 
需要處理的文檔

00:02:38.158 --> 00:02:41.161 
第三我們想要展示我們的
app中所有可用的文檔

00:02:41.228 --> 00:02:44.565 
包括位於其它app的容器內的文檔

00:02:44.631 --> 00:02:47.835 
比如示例中的這個文檔它是位於

00:02:48.402 --> 00:02:51.605 
共享iCloud Drive容器上

00:02:53.207 --> 00:02:55.275 
第四，我們認爲保存一個
最近訪問的文檔列表

00:02:55.342 --> 00:02:58.912 
是個不錯的主意
這樣用戶就可以快速返回

00:02:59.513 --> 00:03:03.317 
他們當前正在處理的文檔

00:03:05.953 --> 00:03:08.589 
現在我們看看怎樣找出我們的

00:03:08.655 --> 00:03:10.324 
“文檔瀏覽器”上的文檔

00:03:12.826 --> 00:03:17.798 
一個笨辦法可能是使用
NSFileManager嘗試列出

00:03:17.865 --> 00:03:19.633 
你在雲端的文檔

00:03:19.933 --> 00:03:21.635 
但是這些結果是不完整的

00:03:23.537 --> 00:03:27.541 
比如說在iCloud有一個
文檔的概念

00:03:27.975 --> 00:03:29.977 
文檔位於那裏 但是內容還沒有實現

00:03:30.043 --> 00:03:32.679 
本地可見的文檔就是說

00:03:32.746 --> 00:03:34.248 
還沒有下載到磁盤上的文檔

00:03:34.414 --> 00:03:37.551 
NSFileManager並不能
正確獲得這些文檔

00:03:38.819 --> 00:03:42.155 
此外如果你試圖通過
NSFileManager來列出你的文檔

00:03:42.589 --> 00:03:44.424 
那麼外部文檔就不會包括進來

00:03:44.658 --> 00:03:47.594 
那麼你列出的也就不是你的app
可用的所有的文檔

00:03:48.829 --> 00:03:49.997 
我們來快速看一下

00:03:51.098 --> 00:03:53.567 
假如說你用的是
NSFileManager API

00:03:55.936 --> 00:03:57.971 
如果你用的是NSFileManager
你可能會獲得文檔一

00:03:58.038 --> 00:04:00.174 
以及這裏的文檔二
它們都已經完整下載到了

00:04:00.541 --> 00:04:03.477 
我們的app的容器的硬盤上

00:04:04.211 --> 00:04:06.613 
但是你遺漏了位於iCloud的

00:04:06.847 --> 00:04:08.982 
文檔三這個文檔

00:04:09.449 --> 00:04:13.620 
並且你也遺漏了位於另一個
app容器上的文檔四

00:04:13.720 --> 00:04:17.824 
而我們的用戶已經授予了你的
app訪問那個文檔的權限

00:04:18.291 --> 00:04:22.129 
因此當你列出你的文檔時你肯定不會
想用NSFileManager API

00:04:23.697 --> 00:04:26.099 
你想用的肯定是
NSMetadataQuery

00:04:27.134 --> 00:04:30.070 
我們來看看
NSMetadataQuery的工作原理

00:04:31.638 --> 00:04:35.008 
NSMetadataQuery會
獲得所有你的app可用的文檔

00:04:35.609 --> 00:04:38.679 
包括位於iCloud的文檔三

00:04:38.745 --> 00:04:42.149 
以及位於另一個app的容器
但是用戶已經授權了我們的

00:04:42.216 --> 00:04:45.719 
app查看那個文檔權限的文檔四

00:04:46.520 --> 00:04:50.257 
重點要注意的是這裏還有個文檔五
同樣位於另一個app的容器

00:04:50.457 --> 00:04:53.827 
但是用戶並未授予我們的app
查看那個文檔的權限

00:04:54.328 --> 00:04:57.664 
文檔五並沒有包括在
NSMetadataQuery結果中

00:04:57.731 --> 00:05:00.300 
因爲如果我們把那個文檔展示給用戶

00:05:00.367 --> 00:05:02.202 
那就構成了隱私泄漏

00:05:04.905 --> 00:05:06.840 
讓我們用
NSMetadataQuery

00:05:06.907 --> 00:05:08.175 
找出我們位於雲端的文檔

00:05:10.210 --> 00:05:11.745 
那麼流程是怎樣的呢？

00:05:13.013 --> 00:05:15.883 
首先你要創建你的
NSMetadataQuery

00:05:17.384 --> 00:05:21.054 
然後NSMetadataQuery
就會經過一個初始收集階段

00:05:21.188 --> 00:05:24.291 
列出所有當前對你的app可用的文檔

00:05:26.360 --> 00:05:28.729 
初始收集階段完成後

00:05:28.996 --> 00:05:31.965 
你會得到一條通知
然後你只需要在你的app的UI

00:05:32.032 --> 00:05:35.836 
主線程上把這些初始文檔
顯示出來就可以了

00:05:38.272 --> 00:05:40.874 
但是NSMetadataQuery
並不是到此就完事了

00:05:41.241 --> 00:05:45.112 
此外當雲端狀態發生變更時
你會收到更新通知

00:05:45.179 --> 00:05:48.315 
比如在這裏
iCloud Drive守護程序

00:05:49.016 --> 00:05:52.119 
向我們的app的容器內下載了
一個新文檔

00:05:52.186 --> 00:05:54.388 
我們就在我們的
NSMetadataQuery

00:05:54.454 --> 00:05:55.923 
上收到了關於這個文檔的通知

00:05:58.125 --> 00:06:02.696 
然後你只需要計算變更動畫

00:06:02.763 --> 00:06:06.733 
比如在這裏我們可能想要向
我們的CollectionView

00:06:07.100 --> 00:06:08.869 
插入一個
CollectionView單元

00:06:08.936 --> 00:06:12.773 
然後只需要把這個更新過的UI
顯示在我們的主線程上

00:06:16.510 --> 00:06:18.412 
既然我們已經知道了
怎樣找出我們的文檔

00:06:18.478 --> 00:06:21.915 
我們再來看看怎樣用文檔縮略圖

00:06:21.982 --> 00:06:23.584 
讓我們的UI更棒

00:06:30.457 --> 00:06:35.796 
我們認爲在你的UI顯示縮略圖
是一個不錯的主意

00:06:36.430 --> 00:06:38.866 
因爲它可以給你的用戶提供視覺語境

00:06:39.766 --> 00:06:43.403 
這樣你的用戶只需要一瞥
就可以找到他們感興趣的文檔

00:06:43.470 --> 00:06:45.839 
需要處理的文檔
因爲他們有了不錯的縮略圖

00:06:45.939 --> 00:06:47.474 
他們就可以很快找到文檔

00:06:48.775 --> 00:06:51.578 
iOS 9上有項新特性
會自動爲你創建某些特定的

00:06:51.645 --> 00:06:54.581 
通用文檔類型的縮略圖

00:06:54.648 --> 00:06:57.551 
比如說大的圖像文件舉個例子

00:07:00.087 --> 00:07:02.923 
現在我們再來看看你加載你的縮略圖

00:07:02.990 --> 00:07:06.627 
顯示在你的app的UI的工作流程

00:07:07.861 --> 00:07:09.663 
這裏要重點注意的是

00:07:09.730 --> 00:07:14.334 
加載縮略圖涉及向內存中
加載數量可能很大的數據

00:07:14.968 --> 00:07:20.641 
可能會很慢因此加載你的縮略圖數據時
你肯定不想阻塞你的主線程

00:07:21.708 --> 00:07:23.744 
首先讓我們看一個工作
流程實例應該可以

00:07:24.311 --> 00:07:26.480 
這就是我們的示例代碼app的
工作流程

00:07:27.948 --> 00:07:30.083 
首先在我們的示例代碼中我們
有一個CollectionView

00:07:30.150 --> 00:07:33.687 
CollectionView讓我們加載一個
CollectionView單元

00:07:34.755 --> 00:07:40.494 
我們要通過一個後臺進程
安排讀取縮略圖

00:07:40.561 --> 00:07:42.763 
因爲我們尚未緩存完畢縮略圖

00:07:44.431 --> 00:07:47.668 
現在我們並不會等待完成讀取縮略圖

00:07:48.268 --> 00:07:51.205 
我們要立即返回一個帶有佔位圖像的

00:07:51.271 --> 00:07:55.142 
CollectionView單元
這樣用戶就知道那裏有圖像

00:07:56.476 --> 00:08:00.080 
之後某個時間完成讀取縮略圖後

00:08:01.081 --> 00:08:03.383 
我們會通知我們的
CollectionView

00:08:03.450 --> 00:08:05.118 
需要重新加載那個單元

00:08:06.153 --> 00:08:10.224 
然後我們只要在我們的UI的
那個單元上顯示我們的縮略圖就可以了

00:08:12.793 --> 00:08:17.631 
好的 然我們已經知道了怎樣找出
文檔怎樣用漂亮的縮略圖

00:08:17.698 --> 00:08:20.934 
把它們顯示出來
我們再來看看怎樣管理最近列表

00:08:23.470 --> 00:08:25.772 
我們認爲你可能想用最近列表

00:08:25.839 --> 00:08:29.610 
因爲最近訪問的文檔通常就是用戶

00:08:29.676 --> 00:08:32.578 
正在處理的文檔

00:08:33.614 --> 00:08:37.384 
因此存儲這些文檔的這樣
一個列表是個不錯的主意

00:08:37.451 --> 00:08:39.486 
這樣你的用戶就可以快速返回文檔中

00:08:41.989 --> 00:08:45.425 
同樣地一個笨辦法可能是
使用NSURLs來存儲一個

00:08:45.492 --> 00:08:48.395 
最近訪問的文檔的最近列表

00:08:48.795 --> 00:08:51.431 
但是像之前NSFileManager
已經出現的那樣

00:08:51.565 --> 00:08:53.534 
這樣有很多缺陷

00:08:54.835 --> 00:08:56.203 
我們來快速看一下

00:08:57.471 --> 00:09:02.342 
假如說我們向最近訪問的文檔
存儲一個NSURLs列表

00:09:02.910 --> 00:09:06.413 
但是在我們的app不運行時
iCloud Drive守護程序移動了文檔

00:09:06.580 --> 00:09:09.616 
比如像這樣移動到了一個新文件夾

00:09:11.185 --> 00:09:14.755 
現在NSURL就成了一個受損引用
沒法解算我們的文檔

00:09:14.988 --> 00:09:17.391 
在磁盤上更改後的位置

00:09:18.091 --> 00:09:22.162 
因此我們不能靠它來存儲
我們的最近列表

00:09:24.231 --> 00:09:28.669 
存儲最近列表的正確方法
是使用安全範圍書籤

00:09:30.170 --> 00:09:34.007 
這裏如果我們向這個文檔
存儲了一個安全範圍書籤

00:09:34.575 --> 00:09:37.778 
而iCloud Drive
守護程序再次把這個文檔

00:09:37.845 --> 00:09:42.783 
移動到了一個文件夾
那麼書籤就會自動更新

00:09:42.916 --> 00:09:46.954 
解算文檔在磁盤上的新位置
因此當我們管理我們的最近列表時

00:09:47.020 --> 00:09:48.689 
我們應該使用安全範圍書籤

00:09:51.058 --> 00:09:53.594 
我想快速做個演示

00:09:54.161 --> 00:09:56.396 
看看我們如何管理我們的最近列表

00:09:56.496 --> 00:09:58.198 
如何加載縮略圖

00:10:07.541 --> 00:10:09.610 
好的讓我們在這裏啓動我們的示例代碼

00:10:10.110 --> 00:10:12.379 
我們尚未向我們的app中加載縮略圖

00:10:15.382 --> 00:10:19.219 
但是舉例來說如果
我使用新的多任務處理

00:10:19.286 --> 00:10:22.322 
功能打開iCloud Drive
app 我們就可以看到

00:10:22.389 --> 00:10:24.258 
這些文檔的縮略圖已經在那裏了

00:10:25.392 --> 00:10:29.029 
我們只需要加載它們
顯示到我們的app的UI上即可

00:10:31.532 --> 00:10:33.734 
我們來看看它在代碼中是什麼樣的

00:10:38.071 --> 00:10:42.276 
好的 首先我們來講講如何在代碼中
管理我們的最近列表

00:10:46.313 --> 00:10:47.681 
這裏有件重要的事情

00:10:49.650 --> 00:10:54.821 
當我們在這裏保存對象時我們使用了

00:10:55.455 --> 00:10:59.793 
“標記帶有選項數據”
的方法來進行標記

00:11:00.160 --> 00:11:04.398 
這裏重要的是要傳遞
“適合標記文檔”選項

00:11:04.665 --> 00:11:06.533 
這樣我們就可以稍後進行解算

00:11:08.602 --> 00:11:10.470 
我們的app啓動後我們使用書籤

00:11:10.771 --> 00:11:15.742 
調用了“經由解算標記數據”
NSURL構造符方法

00:11:15.809 --> 00:11:19.313 
這是我們之前保存的
然後我們得到了一個URL

00:11:19.379 --> 00:11:22.416 
就是我們的文檔在磁盤上的
更新後的位置

00:11:24.384 --> 00:11:27.721 
這裏重要的是有了這個返回的URL

00:11:27.788 --> 00:11:30.791 
我們需要調用
“開始訪問資源的安全範圍”

00:11:31.191 --> 00:11:33.460 
防止這個文檔是
另一個app的容器內的文檔

00:11:33.527 --> 00:11:39.433 
否則我們就無法讀取這個文檔
因爲...這個文檔的讀屬性

00:11:39.666 --> 00:11:42.603 
因爲這樣就會讓我們的沙盒

00:11:42.936 --> 00:11:44.705 
訪問到這個文檔

00:11:47.441 --> 00:11:51.311 
那麼對於縮略圖來說
我們已經爲你在示例代碼中

00:11:51.378 --> 00:11:55.949 
寫好了這個很棒的縮略圖緩存類

00:11:56.016 --> 00:11:59.720 
可以爲我們的app緩存我們的縮略圖

00:12:01.021 --> 00:12:03.423 
這會讓我們如釋重負

00:12:03.490 --> 00:12:06.727 
比如調度在後臺進程中加載縮略圖等等

00:12:06.793 --> 00:12:10.731 
然後通知我們的
CollectionView

00:12:10.797 --> 00:12:12.432 
我們需要重新加載單元

00:12:13.166 --> 00:12:14.902 
我們最後一個沒有實現的

00:12:15.502 --> 00:12:17.171 
是這裏的這個代碼塊

00:12:17.437 --> 00:12:20.641 
它會從磁盤上加載我們的縮略圖

00:12:22.109 --> 00:12:24.711 
我們只需要在帶有一個
縮略圖字典鍵的URL上

00:12:24.778 --> 00:12:29.583 
調用“獲取鍵的承諾項目資源值”
這個NSURL方法

00:12:30.350 --> 00:12:33.587 
然後我們就會得到一本縮略圖字典

00:12:33.687 --> 00:12:37.357 
然後我們只需要從字典上抽出
UIImage然後把它返回到

00:12:37.958 --> 00:12:41.995 
我們的縮略圖類這樣我們就可以顯示它

00:12:42.930 --> 00:12:46.900 
這裏重要的是使用
“獲取鍵的承諾項目資源值”

00:12:46.967 --> 00:12:49.336 
來代替“獲取鍵的資源值”

00:12:49.837 --> 00:12:52.639 
因爲文檔可能還沒有實現內容本地可用

00:12:53.040 --> 00:12:59.613 
這樣即使尚未下載我們
也可以展示我們的縮略圖

00:13:02.482 --> 00:13:05.485 
我們需要做的就是重新部署下

00:13:08.555 --> 00:13:10.591 
這樣我們的app裏就有了
一些很棒的縮略圖

00:13:11.258 --> 00:13:14.761 
是在後臺加載的這樣當我們示例代碼中

00:13:14.828 --> 00:13:17.865 
滾動時它們就不會阻塞我們的滾動

00:13:19.233 --> 00:13:20.400 
好的讓我們回到幻燈片

00:13:27.541 --> 00:13:30.544 
關於構建一個“文檔瀏覽器”
我們學到了什麼？

00:13:32.179 --> 00:13:33.714 
首先我們學到了我們應該使用

00:13:33.780 --> 00:13:37.150 
NSMetadataQuery而
不是其它方法來找出我們的文檔

00:13:37.217 --> 00:13:43.023 
這樣我們就可以
找到所有我們的app可用的文檔

00:13:44.458 --> 00:13:47.928 
其次我們學到了我們應該在
我們的app的UI展示縮略圖

00:13:48.428 --> 00:13:50.631 
這樣我們就可以構建一些很棒的UI

00:13:50.697 --> 00:13:53.600 
我們的用戶也可以很快找到
他們正在處理的文檔

00:13:54.535 --> 00:13:56.436 
最後我們學到了我們應該使用書籤

00:13:56.503 --> 00:13:58.639 
而不是其它方法來存儲我們的最近列表

00:13:58.705 --> 00:14:01.608 
這樣用戶就可以快速回到

00:14:01.675 --> 00:14:03.744 
他們正在處理的文檔

00:14:04.378 --> 00:14:07.548 
那麼我想請約翰尼斯·福特曼上臺來

00:14:07.614 --> 00:14:09.716 
給你們講講如何構建文檔編輯器

00:14:15.822 --> 00:14:16.657 
謝謝 邁克

00:14:17.991 --> 00:14:18.992 
邁克剛纔向你們展示了

00:14:19.193 --> 00:14:22.563 
如何在你的應用程序內構建
一個漂亮的“文檔瀏覽器”

00:14:23.130 --> 00:14:26.500 
當然這會讓我們的app非常漂亮

00:14:26.633 --> 00:14:28.302 
但是同等重要的

00:14:28.368 --> 00:14:32.339 
甚至可能更重要的是你的應用程序中

00:14:32.406 --> 00:14:36.443 
你的用戶可以加載編輯文檔的那一部分

00:14:36.877 --> 00:14:40.113 
畢竟用戶就是爲了這個目的
而試圖使用你的應用程序

00:14:41.281 --> 00:14:45.018 
在我們開始講整個
加載寫入變更文檔之前

00:14:45.085 --> 00:14:48.889 
我們先來快速看看一個叫做

00:14:49.223 --> 00:14:51.658 
文件的協調性的概念

00:14:52.793 --> 00:14:54.761 
我在這裏講的是什麼？

00:14:55.963 --> 00:15:01.635 
在我們新的現代
基於多任務處理的世界中

00:15:01.969 --> 00:15:06.540 
這個概念指的是多個
app訪問顯示同一文件

00:15:07.841 --> 00:15:11.211 
舉個例子我們可以在iCloud
Drive app顯示

00:15:11.578 --> 00:15:15.415 
你的文檔容器內的全部
文件的概述的同時

00:15:16.083 --> 00:15:21.588 
讓你的app運行並且
讓用戶編輯這個文檔

00:15:22.856 --> 00:15:26.093 
或者還有一種更保守的方法

00:15:26.493 --> 00:15:30.464 
即使你的用戶沒有使用這個
兩個在前多任務處理視圖

00:15:30.531 --> 00:15:34.101 
也可能經常出現iCloud
Drive同步守護程序

00:15:34.601 --> 00:15:37.070 
可能想要訪問這個文檔進行雲端同步

00:15:37.838 --> 00:15:44.044 
而同時你的用戶正在編輯這個文檔

00:15:44.111 --> 00:15:46.446 
實際上這是一種非常常見的情況

00:15:46.914 --> 00:15:49.650 
因爲用戶正在編輯這個文檔

00:15:50.284 --> 00:15:52.586 
他們把這個文檔保存到了磁盤

00:15:53.287 --> 00:15:56.190 
這個文檔當然就發生了變化
因此iCloud Drive守護程序

00:15:56.523 --> 00:15:59.426 
就想確保它在雲端也進行更新了

00:16:00.861 --> 00:16:05.866 
因此這是一種常見的情況

00:16:06.633 --> 00:16:10.137 
我們來看看你的用戶正在磁盤上

00:16:10.204 --> 00:16:13.507 
編輯這個文檔這一具體案例

00:16:14.341 --> 00:16:16.977 
當然你的app看起來正在運行中

00:16:17.578 --> 00:16:19.346 
用戶正在進行編輯

00:16:19.913 --> 00:16:22.816 
同時你的應用程序正在

00:16:23.016 --> 00:16:29.056 
自動保存定期把這個文檔寫入磁盤

00:16:29.590 --> 00:16:31.859 
這樣我們在某一時刻有一個寫入操作

00:16:32.559 --> 00:16:35.762 
然後之後某個時刻我們又有用戶編輯

00:16:36.196 --> 00:16:39.032 
變更文檔的這樣一個操作
然後我們又有一個寫入操作

00:16:40.033 --> 00:16:43.136 
很好 我們假設在某個時刻
我們的用戶充分利用了

00:16:43.637 --> 00:16:45.606 
這個多任務處理功能也就是說

00:16:45.672 --> 00:16:51.311 
當他們編輯這個文檔時他們還同時

00:16:51.712 --> 00:16:53.413 
運行着另外一個應用程序

00:16:54.248 --> 00:16:57.684 
這個其它應用程序可能
之前對這個文檔有一個引用

00:16:57.751 --> 00:17:01.555 
並不會立即進行狀態恢復

00:17:01.622 --> 00:17:05.559 
舉例來說即試圖從磁盤上讀取這個文檔

00:17:06.727 --> 00:17:11.031 
現在你可以看到這種情況很糟糕

00:17:11.598 --> 00:17:14.800 
因爲當我們讀取這個文檔時同時還有

00:17:14.902 --> 00:17:16.737 
另外一個應用程序對它進行寫入操作

00:17:17.738 --> 00:17:19.406 
這實際上就是我們的應用程序

00:17:19.873 --> 00:17:22.142 
我們得到的就是這個不一致的讀取

00:17:22.542 --> 00:17:24.178 
當然這很不幸

00:17:24.778 --> 00:17:26.445 
我們正在寫入這個文檔但是同時

00:17:26.512 --> 00:17:28.382 
另一個應用程序又正在讀取這個文檔

00:17:29.049 --> 00:17:32.019 
數據僅僅寫了一半到磁盤
另一半還沒有寫入

00:17:32.619 --> 00:17:35.189 
出現這種怪異的不一致的數據時

00:17:35.255 --> 00:17:37.090 
其它app可能就不知道應該怎麼做

00:17:37.591 --> 00:17:38.759 
這種情況很糟糕

00:17:39.927 --> 00:17:43.830 
同樣地即使我們設法挺了過去

00:17:44.264 --> 00:17:46.600 
我們第二次寫入後別忘了

00:17:46.667 --> 00:17:49.436 
我們現在仍然正在第一個
應用程序中編輯這個文檔

00:17:50.270 --> 00:17:54.842 
其它應用程序現在仍然
正在顯示你的文檔

00:17:55.809 --> 00:18:00.914 
其它應用程序現在正在
顯示你的文檔的舊版本

00:18:00.981 --> 00:18:04.551 
我們就遇到了過時顯示這樣一個問題

00:18:05.953 --> 00:18:08.021 
當然出現這種情況很不幸

00:18:08.689 --> 00:18:11.758 
這裏我們給你們準備了
兩個方便的解決方法

00:18:12.693 --> 00:18:16.530 
首先我們有了這個文件的協調性的概念

00:18:17.631 --> 00:18:22.202 
文件的協調性是一種
分佈式閱讀程序/寫入程序加鎖機制

00:18:23.003 --> 00:18:26.740 
這就意味着
雖然任何時候多個閱讀程序

00:18:26.807 --> 00:18:29.810 
都可以讀取同一個文檔
但是每次卻只能有一個寫入程序

00:18:30.344 --> 00:18:35.782 
這個寫入程序會禁止
其它任何閱讀程序進行讀取

00:18:37.284 --> 00:18:39.620 
這就意味着如果我們的應用程序

00:18:39.686 --> 00:18:42.956 
就像使用UIDocument那樣
使用正確的文件的協調性

00:18:43.423 --> 00:18:45.692 
這些機制就會生效

00:18:46.326 --> 00:18:51.532 
我們的讀取操作就會被推遲到
我們的寫入操作完成後

00:18:51.965 --> 00:18:54.601 
這樣我們就能始終保持

00:18:55.202 --> 00:18:59.606 
這個文檔一致的形象

00:19:00.307 --> 00:19:01.141 
非常棒

00:19:02.309 --> 00:19:05.245 
我向你們保證這裏還有一個機制

00:19:05.546 --> 00:19:08.282 
這裏的這個機制是
NSFilePresentation

00:19:09.249 --> 00:19:12.119 
NSFilePresentation
是一種分佈式修改機制

00:19:12.920 --> 00:19:16.790 
這就意味着我們的文件的協調性會

00:19:17.157 --> 00:19:20.227 
自動告訴所有其它的文件提出器

00:19:20.294 --> 00:19:24.298 
你的文檔已經登記過了已經寫入了磁盤

00:19:24.865 --> 00:19:27.768 
文件提出器需要對自身進行更新

00:19:29.069 --> 00:19:32.005 
這樣在我們的第二次寫入後
我們就可以立即得到一個通知

00:19:32.072 --> 00:19:35.909 
我們就可以放心地更新我們的UI了

00:19:36.877 --> 00:19:43.884 
很好我們就是這樣來確認我們的文檔
總是保存一致的形象

00:19:44.418 --> 00:19:45.719 
但是文檔是什麼？

00:19:46.753 --> 00:19:49.456 
當然我們首先需要創建一些文檔

00:19:49.523 --> 00:19:52.226 
這樣纔可以顯示文檔讓用戶編輯文檔

00:19:52.726 --> 00:19:53.894 
我們來看看這個

00:19:54.795 --> 00:19:57.564 
我們創建這些文檔的目的是什麼？

00:19:57.865 --> 00:20:01.268 
讓我們想象下
當我們實現我們的示例app時

00:20:01.335 --> 00:20:03.670 
我們在右上角有這樣一個
小的“加號”按鈕

00:20:04.071 --> 00:20:07.040 
這是個加號按鈕用戶點擊下

00:20:07.107 --> 00:20:10.811 
我們可能會彈出一個
示例對話或是類似的東西

00:20:11.078 --> 00:20:14.014 
不過我們總會在某個時刻創建一個文檔

00:20:14.581 --> 00:20:16.783 
在這裏我們的主要目的是

00:20:17.084 --> 00:20:21.188 
給用戶一個一致的顯示

00:20:21.822 --> 00:20:23.857 
並且這個顯示總是最新的

00:20:24.291 --> 00:20:28.228 
如果用戶點擊這個小加號按鈕
那就沒什麼大用

00:20:28.629 --> 00:20:31.431 
我們現在並不會在我們的
“文檔瀏覽器”內得到更新

00:20:31.498 --> 00:20:35.035 
用戶就會困惑不解不知道發生了什麼

00:20:35.102 --> 00:20:37.738 
用戶可能會再點擊幾次這個加號按鈕

00:20:37.804 --> 00:20:40.707 
現在我們有了五個不同的新文檔
這可不太妙

00:20:40.941 --> 00:20:46.813 
如果不使用文件的協調性
我們最後就可能出現

00:20:47.447 --> 00:20:51.752 
現在這種情況當然了這是因爲...

00:20:51.818 --> 00:20:54.254 
這就意味着我們在
磁盤上創建了一個文檔

00:20:55.088 --> 00:20:57.724 
之後某個時刻iCloud
Drive守護程序注意到了

00:20:57.991 --> 00:21:01.895 
這個新文檔然後通知我們的app

00:21:01.962 --> 00:21:06.233 
這個延遲可能在半秒左右

00:21:06.300 --> 00:21:08.669 
如果守護程序現在正忙
延遲時間可能會更長

00:21:09.503 --> 00:21:12.339 
我們正是想要避免這種延遲

00:21:13.006 --> 00:21:17.144 
如果你使用文件的協調性
那現在就很方便了

00:21:17.611 --> 00:21:19.613 
會直接替你完成

00:21:20.814 --> 00:21:25.853 
協同運行會與你用來
在你的瀏覽器中顯示文檔的

00:21:26.119 --> 00:21:28.522 
NSMetadataQuery一起

00:21:28.589 --> 00:21:34.628 
協力也就是在協調完成後

00:21:34.695 --> 00:21:37.598 
進行迴路循環立即告訴

00:21:38.031 --> 00:21:40.300 
你正在運行的查詢出現了

00:21:40.868 --> 00:21:43.036 
一個新的更新後的文檔

00:21:44.338 --> 00:21:46.874 
這樣我們就幹掉了這個令人厭惡的延遲

00:21:48.308 --> 00:21:50.711 
當然這裏還是要提醒你們一件事

00:21:51.311 --> 00:21:53.714 
因爲我們是在磁盤上進行寫入

00:21:54.214 --> 00:21:57.551 
無論我們往磁盤上寫入什麼都需要時間

00:21:58.619 --> 00:22:03.090 
當然了在主線程上執行任何需要

00:22:03.156 --> 00:22:06.093 
時間的操作都很不幸

00:22:06.159 --> 00:22:09.363 
因爲它會阻塞主線程
讓你的應用程序在用戶看來

00:22:09.429 --> 00:22:11.632 
就像成了一個結巴

00:22:15.936 --> 00:22:18.605 
當然瞭解決這個也很容易

00:22:19.173 --> 00:22:20.607 
我們要使用一個後臺進程

00:22:20.674 --> 00:22:25.712 
來發送這一協同運行來確保

00:22:25.979 --> 00:22:31.518 
我們的操作不會阻塞主線程

00:22:32.352 --> 00:22:34.154 
幸運的是我們仍然...

00:22:34.221 --> 00:22:36.056 
因爲我們仍然在用這個協同運行

00:22:36.623 --> 00:22:40.928 
我們就仍然可以在我們的UI
上得到立即更新的顯示

00:22:40.994 --> 00:22:44.331 
這是因爲我們的
NSMetadataQuery

00:22:44.798 --> 00:22:46.333 
仍然是直接更新的

00:22:47.234 --> 00:22:49.436 
你甚至都不需要把這個信息
彈回給主線程

00:22:49.503 --> 00:22:51.405 
這是因爲我們是在直接更新

00:22:51.471 --> 00:22:53.040 
NSMetadataQuery

00:22:54.374 --> 00:22:59.046 
很好 另一個常用的
操作是刪除某個文檔

00:23:00.180 --> 00:23:03.317 
對於你的用戶來說
這是再正常不過的事

00:23:03.383 --> 00:23:05.752 
這個文檔他們不用了
他們想把這個文檔刪掉

00:23:06.119 --> 00:23:07.688 
這樣就不會弄亂他們的工作區

00:23:08.255 --> 00:23:12.226 
刪除文檔背後的基本理念
仍然是一模一樣的

00:23:12.926 --> 00:23:17.664 
我們會通過我們的後臺線程
協調某個寫入操作

00:23:17.998 --> 00:23:21.902 
在本次寫入時執行刪除操作然後通過
NSMetadataQuery

00:23:21.969 --> 00:23:27.040 
回送給主線程及時進行更新

00:23:29.042 --> 00:23:35.983 
很好 你就是這樣通過你們的
後臺進程對創建刪除文檔進行管理的

00:23:36.984 --> 00:23:42.256 
我們來看看你到底想用這些文檔幹什麼

00:23:42.956 --> 00:23:45.726 
當然你想顯示這些文檔

00:23:46.493 --> 00:23:48.562 
也就是說你想讀寫這些文檔

00:23:49.396 --> 00:23:52.666 
現在我們強烈推薦你使用

00:23:52.733 --> 00:23:55.502 
UIDocument來讀寫文檔

00:23:56.036 --> 00:24:00.841 
UIDocument會實現
NSFileCoordination調用

00:24:01.008 --> 00:24:03.977 
這樣可以確保你在任何時候
進行讀寫文檔時

00:24:04.044 --> 00:24:06.046 
都是以一種協調的方式進行

00:24:07.314 --> 00:24:12.119 
此外它還會實現
NSFilePresentation

00:24:12.319 --> 00:24:13.987 
確保會立即通知這個文檔發生了變更

00:24:14.054 --> 00:24:17.591 
可以在你的顯示中立即更新了

00:24:19.026 --> 00:24:20.928 
我們來看看怎樣讀取一個文檔

00:24:21.662 --> 00:24:25.332 
你創建一個UIDocument對象
然後在這個UIDocument實例中

00:24:25.399 --> 00:24:28.302 
簡單調用這個“完成後打開”方法

00:24:29.203 --> 00:24:32.973 
這種方法會通過一個後臺工作隊列

00:24:33.674 --> 00:24:35.375 
取出一個協調讀取

00:24:36.510 --> 00:24:40.147 
這樣你的應用程序就可以保持
完美的性能和響應性

00:24:40.981 --> 00:24:44.818 
同時你的文檔可以對自身進行讀入

00:24:45.652 --> 00:24:49.523 
那麼現在你需要做的

00:24:49.823 --> 00:24:52.292 
就是實現“通過內容載入”這個方法

00:24:53.293 --> 00:24:55.662 
這種方法會在協調讀入中簡單調用

00:24:55.829 --> 00:24:58.298 
因此就被這個協調讀入給封裝了

00:24:58.398 --> 00:25:01.602 
這就意味着在那裏
讀入任何你想要的東西

00:25:01.668 --> 00:25:05.305 
都是絕對安全的 
請聽清楚是來自那個文檔

00:25:06.139 --> 00:25:09.843 
那麼你需要做的就是取出內容

00:25:09.910 --> 00:25:13.814 
然後把它們填入你的文檔數據

00:25:14.448 --> 00:25:17.885 
現在這裏還有一種方法

00:25:18.118 --> 00:25:20.521 
你也可以選擇實現這種方法

00:25:21.522 --> 00:25:25.893 
它會取出一個
NSURL而不是一大堆數據

00:25:26.727 --> 00:25:30.430 
你也可以把這個方法用於
舉例來說流文檔

00:25:30.497 --> 00:25:34.935 
有時候你可能更有理由這麼做

00:25:35.502 --> 00:25:40.240 
這是因爲舉例來說磁盤上的文檔格式
與你在內存中想要的格式完全不同

00:25:41.208 --> 00:25:44.778 
完成後我們只需要回送給主隊列

00:25:44.845 --> 00:25:48.815 
然後調用你提供給我們的完成塊

00:25:49.249 --> 00:25:53.620 
在那個完成塊中你可以舉例來說

00:25:53.687 --> 00:25:57.491 
爲你的文檔推送更新你的新界面

00:26:00.227 --> 00:26:03.397 
很好讀入一個文檔的原理就是這樣的

00:26:03.897 --> 00:26:06.967 
不過別忘了麥克告訴過你們

00:26:07.034 --> 00:26:09.036 
這個概念叫做“約定”

00:26:09.770 --> 00:26:16.109 
一項“約定”指的是iCloud 
Drive守護程序允諾給你的app

00:26:16.410 --> 00:26:20.681 
某個文檔就在那裏
但是還沒有進行下載

00:26:21.949 --> 00:26:24.084 
這就意味着對這個文檔進行讀入

00:26:24.151 --> 00:26:26.320 
就可能會觸發一次下載

00:26:27.688 --> 00:26:32.025 
當然瞭如果你像我們一樣

00:26:32.092 --> 00:26:38.165 
生活在真實的世界中
很明顯下載有時候會很慢

00:26:38.465 --> 00:26:41.768 
依據你的文檔大小下載可能

00:26:42.269 --> 00:26:43.370 
需要一段時間

00:26:43.971 --> 00:26:49.409 
你的用戶可能把這次下載
歸咎於你的app出了問題

00:26:49.710 --> 00:26:51.879 
這很不公平這不是你的錯

00:26:52.479 --> 00:26:56.917 
本次下載所處的網絡連接很慢
需要一點時間

00:26:57.684 --> 00:27:02.723 
我們在iOS 9中爲你準備了一項
新特性我們公開了一種通過

00:27:02.789 --> 00:27:05.759 
新的
NSProgressReporting協議

00:27:06.126 --> 00:27:09.663 
在UIDocuments上顯示
進度的方法

00:27:10.697 --> 00:27:12.633 
實現這個非常簡單

00:27:13.133 --> 00:27:18.639 
NSProgressReporting協議在你的
UIDocument實例上公開了一項

00:27:19.173 --> 00:27:24.878 
進度屬性這項進度屬性是我們填寫的
顯示給你我們的進度如何了

00:27:25.546 --> 00:27:29.116 
基本上這就是下載狀態的
一項簡單的百分比

00:27:30.350 --> 00:27:35.989 
我們現在通過一個狀態變換
公開了這項NSProgress屬性

00:27:36.390 --> 00:27:39.993 
這樣你就可以把它顯示爲
你在你的文檔狀態上

00:27:40.894 --> 00:27:44.831 
監聽到的狀態變換通知

00:27:46.133 --> 00:27:50.304 
當狀態發生變換時你就可以
看到帶有下列內容的新標誌

00:27:50.571 --> 00:27:53.040 
“你好我在這裏公開了一條進度”

00:27:54.007 --> 00:27:55.809 
然後你只要顯示這個進度就可以了

00:27:56.510 --> 00:28:00.314 
舉例來說在一個
UIProgress視圖上顯示一個進度

00:28:00.614 --> 00:28:02.449 
過去往往比較複雜

00:28:02.883 --> 00:28:05.018 
這是因爲它公開了一項
你需要把值觀測鍵入

00:28:05.085 --> 00:28:08.722 
這個進度視圖的屬性

00:28:09.389 --> 00:28:13.627 
當然我們也意識到了這一點
還是在iOS 9上

00:28:13.861 --> 00:28:17.097 
我們在UIProgress視圖新公
開了一項觀測進度屬性

00:28:17.698 --> 00:28:23.237 
你就可以直接把NSProgress
弄到進度視圖

00:28:23.770 --> 00:28:25.606 
你只需要把
NSProgress分配給

00:28:25.873 --> 00:28:28.375 
進度視圖的“觀測進度”屬性

00:28:29.076 --> 00:28:31.879 
它就會自動更新它的計數

00:28:33.514 --> 00:28:35.048 
對你來說這非常方便

00:28:38.252 --> 00:28:43.123 
謝謝 那麼你只需要監聽
下次狀態變換

00:28:43.223 --> 00:28:47.861 
監聽這樣的信號：
“你好我們把這個進度搞完了”

00:28:48.729 --> 00:28:53.433 
此時你可能想取消顯示你的
UIProgress視圖

00:28:53.834 --> 00:28:57.237 
準備顯示新的文檔控制器

00:28:58.872 --> 00:29:01.675 
很好 這就是讀入文檔

00:29:01.875 --> 00:29:03.710 
當然我們還想寫入文檔

00:29:04.344 --> 00:29:08.048 
寫入文檔和讀入文檔是對稱的

00:29:08.715 --> 00:29:12.085 
我們寫入文檔的方式
就是在一條後臺進程上

00:29:12.152 --> 00:29:15.122 
取出一個協調文件的協調性

00:29:15.923 --> 00:29:19.526 
這個略微有點不同不是由你來啓動它

00:29:19.993 --> 00:29:23.597 
而是由UIDocument
自動通知說現在非常適合

00:29:24.164 --> 00:29:27.835 
保存文檔

00:29:28.135 --> 00:29:31.905 
比如說因爲有一陣沒有編輯進來

00:29:31.972 --> 00:29:36.543 
或者因爲文檔上次保存後
已經過去了一段時間

00:29:37.611 --> 00:29:40.647 
或者因爲用戶把你的
應用程序放到了後臺

00:29:40.714 --> 00:29:43.450 
那麼這個時候保存文檔就非常合適

00:29:44.117 --> 00:29:47.688 
不過這種實現方式
和讀入一個文檔是非常

00:29:47.754 --> 00:29:51.091 
對稱的我們只需要在
你的UIDocument實例上

00:29:51.158 --> 00:29:52.759 
調用“類型內容”

00:29:53.160 --> 00:29:56.830 
然後你把你從那裏返回的
NSData實例填進去

00:29:57.865 --> 00:30:00.534 
非常好 這裏還有一件事

00:30:00.834 --> 00:30:04.004 
此時寫入一幅縮略圖也非常方便

00:30:04.771 --> 00:30:08.375 
正如麥克告訴你們的
我們會爲某些非常特定的文檔

00:30:08.642 --> 00:30:12.980 
格式自動生成縮略圖
不過有很大機率你正在構建的東西

00:30:13.046 --> 00:30:16.149 
和我們正在構建的東西並不完全一致

00:30:16.683 --> 00:30:21.421 
因此如果你沒有使用我們的
非常通用的格式來

00:30:21.488 --> 00:30:25.526 
進行構建像圖像或者簡單文本

00:30:25.959 --> 00:30:28.896 
那麼你就想自己寫入縮略圖

00:30:29.930 --> 00:30:32.466 
現在你這樣實現的方式

00:30:32.533 --> 00:30:35.068 
我們稱之爲在
你的UIDocument上

00:30:35.135 --> 00:30:37.871 
“自行寫入文件屬性”方法

00:30:39.039 --> 00:30:42.676 
使用這種方法
你只需要當成你的屬性字典的一部分

00:30:42.943 --> 00:30:45.078 
返回一個UIImage實例

00:30:46.280 --> 00:30:48.215 
在這個實例中我們會在寫入你的文檔

00:30:49.116 --> 00:30:53.520 
包含於同一協調寫入上進行寫入

00:30:54.188 --> 00:30:56.390 
這就意味着如果此時用戶

00:30:56.456 --> 00:31:01.762 
在一個單獨的窗格中打開了
“文檔瀏覽器”

00:31:02.196 --> 00:31:04.331 
他們就不會看到不一致的狀態

00:31:05.098 --> 00:31:10.270 
很好 這裏重點需要記住的是
這是在一條後臺進程上調用的

00:31:10.971 --> 00:31:14.007 
這就意味着在任何情況下

00:31:14.074 --> 00:31:17.678 
你都不能用UIViews
來寫入...來渲染你的縮略圖

00:31:18.212 --> 00:31:21.148 
UIViews不屬於線程安全
因此你需要確保你的縮略圖

00:31:21.481 --> 00:31:23.717 
渲染是通過舉例來說

00:31:24.218 --> 00:31:28.088 
Core Graphics
或者textKit

00:31:28.455 --> 00:31:33.060 
或者任何其它我們在我們的
平臺上提供的線程安全渲染機制來進行

00:31:33.293 --> 00:31:38.532 
在iOS 8上訪問一個文檔的
唯一機制是通過一個副本來訪問

00:31:39.299 --> 00:31:42.169 
原因在於一般來說應用程序

00:31:42.236 --> 00:31:45.005 
不能訪問彼此的沙盒

00:31:45.372 --> 00:31:48.976 
因此如果我們有兩個應用程序
沙盒那麼從一個沙盒

00:31:49.343 --> 00:31:53.380 
移動到另一個沙盒的
唯一方式就是第一個應用程序

00:31:53.647 --> 00:31:58.151 
在另一個應用程序的
沙盒內生成一個副本

00:31:58.752 --> 00:32:04.525 
現在通過使用UIDocument
菜單視圖控制器我們就可以鬆口氣了

00:32:04.992 --> 00:32:10.297 
它允許你的應用程序
在另一個應用程序的容器內進行拉取

00:32:11.131 --> 00:32:15.536 
不過一般來說你不會
僅僅打開一個文檔就算了

00:32:16.203 --> 00:32:19.306 
每次打開這個文檔都會生成一個副本

00:32:20.340 --> 00:32:24.578 
當然 處理這些副本就非常方便了

00:32:24.711 --> 00:32:27.748 
因爲你現在其它應用程序的
容器內有一個你的

00:32:28.081 --> 00:32:30.584 
文檔的副本用戶會對它進行修改

00:32:30.651 --> 00:32:33.220 
這樣你就會得到這個文檔的第二個版本

00:32:33.854 --> 00:32:36.590 
現在舉例來說回到你的應用程序中

00:32:36.657 --> 00:32:39.459 
用戶想打開這個文檔

00:32:40.160 --> 00:32:42.763 
這樣就會生成第三個副本

00:32:43.197 --> 00:32:46.700 
現在漂浮着的
你有文檔的三個不同的版本

00:32:47.401 --> 00:32:50.504 
這很不幸因爲用戶會感到困惑不解

00:32:50.938 --> 00:32:52.873 
不知道哪個版本是最近的版本

00:32:54.308 --> 00:32:56.710 
這種情況可不太妙

00:32:57.945 --> 00:33:00.681 
現在在iOS 9中
我們有了這個漂亮的新機制

00:33:00.747 --> 00:33:01.949 
叫做“就地打開”

00:33:03.150 --> 00:33:05.853 
這意味着通過使用文檔交互控制器

00:33:05.986 --> 00:33:08.255 
你的應用程序可以授予另一個應用程序

00:33:08.856 --> 00:33:14.561 
訪問一個文檔的權限

00:33:15.896 --> 00:33:18.599 
文檔還是一模一樣的

00:33:18.665 --> 00:33:22.436 
這不是一個副本
而是對這個文檔的一個副本

00:33:23.670 --> 00:33:27.975 
當然了這就意味着
另一個應用程序就可以進行編輯

00:33:28.308 --> 00:33:30.611 
然後通過展示文件這一魔法

00:33:30.677 --> 00:33:34.414 
直接反射到你的應用程序中

00:33:36.116 --> 00:33:38.552 
當然了這對用戶來說就非常方便

00:33:39.119 --> 00:33:42.389 
這包括通過iCloud Drive
app以及通過Spotlight

00:33:42.689 --> 00:33:43.557 
打開的文件

00:33:44.491 --> 00:33:48.729 
這就意味着你的用戶任何時候在
iCloud Drive app中

00:33:48.996 --> 00:33:55.068 
瀏覽他們的文檔時我們就可以直接
就地打開那個文檔

00:33:56.703 --> 00:33:59.139 
這個背後的機制
和“文檔菜單視圖控制器”

00:33:59.206 --> 00:34:01.909 
中使用的機制非常相似

00:34:02.476 --> 00:34:05.012 
這就意味着如果你的應用程序
已經對此提供支持了

00:34:05.679 --> 00:34:08.315 
那麼對你來說支持這種機制
就不費吹灰之力

00:34:09.315 --> 00:34:12.619 
即使你現在不支持
UIMenuViewController

00:34:12.686 --> 00:34:15.255 
採用這種機制也不費吹灰之力

00:34:15.322 --> 00:34:18.659 
因爲這並不是多麼神奇的東西

00:34:18.725 --> 00:34:20.226 
你獲得一個URL後

00:34:20.494 --> 00:34:23.597 
就把它放入你稍後將要展示的
一個UIDocument實例中 

00:34:24.697 --> 00:34:28.135 
我們現在來快速看看
你怎樣可以對此提供支持

00:34:29.969 --> 00:34:31.271 
就像我之前說的非常簡單

00:34:31.871 --> 00:34:33.907 
首先你要告訴我們你對此提供支持了

00:34:34.574 --> 00:34:36.143 
記住當我們試圖找出我們是否要

00:34:36.210 --> 00:34:41.614 
就地打開這個文件時
你的app可能在那時並不會啓動

00:34:42.149 --> 00:34:43.617 
因此你要事先告訴我們

00:34:44.284 --> 00:34:48.621 
你需要在你的Info.plist中
採用“LS支持就地打開文檔”

00:34:48.688 --> 00:34:50.791 
這個鍵來告知我們

00:34:51.190 --> 00:34:53.159 
根據你用的是Objective-C
還是Swift不同

00:34:53.226 --> 00:34:55.295 
你只需要把它設置成
爲“是”或者“真”即可

00:34:55.996 --> 00:35:02.336 
這樣就可以告訴我們
你的應用程序可以處理這個了

00:35:03.136 --> 00:35:05.873 
你還需要再寫一點代碼

00:35:06.540 --> 00:35:09.109 
是一種新的委託方法

00:35:10.177 --> 00:35:11.078 
那個看起來怎麼樣？

00:35:11.678 --> 00:35:15.015 
假如說你已經在這裏打開了文檔

00:35:15.649 --> 00:35:18.919 
這樣假設很合理這是因爲
你的app是基於文檔的

00:35:19.353 --> 00:35:23.757 
因此你實現的方法
肯定就和我們在這裏看到的非常類似

00:35:24.591 --> 00:35:28.262 
現在你的方法肯定
得到了一個NSURL

00:35:29.129 --> 00:35:32.332 
因爲這個NSURL是
系統爲你的app創建的

00:35:32.399 --> 00:35:35.602 
臨時副本你就需要把這個副本複製到

00:35:36.670 --> 00:35:40.674 
你自己的容器然後打開這個複製文件

00:35:41.642 --> 00:35:46.313 
這一小塊代碼的作用就是這個

00:35:46.880 --> 00:35:49.449 
現在首先要做的
是在這裏採用我們的新方法

00:35:50.250 --> 00:35:53.320 
這種新方法和舊方法非常相似

00:35:53.854 --> 00:35:56.423 
它只是取得了一本選項字典

00:35:57.157 --> 00:36:01.295 
對之前的方法的參數進行封裝

00:36:01.929 --> 00:36:05.832 
重要的是其中的一個參數是
“就地打開”鍵

00:36:07.067 --> 00:36:11.672 
現在你要做的，
就是看看這個“就地打開”鍵

00:36:12.039 --> 00:36:13.607 
是否爲真如果這個鍵爲真

00:36:14.741 --> 00:36:18.445 
那麼你的應用程序應該就可以
就地打開這個文件了

00:36:18.812 --> 00:36:20.848 
這就意味着它不應該生成副本

00:36:21.648 --> 00:36:24.585 
很簡單你不應該再做
你之前不得不做的事了

00:36:26.119 --> 00:36:29.089 
現在你有了這個URL

00:36:29.523 --> 00:36:34.194 
你只需要照着之前的打開方式
打開它就可以了

00:36:36.196 --> 00:36:38.665 
支持就地打開就是這麼簡單

00:36:40.467 --> 00:36:43.003 
很好 我們來總結下今天學到的東西

00:36:43.904 --> 00:36:47.341 
我們已經看過了怎樣讓你的app
性能響應性很高

00:36:47.407 --> 00:36:53.247 
看過了使用NSMetadataQuery
來展示一組文檔並且當雲端

00:36:53.313 --> 00:36:58.118 
有變更發生時及時更新這些文檔

00:36:58.218 --> 00:36:59.753 
這種方法有多麼漂亮

00:37:00.587 --> 00:37:04.258 
我們還看到了怎樣使用
書籤來實現最近訪問機制

00:37:04.892 --> 00:37:07.294 
這樣你的用戶就可以很快返回

00:37:07.427 --> 00:37:09.897 
他們之前的狀態...
他們之前所處的文檔

00:37:10.631 --> 00:37:12.733 
當然有些事情我們沒有說

00:37:12.799 --> 00:37:14.468 
但是也非常合理

00:37:14.668 --> 00:37:17.204 
即你也可以使用書籤來實現狀態恢復

00:37:17.704 --> 00:37:21.742 
這樣你的用戶就可以直接返回
他們之前所處的狀態

00:37:22.809 --> 00:37:26.180 
我們還看到了怎樣使用縮略圖
讓你的應用程序非常美觀

00:37:26.547 --> 00:37:30.350 
看到了怎樣實現進度顯示
確保你的用戶

00:37:30.417 --> 00:37:33.253 
始終清楚在他們的
應用程序內發生了什麼

00:37:34.121 --> 00:37:37.491 
最後我們也看到了實現
就地打開有多麼容易

00:37:38.125 --> 00:37:41.461 
就地打開是個很棒的新機制
你的用戶就可以直接在

00:37:41.762 --> 00:37:45.632 
你的應用程序內打開文檔

00:37:46.166 --> 00:37:49.036 
而不用複製多份副本

00:37:50.470 --> 00:37:54.942 
我們今天發佈的一個示例代碼
對所有的這些概念

00:37:55.008 --> 00:37:57.144 
都做了一個漂亮的展示

00:37:57.744 --> 00:37:59.813 
這個示例代碼實際上
就是麥克之前在演示中

00:37:59.880 --> 00:38:01.415 
向你們演示的那個

00:38:01.915 --> 00:38:03.684 
它實現了所有的這些特徵特性

00:38:04.151 --> 00:38:07.120 
即在一個“文檔瀏覽器”中創建文檔

00:38:08.155 --> 00:38:13.360 
展示文檔生成這些文檔的變更動畫

00:38:13.827 --> 00:38:18.098 
當然還有寫入縮略圖當然還有就地打開

00:38:19.066 --> 00:38:22.703 
如果你需要獲得技術支持
我們建議你去我們的論壇

00:38:23.737 --> 00:38:27.341 
你可以看到在這個鏈接下面
我們也有很棒的資料

00:38:28.242 --> 00:38:32.145 
如果你想了解關於使用
“UIDocument菜單視圖控制器”

00:38:32.212 --> 00:38:33.447 
的更多信息

00:38:33.981 --> 00:38:39.386 
來實現拉取機制，
而不是就地打開工具的拉取機制

00:38:39.887 --> 00:38:45.359 
這樣你的應用程序就可以
從另一個應用程序的容器內拉取文檔

00:38:45.893 --> 00:38:50.197 
或者你對如何實現基於UIDocument
的應用程序略感興趣

00:38:50.664 --> 00:38:53.267 
我們建議你觀看我們去年的會議

00:38:54.101 --> 00:38:57.004 
即去年的會議234

00:38:57.604 --> 00:38:59.273 
當然你在網上也找得到

00:39:00.040 --> 00:39:01.608 
那麼謝謝你抽出時間參會

00:39:01.875 --> 00:39:03.210 
祝你下午過得愉快