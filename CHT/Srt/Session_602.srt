00:00:20.287 --> 00:00:23.423 
以Model I/O
進行3D資源管理

00:00:24.958 --> 00:00:25.792 
大家好

00:00:25.859 --> 00:00:28.495 
歡迎來到這場關於以Model
I/O進行3D資源管理的演講

00:00:28.562 --> 00:00:31.798 
我是尼克 來自圖像 媒體 和圖形組

00:00:33.567 --> 00:00:38.505 
今天我很高興向大家介紹新的
Model I/O框架

00:00:38.972 --> 00:00:43.110 
我們正在提高...
或者說我們其實是正在讓大家

00:00:43.177 --> 00:00:46.580 
能夠提高交互式的真實感圖形的品質

00:00:47.047 --> 00:00:53.720 
到目前爲止你們一直使用的
圖形框架和硬件都是過去開發的

00:00:53.954 --> 00:00:56.957 
當時的硬件與現在相比有太多的侷限

00:00:57.558 --> 00:00:59.860 
而現在你們口袋裏的設備
擁有的功能絕對令人驚豔

00:01:00.160 --> 00:01:04.697 
現在我們有了新的框架
使你們能夠充分發揮硬件的作用

00:01:04.765 --> 00:01:08.468 
爲客戶服務但是你們
必須不斷給這個框架

00:01:09.002 --> 00:01:11.071 
增添真正好看的元素

00:01:11.638 --> 00:01:16.410 
所以既然現在有了高性能

00:01:17.411 --> 00:01:21.114 
和低功耗圖形應用程序接口
你們就需要一種方法來把

00:01:21.181 --> 00:01:24.985 
圖片製作得具有真實感真實感意味着
圖片要基於現實存在源於現實存在

00:01:25.552 --> 00:01:29.890 
那麼你們需要做有很多的研究
還要有大量相關的知識

00:01:30.057 --> 00:01:31.158 
才能實現這個目標

00:01:31.692 --> 00:01:33.760 
你們需要了解相機的物理原理

00:01:33.827 --> 00:01:36.263 
各種材料的物理特性光的物理特性

00:01:37.364 --> 00:01:39.633 
當然你們也可以多讀相關的資料

00:01:39.700 --> 00:01:41.034 
我很贊成這種做法

00:01:41.468 --> 00:01:45.806 
要有效運用那些材料和光需要
做大量繁瑣的工作

00:01:46.440 --> 00:01:49.042 
閱讀大量的資料然後再進行集成運用

00:01:50.010 --> 00:01:53.747 
那麼我們對Model I/O所做的
就是我們已經着手進行這些工作

00:01:54.248 --> 00:01:57.484 
我們已經進行了大量的研究
我們已做了一大堆的集成

00:01:57.985 --> 00:02:01.221 
我們已經準備了一套統一的數據結構

00:02:01.288 --> 00:02:05.158 
來連貫一致地描述這些性能我們還
開發了一個使用簡便的應用程序接口

00:02:06.460 --> 00:02:10.030 
所以說Model I/O是一個處理

00:02:10.097 --> 00:02:12.332 
3D資源和數據的框架

00:02:12.999 --> 00:02:17.337 
所以在最基本的層面上
你們可以利用Model I/O

00:02:17.604 --> 00:02:20.874 
導入和輸出常見格式的文件

00:02:21.675 --> 00:02:25.679 
你們可以以現實的方式描述採光情況

00:02:25.913 --> 00:02:27.381 
各種材料 環境條件

00:02:28.182 --> 00:02:31.351 
你們可以將美工人員提供的資源和作品

00:02:31.785 --> 00:02:35.022 
導入Model I/O
再進行一些有趣的處理

00:02:35.088 --> 00:02:37.858 
在演講過程中我們會講到處理方法

00:02:38.492 --> 00:02:42.095 
現在有很多可以運用的工具

00:02:42.229 --> 00:02:47.401 
其主要關注點都是進行
基於物理特性的渲染和材料屬性

00:02:47.835 --> 00:02:52.039 
I/O模型讓你們可以通過
自己的管道利用那些工具

00:02:54.141 --> 00:02:57.244 
Model I/O已經集
成到Xcode 7裏

00:02:57.311 --> 00:02:59.213 
還有GameKit的應用程序接口裏

00:02:59.279 --> 00:03:03.417 
可以在iOS 9
和OS10.11中運行

00:03:04.785 --> 00:03:09.590 
所以概括地說這個綠色的大盒子是

00:03:10.090 --> 00:03:12.192 
Model I/O與你們的框架

00:03:12.593 --> 00:03:13.961 
或應用程序想融合的地方

00:03:14.561 --> 00:03:17.831 
我們就從聯繫創建工具講起
首先美工人員製作一些很好的作品

00:03:18.465 --> 00:03:20.601 
然後你們要將其
導入Model I/O

00:03:21.201 --> 00:03:26.607 
接下來由Model I/O快速完成那些
原本繁瑣乏味又容易出現錯誤的步驟

00:03:26.807 --> 00:03:32.112 
爲各種框架創建緩衝區進行快速渲染

00:03:32.646 --> 00:03:36.416 
在這個盒子之外我們所支持的
框架有SceneKit

00:03:36.650 --> 00:03:37.885 
Metal 和 OpenGL

00:03:40.621 --> 00:03:45.058 
現在Model I/O不僅可以
加載文件和保存文件

00:03:45.692 --> 00:03:48.462 
它還讓你們能夠進行原本有用

00:03:48.595 --> 00:03:50.731 
但耗時太長或有其他弊端的操作

00:03:51.098 --> 00:03:53.534 
來改善資源的外觀

00:03:54.201 --> 00:03:56.470 
你們可以選取一項資源

00:03:56.770 --> 00:03:59.339 
對其進行接下來我會談到
的各種熱處理操作的其中一項

00:03:59.573 --> 00:04:02.342 
再把這項資源恢復成統一
的表示形式導回Model I/O

00:04:03.076 --> 00:04:05.746 
再把它放到硬件準備緩衝區

00:04:07.381 --> 00:04:12.786 
你也可以先利用Model I/O

00:04:13.187 --> 00:04:15.222 
提供的獨特的功能對資源進行處理

00:04:15.322 --> 00:04:18.225 
完成這裏的循環然後把它發送回

00:04:18.291 --> 00:04:20.260 
內容創作工具讓美工人員

00:04:20.793 --> 00:04:24.398 
進行調整也許再添加一些
比如細節處理或進行其他改進

00:04:24.865 --> 00:04:28.502 
然後你可以不斷重複這個循環
直到達到你的app 

00:04:28.635 --> 00:04:30.971 
所需要的外觀和質量水平爲止

00:04:33.240 --> 00:04:37.611 
那麼我們今天要講的是這些功能是什麼

00:04:38.579 --> 00:04:39.446 
其數據類型是什麼

00:04:39.513 --> 00:04:41.982 
那些數據類型的物理動機從何而來

00:04:42.683 --> 00:04:47.521 
我們將談論如何支持
各種幾何功能三維像素

00:04:48.121 --> 00:04:52.726 
和一些先進的光照技巧
以及我們的熱處理步驟

00:04:56.897 --> 00:05:00.534 
好的 我們開始麪包和黃油資料讀取中

00:05:01.435 --> 00:05:05.272 
導入格式我們從

00:05:05.672 --> 00:05:09.109 
一些最常用的格式開始

00:05:11.211 --> 00:05:14.915 
蒸餾器是一種性能非常高的格式

00:05:15.148 --> 00:05:19.453 
它來自電影行業現在
也大量在遊戲中使用

00:05:20.020 --> 00:05:23.824 
這這裏所列出的格式中它是最現代的

00:05:23.891 --> 00:05:28.629 
它包括了關於動畫和材料綁定的信息

00:05:28.695 --> 00:05:30.797 
還有其他各種各樣的有趣的信息

00:05:31.331 --> 00:05:34.735 
多邊形是多邊形的
標準格式使用這個格式

00:05:34.801 --> 00:05:36.770 
需要進行大量的學術研究

00:05:37.271 --> 00:05:43.777 
三角形通常用CAD和CAM這兩種
應用程序製作和攝取

00:05:44.278 --> 00:05:47.681 
而且Wavefront .obj
文件可以得到普遍的讀寫支持

00:05:48.382 --> 00:05:50.250 
如果要在此刻進行導出

00:05:50.484 --> 00:05:54.521 
你可以導出你的
CAD / CAM材料

00:05:57.758 --> 00:05:59.760 
所以導入很容易

00:06:00.027 --> 00:06:02.930 
你使用URL通過內核自行啓動
得到一個MDL資源

00:06:03.430 --> 00:06:07.034 
然後你可以用“輸出資源到URL”
把它導出到其他位置

00:06:09.837 --> 00:06:12.706 
關於物理真實感我還要再說幾句

00:06:12.840 --> 00:06:16.376 
但是不做太細緻的解釋

00:06:16.610 --> 00:06:20.280 
光照一直以來都要有一個位置

00:06:20.547 --> 00:06:23.584 
比如一個錐角衰減區

00:06:24.151 --> 00:06:26.420 
還要有其他一些從物理
角度來看不真實的參數

00:06:26.486 --> 00:06:28.622 
這些參數只是在數學上與過去的硬件和

00:06:28.689 --> 00:06:30.324 
圖形應用程序接口相統一

00:06:30.858 --> 00:06:36.029 
我們現在要爲大家提供的
是對IES概要文件的訪問方法

00:06:36.263 --> 00:06:39.499 
現在如果你去五金店並且發現

00:06:39.633 --> 00:06:41.068 
比如你非常喜歡的一款燈具

00:06:41.168 --> 00:06:43.904 
比如說我真的很喜歡那裏的那款燈
而且我在商店裏看到了它

00:06:44.204 --> 00:06:48.108 
我可以先讀一下旁邊的標籤
再去生產商的網站

00:06:48.609 --> 00:06:51.111 
在網上我可以找到一個IES概要文件

00:06:51.178 --> 00:06:54.681 
它是一個數據文件
裏面有關於這種燈的各種數據

00:06:54.781 --> 00:06:57.851 
我能瞭解每一個角度燈光的輻照度

00:06:58.919 --> 00:07:01.321 
我們把那個文件讀入到
一個所謂的輕型網絡

00:07:01.655 --> 00:07:04.992 
就是一組很容易加載到着色器裏的數據

00:07:05.459 --> 00:07:09.029 
那麼如果你願意你可以在你的着色器裏

00:07:09.229 --> 00:07:11.832 
親自點亮可與真實世界的燈媲美的燈

00:07:12.466 --> 00:07:14.701 
現在你在五金店裏買燈時

00:07:15.002 --> 00:07:17.971 
不會專門提出RGB值或類似的要求

00:07:18.038 --> 00:07:21.742 
燈的特點通常由溫度描述
比如4000開氏度或其他度數

00:07:22.309 --> 00:07:25.512 
那麼你也可以用開氏度來指定這些高度

00:07:26.046 --> 00:07:28.815 
我們還可以提供基於那邊正在工作的

00:07:28.949 --> 00:07:30.384 
挖掘機的燈光的圖像

00:07:31.084 --> 00:07:35.289 
這些材料以前都需要使用傳感器 

00:07:35.455 --> 00:07:38.325 
這意味着隨角度衰減現象

00:07:38.792 --> 00:07:40.594 
並且在Blinn-Phong高光區

00:07:40.661 --> 00:07:42.896 
會有可調節的亮點

00:07:43.430 --> 00:07:44.498 
我們還爲你們提供

00:07:44.598 --> 00:07:48.035 
一個基線物理雙向反射函數

00:07:48.101 --> 00:07:52.806 
也可以叫做BRDF如果你想要取得

00:07:53.006 --> 00:07:54.641 
絕對逼真的效果你絕度需要這個函數

00:07:55.075 --> 00:07:59.413 
請注意那臺挖掘機上就有BDRF

00:08:00.314 --> 00:08:03.350 
相機歷來是針孔相機

00:08:03.717 --> 00:08:06.820 
描述相機時我們
從鏡頭一直介紹到傳感器

00:08:07.221 --> 00:08:09.356 
現在我們爲你們提供一些實用程序

00:08:09.456 --> 00:08:12.926 
來處理照片和程序中的各種環境元素

00:08:16.029 --> 00:08:19.600 
現在你們會看到
用Xcode中的工具做熱處理

00:08:19.967 --> 00:08:23.203 
在這張幻燈片上我要告訴你們

00:08:24.238 --> 00:08:26.206 
在Xcode中你可以用來

00:08:26.340 --> 00:08:29.943 
執行這些操作的工具你也可以
通過框架在Model I/O中使用

00:08:30.511 --> 00:08:32.044 
所以如果你想製作自己的管線

00:08:32.179 --> 00:08:35.682 
你自己的離線管道以便對自己的資源

00:08:35.749 --> 00:08:39.019 
進行徹底的熱處理無論批次大小

00:08:39.419 --> 00:08:41.321 
都可以通過應用程序接口框架

00:08:41.922 --> 00:08:43.056 
使用那些工具

00:08:45.626 --> 00:08:47.561 
我們已經介紹了三維像素

00:08:47.828 --> 00:08:50.864 
你們可以選取一個又大又舊的網格
把它變成巨大的索引緩存

00:08:50.931 --> 00:08:52.666 
你們可以把自己的數據與它關聯起來

00:08:53.066 --> 00:08:54.168 
稍後我們會就此多談一些

00:08:55.002 --> 00:08:56.904 
再說一次在資源的基礎上

00:08:57.271 --> 00:09:01.441 
創建三維像素以及
在特定區域找到三維像素非常簡單

00:09:01.675 --> 00:09:03.610 
你們可以運用實體幾何構造法

00:09:03.677 --> 00:09:05.946 
還可以把三維像素導回到一個網格

00:09:06.446 --> 00:09:07.948 
期間可以利用數據平滑法

00:09:08.415 --> 00:09:09.249 
類似的做法吧

00:09:11.118 --> 00:09:16.190 
所以通過系統集成
將Model I/O直接集成到

00:09:16.990 --> 00:09:21.395 
SceneKit中可以在
MetalKit和GLKit中使用

00:09:22.596 --> 00:09:26.600 
在取景器和快速瀏覽功能中
Model I/O是用來做預覽的

00:09:26.667 --> 00:09:30.470 
所以你可以去找一個蒸餾器
abc緩存文件按下空格鍵

00:09:30.537 --> 00:09:32.806 
然後會彈出取景器
你可反覆查看你的資源

00:09:32.873 --> 00:09:36.643 
甚至不用打開任何類型的
試鏡環境對其進行預覽

00:09:37.411 --> 00:09:39.646 
您可以在Xcode中編輯資源

00:09:39.913 --> 00:09:43.750 
這張圖片中的挖掘機就是
用Xcode進行加載的

00:09:44.284 --> 00:09:48.021 
Model I/O使用Swift
語言在Playgrounds中工作

00:09:50.757 --> 00:09:54.161 
好 這一切可以歸結到數據類型的本質

00:09:55.395 --> 00:10:00.601 
所以從一個URL得到的是MDL資源

00:10:01.001 --> 00:10:04.071 
它包含了你們往往會處理的所有對象

00:10:04.671 --> 00:10:08.242 
它是一個你知道
快速列舉素材資料的索引容器

00:10:08.709 --> 00:10:11.311 
它有變換層次結構 網格

00:10:11.578 --> 00:10:14.748 
相機和燈光 這些你可以
利用應用程序接口進行製作

00:10:15.148 --> 00:10:17.284 
或通過URL加載

00:10:18.285 --> 00:10:20.754 
所以一項典型的
你可以利用的asset

00:10:21.088 --> 00:10:24.958 
比如一個又大又舊的蒸餾器文件
會包含很多有趣的東西

00:10:26.026 --> 00:10:31.098 
這個舉一個例子裏面有幾個攝像頭

00:10:31.298 --> 00:10:34.234 
一盞燈 一個根變換

00:10:34.301 --> 00:10:36.470 
以及右上角的藍色框

00:10:36.837 --> 00:10:39.740 
下面是挖掘機的信息

00:10:39.806 --> 00:10:42.409 
橙色的框顯示 是的

00:10:42.476 --> 00:10:45.312 
橙色的框只是表明你也可以顯示
你的材料賦值情況

00:10:45.913 --> 00:10:47.581 
這就是資源所包含的信息

00:10:48.015 --> 00:10:50.784 
這都是邏輯上的應爲一體的東西

00:10:50.851 --> 00:10:53.420 
所以你就有了很多的資源
把它們組合成一個場景

00:10:55.756 --> 00:11:00.360 
asset有內存分配器

00:11:00.794 --> 00:11:04.865 
你需要的話可以添加分配器
自己管理內存

00:11:05.499 --> 00:11:10.470 
Asset有內部事務描述符

00:11:10.971 --> 00:11:13.040 
這是導入導出工具

00:11:13.407 --> 00:11:14.775 
和大量子工具

00:11:15.342 --> 00:11:17.811 
這些子工具都是MDL對象

00:11:19.713 --> 00:11:23.050 
MDL對象自身可以組成一個層

00:11:24.685 --> 00:11:28.856 
現在完成了一個典型的標準圖
當然應該有轉換層

00:11:30.490 --> 00:11:35.162 
MDL對象有轉換組件

00:11:36.296 --> 00:11:39.333 
我們並沒有執行轉換

00:11:39.399 --> 00:11:41.368 
你知道這是放置矩陣的標準步驟

00:11:41.435 --> 00:11:43.003 
實際上我們有轉換組件

00:11:43.537 --> 00:11:45.706 
這種組件非常有意思

00:11:45.839 --> 00:11:47.741 
因爲它允許我們創建一種場景圖

00:11:47.808 --> 00:11:52.479 
這種場景圖不必有父/子的類型關係

00:11:52.946 --> 00:11:55.349 
另外可以定義自己的組件

00:11:56.717 --> 00:12:00.687 
現在我想我應該已經提到了那個好東西

00:12:01.088 --> 00:12:04.691 
編寫自定義導入導出器的
API已經設計出來了

00:12:05.125 --> 00:12:08.629 
你可以編寫如果你有自定義的文件格式

00:12:09.363 --> 00:12:12.399 
你可以編寫倒入導出氣讓我們回來

00:12:12.866 --> 00:12:17.838 
這裏有個自定義的觸發器組件

00:12:17.905 --> 00:12:21.241 
它擁有了一組你自己的功能
會發生一系列相應的動作

00:12:21.708 --> 00:12:24.978 
這個編寫自定義導入導出器的API
可以讓你自己創建功能

00:12:25.045 --> 00:12:28.515 
並定義它的動作是什麼定義它連接什麼

00:12:29.383 --> 00:12:33.587 
現在一個網格包含一個
或多個頂點緩衝區

00:12:33.954 --> 00:12:38.158 
這是需要GPU進行位圖化的位置

00:12:38.859 --> 00:12:41.228 
法向下面是子網格

00:12:42.262 --> 00:12:45.999 
要想知道子網格實際是什麼

00:12:46.667 --> 00:12:50.637 
你應該有一個驅動挖掘器的功能

00:12:51.071 --> 00:12:53.740 
這個功能應該有些像
安全帽一樣的可選組件

00:12:54.074 --> 00:12:55.876 
這個組件不應該是可選的但它確實是

00:12:56.443 --> 00:13:01.181 
在一個索引緩存中
我應該有整個沒有可選組建功能

00:13:01.315 --> 00:13:03.417 
在另一個索引緩存中

00:13:03.483 --> 00:13:05.953 
我應該有所有指向
原始網格頂點緩存的索引

00:13:06.353 --> 00:13:08.222 
它裏面應該有可選組件

00:13:08.789 --> 00:13:10.791 
所以通過渲染或者不渲染子網格

00:13:11.024 --> 00:13:12.759 
網格會有可選組件或者沒有可選組件

00:13:14.895 --> 00:13:17.130 
子網格之間可以用頂點緩存共享數據

00:13:17.197 --> 00:13:20.000 
所以這將會允許你向硬件單獨提交

00:13:21.735 --> 00:13:26.039 
因此網格除了有頂點和索引緩存

00:13:27.140 --> 00:13:30.511 
還有功能函數以及產生

00:13:30.577 --> 00:13:32.913 
常用事物的生成模板
例如盒子 球等等

00:13:34.214 --> 00:13:35.349 
還有調節器

00:13:35.716 --> 00:13:39.419 
如果一個網格沒有法線或切線基值

00:13:39.486 --> 00:13:43.090 
或是類似的東西 你可以在需求中生成

00:13:43.390 --> 00:13:47.561 
回想一下烘焙和導出循環
我前面提到過的

00:13:48.362 --> 00:13:50.163 
當然得有烘烤師

00:13:52.699 --> 00:13:57.437 
現在一個網格緩存必須訪問硬件

00:13:57.838 --> 00:13:59.540 
因爲它要去硬件取數據

00:14:00.807 --> 00:14:01.708 
取硬件中的真實值

00:14:02.242 --> 00:14:04.645 
緩存有多大取決於你如何分配它

00:14:06.313 --> 00:14:09.650 
你必須描述這些頂點緩存

00:14:09.716 --> 00:14:13.887 
你必須說出緩存的用途
比如是存儲位置嗎

00:14:14.354 --> 00:14:15.822 
它有多大？

00:14:15.889 --> 00:14:18.091 
它佔用多少字節等等 等等

00:14:19.359 --> 00:14:23.864 
最後從一個頂點切到另一個
硬件需要知道這些

00:14:24.364 --> 00:14:26.700 
子網格也一樣

00:14:26.900 --> 00:14:28.435 
確定你需要什麼樣的索引

00:14:28.635 --> 00:14:30.971 
是16s還是32s或是其它

00:14:31.205 --> 00:14:35.742 
下面講幾何類型三角帶？點？還是線？

00:14:36.376 --> 00:14:37.277 
最後是材質

00:14:38.612 --> 00:14:45.519 
如果你使用這些類庫能生產積極性

00:14:46.053 --> 00:14:47.821 
爲了告訴你這意味着什麼

00:14:48.088 --> 00:14:51.058 
我們使用了雙向反射函數

00:14:51.124 --> 00:14:55.362 
它有十個簡單參數這是
爲了讓藝術家有更加直觀的感受

00:14:56.029 --> 00:15:01.535 
一個更重要的功能是
設定物體是否貼合實際

00:15:01.602 --> 00:15:03.036 
像黏土或是金屬

00:15:03.604 --> 00:15:06.373 
如果你向一頭設定這個值

00:15:06.573 --> 00:15:07.875 
它就會像是黏土

00:15:08.909 --> 00:15:10.110 
如果向另一頭調

00:15:10.477 --> 00:15:12.779 
它就會表現得像是金屬

00:15:15.349 --> 00:15:20.120 
在這裏我把這兩者結合起來
把一個丙烯酸透明的外套

00:15:22.289 --> 00:15:27.194 
放在金屬底座上面我調整了
一個參數給出緞面的效果

00:15:31.031 --> 00:15:34.201 
這是一個真正藝術家般的作品

00:15:34.268 --> 00:15:37.204 
一個有着各種不同材料的太空船

00:15:37.471 --> 00:15:40.207 
只是給你一點思路只需很少的

00:15:40.374 --> 00:15:43.010 
參數就可以給出多種多樣的外觀

00:15:44.811 --> 00:15:50.951 
那麼材質應該有個名字類似於所有在
Model I/O中配置屬性的東西

00:15:51.018 --> 00:15:54.121 
無論你是否想要
Lambert Blinn-Phong

00:15:54.188 --> 00:15:55.822 
都要設定散射函數

00:15:56.156 --> 00:16:00.794 
因爲需要向下兼容舊系統
並且真實可信

00:16:00.961 --> 00:16:04.331 
當然如果你想進入真實可信的
勇敢新世界的話

00:16:05.465 --> 00:16:08.435 
這些材質是單獨繼承的這意味着

00:16:08.902 --> 00:16:15.342 
你可以通過改變每個功能的
一個值或是某些東西

00:16:15.409 --> 00:16:18.545 
你可以指定基礎材質和跨越屬性

00:16:18.979 --> 00:16:20.747 
以及子類材質

00:16:21.415 --> 00:16:24.718 
材質屬性有名稱用來說明

00:16:24.785 --> 00:16:27.521 
它們如何使用的釋義

00:16:27.588 --> 00:16:30.324 
以及說明它是浮動值或是顏色值的類型

00:16:31.725 --> 00:16:32.559 
下面是光

00:16:33.026 --> 00:16:36.997 
光有物理參數

00:16:37.164 --> 00:16:40.434 
和物理屬性以及幾何形狀

00:16:40.634 --> 00:16:42.436 
它們有擴展度和寬度

00:16:42.836 --> 00:16:46.874 
光以特定的方式傳播

00:16:47.140 --> 00:16:49.343 
你可以指定它的流明和色溫

00:16:49.743 --> 00:16:52.513 
在整個Model I/O中
真正讓我激動的

00:16:52.779 --> 00:16:55.682 
是得到了色彩方面的支持

00:16:56.016 --> 00:17:00.153 
可以指定使用現代色彩

00:17:00.654 --> 00:17:04.290 
如果你想用SRGB
我們有設定好的SRGB

00:17:04.358 --> 00:17:06.425 
如果你想用Rec.709

00:17:06.492 --> 00:17:08.662 
或者是新的Asus CG色彩配置

00:17:09.128 --> 00:17:11.198 
這種色彩配置可以保證你的色彩

00:17:11.565 --> 00:17:14.535 
以一定的方式在app的內容里加載

00:17:14.601 --> 00:17:17.704 
它自始至終表現穩定

00:17:18.038 --> 00:17:21.742 
不會發生奇特的變化這可能會給你
你知道意想不到的色彩

00:17:24.810 --> 00:17:28.782 
我們現在有了類似物理光

00:17:29.516 --> 00:17:32.719 
各種子類程序區光源

00:17:32.986 --> 00:17:35.556 
應該說是程序描述的區域光源

00:17:36.089 --> 00:17:41.161 
IES光度分析計

00:17:41.495 --> 00:17:44.498 
反光貼圖或發光貼圖的光探測器

00:17:44.598 --> 00:17:49.102 
你可以用它們來計算球面諧波
諸如此類的代表正在發生什麼的東西

00:17:50.404 --> 00:17:57.077 
我們的相機也不僅僅是
針孔無限聚焦相機

00:17:57.711 --> 00:18:01.982 
我們描述的相機發生了巨大的變化

00:18:02.416 --> 00:18:08.222 
我的照片這裏應該有個鏡頭
這裏應該有個傳感器

00:18:08.589 --> 00:18:12.826 
我們描述鏡頭可以看到的範圍
描述鏡頭屬性

00:18:12.893 --> 00:18:15.495 
失真的種類 桶形失真

00:18:15.596 --> 00:18:18.532 
或者是色差之類的東西鏡頭的幾何形狀

00:18:18.599 --> 00:18:21.201 
鏡片的有多大 鏡筒有多長

00:18:21.702 --> 00:18:22.870 
出口孔徑

00:18:22.936 --> 00:18:27.040 
你關了多少光圈 傳感器有多大

00:18:27.341 --> 00:18:30.077 
傳感器的曝光功能是什麼

00:18:30.644 --> 00:18:34.781 
所有上述設置的結果是

00:18:34.848 --> 00:18:41.054 
如果你裝載了一個35或者
說50毫米F1.8光圈的相機

00:18:41.121 --> 00:18:45.392 
去查維基百科

00:18:45.592 --> 00:18:47.928 
一個這樣的鏡頭有什麼功能

00:18:47.995 --> 00:18:51.832 
視野是多大 離焦光怎樣

00:18:52.032 --> 00:18:55.602 
突出尺寸及MDL相機的
實用功能等類似的東西

00:18:55.669 --> 00:18:59.006 
這個相機將和你在書上看到的一樣

00:18:59.173 --> 00:19:01.942 
所以這是一個方便而且有趣東西

00:19:02.209 --> 00:19:06.880 
我鼓勵你把這一類的
計算整合到你的着色器和通道

00:19:08.348 --> 00:19:09.650 
這裏只是一個簡短的例子

00:19:10.784 --> 00:19:13.153 
當我第一次將它加載到我的查看器中

00:19:13.453 --> 00:19:15.389 
使用默認的曝光設置

00:19:15.689 --> 00:19:18.692 
有些細節的丟失

00:19:18.892 --> 00:19:23.463 
挖掘機的黑暗區域很多細節看不到

00:19:24.431 --> 00:19:29.503 
對不起 這裏的亮度不好
我這圖像曝光不足

00:19:29.570 --> 00:19:32.105 
然後 使用閃關燈以

00:19:32.172 --> 00:19:36.577 
給出陰影的細節在
減少炫光的同時提升整體水平

00:19:37.711 --> 00:19:39.246 
就像一個攝影師做的那樣

00:19:40.514 --> 00:19:43.150 
如果你玩的是自己真正的相機

00:19:45.819 --> 00:19:46.653 
現在 該天空了

00:19:47.888 --> 00:19:49.656 
我們有兩種方法創造天空

00:19:49.990 --> 00:19:53.927 
第一種方法是使用一個程序天空發生器

00:19:54.194 --> 00:19:55.395 
它使用物理學

00:19:56.496 --> 00:19:59.399 
你給出當天的時間本質上太陽有多高

00:19:59.700 --> 00:20:03.403 
天氣如何有沒有很多地面上來的背散射

00:20:03.470 --> 00:20:05.272 
空氣中是不是有很多垃圾

00:20:05.906 --> 00:20:09.643 
我們通過大量的數學運算

00:20:09.943 --> 00:20:12.145 
精確計算天空的樣子

00:20:13.480 --> 00:20:15.015 
另外一條路是

00:20:15.315 --> 00:20:19.853 
它創建一個立方體你知道使用...

00:20:20.354 --> 00:20:24.491 
現在你可以在這個基於物理的領域

00:20:24.591 --> 00:20:27.461 
創造天空的另一種方法是攝影

00:20:27.828 --> 00:20:29.596 
你可以用手機或DSLR

00:20:29.663 --> 00:20:33.200 
攝製一個球形全景圖
我用IPHONE製作了這張圖

00:20:35.435 --> 00:20:39.606 
你可以使用mdltexture
和initwithurl API

00:20:39.673 --> 00:20:44.711 
創建一個立方體

00:20:45.045 --> 00:20:46.246 
反射或發光地圖

00:20:46.313 --> 00:20:48.549 
從圖像中我們可以推斷出光是入射光

00:20:48.649 --> 00:20:51.818 
所以這已經轉換成一個立方體

00:20:54.254 --> 00:20:58.325 
然後從這些裏面你可以計算出輻照度

00:20:58.859 --> 00:21:02.863 
這三條顯示的是原始圖像

00:21:03.163 --> 00:21:09.636 
中間線是紋理貼圖以一定的
卷積或水平的模糊度發光

00:21:10.237 --> 00:21:14.775 
第三個真的很好玩
中間是一個紋理它使用大量的內存

00:21:15.142 --> 00:21:18.111 
第三個實際是球諧係數

00:21:18.478 --> 00:21:24.418 
所以他是27浮動重現的光照環境

00:21:24.484 --> 00:21:29.556 
之前用數十個K代表中間線或中間地帶

00:21:30.891 --> 00:21:32.059 
把這些放在一起

00:21:32.559 --> 00:21:36.530 
這個挖掘機和它周圍的環境非常和諧

00:21:36.897 --> 00:21:41.902 
我畫的這些作品我認爲
另人激動我希望你們可以

00:21:42.503 --> 00:21:44.705 
用這些工具做出非常酷的作品

00:21:46.840 --> 00:21:49.276 
現在我只是想多說一點

00:21:49.376 --> 00:21:51.678 
關於如何整合Model I/O
和SceneKit

00:21:52.613 --> 00:21:55.349 
本質上在Model I/O
和SceneKit元素的頂層

00:21:55.682 --> 00:21:59.219 
有一對一的依賴關係

00:21:59.786 --> 00:22:02.556 
mdlasset對
應SceneKit根節點

00:22:03.457 --> 00:22:07.127 
MDLMesh 和SCNNode
通過SCN座標聯繫起來

00:22:07.427 --> 00:22:11.365 
MDLLight
有SCNLight的相機和材質

00:22:12.032 --> 00:22:16.203 
在SceneKit參數
和Model I/O參數間

00:22:16.603 --> 00:22:19.806 
沒有一致的模型我們就通過翻譯

00:22:20.040 --> 00:22:21.842 
得到一個近似的模型

00:22:23.677 --> 00:22:26.747 
現在Model I/O
實際上沒有做渲染

00:22:26.813 --> 00:22:31.552 
你可能收集了既然
我提到過其它渲染APIS

00:22:32.252 --> 00:22:35.088 
所以在metalkit更接近金屬

00:22:36.023 --> 00:22:39.126 
你將MDLMesh作爲

00:22:39.426 --> 00:22:46.133 
MetalK
和Model I/O間的模型陣

00:22:46.733 --> 00:22:49.603 
網格陣列一旦你有了網格陣列

00:22:49.903 --> 00:22:52.639 
你就可以自己寫陰影遍歷網格

00:22:52.706 --> 00:22:55.409 
和照明條件並做渲染

00:22:55.876 --> 00:23:00.180 
但是得到這些爲你準備的
金屬緩存是絕對透明的

00:23:01.181 --> 00:23:06.353 
說到這個我想把麥克風給
克勞迪婭·羅伯茨

00:23:06.520 --> 00:23:09.623 
分享關於幾何圖形和體素的內容

00:23:18.332 --> 00:23:21.668 
大家好 我的名字是
克勞迪婭·羅伯茨 尼克已經提到了

00:23:21.735 --> 00:23:25.339 
我將概述一些不同的方法以便你可以

00:23:25.405 --> 00:23:28.208 
描述和個性化
Model I/O中的幾何圖形

00:23:28.876 --> 00:23:35.148 
幫助你創造更加有
真實外觀和感覺的遊戲和應用

00:23:37.351 --> 00:23:39.253 
給你們講一下我們將要分享的重點

00:23:39.520 --> 00:23:42.556 
首先我將討論Model I/O
如何支持正常平滑

00:23:43.090 --> 00:23:48.562 
然後進入細分曲面
討論體素和一個快速的演示

00:23:50.664 --> 00:23:52.566 
好的 開始吧法線平滑

00:23:53.567 --> 00:23:55.202 
法線平滑是非常酷的技術

00:23:55.402 --> 00:24:00.073 
能讓人相信你的模型有更多幾何形狀

00:24:01.008 --> 00:24:04.845 
默認情況下
多邊形的頂點都有相同的法線

00:24:05.412 --> 00:24:08.916 
這樣多邊形的表面也有相同的法線

00:24:09.816 --> 00:24:12.886 
這會造成相鄰多邊形之間的
一個明顯的褶皺

00:24:13.187 --> 00:24:17.691 
這是突然變化和頂點法線的
光柵化過程的結果

00:24:18.892 --> 00:24:21.128 
這種顏色的強烈對比可以減輕

00:24:21.295 --> 00:24:24.298 
通過引入一個共享的法線值

00:24:24.364 --> 00:24:27.901 
其值是共享相同的
座標位置頂點法線的平均值

00:24:28.836 --> 00:24:33.707 
現在在GPU輕度計算下
多邊形表面每個點的正常值

00:24:33.774 --> 00:24:36.643 
將是頂點法線插值

00:24:36.710 --> 00:24:40.247 
不再是同樣的值展現出
很好的平滑明暗效果

00:24:41.982 --> 00:24:46.887 
使用mdlmesh API你可以通過調用
addNormalsWithAttributeNamed方法

00:24:46.954 --> 00:24:50.324 
給對象添加平滑法線

00:24:50.757 --> 00:24:53.193 
你還可以通過設置皺紋閥值

00:24:53.493 --> 00:24:55.495 
控制什麼時候使用正常平滑

00:24:56.830 --> 00:25:01.869 
在我們的飛船上我們看到左邊有
默認的平面陰影網格

00:25:02.402 --> 00:25:03.904 
右邊有平滑陰影

00:25:06.373 --> 00:25:08.208 
下面是細分曲面

00:25:09.109 --> 00:25:12.045 
細分曲面是一項普通技術

00:25:12.246 --> 00:25:15.782 
用來使用低細度的幾何圖形產生

00:25:15.849 --> 00:25:18.252 
和渲染平滑表面

00:25:19.152 --> 00:25:22.489 
這種技術可以讓你使用
一個簡單的多邊形控制網格

00:25:22.689 --> 00:25:25.192 
創建所需的不同級別的細節

00:25:25.859 --> 00:25:27.828 
舉例來說當一個物體遠的時候

00:25:27.895 --> 00:25:30.664 
它以少量的多邊形來渲染

00:25:31.098 --> 00:25:34.034 
當物體離鏡頭越來越近的時候

00:25:34.401 --> 00:25:35.769 
它會提高顆粒度

00:25:36.970 --> 00:25:38.839 
通過改變模型的細分層次

00:25:38.906 --> 00:25:40.908 
你可以產生不同的網格

00:25:40.974 --> 00:25:42.276 
不需要全部人工創建

00:25:43.544 --> 00:25:46.013 
在Model I/O中
你可以通過調用新的

00:25:46.380 --> 00:25:51.818 
SubdividedMesh程序
或者MDLMesh來創建細分層次

00:25:52.853 --> 00:25:55.489 
在下面我們將細分級別設置爲2

00:25:55.889 --> 00:25:58.325 
實現了右邊的光滑網格

00:25:58.625 --> 00:26:01.428 
多邊形數顯著增加

00:26:04.398 --> 00:26:05.999 
最後是體素

00:26:06.834 --> 00:26:09.636 
除了提供各種以多邊形展示

00:26:09.736 --> 00:26:12.072 
3D模型的先進技術

00:26:12.573 --> 00:26:15.709 
Model I/O還支持容量展示

00:26:17.044 --> 00:26:19.279 
通過以物體近似真實世界

00:26:19.346 --> 00:26:24.318 
的情況展示模型這是
一系列空間粒子或點

00:26:24.384 --> 00:26:28.155 
有固有的性質 
如體積 質量 速度 顏色

00:26:28.689 --> 00:26:32.559 
以一系列的物理現實技術分析和操作

00:26:32.759 --> 00:26:34.494 
的大門向你敞開了

00:26:35.829 --> 00:26:38.832 
與多邊形網格一樣很難建模

00:26:38.899 --> 00:26:42.536 
和展現表面不規則的現象
如雲 水 火

00:26:42.936 --> 00:26:45.706 
有了體積表現就變得非常容易了

00:26:46.607 --> 00:26:49.643 
現在與其試圖混合和扭轉

00:26:49.743 --> 00:26:52.646 
多邊形的剛性外殼
該模型成爲一個變形的物質

00:26:52.713 --> 00:26:54.915 
任何時間都可以改變它的屬性

00:26:56.083 --> 00:26:58.819 
沿着相同的路線 這表示

00:26:58.952 --> 00:27:02.122 
允許程序生成建模意味着它可以製造

00:27:02.256 --> 00:27:04.658 
讓人興奮和感到新奇的機會和遊戲

00:27:05.125 --> 00:27:08.762 
考慮修改和毀壞對象和飛地

00:27:11.665 --> 00:27:14.801 
因爲體素模型能更準確地表現

00:27:14.868 --> 00:27:18.138 
真實世界它可以讓自己以

00:27:18.205 --> 00:27:22.776 
更自然和真實的方式
被探索和操縱就像是切片技術

00:27:23.944 --> 00:27:25.946 
這事實上被證明在醫學影像領域

00:27:26.013 --> 00:27:28.849 
是特別有用的非常幸運

00:27:28.916 --> 00:27:34.354 
科學家已經證明我們
頭骨不是一個三角形空殼

00:27:36.089 --> 00:27:39.126 
最後鑑於你已經有了固體體素模型

00:27:39.193 --> 00:27:41.628 
你可以執行構造實體幾何布爾

00:27:41.695 --> 00:27:43.797 
操作以便創建大量

00:27:43.864 --> 00:27:45.933 
更有趣複雜的模型

00:27:48.535 --> 00:27:50.437 
在Model I/O中我們以

00:27:50.504 --> 00:27:53.507 
MDLVoxelArray API
暴露體素

00:27:54.274 --> 00:27:56.276 
我們的作品以稀疏網格表現

00:27:56.343 --> 00:27:59.146 
空間模型稀疏網格可以

00:27:59.213 --> 00:28:01.048 
使用簡單的空間索引訪問

00:28:02.249 --> 00:28:06.019 
這個表現形式具有快速找到並
訪問鄰居的功能

00:28:07.588 --> 00:28:11.625 
網格除了連接得每個體素外
還包含殼等級值

00:28:11.925 --> 00:28:16.230 
殼等級值是表明體素在正外部方向

00:28:16.697 --> 00:28:21.301 
和負內部方向離模型表面的遠近

00:28:22.603 --> 00:28:24.638 
Model I/O也支持

00:28:24.805 --> 00:28:28.308 
創建封閉網格模型的清理
及轉回多邊形網格

00:28:29.510 --> 00:28:31.778 
我將向你展示少量你需要的API調用

00:28:31.845 --> 00:28:34.281 
以便能引入體素和Model I/O

00:28:36.083 --> 00:28:39.253 
假設有一個初始化的
MDLVoxelArray

00:28:39.319 --> 00:28:42.055 
你可以通過調用
setVoxelsForMesh方法

00:28:42.623 --> 00:28:44.925 
從MDMMesh模型產生體素數據

00:28:45.993 --> 00:28:49.830 
分離參數的作用是
設置分辨率設定層的數量

00:28:50.130 --> 00:28:54.201 
將你的模型在垂直方向分開

00:28:55.269 --> 00:29:00.340 
你也可以設置模型內牆和外牆的厚度
就用最後的這兩個參數

00:29:02.442 --> 00:29:04.211 
一旦你建立了體素數組對象

00:29:04.878 --> 00:29:06.947 
你可以在它們上面執行各種各樣的操作

00:29:07.014 --> 00:29:10.083 
例如體素的交集合集及差分

00:29:10.150 --> 00:29:12.653 
這些是基本布林操作

00:29:14.621 --> 00:29:16.823 
要實際加工和處理

00:29:16.890 --> 00:29:20.527 
檢查體素數據只需調用
getvoxelindices方法

00:29:21.628 --> 00:29:24.565 
做完了上面的操作
用meshUsingAllocator程序

00:29:24.631 --> 00:29:26.500 
就可以將體素模型

00:29:26.733 --> 00:29:28.836 
轉換回多邊形模型

00:29:31.104 --> 00:29:31.939 
非常簡單

00:29:32.673 --> 00:29:35.342 
現在我將用快速
展示來展現一個動態的體素

00:29:54.728 --> 00:29:55.996 
讓我們看這個展示

00:29:56.463 --> 00:29:58.765 
它會用一個小時的時間來展示

00:29:58.832 --> 00:30:00.934 
如何使用
SceneKit editor來創建

00:30:01.001 --> 00:30:02.936 
我們只需要在地面上拖拽

00:30:03.337 --> 00:30:08.308 
同樣地像昨天在華盛頓
看到的紅色熊貓那樣

00:30:08.642 --> 00:30:12.779 
這是規則的多邊形網格
你可以使用任意的網格來製作

00:30:13.747 --> 00:30:16.984 
下面是使用MDLVoxelArray 
API它僅用兩條線的代碼

00:30:17.150 --> 00:30:19.486 
就把網格變成了體素

00:30:20.354 --> 00:30:25.158 
那麼對於每個體素
我們都創建一個SCN盒子 就像這樣

00:30:30.230 --> 00:30:32.666 
現在我們有了在
SceneKit中的體素

00:30:33.066 --> 00:30:36.637 
讓人激動的是我們可以使用

00:30:36.703 --> 00:30:39.640 
SceneKit所提供的
所有非常酷的東西

00:30:40.040 --> 00:30:42.910 
舉例來說使用一條線的代碼

00:30:42.976 --> 00:30:45.846 
我們可以把SCN盒子變成SCN球

00:30:47.614 --> 00:30:50.050 
讓大家開心下
我們將SceneKit體素

00:30:50.117 --> 00:30:52.386 
提供給所有節點然後引爆它

00:30:53.921 --> 00:30:56.456 
現在由Remi來接着講

00:30:56.523 --> 00:30:59.293 
關於照明和Xcode支持的高級主體

00:31:09.002 --> 00:31:10.704 
大家好 謝謝克勞迪婭

00:31:11.271 --> 00:31:16.276 
如克里斯所說我將分享關於烘焙

00:31:16.343 --> 00:31:18.946 
以及Model I/O
工作原理的高級內容

00:31:20.113 --> 00:31:23.283 
所以就是高級照明和烘焙目的是什麼

00:31:23.884 --> 00:31:27.187 
目的是介紹框架和喧染通道

00:31:27.254 --> 00:31:29.423 
在你的遊戲中叫做全局照明

00:31:30.290 --> 00:31:31.124 
是什麼呢？

00:31:31.592 --> 00:31:34.561 
這麼說不好立即 好吧
我這裏有點的高度

00:31:34.628 --> 00:31:38.498 
有三角形讓我們用點工具照亮它就是了

00:31:39.099 --> 00:31:41.401 
我們將試圖讓場景看上去是真的

00:31:41.635 --> 00:31:45.005 
我們將要在光線因爲不能穿過三角板

00:31:45.172 --> 00:31:47.441 
而在牆上反射的和阻擋的場景中

00:31:47.741 --> 00:31:50.177 
仿真光線實際移動

00:31:51.178 --> 00:31:53.647 
問題是這消耗非常大

00:31:53.780 --> 00:31:58.185 
在影片中會花費很長的時間
如果你想花費半個小時去重構的話

00:31:58.685 --> 00:32:00.120 
但這不適合我們

00:32:00.487 --> 00:32:03.857 
請看這張圖片你可以看到舉例來說

00:32:04.391 --> 00:32:07.528 
這裏的牆左邊的紅牆

00:32:07.594 --> 00:32:09.663 
在球上投射了一些紅色的光

00:32:10.197 --> 00:32:14.001 
牆不是真的光但光在

00:32:14.201 --> 00:32:17.638 
真實世界裏是從牆上反射到球上的

00:32:18.438 --> 00:32:23.143 
回到球上它有點暗
因爲球吸收了牆上反射的光

00:32:23.210 --> 00:32:26.079 
它不是真實的直接陰影
但是還有一些事情發生

00:32:27.848 --> 00:32:30.150 
問題是很難做到實時

00:32:30.484 --> 00:32:32.886 
所以我們將展示如何在

00:32:32.953 --> 00:32:36.557 
預編譯期間遊戲運行之前做一些預運算

00:32:37.191 --> 00:32:40.127 
這樣你可以得到近似真實的景象

00:32:40.494 --> 00:32:42.429 
而不用任何性能的回落

00:32:42.829 --> 00:32:44.298 
我們將平衡性能和質量

00:32:44.631 --> 00:32:48.268 
所以你可以用很少的性能開銷
得到你想要的效果

00:32:49.770 --> 00:32:52.873 
因此今天的全局照明將有兩個點

00:32:52.940 --> 00:32:56.710 
首先我們將展示環境遮擋

00:32:57.377 --> 00:32:58.679 
然後是光照貼圖

00:32:59.446 --> 00:33:01.949 
爲了介紹環境遮擋我會展示一個示例

00:33:03.350 --> 00:33:07.321 
請看這個飛船它是默認的
SceneKit飛船 看上去不錯

00:33:07.654 --> 00:33:11.225 
是一個大飛船
我喜歡玩這個遊戲但是它有點平

00:33:11.325 --> 00:33:12.960 
如果你看看翅膀和發動機

00:33:13.627 --> 00:33:18.398 
它的翅膀尾部
和發動機的開端部位有點不清楚

00:33:18.465 --> 00:33:20.734 
如果你看右邊圖像的兩翅片

00:33:21.602 --> 00:33:24.171 
它有點怪異因爲你給它的光

00:33:24.238 --> 00:33:26.974 
和前面的飛船的光一樣
但是翅片應該擋住光線

00:33:27.641 --> 00:33:30.277 
如果你要添加環境遮擋 它會變成這樣

00:33:31.778 --> 00:33:34.481 
同樣的漸變但是看上去更真實了

00:33:34.548 --> 00:33:37.484 
因爲現在在翅膀和發動機之間的

00:33:37.751 --> 00:33:38.986 
遮擋有了陰影

00:33:39.520 --> 00:33:41.522 
如果我在第二個上面添加環境遮擋

00:33:41.755 --> 00:33:43.423 
它會這樣 同樣的

00:33:43.690 --> 00:33:46.527 
但你可以看到光的遮擋

00:33:46.860 --> 00:33:49.162 
這是更讓人信服的體驗

00:33:49.229 --> 00:33:53.200 
這是一個更好看的圖片
環境遮擋實際是什麼

00:33:54.501 --> 00:33:58.739 
環境遮擋是非常簡單的
幾何圖形遮擋測量

00:33:59.039 --> 00:34:02.009 
意思是我的點或是網格

00:34:02.442 --> 00:34:04.244 
在我的世界裏有多少光

00:34:04.311 --> 00:34:07.614 
可以真正的落在我的點

00:34:07.681 --> 00:34:10.951 
有多少光被我的網格
或是它周圍的網格遮住了

00:34:11.752 --> 00:34:17.858 
所以它基本上是一個信號 1
代表白色說明我完全無遮擋

00:34:17.991 --> 00:34:22.062 
全部的光發散出去了大多的光不能到那

00:34:22.462 --> 00:34:23.630 
如果我們看信號

00:34:23.964 --> 00:34:24.831 
是這樣的

00:34:25.532 --> 00:34:28.101 
幾何全白因爲大多數光都不能到那兒

00:34:28.335 --> 00:34:30.904 
但是你看一些...那裏的物理數據

00:34:32.739 --> 00:34:33.774 
我們如何計算？

00:34:34.507 --> 00:34:37.143 
使用離線光線追蹤

00:34:37.210 --> 00:34:41.882 
網格變成...
我們把光線射向各個方向

00:34:42.081 --> 00:34:44.284 
然後計算如果我在我的點周圍照射光線

00:34:44.618 --> 00:34:46.520 
有多少光線

00:34:46.786 --> 00:34:50.489 
有多少光線射在網格上
有多少射在天空盒子上

00:34:50.791 --> 00:34:53.193 
兩者之間的區別在於我的環境遮擋信號

00:34:54.328 --> 00:34:55.728 
我們需要什麼？

00:34:56.530 --> 00:34:59.199 
輸入 網格 我的太空船

00:34:59.633 --> 00:35:00.701 
一系列的遮擋網格

00:35:01.268 --> 00:35:02.703 
這裏它只是一個太空船

00:35:02.769 --> 00:35:05.439 
舉個例子如果我表現那個場景的光

00:35:06.039 --> 00:35:09.376 
我想做地面場景的
它將計算地面的環境遮擋

00:35:09.610 --> 00:35:14.014 
我還要所有的椅子 人 地板

00:35:14.515 --> 00:35:18.819 
所有阻擋光線的東西
這樣我就有了一個非常好看的網格

00:35:19.052 --> 00:35:19.887 
這是非常好的設定

00:35:20.888 --> 00:35:21.955 
我的輸出是

00:35:22.523 --> 00:35:25.859 
一組每個點的遮擋值

00:35:26.627 --> 00:35:27.728 
點的遮擋

00:35:29.196 --> 00:35:30.397 
我們如何存儲

00:35:30.831 --> 00:35:34.168 
2種方式頂點或紋理

00:35:34.668 --> 00:35:36.537 
如果我的網格有很多頂點

00:35:36.637 --> 00:35:40.207 
舉例來說一個有大量三角形的太空船

00:35:40.507 --> 00:35:42.075 
我們可以用頂點來存儲非常好

00:35:42.309 --> 00:35:45.679 
因爲它非常節省資源
每個頂點只要一浮動

00:35:46.246 --> 00:35:52.286 
柵格化你的金屬或管道
非常節省的渲染

00:35:53.587 --> 00:35:57.024 
舉例來說太空船是少量三角形

00:35:57.391 --> 00:35:58.292 
我們需要紋理來存儲

00:35:59.693 --> 00:36:02.396 
我們已經內建在Model I/O

00:36:02.796 --> 00:36:08.235 
一個UV映射創建二維紋理
以其包裹3D網格

00:36:08.869 --> 00:36:12.506 
這樣這個紋理的每個
象素都有了環境遮擋

00:36:12.940 --> 00:36:15.442 
我們要看看這個飛船的紋理是什麼樣子

00:36:15.709 --> 00:36:16.543 
它是這樣的

00:36:17.845 --> 00:36:20.814 
你可以看到紋理環繞在太空船周圍

00:36:21.415 --> 00:36:24.117 
你可以看到翅膀和發動機的基座等等

00:36:26.887 --> 00:36:28.722 
我們怎麼計算 非常簡單

00:36:28.922 --> 00:36:30.057 
簡單得不行

00:36:30.390 --> 00:36:32.693 
舉例來說你可以看最上邊的這個船網格

00:36:33.260 --> 00:36:35.028 
產生環境遮擋

00:36:35.896 --> 00:36:37.030 
這是紋理

00:36:37.631 --> 00:36:41.001 
我們有2個參數質量和衰減因子

00:36:41.668 --> 00:36:44.872 
如果我們提升質量
它將會將會發射更多的光線

00:36:44.938 --> 00:36:48.408 
得到更好看的信號 但是它
將會花費更多的時間去計算

00:36:49.276 --> 00:36:53.080 
因爲這是烘焙它會在遊戲加載前運行
但問題還沒解決

00:36:53.547 --> 00:36:56.550 
如何我們做一個紋理烘焙
那麼紋理會更大

00:36:56.683 --> 00:36:59.019 
所以它會提升一點內存消耗

00:36:59.653 --> 00:37:01.755 
那麼衰減僅僅會衰減信號

00:37:01.822 --> 00:37:03.657 
只有暗的部分仍然保持暗

00:37:04.925 --> 00:37:09.897 
最酷的是我們與SceneKit團隊
開發了在SceneKit甚至是

00:37:09.963 --> 00:37:12.366 
SceneKit編輯器中的功能

00:37:12.432 --> 00:37:14.134 
大家在華盛頓看到過了

00:37:14.701 --> 00:37:16.203 
我將立刻向你展示這個

00:37:20.174 --> 00:37:22.876 
它有效了

00:37:23.310 --> 00:37:26.747 
這裏我只加載了一點場景

00:37:27.080 --> 00:37:31.351 
太空船和天空盒子

00:37:31.752 --> 00:37:33.787 
太空船在太空飛得非常好

00:37:34.188 --> 00:37:40.961 
我在這裏沒有加光
所以非常平唯一可見的是環境光

00:37:41.895 --> 00:37:45.199 
你可以看到環境光線對

00:37:45.265 --> 00:37:47.067 
太空船的外觀沒有作用

00:37:47.301 --> 00:37:49.937 
它沒有以幾何圖形位置的形式

00:37:50.003 --> 00:37:52.139 
反饋給用戶 所以它非常平

00:37:52.940 --> 00:37:53.774 
我們要改變

00:37:54.241 --> 00:37:55.843 
我先點擊網格

00:37:55.909 --> 00:37:58.612 
我將看到實際上這裏有些頂點

00:37:58.812 --> 00:37:59.880 
所以我們做個頂點烘焙

00:38:01.014 --> 00:38:02.349 
我會帶入幾何選項卡

00:38:03.984 --> 00:38:06.854 
我將在這兒在環境烘焙下面 選擇頂點

00:38:07.721 --> 00:38:10.991 
這些值非常好 點烘焙

00:38:11.725 --> 00:38:12.559 
發生了什麼

00:38:12.993 --> 00:38:16.530 
對於船上的每一個小的頂點
我們將發送100

00:38:16.597 --> 00:38:20.334 
到200光線到它的周圍
看上去是這樣

00:38:21.401 --> 00:38:23.170 
看 更好的方式

00:38:24.771 --> 00:38:26.306 
我們有了這個 現在又有了這個

00:38:27.241 --> 00:38:28.242 
它感覺上更好了

00:38:28.375 --> 00:38:30.577 
如果你看 例如 這 頂板

00:38:30.944 --> 00:38:34.314 
在1號底部有遮擋
因爲光線不能很容易的到達那裏

00:38:34.815 --> 00:38:36.850 
如果我們看這裏面的窗戶 在這裏

00:38:37.718 --> 00:38:40.554 
窗口的內口比外部有更多的遮擋

00:38:41.355 --> 00:38:42.890 
如果我們看這

00:38:43.323 --> 00:38:44.157 
縮小

00:38:44.725 --> 00:38:46.793 
如果 我們看下面的大炮

00:38:47.160 --> 00:38:48.862 
大炮的頂部非常暗

00:38:48.929 --> 00:38:51.532 
因爲整個船阻止光到達那裏

00:38:51.965 --> 00:38:53.767 
如果我們看底部

00:38:54.568 --> 00:38:55.936 
都是白的 有意義 是嗎

00:38:56.803 --> 00:39:00.407 
所以每個頂點增加一浮動，我們能

00:39:00.474 --> 00:39:05.712 
用環境光照亮我們的場景更好看了

00:39:07.247 --> 00:39:09.149 
在SceneKit中是可用的

00:39:09.950 --> 00:39:12.586 
讓我們回到幻燈片

00:39:14.288 --> 00:39:15.122 
這是環境遮擋

00:39:16.023 --> 00:39:20.227 
今天關於以高級光貼圖照射
就分享到這裏

00:39:21.261 --> 00:39:22.829 
光貼圖是什麼

00:39:23.330 --> 00:39:27.167 
光貼圖是一種方法讓你的漫射照明

00:39:27.234 --> 00:39:30.204 
進入遊戲並預計算實時
還是非實時情況下

00:39:30.270 --> 00:39:33.207 
擴散照明對紋理的影響

00:39:33.607 --> 00:39:35.976 
正如你們知道的
如果你做了一些遊戲編程

00:39:36.510 --> 00:39:38.579 
光照是非常耗資源的

00:39:38.745 --> 00:39:41.815 
如果你有十個光源那麼每一幀

00:39:41.915 --> 00:39:46.553 
你需要計算光的方面
以及它是如何幹擾你的遊戲的

00:39:46.920 --> 00:39:48.155 
這非常耗資源

00:39:48.755 --> 00:39:52.693 
這裏我拖拽了仿真器中的一個飛機

00:39:52.759 --> 00:39:55.896 
兩隻盒子八個光源

00:39:56.396 --> 00:39:58.298 
然後 我計算 在我加載遊戲前

00:39:58.365 --> 00:40:03.570 
使用光貼圖烘焙
光貼圖如何照亮場景及照亮紋理

00:40:05.005 --> 00:40:08.141 
如果我們看這個場景

00:40:08.642 --> 00:40:09.810 
看上去這樣

00:40:09.877 --> 00:40:11.211 
非常真實

00:40:11.578 --> 00:40:13.113 
我們有了陰影和光

00:40:13.480 --> 00:40:16.550 
但是這實際耗費一個紋理獲取

00:40:18.352 --> 00:40:19.186 
這樣

00:40:19.786 --> 00:40:22.289 
通常渲染八個光特別是如果你有陰影

00:40:22.356 --> 00:40:23.690 
陰影貼圖非常耗資源

00:40:24.358 --> 00:40:25.325 
紋理看上去這樣

00:40:25.559 --> 00:40:29.096 
很簡單你看中間的箱子和陰影

00:40:31.698 --> 00:40:33.700 
這非常酷 只是一個紋理獲取 是嗎？

00:40:34.201 --> 00:40:35.369 
它支持非常多的光

00:40:35.636 --> 00:40:37.771 
我能有100,000個光源

00:40:37.905 --> 00:40:41.508 
它將具有相同的運行成本

00:40:41.675 --> 00:40:43.844 
甚至陰影看上去也很酷

00:40:44.278 --> 00:40:47.481 
當你象這樣做出個點光源
它非常貼近地面

00:40:47.548 --> 00:40:50.784 
你會遇到精確性問題
除非你這樣做

00:40:50.951 --> 00:40:54.655 
發送光線到這個東西上的每個象素

00:40:54.988 --> 00:40:58.225 
看看哪個象素有光哪個象素沒有光

00:40:58.492 --> 00:41:01.628 
你的陰影看上去將非常真實離線計算

00:41:03.397 --> 00:41:07.100 
我們支持超複雜的實時幻燈片

00:41:07.201 --> 00:41:11.138 
你甚至無法想像 這非常酷

00:41:11.572 --> 00:41:14.842 
舉個例子我們實際的
光照在很長的時間裏很難

00:41:14.908 --> 00:41:17.344 
做到實時因爲用一般的點光

00:41:17.411 --> 00:41:21.582 
很難做到三角反射處理

00:41:21.882 --> 00:41:23.717 
這裏我們用的是光線追蹤

00:41:23.784 --> 00:41:27.387 
所以我們只要發出光線
看看哪些有光哪些沒有光

00:41:28.055 --> 00:41:30.057 
我們也支持冷IS光源

00:41:30.524 --> 00:41:31.892 
尼克之前說過的

00:41:33.327 --> 00:41:34.261 
這是光貼圖

00:41:35.762 --> 00:41:38.665 
讓我們總結一下

00:41:39.233 --> 00:41:42.336 
今天我們介紹了一種非常新的框架
對於它 我們非常高興

00:41:43.270 --> 00:41:47.407 
首先它做了基本的3D文件導入導出

00:41:47.875 --> 00:41:49.343 
但是對你來說做得非常多

00:41:49.843 --> 00:41:52.479 
它使用基於真實世界

00:41:52.880 --> 00:41:56.984 
而不是以浮動定義的
模型 光 相機 物質和天空

00:41:57.317 --> 00:41:59.553 
介紹了渲染的物理基礎概念

00:42:00.387 --> 00:42:03.190 
我們有系統集成在Xcode中

00:42:03.257 --> 00:42:05.392 
的框架和工具中你可以玩 玩得很開心

00:42:07.160 --> 00:42:10.197 
爲得到更多的信息
我們邀請你看我們的文檔

00:42:10.264 --> 00:42:12.432 
視頻 論壇和技術支持

00:42:12.866 --> 00:42:15.636 
任何一般的查詢
您可以聯繫艾倫·謝弗

00:42:16.603 --> 00:42:21.508 
相關的會議有明天的
“SceneKit進階”

00:42:21.575 --> 00:42:23.076 
和週二的Metal新功能

00:42:23.510 --> 00:42:27.014 
一會兒和明天早上9點

00:42:27.080 --> 00:42:28.782 
我們將在
Model I/O實驗室見面

00:42:29.349 --> 00:42:31.685 
謝謝你們
希望你們有一個偉大的WWDC