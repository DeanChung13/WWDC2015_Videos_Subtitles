00:00:20.187 --> 00:00:21.154 
Apps的安全

00:00:21.488 --> 00:00:22.990 
你們好 謝謝

00:00:26.360 --> 00:00:29.663 
我是伊凡是Apple公司安全
及隱私策略小組的負責人

00:00:31.098 --> 00:00:32.566 
今天我們來談一談安全

00:00:33.834 --> 00:00:38.639 
事實上今天將主要談的是設備安全

00:00:39.439 --> 00:00:43.143 
現在你們也知道我們
設備的安全性能非常高

00:00:43.310 --> 00:00:47.347 
有些安全性能是OSX
或IOS所特有的是兩個平臺兼有的

00:00:48.215 --> 00:00:50.450 
我們將繼續開發這些性能

00:00:50.651 --> 00:00:54.054 
你們也將看到我們在
這領域會不斷地創新

00:00:54.721 --> 00:00:58.492 
今天我會抽些時間和
你們簡單談談網絡安全

00:01:00.561 --> 00:01:02.696 
一談到網絡安全你們大部分人都會想到

00:01:02.763 --> 00:01:06.834 
HTTPS我們多數也是在瀏覽器的
鎖定圖標中見過它

00:01:08.502 --> 00:01:13.140 
在過去網站會使用HTTPS和TLS

00:01:13.207 --> 00:01:15.475 
來傳輸一些敏感信息

00:01:17.144 --> 00:01:20.981 
在我們看來信用卡信息
已算不上敏感信息

00:01:21.782 --> 00:01:25.152 
所有的用戶信息纔是真正的敏感信息

00:01:25.219 --> 00:01:29.489 
而作爲開發者認爲不敏感的
信息在用戶看來可能就是敏感信息

00:01:31.692 --> 00:01:34.595 
TLS真正重要的一點
也是我們通常想不到的

00:01:34.661 --> 00:01:39.066 
就是它不僅會保護網絡運行的信息安全

00:01:39.666 --> 00:01:42.069 
而且還保護連接的完整性

00:01:42.769 --> 00:01:44.905 
網絡面臨的威脅已經變了

00:01:45.873 --> 00:01:48.842 
已不再是戴着黑色面罩躲藏

00:01:48.909 --> 00:01:51.345 
在網絡的某些角落
去竊取你信用卡數字那些人

00:01:52.012 --> 00:01:55.182 
事實上 用戶是想保護自己免受
其他威脅攻擊

00:01:55.616 --> 00:01:58.151 
例如 網絡服務供應商

00:01:58.218 --> 00:02:00.821 
他們向每個應用中插入跟蹤標頭信息 

00:02:01.188 --> 00:02:04.558 
或直接記錄瀏覽歷史
以進行廣告定向投放

00:02:06.260 --> 00:02:11.865 
所以 我們認爲TLS在2015年的
最主要職責就是保護消費者

00:02:12.232 --> 00:02:13.066 
網絡信息安全

00:02:15.836 --> 00:02:17.771 
但是TLS仍有漏洞

00:02:18.539 --> 00:02:20.941 
很多服務器仍使用TLS 1版本

00:02:21.241 --> 00:02:23.010 
這個版本太老了已有16年的歷史了

00:02:23.377 --> 00:02:26.747 
連最新版本TLS 1.2
也已經有7年的歷史了

00:02:27.080 --> 00:02:31.785 
TLS 1.2包含了很多重要的
協議加密升級功能能夠抵抗我們

00:02:31.852 --> 00:02:35.322 
正面臨或未來要面臨的各種威脅

00:02:36.523 --> 00:02:40.027 
事實上 連TLS1.2版本也有漏洞

00:02:41.562 --> 00:02:43.664 
根據TLS的運作方式如果黑客

00:02:43.730 --> 00:02:46.200 
黑掉一個服務器並竊取你的TLS密鑰

00:02:46.633 --> 00:02:51.939 
那麼他們就可以破解服務
器曾經加載過的加密數據

00:02:52.439 --> 00:02:53.907 
毫無疑問這是非常恐怖的

00:02:54.474 --> 00:02:57.411 
不過有個正向加密的
軟件可解決這一問題

00:02:57.511 --> 00:02:59.813 
有了正向加密即使黑客黑掉一個

00:02:59.880 --> 00:03:03.083 
服務器竊取了TLS密鑰
他們也只能用密鑰

00:03:03.150 --> 00:03:04.985 
破解服務器未來加密傳輸的數據

00:03:05.152 --> 00:03:07.554 
不能破解已加密的歷史數據

00:03:08.555 --> 00:03:10.824 
這樣非常棒 因爲它能減少龐大的網絡

00:03:10.891 --> 00:03:11.992 
加密數據負荷

00:03:13.861 --> 00:03:17.197 
TLS支持正向加密正向加密過程通過

00:03:17.264 --> 00:03:19.433 
使用密碼組完成而密碼組是由啓動

00:03:19.499 --> 00:03:22.736 
服務器所必須的加密基元組合而成

00:03:23.370 --> 00:03:26.773 
所以 你們的服務器無需運行TLS
只需運行TLS 1.2

00:03:26.840 --> 00:03:31.078 
爲了獲得正向加密
你們必須對其進行設置

00:03:32.479 --> 00:03:36.083 
我爲什麼告訴你這些呢
引用蒂姆的話我會讓你們讀一下

00:03:42.789 --> 00:03:44.558 
我們必須修正這問題

00:03:46.159 --> 00:03:47.594 
爲了幫助你們不出問題

00:03:48.595 --> 00:03:51.265 
我們將向你們介紹App
Transport Security

00:03:51.832 --> 00:03:52.666 
它是這樣運行的

00:03:53.800 --> 00:03:58.405 
在OSX EI Capitan
或ISO9打開你們的應用

00:03:59.540 --> 00:04:03.010 
默認它這樣就不會連接到
不受保護的HTTP鏈接   

00:04:03.076 --> 00:04:05.846 
它們會連接失敗
而且程序生成的任何TLS連接

00:04:05.913 --> 00:04:10.184 
也不會按照我剛纔描述的最優做法

00:04:10.450 --> 00:04:12.452 
這就是帶有正向加密的TLS 1.2

00:04:13.020 --> 00:04:16.190 
任何已知的不安全加
密基元均無法被允許

00:04:16.490 --> 00:04:18.825 
密鑰尺寸也有最低要求

00:04:19.526 --> 00:04:21.695 
現在你可能不會完全按照這些要求去做

00:04:21.762 --> 00:04:25.132 
立即遵守這些要求不過沒關係

00:04:25.199 --> 00:04:27.367 
你可以在
Info plist中根據每種情況

00:04:27.434 --> 00:04:31.872 
指定例外情況或進行全局覆蓋

00:04:32.472 --> 00:04:35.742 
但是就整個行業而言我們必須儘快做到

00:04:35.809 --> 00:04:38.378 
讓用戶信息無法接觸到未加密網絡

00:04:39.479 --> 00:04:40.380 
我們需要你們的幫助

00:04:41.682 --> 00:04:43.717 
謝謝大家下面由我的
同事皮埃爾給你們談談

00:04:43.784 --> 00:04:46.486 
System Integration
Protection

00:04:51.491 --> 00:04:52.326 
謝謝伊凡

00:04:54.795 --> 00:04:57.464 
嗨 大家好 我是
皮埃爾•奧利佛•馬特爾

00:04:57.798 --> 00:05:01.101 
擔任Apple公司
沙盒技術部的技術經理

00:05:02.402 --> 00:05:05.239 
今天我和大家談談 System
Integration Protection

00:05:05.405 --> 00:05:07.140 
這是我們在
El Capitan引進的

00:05:07.207 --> 00:05:08.942 
新型硬化機理

00:05:10.344 --> 00:05:14.114 
在探究細節之前我想退一步

00:05:14.548 --> 00:05:16.650 
給大家說說我們要達成什麼目標

00:05:17.918 --> 00:05:23.123 
在Apple公司 我們團隊的使命
是確保用戶能享受到

00:05:23.190 --> 00:05:25.726 
產品帶來的極致體驗我們相信

00:05:25.792 --> 00:05:27.995 
我們可以保護他們的

00:05:28.061 --> 00:05:32.366 
個人資料即使資料被

00:05:32.666 --> 00:05:35.602 
惡意軟件甚至更糟糕的

00:05:36.103 --> 00:05:39.206 
編寫軟件攻擊傷害也會很小

00:05:40.807 --> 00:05:44.244 
爲了達到這個目的我們已設計和集成

00:05:44.378 --> 00:05:47.514 
各項安全技術正如伊凡上面所提到的

00:05:47.981 --> 00:05:50.217 
這些年研發的iOS和 OS X

00:05:50.884 --> 00:05:52.553 
研發所採用的一種

00:05:52.619 --> 00:05:56.456 
配額和原則就是深度防禦概念

00:05:57.724 --> 00:06:00.027 
使用的關鍵原則你可能也

00:06:00.093 --> 00:06:03.197 
有所耳聞 那就是安全與層有關

00:06:04.231 --> 00:06:06.900 
你不能把所有雞蛋都
放在同一個籃子裏

00:06:06.967 --> 00:06:10.571 
不要指望單層保護設備就完事大吉了

00:06:10.871 --> 00:06:13.006 
因爲不管這個保護層

00:06:13.774 --> 00:06:18.111 
防彈性 防水性 抗震性有多好

00:06:18.178 --> 00:06:21.648 
一旦壞掉就

00:06:22.382 --> 00:06:23.984 
功虧一簣

00:06:25.652 --> 00:06:28.755 
相反 你們應該依靠多層保護

00:06:29.456 --> 00:06:32.793 
原則上有了多層安全保護

00:06:33.293 --> 00:06:35.562 
不僅能推遲黑客入侵時間

00:06:36.096 --> 00:06:37.564 
還能限制被攻擊範圍

00:06:39.132 --> 00:06:41.235 
到現在爲止 深度預防

00:06:41.301 --> 00:06:43.637 
這個古老的軍事概念被用來捍衛世界

00:06:43.937 --> 00:06:47.140 
各地城池已有幾百年歷史了

00:06:48.642 --> 00:06:49.977 
我知道你們很喜歡瑣事

00:06:50.344 --> 00:06:52.613 
所以 我可以告訴你們這個概念是

00:06:52.679 --> 00:06:57.417 
塞巴斯蒂安•德•沃邦
在17世紀70年代正式提出的

00:06:57.484 --> 00:06:59.052 
那時 他受法國國王邀請

00:06:59.486 --> 00:07:01.555 
在全國建造堡壘

00:07:02.155 --> 00:07:04.758 
以保衛王國安全

00:07:05.692 --> 00:07:08.061 
你們可能不熟悉這個人

00:07:08.128 --> 00:07:10.130 
但你們肯定見過他的作品

00:07:11.298 --> 00:07:12.699 
這就是他其中的一個城堡設計圖

00:07:14.034 --> 00:07:15.969 
你們可以清楚地看到這幾個保護層是

00:07:16.036 --> 00:07:17.971 
用來抵擋不同的襲擊 

00:07:19.673 --> 00:07:22.075 
它們可以拖住入侵者然後通過

00:07:22.309 --> 00:07:26.914 
易守難攻的窄道把入侵者抵擋在外面

00:07:28.649 --> 00:07:31.685 
我們來看看如何
把這個原理用到OS X的安全模型上

00:07:32.519 --> 00:07:34.922 
我不知道你們是不是這樣
反正我是經常夢想着

00:07:34.988 --> 00:07:36.523 
建造自己的堡壘就是這樣

00:07:37.824 --> 00:07:40.561 
我們在這之上設置自己的安全層

00:07:42.062 --> 00:07:44.565 
我們從底部的網閘開始

00:07:45.732 --> 00:07:49.369 
網閘要確保從網上下載到

00:07:49.436 --> 00:07:54.041 
用戶設備上的應用是經開發者簽字的

00:07:54.341 --> 00:07:58.412 
開發者擁有Apple公司發佈的
開發者身份證明

00:07:59.513 --> 00:08:02.583 
否則程序將無法運行

00:08:03.884 --> 00:08:06.019 
網閘要配合系統的其他機制運行

00:08:06.086 --> 00:08:08.856 
如惡意軟件檢測機制

00:08:09.323 --> 00:08:11.592 
這樣纔能有效

00:08:12.459 --> 00:08:16.096 
防止惡意軟件大規模地
入侵我們生態系統

00:08:18.131 --> 00:08:19.433 
第二層是沙盒

00:08:20.801 --> 00:08:23.537 
回到Lion 我們引入了App沙盒

00:08:23.971 --> 00:08:27.207 
我們強制性規定所有從App Store
下載的應用都要使用App沙盒

00:08:28.909 --> 00:08:32.145 
對於從App Store
以外下載的應用

00:08:32.212 --> 00:08:35.082 
比如開發者ID程序
也強推薦使用App沙盒

00:08:36.482 --> 00:08:38.485 
沙盒是一種控制機制

00:08:39.253 --> 00:08:42.289 
它能確保即使你們的程序被入侵了

00:08:43.090 --> 00:08:47.160 
攻擊者也只能訪問用戶提供的資料

00:08:47.794 --> 00:08:50.731 
而不能竊取用戶資料

00:08:51.498 --> 00:08:53.767 
也不能破壞其他系統

00:08:56.270 --> 00:08:59.640 
如果你們成功繞開前兩層
那麼就來到了第三層

00:09:00.307 --> 00:09:02.442 
經典的POSIX權限方案

00:09:03.210 --> 00:09:05.679 
在這裏 你們的應用

00:09:05.746 --> 00:09:09.216 
只能在系統授予用戶的權限下運行

00:09:10.083 --> 00:09:13.387 
所以它既不能訪問不同用戶資料

00:09:14.154 --> 00:09:19.693 
也不能修改root用戶
對系統進行的配置設置

00:09:21.528 --> 00:09:25.365 
最後 我們把Keychain 
看成第三層上面的一層

00:09:25.432 --> 00:09:28.836 
它是用來保護用戶密鑰的

00:09:30.504 --> 00:09:33.674 
它通過加密和應用分離

00:09:34.274 --> 00:09:37.377 
確保只有在第一層存儲祕密的應用

00:09:37.811 --> 00:09:40.747 
纔可以返回此層

00:09:42.983 --> 00:09:44.351 
所以當你們看到整個方案後

00:09:45.052 --> 00:09:46.486 
你們會明白很多事情

00:09:47.588 --> 00:09:54.428 
首先 網閘阻止下載到
機器上的不信任代碼

00:09:55.329 --> 00:09:58.165 
但是它還不是真正的控制機制

00:09:58.532 --> 00:10:01.502 
因爲啓動網閘不會阻止任何應用運行

00:10:02.269 --> 00:10:05.472 
而且它也不會保護機器已有代碼

00:10:05.539 --> 00:10:08.308 
例如它不會保護OS自帶的代碼

00:10:10.244 --> 00:10:13.914 
所以 雖然它可能是

00:10:14.214 --> 00:10:16.149 
我們平臺最有效的控制機制

00:10:17.251 --> 00:10:19.186 
但沙盒機制是OS X的唯一選擇

00:10:19.853 --> 00:10:22.656 
我們沒有要求規定每個過程都

00:10:22.956 --> 00:10:24.525 
必須在沙盒中運行

00:10:26.593 --> 00:10:30.364 
最後當你們看到POSIX層時

00:10:31.532 --> 00:10:36.470 
會發現大部分的Mac系統 
都是單用戶系統

00:10:37.070 --> 00:10:40.440 
而系統的用戶實際上是臨時管理員

00:10:40.507 --> 00:10:42.109 
一直在行使管理特權

00:10:44.845 --> 00:10:46.914 
root賬戶通常要麼處於保護狀態

00:10:46.980 --> 00:10:50.450 
要麼保護密碼較弱甚至沒有密碼

00:10:51.852 --> 00:10:55.289 
事實上如果真的有
密碼而且你想要的話

00:10:55.522 --> 00:10:56.957 
用戶也可能會給你

00:10:59.860 --> 00:11:03.530 
而且 當你最後root之後
實際上已經能控制

00:11:03.997 --> 00:11:07.000 
整個機器 因爲root文件可以禁用
設備上所有的安全措施

00:11:07.701 --> 00:11:10.971 
它能替換內核擴展

00:11:11.471 --> 00:11:15.275 
替代提供其他安全服務

00:11:15.809 --> 00:11:18.545 
甚至可以擾亂運行中的
Keychain層

00:11:20.681 --> 00:11:24.051 
所以 事實就是一旦代碼在Mac運行

00:11:24.551 --> 00:11:26.720 
那麼很容易進行root

00:11:27.187 --> 00:11:29.056 
一旦root成功
你就可以完全控制機器

00:11:29.590 --> 00:11:30.457 
也就是說

00:11:31.358 --> 00:11:33.794 
任何一段惡意代碼實際上就是一個密碼

00:11:34.127 --> 00:11:35.562 
或一個可以完全

00:11:35.929 --> 00:11:37.664 
控制你機器的漏洞

00:11:40.033 --> 00:11:44.338 
這表明我們還需要另一個層

00:11:45.405 --> 00:11:49.209 
一個能消除機器root權限的層

00:11:50.110 --> 00:11:52.045 
從而在默認情況下保護系統

00:11:52.145 --> 00:11:54.515 
好像是Apple安裝到機器上的一樣

00:11:55.349 --> 00:11:57.017 
硬盤和runtime都進行安裝

00:11:58.852 --> 00:12:02.589 
因爲我們現在正討論限制root權限

00:12:03.323 --> 00:12:06.860 
所以我們需要提供一套配置機制

00:12:07.327 --> 00:12:09.897 
防止root被入侵

00:12:10.831 --> 00:12:13.500 
而且還能重設root權限

00:12:15.602 --> 00:12:18.438 
這就是System
Integration Protection

00:12:18.872 --> 00:12:20.440 
這是一個新的安全策略

00:12:20.908 --> 00:12:24.011 
適用於系統中的每個進程

00:12:24.645 --> 00:12:26.680 
不管這個進程是否

00:12:26.947 --> 00:12:29.716 
具備附加特權或者在沙箱外運行

00:12:31.785 --> 00:12:33.887 
該策略能爲磁盤或runtime中的

00:12:34.221 --> 00:12:37.925 
系統組件提供額外保護

00:12:39.126 --> 00:12:43.096 
而且系統如果安裝
Apple簽字安裝包

00:12:43.163 --> 00:12:46.900 
二進制只能被安裝程序

00:12:48.101 --> 00:12:50.003 
或者軟件更新機制修改

00:12:50.704 --> 00:12:54.308 
這樣系統二進制文件就能免受

00:12:54.374 --> 00:12:58.412 
runtime附件和代碼注入的風險

00:12:59.980 --> 00:13:01.715 
在探究細節之前

00:13:01.982 --> 00:13:05.285 
我們先看一下這是如何影響開發者的

00:13:06.420 --> 00:13:09.456 
好消息是如果你的應用

00:13:09.523 --> 00:13:12.726 
是App Store下載的 
那麼應用就不會受到此類風險

00:13:13.694 --> 00:13:16.496 
<br/> 
因爲App Store指南

00:13:16.630 --> 00:13:18.632 
和沙箱策略可以加以保護

00:13:18.799 --> 00:13:20.534 
阻止此類行爲

00:13:21.502 --> 00:13:23.604 
然而 如果你們的應用
不是來自App Store

00:13:24.338 --> 00:13:26.607 
而且需要修改系統的二進制文件

00:13:27.140 --> 00:13:32.880 
或修改磁盤框架
如果需要將儲存信息安裝到系統位置

00:13:34.414 --> 00:13:36.283 
那麼應用就會受到影響

00:13:36.683 --> 00:13:39.019 
我將在這裏解釋一下

00:13:39.753 --> 00:13:41.755 
什麼是系統位置

00:13:43.023 --> 00:13:46.894 
最後如果你們的
應用需要檢查系統進程中

00:13:46.960 --> 00:13:49.897 
任一進程的的內存狀態

00:13:50.898 --> 00:13:56.537 
或需要在系統運行的進程中或跨進程

00:13:56.703 --> 00:13:57.704 
插入庫或進行調試

00:13:59.773 --> 00:14:02.576 
那麼讓我們看看新機制的核心

00:14:03.076 --> 00:14:05.679 
首先我會瞭解下新文件系統限制

00:14:05.946 --> 00:14:08.582 
我們在Capitan系統
引入該文件系統

00:14:09.550 --> 00:14:11.018 
然後再看一下它是如何擴展到

00:14:11.318 --> 00:14:13.420 
新runtime保護進程

00:14:15.022 --> 00:14:17.090 
最後瞭解一下該系統與

00:14:17.157 --> 00:14:20.060 
內核擴展開發流程的關係

00:14:20.127 --> 00:14:23.530 
以及它是如何影響kext開發者的

00:14:24.798 --> 00:14:27.334 
然後由於這個功能
是能夠被完全禁用的

00:14:28.001 --> 00:14:29.503 
接下來向你們展示一下如何禁用

00:14:31.138 --> 00:14:32.539 
那就得首先講講文件系統

00:14:33.974 --> 00:14:39.880 
我們想做到的就是
保護系統存儲信息不被修改

00:14:41.281 --> 00:14:45.986 
爲達到這一目的 
安裝程序會標在文件安裝過程中

00:14:46.520 --> 00:14:47.855 
標記系統內容

00:14:48.655 --> 00:14:51.291 
我們在Capitan系統中加入了
新的文件系統標記

00:14:52.359 --> 00:14:56.530 
之後在運行過程中內核能阻止任何

00:14:56.830 --> 00:14:58.932 
企圖篡改受保護文件

00:14:58.999 --> 00:15:01.969 
或文件夾的行爲除非該行爲是

00:15:02.035 --> 00:15:05.272 
特別授權的進程發出的

00:15:05.806 --> 00:15:07.908 
Capitan系統只有幾種此類進程

00:15:09.243 --> 00:15:13.881 
內核還會防止
儲存私密內容的塊設備被讀寫

00:15:15.215 --> 00:15:16.783 
而且還會阻止

00:15:16.950 --> 00:15:18.252 
私密內容被篡改

00:15:20.187 --> 00:15:22.122 
現在 必須記住一點是

00:15:22.422 --> 00:15:25.158 
這隻適用於root文件和

00:15:25.592 --> 00:15:26.727 
當前運行OS的啓動卷

00:15:27.995 --> 00:15:30.731 
所以你應該把它看成系統運行時的

00:15:31.031 --> 00:15:33.066 
一種自我保護機制

00:15:36.270 --> 00:15:39.206 
因爲我們現在要
保護磁盤上的系統存儲信息

00:15:39.273 --> 00:15:41.308 
所以你們必須明確區分

00:15:41.375 --> 00:15:43.510 
系統內容和第三方內容

00:15:44.912 --> 00:15:48.849 
在Capitan 這張圖標左側

00:15:48.916 --> 00:15:51.885 
所有位置都被默認爲系統位置

00:15:52.853 --> 00:15:55.189 
這意味着系統會阻止你在那裏進行讀寫

00:15:55.923 --> 00:15:57.824 
即使是安裝程序包下載的也一樣

00:15:59.493 --> 00:16:01.728 
因爲多年來我們一直建議你們

00:16:02.062 --> 00:16:03.697 
不要讀寫到這些位置

00:16:03.964 --> 00:16:05.499 
所以你們當中受影響的人應該不多

00:16:05.732 --> 00:16:08.535 
如果你們的安裝包把存儲信息放到這裏

00:16:08.602 --> 00:16:10.671 
Capitan應該不會出現大的故障

00:16:11.471 --> 00:16:13.674 
如果你想把所有的軟件都
安裝在/System路徑下

00:16:14.007 --> 00:16:17.010 
那麼你需要將此存儲信息移到
subfolder of /Library下

00:16:17.077 --> 00:16:20.681 
如果是系統內的
存儲信息或(tilde)/Library

00:16:21.248 --> 00:16:24.318 
如果是用戶存儲信息

00:16:26.119 --> 00:16:29.156 
或者如果你想把軟件都安裝到
/bin或者/sbin

00:16:29.923 --> 00:16:32.125 
或者/usr目錄下

00:16:32.192 --> 00:16:35.395 
比如/usr/bin, /usr/lib
或者usr/libexec

00:16:35.996 --> 00:16:39.266 
那麼你要把儲存信息移到

00:16:39.600 --> 00:16:44.271 
/usr/文件夾下的
適當位置 因爲這裏是

00:16:44.338 --> 00:16:45.939 
第三方唯一可訪問的路徑

00:16:47.574 --> 00:16:48.709 
然後需要注意的是

00:16:49.676 --> 00:16:52.513 
最佳的存儲信息位置仍是
/Applications路徑

00:16:52.646 --> 00:16:55.549 
這是因爲這個位置是用戶可見位置

00:16:56.149 --> 00:16:58.752 
方便用戶把應用拖入

00:16:58.819 --> 00:17:00.454 
垃圾箱並刪除存儲信息

00:17:01.855 --> 00:17:07.493 
要注意的是 當用戶升級 

00:17:07.694 --> 00:17:10.830 
Yosemite install到
Capitan install時

00:17:11.431 --> 00:17:14.667 
安裝程序會會把系統內

00:17:14.734 --> 00:17:18.505 
發現的第三方存儲信息移到系統外

00:17:19.640 --> 00:17:23.076 
所以爲了不影響這些用戶

00:17:23.143 --> 00:17:26.680 
務必確保把存儲內容儘快轉移出去

00:17:29.783 --> 00:17:31.618 
現在我們看一下runtime保護

00:17:33.086 --> 00:17:35.756 
能夠改變runtime中的進程行爲

00:17:35.923 --> 00:17:38.959 
就相當於能夠改變

00:17:39.026 --> 00:17:40.827 
改變磁盤上的二進制文件

00:17:41.495 --> 00:17:43.263 
如果想保護磁盤上的二進制文件

00:17:43.530 --> 00:17:46.133 
或系統存儲信息我們必須保證

00:17:46.400 --> 00:17:49.536 
不能插入代碼或改變

00:17:49.603 --> 00:17:51.538 
這些系統進程的行爲

00:17:53.006 --> 00:17:56.710 
爲了實現該目的我們在進程結構中

00:17:57.344 --> 00:18:01.815 
引入一種新的限定標記這種標記的
內核適用於每個單一進程

00:18:03.050 --> 00:18:06.086 
如果磁盤上的

00:18:06.854 --> 00:18:09.990 
主要可執行文件受程序保護

00:18:11.258 --> 00:18:13.193 
或寫入Apple
特別授權的主要可執行文件

00:18:13.260 --> 00:18:14.695 
那麼內核將在準確時刻做出標記

00:18:19.967 --> 00:18:22.536 
之後系統將自動區別

00:18:22.836 --> 00:18:26.073 
該受限進程和常規進程

00:18:26.940 --> 00:18:29.476 
一方面如果task-for-pid

00:18:29.943 --> 00:18:33.747 
和processor-set-tasks
SPI需要調用受限進程

00:18:34.014 --> 00:18:36.283 
那麼它們將無法運行

00:18:37.251 --> 00:18:39.419 
並且會設置EPERM爲0

00:18:40.621 --> 00:18:44.191 
這意味着你的產品需要依靠

00:18:44.324 --> 00:18:48.061 
系統進程才能運行

00:18:48.262 --> 00:18:51.198 
例如Finder 你需要
向Finder插入代碼

00:18:51.265 --> 00:18:53.634 
否則它再也無法運行了

00:18:56.270 --> 00:19:03.243 
如果你插入exec 
那麼二進制文件將導致子進程受限

00:19:04.611 --> 00:19:07.214 
然後系統將自動重新設置

00:19:07.281 --> 00:19:08.949 
子進程的mach特殊接口

00:19:09.650 --> 00:19:11.985 
這樣意味着你將 

00:19:12.352 --> 00:19:13.587 
無法控制子進程

00:19:14.421 --> 00:19:18.158 
如果你插入一個特權工具

00:19:18.592 --> 00:19:20.961 
然後想要保持控制
那麼它也將不能運行

00:19:23.263 --> 00:19:29.469 
連接器將忽視所有
保護二進制文件的dyld環境變量

00:19:30.270 --> 00:19:33.407 
所以在執行過程中如果你在進程中

00:19:33.574 --> 00:19:35.509 
將庫插入二進制文件

00:19:36.109 --> 00:19:38.745 
連接器忽視新庫

00:19:40.314 --> 00:19:44.384 
最終如果使用
dtrace的話所有針對

00:19:44.551 --> 00:19:49.189 
受限進程的dtrace
探針將無法匹配

00:19:49.890 --> 00:19:53.994 
這樣就無法看到進程和內核的互動過程

00:19:54.962 --> 00:19:58.732 
你們也將檢測不到受限進程存儲空間

00:19:58.932 --> 00:20:00.968 
也就無法檢測到內核內存

00:20:02.836 --> 00:20:05.472 
當然這適用於調試器LLDB

00:20:06.106 --> 00:20:09.576 
如果你們試圖
調用LLDB作爲root

00:20:09.643 --> 00:20:12.179 
並連接到Finder這樣也無濟於事

00:20:15.282 --> 00:20:17.384 
現在接下來是kext簽字程序

00:20:17.751 --> 00:20:21.321 
你們肯定也知道所有帶
Kexts開發者ID證書的擴展

00:20:21.622 --> 00:20:25.359 
都是Apple公司發行的

00:20:26.527 --> 00:20:31.098 
擴展必須安裝到
/Library/Extensions路徑下

00:20:32.866 --> 00:20:37.638 
新鮮的是因爲我們把
kext簽字程序放置在

00:20:38.472 --> 00:20:41.909 
System Integrity
Protection之下進行保護

00:20:42.576 --> 00:20:45.479 
所以kext-dev-mode
boot-arg就被淘汰了

00:20:46.446 --> 00:20:49.983 
如果你是kext開發者你就需要用

00:20:50.083 --> 00:20:52.419 
未簽字的內核擴展進行測試

00:20:52.486 --> 00:20:55.589 
你需要禁用保護我馬上給你們演示一下

00:20:56.523 --> 00:20:59.693 
這也意味着爲了禁用kext簽字

00:20:59.760 --> 00:21:02.829 
你在那裏可能也看不到這個註釋行 

00:21:03.096 --> 00:21:04.198 
它已經無法運行了

00:21:08.702 --> 00:21:10.337 
下面我們來談一下配置機制

00:21:12.573 --> 00:21:17.110 
我們堅信這個新機制
對保護對我們的用戶至關重要

00:21:18.679 --> 00:21:21.815 
話雖這麼說但我們也意識到

00:21:21.882 --> 00:21:24.418 
人無法完全操控他們的機器

00:21:25.385 --> 00:21:26.620 
因爲我之前就說過

00:21:26.887 --> 00:21:28.422 
它保護着磁盤上的內核

00:21:28.922 --> 00:21:31.525 
需要所有的內核擴展都必須被簽字

00:21:32.192 --> 00:21:34.494 
而且因此kext開發者

00:21:34.561 --> 00:21:36.363 
也不能如願以償地測試未簽字kext

00:21:38.031 --> 00:21:40.200 
正因如此它被完全棄用了

00:21:41.301 --> 00:21:44.771 
配置存放在NVRAM配置中

00:21:45.272 --> 00:21:48.141 
這意味着可以適用於整個機器

00:21:48.475 --> 00:21:50.410 
所以如果你有幾個
Capitan安裝程序

00:21:50.777 --> 00:21:52.513 
它們都會有同樣的配置 

00:21:53.680 --> 00:21:55.516 
而且OS安裝程序也是如此

00:21:55.649 --> 00:21:59.186 
所以當你從seed 1升級到
seed 2再升級到GM之後

00:21:59.753 --> 00:22:01.321 
配置也將保持不變

00:22:01.455 --> 00:22:03.257 
我們安裝時不用每次都進行重新配置

00:22:05.359 --> 00:22:08.161 
現在 因爲root實際上
已經設置了NVRAM

00:22:08.262 --> 00:22:10.631 
在這裏我們不能相信root

00:22:11.098 --> 00:22:14.434 
也就是我們不能在
OS系統上安裝配置機制

00:22:15.068 --> 00:22:17.571 
我們要進行轉移 
把它安裝在Recovery OS下

00:22:18.305 --> 00:22:21.041 
所以NVRAM也就只能在
Recovery下進行配置設置

00:22:21.775 --> 00:22:23.010 
如果你想改變配置

00:22:23.777 --> 00:22:26.346 
你需要在機器的
Recovery OS中進行重啓

00:22:26.413 --> 00:22:29.449 
在引導畫面下按Command+R鍵
進行開機啓動

00:22:30.851 --> 00:22:32.586 
然後在Utilities菜單中 

00:22:32.653 --> 00:22:35.155 
運行安全配置應用

00:22:36.323 --> 00:22:38.926 
檢測System
IntegrityProtection盒

00:22:39.359 --> 00:22:40.694 
應用 然後重啓

00:22:42.029 --> 00:22:44.464 
記住我剛纔描述的那些類型很有可能

00:22:44.531 --> 00:22:46.300 
在以後的seed版本中會發生變化

00:22:46.433 --> 00:22:51.038 
所以務必閱讀註釋瞭解新的操作步驟

00:22:54.007 --> 00:22:55.809 
我們總結一下到到目前
爲止所談論的內容

00:22:57.277 --> 00:22:59.980 
System Integrity 
Protection是一種新的策略

00:23:00.047 --> 00:23:01.181 
適用於系統的每個進程

00:23:02.282 --> 00:23:06.520 
Apple公司將其安裝
在磁盤和runtime上

00:23:06.620 --> 00:23:10.424 
通過限制讀寫系統位置訪問權限

00:23:10.858 --> 00:23:14.995 
以及防止runtime
連接和代碼插入

00:23:15.963 --> 00:23:18.599 
從而保護系統

00:23:20.434 --> 00:23:23.203 
安裝程序能有效地把第三方存儲內容

00:23:23.337 --> 00:23:25.172 
轉移到系統位置之外

00:23:25.239 --> 00:23:27.474 
所以要確保儘快轉移你的存儲內容

00:23:27.908 --> 00:23:30.110 
否則 就只能自認倒黴了
因爲 你會找不到內容

00:23:31.678 --> 00:23:37.918 
最後可使用Recovery OS
配置機制禁用該功能

00:23:39.720 --> 00:23:41.388 
這就是我爲大家呈現的內容
謝謝大家

00:23:41.655 --> 00:23:42.789 
下面我把舞臺交給安德魯

00:23:48.996 --> 00:23:49.830 
謝謝你 皮埃爾

00:23:51.665 --> 00:23:56.970 
我是安德魯·惠利在Core OS
 安全功能組負責管理數據安全組

00:23:59.139 --> 00:24:01.475 
你可能聽過app傳輸安全

00:24:02.142 --> 00:24:04.611 
以及app在連接狀態下

00:24:05.012 --> 00:24:07.014 
是它如何保護傳輸中的數據的

00:24:08.015 --> 00:24:11.718 
我將會討論數據安全的不同保護方式

00:24:13.187 --> 00:24:16.190 
我會點擊Keychain
然後存儲用戶信息

00:24:17.491 --> 00:24:21.795 
之後看一下Touch ID
看看你是如何權衡

00:24:21.862 --> 00:24:23.463 
程序安全與程序便捷的

00:24:25.532 --> 00:24:28.702 
在這個過程中我將體驗一下現有的技術

00:24:28.936 --> 00:24:32.940 
和iOS 9的新功能以及
如何配合使用

00:24:33.407 --> 00:24:36.577 
從而提供適合你們
app的安全保護等級

00:24:40.080 --> 00:24:42.649 
我們首先快速
瀏覽一下Keychain

00:24:43.217 --> 00:24:46.587 
你可以把它看作是專業的數據庫

00:24:47.454 --> 00:24:51.425 
通過增加行數來儲存數據
我們稱爲Keychain項目

00:24:51.892 --> 00:24:54.761 
然後通過屬性進行查詢

00:24:56.597 --> 00:25:01.301 
爲了優化隱私我這裏說的隱私包括密碼

00:25:01.969 --> 00:25:04.771 
標記 cookie或祕鑰

00:25:06.139 --> 00:25:10.511 
如果你有成千上萬兆字節信息要儲存

00:25:10.844 --> 00:25:15.549 
那麼可以考慮使用基於文件的
數據保護或者通過API進行

00:25:16.049 --> 00:25:18.318 
批量加密方法 
如Common Crypto

00:25:18.585 --> 00:25:20.287 
然後將密鑰存儲在Keychain中

00:25:25.292 --> 00:25:27.961 
儘管這些SecItem API
已經存在很長時間了

00:25:28.262 --> 00:25:30.631 
但它仍是最好的祕密存儲工具

00:25:30.931 --> 00:25:33.066 
包括新Swift apps中的密碼

00:25:34.468 --> 00:25:37.838 
這裏我們這裏有個祕密 
想通過SecItemAdd

00:25:37.905 --> 00:25:40.574 
把它存在Keychain中

00:25:42.209 --> 00:25:44.344 
爲了這麼做我們構建了一個字典

00:25:44.711 --> 00:25:46.480 
這個字典包括祕密信息

00:25:46.947 --> 00:25:51.818 
還有今後查詢所必須的某些屬性

00:25:52.286 --> 00:25:53.554 
和應當採取的保護措施

00:25:56.256 --> 00:25:59.560 
這種創建包括描述
項目查詢方式字典的方式

00:25:59.626 --> 00:26:04.865 
也可用於查詢刪除 

00:26:05.098 --> 00:26:10.037 
更新條目和其他API
我後面會談到這一點

00:26:11.405 --> 00:26:14.074 
有關Keychain API的信息

00:26:14.141 --> 00:26:17.711 
2013年的WWDC
的709會議還有很多

00:26:20.314 --> 00:26:25.152 
所以在編寫訪問Keychain
代碼的時候你們要注意以下幾點

00:26:26.987 --> 00:26:30.290 
首先處理用戶隱私信息
是代碼安全信息當中

00:26:30.357 --> 00:26:32.326 
真正敏感的一個環節

00:26:33.093 --> 00:26:37.464 
所以你們應該把它分成
小而簡單又可測試的小單元

00:26:39.499 --> 00:26:42.069 
通常可以使用
wrapper class

00:26:44.438 --> 00:26:46.573 
不管是直接使用
還是使用wrapper

00:26:47.107 --> 00:26:49.710 
請確保你的應用

00:26:50.410 --> 00:26:52.312 
受到最高級別的保護

00:26:53.680 --> 00:26:56.984 
我們描述和討論的數據保護級別

00:26:57.518 --> 00:27:03.790 
指的是通過加密訪問項目的次數

00:27:03.924 --> 00:27:06.360 
例如當設備在iOS8系統上

00:27:08.562 --> 00:27:12.766 
被鎖定的時候我們添加了
After First Unlock

00:27:14.434 --> 00:27:18.338 
再說一遍這功能早就有了
當你必須在背景下

00:27:18.572 --> 00:27:20.941 
訪問這些項目時候你就可以使用它

00:27:21.308 --> 00:27:22.876 
比例你開發的是一款VoIP應用

00:27:27.147 --> 00:27:30.651 
iOS 9不支持隨時訪問

00:27:31.051 --> 00:27:34.688 
所以你們必須着手
把這些項目移到到更高級別位置

00:27:40.527 --> 00:27:44.498 
我們已開發出WatchKit 2
所以你的Watch app現在可以

00:27:44.565 --> 00:27:48.969 
訪問SecItem API
雖然在Watch上

00:27:49.036 --> 00:27:52.873 
輸入用戶全名和密碼的
這種用戶體驗並非是你想要的

00:27:54.408 --> 00:27:58.512 
如果你的Watch app
顯示的是配對iOS設備的數據

00:27:59.079 --> 00:28:01.415 
那麼你只需發送內容

00:28:01.748 --> 00:28:03.750 
而無需使用永久證書

00:28:05.586 --> 00:28:07.955 
如果你的Watch app
確實需要直接訪問證書

00:28:08.822 --> 00:28:14.461 
那麼與其保存完整的用戶名和密碼

00:28:15.162 --> 00:28:18.065 
不如讓服務器發送
一個許可證或cookie

00:28:18.365 --> 00:28:22.503 
從而獲得權限訪問

00:28:22.669 --> 00:28:26.139 
那些Watch app
所需要的主要功能內容

00:28:30.143 --> 00:28:33.447 
不僅僅在Watch上提示用戶名

00:28:33.514 --> 00:28:35.716 
和密碼非常不方便

00:28:36.416 --> 00:28:42.823 
在過去的幾個版本我們引入了幾種
技術減少密碼提示的頻率

00:28:44.791 --> 00:28:47.060 
第一個就是共享web證書

00:28:48.896 --> 00:28:51.999 
我們都瞭解也都喜歡
Safari保存的密碼

00:28:52.266 --> 00:28:54.868 
以及提示和儲存密碼的方式

00:28:56.370 --> 00:29:00.340 
有了iCloud Keychain
密碼就可以同步 自動保存

00:29:00.407 --> 00:29:01.475 
到所有設備上

00:29:03.844 --> 00:29:05.179 
但是 常見的是一個服務器

00:29:05.245 --> 00:29:08.182 
同時擁有一個
網站和一個iOS app

00:29:08.782 --> 00:29:12.619 
所以 如果這些程序都能共享

00:29:12.753 --> 00:29:14.354 
Safari保存密碼那就太棒了

00:29:15.122 --> 00:29:17.391 
有了共享web證書就可以辦到

00:29:19.693 --> 00:29:22.262 
這些是你們在登錄

00:29:22.362 --> 00:29:24.698 
或註冊程序要添加的代碼

00:29:27.634 --> 00:29:30.204 
SecCreate Shared
WebCredential Password將

00:29:30.270 --> 00:29:33.473 
返回一個隨機字符串
和Safari保存的密碼格式一樣

00:29:33.574 --> 00:29:34.942 
用於提示密碼

00:29:36.310 --> 00:29:39.046 
你們能調用SecAdd
SharedWeb Credential

00:29:39.112 --> 00:29:42.382 
告知Safari
需要將新用戶名和密碼

00:29:42.649 --> 00:29:44.651 
自動輸入到特定域中

00:29:47.721 --> 00:29:51.091 
在iOS 9我們已經實現這個功能

00:29:51.491 --> 00:29:53.427 
方式是在模擬器上運行時

00:29:53.493 --> 00:29:54.928 
降低安全檢查等級

00:29:56.530 --> 00:29:57.364 
我們來體驗一下

00:29:59.199 --> 00:30:02.803 
我從註冊程序開始

00:30:03.237 --> 00:30:06.306 
然後添加剛剛展示過的代碼

00:30:09.109 --> 00:30:12.012 
然後進入Safari設置

00:30:12.145 --> 00:30:15.749 
確保已啓用名稱和密碼自動輸入

00:30:17.518 --> 00:30:19.419 
搜索Safari等待結果

00:30:22.356 --> 00:30:25.325 
我們回到程序上來

00:30:25.826 --> 00:30:27.561 
頁面上顯示用戶名稱和密碼提示

00:30:29.229 --> 00:30:32.833 
共享網絡憑據允許應用

00:30:32.900 --> 00:30:36.537 
顯示一個選擇器這個選擇器列出了
Safari在這個域中

00:30:36.603 --> 00:30:37.704 
保存的所有賬號

00:30:40.507 --> 00:30:43.010 
每當用戶選擇一個賬號 用戶名

00:30:43.076 --> 00:30:46.446 
和密碼就會根據
Shared Web Credential

00:30:46.580 --> 00:30:52.252 
返回到已完成處理的
程序中然後就可以登錄了

00:30:55.989 --> 00:30:58.091 
如果你想要在設備上使用這個功能

00:30:58.158 --> 00:31:02.262 
而不是隻在模擬器上使用
你就需要在你的應用上

00:31:03.363 --> 00:31:06.099 
添加一個授權你可以在
Xcode的權限標籤頁的

00:31:06.233 --> 00:31:08.202 
相關域部分中進行該操作

00:31:10.938 --> 00:31:14.274 
你需要將JSON文件放在服務器中

00:31:14.942 --> 00:31:16.376 
不過你可能已經有了

00:31:16.710 --> 00:31:19.246 
畢竟它跟Handoff和
iOS 9應用鏈接中

00:31:20.747 --> 00:31:24.685 
所用的是同一個

00:31:30.157 --> 00:31:31.658 
我們對iOS 9做了一個改變

00:31:31.725 --> 00:31:33.126 
讓適應性更好這個改變是

00:31:33.460 --> 00:31:35.996 
你不再需要分別簽署該文件

00:31:36.530 --> 00:31:39.399 
它將由安全TLS連接所保護

00:31:45.539 --> 00:31:49.243 
我提到過Safari通過
iCloud Keychain保存密碼

00:31:49.643 --> 00:31:52.045 
但是你們也可以在
自己的應用中直接使用它

00:31:53.146 --> 00:31:55.282 
想象你有一個
iOS iPad

00:31:55.849 --> 00:31:59.052 
iPhone和OS X 
App Store app

00:31:59.386 --> 00:32:03.423 
你想要只登陸一個
就同時登陸所有這些程序

00:32:05.659 --> 00:32:08.028 
對於能夠用於多種設備的應用密碼

00:32:08.095 --> 00:32:11.999 
你們可以考慮將同步性屬性

00:32:12.065 --> 00:32:14.034 
添加到所有的SecItem調用

00:32:15.736 --> 00:32:17.271 
你還需要考慮幾件事情

00:32:17.337 --> 00:32:19.973 
比如 刪除一個項目
就會將所有位置的該項目同時刪除掉

00:32:20.107 --> 00:32:22.709 
所以請確保你只在正確的
情況下進行該操作

00:32:24.578 --> 00:32:28.715 
這裏還有幾個注意事項
你可以在SecItem.h.

00:32:30.584 --> 00:32:31.985 
查看如果你有興趣想了解更多

00:32:32.052 --> 00:32:34.388 
關於iCloud Keychaine
安全性的信息

00:32:34.755 --> 00:32:37.925 
或者想知道同步的密碼如何
保護個人隱私

00:32:37.991 --> 00:32:41.128 
不被其他用戶看到
請查看iOS 安全白皮書

00:32:41.528 --> 00:32:43.096 
會議結束有個鏈接

00:32:46.700 --> 00:32:51.305 
我重申下 
Keychain存着你所有的祕密

00:32:51.471 --> 00:32:55.309 
而純文本文件或plist
文件已經沒有密碼

00:32:56.510 --> 00:32:58.979 
所有請儘可能保護好它們

00:33:00.681 --> 00:33:03.050 
並且如果合適的話請使用
SharedWedCredentials

00:33:03.116 --> 00:33:06.286 
比如我們的Keychain 
以便在用戶的設備上將進行同步

00:33:06.453 --> 00:33:08.222 
同時儘量不用密碼提示

00:33:13.026 --> 00:33:16.597 
所以雖然有些祕密能在
多臺設備上同步但你只想它們

00:33:17.264 --> 00:33:18.465 
在一臺設備上安全待着

00:33:18.532 --> 00:33:21.535 
這時候iCloud
Keychain就派上大用場了

00:33:23.337 --> 00:33:25.639 
安全通訊應用就是一個例子

00:33:26.006 --> 00:33:29.943 
這種應用的加密是設備對設備
而不是用戶對用戶

00:33:32.779 --> 00:33:35.082 
我已經提到過的不同保護級別中

00:33:35.182 --> 00:33:37.251 
有一個
ThisDeviceOnly級別

00:33:38.118 --> 00:33:40.921 
項目會被備份但只能被

00:33:41.088 --> 00:33:42.322 
恢復到它們最初始的設備中

00:33:44.191 --> 00:33:47.794 
去年 我們增加了
WhenPassCodeSet級別

00:33:48.295 --> 00:33:50.464 
確保項目始終處於

00:33:50.564 --> 00:33:52.533 
本地設備密碼保護之下

00:33:54.268 --> 00:33:56.069 
你可以使用
AccessControl表

00:33:56.136 --> 00:33:59.339 
以對項目進行更爲嚴密的控制

00:34:03.777 --> 00:34:04.711 
既然我們在談論

00:34:04.811 --> 00:34:07.447 
保護特定設備證書的事情

00:34:07.881 --> 00:34:10.918 
那麼讓我們來看一看
iOS設備的安全域

00:34:12.319 --> 00:34:14.821 
用戶空間也就是應用運行的空間

00:34:15.889 --> 00:34:19.092 
以及皮埃爾提到過的
能夠提供進程分離和

00:34:19.159 --> 00:34:21.228 
其它安全功能的內核

00:34:22.563 --> 00:34:25.831 
不過它也提供了很多很多其它OS工具

00:34:26.033 --> 00:34:28.335 
這意味着它有着
一個相當強大的防攻擊服務

00:34:29.036 --> 00:34:32.306 
我們在iPhone 5s中
加入了Secure Enclave

00:34:35.475 --> 00:34:40.681 
Secure Enclave
是獨立運行的在設計之時

00:34:40.813 --> 00:34:42.850 
始終將安全性視爲最高原則

00:34:44.484 --> 00:34:48.222 
我們在其中放置了
Touch ID來保護隱私

00:34:48.288 --> 00:34:50.924 
以及你的指紋信息的安全

00:34:52.626 --> 00:34:55.661 
我們將KeyStore從內核

00:34:55.728 --> 00:34:58.532 
移進
Secure Enclave就是它

00:34:58.866 --> 00:35:02.069 
控制着Keychain項目的密碼

00:35:02.169 --> 00:35:03.070 
以及數據保護

00:35:07.374 --> 00:35:09.409 
所以讓我們現在
着重瞭解一下Touch ID

00:35:11.311 --> 00:35:13.547 
我們把它視爲一種安全技術

00:35:13.947 --> 00:35:16.350 
但它真正出色的是它的便利性

00:35:17.150 --> 00:35:20.320 
你可以不用總是輸入密碼
就可以解鎖你的設備

00:35:21.788 --> 00:35:24.458 
不過它本身也可以帶給我們
一些安全上面的好處

00:35:25.125 --> 00:35:29.029 
比如如今擁有複雜的長密碼
變得更加容易了

00:35:29.897 --> 00:35:32.132 
它能夠提高數據保護的安全性

00:35:33.467 --> 00:35:37.871 
或者現在你的手機能夠立即上鎖

00:35:38.038 --> 00:35:40.707 
從而減少被攻擊和解鎖狀態的時間

00:35:44.745 --> 00:35:48.649 
在iOS 8我們提供了一些API
所以當你在安全性和便利性之間

00:35:48.715 --> 00:35:52.486 
做權衡的時候你可以使用
應用裏的Touch ID

00:35:53.187 --> 00:35:55.556 
但爲何是這兩者它們如何不同？

00:35:56.890 --> 00:35:59.393 
若想知道首先
你得了解Touch ID

00:35:59.459 --> 00:36:01.495 
和生物特徵識別的工作機制

00:36:01.862 --> 00:36:05.365 
幸運的是 這很簡單
它可以歸結爲一個條件句

00:36:06.300 --> 00:36:10.003 
如果伸出的手指和登記的手指相匹配

00:36:10.537 --> 00:36:11.772 
就要做出反應

00:36:13.173 --> 00:36:16.376 
造成差別的原因是這種反應是什麼

00:36:16.944 --> 00:36:17.845 
以及反應在哪裏發生

00:36:21.148 --> 00:36:22.816 
讓我們從Local
Authentication開始談起

00:36:24.785 --> 00:36:27.287 
當一根手指被放在
Touch ID感應器下

00:36:27.654 --> 00:36:29.556 
在Secure Enclave
裏得到匹配

00:36:32.059 --> 00:36:33.227 
匹配的消息

00:36:33.327 --> 00:36:36.730 
會通過Local Authentication
發送到你的應用

00:36:37.297 --> 00:36:38.298 
從而成功計算出布爾值 

00:36:40.067 --> 00:36:43.770 
你的應用就是這樣
對那條信息的做出反應的

00:36:46.740 --> 00:36:50.143 
進程雖然在Secure 
Enclave開始

00:36:50.911 --> 00:36:54.982 
但最終安全決策卻是

00:36:55.449 --> 00:36:58.352 
用戶空間裏的應用做出

00:37:01.355 --> 00:37:03.323 
所以你什麼時候可能想要通過
Local Authentication

00:37:03.390 --> 00:37:04.391 
使用Touch ID呢

00:37:05.826 --> 00:37:09.062 
想想你的應用如果你有任何安全障礙

00:37:09.530 --> 00:37:12.799 
比如輸入密碼來確認一項操作

00:37:13.333 --> 00:37:15.335 
即使用戶已經登錄了

00:37:17.004 --> 00:37:19.239 
使用Touch ID會更容易

00:37:21.108 --> 00:37:23.944 
或者你可能不想要總是
使用Touch ID 

00:37:24.511 --> 00:37:30.484 
但在驗證過程中採取額外的
措施這會是一個大障礙

00:37:34.188 --> 00:37:36.890 
比如你可以在查看敏感數據前

00:37:37.057 --> 00:37:38.458 
做出提示

00:37:40.160 --> 00:37:45.766 
或者在某個操作之前做出提示
比如永久性刪除賬戶

00:37:49.770 --> 00:37:52.372 
一種模式是在你的應用流中

00:37:52.472 --> 00:37:53.774 
做出一個Touch ID提示

00:37:55.042 --> 00:37:59.012 
但這可能導致這種情況發生
那就是 用戶剛剛用Touch ID解鎖

00:37:59.446 --> 00:38:02.549 
但沒過多久應用又會發來提示

00:38:04.785 --> 00:38:09.089 
在iOS9 我們添加了
TouchIDAuthentication

00:38:09.223 --> 00:38:12.726 
AllowableReuseDuration
這是在Local Authentication

00:38:12.793 --> 00:38:13.694 
環境下的一項屬性

00:38:14.962 --> 00:38:16.630 
你可以使用它來指定一個窗口

00:38:17.297 --> 00:38:19.600 
如果用戶最近剛用Touch ID

00:38:20.100 --> 00:38:22.369 
來解鎖他們的設備在期間

00:38:22.536 --> 00:38:23.437 
你就不需要再次提示

00:38:25.138 --> 00:38:27.875 
那是讓你的策略寬鬆一些的一種辦法

00:38:29.676 --> 00:38:32.379 
但或許你想讓你的策略在某些情況下

00:38:32.513 --> 00:38:33.514 
更嚴格一些

00:38:33.580 --> 00:38:37.017 
比如 對一個新登記的指紋做出反應

00:38:40.420 --> 00:38:44.625 
同樣也是一項新技術我們有
evaluatedPolicyDomainState屬性

00:38:46.326 --> 00:38:47.828 
這是一個完全隱祕的值

00:38:48.262 --> 00:38:51.064 
代表了已登記指紋的當前情況

00:38:52.833 --> 00:38:55.636 
你真正能做的是實時做一下比較

00:38:56.403 --> 00:39:00.574 
如果它改變了
那就是設置裏的已登記指紋中

00:39:00.741 --> 00:39:02.409 
有一個指紋信息已經被添加或移除

00:39:04.912 --> 00:39:07.047 
如果你察覺到並且它適合

00:39:07.147 --> 00:39:11.251 
你的應用或許你可以再次提示

00:39:11.318 --> 00:39:14.054 
看看用戶是否還想
使用應用上的Touch ID

00:39:14.555 --> 00:39:16.623 
或者輸入一個密碼來重新啓動它

00:39:19.693 --> 00:39:22.863 
那麼我們來看看iOS 9的本地授權
有哪些新功能

00:39:24.731 --> 00:39:27.267 
我已經提到了
AllowableReuseDuration

00:39:27.334 --> 00:39:29.136 
和
PolicyDomainState

00:39:30.637 --> 00:39:34.408 
另外你可以取消本地授權功能 

00:39:34.908 --> 00:39:38.812 
並且如果用戶現在會收到
Touch ID提示 

00:39:38.879 --> 00:39:42.749 
那麼取消後系統會自動爲用戶選擇取消

00:39:43.183 --> 00:39:44.284 
並關閉對話框

00:39:46.220 --> 00:39:50.190 
evaluateAccessControl
讓本地授權可以

00:39:50.257 --> 00:39:56.129 
和Keychain Access Control
Lists一同使用我將稍後介紹 

00:39:56.230 --> 00:39:59.566 
也會給出很多示例和示例代碼

00:40:02.302 --> 00:40:05.305 
所以說起Keychain Access
Control Lists

00:40:05.639 --> 00:40:07.941 
這是第二種方式你可以
在應用內使用Touch ID

00:40:08.208 --> 00:40:10.978 
然後用來保護特定的
Keychain項目

00:40:12.312 --> 00:40:13.947 
這是我們的結構圖

00:40:15.382 --> 00:40:18.919 
和之前一樣 Touch ID
在安全區域內發生匹配

00:40:19.653 --> 00:40:22.623 
但是這次匹配信息會從安全區域內

00:40:23.156 --> 00:40:25.659 
發送到Keystore

00:40:27.327 --> 00:40:32.499 
只有在此之後
你的Keychain項目纔會

00:40:32.933 --> 00:40:33.767 
被釋放回到應用中

00:40:37.504 --> 00:40:39.840 
所以如果你想要對特定的
文件進行保護的話

00:40:39.907 --> 00:40:41.808 
這麼這種方式非常有用

00:40:43.477 --> 00:40:46.280 
另外這也充分利用了安全區域的

00:40:46.680 --> 00:40:48.615 
額外保護功能

00:40:50.617 --> 00:40:55.522 
也許有時候你在權衡應用的安全性

00:40:55.789 --> 00:40:58.125 
然後你發現有些東西你實在不想要保留

00:40:58.192 --> 00:41:00.394 
不要每次或者經常收到提示

00:41:01.862 --> 00:41:04.298 
你可以使用Access
Control Lists進行保存

00:41:04.398 --> 00:41:07.901 
然後使用Touch ID進行保護
從而提供更好的用戶體驗

00:41:09.670 --> 00:41:12.406 
或者你可以將其用來

00:41:12.673 --> 00:41:14.641 
增加已經保存的項目的安全性

00:41:18.011 --> 00:41:21.682 
你可以通過指定兩項安全屬性
創建訪問控制列表

00:41:23.250 --> 00:41:25.886 
第一是數據有效保護類型

00:41:26.653 --> 00:41:30.290 
指的是需要使用密碼

00:41:32.860 --> 00:41:35.329 
才能訪問安全區域裏的數據
接下來你可以制定一項策略

00:41:36.697 --> 00:41:38.999 
該策略指定了一種情況 

00:41:39.600 --> 00:41:42.002 
只有這種情況滿足後
安全區域纔會釋放項目

00:41:42.135 --> 00:41:44.137 
單單訪問密碼是無法查閱的

00:41:47.608 --> 00:41:50.177 
因此我們來看看策略類型

00:41:51.979 --> 00:41:53.580 
第一種是UserPresence

00:41:54.047 --> 00:41:56.083 
這種策略會提示需要
Touch ID匹配 

00:41:56.149 --> 00:41:58.252 
然後返回到設備密碼

00:41:59.486 --> 00:42:02.389 
另外你也可以直接
跳轉到DevicePasscode

00:42:04.791 --> 00:42:06.994 
iOS 9的新功能是
TouchIDAny

00:42:08.395 --> 00:42:12.165 
這種策略需要Touch Id匹配
但是不會有反饋

00:42:13.800 --> 00:42:18.138 
另外更爲嚴格的新策略是
TouchIDCurrentSet

00:42:19.173 --> 00:42:22.442 
使用該策略只有在保存項目
時候使用的登記指紋組

00:42:22.509 --> 00:42:24.611 
不發生變化的情況下

00:42:24.912 --> 00:42:26.346 
項目纔會釋放

00:42:28.282 --> 00:42:29.483 
我想要詳細談談這種策略

00:42:29.850 --> 00:42:33.353 
因爲你的應用可能用得着

00:42:33.487 --> 00:42:36.423 
因爲這種策略提供多要素授權

00:42:38.492 --> 00:42:40.727 
當談到多要素的時候
你可能經常會想到

00:42:40.861 --> 00:42:46.066 
比如像是密碼還有其他一些
你可以想到的東西

00:42:46.133 --> 00:42:49.770 
比如物理標記智能卡

00:42:50.804 --> 00:42:54.041 
或者是iOS設備的安全區域
和Touch ID

00:42:56.910 --> 00:42:59.079 
如果你保存一個文件 

00:42:59.179 --> 00:43:03.016 
然後使用TouchIDCurrentSet
策略進行保護 

00:43:03.083 --> 00:43:06.253 
如果無法成功進行Touch ID
匹配那麼是無法訪問文件的

00:43:07.688 --> 00:43:08.922 
而且沒有其他方式可以訪問

00:43:09.323 --> 00:43:13.961 
另外如果對手有設備密碼 

00:43:14.628 --> 00:43:17.331 
他們無法訪問設置登記指紋 

00:43:17.831 --> 00:43:19.199 
這樣對手就無法訪問文件了

00:43:24.705 --> 00:43:27.274 
最後的兩種策略
ApplicationPassword

00:43:27.341 --> 00:43:28.876 
和
PrivateKeyUsage

00:43:29.376 --> 00:43:32.946 
讓你可以執行高級功能
這是Touch ID之上的高級功能

00:43:34.815 --> 00:43:36.850 
第一個是
ApplicationPassword

00:43:37.818 --> 00:43:41.822 
爲了說明讓我們看看
WhenUnlocked類別的項目

00:43:41.922 --> 00:43:43.156 
是如何被加密保護的

00:43:45.025 --> 00:43:49.096 
同樣的即使是最好的門鎖
如果你忘帶鑰匙還是白塔

00:43:49.596 --> 00:43:52.032 
因此如果加密數據
和祕鑰保存在同一個地方

00:43:52.466 --> 00:43:54.101 
那麼數據實際上沒有得到保護

00:43:56.036 --> 00:43:58.872 
數據保護和Keychain
安全實質上是使用設備密碼保護

00:43:59.373 --> 00:44:01.008 
而且密碼已經保存在我們已知的

00:44:02.042 --> 00:44:06.180 
最爲複雜的系統之中即用戶的大腦

00:44:08.549 --> 00:44:10.584 
用戶記得密碼
可以使用密碼訪問設備

00:44:11.151 --> 00:44:14.054 
在我們輸入密碼然後
會生成一把密碼鑰匙

00:44:14.521 --> 00:44:16.690 
這把祕鑰能破解項目密碼

00:44:19.993 --> 00:44:23.730 
現在讓我們看看受
ApplicationPassword保護的項目

00:44:28.502 --> 00:44:32.072 
只有設備密碼往往是不夠的

00:44:33.640 --> 00:44:36.510 
你的應用還必須有自己的密碼

00:44:37.578 --> 00:44:40.314 
因此我們生成了密碼鑰匙

00:44:40.881 --> 00:44:45.352 
而且只有在設備密碼
和應用密碼都正確後

00:44:45.953 --> 00:44:48.822 
密碼鑰匙纔會授權給
Keychain訪問項目

00:44:51.825 --> 00:44:55.863 
正如我提到的如果
你將密碼保存到設備上或者應用中

00:44:56.530 --> 00:44:58.732 
這實際上並沒有提供額外的保護功能

00:44:59.600 --> 00:45:02.903 
因此你必須考慮除了設備
你還可以將密碼保存在哪裏

00:45:04.404 --> 00:45:07.407 
也許是服務器服務器
可以執行自己的策略

00:45:07.474 --> 00:45:09.076 
決定何時反饋密碼到你的應用上

00:45:11.111 --> 00:45:15.182 
或者也許你有物理配件
而且你也覺得用戶有物理配件

00:45:16.483 --> 00:45:19.520 
如果配件無法向你的應用提供密碼 

00:45:20.387 --> 00:45:22.656 
那麼就無法破解Keychain項目

00:45:23.123 --> 00:45:24.858 
而你也無法訪問數據

00:45:28.996 --> 00:45:34.067 
如要使用ApplicationPasswords 
你需要創建AccessControl列表

00:45:34.668 --> 00:45:36.537 
和本地授權指令

00:45:37.638 --> 00:45:40.407 
第一個列表會要求你使用應用密碼

00:45:40.874 --> 00:45:43.177 
第二指令會自行設定密碼

00:45:44.978 --> 00:45:47.247 
然後你可以取下這二者然後添加到

00:45:47.314 --> 00:45:49.449 
Secltem Call字典之中

00:45:51.218 --> 00:45:56.757 
這是使用本地授權指令

00:45:56.957 --> 00:45:59.092 
和Keychain項目的例子

00:46:01.862 --> 00:46:03.130 
那麼這就是
ApplicationPassword

00:46:04.431 --> 00:46:07.034 
最後的新策略指的是私人祕鑰用途

00:46:09.369 --> 00:46:10.637 
這是比較早的表格 

00:46:11.238 --> 00:46:14.308 
在這裏我們可以看到一個Keychain
項目從安全區域內的KeyStore

00:46:14.374 --> 00:46:16.710 
被釋放出來返回到了應用中

00:46:18.445 --> 00:46:22.983 
很明顯如果你將密碼
用於登錄服務器的話就需要它了 

00:46:23.550 --> 00:46:26.987 
但是這暴露了你的密碼
讓用戶空間存在潛在危險

00:46:28.989 --> 00:46:30.791 
所以如果有辦法在安全區域內 

00:46:30.924 --> 00:46:33.460 
保存密碼的話就不妙了

00:46:33.894 --> 00:46:35.095 
那麼這還有用嗎？ 

00:46:35.929 --> 00:46:38.131 
而且這裏使用的是不對稱加密技術 

00:46:39.499 --> 00:46:43.036 
這裏我們有的不僅僅是
單一的祕鑰 而是一組祕鑰

00:46:44.671 --> 00:46:47.307 
公共祕鑰並不需要任何保護 

00:46:47.841 --> 00:46:49.877 
但是私人祕鑰就必須要好好保護了

00:46:54.114 --> 00:46:57.518 
使用這種策略會用到
SecKey APi 

00:46:57.885 --> 00:47:00.254 
而且具體說的話幾分鐘說不完 

00:47:00.320 --> 00:47:03.924 
這裏就略過了但是這裏
有概括圖可以看看流程

00:47:05.492 --> 00:47:09.429 
如果你設定某些新的額外參數的話 

00:47:09.796 --> 00:47:12.065 
調用SecKeyGeneratePair會讓

00:47:12.165 --> 00:47:14.568 
私人祕鑰保存到安全區域中

00:47:15.802 --> 00:47:19.673 
但是公共祕鑰仍會返回到應用中保存

00:47:23.977 --> 00:47:26.613 
如果你嘗試檢索使用
SecItemCopyMatching的私人祕鑰 

00:47:26.680 --> 00:47:28.615 
那麼你會得到一個參數 

00:47:30.083 --> 00:47:35.222 
但是無法在安全區域之外
獲得實際的數據

00:47:37.658 --> 00:47:38.926 
因此實際上該如何使用呢？

00:47:39.726 --> 00:47:42.563 
好 你也許有一些數據是需要保留的

00:47:43.197 --> 00:47:48.802 
因此你可以調用SecKeyRawSign
然後將數據傳輸到安全區域

00:47:50.137 --> 00:47:52.606 
如果你已經設置了使用
Touch ID保護私人祕鑰

00:47:52.673 --> 00:47:53.907 
那麼只有在成功指紋匹配後

00:47:54.875 --> 00:47:59.246 
私人祕鑰才能用於訪問數據

00:47:59.413 --> 00:48:02.950 
之後再返回到應用中

00:48:09.356 --> 00:48:13.727 
因此也許你會想使用該策略作爲第二
要素加強Touch ID的安全性

00:48:15.429 --> 00:48:18.532 
我會給你看個示例流程但是請注意

00:48:18.832 --> 00:48:22.469 
在編寫加密協議的時候
這裏有很多複雜的細節

00:48:22.903 --> 00:48:24.738 
所以請別把這個示例當成標準

00:48:26.907 --> 00:48:28.675 
首先在登記流程中

00:48:29.076 --> 00:48:30.377 
你會生產一個密鑰對

00:48:32.646 --> 00:48:37.751 
然後將公共祕鑰和用戶
一般登錄信息發送到服務器上

00:48:39.953 --> 00:48:43.790 
服務器會將公共祕鑰
和用戶信息相關聯並記錄

00:48:43.857 --> 00:48:47.194 
這就是登錄流程

00:48:49.429 --> 00:48:52.199 
之後當服務器想要驗證你是

00:48:52.266 --> 00:48:55.135 
從同一臺物理設備登錄的 

00:48:56.937 --> 00:48:59.039 
服務器會嚮應用發送一個挑戰 

00:48:59.940 --> 00:49:02.342 
挑戰反過來會調用
SecKeyRawSign

00:49:04.878 --> 00:49:06.713 
用戶這時候會進行指紋識別 

00:49:07.147 --> 00:49:08.348 
然後匹配Touch ID

00:49:10.717 --> 00:49:14.121 
這樣挑戰就通過了
然後應用會將挑戰返回到服務器

00:49:16.256 --> 00:49:19.459 
之後服務器會使用之前保存的公共祕鑰

00:49:19.993 --> 00:49:21.061 
進行驗證簽字

00:49:25.032 --> 00:49:27.167 
再具體展開看一下細節

00:49:27.701 --> 00:49:30.571 
通過驗證的祕鑰是
Elliptic Curve P256

00:49:31.738 --> 00:49:35.142 
私人祕鑰則無法提取
即使在保護情況下亦不可

00:49:35.709 --> 00:49:38.579 
然後應用是RawSign
和RawVerify

00:49:43.016 --> 00:49:46.620 
總結一下 我已經大概講解了
Keychain的情況

00:49:47.621 --> 00:49:50.057 
以及大家可能會用到
Keychain的情況

00:49:52.359 --> 00:49:56.396 
我談論的技術是我們應當避免
讓用戶被密碼提示反覆騷擾

00:49:58.465 --> 00:50:02.336 
看看這兩個Touch
ID API 本地授權

00:50:02.736 --> 00:50:04.705 
和Keychain
Access Controls

00:50:06.340 --> 00:50:10.043 
另外之前說的新的高級功能
大家可以開發出新的東西

00:50:10.244 --> 00:50:13.547 
我們已經添加到
iOS 9的新API之中了

00:50:17.751 --> 00:50:22.289 
App密碼以及安全區
域保護的私人祕鑰

00:50:24.391 --> 00:50:25.659 
我總是非常期待

00:50:25.959 --> 00:50:28.862 
看看大家會如何利用新的API

00:50:28.929 --> 00:50:30.731 
開發出什麼更好玩的

00:50:31.164 --> 00:50:36.103 
也想看看大家是如何在應用中
權衡安全性和便捷性的

00:50:39.173 --> 00:50:41.642 
另外線上還有其他更多的資料

00:50:43.677 --> 00:50:46.213 
包括我之前提到的iOS安全白皮書

00:50:49.383 --> 00:50:51.919 
週四的NSURL網絡會議上
還會有更多的關於

00:50:52.352 --> 00:50:55.189 
應用傳輸安全的內容

00:50:59.593 --> 00:51:02.262 
另外歡迎明早和週四上午來到

00:51:02.663 --> 00:51:04.398 
安全私人實驗室會見我們

00:51:05.098 --> 00:51:06.066 
非常感謝大家