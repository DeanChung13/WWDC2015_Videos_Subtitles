《LLDB最新內容》以自己的方式調試達至名利雙收
下午好
歡迎參加《LLDB最新內容》講座
我是凱特
我負責管理Xcode的運行時間分析工具
也包括LLDB
今天我來爲大家介紹但我還帶來
兩位工程師
西恩和恩里科
他們會更深入介紹部分內容
但是開始之前我想談談
自上次WWDC以來  
今年的亮點有些或大
或小的改變
最著名的是...
我們推出首個Swift調試器
顯然這是向前邁出了一步可以編寫和開發
Swift代碼 大家一定會逐漸熟悉並喜愛
但更重要的是不會就此爲止
我們會進一步改善調試器
希望大家繼續反饋
幫我們實現盡善盡美
與此同時
我們還推出了Swift REPL
它稍稍不同於標準請求回覆REPL環境
實際上是僞裝的LLDB
大家不僅可以通過REPL 在Swift中提出問題
還可以通過它來調試那些問題
你實際上是在REPL中設置斷點
實現想在調試環境下
完成的任何事情
因爲它是LLDB
如果還沒有這麼深入研究
我建議大家看看看這一問題的相關博客
但是 這不是...最終結果
之後 我們做了無數的改進
自從首次推出產品以來
我們已經在Swift
調試體驗方面進行了百餘項改進
而且我們還在繼續提高Objective-C的調試體驗
我們今天也會提到部分內容
不過只會介紹自去年起做出的改進
Swift類型起初並未顯示出
繼承了Objective-C域
我們後來對此作了更正
Help現在包括了指令別名
需要理解的是
因爲當LLDB看似語法比較冗長
我們可能會讓你輸入help
實際上有許多快捷方式
在這次講座中我們會使用下列符號來描述它們
Help實際上可以縮寫爲第一個獨特序列
在這種情況下H就足以調出幫助
更重要的是對於更復雜的例子而言
如表達式-O--是指評價表達式
告知結果就像它是通過發送方法
來描述自己的一個對象
隨後在該表達之後
並無其他選項
但你可以輸入PO
PO是個方便的別名可以對左邊的
所有內容進行速記
那麼如果你習慣於用幫助
應該學習使用這些別名
因爲它們可以最快捷地
幫你獲得LLDB中的部分強大功能
我們還改善了數據格式
因爲告知你相關的數據情況
對於調試體驗而言是非常重要的
那麼設置
和NSNS Index Path
目前就有了默認格式
可以幫助理解數據
而不是僅僅展示
底層結構的回收機制
表達式的Printf原型
如果曾嘗試以Printf對它進行計算 可能會發現
有一些稍微可疑的結果
這是因爲調試器對它
不瞭解的表達式
聲明做了很多假設
而之前它在很多情況下也不瞭解printf
因此之前不知道它是個可變參數函數
也就是可以採取可變數量的特殊參數
也不瞭解特別是在64位設備上
如何正確傳遞這些特殊參數
這些都已得到改正這樣所有的
涉及C和Objective-C的printf表達式
都應該另行執行
那麼最後這次是真的最後
我們改善了分解格式
使其更方便閱讀
來深入瞭解部分更有趣的改進
今年春天實現了斷點改進
大家可能還沒有意識到
具體而言 大家現在可以命名斷點了
命名的斷點可能會比其他斷點
更易於使用這可能開始並不明顯
不過 這些命名不一定具備獨特性
可以對單個斷點使用多個名稱 這就很不簡單
可以把它們想象成標籤
所有的斷點指令都使用這些名稱
那麼設置斷點時可以提供斷點設置
短線N 大寫N
加上名稱
還可以加上另一個短線大寫N
和額外的名稱等等
但更重要的是一旦爲斷點
或多個斷點命名
我就可以對它們
通過所有其他的指令來操作
斷點可以命名這會使得所有斷點
都是可以共享命名或者就把它當作是標籤
這其實非常有趣因爲我們現在可以
實現在LLDBinit中設置斷點
如果你還不熟悉LLDBinit
這是一種文件...
名前綴有個句號
會進入主目錄
告知LLDB 這裏有一束指令
每次打開LLDB會話都需要執行
如果這麼使用則會在LLDB啓動時
生成一組 默認斷點
所有設置的斷點在實際生成目標之前
都會被所生成的每個目標所繼承
那麼結合兩方面因素
我可以在這些代碼行編寫LLDBinit
一組斷點 -n都命名爲malloc
一個斷點 -n都命名爲free
把所有斷點命名爲memory
然後再關閉
這就可以很方便的獲得所有處理斷點的內存
只要在我之後用到的
任何會話中輸入
"breakpointenablememory"即可
這樣就有了自己的一組非常方便的斷點
我肯定大家會經常使用
現在可以給它們一些好記的名稱
但是 當然大家在這裏不僅是來學習
我們已經完成並推出的內容
還有我們剛開始預覽的內容
Xcode 7
是個很重要的版本
包括許多改進
最重要的是表達式求值
西恩會爲大家詳細介紹這方面內容
Swift 2支持...當然...
語言會不斷髮展以及Objective-C 
支持模塊的高級處理
這些內容我們也會深入講解
但是部分內容其實就在後臺
如果繼續深入研究你可能會注意到
例如在Xcode 7中
大家都知道模塊
我們實際上可以在爲模塊構建調試信息一次後
再不必在其他位置重複進行
這可以大幅減少調試信息的
數量 並提高彙編的性能表現
一旦進入實際的.dSYM文件 
這個.dSYM文件就會
將你所需的所有內容都包括在內
但是其中還包括部分其它優化
例如 不爲C++類型複製信息
這多虧了定義法則的規定
否則我們會有多個副本
實際上 我們看到調試信息
要比Xcode 6中少了1/6
特別是對C++項目更是如此
我們還在多方面改進了數據格式
在Objective-C和Swift中矢量類型有着
獨特的自動數據格式
也許更重要的是
如果有Swift自定義類型
現在可以自定義它們的表現方式
只要編寫Swift代碼即可
恩里科會介紹更多詳情
我們還在LLDB中整合了地址消毒劑支持
那麼地址消毒劑不只會在
參考內存無效時會告知
你還可以針對內存提出問題
比如可以問例如 內存歷史
從LLDB控制檯瞭解它分配到哪裏
以及何時釋放
那麼你可能想了解更多
指令的內存系列並想知道相關幫助
我們還增加了類型查找指令
類型查找指令可以獲取
系統的任何類型信息
基本上 這就是個類似頭文件的表示
可以在調試器中獲得
以便提醒你類型的內容
因此 從LLDB提示中
我只需要把類型變爲"type lookup"隨後加上
類型名稱 然後我會獲得類型快速說明
本例中 新的錯誤類型
用於Swift錯誤處理機制
我知道 在幕後
通常會執行一對
一般已執行了的屬性只要使用EDAM類型即可
但是不管怎樣 都可以從控制檯看到細節詳情
同理 如果我感興趣"Comparable"類型
是個協議
它會告訴這個協議實際上是來自另外兩個
這樣你會看到我們從Equatable
<br/> 得到了等號運算符
下劃線Comparable 可以提供小於比較
而導出運算符是Comparable協議的一部分
這裏還可獲取許多便捷信息
和所有內容一樣
提醒你不必輸入完整命令"type lookup"
TY空格L便足以使用這個指令
但是要想知道更多詳情
特別是談到怎樣計算表達式
我想有請西恩•卡拉南[
大家好
我來講講LLDB中的LLDB
大家可能會覺得
有那麼多編譯器會話
爲什麼要在乎編譯器？
編譯器是LLDB的關鍵內容
會使得LLDB功能強大
會令LLDB簡單易用
它的強大是
因爲編譯器對程序運行
對配置數據的方法
以及當你說想看看
這個變量或調用函數時等 
有着獨特的理解
編譯器很重要還有一個原因是
它們可以與調試器輕鬆配合使用
如果想要打印
只要使用你熟悉
輸入的代碼
交給表達式指令
編譯器就會從中拿到指令
今天
我來講講在編譯器整合方面
有兩個重要
相關領域
獲得了的改進
首先
有個好消息要告訴各位
長期從事Objective-C 的開發人員
接下來
我要告訴...
Swift開發人員
希望現在各位都是
聊聊...
我們所做的這些改進
現在就開始講講Objective-C
LLDB
包括...
兩個獨立的編譯器
Clang
強大的Objective-C編譯器
當然 從去年起
是Swift編譯器
我們的Objective-C編譯器支持
多年來一直在改進
我們加入了非常出色的新功能
比如
Objective-C運行時間整合
那麼 如果Objective-C運行時間有部分信息
並未顯示在調試信息中
我們知道該向編譯器提供
這樣可以使用很多類
而不必特別做些什麼
當然 去年
我們在LLDB中
引入了Swift編譯器
Swift編譯器已經是
是很強的工具
我們把從Swift編譯器中
整合所學內容都用到其中
我們對二者都做了改進
我們來談談
表達式剖析器與Swift
怎麼配合
從Objective-C的角度
我們現在來看簡單的打印指令
這裏說到打印 因爲我用了p快捷方式
實際上是指
表達式
注意短線 
這是指
在p指令編碼後的所有內容
不能這樣把額外的選項交給指令
這裏有其他方法恩里科會給大家介紹
而且凱特剛剛給大家看過
這裏是些循環運行的簡單代碼
並會每次打印出循環計數
的確 如果運行它
你會得到自己預期的數字
這個功能好在哪裏？
LLDB和程序是單獨的進程
LLDB內部有swift編譯器
程序已經在運行
但是有了LLDB的幫助
Swift編譯器可以把你剛輸入程序運行的
代碼添加進來
如果喜歡打印...
循環計數器 這就相當棒
但是還有要調試的內容
Swift可以和變量配合
輸入一些代碼
數組的內容就打印出來
現在 這裏的數組
正好有一些在程序中的代碼
LLDB安排在編譯器上...
顯示數據 
這樣可以生成你所需的代碼
我還想簡單...介紹一下
就是Swift怎麼和SDK配合
當你輸入NSApplication.sharedApplication
這樣的表達式時 
首先 你會看到
NSApplication.sharedApplication
是按照預期的方式
但是LLDB要去
發現包括它的SDK模塊
讓編譯器可以訪問它
然後編譯器找到NSApplication
並想出如何使用sharedApplication
這非常好
而且都是在Swift中...
自動完成
在Objective-C
它並非總是工作
讓我們在Objective-C嘗試所有這些
有些人此刻可能有些擔心
因爲你知道 NSLog有時並不像
調試器中那麼簡單
過去 當輸入NSLog時
會看到像這樣的錯誤提示:
NS日誌存在未知返回類型
這是因爲在SDK肯定會
存在NSLog的定義
但是LLDB發現
符號中只有調試信息中的內容
在本例中它看到一個符號
這個符號 我們不知道它的返回類型是什麼
我們甚至不知道它還用了格式字符串
好消息是問題已經得到解決
NSLog是按照預期的方式工作
我們再做些更隱祕的內容
打印NSMakeRect
稍等！
爲什麼是隱祕的內容呢？
就在這裏框架中
可惜的是看似標識符並不存在
現在大家就會瞭解如果使用NSLog
可以轉換結果
對 可以這麼用
但是NSMakeRect不能這麼用
這是因爲
NSMakeRect是確定的NS-Inline
沒有符號
LLDB什麼也看不到
不錯
沒問題了
還剩一個問題
我們現在來看
原先NSApplicationsharedApplication
的情況
當然 若你是自己運行這個表達式
當然會在Objective-C中運行
我們已經在爲Objective-C運行時間整合
做了很多工作
但是如果想找出undo.Manager 
你很快會發現運行時間並未告訴你所有內容
特別是你發現的這個關於undo.Manager的
奇怪錯誤提示在類型id對象中並未發現
是什麼情況？
在SDK肯定
sharedApplication會返回一個
NSApplication星級
但如果來看運行時間
返回的是id
是個一般的
Objective-C對象
好消息
這不再是問題了
實際上 我們會看到只能從SDK得到的信息
例如指針爲可空值
這就是SDK支持Swift的最新功能
也會進入Objective-C
不過信息就在這裏
這就是我們所應用的理念
從SDK直接讀出
代碼會一直在LLDB中運行
我們瞭解本地變量函數 自己的類
SDK函數另一方面
我們還有更多問題 如大家所見
SDK類就像NSView和NSApplication
我們看到了 但是如你所見
因爲運行時間整合
這裏有個小星號
現在SDK包括如果你試着在表達式用過
NSASCIIStringEncoding
就會瞭解這永遠不行
如果使用宏 如int-max
那麼 max
利用兩個數字中最大值
這樣也不會奏效
所有這些在最新的LLDB中都已解決
我們也刪掉了煩人的星號
大家可能會說那麼每月要付多少個39.95才能用上
這個功能呢？
好消息 這完全免費
你只需要@import AppKit即可
運行一個表達式
表明輸入我關心的框架
如果用到AppKit 或是在諸位中間的
兩三位...
iOS程編寫人員
輸入UIKit...
就可以了
現在
我們並未將Swift放在那裏不管
Swift2.0可實現強大的錯誤處理支持
LLDB馬上就可以支持the bat
正如大家所期待的那樣
我們可以處理Swift錯誤
當調用可能在
表達式引發錯誤的函數時
你不必調用"try"
因爲...
我們爲大家抓取內容
如果你輸入
這個函數"throws"
並把它交給表達式
注意這和p指令完全一樣
你會獲得
爲你生成的...
錯誤變量 
其中包括函數引發的錯誤
也可以在REPL中...完成這些
如果從REPL提示中你做了同樣的事情
則會得到...錯誤變量
我們再來看看LLDB支持的...
更多內容
也就是說 你不希望總是看到
最後出現的是錯誤
你需要了解產生錯誤的代碼是什麼
不過 在Objective-C中
你用到了斷點來完成
具體而言你在Objective-C異常中設置了斷點
方法是...
你用了斷點來設置指令
確定了希望爲...
異常Objective-C...
設置斷點
我們來爲你設置了斷點
那麼一旦Objective-C代碼
要引發異常
我們就會停下來
在Swift錯誤中你可以做同樣的事情
只要用Swift替代Objective-C 
我們就會停止程序要...
引發的...
Swift錯誤
但是還可以...
做另一件很酷的事
你可以停止具體的錯誤類型
這是我們支持Swift的一個功能
這麼做的方法很簡單
和你在設置表達式斷點非常相似
可以使用短線O參數
來明確你希望捕捉的
錯誤類型名稱
如果這麼做那麼只有在出現
你感興趣的錯誤類型時
纔會停下來
最後
當然
你可以按照正常代碼中...
的方法捕捉錯誤
畢竟 部分而言
REPL是指了解和發現語言運行的方法
如果輸入Foundation
來獲取NSError
然後編寫會產生NSError的代碼
就可以捕捉NSError...並打印出來
如果這麼做
結果就和你在自己的程序中
捕捉的效果完全相同
我希望大家...
記住兩點
首先
添加輸入...
自己的模塊
第二
試着用LLDB進行錯誤處理
這是個不錯的辦法
要想了解更多詳情
不是說告訴程序該做什麼
而是如何在程序產生資料完成後打印信息
有請恩里科·格拉納塔
大家好
上午我還在實驗室
我們在想辦法解決一個問題
問題是...爲什麼我看不到這個變量？
出什麼事了？
爲了幫助大家找到問題
我們試了幾個指令
試了表達式 還有PO 我們還試了幀變量
此刻 人們通常會問
爲什麼有那麼多指令來做幾乎相同的事情？
來看我的數據看看程序中在發生什麼
大家來這裏就是了解內部消息的
我們來看一下LLDB讓你看數據的指令
共有三個
幀變量
表達式指令
是個p指令
表達式 短線大寫O
這個...
剛纔講過
是作爲PO指令
首先
幀變量指令
幀變量指令可以縮寫爲frv
輸入時 基本是Xcode變量視圖
它讓你...看所有的本地變量
讓你看...
幾個本地變量
此外
也可以應用...
帶有短線 短線格式旗標的格式
要強調的一點是
因爲在看到首次輸出時
有Tuple的話我會回到這裏
這是個...
聚合
是包括其他對象的對象
聚合當中的內容
我們稱之爲...
子對象
這個表達式指令
在本次會話中你會多次看到
我會簡要介紹一下
當然
有了表達式指令
可以簡單算一下正如你猜測的一樣
完全可能...使用之前的結果
並用它們完成更多內容
當然 表達式指令也知道如何
自定義結果的格式
需要再次強調的一點是
子對象
第三個指令
po指令
這個可能是...在座各位Objective-C開發員的指令
我猜測在Objective-C代碼之前
大家都知道是PO指令
你可以生成對象把說明打印出來
可以生成NSArray或打印現有的NSArray
你就會看到其中的內容
要知道
對於字符串而言非常簡單
那麼
三條指令
它們並非是完全一樣的功能
大家估計此刻也猜到了
實際上
它們只是有些相似
但不是完全相同
例如
表達式指令和po指令
是..."run my code"指令
無論代碼類型是什麼
這些指令都會運行
但是 接下來的幀變量指令
和表達式指令第二步則不相同
當它們不得不顯示結果時
會用到LLDB格式器系統
我們在以往的WWDC講座中
介紹過LLDB格式器系統
大家應該都去找來看看
不過簡單而言
LLDB掌握部分嵌入系統類型
並對其自動格式化
NSArray NSDictionaries加字符串
還可以提供...在Python中編寫的自己的格式
另一方面
po指令並不使用LLDB格式器
po指令在...後面在幕後
運行更多的代碼
實際上會生成爲
爲你顯示的真實結果
你可能已經在一個Objective-C類中
至少編寫了一個說明方法
然後意識到這就是po打印的內容
現在
我希望大家想一想
這兩個模型
實際上在用你的對象併爲之生產數據
LLDB格式器模型
我們稱之爲
"out of process"格式模型
爲什麼呢
因爲格式器位於進程之外
它或者將內容構建到調試器中
或者你用部分Python腳本表現對象
這是不同的語言不同的文件
存在於不同的作用域中
另一方面
外部格式器位於調試器中
這就很容易...
讓他訪問調試器所具備程序的所有內容
就像是可以鳥瞰所有進程
因此 這類格式器也可以很容易...
確定程序狀態並未改變
你若是看到調試器中的數據後
不想改變程序狀態
調試器相當於是階段...
檢測器
它來看內容並試圖不做改變
在另外的模型中
po模型
writeadescriptionmethod模型
是個進程格式模型
你同時編寫數據和格式器
再用相同的語言編寫一遍
可能甚至都在相同的文件中編寫
因爲格式器是在應用中
運行的代碼
可以輕鬆並完全
訪問應用的對象模型
但是功能更強大
責任也更大
需要確保格式器
並沒有改變程序的狀態
要確保並未在格式器中...
對準備表現的對象做了任何改變
那好 Objective-C
具備進程進程格式模型
我可以編寫說明方式
調試器會用到
那Swift會怎樣？
結果是 演講廳裏在座的各位
又一次知道了內部消息
從一開始Swift已有了
進程格式模型
但是 在哪兒呢？
怎麼用呢？
希望大家都用過Swift開發環境
如果用過Swift開發環境
那就用過進程格式模型
從一開始它就在這裏
那有什麼新奇的呢？
現在 在Xcode 7我們會採取完全相同的模型
把它作爲公共API
大家可以使用它
它仍然支持...開發環境
不過現在也支持LLDB po指令
現在 你有着正確的Swift格式器
針對Swift對象
怎麼弄？
我們來詳細講一下
這個模型基於...
4個協議
這些是各自的名稱
對 我說是四個協議
它們的名稱相當長
但是...我不會過分擔心
可能是這個模型的可選項
4個協議
並非是指必須符合所有要求
可以選擇子集來獲得所需要的結果
符合使用的協議部分
就可以了
我們來看一下協議
CustomStringConvertible
是協議名稱
表示...
怎樣把對象作爲字符串打印？
它並未告知LLDB
它還告知了Swift
怎麼弄？
Swift打印功函數
以及Swift字符串插值功能
二者都用了CustomStringConvertible協議
非常好用
實現這些很難嗎？
非常簡單
我有個數據結構代表啤酒歌的瓶子
因爲我自己正在準備bash腳本
我想把歌詞打印出來
就生成了一個實例
並看牆上有多少啤酒瓶
但是要等到app的...
所有內容都沒問題的時候
如果我做調試也許我需要更多信息
那就需要Custom DebugString Convertible
這是調試器對這個對象的具體表示
調試器具體表示是什麼
則要取決你的app
完全取決於對象模型的語義
但是作爲提示
debugPrint函數
將默認選擇這個協議
當然
打印和debugPrint 
不會滿足其他一致性要求
如果它們的興趣點不在此
怎麼運行呢？
很簡單
我們把啤酒瓶進行擴展
因爲我們在做調試
希望瞭解牆上啤酒瓶的更多信息
這樣我們可以確定啤酒類型是否正確
這就會成爲不錯的bash腳本因爲它們都很出色
第三個協議
是CustomPlaygroundQuick Lookable
正如名稱所示
這個協議是主要爲環境而定
是指爲環境中的對象提供
豐富的圖形表示
想要看舉例嗎？
當然有
我可以編寫代表一個人的數據結構
然後我可以獲得一個人的描述
在環境的側邊工具欄顯示
以此作爲生成這個類型對象的結果
不好意思讓你們失望了
我的確想做成的
但是 大會上不會銷售
帶有人像的T恤衫
不好意思
不過 我有個彌補的辦法
其中最後的協議
CustomReflectable協議
它可以讓我生成完全自定義的
子對象層次
好 我說過 我會回到"children"這裏 說到做到
當我說到完全自定義子對象層次時
我是說
我可以做個新的...
我可以爲對象製作新的結構
可以告知語言可以告知調試器
可以告知環境
我的對象實際上是用什麼來造的
大家會看到
你做此事的方法
交易用的貨幣
在想要對Swift描述對象的結構時 
被稱爲
Mirror
可反射的鏡像
我們來看個例子不要費時費事
我有個應用用來
蒐集溫度樣本
它有兩個數據結構
一個用來描述
此刻的時間
它說在給定的時刻
這就是我得到的溫度信息
接着當然我們獲得溫度樣本
現在我來調試app
我想看看是什麼情況
怎麼來處理樣本
所以我提出
po溫度
我得到的是這個
實話講 我看着它覺得
作爲默認值還不錯
不過 我立刻發現我想調整兩個問題
爲什麼在把時間堆在兩行？
我想把所有內容都放在一行
而且如果是用a.m.p.m.格式
表示上下午最好
還有溫度
我看着它 覺得
標度是什麼呢？
我不知道
是開氏列氏還是蘭氏溫標？
我們在美國想用的是華氏溫度
好消息是我們可以用兩步驟
解決所有這些問題
開始
第一步 我們把時間按照一行打印
我做了這些來實現這一點
用了NSDate格式器
因爲我要在...自己的應用中運行
因爲我運行的對象格式代碼
實際就是正常的Swift代碼
就是我通常編寫app
所用的代碼不論是什麼框架
什麼庫
還是我的app完成任務通常所用的技術
我在格式器中用就好了
在本例中 是NSDate格式器
第二步
選用華氏溫度
怎麼實現？
我們生成鏡像
好了
現在我們可以說溫度數據對象
是作爲包括三項內容來構建
時間 攝氏溫度
以及華氏溫度
時間是存儲在對象內部的
真實時間數據的字符串插值
因爲是用字符串插值
因爲我們提供了自定義字符串可轉換一致性
這些可以自動提取
這裏還要注意的一點是
當我獲得兩種溫標用攝氏度
和華氏度來進行結果打印
我不能改變存儲在對象內的數值
當然 你會說 不要改
實際上 要注意的是
不要用編寫進程格式器的
方法改變程序的狀態
現在我們做了這麼些工作得到了這些東西
會怎樣從中受益呢？
我們可以試着再做po
來吧
現在我再來看
我看到了對象
可以看到現在是
6:30 p.m.
是93.2度
大家可能會奇怪 的確
昨天庫柏蒂諾是很熱
現在我們完成了但是這麼做
是因爲我們很聰明提前完成了工作
有時 我會試着調試一些內容
把自己的程序調試到位
結果有這樣一個很難複製的問題
最後發生了
不過現在真的很難找到這數據
數據非常令人頭痛非常很複雜
真希望自己之前做過這事兒
這樣我就可以更簡單地看待我的數據了
不過 可惜沒有
所有的希望都落空
不 沒有
還可以添加一致性和運行時間
通過表達式剖析器 可以添加這些一致性
並運轉 同時調試你的app
另一方面
你還不能改變它們
現有的一致性保留
你在REPL做嘗試
你真希望自己能做po
我希望自己能添加一致性
在REPL中也可以這麼做
當然 但是我確定大家都期望這樣
爲什麼？
在環境中 也是如此
來看
看似...
我們在過去一年在調試器方面
所做了許多動作
你們從凱特 西恩和我這裏聽到的
這些都離不開要在調試的同時確保能夠輕鬆訪問
儘可能多的相關信息
訪問Objective-C運行時間
會讓你在域無法獲取之前對之有更多瞭解
SDK模塊
爲應用所運行的操作環境
更多類型 更多函數甚至有宏觀
提供了前所未有的訪問程度
還有進程格式
進程格式是用來生成
跨界應用類型的編譯表示的
極好方法
它們可以應用在環境中在REPL中
也可以是在調試器中
若要了解更多詳情
可以隨時
瀏覽我們的網站Swift語言文件
或開發人員論壇當然還有實驗室
還可以給開發顧問斯特凡發郵件
非常感謝希望大家喜歡WWDC