00:00:19.720 --> 00:00:24.424 
Swift性能優化

00:00:33.267 --> 00:00:36.236 
早上好 歡迎來到
“Swift性能優化”演講現場 

00:00:36.537 --> 00:00:39.673 
我的名字是那達夫我將與
我的同事邁克爾

00:00:39.840 --> 00:00:41.775 
和喬一起向大家展示如何

00:00:41.842 --> 00:00:43.443 
優化你的Swift程序

00:00:44.344 --> 00:00:49.950 
現在我們編譯器團隊的工程師
熱衷於讓代碼運行得快

00:00:50.284 --> 00:00:52.586 
我們相信如果你的app得到高度優化

00:00:52.653 --> 00:00:54.221 
你可以創造出令人歎爲觀止的作品

00:00:54.421 --> 00:00:57.491 
如果你有同樣的看法
那麼這個演講適合你聽

00:01:01.929 --> 00:01:04.031 
今天我首先要講一講在過去的幾年中

00:01:04.096 --> 00:01:07.301 
我們對編譯器所做的一些新的優化

00:01:08.001 --> 00:01:11.738 
之後邁克爾將描述
Swift語言的底層實現

00:01:11.805 --> 00:01:13.507 
並就如何編寫高性能的

00:01:13.740 --> 00:01:15.442 
Swift代碼給大家一些建議

00:01:15.943 --> 00:01:20.547 
最後喬將演示如何使用工具來識別

00:01:20.948 --> 00:01:23.984 
和分析你的Swift
代碼中的性能瓶頸

00:01:26.720 --> 00:01:31.558 
Swift是一個靈活
並且安全的編程語言

00:01:31.625 --> 00:01:36.129 
有很多的功能包括閉環 協議 泛化

00:01:36.430 --> 00:01:38.532 
當然還有自動引用計數

00:01:38.999 --> 00:01:42.603 
現在你們中有些人可能把
這些特性與運行緩慢聯繫在一起

00:01:42.836 --> 00:01:46.907 
因爲程序必須做更多的工作
來實現這些高級功能

00:01:47.608 --> 00:01:50.744 
但Swift是一種
非常快速的編程語言

00:01:50.811 --> 00:01:53.080 
可以編譯爲高度優化的本地代碼

00:01:54.081 --> 00:01:56.517 
那麼我們如何讓Swift迅速運行呢?

00:01:57.217 --> 00:01:59.753 
好 我們將編譯器優化的

00:02:00.053 --> 00:02:05.392 
目標設定爲所有的這些
高級功能實現了這些目標

00:02:05.859 --> 00:02:12.499 
就可以確保那些高級
功能造成的負擔是最小的

00:02:14.468 --> 00:02:16.904 
現在 我們有很多編譯器優化

00:02:16.970 --> 00:02:19.373 
但是我們沒有足夠的時間去逐一回顧

00:02:19.673 --> 00:02:23.544 
所以我決定給你們舉一個
編譯器優化的例子

00:02:24.111 --> 00:02:26.980 
這種優化稱爲消除邊界檢查

00:02:29.650 --> 00:02:31.919 
在屏幕上你們可以看到
一個非常簡單的循環

00:02:32.186 --> 00:02:34.087 
這個循環用數字13對陣列中的所有

00:02:34.354 --> 00:02:37.658 
元素進行掃描
從而對陣列的內容進行加密

00:02:37.891 --> 00:02:39.059 
這種加密方式並不好

00:02:39.860 --> 00:02:43.096 
在陣列邊界以外進行讀寫

00:02:43.163 --> 00:02:45.032 
是一個嚴重的錯誤

00:02:45.499 --> 00:02:47.401 
也可能有安全隱患

00:02:48.101 --> 00:02:52.472 
而Swift則可以對你的
程序進行保護它添加了一些代碼

00:02:52.539 --> 00:02:55.442 
能夠檢查阻止程序
在陣列邊界以外進行讀寫

00:02:56.109 --> 00:03:00.047 
現在 問題是這種檢查
會拖慢代碼的運行速度

00:03:02.182 --> 00:03:05.319 
另一個問題是它會阻擋其他優化

00:03:05.385 --> 00:03:07.988 
例如在運行這種檢查時

00:03:08.355 --> 00:03:09.656 
我們就不能將這段代碼向量化

00:03:10.524 --> 00:03:13.193 
所以我們已經實現了一個編譯器優化

00:03:13.627 --> 00:03:16.964 
以便將這種檢查置於
循環之外使檢查的代價

00:03:17.030 --> 00:03:21.468 
可以忽略不計因爲我們並不是
對陣列邊界以內遇到的

00:03:21.802 --> 00:03:24.037 
循環中的每次迭代都進行檢查

00:03:24.271 --> 00:03:26.673 
我們只在進入陣列時進行一次檢查

00:03:27.174 --> 00:03:28.942 
所以這是一個非常強大的優化

00:03:29.443 --> 00:03:31.044 
它使得數字代碼運行得更快

00:03:33.080 --> 00:03:36.316 
好吧 這是一個優化的一個例子

00:03:36.617 --> 00:03:38.619 
而我們有很多優化

00:03:39.319 --> 00:03:41.021 
我們知道這些優化起到了作用

00:03:41.221 --> 00:03:44.825 
而且非常有效因爲我們
正在跟蹤數以百計的程序

00:03:44.892 --> 00:03:47.594 
和基準測試程序在過去的一年裏

00:03:47.828 --> 00:03:50.931 
我們注意到這些程序的
運行速度顯著加快

00:03:51.398 --> 00:03:53.567 
每次我們添加一個新的優化

00:03:53.934 --> 00:03:57.171 
每次我們對現有的優化進行改進

00:03:57.471 --> 00:03:59.640 
我們都會注意到這些程序變得更快

00:04:00.774 --> 00:04:03.510 
現在大家不會有興趣逐一瞭解

00:04:03.577 --> 00:04:06.947 
這些程序所以我決定介紹其中的五個

00:04:08.282 --> 00:04:12.619 
現在大家在我身後的屏幕上
看到的程序來自多個領域

00:04:13.287 --> 00:04:15.956 
一個是面向對象的程序

00:04:16.055 --> 00:04:19.159 
另一個是數字型的 另一個是函數型的

00:04:20.459 --> 00:04:22.763 
我相信這些程序代表了

00:04:22.829 --> 00:04:25.399 
如今用戶以Swift語言
編寫的代碼類型

00:04:26.333 --> 00:04:28.001 
正如大家所見在過去的一年

00:04:28.569 --> 00:04:30.304 
這些程序明顯運行得更快

00:04:30.370 --> 00:04:33.040 
加快了兩到八倍之間這非常了不起

00:04:33.707 --> 00:04:36.310 
現在這些程序在發佈模式下進行了優化

00:04:37.211 --> 00:04:39.947 
但我知道你們也關心未優化的

00:04:40.314 --> 00:04:43.150 
程序的性能因爲你們花費大量的時間

00:04:43.617 --> 00:04:46.320 
編寫代碼進行調試並將其在模擬器運行

00:04:46.453 --> 00:04:48.388 
所以你們關心未優化程序的性能

00:04:49.556 --> 00:04:54.061 
所以這五個項目是相同的
均處在調試模式

00:04:54.528 --> 00:04:55.462 
他們都未經優化

00:04:55.996 --> 00:04:58.632 
所以你們可能會問自己 等等

00:04:58.732 --> 00:05:04.304 
對優化器的改進是如何提高
未優化代碼的性能的

00:05:04.638 --> 00:05:09.042 
對吧 我們做了兩件事
使未優化的代碼運行得更快

00:05:09.409 --> 00:05:12.513 
首先 我們改進了
Swift的運行時組件

00:05:12.813 --> 00:05:16.984 
運行時組件負責分配內存

00:05:17.050 --> 00:05:19.386 
訪問元數據以及類似這樣的事情

00:05:19.453 --> 00:05:20.554 
所以我們對它進行了優化

00:05:20.954 --> 00:05:24.424 
我們做的第二件事是現在我們能夠

00:05:24.491 --> 00:05:26.927 
更好地優化Swift標準庫

00:05:27.060 --> 00:05:31.965 
標準庫是含有陣列實現
代碼詞典和設置的組件

00:05:32.299 --> 00:05:35.769 
所以通過更好地優化標準庫

00:05:36.069 --> 00:05:39.706 
我們能夠提升未優化程序的性能

00:05:40.674 --> 00:05:45.145 
我們知道在過去的一年經過優化

00:05:45.479 --> 00:05:48.882 
和未經優化的程序的性能都顯著增強

00:05:49.449 --> 00:05:51.518 
但是爲了瞭解全部的情況
我想給大家做一個

00:05:51.585 --> 00:05:53.787 
Swift與
Objective-C語言的比較

00:05:55.055 --> 00:05:58.859 
現在在屏幕上你可以看到
兩個非常著名的基準測試程序

00:05:59.126 --> 00:06:01.361 
這是Richards
和DeltaBlue

00:06:01.428 --> 00:06:02.829 
都是以面向對象的風格編寫的

00:06:03.230 --> 00:06:04.331 
根據這兩個程序的測試

00:06:04.531 --> 00:06:06.800 
Swift要比
Objective-C快得多

00:06:07.467 --> 00:06:09.136 
在演講的這個階段

00:06:09.203 --> 00:06:12.239 
我不會告訴你們爲什麼Swift
要比Objective-C快

00:06:12.673 --> 00:06:14.842 
但是我向諸位保證
我們還會回到這張幻燈片

00:06:15.242 --> 00:06:17.077 
而且我們將談到爲什麼Swift更快

00:06:19.413 --> 00:06:22.549 
好 現在我要講些不一樣的東西

00:06:23.116 --> 00:06:25.819 
我想談談一個新的編譯器優化模式

00:06:25.953 --> 00:06:28.121 
叫做“模塊整體優化” 

00:06:28.388 --> 00:06:30.691 
它可以讓你的程序運行速度明顯加快

00:06:31.525 --> 00:06:35.896 
但在那之前我想談談
Xcode編譯文件的方式

00:06:38.065 --> 00:06:41.435 
Xcode是單獨編譯每個文件的

00:06:42.169 --> 00:06:44.137 
這是一個很好的理念

00:06:44.471 --> 00:06:47.641 
因爲它可以在計算機的多個
核心中並行編譯很多文件

00:06:48.108 --> 00:06:48.942 
這樣很好

00:06:49.042 --> 00:06:52.846 
它也可以重新編譯
需要更新的只讀文件

00:06:53.380 --> 00:06:54.214 
所以很好

00:06:54.548 --> 00:06:59.086 
但問題是這種優化器的
處理範圍僅限於一個文件

00:07:01.555 --> 00:07:05.058 
有了模塊整體優化模式編譯器能夠

00:07:05.125 --> 00:07:09.029 
一次優化整個模塊這樣的優勢很明顯

00:07:09.129 --> 00:07:11.031 
因爲它可以分析所有數據

00:07:11.632 --> 00:07:12.933 
並進行積極的優化

00:07:13.567 --> 00:07:17.271 
現在 構建整體優化
模式需要更長的時間

00:07:19.106 --> 00:07:22.242 
但生成的二進制代碼通常運行得更快

00:07:24.645 --> 00:07:27.181 
在Swift 2中我們對
模塊整體優化模式

00:07:27.247 --> 00:07:28.515 
進行了兩個主要的改進

00:07:28.582 --> 00:07:33.020 
首先們添加了新的依靠模塊整體

00:07:33.520 --> 00:07:35.088 
優化模式的優化

00:07:36.223 --> 00:07:38.258 
所以你們的程序有可能運行得更快

00:07:38.992 --> 00:07:44.331 
第二我們能夠實現編譯管道
某些部分並行

00:07:44.831 --> 00:07:49.837 
所以在模塊整體優化模式中的
編譯組件應該使用更短的時間

00:07:53.106 --> 00:07:55.209 
在我身後的屏幕上你可以看到兩個程序

00:07:55.275 --> 00:07:57.911 
它們在模塊整體優化模式下運行得更快

00:07:58.045 --> 00:08:00.981 
因爲編譯器能夠做出更好的決策

00:08:01.048 --> 00:08:07.387 
它能分析整個模塊的信息
並據此做出更積極的優化

00:08:10.123 --> 00:08:13.694 
在Xcode 7中
我們對優化級別菜單進行了一些更改

00:08:14.194 --> 00:08:18.665 
現在模塊整體優化是你們可以
選擇的選項之一

00:08:19.233 --> 00:08:21.435 
所以我鼓勵你們在你們的程序中嘗試

00:08:21.802 --> 00:08:22.636 
模塊整體優化模式

00:08:23.537 --> 00:08:25.906 
說到這一點我想邀請邁克爾上臺

00:08:25.973 --> 00:08:28.609 
給大家講解Swift代碼的底層實現

00:08:28.675 --> 00:08:32.179 
並給大家一些關於編寫高性能
Swift代碼的建議

00:08:32.379 --> 00:08:33.212 
謝謝大家

00:08:44.191 --> 00:08:45.025 
謝謝 那達夫

00:08:46.193 --> 00:08:47.861 
今天我想跟大家談談

00:08:48.195 --> 00:08:53.133 
Swift編程語言及其性能
特徵的三個不同方面

00:08:53.800 --> 00:08:57.271 
對於每個方面我都會給出具體的技術
大家可以用它們

00:08:57.404 --> 00:08:59.773 
來提高你們的app的性能

00:09:01.575 --> 00:09:04.111 
讓我們首先說說引用計數

00:09:04.745 --> 00:09:09.616 
一般來說編譯器可以消除大部分引用
計數的負擔不需要任何幫助

00:09:10.450 --> 00:09:14.988 
但是有時候你還是會發現由於
引用計數的負擔造成的代碼減速

00:09:15.956 --> 00:09:19.593 
今天我將展示兩種技術 你們可以利用

00:09:19.860 --> 00:09:22.095 
它們來減少甚至消除這種負擔

00:09:23.530 --> 00:09:26.033 
讓我們首先看看引用計數和類的關係

00:09:26.366 --> 00:09:29.169 
從而瞭解引用計數的基礎知識

00:09:30.971 --> 00:09:32.873 
這裏有一個代碼塊

00:09:33.106 --> 00:09:36.243 
它包含一個C類一個包含一個

00:09:36.310 --> 00:09:39.146 
可選C的函數和幾個變量定義

00:09:39.613 --> 00:09:41.915 
讓我們逐行看看代碼執行情況

00:09:44.084 --> 00:09:46.720 
首先我們從分配C類的新實例開始

00:09:46.787 --> 00:09:48.822 
並將其分配給變量X

00:09:49.790 --> 00:09:53.360 
注意在類別實例的頂部
有一個包含數字1的框

00:09:53.560 --> 00:09:56.230 
它代表了類實例的引用計數

00:09:56.997 --> 00:10:01.869 
當然這是1 因爲目前只有一個
類實例的引用 即x

00:10:02.903 --> 00:10:05.873 
然後我們將X分配給變量y

00:10:06.006 --> 00:10:08.041 
這將創建一個新的類實例的引用

00:10:08.342 --> 00:10:13.614 
導致我們增加類實例的引用計數
給我們一個引用計數 2

00:10:14.848 --> 00:10:16.583 
然後我們中止了y並打開了foo

00:10:16.650 --> 00:10:18.719 
但是實際上我們並沒有中止y本身

00:10:18.785 --> 00:10:24.691 
相反我們創建了一個臨時的C
並把y賦值到C

00:10:25.192 --> 00:10:29.263 
它可以充當類別實例的第三個引用

00:10:29.530 --> 00:10:32.799 
這可以導致我們再一次增加
類別實例的引用計數

00:10:33.901 --> 00:10:39.473 
然後當foo退出時C被摧毀
導致我們減少類別實例的引用計數

00:10:39.706 --> 00:10:42.109 
使引用計數爲2

00:10:42.342 --> 00:10:45.445 
最後我們賦值零到y和x

00:10:45.846 --> 00:10:48.182 
使類別實例的引用計數爲零

00:10:48.448 --> 00:10:49.883 
然後它被收回

00:10:51.652 --> 00:10:55.255 
注意每次我們做了一個任務

00:10:55.556 --> 00:10:58.058 
我們必須執行引用計數操作

00:10:58.225 --> 00:11:00.360 
來保持類別實例的引用計數

00:11:01.261 --> 00:11:04.364 
這是很重要的因爲
我們必須一直保持記憶安全

00:11:05.866 --> 00:11:09.303 
現在對於熟知
Objective-C的你們來說

00:11:09.369 --> 00:11:11.872 
當然沒有什麼新的情況發生

00:11:12.306 --> 00:11:17.010 
減量和增量被謹慎的保留

00:11:17.678 --> 00:11:18.545 
和解除

00:11:19.246 --> 00:11:21.181 
但是現在我想告訴你

00:11:21.248 --> 00:11:24.451 
一些也許更獨特更新奇的事情

00:11:24.852 --> 00:11:28.088 
也就是說結構是如何
引用計數相互影響的

00:11:29.356 --> 00:11:35.162 
我要開始了...讓我們開始討論
先觀察一個不包含引用的類別

00:11:36.697 --> 00:11:37.865 
這裏有一個類別點

00:11:38.298 --> 00:11:40.000 
當然 它不包含任何引用

00:11:40.434 --> 00:11:43.770 
但是它有兩個特性x和y都是浮點數

00:11:44.705 --> 00:11:47.040 
如果我存儲其中一個點在一個數組中

00:11:47.474 --> 00:11:50.711 
當然因爲它是一個類別
所以我不會把它直接存儲在數組中

00:11:51.011 --> 00:11:53.714 
相反我把參照點存儲在數組中

00:11:55.015 --> 00:11:56.917 
所以當我對該數組進行迭代

00:11:57.184 --> 00:12:01.355 
並初始化循環變量p的時候

00:12:01.421 --> 00:12:04.892 
我實際上創建了一個
到類別實例的新的引用

00:12:05.292 --> 00:12:07.928 
這意味着我必須執行引用計數的增加

00:12:08.962 --> 00:12:11.732 
然後,當P在循環變量的
最後被摧毀的時候

00:12:11.798 --> 00:12:14.168 
我必須減少引用計數

00:12:15.302 --> 00:12:17.804 
在Objective-C中
我們必須時常地

00:12:17.971 --> 00:12:20.507 
做簡單的數據結構比如點

00:12:20.574 --> 00:12:24.211 
一個你可以使用來自Foundation
像NSRA數據結構的類別

00:12:24.978 --> 00:12:27.614 
然後無論你何時操作簡單的數據結構

00:12:27.781 --> 00:12:29.883 
你將會使類別產生負荷

00:12:30.751 --> 00:12:33.520 
在Swift裏
我們可以使用結構...

00:12:33.587 --> 00:12:36.023 
在這種情況下我們可以
使用結構解決問題

00:12:36.089 --> 00:12:37.658 
而不是一個類別

00:12:38.792 --> 00:12:40.994 
所以讓我們把點做成結構

00:12:41.562 --> 00:12:44.898 
現在我們能夠將各個點
直接存儲到這個數組中

00:12:44.965 --> 00:12:47.267 
因爲Swift數組能夠
直接存儲結構組

00:12:47.734 --> 00:12:54.174 
更重要的是因爲一個結構本身不需要
引用計數 而且這個結構的屬性

00:12:54.508 --> 00:12:57.144 
也不需要引用計數

00:12:57.377 --> 00:13:01.315 
所以我們可以直接捨棄之前
所有引用的計數在循環中

00:13:03.116 --> 00:13:06.453 
現在讓我們思考一個更加複雜的例子

00:13:06.520 --> 00:13:09.656 
假設一個結構中包含一個引用的參數

00:13:13.093 --> 00:13:17.564 
雖然一個結構其本身在
任務中並不需要引用計數變量

00:13:17.631 --> 00:13:21.001 
就像我之前提到的
但是它確實需要這種變量

00:13:21.068 --> 00:13:22.970 
如果一個結構中包含了一個引用參數

00:13:23.837 --> 00:13:25.939 
這是因爲分配一個結構

00:13:26.240 --> 00:13:30.177 
和獨立分配每一個屬性是等價的

00:13:31.278 --> 00:13:33.614 
所以考慮到我們之前
看到的關於結構的點

00:13:35.082 --> 00:13:38.752 
它能夠很有效的被複制
當我們分配它的時候就沒有引用的計數

00:13:39.152 --> 00:13:42.623 
假設有一天我在我的app上工作

00:13:42.689 --> 00:13:44.691 
我決定... 好吧我想要使每一個點

00:13:44.758 --> 00:13:47.461 
都能被畫成不同的顏色

00:13:47.661 --> 00:13:51.598 
所以我在我的結構中
添加了一個UI顏色屬性

00:13:52.099 --> 00:13:55.769 
當然 Ui顏色是一個類這實際上是在
我的結構中添加了一個參數

00:13:57.271 --> 00:14:00.774 
現在這就意味着在任何時刻
我要分配這個結構

00:14:01.341 --> 00:14:04.344 
和獨立分配這個結構中的UI顏色

00:14:04.912 --> 00:14:08.882 
都是等價的這就意味着
我必須執行一個對計數參數的修改

00:14:10.317 --> 00:14:14.521 
現在雖然使用一個
包含計數參數的結構的代價並不高

00:14:14.588 --> 00:14:19.359 
我的意思是 我們通常使用類
並且類也有相同的特性

00:14:19.893 --> 00:14:23.730 
現在我想給你們展示
一個更加極端的例子

00:14:24.298 --> 00:14:27.568 
即一個包含很多計數字段參數的結構

00:14:29.036 --> 00:14:33.340 
這裏我有一個結構用戶我將使用它
來模擬用戶在一個我寫的app中

00:14:33.707 --> 00:14:37.044 
並且每個用戶都有一些
跟它相關聯的數據 即

00:14:37.144 --> 00:14:40.781 
三個字符串 一個作爲用戶的名字

00:14:41.381 --> 00:14:43.550 
一個作爲用戶的姓氏

00:14:43.951 --> 00:14:45.752 
一個作爲用戶的地址

00:14:46.887 --> 00:14:49.823 
我也有一個空間
來存儲數組和一個字典

00:14:49.890 --> 00:14:52.759 
來存儲與用戶相關的特定的app數據

00:14:54.361 --> 00:14:57.698 
即使這些所有的參數都是數值類型的

00:14:58.599 --> 00:15:02.002 
在其內部 包含一個類

00:15:02.402 --> 00:15:05.772 
這個類用來管理內部數據的生命週期

00:15:06.974 --> 00:15:10.077 
這就意味着每次我分配
這些結構中的一個參數

00:15:11.411 --> 00:15:14.381 
每次我都要將這個參數
推送到一個函數中

00:15:14.448 --> 00:15:17.784 
事實上我不得不進行
五次計數參數的修改工作

00:15:19.219 --> 00:15:22.289 
好 我們可以使用包裝函式類來操作

00:15:23.423 --> 00:15:25.325 
這裏我再次使用用戶結構

00:15:25.559 --> 00:15:27.694 
但是這次不是隻依靠它自己

00:15:28.028 --> 00:15:29.730 
它包含在一個包裝函式類中

00:15:30.130 --> 00:15:32.966 
我還可以使用類引用來操作這個結構

00:15:33.367 --> 00:15:36.303 
更重要的是如果我把這個
引用當作一個函數

00:15:36.503 --> 00:15:38.305 
或我聲明-或我簽名-

00:15:38.372 --> 00:15:39.806 
用這個引用來初始化一個變量

00:15:39.873 --> 00:15:43.143 
我只是在做一個引用計數增量

00:15:44.478 --> 00:15:46.847 
現在 重要的是要注意到

00:15:47.481 --> 00:15:49.683 
這裏語義有了變化

00:15:50.350 --> 00:15:54.388 
我們已經從使用真值語義

00:15:54.855 --> 00:15:57.191 
改變爲引用語義

00:15:58.358 --> 00:16:02.229 
這樣就會導致意想不到的
數據共享可能會導致

00:16:02.296 --> 00:16:04.798 
不可思議的結果或你沒想到的事情

00:16:06.099 --> 00:16:08.635 
但是有一種方式

00:16:08.702 --> 00:16:13.574 
你可以具有真值語義
並且從這個最優化中受益

00:16:14.608 --> 00:16:15.976 
如果你想了解更多

00:16:16.109 --> 00:16:20.214 
請進入用值類型來構建
更好的應用程序的講座

00:16:20.280 --> 00:16:22.382 
在Swift明天的任務中

00:16:22.449 --> 00:16:24.685 
在下午2:30它將是一場精彩的講座

00:16:24.852 --> 00:16:26.286 
我真的建議你去

00:16:29.690 --> 00:16:32.092 
現在我們已經談論了引用計數

00:16:32.860 --> 00:16:36.663 
我想繼續討論有關通用型的內容

00:16:40.000 --> 00:16:41.802 
這裏我有一個通用函數min

00:16:41.969 --> 00:16:47.274 
它是通過類型T的通用性 符合
Swift標準庫的比較協議

00:16:47.774 --> 00:16:49.476 
從源程序的角度來看

00:16:49.743 --> 00:16:52.412 
這看起來不那麼大
我的意思是它只有三行

00:16:53.146 --> 00:16:57.351 
但是實際上 幕後要比想的多的多

00:16:57.918 --> 00:17:00.721 
例如這裏實際發出的代碼

00:17:00.888 --> 00:17:04.191 
這裏我還是使用僞-Swift
來代表編譯器發出的代碼

00:17:04.992 --> 00:17:09.363 
編譯器發出的代碼不是這三行 而是這

00:17:10.998 --> 00:17:15.068 
首先要注意編譯器在使用間接法
來比較X和Y

00:17:15.502 --> 00:17:18.137 
這是因爲我們可以輸入兩個整數

00:17:18.204 --> 00:17:22.108 
到min函數或者我們
可以輸入兩個浮點數

00:17:22.175 --> 00:17:24.711 
或是兩個字符串或我們可以
輸入任何可比較類型

00:17:24.778 --> 00:17:27.647 
這樣編譯器在所有的情況下都是正確的

00:17:27.714 --> 00:17:29.149 
並且能夠處理它們中的任何一個

00:17:30.117 --> 00:17:32.786 
另外因爲編譯器不知道

00:17:32.986 --> 00:17:35.689 
是否T要求引用計數更改

00:17:35.923 --> 00:17:37.791 
它必須插入另外的間接法

00:17:38.091 --> 00:17:41.595 
這樣min T函數就
能處理兩種類型T

00:17:41.762 --> 00:17:45.832 
要求引用計數和
不要求引用計數的類型T

00:17:46.099 --> 00:17:51.104 
例如 對於整數而言
Swift運行時內僅未進行上行調用

00:17:52.706 --> 00:17:55.909 
在這兩種情況下編譯器都處於保守模式

00:17:56.109 --> 00:18:00.147 
因爲在這種模式下編譯器須能
處理任一T類系統數據

00:18:01.548 --> 00:18:06.019 
幸運的是編譯器優化
能夠幫助我們消除重載

00:18:06.720 --> 00:18:09.790 
編譯器優化也稱爲泛型特殊化

00:18:10.891 --> 00:18:15.229 
本文中的函數foo將兩個整數
傳遞給泛型函數min-T

00:18:15.996 --> 00:18:18.732 
執行泛型特殊化時

00:18:19.066 --> 00:18:21.702 
編譯器首先調用了函數min和foo

00:18:22.336 --> 00:18:25.405 
並且發現兩個整數被傳遞給了
本文中的泛型函數min-T

00:18:26.273 --> 00:18:28.742 
編譯器可以查看

00:18:28.809 --> 00:18:33.313 
泛型函數min-T的定義
因此其能夠克隆函數min-T

00:18:34.081 --> 00:18:36.316 
並且將克隆的函數進行特殊化處理

00:18:36.383 --> 00:18:41.421 
方法是將泛型類型T
替換爲特殊化類型Int

00:18:42.589 --> 00:18:45.158 
隨後針對函數Int優化特殊函數

00:18:45.692 --> 00:18:49.029 
並消除與這個函數相關的所有重載

00:18:49.096 --> 00:18:52.466 
因此這樣會刪除所有引用計數
即不必要的引用計數調用

00:18:52.533 --> 00:18:54.868 
並且我們可以
直接對這兩個整數進行比較

00:18:56.637 --> 00:19:00.040 
最後 編譯器將泛型函數
min-T的調用替換爲

00:19:00.374 --> 00:19:04.077 
特殊函數min Int的調用

00:19:04.311 --> 00:19:06.046 
以便進行進一步的優化

00:19:08.148 --> 00:19:11.752 
泛型特殊化
是一個非常強大的優化方法

00:19:12.452 --> 00:19:18.392 
但其也有一個不足之處 即
泛型定義的可見性

00:19:18.592 --> 00:19:21.628 
這類例子包括本文中函數
min-T的泛型定義

00:19:23.297 --> 00:19:27.167 
這裏我們對包含兩個整數的
泛型函數min-T進行計算

00:19:27.901 --> 00:19:31.772 
在這種情況下我們可以執行
泛型特殊化嗎？

00:19:32.573 --> 00:19:35.475 
即使由於我們分別對文件
1.Swift和文件2.Swift

00:19:35.542 --> 00:19:37.711 
進行編譯編譯器可以看到
兩個整數被傳遞給了

00:19:38.345 --> 00:19:40.414 
泛型函數min-T

00:19:41.048 --> 00:19:44.685 
但當編譯器編譯文件1時

00:19:44.751 --> 00:19:47.521 
文件2中函數的定義

00:19:47.688 --> 00:19:49.957 
對編譯器來說不可見

00:19:50.123 --> 00:19:54.194 
因此當編譯文件1時

00:19:54.361 --> 00:19:57.531 
編譯器不能查看
泛型函數min-T的定義

00:19:57.831 --> 00:20:01.201 
因此我們必須調用泛型函數min-T

00:20:02.870 --> 00:20:06.473 
但是如果我們啓用了全模塊優化
情況會是怎樣的呢？

00:20:07.841 --> 00:20:10.878 
如果我們啓用了全模塊優化

00:20:11.211 --> 00:20:15.549 
就會同時對文件1.Swift和文件
2.Swift進行編譯

00:20:16.049 --> 00:20:19.987 
這意味着當同時編譯文件1或文件2時

00:20:20.053 --> 00:20:22.623 
文件1和文件2中的定義都是可見的

00:20:22.689 --> 00:20:28.061 
所以基本上這就意味着
即使min-T泛型函數在文件2中

00:20:29.062 --> 00:20:32.599 
我們編譯文件1的時候可以看到它

00:20:33.734 --> 00:20:36.703 
因此我們能夠將min-T
泛型函數具體化爲Min int

00:20:36.770 --> 00:20:41.241 
並用min int替換調用
min-T的命令

00:20:42.409 --> 00:20:46.480 
這是能較爲明顯地體現出
模塊優選的整體作用的第二個案例

00:20:47.181 --> 00:20:51.051 
這個案例中編譯器能進行
類屬指明的唯一

00:20:51.118 --> 00:20:54.154 
原因是啓動整個模塊優化時

00:20:54.221 --> 00:20:56.857 
編譯器能得到附加信息

00:21:01.195 --> 00:21:05.465 
既然已經講過了泛型那我想再講講

00:21:05.899 --> 00:21:08.669 
動態調度技術以作總結

00:21:11.572 --> 00:21:14.174 
這裏我有一個寵物類的類層次結構

00:21:15.209 --> 00:21:19.713 
可以注意到寵物類具有
方法噪聲 屬類型

00:21:20.113 --> 00:21:24.051 
以及一個方法噪聲處理法
用以處理方法噪聲

00:21:24.685 --> 00:21:29.590 
還可以注意到寵物類的
一個子類狗類可以覆蓋噪聲

00:21:30.190 --> 00:21:32.526 
現在再考慮產生噪聲的函數

00:21:33.126 --> 00:21:34.528 
這是一個很簡單的函數

00:21:34.661 --> 00:21:37.531 
它帶有一個參數p
這是寵物類的一個特徵

00:21:38.899 --> 00:21:42.803 
即使這個大括號裏牽涉的信源不多

00:21:44.071 --> 00:21:46.573 
但後臺的運行卻比我們想象得要多

00:21:46.874 --> 00:21:51.278 
比如下面的Swift僞碼
並不是編譯器發出的

00:21:51.845 --> 00:21:53.780 
名稱和噪聲不是直接被調用的

00:21:53.881 --> 00:21:56.450 
而是通過編譯器發出代碼

00:21:57.184 --> 00:21:58.952 
注意此處調用

00:21:59.019 --> 00:22:02.256 
名稱getter方法
和方法噪聲的間接性

00:22:02.422 --> 00:22:04.525 
編譯器必須插入這一間接性

00:22:04.825 --> 00:22:08.028 
因爲它不知道在當前的類層次結構下

00:22:08.095 --> 00:22:13.467 
屬類名和方法噪聲是否應該被子類覆蓋

00:22:14.601 --> 00:22:17.304 
這一案例中的編譯器只會發出--

00:22:17.871 --> 00:22:24.545 
如果能夠證明沒有
名稱或者噪聲的子類的覆蓋的話

00:22:24.745 --> 00:22:27.548 
只會發出直接調用命令

00:22:28.782 --> 00:22:32.052 
在噪聲的案例中這恰恰就是我們想要的

00:22:32.452 --> 00:22:35.856 
我們想要噪聲能夠被這個
應用程序編程接口中的子類覆蓋

00:22:36.390 --> 00:22:38.792 
我們想形成這種效果
就是在一個寵物類的案例中真的

00:22:38.892 --> 00:22:42.629 
有子類狗類的話如果我
調用噪聲這隻狗會叫

00:22:43.230 --> 00:22:45.933 
而在一個真正的寵物類的案例中

00:22:46.233 --> 00:22:48.001 
如果我調用噪聲我們會聽到貓叫

00:22:48.235 --> 00:22:49.436 
這完全是合理的

00:22:50.637 --> 00:22:54.641 
但在名稱的案例中
這實際上是不合需要的

00:22:55.342 --> 00:22:56.977 
這是因爲在這個應用程序編程接口中

00:22:57.211 --> 00:23:00.981 
名稱不是...永遠不是被覆蓋的

00:23:01.048 --> 00:23:02.683 
對名稱進行覆蓋是不必要的

00:23:03.217 --> 00:23:06.753 
我們可以通過約束這個應用程序
編程接口的類層次結構來建立模型

00:23:08.188 --> 00:23:10.057 
我今天要向你們介紹

00:23:10.123 --> 00:23:13.627 
可以用來約束你們的API類
層次結構的兩種Swift 語言特徵

00:23:14.027 --> 00:23:15.696 
其一是對繼承的約束

00:23:16.163 --> 00:23:19.533 
其二是通過存取控制約束存取

00:23:20.334 --> 00:23:25.138 
讓我們先談談繼承約束
也就是最後一個關鍵詞

00:23:27.107 --> 00:23:29.476 
當某API包含的一項聲明上

00:23:29.543 --> 00:23:31.044 
有最後一個關鍵詞時

00:23:31.311 --> 00:23:35.749 
該API即傳遞着一個信息
該聲明在任何時候都不會被子類覆寫

00:23:36.850 --> 00:23:38.485 
舉一個聲音製作的例子

00:23:38.986 --> 00:23:42.022 
默認情況下編譯程序一定會採用間接法

00:23:42.456 --> 00:23:44.191 
調用getter 以給出名稱

00:23:44.591 --> 00:23:49.096 
因爲如果沒有更多信息則無法知道

00:23:49.329 --> 00:23:51.231 
名稱是否被子類覆寫

00:23:51.632 --> 00:23:56.036 
但是我們知道在該API中
名稱在任何時候都不會被覆寫

00:23:56.103 --> 00:23:58.472 
我們也知道在該API中

00:23:59.640 --> 00:24:02.042 
並不是要名稱能夠被覆寫

00:24:02.242 --> 00:24:04.811 
那麼我們就可以通過
對名稱附上最後一個關鍵詞

00:24:05.012 --> 00:24:07.514 
對此進行執行和傳達

00:24:08.949 --> 00:24:12.586 
之後編譯程序會看名稱並意識到 哦

00:24:12.653 --> 00:24:14.555 
這個在任何時候都不會被子類覆寫

00:24:14.621 --> 00:24:17.691 
而動態分配即間接法可被刪除

00:24:19.493 --> 00:24:22.863 
既然我們已經講了繼承約束

00:24:22.930 --> 00:24:25.098 
我就要稍微介紹一下存取控制

00:24:26.300 --> 00:24:30.771 
該API中證明pet
和dog均在單獨的文件中

00:24:31.071 --> 00:24:35.042 
即在pet.Swift和dog.Swift中
但是屬於相同的模塊 即模塊A

00:24:35.542 --> 00:24:39.046 
除此之外還有一個
叫做Cat的pet子類

00:24:39.379 --> 00:24:42.182 
它屬於另一個模塊
但是在文件cat.Swift中

00:24:42.583 --> 00:24:43.717 
我要問的問題是

00:24:43.784 --> 00:24:47.487 
編譯程序能夠向noiseimpl
發出直接調用指令嗎？

00:24:49.022 --> 00:24:50.457 
默認情況下不能

00:24:51.158 --> 00:24:53.527 
這是因爲在默認情況下
編譯程序必須假定

00:24:53.594 --> 00:24:56.163 
該API是要noiseimpl

00:24:56.230 --> 00:24:58.899 
在Cat 和Dog
這樣的子類中被覆寫

00:24:59.900 --> 00:25:02.503 
但是我們知道事實上並非如此

00:25:02.803 --> 00:25:06.940 
我們知道noiseimpl是
pet.Swift私有實現詳細信息

00:25:07.374 --> 00:25:11.745 
在pet.swift以外不應可見

00:25:12.713 --> 00:25:16.016 
我們可以通過在noiseimpl上
附上這個私有關鍵詞

00:25:16.250 --> 00:25:17.084 
從而實現該目的

00:25:18.051 --> 00:25:20.454 
一旦我們在noiseimpl上
附上這個私有關鍵詞

00:25:20.521 --> 00:25:23.690 
noiseimpl在
pet.Swift以外不再可見

00:25:24.424 --> 00:25:26.760 
這意味着編譯程序可立即知道

00:25:27.027 --> 00:25:30.397 
在cat或者dog中
不會出現任何覆寫情況

00:25:30.464 --> 00:25:32.999 
因爲它們均不在pet.Swift中

00:25:33.333 --> 00:25:39.006 
並且在pet.Swift中只有
一個執行noiseimpl的分類即Pet

00:25:39.406 --> 00:25:43.177 
此時編譯程序可向noiseimpl
發出直接調用的指令

00:25:44.545 --> 00:25:46.213 
我們已經討論過private

00:25:46.747 --> 00:25:50.984 
下面來討論全模塊優化與
訪問控制間的交互作用

00:25:53.320 --> 00:25:57.157 
Pet類我們已談論很多
接下來我們將談論dog子類

00:25:58.025 --> 00:26:01.195 
謹記Dog類是Pet類的子類

00:26:01.261 --> 00:26:04.865 
它包含內部訪問但不含公共訪問

00:26:05.966 --> 00:26:08.368 
如果我們調用
Dog類中的noise函數

00:26:08.802 --> 00:26:12.105 
沒有更多信息編譯器必須間接嵌入

00:26:12.739 --> 00:26:16.810 
因爲編譯器不知道模A不同文檔中
是否存在Dog子類

00:26:17.911 --> 00:26:20.314 
當全模塊優化生效時

00:26:21.014 --> 00:26:23.450 
編譯器了獲得了模寬的可視度

00:26:23.984 --> 00:26:26.420 
可以看到模型中所有文檔

00:26:27.020 --> 00:26:31.425 
當然編譯器也能看到dog類沒有子類

00:26:31.758 --> 00:26:34.928 
因此編譯器可以直接調用

00:26:34.995 --> 00:26:36.797 
Dog類實例中的noise函數

00:26:37.097 --> 00:26:42.035 
需要特別關注的是
你必須開啓全模型優化模式

00:26:42.536 --> 00:26:44.938 
卻不用改變任何代碼

00:26:45.706 --> 00:26:47.841 
通過給編譯器提供更多的信息

00:26:48.242 --> 00:26:50.878 
使編譯器理解類層次體系

00:26:51.178 --> 00:26:54.214 
更多的信息實現了免費優化

00:26:54.414 --> 00:26:57.084 
卻不增加我的工作量

00:26:59.520 --> 00:27:02.689 
現在讓我們回顧那達夫之前介紹的圖表

00:27:03.490 --> 00:27:10.297 
在面向對象基準測試中

00:27:11.298 --> 00:27:13.800 
爲什麼Swift
比Objective-C快很多？

00:27:16.937 --> 00:27:20.007 
爲什麼Objective-C中

00:27:20.841 --> 00:27:24.878 
的編譯器不能通過
Ob-C信息發送消除動態分配

00:27:25.112 --> 00:27:27.714 
不能通過它進行內聯 不能進行分析

00:27:27.814 --> 00:27:30.217 
編譯器必須假設

00:27:30.350 --> 00:27:32.052 
Ob-C另一側存在信息發送

00:27:32.886 --> 00:27:35.923 
但在Swift中 編譯器有更多信息

00:27:36.223 --> 00:27:39.459 
它可以看到另一側的確定信息

00:27:39.526 --> 00:27:42.162 
能夠消除大量實例中的動態分配

00:27:43.230 --> 00:27:44.998 
這類實例中

00:27:45.399 --> 00:27:47.467 
顯著快速的代碼

00:27:47.734 --> 00:27:49.770 
帶來更多運行結果

00:27:51.638 --> 00:27:55.375 
因此請使用final關鍵字

00:27:55.442 --> 00:27:57.144 
與API's intent進行通訊

00:27:57.678 --> 00:28:00.414 
這有助於編譯器理解你的類層次體系

00:28:01.315 --> 00:28:03.817 
並實現額外優化

00:28:04.017 --> 00:28:07.821 
但是應謹記根據變化情況

00:28:07.888 --> 00:28:09.990 
對現有客戶進行更新

00:28:10.591 --> 00:28:12.993 
並在已發佈版本中試用全模型優化

00:28:13.460 --> 00:28:16.363 
這一工具可以優化編譯器性能

00:28:16.463 --> 00:28:18.465 
比如讓它變得更加強勁和專業化

00:28:18.732 --> 00:28:23.003 
通過讓編譯器能更好得理解
你的應用程序接口中的類繼承體系

00:28:23.303 --> 00:28:25.606 
你不需要做什麼

00:28:25.672 --> 00:28:29.142 
就可以體會到更及時的
動態內存清空的好處

00:28:30.410 --> 00:28:32.713 
現在有請喬來做介紹

00:28:32.980 --> 00:28:35.215 
他將爲你們展示該
如何使用這些技術和工具

00:28:35.282 --> 00:28:37.384 
來讓你們的應用程序

00:28:37.618 --> 00:28:39.386 
獲得更好的性能體驗

00:28:47.828 --> 00:28:48.662 
謝謝你 邁克爾

00:28:48.762 --> 00:28:51.398 
我叫喬是這個工具團隊裏的一名工程師

00:28:51.532 --> 00:28:55.169 
今天我將要給你們演示這一工具
通過一個運行起來有些慢的程序

00:28:55.602 --> 00:28:56.703 
來 讓我們開始吧

00:29:09.049 --> 00:29:11.618 
好 現在我們的快速
應用程序正在緩緩得啓動

00:29:11.685 --> 00:29:14.855 
我要做的就是接着繼續點擊運行按鈕

00:29:14.922 --> 00:29:17.157 
在其下拉列表中選擇Profile

00:29:17.758 --> 00:29:19.426 
這會使我們的應用
在發佈模式下運行

00:29:19.626 --> 00:29:21.328 
然後再以模板選擇器的形式啓動工具

00:29:21.395 --> 00:29:23.063 
以便於我們可以好好的描述一下它

00:29:23.363 --> 00:29:27.067 
鑑於它還在緩緩運行
讓我們從時間分析模板開始

00:29:28.602 --> 00:29:30.304 
在工具界面中只需點擊 錄製

00:29:30.804 --> 00:29:35.075 
當你的應用開始啓動本工具
會自動在後臺開始錄製記錄它的動作

00:29:35.676 --> 00:29:38.612 
在這裏可以看到我們所運行的程序
在我做任何目標操作之前

00:29:38.912 --> 00:29:41.248 
它正以60幀每秒的速率運行

00:29:41.648 --> 00:29:43.450 
一旦我把這些粒子加入屏幕中

00:29:43.550 --> 00:29:45.085 
它們四處擴散 彼此躲避

00:29:45.152 --> 00:29:47.221 
正如我想要的那樣
這時我們的程序運行速度

00:29:47.287 --> 00:29:48.622 
變成了每秒38幀

00:29:48.689 --> 00:29:50.290 
我們失去了接近三分之一的效率

00:29:50.891 --> 00:29:52.226 
現在我們正視這一問題

00:29:52.659 --> 00:29:55.295 
退出原來的應用 回到本工具中

00:29:56.096 --> 00:29:58.098 
讓我們來放大一下以便看清發生了什麼

00:29:58.832 --> 00:30:01.602 
只需要拖動這個 向這邊拖動

00:30:01.802 --> 00:30:05.138 
就可以非常便捷得進入視圖快速跟
蹤模式把你的數據加入水平時間軌

00:30:05.839 --> 00:30:06.807 
然後呢？

00:30:07.307 --> 00:30:10.077 
在跟蹤視圖中可以看到
我們這個應用的CPU使用情況

00:30:10.544 --> 00:30:13.380 
在我做任何操作之前
我們看左邊CPU使用率非常低

00:30:13.747 --> 00:30:16.250 
當我加入這些粒子CPU變得很高

00:30:16.650 --> 00:30:18.752 
你們可以看到通過移動你的鼠標

00:30:18.819 --> 00:30:21.021 
並停懸在這個ruler視圖以內
這些取值是什麼

00:30:21.221 --> 00:30:24.291 
你們可以看到我們先是
大約10%左右沒有做更多

00:30:24.658 --> 00:30:28.328 
隨後大約100%
所以我們的CPU達到飽和

00:30:28.662 --> 00:30:30.597 
爲了提升我們的性能

00:30:30.831 --> 00:30:32.533 
我們需要將目前的工作量減少多少

00:30:33.166 --> 00:30:34.434 
那麼我們正在做哪些工作？

00:30:34.835 --> 00:30:37.237 
下面的該詳細信息面板由此進入

00:30:38.505 --> 00:30:39.840 
所以這是我們所有的線程

00:30:40.240 --> 00:30:41.608 
繼續將此再開啓一點

00:30:41.875 --> 00:30:46.046 
你們可能從調試程序中的Xcode
內側看到起就熟悉這個調用棧

00:30:46.313 --> 00:30:49.816 
Start、calls main、calls NS
application main等等

00:30:49.917 --> 00:30:52.986 
但是Instruments
要告訴你們的是你在該功能內

00:30:53.287 --> 00:30:55.455 
包括其子功能內 要花費多少時間

00:30:55.856 --> 00:30:57.457 
即第一欄的Running Time

00:30:57.558 --> 00:31:01.428 
我們可以看到有11,220毫秒
或者說我們99%的時間

00:31:01.795 --> 00:31:04.531 
花在了NSApplicationMain
或者其調用的程序上

00:31:04.665 --> 00:31:08.135 
第二欄 即Self是從功能本身取
instrument的時間

00:31:08.468 --> 00:31:10.003 
因此不包括其子功能

00:31:10.871 --> 00:31:13.173 
所以我要做的是看看
self數在哪裏變大

00:31:13.407 --> 00:31:15.576 
即該功能實際在哪裏進行大量工作

00:31:16.109 --> 00:31:18.545 
你可以繼續逐一開啓 搜尋

00:31:18.612 --> 00:31:19.680 
但是需要花點時間

00:31:20.447 --> 00:31:22.616 
我們倒是建議你由此向右

00:31:22.816 --> 00:31:24.084 
這樣放大了詳細信息視圖

00:31:24.751 --> 00:31:28.188 
而Instruments將在你的
應用程序中顯示最重的那一個堆棧蹤跡

00:31:28.255 --> 00:31:29.723 
在這裏所取次數最多

00:31:30.190 --> 00:31:33.994 
在此你可以再次看到我們的主線程
用了11,229毫秒

00:31:35.128 --> 00:31:37.998 
從Start開始灰色符號爲系統框架

00:31:38.265 --> 00:31:40.601 
黑色符號如Main是你的代碼

00:31:41.235 --> 00:31:42.936 
我要做的只是向下看這個列表

00:31:43.003 --> 00:31:45.772 
看它是否有大一些的跳躍
即大約此時有我們感興趣的事情發生

00:31:46.573 --> 00:31:49.042 
如果我向下掃過該列表數字慢慢變小

00:31:49.109 --> 00:31:52.012 
但是在我到這裏看到從大約
9000到大約4000的跳躍之前

00:31:52.112 --> 00:31:54.648 
沒有出現大的跳躍

00:31:54.715 --> 00:31:57.551 
那麼那裏有事情發生
我打算繼續進行點擊我的代碼

00:31:58.185 --> 00:32:00.687 
而Instruments
已經自動擴展了左側調用樹

00:32:00.754 --> 00:32:02.389 
這樣你就能看到你剛剛點擊了什麼

00:32:03.557 --> 00:32:04.791 
讓我將此框起來

00:32:06.226 --> 00:32:07.194 
這裏在發生什麼？

00:32:07.828 --> 00:32:09.429 
好,讓我往回來一點

00:32:09.496 --> 00:32:14.168 
這是NSFiretimer調用
驅動我的仿真速率是60幀/s

00:32:14.735 --> 00:32:18.772 
這是我的粒子
Sim.app代理更新程序

00:32:19.106 --> 00:32:20.841 
驅動仿真的Swift程序

00:32:21.441 --> 00:32:25.012 
在它們之間是個
古怪的類似objc的東西

00:32:25.579 --> 00:32:30.817 
這只是個thunk
本質上,它是嵌入式函數的解釋器

00:32:30.884 --> 00:32:34.021 
可以使我的代碼在SWIFT

00:32:34.454 --> 00:32:36.957 
的NSFiretime中
進入Objective-C

00:32:37.291 --> 00:32:38.892 
這就是它的作用 另外我們可以忽略它

00:32:39.560 --> 00:32:43.030 
現在我們看到更新
程序佔有89%系統時間

00:32:43.463 --> 00:32:45.666 
所以我們需要繼續優化這個程序

00:32:46.133 --> 00:32:48.068 
其它東西我不關心

00:32:48.569 --> 00:32:51.905 
接下來我將會把它隱藏起來
專注於這個更新程序

00:32:51.972 --> 00:32:53.574 
通過點擊右邊的這個箭頭

00:32:54.541 --> 00:32:56.109 
你看 這個周圍的東西都隱藏了

00:32:56.543 --> 00:32:59.313 
運行時間已重置爲100%

00:32:59.379 --> 00:33:01.114 
只是幫你做些心理數學

00:33:02.349 --> 00:33:04.151 
仔細看看這個函數做了哪些工作

00:33:04.218 --> 00:33:06.620 
更新Phase Avoid調用
找到最近的鄰居

00:33:07.087 --> 00:33:09.423 
這裏進入到非常有意思的部分了

00:33:09.857 --> 00:33:12.960 
看Swift release
佔用40%系統時間

00:33:13.026 --> 00:33:15.996 
Swift retain
佔用35%系統時間

00:33:16.396 --> 00:33:20.334 
只是這兩個函數 我們就
佔用了3/4的系統時間

00:33:20.400 --> 00:33:22.870 
僅僅是個管理引用計數的更新程序

00:33:23.604 --> 00:33:24.538 
差的遠

00:33:24.638 --> 00:33:26.039 
接下來幹啥？

00:33:26.573 --> 00:33:28.675 
恩 如果我雙擊尋找最近的鄰居程序

00:33:29.676 --> 00:33:31.378 
這調用了那些
retains和release

00:33:31.445 --> 00:33:33.146 
Instruments將顯示源代碼

00:33:33.247 --> 00:33:35.716 
然而Swift是自動引用計數語言

00:33:35.782 --> 00:33:38.552 
所以你不會直接看到
這些release和retain

00:33:39.219 --> 00:33:41.955 
但你能如果你翻到反編譯視圖

00:33:42.623 --> 00:33:43.657 
點擊按鈕

00:33:44.191 --> 00:33:46.693 
Instruments將會顯示
編譯器實際產生的代碼

00:33:46.860 --> 00:33:49.630 
你可以在這找找這裏有很多的調用

00:33:49.997 --> 00:33:52.432 
這個release佔用了23%時間

00:33:52.733 --> 00:33:54.735 
這裏有更多的
retain和release

00:33:54.801 --> 00:33:56.336 
這是另一個release

00:33:56.403 --> 00:33:58.672 
它們到處都是對於這我們該怎麼做？

00:33:59.840 --> 00:34:04.178 
讓我們回到代碼找到粒子文件

00:34:04.311 --> 00:34:05.579 
這是類粒子

00:34:05.646 --> 00:34:07.047 
所以它是一個默認的內部類

00:34:07.381 --> 00:34:09.315 
它符合協作協議

00:34:09.683 --> 00:34:10.516 
好的

00:34:11.251 --> 00:34:15.289 
下面是...這是尋找最近的鄰居程序
之前它會佔用所有的時間

00:34:15.956 --> 00:34:18.225 
現在我知道當更新時間器啓動時

00:34:18.292 --> 00:34:21.795 
代碼會在屏幕上每一個
粒子上去調用尋找最近的鄰居程序

00:34:22.663 --> 00:34:24.831 
那麼這個內部循環開始

00:34:24.898 --> 00:34:26.934 
遍歷屏幕上的每一個粒子

00:34:27.067 --> 00:34:30.404 
這裏我們有一個N2算法

00:34:30.469 --> 00:34:33.806 
循環的工作是產生非常巨量的時間值

00:34:34.440 --> 00:34:37.210 
我們所做的優化工作將有很大作用

00:34:37.844 --> 00:34:38.679 
看，發生了什麼？

00:34:39.012 --> 00:34:40.447 
在我們訪問這些粒子時

00:34:40.514 --> 00:34:43.750 
我們有循環了有一些retain
和release的開銷

00:34:44.418 --> 00:34:47.888 
這是正在調用的屬性getter
這個.ID屬性

00:34:48.255 --> 00:34:49.356 
前面邁克爾說過的

00:34:49.422 --> 00:34:50.690 
既然這是一個內部類

00:34:50.757 --> 00:34:52.226 
這裏應該有一些

00:34:52.292 --> 00:34:54.761 
跨越這些屬性getter的
Swift文件

00:34:54.828 --> 00:34:56.563 
我們執行這些屬性getter

00:34:56.797 --> 00:35:00.100 
的動態調度這些屬性getter
都有retain/release開銷

00:35:00.968 --> 00:35:03.103 
接下來是一個求距離平方的函數調用

00:35:03.604 --> 00:35:06.573 
事實上它有十幾個源代碼行

00:35:06.640 --> 00:35:10.410 
我們再一次去做動態調用程序

00:35:10.744 --> 00:35:13.247 
所有的開銷和retain
 release開銷都一樣

00:35:14.047 --> 00:35:16.083 
對這個代碼我們能做點什麼

00:35:16.350 --> 00:35:18.018 
恩 這是個完整代碼

00:35:18.318 --> 00:35:20.020 
這是我寫的 我完了

00:35:20.087 --> 00:35:23.357 
我的粒子類是完整的 不需要子類

00:35:23.590 --> 00:35:25.559 
我應該通過把這個類標記爲final

00:35:25.626 --> 00:35:28.195 
把我的意圖告訴編譯器

00:35:31.131 --> 00:35:34.601 
就是這麼一點改變讓我們繼續 
再次配置應用 看看

00:35:36.837 --> 00:35:39.339 
現在編譯器能夠編譯這個文件了

00:35:39.406 --> 00:35:41.808 
也知道這個粒子文件

00:35:41.875 --> 00:35:44.444 
沒有其它的子類了 抱歉

00:35:44.878 --> 00:35:48.615 
這意味着它能夠進行其它的優化了

00:35:48.849 --> 00:35:50.517 
可以直接調用這些函數

00:35:50.584 --> 00:35:53.387 
甚至讓它們內部聯結或者其它的優化

00:35:53.620 --> 00:35:55.789 
這可以減少我們之前的開銷

00:35:56.590 --> 00:36:00.260 
打開記錄 這次加載這些粒子

00:36:00.661 --> 00:36:03.497 
看看這次它們以60幀/s的速度運行

00:36:03.564 --> 00:36:06.667 
讓我們回到優化前的每秒20幀

00:36:07.301 --> 00:36:08.235 
不錯

00:36:08.468 --> 00:36:09.903 
然而你可能會猜到

00:36:09.970 --> 00:36:13.540 
第二節是衝突當我們換一個算法

00:36:13.607 --> 00:36:14.942 
現在它們相互衝突了

00:36:15.242 --> 00:36:19.346 
幀速率下降了25%回到了45幀/s

00:36:19.980 --> 00:36:23.083 
我們再次面臨性能問題
回到Instruments

00:36:23.250 --> 00:36:24.918 
看看 發生了什麼

00:36:25.419 --> 00:36:28.488 
我們將把之前做的再做一遍
把這個放大一點

00:36:29.022 --> 00:36:31.825 
點擊Snap Track to Fit
現在怎麼樣？

00:36:32.259 --> 00:36:35.462 
看左邊 這是迴避階段

00:36:35.562 --> 00:36:39.433 
變好了 提升了大約30%到40%

00:36:39.499 --> 00:36:41.602 
這是我們每秒60幀的原因

00:36:42.369 --> 00:36:45.172 
看右邊這是衝突階段

00:36:45.239 --> 00:36:48.475 
現在這會佔有100%的CPU性能

00:36:48.742 --> 00:36:50.277 
幀速率又下來了

00:36:50.978 --> 00:36:54.948 
再做一次剛纔做的事調用數據樹

00:36:55.015 --> 00:36:57.618 
仔細看看這個窗口中有

00:36:57.684 --> 00:36:59.653 
迴避階段的數據運行良好

00:36:59.953 --> 00:37:03.457 
也有衝突數據這是
需要我真正去關註解決的

00:37:04.124 --> 00:37:08.161 
迴避階段的樣本會平滑我們的結果

00:37:08.529 --> 00:37:11.932 
所以我將設置一個時間
過濾器讓我能只看衝突階段

00:37:12.299 --> 00:37:13.567 
很簡單

00:37:13.734 --> 00:37:15.502 
只需要在時間線中點擊和拖拽就行

00:37:16.069 --> 00:37:17.571 
現在我們的細節窗格更新了

00:37:17.638 --> 00:37:19.907 
只顯示我們的衝突階段了

00:37:20.841 --> 00:37:22.476 
現在我們再做一次

00:37:23.310 --> 00:37:24.778 
從頭回到我們的擴展細節視圖

00:37:25.712 --> 00:37:28.782 
向下看這個列表看有跳躍的地方

00:37:29.216 --> 00:37:32.619 
有趣的事情發生了從8000毫秒

00:37:32.686 --> 00:37:33.921 
到2000毫秒

00:37:34.288 --> 00:37:36.623 
所以我去點這裏的衝突檢測類

00:37:37.691 --> 00:37:40.894 
Instruments
再次自動展開了調用樹

00:37:41.628 --> 00:37:43.397 
讓我們看看這裏發生了什麼

00:37:43.530 --> 00:37:48.368 
88%的時間花在了這裏的
運行時間步進程序很好的挖掘點

00:37:48.936 --> 00:37:52.005 
再來一次 點右邊這個關注箭頭

00:37:52.673 --> 00:37:54.575 
現在我們只看運行時間步進程序

00:37:55.309 --> 00:37:56.410 
看看它在做什麼

00:37:57.277 --> 00:37:59.680 
好 25%的時間用在了

00:37:59.746 --> 00:38:02.683 
Swift.array.underscore
返回元素節點這個項目上

00:38:02.816 --> 00:38:05.719 
當你看這個三角括號裏的A時

00:38:05.819 --> 00:38:10.157 
意味之你正在調用函數的
通用格式和所有需要的開銷

00:38:10.791 --> 00:38:15.429 
你會再次在Swift數組的
三角括號裏的A這個位置看到

00:38:15.729 --> 00:38:17.631 
這是個有效的子腳本

00:38:18.031 --> 00:38:20.834 
當你把三角括號換成方括號也是一樣的

00:38:20.901 --> 00:38:23.437 
所以我們正在調用的
是通用屬性getter

00:38:24.104 --> 00:38:26.240 
在這三個通用函數之間

00:38:26.306 --> 00:38:32.112 
我們看到大約50%的時間用在了
這三個通用函數

00:38:32.446 --> 00:38:34.715 
我們怎麼做才能消除這些開銷呢

00:38:35.582 --> 00:38:37.217 
好 回到Xcode

00:38:38.752 --> 00:38:40.320 
這是我的衝突檢測文件

00:38:40.854 --> 00:38:44.591 
這是衝突協議我的粒子會服從這些協議

00:38:45.025 --> 00:38:47.361 
這是通用類 類檢測

00:38:47.661 --> 00:38:50.230 
T類型會符合一個衝突協議

00:38:50.764 --> 00:38:54.801 
它做的是它的衝突數組
這是通用的T類型

00:38:55.435 --> 00:38:58.305 
下面的是我們的運行時間步進程序

00:38:59.072 --> 00:39:00.574 
這是我們開銷的地方

00:39:00.974 --> 00:39:02.276 
這個函數做了什麼

00:39:02.643 --> 00:39:05.779 
恩 它遍歷了我們所有的衝突
從一個數組訪問了一個衝突

00:39:05.846 --> 00:39:09.716 
調用了大量的屬性getter

00:39:10.017 --> 00:39:10.851 
這裏更多

00:39:11.051 --> 00:39:14.488 
這是個內部循環調用
像前面我們做的一樣

00:39:14.555 --> 00:39:16.423 
我們把另一個衝突從數組中拉出來

00:39:16.723 --> 00:39:18.392 
然後是所有的屬性getter

00:39:18.559 --> 00:39:23.630 
我們做了很多的通用操作我們應該
把這些都幹掉我們怎麼做呢？

00:39:24.164 --> 00:39:29.736 
這次你可以看我的衝突檢測類
就在Swift文件裏

00:39:30.103 --> 00:39:36.210 
然而這個用戶在用這個類的App代理

00:39:36.276 --> 00:39:39.479 
程序中這個Swift文件的粒子
它在這個模型的另一部分

00:39:39.847 --> 00:39:42.382 
我們要轉到 Whole 
Module Optimization

00:39:42.716 --> 00:39:45.152 
很簡單點工程

00:39:46.353 --> 00:39:48.222 
在build設置參數中

00:39:48.622 --> 00:39:52.893 
確定是所有的在
build設置參數找到優化

00:39:54.061 --> 00:39:56.997 
這是優化參數那達夫之前演示過的

00:39:57.231 --> 00:40:00.367 
你只要把你的release生成參數
切換到全模型優化

00:40:01.034 --> 00:40:02.135 
現在當我們配置的時候

00:40:02.736 --> 00:40:07.241 
編譯器正在查看所有的文件
創建一個更優的二進制文件

00:40:07.441 --> 00:40:08.642 
但是讓我們看看會發生什麼

00:40:09.276 --> 00:40:11.311 
我們將第三次運行時間分析器

00:40:12.012 --> 00:40:15.749 
開始記錄 60幀/s

00:40:16.149 --> 00:40:19.720 
添加粒子衝突的階段仍在運行
以60幀/s的速率

00:40:19.887 --> 00:40:22.422 
好 我希望這沒什麼變化一直很好

00:40:23.056 --> 00:40:24.892 
然後我們轉到衝突階段

00:40:24.992 --> 00:40:27.661 
現在它仍運行在60幀/s

00:40:28.028 --> 00:40:30.330 
所有的配置只需幾分鐘

00:40:30.397 --> 00:40:31.632 
和一些小的調整

00:40:31.732 --> 00:40:33.500 
我們讓程序變得快多了

00:40:42.709 --> 00:40:44.211 
好的 歸納一下我們今天看到的

00:40:44.578 --> 00:40:47.014 
我們知道Swift是
一種靈活的編程語言

00:40:47.281 --> 00:40:51.652 
使用安全的自動引用計數完成內存管理

00:40:51.952 --> 00:40:53.921 
這些強大的功能讓人

00:40:53.987 --> 00:40:56.423 
愉悅的編寫代碼
雖然這帶來一些額外i的開銷

00:40:56.590 --> 00:40:59.426 
我們想做的是讓你
專注於你的APIs和代碼

00:40:59.493 --> 00:41:01.862 
當你在編寫它們時保持高效思維

00:41:02.296 --> 00:41:04.331 
你怎麼確定額外開銷呢

00:41:04.665 --> 00:41:06.533 
在Instruments
分析你的應用程序

00:41:06.600 --> 00:41:09.102 
在開發代碼的全生命週期裏

00:41:09.469 --> 00:41:11.071 
當你發現問題時都需要這樣做

00:41:11.138 --> 00:41:13.540 
你會更快更準更容易的定位問題的原因

00:41:13.607 --> 00:41:16.076 
尤其是你的APIs發生變化時

00:41:17.811 --> 00:41:22.149 
有些在線文檔當然你可以去
Developer Forums

00:41:22.216 --> 00:41:25.085 
得到Swift問題的答案和解決方案

00:41:26.320 --> 00:41:31.024 
說到解決方案今天3:30在
Mission有一個深度案例分析

00:41:31.091 --> 00:41:35.963 
專門討論時間分析器比
我們今天講的更深入

00:41:36.396 --> 00:41:40.100 
像之前邁克爾提到過的使用Swift
的數值類型可以建立更好的應用

00:41:40.434 --> 00:41:43.937 
如你今天所看到的謝謝你們