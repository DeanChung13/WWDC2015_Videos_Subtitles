下午好
大家好感謝大家能來參加講座
我是泰德·克熱梅內克我在Apple管理Swift團隊
阿萊克斯和我很高興也很榮幸
和大家講講在編譯時使用Swift
來發現編碼的更多問題
這是個相當寬泛的話題 所以我們
所以我們決定主要談兩個問題
首先是利用Swift 2中的新語言術語供給
以便輕鬆允許應用利用新的API
與此同時部署更早的版本
在更早的講座中我們簡要談過這個話題
我們馬上要深入探討設計
方法的理念所解決的問題
以及如何在代碼中實現最佳應用
然後 阿萊克斯會談談如何
使用富類型系統協議和枚舉
甚至還有協議擴展以便在在自己的代碼中
執行應用不變性並定義解決許多應用開發模板
我們先來看第一個話題
利用新API
這類話題已經講了很多遍很多人對此都很熟悉
對Apple而言 我們繼續在
每個OS版本中推出豐富的API
讓大家有機會在應用中構建不錯的功能
對嗎？這是我們這麼做的部分原因 不是嗎？
這裏的謎題是app具備已有用戶 對麼？
他們目前...
他們不必使用最新的OS
在iOS 有較快的使用率
但是這不是說人人都會立刻採用
還有些人出於各種原因完全不會使用
那麼你會面臨一系列選擇你會怎麼做呢？
你是否會繼續
並要求app使用最新OS？
好 那你獲得所有的新API 可這的確成問題
因爲你會搞砸
要知道 你會損失用戶
這些是會購買你的app的人羣
你是否應該走到相反的極端
控制使用新API？
這樣就會獲得所支持的
最早版本OS的最小公分母
這樣做很糟糕因爲你會影響到
原本可以向用戶提供的豐富
功能
當然 要知道有魚和熊掌兼得的辦法
可以採用新API與此同時還
可以部署更早的版本
所以很長時間以來 我們在技術上
都支持這種做法
當然 可以在Objective-C和Swift中均可如此
可是現實中 如今這是個非常
痛苦的體驗
在Swift 2中 我們儘可能不讓它這麼痛苦
我們通過開發人員告知的當前問題
關於部署較早版本
並設法解決語言中的問題
來實現這一點
現在基本模型並未改變 對吧？
對於開發而言在我們的平臺上
一直希望大家使用最新SDK
對嗎？這會導致應用中所有可能
用到的API都混到了
一起
然後 可以切換app的部署目標
說明你想要退回的時間
從畫面來看這樣就非常簡單
就像是版本的滑動視窗
設置最新的基底SDK
把部署目標設置到視窗的
最早版本 對麼？
從概念來講 很簡單
那麼在談到在Swift 2中 
如何採用新功能和API之前我們先來看
現有方法中的問題
基本上而言 你必須編寫app
以便應對更早版本的主OS中API缺失的問題 對嗎？
還有幾個問題需要單獨考慮
整個框架的缺失類方法 
函數 甚至部分枚舉值
在更早的版本中不得使用
但是令人煩心的是你必須逐一
解釋所有這些問題
對框架而言很是麻煩 要決定
我把它連接到應用時 這個
框架是可選項
如果不這樣做app就會在啓動
較早版本的OS時 出現問題
然後是API本身實際運用
我們先來看類
基本上來說你是在編寫app
因此它會有不同表現
這將是有條件的行爲
例如當新的API可用app就會做些不同的事情
因此條件邏輯並不是問題
問題在於怎樣爲行爲實現條件化
在這張幻燈片上是用來檢測可用性的
典型方法
你來查詢Objective-C的運行時間
這個類會在運行時間出現麼？
問題是這有點謊言的味道
對嗎？我是說類可以有
但是這不意味着你可以使用
API會經常開始是內部API 
在OS中 
它們會在生成和演進的地方呆上一陣在對外發布時
API的行爲
可能已經完全改變
即便這樣的檢測在運行時間成功了
這也不能說明實際使用
這款API時會絕對安全
而是說 如果在OS版本上你使用的時間太過於早 
基本上會在應用中加上定時炸彈
原本你以爲API會按照一定方式表現 現在會完全遭到破壞
這會令開發人員多次受到打擊
因此是個嚴重問題
另一個問題是太容易出錯
來看這個新款API
通過幾項特色功能
我的代碼完全有效結果卻出了差錯
數據在NS數據資產之前很久引入的
代碼還會編譯 若在最新的OS上檢測
它甚至會成功運行
那麼只是在更早版本的設備上
運行代碼 纔會出現問題
對嗎？這與通常的測試場景完全不符
在部分情況下
只需要用戶來發現這個問題
即將出現的情況是當你試圖使用這個類時運行時間會崩潰
很容易因爲簡單的小錯出現問題
方法和類的問題基本一樣
可能會出現輸入錯誤
如果檢測屬性的可用性
你現在必須瞭解屬性的選擇器
同時還要拼寫正確
此外語法也完全不同 對嗎？
來檢測API但是語法不一樣
函數也有着同樣問題
你會犯同樣的錯誤不過可以有
其他方式來編寫
那麼 如果有枚舉那你就被完全騙到了
你不知道 怎樣的解決方案才合適
選擇器對映射完全沒有反應
那就要手動OS版本檢測
來看這個表格感覺就像是你希望
改正的所有簿記問題
都在這裏
這是個非常傷感的故事
現在我們看到的是的確成問題的
編程模型
對嗎？技術上可行但是很難做到
我們希望你利用新款API
與此同時繼續支持所有的用戶
我們需要解決這些問題
在Swift 2中情況有所改變
把改變構建在語言當中
要以怎樣架構app爲主 那麼
有其他方法可行時可以考慮
使用這些API
你理解 會有條件性行爲
但是你會主要關注於此
然後有編譯器作爲支持
如果用不安全的方式使用API 就會出現錯誤
還要有統一的句法這樣就不必考慮
類 方法函數甚至映射問題
這些都在所用的句法中處理好了
編譯器瞭解你該用的句法
如果你沒有做對 它會告訴你正確做法
因爲編譯器會一直參與其中
在Swift中我們使用模型
所有可選鏈接可以幫你來處理
那麼這樣效果如何這裏是來自核心位置的部分API
比如說 我在部署iOS 9
因此使iOS 9 SDK
並設置iOS 9的部署目標
編譯器可以在SDK中看到該信息
因此這是在Objective-C頭文件中
還可以作爲Swift中生成的界面來查看
因此類被引入iOS 2中
方法稍後會引入iOS 8
因爲我在運行iOS 9
可以無條件使用這款API
如果我在iOS 8部署也仍然沒有問題
但是如果我一路退回iOS 7 
編譯器可以看到正如我們可以在幻燈片上看到
使用這種方法並不安全
需要請求使用授權
編譯器會告訴你這是不安全代碼
是錯誤
它會禁止你構建這個代碼
並會提供不錯的安全性檢測
它會提供可以解決
這一問題的不同方法
這裏有註解 你是否需要安全檢測？
會有附上的解決辦法 如果接受
代碼就重寫 像這樣
現在有彙編組合靜態執行
和運行時間執行
這就是散列可用句法
基本上 編譯器掃描可以看到代碼塊中的
所有內容最新的iOS OS X或安全執行這些API
所需的具體版本
是什麼？
然後會使用在散列可用的
所提到版本進行適當的運行時間檢測
編譯器會把它插入其中
你不必猜測如何完成 會高效完成
並做緩存這樣就可以安全使用
在SDK中使用該信息
會實現高保真因此會得到真正安全的模式
有些人會問
爲什麼要在OS版本中進行檢測呢
不是提供過對以往內容
所做的指南麼？
原因是做簿記實在太難
至少當你查詢運行時間時 
你會得到部分真相 但是在很多情況下即便是真相也會有出入
邏輯上來講 和app開發人員交談
要知道 你希望構建在app上的體驗
都發起在用戶正在
運行的主OS上 對麼？
在每個OS版本中都有一批新的API
這些基本上定義了你可以執行的
各種功能而用戶在使用
不同版本的OS 因此 他們在邏輯上
打破了你的app所具備的
行爲類別 對麼？
所有這些在邏輯一致性上都有區別
同樣 它也不會檢測某款API的存在
因爲你通常準備同時使用若干API
這其實說不過
某款API的存在並非表明其他
也會存在
信息位於SDK中編譯器可以爲你
完成簿記工作
編譯器涉及到真正的規則改變者
它使得可用性檢測非常可靠
可以假設編譯器在做着正確的事情
你儘可放心是在
通過定義解決整類問題
因爲你在用編譯執行
而且自然會進入多個平臺
比如 我之前有這個NSData資產實例
如果我想讓代碼以OS X和iOS爲目標
我可以簡單擴展句法稱我也在
其他平臺檢測其最小可用性
星級表明基本上在所有其他情況下
在本例中應該是Watch OS
我們把它放在那裏顯性調用
潛在的流程控制
對於其他沒有明顯提及的平臺
會執行指定條件
基本上是真和假
我們本想調用這些分支
它們仍將被採用
因此 我們想顯性調用
可讀性行爲
現在可讀性檢測會在Swift 2中
自然構成用於控制流的可供性
比如 你之前已經構建了app 希望
進行這類檢測 然後執行部分功能
否則什麼都不做只要擺脫困境即可
這與新的保安聲明相結合
可以像這樣調整編碼
保安聲明下面的的所有內容
都有散列可用標籤提供的
可用性
因此自然會找到方法
來構成應用的因素
比如 你之前已經在iOS 7上做過部署
我會把iOS 7中可用的API代碼染成綠色
綠色條代表代碼塊中
可以安全使用iOS 7或更早版本
因此這基本上是編譯器
對世界的看法
如果我想用iOS 8 API我已經把它的代碼
塗成橙色 你需要對它進行可用性檢測
否則 你會從編譯器收到一個錯誤
你可以認爲在代碼塊中
你有特權
決定什麼API可以調用
一旦我出了代碼塊特權就不復存在
就只能調用iOS 7 API
如果我想調用iOS 9 API我可以進行不同的檢測
這會在代碼塊中提供不同範圍的特權
它是極具可組合能力和可讀性的模型
比如 我在根據
部分API是否可用構建
具備整套不同功能的app
我想對此進行分解
我不是隻把一束代碼加入條件語句
我希望把它分解放入不同的函數中
這很容易做到
可以聲明另一個函數
比如出於教學目的我的函數使用iOS 8
我準備從條件代碼塊中調用
問題在於編譯器不知道
你要做什麼要知道
只有完成檢測才能調用這個
在默認狀態下編譯器會確認
你鎖定iOS 7
我假設你在這個函數中 只使用
iOS 7 API
如果你想用iOS 8API那麼就要進行檢測
這不太好 對吧？
這裏並未提供方法來真正分析app
還會導致冗餘檢測
你可以告知編譯器你的意圖
這樣SDK本身會有這些方法和類的
添加可用適應
稱這是可以用於API的最小OS
在自己的代碼上也可以使用同樣的註解
表示除非已經進行過適當的
可用性檢測否則不得調用該函數
一旦出現這種情況
編譯器會以不同方式看待代碼
然後可以完全刪除檢測
即額外的可用性檢測安全使用iOS 8 API
這可以組合使用
因爲其他函數也有相似註解
如果函數有着相同的API特權 
可以直接調用它們
如果在進行可用性檢測時
想通過更多特權調用API
那麼這樣很方便構成 很容易理解
代碼的構成方法
如大家的預期這也適用於方法
這樣可以標註類爲可用
但是具體方法 也許不可用
如果需要 你可以在調用更可用的
具體方法前 舉例說明該類
你需要進行檢測
在要求最小的可用性時 如果想標識
整個類的話這樣會奏效 
如果這樣做 除非進行過可用性檢測
否則甚至連舉例說明類都不可能
那你會獲得API可用性
完整的全部傳遞閉包
這會自然引發 可以使用的更多技巧
比如 你已有較早版本中的自定義模糊視圖 
Apple會推出更具體的UI視圖子類 
你想使用新版本
在主OS上使用它們
你想通過可用性保護實現這類
運行時間多態 那麼如果你在
運行OS 要使用原生UI
否則就要使用自定義的
這樣獲得對象的客戶端
並不需要在乎你運行的OS版本
到底是哪個
你已經完全提供了關注點的分離
當用到協議做同樣的事情
效果會很好可提供不同的執行
可以有閉包不同的函數
可以實現完全不同的新方法分析代碼
並獲得你所期待的安全性
我們覺得可用性檢測相當棒
我覺得它的確提供了具有凝結力
的安全方法來使用新款API並部署到更早版本
統一的句法提供了真正安全的編程模型
但是更重要的是它提供了正常分析app的方法
你可以閱讀app
可以閱讀代碼並理解
可以期待不變性
我覺得這一點 非常強大
接下來我把講臺交給阿萊克斯
他來介紹使用Swift強大類型系統的其他方法
以便在自己的應用中執行不變性
謝謝 泰德
大家好我是阿萊克斯•米基科夫斯基
是Apple的示例編碼員
在過去的一年半時間
我都在教開發人員如何用Swift編寫Cocoa app
我對於Swift和Cocoa有着清晰的夢想
怎樣才能讓二者在一起實現安全的
編譯時間 安全應用
今天我想介紹我已有部分想法 
並解釋大家可以從中使用的
部分範例並把這些概念
運用到各自的應用當中
這樣你也可以編譯時間安全代碼
現在我還沒有告知大家 但是在這些想法中
我還想到了獨角獸
我開發了獨角獸app來看一下
我設想的不同獨角獸
首先 我想介紹我應用中的
Asset Catalog 標識符
每個人都在UIKit中用到它
我的獨角獸瀏覽app相對簡單
在Asset Catalog中我已經加入3個獨角獸圖像
我現在想看看當我從Asset Catalog生成圖像
代碼會是什麼樣
你會注意到
我在搭建的3個圖像
每個圖像我都向UIKit UI
圖像API傳遞一個字符串
不知道Asset Catalog UIKit實際上提供了怎樣的資產
所以我必須打開這些圖像
才能在應用中使用它們
非常不巧
因爲已在Asset Catalog定義Asset Catalog標識
我不希望這裏出現重複信息
此外 這裏我只會使用3個圖像
可是在整個應用中我會用到許許多多
問題是很難找到你的代碼中
是否有輸入錯誤幻燈片上是
這些錯誤會引發的反應
基於這些 你可能會希望進行修改我明白
但是確實很難回去把它們都找出來
那麼經典的解決方案應該是有個
全局常數
這樣可以在應用的各個地方使用
同樣的常數
如果使用正確那就可以把獨角獸
圖像按照你的想法再找回來
但還是要打開圖像 因爲編譯器
不清楚框架也不知道
你是否會
提供有效的常數名稱
此外 可以提供隨機的爲API提供隨機流
運行時間會出現致命錯誤
因爲NSUbiquity身份改變節點
通知還是字符串可以有效傳遞至
UI圖像指定API
我們來看看怎樣解決這個問題
我們要做的是嚴格的類型解決方案
我們在代碼中將字符串傳遞到各處
我們希望的是強大的類型解決方案
希望可以將字符串映射到
新的類型
這會讓我們編碼解決
怎樣搭建應用至
編輯器的信息
這樣可以把非選擇性UI圖像
返回到代碼的各處
解決方案就是
針對應用進行枚舉
我們在應用中定義的枚舉
如果來看之前定義的代碼
我不希望代碼是這幅樣子
我想每次生成UI圖像對象都傳遞枚舉
這樣我就不必
在代碼中打開返回值
怎麼實現呢？
首先我希望
定義UI圖像的嵌套類型 以便在
枚舉大小寫和Asset Catalog中
定義的字符串表達之間提供
映射
我們將之定義爲嵌套類型
這樣可以存儲在AssetCatalog的其他資產
也可以使用這種方法
一旦這麼做就非常簡單
我可以在枚舉大小寫和字符串表達之間
提供大小寫映射
對所有其他的情況也可以這樣
這種方法的真正好處在於
如果我不小心有輸入錯誤 如果
我不小心從什麼地方複製粘貼了字符串
出現了重複編譯器就會
警告或者報錯 告訴我
在枚舉中出現了重複問題
編譯器可以這樣幫忙 實在太好了
現在我們已經定義了新類型
我所需要做的就是返回再編寫便利初始化函數
其中使用這個枚舉而不是字符串
並將枚舉的原始值轉至UIKit
定義的UI圖像命名初始化函數
如果我們回來再看代碼
可以把獨角獸放在所希望的任何地方
如果我們再來看像以前那樣出現輸入錯誤會怎樣
現在編譯器可以告知出現了輸入錯誤
因爲我們已經把應用結構的
信息編入了代碼之中
如果修復這個問題編譯器錯誤也不復存在
我們來談談這麼做的好處
首先是我們的常數位於中心
如果將新的圖像加入Asset Catalog
我準確知道該在哪裏添加圖像常數
還有一個好處是這樣做不會污染
全局命名空間
我可以有在Asset Catalog中定義的若干對象
可以在其中運用這個辦法
最好的一點是 當構建UI圖像對象時
在應用中可以只用這些
枚舉情況中的一種
所以編譯器可以幫你實現這點
現在你可以將非選擇性圖像返回到
代碼中的任何地方 因此不必擔心
強行打開的問題
這是我們在獨角獸瀏覽器app中所用的非常
獨特的方式但我希望你們想想
怎樣在自己的代碼中使用枚舉
以提供其他種類的富映射
你們可以不只是作爲字符串使用
還可以使用整數甚至是選擇器
有很多機會
在自己的代碼中定義這些映射
現在來深入探討枚舉 但是我想
先說說聯線標識符
因爲在代碼中始終要
使用到它
現在 我的想法越發強烈
我必須研製出一款app 讓我真正跟蹤
獨角獸 並在運行中下載它們
我有更復雜的應用
如果來看故事板
就會變得非常簡單
我只有單獨的視圖控制器 可以
聯線其他兩個視圖控制器
對於所有這些視圖控制器而言
我定義了一個聯線標識符
我需要看看當我們覆蓋
聯線準備來配置獨角獸瀏覽器
視圖將呈現的
視圖控制器時 代碼會是什麼樣
我們覆蓋了這種方法 執行這一點的
經典辦法是打開
聯線標識符字符串
現在 在我使用完全相同的字符串之前
我是按照故事板中的聯線定義的字符串
編輯器對此還一無所知
當我只打開這兩個字符串時
編譯器會告訴我
這並非是窮盡性檢測
我必須加入默認情況因爲編譯器不知道
我已經提供了有效映射
但是如果我加入了新的視圖控制器
必須有個全新的聯線 那會怎樣？
我怎麼才能知道在代碼中
哪裏需要改變 這個邏輯？
我們來看看再次通過枚舉
該怎麼解決這個問題
我定義了獨角獸瀏覽器視圖控制器的嵌套類型
它將代表聯線標識符的情況
和故事板字符串表達
之間的映射
我們來看 怎麼實現用更強大的類型
聯線方法準備
首先 我要做的是
從故事板聯線對象抓取聯線
標識符字符串
並從原始值中構建聯線
識別符枚舉
我還會提供部分運行時間
檢測調試以防我並未
爲新的聯線識別符 提供有效的
枚舉情況
從這裏 我可以打開枚舉 而不是字符串
這非常棒 因爲我必須打開
兩種情況 編譯器知道我在枚舉中
只定義了兩種情況所以我必須在代碼中打開
如果我們在枚舉中添加了新的聯線標識符
編譯器就會告知 我們並未
進行窮盡性轉換以便我們在枚舉中
打開的代碼各處
編譯器就會告訴我們
在哪裏更新邏輯
這對字符串解決方案來說是個極大的好處
我們可以這樣重寫聯線準備
但是 有時需要通過標識符 
人工啓動執行聯線
在本例中 我想要引入一束獨角獸
下載它們在Web上 下載圖像
顯示新的視圖控制器
我們來看看 這些代碼是什麼樣子
那麼經典的解決方案是將字符串
傳遞至帶有標識符方式的執行聯線
我們已經定義了這種枚舉
我們只是想使用已經提供的
這種映射
相反 我們想用枚舉
怎麼做呢？
其實 非常簡單
我們可以通過標識符方法定義UIKit定義執行聯線
的過載其中採用了枚舉而不是字符串
然後用枚舉的原始值調用UIKit 定義方法
如果我們返回用枚舉調用
方法的代碼它完全是按照我們的預期運轉
這就是針對獨角獸瀏覽器視圖
控制器的絕佳解決方案
但是如果再複雜一點會怎樣？
我希望看看我們剛纔做的結構
看怎樣才能把它應用到
獨角獸瀏覽器以外的視圖控制器
我們做的是在枚舉情況
及其故事板上的字符串表達之間
提供映射
我們還增加了使用該映射的
執行 以便獲得應用中
更強大的類型系統
但如果我們增添新的視圖控制器
我們希望做同樣的事情
需要不得不復制所有那些工作我不希望這麼做
我真正想做的是從視圖控制器提取
執行 並定義鬆散映射因爲聯線標識符的枚舉
會具體針對視圖控制器
通過這樣做 我們可以爲多種
視圖控制器使用該執行
不論其類層次如何
通過重複使用這個執行可以避免許多
糟糕的類層次
我們會通過協議 來實現這一點
所以我定義了一個新的協議
我們會稱之爲聯線處理類型
我們的視圖控制器需要與它
相一致
我希望定義剛提到的映射
現在它將成爲聯線標識符枚舉
我們希望確保聯線標識符和
原始可顯示協議相一致
這個協議是個關於各類型支持的
枚舉的重要執行細節
編譯器可以自動爲你合成
關於協議定義就是這些
我現在需要用Swift 2.0的功能
受限制的協議擴展
來實際添加將成爲我們的
泛性可重用代碼的執行
我們將擴展聯線處理類型
接下來我們對之加以限制
如果這些限制條件滿足的話 我們只想讓執行
加入其中
第一個限制條件是滿足協議的類型爲
UI視圖控制器子類
這將會讓我們在協議擴展中
調用UI視圖
控制器方法
第二點是我們想確定
聯線標識符映射是位於
映射情況和字符串之間
我們已經定義了有限制條件的協議擴展
我們所需要做的就是添加執行
我們要通過之前定義的標識符 
採用聯線現有執行 
並將完全相同的執行加入代碼
如果我們返回獨角獸瀏覽器視圖控制器
我們只需在新類型中加入一致性
我們已經滿足了協議的所有相關類型限制條件
因爲我們已經識別了這個聯線
標識符枚舉
如果我們進入處理行爲方法 我們可以
用完全相同的方式調用代碼 但我們在聯線處理類型中重用執行
我們可以這樣通過標識符方式
重用表現聯線但是要是調用聯線準備
或聯線處理準備會怎樣？
我需要定義便捷方式
其中會採用故事板對象
並返回聯線標識符枚舉
這是在協議擴展中完成
我要再次做的是使用之前定義的執行
返回我們用代碼
生成的聯線標識符枚舉
如果來看爲聯線方式所做準備
結果就變得非常簡單
我們所需要做的就是通過聯線的
聯線識別符 打開結果返回這是我們剛定義的方法我們只需要提供
兩種情況打開方法和之前的完全相同
但是我們有這個泛型解決方案
我們來談談這麼做的好處
當我們將之添加到 聯線標識符枚舉中時
編譯器完全瞭解我們在故事板上
定義的聯線
可以確保我們在代碼中
處理了所有可能的情況
通過使用協議擴展我們具有可重新使用的解決方案
我們可以在符合新協議的任何視圖
控制器上使用這個執行
我們還有便捷句法
可以在不同的
視圖控制器上使用方法句法
不一定必須是 自由函數
這是在獨角獸瀏覽器app中可以使用協議和
有限制方式的協議擴展的 
獨特方式但是大家都有許多其他有趣應用
我想讓大家做的是思考一下
怎樣在自己的應用中使用協議和
相關類型限制條件來編碼部分
應用的結構到編譯器這樣它可以幫你
實現編譯時間安全性
我想讓你們想想
怎樣使用協議擴展
在自己的應用中分享執行
避免一系列糟糕的類層次問題
泰德和我今天說得夠多了但是希望大家從中領會到
編譯器是來幫助大家的
泰德說的是如何在新API中安全利用這一點
現在 這可以通過編譯器大部分完成
編譯器知道有什麼這不是具體針對
哪個OS的版本
我和大家介紹的是應用的強大類型
強迫應用實現不變性
並利用編譯器
讓它知道應用的限制條件
並把這些信息編入代碼
這樣編譯器可以幫你分析
編譯時間的問題而不是在運行時間
若要了解更多詳情
建議大家在線觀看《基於協議的Swift編程》
講座 如果你自己對Cocoa和Swift
有明晰的夢想建議你仔細看看這兩個示例
編目示例有聯線處理類型協議的實例
DemoBots使用了
在協議中使用枚舉的一系列有趣方法
實現編譯時間安全性
若要了解更多詳情可以查看
Swift LanguageDocumentation
我們還有開發人員論壇如有任何問題 
你們也可以聯繫斯特凡
感謝大家希望能在實驗室見到大家