大家好
我的名字是布蕾特妮·佩因
接下來你們將和喬恩·德拉蒙德見面
我們是SpringBoard團隊的工程師
今天我們主要想和你們聊聊怎麼調整你的app 
以運用iPad和iOS 9上多任務處理功能
這是多任務處理系列中的第三個講座
很可惜前面兩個已經結束了
如果你們還沒來得及收看的話 應該去看一下
那麼我今天有很多話要說喬恩也是
我們會講得很快
請注意聽
所以這就是你的app
在iOS 8中你的app 支配了你的整臺儀器
它可以儘量使用儀器上所應許的系統資源分量
但在iOS 9中多任務處理已經不再像往常一樣了
它可以也可能在同一個屏幕裏出現更多的app
而在所有屏幕上的app現在必須共享同一個系統資源
像是CPU GPU DISKI/O之類的一些系統資源
隨着多個程序互相爭奪CPU的容量而退化
讓我們以CPU爲例子
現在這個是爲了我們講座上的新開發者們
app響應性的Holy Grail在於能夠將你的UI更新於
每秒顯示幀數爲60幀或者60幀率
這意味着你只需大概16毫秒
來完成你所有需要的工作並對用戶作出反應
所以如果這是你的app
比如說它在60 幀率上渲染得很好
它可以在僅僅十秒內將所有工作完成
這其中的每一幀代表一毫秒
之後 用戶將增加另一個附帶的app
-這個app同樣在60幀率上更新得很好
而且它在6毫秒內完成所有的工作
兩個app結合在一起像你看到的 已經用了
我們所擁有的全部16毫秒
以能夠在60幀率上渲染
此時用戶打開一個PIP
而這個PiP也同樣運行得很好
之後他需要八毫秒來渲染他的UI
這三個apps結合在一起
在屏幕上24毫秒 而這意味着
渲染過程其實是大概在40FIPS而不是
我們想要的60 FIPS
用戶會意識到卡頓
同樣的問題也適用於GPU
但一些系統資源比如內存會產生
一個更加不好的用戶體驗
當很多程序一起爭取它的容量時
我們再來看一下這個例子
還是這個app
這個iPad下的系統內存佔用
你可以看到在最左邊 我們的系統正在使用用一些檔案儲存
在中間這是你的app藍色的app
也在使用一些檔案儲存
然後這些剩餘空間
這裏有很多使用空間
你可以做各種各樣的事情
之後 用戶增加了一個二級app
而這個附帶app也需要內存
但我們狀態依然很好
我們還有一點點剩餘儲存空間
然後猜猜接下來會發生什麼
PiP出現了
現在我們沒有記憶體了
當系統無法找到空間記憶體時
它必須停止一個app運行
在這種情況下用戶被活生生地從他/她 
可以說是她的當前處境中拉出來
然後我們又把它帶回到SpringBoard
在我看來這是一個更糟糕的用戶體驗
相比之下和當多個程序爲CPU或者GPU競爭UI將停頓
所以你現在可能在問自己SpringBoard是什麼
以及爲什麼SpringBoard工程師今天會在這裏和你談多任務處理
其實SpringBoard代表很多東西
它是主屏幕
鎖屏
圖標 壁紙 姿態系統 通知中心
控制中心
我有點兒混亂了
好吧 除此之外還有更多
但是最重要的一點如同所有人我們是一個UI應用程序
SpringBoard最初是多任務處理app
在iOS 9和iOS 9之前
SpringBoard 一直被認爲在前臺操作
即使你的app可能被用戶看到
因此 我們面對和你們一樣關於新多任務處理環境中的挑戰
應此我們一路走來學到了很多
我們想和你們分享其中一些學到的內容這樣你們就不會犯同樣的錯誤
我們開始吧
最簡單的第一部分是優化你的app
第一件事用泄露工序找到並修復電腦的內存泄露問題
你們當中有多少人忘記寫DIALEK了
應該有更多的人舉手
好吧 我忘了
發生在我們大多數人身上
而泄露工具可以幫助你找到這些問題
然而它們通常很容易被修復
但防止內存泄露問題的最好方式是用Swift
你們應該用那個
最後 你應該用定位工具來尋找
並修復保留週期和無限內存增長
最後 你應該用實時分析工具來尋找
和修復低效的電腦算法
我不會在今天討論這些問題
這些問題都會發生在所有的apps不僅是
多任務處理的apps而已
反之 我們會注重於
新的多任務處理環境中最重要的事情
在我們的經驗裏我們學到最深的一課是
良好的表現需要權衡
你是打算預期計算你的數據然後存在記憶體裏
還是打算聯機計算並使用CPU
你是打算把所有資源都存在本地的磁盤裏
還是把它們存在cloud裏然後想用的時候隨時都可以取得
你想要在CPU還是GPU上運行動畫
我們來看一個關於我們之前做過的一個
叫IconReel樣本app的例子
所以這是我們app最開始的狀態
它最初有很多圖標
當用戶點擊某圖標時 我們將圖標放大
來呈現一個更詳細的視圖
底部有一個dock欄
用戶可以在這裏保存他們 喜歡的圖標
當一個用戶添加更多的圖標時我們會添加更多的頁面
這時用戶可以頁面之間滑動
有人覺得這個很眼熟嗎
是的 是故意的
所以 我們可以保留所有的圖標
內存中是因爲每個圖標僅爲約60KB
我們會將它們全部存在一個擴展裏面
結果就是滑動很棒
爲什麼呢 因爲我們沒有其它可以滑動的屏幕
所以我們部分用戶喜歡添加更多的圖標
所以我們向記憶體中添加更多的圖標
目前爲止滑動還是可以的
那麼 這個動畫可能看起來眼熟
那是因爲有很多apps 
有像這樣的一個動畫
想一下在一個照片或開發視頻app中的照片滑動
你的app裏也許有一個類似的動畫
一切都很好
一些我們很好的用戶甚至下載了
更多圖標
我們現在的擴展裏有更多的圖標
且結果是滑動依然很完美
也就是說 直到我們在某時看到IconReel死機
以及在一個多任務處理環境下我們有時能看到彼此的
前臺apps死機
我們來看一看這裏發生了什麼
我們用一個實時分析器追蹤看到CPU
和磁盤I/O在滑動時最小化了
但定位工具告訴我們我們的記憶體使用
其實是非常高的因爲我們所有圖標都在記憶體裏
這裏的情況是IconReel在快速地消耗可用的系統記憶體
而當系統內存短缺時
它試圖釋放一些空間
如果它找不到任何空間那麼它必須終止程序
有時這意味會終止IconReel
而有的時候這意味着終止其它前臺app
但上述所有的情況都是一個非常糟糕的用戶體驗
我們想避免這個情況
作爲一個良好的多任務管理公民IconReel需要
管理好它的記憶體使用這樣的話所有
屏幕上的apps可以共存並創造很好的用戶體驗
這也是我們用戶所期望的
這就將我們帶到了工作集的概念上來
你可以做的最重要的一件
優化你記憶體使用的事就是理解
並管理你的工作集
你的工作集應該只由重要的東西
和你的app目前所需資源組成
你應該讓它保持小一些
來確保你的低記憶體使用
它有可能會根據環境變化
比如 你的工作集可能包含不同對象
當一個在前臺的app
和一個在後臺的app相比它可以改變
當你改變視圖控制器時
最後 你不應該讓其無限增長
我們看過當系統沒有記憶體時候的情況
我們不想你成爲那個app
讓我們看一下IconReel的工作集
在最後一個例子的尾端
IconReel的工作集就是我們在記憶體中保留的那個圖標
這是最好的工作集嗎
不是
那麼我們現在真正需要做什麼
現在我們真正需要的是用戶正在看的圖標屏幕
所以這是一個更優秀的工作集
那麼現在我們來試一下滑動我們
只有一頁圖標的工作集
噢 噢 好吧
這太糟了
而且如果你因爲我站着擋住了你沒有看到
那個滑動十分糟糕
有一個多秒的停留在
滑到下一頁看到圖標時
我們來看看發生了什麼
我們用另外一個實時分析器
然後我們看到CPU而磁盤I/O 事實上在滑動中非常高
而分配顯示我們的記憶體使用非常低
這個恰恰是我們剛剛發生相反的問題
就像我說的良好的運行包括進行一系列的權衡
我們如何能修復這個
答案是更好的管理我們CPU的時間
所以你能做的最重要的事
就是能夠讓你的app反應做的工作
在你的主流程上越少越好
主流程最優先的事情就是對用戶時間做出反應
在你的主流程上做不必要的工作意味着
主流程有更少的時間來響應用戶事件
因爲你在分享CPU時間給所有的apps
在屏幕上你需要特別謹慎
應對你的主線程在幹什麼
所有在主線程上進行的沒有直接
響應用戶事件的工作應在別的地方進行
什麼工序是我們可以用來保證我們不斷地響應
用戶時間但同時確保我們可以
及時地做其它工作
那麼答案就是我們可以用GCD和服務質量
在WWDC2014時有一個很棒的演講
而在來臨的週五會有一個關於GC和服務質量很棒的演講
所以我不會在這裏細說
它們是非常重要的兩個東西
第一件事是你的主流程正在
最高優先地運作而那個就是用戶交互優先權
另外一件事是
服務質量的頻率在
所有前臺應用中分享
這樣每個人的用戶發起的隊列將有相同的機會接觸到CPU 
而每個前臺隊列也有相同的機會接觸CPU
沒有一個前臺的app比另外的跟有優先權
如果你能適度的優先你係統的工作
那麼系統就可以保證我們能夠
在屏幕上有多重apps操作時得到最佳運作
所以這個和IconReel有何關係
我們會在一個不同的流程上使用GCD加載圖標
在用戶發起的服務質量上
我們要做的第一件事 建立調度隊列
這個叫做圖標生成隊列
當我們在主流程時我們會異步調度
在我們的圖標隊列中生成在下一個界面生成每個圖標隊列
雖然在代碼片段中並不明顯
但是從主流程中異步調度工作到一個
像這樣給質量服務降級的隊列
到第二高的服務質量的用戶發起服務質量中去
所以這個代碼能夠有效地在用戶發起服務質量中加載所有圖標
好 現在讓我們再試着滑動一下 
好的 這好多了
如果你的設計行得通
這樣你和你apps就能使用這個方案
比如說你可以一邊展示你的佔位圖片
一邊等待真正的內容加載出來
但IconReel的設計不允許這樣
我們必須有已經加載好的圖標在它已經在屏幕上滑動之前
所以我們真正需要的是找到一個方式
來暫時促進圖標生成隊列
在主流程中達到同樣優先權
就在界面滑動圖標之前
這樣它可以更快地完成圖標生成
還有另一種方法是
使用服務質量覆蓋
當我們有這一類型的倒置時例如有個高優先權流程或隊列被阻礙而
等待一個低優先權流程或列隊來完成一些工作這個會非常好用
而最酷的部分是
如果你給系統提供足夠的信息
服務質量覆蓋便可以自動生成
你可能在想 布蕾特妮我怎樣才能給系統
提供足夠的信息
這裏有一個好用的表格
再說一遍 去年的演講和
這週五的演講會更深入地講解這個
但今天講的是調度組等和
調度信號等不會是你們要的東西
你應該爲了這些功能的使用審計你的代碼
然後意識到他們不會
在優先倒置中修復這些類型
那麼讓我們看一下我們在IconReel上會怎麼做
當在屏幕上圖標滑動的 第一行之前
在主流程上我們會
同步調度這個空阻塞到我們的圖標隊列中區
我們需要做的是增強圖標隊列的優先權
來和主流程的優先權匹配
直到阻塞被執行
在圖標隊列的點
會回到其正常優先權
現在我們來看一下滑動以及它們是什麼樣的
對 很好 一個很好的慢滑
我們現在來試一下慢滑之後快滑
我的天 我們又回到最初的狀況了
就是當到了下一頁的時候
在屏幕上有一個停頓
現在怎麼辦
這裏有一個規律
將工具再次拿出來我們拿出另外一個追蹤
這次我們還有一個計算器
而且我們要做一點兒計算然後我們要找到我們不能加載
讀取圖標圖片從磁盤中 解碼圖標圖片
然後讓圖標變得好看且有時間
讓一個快速地用戶滑動到下一頁
現在做什麼
我想我們應該等更快的設備了
一些掌聲是給它們的
開個玩笑
我們可以做得更好
我們必須更聰明
數學計算告訴我們可以達到更好
的運行如果我們讓
下一頁的圖標已經在記憶體中運行
這個確保及時當你
在多重頁面中快速滑動我們有足夠的時間
讓用戶可以再次滑動之前加載下一頁的圖標
現在我們來增加我們的工作集從第一頁
到第三頁 你們現在所看到的
頁面不是前一頁也不是後一頁
而我們沒有一個神奇的八球
來知道用戶會滑向哪一頁
所以擁有前後兩頁會是最佳的選項
現在讓我們試着滑動
很好 這看起來好多了
當用戶到達下一頁時
我們已經在加載下一頁的圖標了
但是 這其實增加了我們的記憶體使用
當我們有僅僅一頁的工作集時
我們有記憶體佔用
現在我們有了這個記憶體的佔用
我們應該清楚這將會如何影響其它apps
現在來看當用戶用IconReel在屏幕上打開某二級app時會發生什麼
IconReel調整了大小只展示了三行而不是四行
這是個重新評估我們的工作集的好機會
我們依然需要同時有三頁的四行圖標在內存中嗎
不我們僅僅需要同時有三頁三行的內存
高效到它看起來有點兒像這樣
現在我會手動
刪除這些多餘的圖標行
就是我們不需要用的 但是
需要很多工作來生成它們
如果不是特別需要 我不想重新做
如果有一個地方
讓我我能夠擺放這些圖標那該多好
如果系統需要內存 我們可以丟掉它們
如果系統不需要內存 那麼它們可以留在內存中
然後我們可以再次使用它們當我們需要它們的時候
有一種方法
就是讀取內存發出的警告
當系統低於內存限制時會出現內存發出的警告
說你的程序正在達到它的內存限度
我非常想給你一個數字這樣你可以選擇你的內存限度代碼
不幸的是 沒有這樣一個數字
對於每臺設備和每個應用上下文的限制是不同的
所以我能給出的最好建議就是
讀取系統發出的警告然後採取行動
所以你應該做什麼
你應該把不在工作集的東西清理出來
這包括清理緩存數據釋放圖片
和釋放視圖控制器
這是你可以用來讀取內存警告的APIs
然後我想說明一點
這些都不是第一次在iOS 9中出現
它們存在一段時間了
希望你們都已經使用它們了
現在我可以檢查一個內存警告
然後手動去除那些圖標
我很懶而且我不想那麼做
如果有一個工具可幫我管理那些玩意兒
讓我不用去做就太好了
而我們也有一個這樣的工具它叫做NSCache
它和NSDictionary很像
但它對於可以被快速重塑的對象來說很好
它還幫你處理內存發出的警告
自動清理東西然後它
也知道應用上下文比如前臺和後臺
然後在必要的時候清理東西
它還能做很多很酷的東西但我們今天沒有時間展開討論
不要忘了看NSCache上的資料
現在在拆分視圖上我們可以看到IconReel
這次不把這些圖標刪除
我們把它們放到一個NSCache裏面
實施上我們只把我們生成的每個不在工作集中的圖標放進NSCache裏
而當我們有一個內存發出的警告時
我們可以讓NSCache做所有清除那些不在我們工作集的圖標
讓我們回顧一下
我們從這裏開始每個圖標都在內存裏面
所以我們的內存使用很高 且滑動很流暢而CPU和磁盤I/O很低
但我們有時看到app崩潰
而這並不好
所以我們調整我們的工作集
到只有一頁圖標中然後內存使用很低
但是我們的CPU和磁盤I/O在滑動時很高
而這會產生很差勁的滑動操作
現在我們將工作集的大小變爲三頁圖標
這會給我們的內存增加一點點
然後每一個我們生成的圖標
不在工作集中我們就把它們丟到NSCache裏面
我們增加了整體的內存的使用
但是大量增加內存的使用
已經使它能夠適應內存的限度
對於你們很多人來說 這已經很好了
如果你的app可以在一個多任務處理的環境下運行
且在地圖上交叉運行那麼你的狀態應該不錯
我今天展示了一些你們的app可以做到的事情
來成爲一個優秀而多任務處理的公民
但是有些時候只靠這些事情還是不夠的
爲了和你們聊聊你們接下來可以做什麼
我想請出喬恩德拉蒙德
謝謝你布蕾特妮 大家好
看來你們已經掌控如何使用你的app的內存
來極大地幫助你的app和
其餘系統的運行
但有些時候只靠這些知識並不足夠
如果你已經做了我們說過的所有事情
並且做得很正確 但是情況還是不對
我們將談談一些方法
讓你們的apps可以更好地管理它們的內存佔用
首先 我想回到那個多任務管理的例子
假如我們有一個初級和一個二級app
而現在已經達到內存的極限了
接着系統會發出一個內存警告
身爲良好多任務公民apps會管理好
並清理它們的緩存和其它不需要的東西
好的 那麼現在用戶引進了一個PiP
我們有足夠的內存 這樣不錯
雖然我們還沒到達內存的極限但我們已經接近了
現在用戶將調整那個二級app
讓其達到和初級擁有一對一的比例
因此 這將造成CPU的內存突增
這會使系統不能及時做出反應
很不幸地被逼把
初級的app終止即使它不是
內存增長的正真原因
迴歸到SpringBoard從來就不是一個好的體驗
就像布蕾特妮剛剛展示的那樣
在我繼續講或者結束之前
我想跟你們分享一句話
那就是在你程序之外的東西都應該被視爲
有敵意並且會毀滅你的可能
我不是故意說不吉利的話
且我也不想讓你們覺得我瘋了
但身爲一個良好的多任務管理公民就應該適應
你身邊所有會發生的事情
有時你身邊發生的事情會很離譜
你可能覺得一切都操作得很好
但是系統可能在密謀着終結你
事情雖然不是這樣 但如果你有所準備
這將會幫助你生存
所以首先
內存是在iOS中最被約束的資源
這不是說其它資源不被約束
它們會被約束 只是它們降級的不同而已
當系統沒有內存的時候
它就像在砸一堵牆
有些東西必須離開
它必須將內存拿回來
就像我們之前看到的例子
有時侯系統能夠以比釋放內存更快的速度還原內存
即使我們有時間發佈一個內存警告 
並且三個apps全部都在運行
且都有時間去相應那個警告但我們不能夠知道
它們是否有足夠的CPU循環
來做一些有意義且
可以清除足夠內存來還原內存
爲了瞭解系統是否能夠收回內存
我們需要知道內存是如何被分類
我會將其分爲三個不同的組別
第一個類別我們把它叫做髒的
這是你的程序使用時活躍的內存
這些是你的對象這些是你的堆式分配
靜態 球態和所有你緩存的東西
其實差不多所有的東西
而且這不能被系統召回
因爲這是你在用的
第二個類別叫做可清除的
這是除了髒的內存以外被明確標註
不被app使用的
這樣系統知道當有需要的時候它可以被召回
第三種我們叫乾淨的
這是在磁盤上備份的
系統可以召回這些內存
因爲它永遠可以召回因爲文件已經在這兒了
回到我們的系統內存條
這看起來怎麼樣
我們有一個非常非常小的內存局面
但是系統不這麼看
系統知道當它想釋放一些內存來增長時它可以有餘地使用
而不用發佈內存警告
或要求apps來幹預
你的app的目標和適應內存的使用
就是最小化你髒的內存
而最大化你的可清除的和乾淨的內存
我們從最小化髒的開始
首先 對 少用它
我知道我站在這裏說的很容易
但如果你管理你的工作集
然後追溯你在定位的對象使用工具
來做所有的事情一旦你做好這些事下一
重新分類髒的內存爲可清除的
如果你做了這些它可以被系統自動召回
然後這是可有可無的數據中最好的
你現在不需要的數據也許會在未來需要
所有你可能放到一個緩存裏的事情 比如說
我們把這個應用到IconReel上
這個和我們中斷的情況相似
我們在工作集的兩旁有圖標的緩存
另外 只是
對於這個例子 我將再重新把我們的數據分一下類
比起在一個每個-圖標塊上工作
我會將圖標羣分成集列
就因爲它可以在這兒變得比較輕鬆
這並不意味着會改變我們app的動態
當用戶來回滑動我們更新我們的工作集
有些被緩存了 有些被拉出了緩存
這都是一樣的
我們來給這個內存使用分一下類
首先 我們正在使用的內存
應被分類爲髒的
這是我們的工作集
我們所有在緩存的對象都是可以清除的
這爲我們展示了一個有趣的機會
來讓我們跟高級地分類內存
比如說 標記更多在用着的數據
或是髒的甚至有一些是在緩存裏的
這介紹了一個另一種緩存的方式
第一個那個最外的圖標
是我們最遲使用到的
我們會讓系統在它需要的時候重新召回我們不在乎
但是我們想要確保有能力來控制
我們可能馬上用到的圖標
即使它們依然在緩存中我們會標記它們爲被使用中
這樣系統就不會隨意拿走它們
這些是我們在應對一個內存警告的時可釋放的
這就給了我們一個工作集
一個我們現在絕對會需要
但我們卻無法爲那個工作集做任何東西
這在多任務處理例子中是什麼樣的
我們回到那個出錯的情況
PiP進來了
我們沒有內存了
但現在系統知道初級和
二級的app是良好的多任務處理公民
它們有可以清除的內存的能力
這個系統 不用應對任何人
就可以從app中拿走
然後讓系統迴歸到一個好的狀態
但當然了 如果用戶繼續使用設備
內存將會重新增加
我們又收到了一個內存警告
但因爲那些apps只失去了可清除的數據
它們可以自由地響應內存警告
然後清除緩存這樣還系統一個好的狀態
在你的apps中應該怎麼用你的可清除數據
這很簡單
這裏有一個等級是可清除的數據
然後它是一個NS不可變數據的子類別
它沒有別的性能它很簡單
唯一的分別是這三個方式
第一個就是Begin Content Access
這個告訴系統你正在使用內存
不要把它拿走
第二個方式BeginContent Access
現在內存被認爲是可清除的
而你可能隨時都會失去它
第三個方式是斷定系統是否在你不用的時候把它拿走
回到系統資源條上 這差不多是
布蕾特妮結束的部分
我沒有改變任何東西
這些圖形差不多一樣
不同的是我們抽取了一部分自適應內存
然後重新分類爲可清除的
這使得我們成爲一個更好的多任務公民
因爲系統可以代替我們做工作
但是有相同的本質表現性能
就是如果我失去我的可清除內存
然後我清除了我的緩存 我現在怎麼辦
我需要重塑所有 我需要的數據
及我曾經建造的但這很昂貴
磁盤I/O和CPU出現尖峯 這樣不好
我們分析在app中使用的數據來
看是否我們可以做更多的事情
那麼IconReel使用什麼數據呢
它們是圖標 然後第一個特性就是
它們絕對重要
我們沒有圖標就沒有一個app
某時 用戶會滑動到它們
我們需要它們 無法避免
第二個它們生成用到很多內存
從磁盤中讀取它們破解它們並潤色
你想幹什麼就幹什麼這樣費用浩大的內存
第三點 其實它們可以被預期計算的
我們將提前知道這些圖片會怎樣
如果我們有多餘的空間我們便可以計算它們
最後一點是它們非常靜態
有很大的可能性
如果我提前生成一些東西它會和我想要用它的時候一樣
因爲它不怎麼經常改變
這些所有的觀點結合起來
使得這個數據是一個用於文件緩存的最佳選擇
在我說別的之前
我想說這個依然是一個緩存即使它是一個文件
不要將這些緩存寫到用戶的文件夾中
在你的app的緩存文件中保存
或在系統的臨時目錄中保存
回到我們的系統資源
我們剛介紹了一個新的題目
那就是磁盤空間
我們可以交換一些CPU循環來生成這個數據
保存之後 當我們需要的時候我們再把它拉出來用
我們事實上完全去除了CPU的使用功能
現在你也許已經注意到I/O已經運行了
因爲完全渲染的圖片會比
那些資源文件大 這沒關係
這些都是和權衡有關
這就直接到了被淨化最大的內存
你可能會記得我之前說過被一個文件備份的內存
在磁盤上是被視爲乾淨的
那麼現在我們在磁盤上有一個文件多巧啊
這樣一個文件的數據可以被內存映射
系統會定位一塊內存給你
然後直接映射磁盤中文件的位置和內容
這絕對值得注意內存
在文件內容上必須完全一致
你不能內存映射一個需要更多破解文件
或者當它已經加載了的
這對於只讀數據來說很理想就像我說的
它不怎麼經常改變
這裏最酷的地方就是
以可清除的內存
系統可以在當你需要時重新召回一些空閒的內存
但是 它沒有消失
當你再次需要它時你再次取數它時
系統從磁盤中再次加載回來
就像它從沒消失過一樣
而且它有很大的隨機存取性能
只因爲你的工作集在這而你需要的一塊
數據在別處並不重要
系統可以只讀那塊的部分文件
然後交給你 你就可以工作了
這個看起來是什麼樣的
我們從內存的數據開始
然後你在磁盤上寫出來
系統現在把它當成 內存映射
如果你存取一部分的數據然後它
就會把它加載好 然後交給你
當你不再用它的時候 它就被拿走了
我們如何能將此功能應用到IconReel上
我們從這個工作集開始但是事實上我們是把
我們生成的每個圖標去合拼工作集
創建一個大的數據文件然後寫到磁盤上
現在回到我們的app中來我們再次拿出我們的工作集 三頁
我們訪問這三頁內存
然後系統只加載文件的那一部分
到內存中然後保持其它部分乾淨
不管那文件是不是上百MB
它其實並不在內存中
當我們四處滑動時 一樣的事情發生了
系統加載了我們需要的數據
加入我們引進一個會顯示通知的功能
用於在主界面上的其它圖標
我們可以把它們拉出來然後
不用擔心它們在哪和它們是什麼
虛擬內存系統爲我們做了大部分工作
這會如何改變我們的資源條
這裏我們已經將CPU中斷了
但是我們現在的緩存實際上在磁盤上
那麼這個也消失了
然後我們現在唯一內存佔用就是工作集
其它地方都被認爲是乾淨的
所以不算是反對我們
且值得注意的是我們有效地消除CPU
對前端和後端的需求對於我們的數據生命循環來說
我們不需要CPU來生成數據來展示給
用戶或者我們也不用CPU來清理乾淨來應對內存警告
系統都爲我們做了
你如何能用內存映射數據
在一次 它是一個在NS數據上的簡單API
這裏有些選擇你可以
用來開始數據對象
如果你在初始化器中標註映射選項
你就會得到一個內存映射數據文件
如果我沒有提到我會被看做是玩忽職守
用這個系統時有一些警告
第一個就是它不適用於
少量的數據
在頁面上自己工作的虛擬內存
也就是少量數據
如果你的甚至更小你會遇到
覆蓋在你原有問題上的新問題
還有從內存映射文件中
如果你的內存映射一千個圖標文件比如
這其實有一個對於任何系統可以有的打開文件的限制
這樣你會惹上麻煩
這是其中一個主要原因
爲什麼我們將數據集合成大塊
使其對於VM系統更加好管理
或者你也可以只是濫用虛擬內存系統
你所創造的每個可清除的數據對象創造
在你虛擬內存中的一個區域
如果你創造了太多那些內存映射文件
你會將你整個空間碎片化
你同樣會使其耗盡
如果你決定來內存映射一個10GB內存的文件
那麼你會完全用光內存
不幸的是虛擬內存系統的濫用會導致
你的程序被終結
而這是我們最初想要避免的 對嗎
爲了提供最好的多任務處理體驗
對於用戶理解你的app使用的數據
和數據性能是非常重要的
你現在必須能夠分辨出可有可無的數據
和你需要的重要數據
你的數據可以被預計算嗎
重新建立有多貴
它長時間改變一下
瞭解關於你使用的數據可以幫助你找到
讓你的內存變得最大適用性的正確工具
我們可以一起改善我們apps的適用性
和提供更好的多任務體驗給我們的用戶
在接下來的幾周你會更新你的apps
爲了iOS9的多任務處理
我希望你們把這些話題記住
首先用工具來識別並修復程序錯誤
這是簡單的東西
你的內存泄露無效率的數據構造 算法
廢棄的內存等
把它們都修好
其次適當優先化你的工作
然後別阻隔到主流程
我不知道你們多少人在這個系列的第一階段記住了
就是系統會真的終端
如果你阻隔主流程太長時間
最好了解
你的工作應該在哪然後將其歸位
第三點就是辨別並管理你的工作集
然後瞭解工作集會改變
根據應用的目前執行環境
你是前臺 後臺 PiP
瞭解你現在的位置
因爲你的工作集不應該是相同的
第四個是使用緩存 然後響應內存警告
這個是作爲一個多任務處理好公民的基本
請回應它們
下一個利用虛擬內存系統
也就是我們說過的
瞭解你的app的數據性能
然後看如果你可以利用那些工具
來讓系統爲你管理內存
最後就是良好的表現需要權衡
你的app是有需求的
apps在你旁邊運行的有需求
系統也有侷限
辨別你的app如何可以適應環境
用更約束的資源因爲這是
改善所有人用戶體驗的關鍵
因爲我由一句話開始那麼我就由一句話結束
我在網上找到的這句話
據查爾斯·達爾文
稱不是最強或者最智慧的生存
是那些最會改變的生存
多任務處理和適應有關
然後最能適應的apps將會
帶來最佳的用戶體驗
獲取更多的信息 我非常推薦你們去
看一看文件
這裏有一個新的採取多任務的指南它很棒
去論壇討論有技術支持
如果你有任何問題
找柯特盧·瑟特 聯繫他吧
他也是一個SpringBoard的前任工程師
所以我相信他很願意聆聽你們的想法
我們關於這個有兩個之前的講座
我建議你們也去看它們
接下來也有性能和GCD講座
謝謝大家 今天的到來
我等不及要看你們的apps了