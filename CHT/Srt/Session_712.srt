00:00:20.521 --> 00:00:25.259 
低能耗，高性能：壓縮和加速框架

00:00:27.394 --> 00:00:28.228 
早上好

00:00:33.233 --> 00:00:35.702 
歡迎來到矢量數字組講座

00:00:36.770 --> 00:00:40.407 
我叫埃裏克·比安維爾
現在就職於矢量數字組

00:00:42.476 --> 00:00:47.948 
我們組提供大家都知道的加速框架

00:00:48.415 --> 00:00:51.718 
還在系統裏的一些庫

00:00:53.387 --> 00:00:58.425 
在加速框架中你會發現圖像

00:01:00.127 --> 00:01:03.497 
是圖像操作的數百種

00:01:04.164 --> 00:01:06.867 
功能集合

00:01:07.801 --> 00:01:10.070 
你還會看到加速內部的vDSP是用於

00:01:11.071 --> 00:01:17.110 
信號處理和三層線性代數庫

00:01:19.012 --> 00:01:24.418 
在加速框架以外
我們還維護Math library

00:01:25.085 --> 00:01:27.955 
LibM和字符串函數

00:01:28.655 --> 00:01:33.093 
去年 我們引入了SIMD這是一系列

00:01:33.160 --> 00:01:37.364 
頭文件和函數可提供矢量類型

00:01:37.431 --> 00:01:42.703 
可以向SSC和AVX附近的
CPU矢量單元直接映射

00:01:43.704 --> 00:01:47.808 
今天 我們要介紹這些函數的三種補充

00:01:48.842 --> 00:01:54.114 
首先是壓縮這是數據壓縮庫

00:01:54.882 --> 00:01:58.085 
然後史蒂夫會
介紹SIMD庫的補充內容

00:01:59.152 --> 00:02:01.288 
最後盧克會講稀疏BLAS的內容

00:02:02.189 --> 00:02:04.191 
稀疏矩陣的線性代數

00:02:05.392 --> 00:02:07.127 
我們先來看壓縮

00:02:08.628 --> 00:02:09.463 
壓縮是什麼?

00:02:10.597 --> 00:02:14.668 
壓縮是個新庫它可提供統一

00:02:14.768 --> 00:02:17.771 
和簡單的API進行無損數據壓縮

00:02:18.438 --> 00:02:20.741 
在app中想要使用壓縮時

00:02:21.508 --> 00:02:24.011 
爲什麼會需要這樣的東西呢

00:02:24.912 --> 00:02:27.080 
首先需要找到

00:02:29.249 --> 00:02:32.152 
壓縮讀取手冊編寫代碼進行測試

00:02:33.220 --> 00:02:38.025 
如果不工作就需要另選一個再編寫代碼

00:02:38.492 --> 00:02:39.459 
這會非常麻煩

00:02:39.960 --> 00:02:44.264 
有時 甚至會在你的app中

00:02:44.331 --> 00:02:46.800 
還包括壓縮曲線這對於

00:02:47.167 --> 00:02:49.002 
維護來說就是噩夢

00:02:49.636 --> 00:02:51.338 
因此要爲常見的壓縮算法

00:02:51.405 --> 00:02:55.642 
和統一的API提供包裝

00:02:56.910 --> 00:02:59.713 
以及諸如優化代碼

00:03:00.581 --> 00:03:03.116 
和算法間的輕鬆轉換類好處

00:03:03.617 --> 00:03:06.320 
我們先從放入其中的算法開始

00:03:07.688 --> 00:03:12.259 
當我們談到壓縮算法時
需要考慮兩個矩陣

00:03:12.926 --> 00:03:15.462 
第一個顯然是壓縮比率

00:03:15.896 --> 00:03:18.332 
這是原始數據大小和壓縮有效

00:03:18.866 --> 00:03:21.001 
載荷大小之間的比率

00:03:21.802 --> 00:03:26.273 
我們感興趣的是編碼速度和解碼速度

00:03:27.307 --> 00:03:32.379 
爲選擇算法他們將其放在同一圖形中

00:03:34.081 --> 00:03:37.084 
在這張圖中X軸上顯示的是壓縮比率

00:03:38.151 --> 00:03:40.787 
在Y軸上則是編碼速度

00:03:40.854 --> 00:03:46.727 
在中間是參考參考壓縮器

00:03:46.894 --> 00:03:49.596 
所有的算法都要與這個參考進行比較

00:03:51.131 --> 00:03:53.233 
如果你是在右側壓縮效果較好

00:03:53.367 --> 00:03:56.770 
如果是在頂部壓縮速度較快 就是這樣

00:03:57.004 --> 00:03:59.072 
我們放入一些算法

00:04:00.140 --> 00:04:02.209 
中間的是zlib

00:04:02.309 --> 00:04:04.444 
這是最常用的

00:04:05.312 --> 00:04:06.613 
那我們做了什麼呢？

00:04:06.680 --> 00:04:12.119 
我們選擇最好的壓縮對就是LZMA

00:04:14.655 --> 00:04:16.423 
和最快的LZ4

00:04:18.524 --> 00:04:25.065 
你會看到灰線表明壓縮得
越多難度就會越大

00:04:25.732 --> 00:04:27.901 
壓縮更多 意味着

00:04:28.101 --> 00:04:32.639 
速度越慢壓縮越少
則速度越快呈指數關係

00:04:33.574 --> 00:04:36.610 
正如仔細來看這就是在zlib之上

00:04:37.878 --> 00:04:42.082 
的第一個點
也就是速度更快 稍靠右側一點

00:04:42.149 --> 00:04:44.918 
這是說壓縮得更好這就是LZFSE

00:04:45.385 --> 00:04:47.654 
我們今天要介紹的新壓縮器

00:04:49.423 --> 00:04:54.394 
是對zlib的很好替代
我稍後會談到這點

00:04:55.629 --> 00:05:00.234 
在壓縮庫中我們放了4個壓縮器

00:05:01.401 --> 00:05:05.606 
解碼是這個樣子看似是同樣內容

00:05:05.706 --> 00:05:09.810 
如果壓縮得越多也就
需要更多的解壓時間

00:05:11.144 --> 00:05:15.349 
我們的4個壓縮器都在同樣的位置

00:05:16.049 --> 00:05:20.320 
這些是我們選擇放入壓縮庫的4個算法

00:05:21.154 --> 00:05:25.192 
LZMA用於高壓縮但它位置卻很低

00:05:25.792 --> 00:05:29.763 
LZ4用於快速壓縮
但是它不能壓縮很多

00:05:29.830 --> 00:05:35.569 
在中間位置是zlib和LZFSE 

00:05:35.636 --> 00:05:37.571 
爲在壓縮比率和速度之間取得平衡

00:05:38.839 --> 00:05:42.309 
如果是在不同的應用情況中做比較

00:05:42.676 --> 00:05:44.578 
對於軟件分發你會使用LZMA

00:05:44.645 --> 00:05:47.347 
因爲要在服務器上壓縮一次 然後發送

00:05:47.948 --> 00:05:51.451 
這樣你會希望發送部分越小越好

00:05:52.853 --> 00:05:54.655 
那我們做了什麼呢？

00:05:54.988 --> 00:05:58.325 
我們在Apple硬件上做了部分優化

00:05:59.059 --> 00:05:59.927 
這是什麼意思呢？

00:06:00.727 --> 00:06:04.898 
像這樣例如我們優化了zlib解碼器

00:06:05.999 --> 00:06:08.735 
我們提供的zlib解碼器的性能

00:06:08.802 --> 00:06:15.242 
壓縮能力幾乎比
普通的zlib快1.6倍

00:06:16.009 --> 00:06:17.177 
LZ4也是如此

00:06:17.244 --> 00:06:20.848 
因此這是另一個好處

00:06:20.914 --> 00:06:23.116 
你還會因爲無需改變代碼

00:06:23.183 --> 00:06:26.019 
就可以實現數據安全和性能升級而受益

00:06:27.955 --> 00:06:31.758 
我們簡單介紹一下
新的壓縮器LZFSE

00:06:32.292 --> 00:06:34.962 
你爲什麼會需要新款壓縮器呢？

00:06:36.930 --> 00:06:37.764 
首先它很有趣

00:06:40.434 --> 00:06:44.004 
然後 爲什麼我們要優化zlib?

00:06:44.371 --> 00:06:49.643 
在zlib的熵編碼部分
我們得出了結論

00:06:50.077 --> 00:06:55.048 
這裏是個瓶頸問題無法解決

00:06:55.616 --> 00:06:59.419 
除非是用其他的內容加以取代
我們就是這麼做的

00:07:00.120 --> 00:07:03.824 
我們採用了新技術更精緻的狀態熵

00:07:03.924 --> 00:07:06.793 
並用它取代了zlib編碼

00:07:07.427 --> 00:07:12.999 
好消息是LZFSE可以在 

00:07:13.066 --> 00:07:17.371 
現代CPU架構上實現更好的映射

00:07:18.672 --> 00:07:24.011 
當初的設計目標
是要匹配zlib的壓縮比率

00:07:24.077 --> 00:07:26.013 
使之能實現儘可能快的速度

00:07:26.980 --> 00:07:29.149 
我來給大家看看相關的數字

00:07:30.551 --> 00:07:35.255 
這是壓縮比率通過設計也是同樣的數字

00:07:37.090 --> 00:07:42.262 
這裏是能源效率
編碼和解碼都有LZFSE  

00:07:43.363 --> 00:07:46.500 
如大家所見 在編碼方面 

00:07:46.567 --> 00:07:50.737 
我們快了2倍多
在解碼方面我們快了2.5倍

00:07:50.804 --> 00:07:52.172 
不僅是快是更高效

00:07:52.306 --> 00:07:53.273 
這是什麼意思呢？

00:07:54.074 --> 00:07:58.111 
假設你有的電池是滿格電量
並未進行壓縮

00:07:59.246 --> 00:08:03.951 
通過zlib比如說在電池
沒電之前可以壓縮5千兆數據

00:08:04.451 --> 00:08:09.990 
通過LZFSE 耗費同樣的電量
你可以壓縮12千兆數據

00:08:10.224 --> 00:08:12.526 
這就是高能效的意思

00:08:13.894 --> 00:08:15.762 
實際上 速度方面也不差

00:08:16.096 --> 00:08:20.000 
因爲我們在相同的壓縮比率下在編碼

00:08:20.067 --> 00:08:22.503 
速度方面快了2倍多解碼速度

00:08:23.036 --> 00:08:24.204 
則快了3倍

00:08:26.773 --> 00:08:28.275 
這就是LZFSE

00:08:28.342 --> 00:08:31.378 
我來給大家展示這個API該怎樣使用

00:08:31.445 --> 00:08:36.216 
共有兩個API在一個緩衝區中
立刻出現了所有的數據

00:08:36.283 --> 00:08:37.851 
則要用到緩衝API

00:08:38.619 --> 00:08:44.291 
這是從PC中接收數據時
用到的流API

00:08:46.159 --> 00:08:47.694 
緩衝API非常簡單

00:08:47.761 --> 00:08:52.799 
就像是超級的內存拷貝你提供緩衝

00:08:52.866 --> 00:08:55.936 
和字節數目的地緩衝

00:08:56.003 --> 00:08:59.873 
和容量還還可以提供

00:09:00.107 --> 00:09:03.677 
所需用到的算法

00:09:03.844 --> 00:09:04.878 
這就是LZFSE

00:09:05.445 --> 00:09:08.982 
你會看到在壓縮器之間的轉換

00:09:09.049 --> 00:09:11.885 
就是改變常數即可不需要重寫任何代碼

00:09:12.553 --> 00:09:15.489 
新代碼是壓縮解碼緩衝函數

00:09:15.856 --> 00:09:17.991 
如果出現錯誤或者目的地緩衝區

00:09:18.058 --> 00:09:21.562 
沒有足夠空間它就會將

00:09:21.628 --> 00:09:25.232 
返回目的地緩衝區的字節數變爲0

00:09:26.366 --> 00:09:28.669 
解碼也是同樣道理

00:09:29.269 --> 00:09:32.639 
你會傳遞包括壓縮有效載荷的緩衝區

00:09:33.507 --> 00:09:36.777 
和接收解碼數據的緩衝區

00:09:38.712 --> 00:09:43.050 
不同之處在於它放入輸出

00:09:43.951 --> 00:09:45.519 
緩衝區的字節數

00:09:46.587 --> 00:09:50.057 
如果出現問題它會填充緩衝區

00:09:50.357 --> 00:09:53.594 
也會截取輸出內容

00:09:54.728 --> 00:09:56.763 
我來給大家展示流API

00:09:57.197 --> 00:09:58.932 
這稍微有些複雜

00:10:00.133 --> 00:10:02.970 
因爲你需要在調用之間有些狀態

00:10:03.070 --> 00:10:08.475 
我們會用需要壓縮的
新原始數據多次調用庫

00:10:08.542 --> 00:10:10.477 
這就像個糖果工廠

00:10:10.544 --> 00:10:13.313 
從這邊送入白糖輸出的就是糖果

00:10:16.917 --> 00:10:19.219 
你需要將流對象進行初始化

00:10:19.286 --> 00:10:21.421 
然後多次處理函數

00:10:22.055 --> 00:10:29.029 
最後你會調用函數釋放流
對象佔用的資源

00:10:30.230 --> 00:10:32.533 
我來給大家看看代碼細節

00:10:33.367 --> 00:10:35.769 
首先我們初始化流對象你表示認可

00:10:35.836 --> 00:10:39.072 
我要編碼要使用LZFSE初始化

00:10:39.740 --> 00:10:43.744 
然後你會調用過程

00:10:44.511 --> 00:10:49.750 
在調用過程之前通常是在其他壓縮庫中

00:10:50.350 --> 00:10:53.220 
你需要告知它在哪裏壓縮字節

00:10:53.287 --> 00:10:55.455 
在哪裏放置輸出數據

00:10:56.223 --> 00:11:00.460 
然後調用過程它會和消費者端一樣

00:11:00.527 --> 00:11:02.362 
輸入或填充輸出數據

00:11:03.330 --> 00:11:05.799 
它還會爲你更新這些域

00:11:07.134 --> 00:11:09.903 
最後你會告知它好了做完了

00:11:09.970 --> 00:11:12.072 
沒有白糖原料了 

00:11:13.207 --> 00:11:15.843 
結束之後你就不得
再發送需要壓縮的數據

00:11:15.909 --> 00:11:20.681 
但是你需要多次調用
清空管道獲得輸出數據

00:11:21.615 --> 00:11:25.686 
此刻它會返回結束意思是說

00:11:26.553 --> 00:11:30.657 
最後你需要調用壓縮流銷燬來釋放資源

00:11:31.992 --> 00:11:34.728 
這就是編碼解碼則要更爲簡單

00:11:35.229 --> 00:11:38.031 
你需要相同的初始化代碼

00:11:39.266 --> 00:11:42.469 
這次是要解碼而不是編碼

00:11:43.971 --> 00:11:47.140 
然後你發送數據它會自行分辨

00:11:47.207 --> 00:11:48.609 
這是否爲流的結束部分

00:11:48.675 --> 00:11:52.312 
在某些點它會返回結束這意味着

00:11:53.747 --> 00:11:56.450 
你可以獲得所有數據你還要再次銷燬
就這樣

00:11:56.984 --> 00:11:58.218 
我們完成了壓縮

00:11:59.319 --> 00:12:03.457 
現在來進行打包有一個新的庫

00:12:03.524 --> 00:12:06.226 
可以在幾個壓縮器上
提供簡化和統一的API

00:12:07.461 --> 00:12:09.963 
LZMA LZ4 zlib
和 LZFSE

00:12:10.030 --> 00:12:14.201 
哪個在zlib上更受青睞

00:12:15.502 --> 00:12:18.338 
LZFSE就是新的 高性能壓縮器

00:12:19.173 --> 00:12:22.009 
謝謝大家 有請史蒂夫他會介紹

00:12:23.577 --> 00:12:26.980 
有關SIMD庫的改進內容

00:12:28.115 --> 00:12:28.949 
謝謝

00:12:34.521 --> 00:12:35.355 
謝謝 埃裏克

00:12:35.722 --> 00:12:39.126 
我是史蒂夫·坎農 
和埃裏克一起是矢量數字組的工程師

00:12:39.693 --> 00:12:41.195 
今天 我想談談SIMD 

00:12:41.795 --> 00:12:45.432 
這是個二維三維和四維的矢量數學

00:12:47.100 --> 00:12:50.571 
去年在Yosemite版本
和iOS中 我們引入了SIMD

00:12:51.471 --> 00:12:54.908 
它可以用於C
Objective-C

00:12:55.275 --> 00:12:57.544 
和C++它與Metal着色
語言非常相似

00:12:58.045 --> 00:13:01.415 
也就是說它很容易編寫在GPU上

00:13:01.481 --> 00:13:04.551 
運行的Metal代碼使用和SIMD

00:13:04.618 --> 00:13:07.020 
相同的數據結構和相同的CPU代碼

00:13:07.855 --> 00:13:11.225 
它非常接近着色語言的傳統

00:13:11.291 --> 00:13:14.161 
以及與矢量和矩形工作的方式

00:13:14.528 --> 00:13:15.629 
那麼今年的新增

00:13:16.630 --> 00:13:18.031 
內容是我們也會支持Swift

00:13:23.470 --> 00:13:27.107 
那麼本次講座中以及我主講的部分
都是與Swift有關

00:13:27.174 --> 00:13:28.408 
所有的實例都是Swift

00:13:28.675 --> 00:13:32.613 
大部分情況下 它與C
Objective-C和C++中

00:13:32.813 --> 00:13:34.982 
都是完全相同

00:13:35.482 --> 00:13:39.386 
如果想在深入瞭解這些語言可以看看

00:13:39.453 --> 00:13:42.322 
我們去年的講座視頻其中有些很重要的

00:13:42.389 --> 00:13:45.092 
不同之處我會在講座中明確指出

00:13:45.225 --> 00:13:46.760 
但是 所有的實例都是Swift

00:13:48.562 --> 00:13:50.998 
我們爲什麼要引入新的矢量庫呢?

00:13:51.164 --> 00:13:53.634 
在平臺上有一系列矢量庫

00:13:53.700 --> 00:13:55.169 
我也用過相當多

00:13:55.869 --> 00:13:57.137 
爲什麼還要添加新的呢？

00:13:57.204 --> 00:14:01.241 
我給大家看看幾項實例
都是用其他矢量庫

00:14:01.508 --> 00:14:04.711 
小有不便以及使用
SIMD則會好了許多

00:14:06.180 --> 00:14:07.948 
BLAS是很好的矢量庫 

00:14:08.115 --> 00:14:10.484 
它是加速的一部分這是我用到的
第一部分內容

00:14:10.584 --> 00:14:15.222 
這裏是用向量乘以矢量一個例子

00:14:15.355 --> 00:14:17.291 
並將之加入BLAS的另一個矢量

00:14:17.958 --> 00:14:20.327 
我們生成了兩個Swift數組

00:14:20.661 --> 00:14:21.962 
這些就我們的矢量

00:14:22.663 --> 00:14:28.402 
我們稱之爲C BLAS Saxpy
函數 它會將X乘以2 

00:14:28.735 --> 00:14:30.671 
在加上Y並把結果保存在Y

00:14:31.471 --> 00:14:35.409 
我們需要傳遞的還有一些其他信息

00:14:35.509 --> 00:14:38.078 
因爲這裏是用到原始生成的API

00:14:38.145 --> 00:14:40.480 
它對於長度或步幅一無所知

00:14:40.848 --> 00:14:42.182 
我們需要提供這類信息

00:14:42.683 --> 00:14:44.818 
若是提出顯性調用來做

00:14:44.885 --> 00:14:46.954 
這項工作效率也會很低

00:14:47.754 --> 00:14:50.657 
我們來看GLKit
這是另一個很棒的庫我喜歡GLKit

00:14:51.458 --> 00:14:53.660 
它有顯性矢量類型這樣你就不必

00:14:53.727 --> 00:14:56.663 
使用原始數組但是函數卻非常囉嗦

00:14:56.730 --> 00:15:00.701 
你必須要調用GLK矢量3乘以向量

00:15:01.201 --> 00:15:03.971 
來做算法這非常麻煩

00:15:04.304 --> 00:15:06.206 
使用SIMD是這樣的效果

00:15:09.476 --> 00:15:10.777 
好多了 對吧？

00:15:12.779 --> 00:15:16.917 
你可以寫下想用的算法它會發揮作用

00:15:16.984 --> 00:15:18.519 
你不必調用函數

00:15:18.886 --> 00:15:19.987 
生活真美好

00:15:20.654 --> 00:15:21.855 
那麼這樣就好多了

00:15:22.222 --> 00:15:23.090 
你還能做什麼呢？

00:15:24.925 --> 00:15:30.230 
我們有浮點矢量 雙矢量
32bit整數2 3 4的長度

00:15:31.131 --> 00:15:35.869 
在C Objective-C
和C++還有其他矢量類型可用

00:15:36.803 --> 00:15:39.473 
現在我們有了Swift的子集

00:15:39.973 --> 00:15:44.878 
我們選擇這個子集是因爲
當你想用I/O模型

00:15:45.112 --> 00:15:47.447 
想使用圖形內容這是編寫Metal

00:15:47.514 --> 00:15:49.516 
程序最常用來與其他的庫

00:15:49.583 --> 00:15:52.119 
進行互通的部分這些就是
你希望可用的類型

00:15:53.620 --> 00:15:54.988 
這些類型可以用來做什麼？

00:15:55.055 --> 00:15:56.723 
首先 你要生成它們

00:15:56.823 --> 00:16:00.027 
我們有一系列不錯的起始程序
你可以生成零矢量

00:16:00.627 --> 00:16:03.363 
可以顯性規定矢量元素

00:16:03.664 --> 00:16:08.635 
可以有所有組件相等的矢量
有許多不錯的初始程序

00:16:09.403 --> 00:16:10.704 
你可以完成算法

00:16:11.305 --> 00:16:13.340 
可以有元素方面的算法算子也可以用

00:16:13.407 --> 00:16:16.877 
如果我用兩個矢量相乘
就會得到一個新的矢量

00:16:16.944 --> 00:16:20.047 
其中的每個元素元素的值

00:16:20.113 --> 00:16:22.616 
就是輸入矢量對應元素相乘的結果

00:16:22.983 --> 00:16:26.353 
相除也是同樣我可以用向量相乘

00:16:26.887 --> 00:16:29.489 
我可以進行向量點積向量叉積等等

00:16:30.257 --> 00:16:33.861 
我已經給大家看了一個實例
我馬上給你們再看一個簡單的例子

00:16:34.228 --> 00:16:37.464 
這是個反射函數我可能
會在圖像中經常使用

00:16:37.931 --> 00:16:41.201 
它用1個矢量X它通過垂直於

00:16:41.535 --> 00:16:43.937 
標準矢量N來反射N

00:16:45.038 --> 00:16:47.541 
要寫下它需要編寫數學表達式

00:16:47.841 --> 00:16:52.980 
寫下X減去2倍的
X向量點積和N倍的N

00:16:53.947 --> 00:16:56.750 
你實際上不必寫下這個函數 對嗎？

00:16:56.817 --> 00:16:58.485 
應該已經有現成的可供使用

00:16:59.286 --> 00:17:03.690 
對的 我們有一系列幾何着色器
數學函數可供使用

00:17:04.290 --> 00:17:07.160 
我們還有向量點積
向量叉積 反射 折射

00:17:07.361 --> 00:17:10.230 
距離 等等 
所有這些你都會用到

00:17:10.664 --> 00:17:12.299 
如果你之前寫過着色器程序

00:17:12.432 --> 00:17:14.034 
你就曾多次用過這些函數

00:17:14.101 --> 00:17:17.503 
這些都是在Metal
或開放式CL或GLSL 

00:17:17.971 --> 00:17:21.875 
你所喜愛的着色器語言中的標準內容

00:17:22.876 --> 00:17:25.811 
我們還有浮點4類型的加速

00:17:25.878 --> 00:17:29.816 
的各類數學函數可用
因此可以使用 V sign F

00:17:29.917 --> 00:17:33.520 
VCosf 用這些類型
進行數學函數計算

00:17:34.154 --> 00:17:36.223 
我們還有矩陣和矢量

00:17:37.658 --> 00:17:40.527 
矩陣的類型是浮點數N
乘以N 雙精度N乘以M

00:17:41.195 --> 00:17:43.997 
N是列數M是行數

00:17:44.531 --> 00:17:46.400 
如果你是個數學家就會感覺很奇怪

00:17:46.934 --> 00:17:49.169 
如果你是圖形編程人員這就很正常

00:17:49.336 --> 00:17:52.506 
所以大家會感覺輕車熟路

00:17:53.073 --> 00:17:56.977 
N和M可以是2 3或4但是不一定是
正方矩形例如

00:17:57.044 --> 00:18:02.249 
浮點2乘3 是個兩列三行的矩陣

00:18:03.483 --> 00:18:06.687 
同樣 我們有各種初始程序

00:18:07.187 --> 00:18:10.123 
你可以生成零矩陣可以生成標識矩陣

00:18:10.257 --> 00:18:11.458 
可以生成對角矩陣

00:18:11.525 --> 00:18:14.528 
如果你想可以規定對角元素

00:18:14.728 --> 00:18:18.232 
如果你想還可以規定所有元素
或作爲數組的一列

00:18:18.632 --> 00:18:19.867 
或作爲矢量的一列

00:18:23.303 --> 00:18:24.271 
各種很棒的內容

00:18:27.474 --> 00:18:30.310 
我給大家展示一個使用
矩陣的小算法實例

00:18:31.345 --> 00:18:33.881 
我們在對角上用2s生成矩陣

00:18:33.981 --> 00:18:37.818 
這個矩陣當你相乘時可以用矢量乘以2

00:18:38.418 --> 00:18:41.755 
我們把最後一列進行調整 放入一些值

00:18:42.189 --> 00:18:46.527 
這是個變形矩形矢量乘以2

00:18:46.593 --> 00:18:51.298 
這也使用於偏差可以轉化

00:18:52.165 --> 00:18:54.935 
我們可以把這個用於所有都是1的矢量

00:18:59.072 --> 00:19:00.807 
還可以用矩陣的反向屬性

00:19:00.874 --> 00:19:06.413 
獲得相反變形這樣就可以
恢復到最初的矢量從而取消變形

00:19:07.748 --> 00:19:09.583 
當我希望在兩種語言之間互通時

00:19:09.650 --> 00:19:12.319 
可以使用Objective-C
API 如你想要

00:19:12.386 --> 00:19:13.487 
調用的I/O模型 API

00:19:15.422 --> 00:19:19.259 
Swfit矢量類型
與Objective-C

00:19:19.459 --> 00:19:20.994 
矢量類型在佈局上兼容

00:19:21.161 --> 00:19:24.231 
我的意思是說它們在內存中
有着完全相同的表現

00:19:24.631 --> 00:19:26.400 
編譯器瞭解它們是相同的

00:19:27.467 --> 00:19:31.672 
這樣你就不必考慮
將Swift矢量類型

00:19:31.738 --> 00:19:34.608 
轉變爲Objective-C矢量類型
或是將Objective-C矢量類型

00:19:34.675 --> 00:19:38.712 
轉變爲Swift矢量類型
我這裏有一個返回矢量SIMD矢量的

00:19:38.979 --> 00:19:42.716 
Objective-C API
我可以立即將之用於Swift

00:19:43.050 --> 00:19:46.620 
對於矩陣而言我必須從我所獲得的

00:19:46.987 --> 00:19:49.423 
Objective-C矩陣中
初始化Swift矩陣

00:19:49.489 --> 00:19:51.491 
這是個成本很低的操作基本上是個拷貝

00:19:51.558 --> 00:19:54.561 
因爲佈局相同但是我需要調用初始程序

00:19:55.829 --> 00:19:59.499 
我希望將Swift類型傳遞給
Objective-C時也是同理

00:20:00.200 --> 00:20:01.702 
我可以將所用

00:20:02.069 --> 00:20:04.338 
C矩陣屬性的矩陣傳遞矢量

00:20:04.638 --> 00:20:07.674 
以獲得Objective
矩陣 可以將之傳遞給

00:20:07.741 --> 00:20:09.209 
Objective-C API

00:20:10.544 --> 00:20:12.346 
這就是SIMD

00:20:12.880 --> 00:20:16.116 
當配合小矢量和矩陣使用時
SIMD效果很好

00:20:16.250 --> 00:20:19.152 
有時你也會需要使用更大的矢量和矩陣

00:20:20.087 --> 00:20:22.422 
我就要和大家談談LAPACK

00:20:22.556 --> 00:20:23.724 
BLAS 線性代數

00:20:24.458 --> 00:20:28.195 
這是很有意思的環節我們需要
離開數學分支片刻

00:20:31.098 --> 00:20:35.202 
LAPACK和BLAS 
是業界標準的數學庫

00:20:35.802 --> 00:20:39.773 
這些是平臺上部分最古老的API

00:20:41.508 --> 00:20:44.011 
也就是說看起來有些晦澀難懂

00:20:44.511 --> 00:20:46.413 
不過網上有很多文檔資料

00:20:46.480 --> 00:20:48.081 
因爲它們已經存在了近40年

00:20:49.750 --> 00:20:53.287 
很多情況下你可能會從

00:20:53.353 --> 00:20:55.422 
庫中獲取部分代碼
這就需要依靠這些API

00:20:55.622 --> 00:20:57.858 
只要連上加速效果很好

00:20:58.358 --> 00:20:59.226 
用起來很簡單

00:20:59.860 --> 00:21:03.730 
線性代數是我們去年介紹的新界面

00:21:04.431 --> 00:21:06.533 
其中有更簡單的API

00:21:06.600 --> 00:21:09.002 
來完成更常見的線性代數操作

00:21:09.403 --> 00:21:12.806 
這和上一個幻燈片是完全相同的操作

00:21:12.906 --> 00:21:14.408 
它在解析線性系統 

00:21:14.842 --> 00:21:18.278 
而不是用8個參數調用晦澀的函數

00:21:18.345 --> 00:21:22.916 
你調用LA求解 你提供需要
解析的矢量和矩陣

00:21:24.451 --> 00:21:25.619 
非常好

00:21:26.486 --> 00:21:31.558 
在過去幾年間 
我們對LINPACK談得很少

00:21:32.492 --> 00:21:34.494 
以及在線性代數方面
我們可以實現多快的速度

00:21:34.928 --> 00:21:37.030 
LINPACK基準表明 
對於系統線性等式

00:21:37.097 --> 00:21:39.366 
我們可以多快地求解？

00:21:39.433 --> 00:21:43.237 
這完全是我們
在上一頁幻燈片看到的操作

00:21:44.471 --> 00:21:48.942 
歷史上而言該基準共有三種變體

00:21:49.409 --> 00:21:52.779 
開始是作爲可以多快速地
爲100x100系統求解？

00:21:54.147 --> 00:21:56.850 
但是隨着電腦
越來越強大 速度越來越快

00:21:57.251 --> 00:22:00.153 
它不可能通過這樣的小問題

00:22:00.320 --> 00:22:03.957 
顯示自己的速度有多快 因此變成
一個1000x1000的系統

00:22:05.325 --> 00:22:07.194 
如今 當人們談到LINPACK

00:22:07.294 --> 00:22:09.429 
它們實際上不再構成阻礙

00:22:09.496 --> 00:22:13.200 
你可以隨意選擇所需的大矩陣
來顯示自己能實現多快的速度

00:22:13.834 --> 00:22:16.370 
當你看到超級計算機排名時

00:22:16.436 --> 00:22:18.305 
其中提供的LINPACK分數

00:22:18.372 --> 00:22:20.073 
都是百萬x百萬的量級

00:22:20.140 --> 00:22:22.176 
你儘可選擇讓你的速度可以最快的即可

00:22:23.610 --> 00:22:25.512 
幾周前 我在網上看到

00:22:26.046 --> 00:22:30.417 
有人在說iPad Air 2的速度
已經相當驚人

00:22:30.817 --> 00:22:35.856 
LINPACK可以實現每秒1.8個
十億次浮點運算 相當厲害

00:22:36.757 --> 00:22:39.793 
這可是每秒1.8個十億次浮點運算

00:22:40.894 --> 00:22:43.397 
我知道這個數據不高

00:22:43.797 --> 00:22:49.203 
有人編寫了簡單的程式來解決

00:22:49.269 --> 00:22:51.138 
就是用編譯器所能提供的內容

00:22:51.738 --> 00:22:53.874 
這就是實現的LINPACK分數

00:22:54.441 --> 00:22:58.979 
我在四周看了看
看到有人在認真優化他們的

00:22:59.346 --> 00:23:01.849 
LINPACK程式他們編寫了矢量代碼

00:23:01.982 --> 00:23:04.785 
做了隱藏層還有多線程

00:23:04.985 --> 00:23:08.455 
結果實現了LINPACK
每秒5.6個十億次浮點運算

00:23:08.989 --> 00:23:12.192 
這要快上3倍改進更多

00:23:13.160 --> 00:23:15.696 
不用再去做所有這些工作

00:23:16.663 --> 00:23:18.365 
只需要調用加速即可

00:23:18.565 --> 00:23:22.436 
在前面的幻燈片中
我展示了D獲取RS和LLA解析函數

00:23:22.936 --> 00:23:25.239 
你可以編寫一行代碼

00:23:29.810 --> 00:23:35.282 
如果這麼做 就可以實現
每秒25個十億次浮點運算

00:23:41.889 --> 00:23:43.891 
我們的確是想這麼做

00:23:43.957 --> 00:23:46.026 
我們就是想爲大家帶來便利

00:23:46.093 --> 00:23:48.962 
我們希望讓大家只需編寫一行代碼

00:23:49.162 --> 00:23:51.331 
而不是去着手優化每項內容

00:23:52.132 --> 00:23:55.502 
實現更好的能源利用更好的表現

00:23:55.569 --> 00:23:57.037 
而不需要做太多工作

00:23:58.038 --> 00:24:00.874 
現在有請盧克回到臺上 他會介紹

00:24:00.941 --> 00:24:03.544 
當矩陣非常巨大時你該怎麼做

00:24:06.747 --> 00:24:09.349 
謝謝 史蒂夫 我是盧克·常

00:24:09.650 --> 00:24:12.119 
是矢量數字組的工程師

00:24:12.553 --> 00:24:15.122 
今天我來談談
Sparse BLAS的內容

00:24:17.391 --> 00:24:20.794 
BLAS代表基礎線性代數解析程序

00:24:21.562 --> 00:24:24.831 
稀疏BLAS是稀疏矩陣的BLAS

00:24:25.666 --> 00:24:29.736 
這是iOS 9和OS X.11的新庫

00:24:31.004 --> 00:24:33.841 
它是爲簡單的API和優良性能而設計

00:24:34.308 --> 00:24:36.476 
可以支持單精度和雙精度

00:24:38.812 --> 00:24:40.480 
我們爲什麼需要稀疏BLAS?

00:24:41.281 --> 00:24:44.751 
我可以在已經瞭解具體工作方法的

00:24:45.118 --> 00:24:46.920 
稀疏BLAS上使用緊密BLAS嗎

00:24:47.554 --> 00:24:52.059 
對的 它可以對不大的矩陣提供維數

00:24:53.093 --> 00:24:56.563 
但是使用Sparse BLAS
在很多方面會更勝一籌

00:24:57.631 --> 00:24:58.832 
爲了說明這一點

00:24:59.800 --> 00:25:02.436 
我來給大家
展示一個典型的Sparse矩陣

00:25:03.170 --> 00:25:05.606 
這是機器學習的典型矩陣

00:25:06.039 --> 00:25:10.310 
有着1百萬行和20萬列

00:25:11.044 --> 00:25:14.648 
這就是提供了3000億次的輸入

00:25:15.649 --> 00:25:19.520 
但是矩陣的密度僅爲0.05%

00:25:20.721 --> 00:25:23.190 
這裏是視覺化稀疏矩陣的圖片

00:25:24.157 --> 00:25:26.326 
藍色部分越深密度就會越大

00:25:27.094 --> 00:25:29.930 
正如大家所見圖片上很多
區域都是白色的

00:25:30.531 --> 00:25:31.498 
這些都是零值

00:25:31.999 --> 00:25:34.067 
我們不希望把內存耗費在零值上

00:25:35.202 --> 00:25:37.971 
如果你是在常規的矩陣格式中

00:25:38.038 --> 00:25:39.740 
存儲這個稀疏矩陣

00:25:40.174 --> 00:25:42.442 
你就可以使用常規緊密的BLAS

00:25:43.177 --> 00:25:45.679 
假設這是單精度數字 則會

00:25:46.914 --> 00:25:51.385 
佔用1個太字節以上的內存這並不可行

00:25:52.085 --> 00:25:54.421 
你不會希望在手機和iPad上這麼做

00:25:57.090 --> 00:26:03.764 
這樣會節省內存此外稀疏BLAS 

00:26:03.830 --> 00:26:05.566 
還更節能速度更快

00:26:07.968 --> 00:26:13.273 
我們在MacBook Pro
衡量稀疏BLAS的性能13英寸

00:26:14.074 --> 00:26:17.511 
密度爲0.5%的稀疏

00:26:17.578 --> 00:26:22.182 
BLAS的能效要比緊密BLAS高18倍

00:26:23.383 --> 00:26:28.455 
性能方面要快15倍

00:26:29.923 --> 00:26:32.960 
隨着密度的下降性能會提高

00:26:34.661 --> 00:26:39.466 
在密度爲0.05%時
這是我們在之前的矩陣

00:26:40.033 --> 00:26:43.003 
看到的密度在能效和性能方面

00:26:43.070 --> 00:26:47.107 
會比使用常規
密度的BLAS高100倍

00:26:48.509 --> 00:26:50.444 
這樣大家看出使用稀疏BLAS

00:26:50.511 --> 00:26:54.681 
有着許多強有力的原因
節省內存能效更高速度更快

00:26:55.516 --> 00:26:57.584 
在稀疏BLAS中可以用到什麼？

00:26:58.886 --> 00:27:03.290 
我們有產品 三角解析
我們可以計算範數

00:27:03.824 --> 00:27:06.960 
L1 L2 L 無窮範數等等

00:27:07.995 --> 00:27:10.631 
我們會看到跡這是對角和

00:27:11.365 --> 00:27:15.869 
它可以交換行和列爲矩陣增加新值

00:27:16.003 --> 00:27:18.405 
從矩陣中提取行和列

00:27:19.940 --> 00:27:22.409 
在我介紹操作之前

00:27:22.676 --> 00:27:25.345 
我們來看如何保存稀疏矢量

00:27:26.613 --> 00:27:30.217 
正如我之前所說我們不希望把
內存浪費在零值上

00:27:30.517 --> 00:27:34.021 
我們保存非零值就像這樣

00:27:35.489 --> 00:27:39.359 
然後我們需要了解這些非零值從何而來

00:27:40.027 --> 00:27:42.596 
因此我們保存非零值的指數

00:27:43.630 --> 00:27:45.899 
最後 我們需要了解我們保存了多少

00:27:45.999 --> 00:27:48.035 
這就是非零值非零值的指數

00:27:49.136 --> 00:27:52.306 
這些是稀疏矢量需要保存的三項內容

00:27:54.141 --> 00:27:58.412 
爲了從常規密度矢量

00:27:58.478 --> 00:28:02.382 
轉化爲稀疏矢量
Sparse BLAS提供了效用函數

00:28:02.683 --> 00:28:03.917 
幫助完成轉化

00:28:04.585 --> 00:28:07.387 
如果想從密度專爲稀疏則需要調用壓縮

00:28:08.155 --> 00:28:09.990 
反之 則是需要調用解壓

00:28:10.891 --> 00:28:12.893 
如果你需要了解非零值的數量

00:28:12.960 --> 00:28:15.095 
可以調用獲取矢量非零值數量

00:28:16.363 --> 00:28:19.399 
現在我們來看稀疏矩陣怎麼保存呢？

00:28:20.400 --> 00:28:24.271 
我們可以將稀疏矩陣視作行的集合

00:28:24.671 --> 00:28:26.440 
或是列的集合

00:28:26.740 --> 00:28:30.143 
如果我們壓縮稀疏行稀疏列

00:28:30.978 --> 00:28:33.947 
或是忘記了行和列這就會非常亂

00:28:34.281 --> 00:28:37.584 
我希望將矩陣視作非零值列表 

00:28:37.751 --> 00:28:40.988 
每個非零值我們都會存儲

00:28:41.388 --> 00:28:42.789 
列索引和行索引

00:28:43.757 --> 00:28:46.994 
還有許多其他保存格式 

00:28:47.227 --> 00:28:49.763 
每種都有自己的優勢和不足

00:28:50.597 --> 00:28:52.766 
對於你所要進行的具體操作

00:28:52.900 --> 00:28:54.801 
可能會有最佳的保存格式

00:28:56.370 --> 00:28:58.305 
我們決定讓事情更容易些

00:28:59.506 --> 00:29:01.708 
我們定義了稀疏矩陣數據類型

00:29:02.910 --> 00:29:05.746 
這是個不透明指針如果你想用的話

00:29:05.812 --> 00:29:08.582 
必須先用創建函數來生成

00:29:09.149 --> 00:29:11.952 
並且可以對其進行操作做完之後

00:29:12.152 --> 00:29:13.020 
必須銷燬

00:29:14.221 --> 00:29:15.656 
這麼做的好處是

00:29:15.722 --> 00:29:17.991 
我們可以爲你管理內存

00:29:18.358 --> 00:29:20.527 
想在矩陣中添加新值時

00:29:20.594 --> 00:29:22.930 
你也不必擔心分配新內存

00:29:23.363 --> 00:29:27.034 
或重新調整緩衝區或最後釋放緩衝區

00:29:27.267 --> 00:29:28.101 
我們來做這些

00:29:29.603 --> 00:29:33.040 
更好的是我們可以選擇最好的保存格式

00:29:33.707 --> 00:29:36.877 
例如如果你在稀疏矩陣中

00:29:36.944 --> 00:29:39.980 
插入一組行我們會按照稀疏行來保存

00:29:40.747 --> 00:29:45.452 
當你插入一組列時我們會
按照稀疏列來保存

00:29:46.320 --> 00:29:49.156 
如果你想做特殊的操作

00:29:49.223 --> 00:29:54.294 
還有最好的保存格式
我們也會自動轉化爲該格式

00:29:55.429 --> 00:29:58.765 
最後 這會讓我們在API中

00:29:58.832 --> 00:30:01.635 
隱藏維數細節讓API更爲乾淨

00:30:02.703 --> 00:30:04.605 
當你調用稀疏函數時

00:30:04.671 --> 00:30:08.308 
你不必每次傳遞稀疏矩陣的維數

00:30:09.776 --> 00:30:10.811 
這裏是個示例

00:30:12.379 --> 00:30:14.381 
首先創建稀疏矩陣

00:30:16.016 --> 00:30:18.986 
然後你會在稀疏矩陣中插入一個值

00:30:19.553 --> 00:30:23.857 
或是插入稀疏矢量作爲行或列

00:30:25.125 --> 00:30:27.661 
然後提交稀疏矩陣的更改

00:30:27.895 --> 00:30:31.298 
在下一個幻燈片中
我來講詳細介紹提交函數

00:30:32.366 --> 00:30:34.034 
完成之後要調用銷燬

00:30:35.302 --> 00:30:37.571 
好的 爲什麼需要提交函數？

00:30:39.006 --> 00:30:44.144 
數據插入造價很高因爲
我們以壓縮格式保存值

00:30:44.778 --> 00:30:47.614 
每次你需要在涉及數據移動的

00:30:48.015 --> 00:30:49.850 
壓縮存儲中

00:30:50.250 --> 00:30:53.754 
加入值就會涉及更多
內存分配這樣造價很高

00:30:54.821 --> 00:30:58.559 
我們需要延遲所有的數據插入
這樣可以分批處理

00:31:01.228 --> 00:31:04.731 
好消息是即便你忘記調用提交函數

00:31:05.432 --> 00:31:07.568 
當你在矩陣中進行操作時 

00:31:08.035 --> 00:31:10.037 
提交函數也會自動啓動

00:31:10.704 --> 00:31:13.173 
現在你可能會問爲什麼要用提交函數?

00:31:14.541 --> 00:31:16.910 
如果想要控制代碼性能

00:31:17.578 --> 00:31:20.113 
你顯然要用到提交函數

00:31:20.681 --> 00:31:24.384 
加入你在app啓動期間

00:31:24.451 --> 00:31:27.588 
讓稀疏矩陣就緒這樣app可以對

00:31:27.654 --> 00:31:29.823 
用戶的數據 儘快做出反應

00:31:30.724 --> 00:31:34.228 
那麼就要在啓動代碼中加入提交函數

00:31:35.162 --> 00:31:35.996 
這樣相當好用

00:31:37.197 --> 00:31:40.033 
好 考慮到時間問題
我只介紹稀疏BLAS中

00:31:40.100 --> 00:31:42.903 
最常見的兩個操作

00:31:43.537 --> 00:31:46.173 
第一個是乘積C=AxB

00:31:46.840 --> 00:31:49.776 
我們支持矢量內積 矢量外積

00:31:50.310 --> 00:31:52.946 
矩陣矢量乘積矩陣矩陣乘積

00:31:54.014 --> 00:31:55.883 
A B C的類型是什麼？

00:31:56.250 --> 00:32:01.555 
對於內積A是稀疏B
爲稀疏或緊密C爲單一值

00:32:02.489 --> 00:32:05.559 
對於外積 A爲緊密B爲稀疏

00:32:05.826 --> 00:32:08.161 
結果C是稀疏矩陣

00:32:08.962 --> 00:32:11.265 
對於矩陣矢量和矩陣矩陣乘積

00:32:11.498 --> 00:32:14.034 
A爲稀疏 B爲緊密C爲稀疏

00:32:15.135 --> 00:32:18.539 
你需要兩個稀疏矩陣
乘積的情況非常罕見

00:32:18.605 --> 00:32:19.573 
因此不做支持

00:32:21.441 --> 00:32:24.778 
這裏是矩陣乘積的
函數原型

00:32:26.146 --> 00:32:28.148 
稀疏函數的命名規則是先

00:32:28.415 --> 00:32:33.787 
是下劃線稀疏後面是我們要做的
操作在本例中是矩陣相乘

00:32:34.888 --> 00:32:38.225 
緊密是指BC爲緊密浮點是數據類型

00:32:39.193 --> 00:32:42.162 
你將會返回成功或錯誤代碼

00:32:42.963 --> 00:32:45.933 
這個函數的參數正如常規BLAS

00:32:46.033 --> 00:32:49.536 
你規定B和C的次序是列主序或行主序

00:32:49.770 --> 00:32:52.005 
你來表示自己是否需要將A換位

00:32:52.773 --> 00:32:55.909 
B和C的列數 其餘則和BLAS一樣

00:32:57.711 --> 00:33:00.480 
下一個操作是三角解析

00:33:01.148 --> 00:33:03.183 
你來爲三角系統等式求解

00:33:03.750 --> 00:33:08.121 
T必須是上或下三角矩陣

00:33:09.189 --> 00:33:13.927 
我們支持緊密緊密矢量或B矩陣

00:33:15.295 --> 00:33:17.731 
主要注意的是上或下三角

00:33:17.798 --> 00:33:22.135 
屬性必須在進行數據插入前設置

00:33:23.036 --> 00:33:24.638 
這裏的代碼就是強調這一點

00:33:25.639 --> 00:33:29.309 
設置矩陣屬性需要在進行
任何數據插入前完成

00:33:29.810 --> 00:33:32.346 
在數據插入後可以調用三角求解

00:33:32.813 --> 00:33:35.682 
參數則和BLAS一樣

00:33:38.185 --> 00:33:42.756 
總之稀疏BLAS
是和簡單API一起設計

00:33:42.990 --> 00:33:45.158 
它有着非常廣的操作範圍

00:33:45.626 --> 00:33:46.894 
性能也很好

00:33:48.195 --> 00:33:50.831 
好的現在就來總結一下講座內容

00:33:51.765 --> 00:33:53.934 
我們今天介紹了三個新庫

00:33:54.635 --> 00:33:58.605 
用我們的新壓縮器LZFSE進行壓縮

00:33:59.673 --> 00:34:01.575 
現在 你可以在Swift上

00:34:02.109 --> 00:34:04.144 
使用SIMD還有稀疏BLAS庫

00:34:05.445 --> 00:34:07.214 
它們有着共同的設計目標

00:34:07.848 --> 00:34:11.717 
都是速度更快能效高便於使用

00:34:12.186 --> 00:34:15.455 
我們鼓勵大家試一試
讓我們知道你們是怎麼想的

00:34:16.489 --> 00:34:17.791 
我們很希望能聽到大家的反饋

00:34:18.958 --> 00:34:22.529 
我們對開發人員的要求
和反饋都認真對待

00:34:22.763 --> 00:34:25.431 
實際上 我們添加到
加速框架中的許多功能

00:34:25.498 --> 00:34:30.070 
都是根據開發人員的要求進行的

00:34:30.469 --> 00:34:33.507 
如果你發現自己想用的功能沒有

00:34:33.841 --> 00:34:35.208 
請填寫功能申請

00:34:36.909 --> 00:34:39.612 
若想了解更多詳情我們還有vDSP和

00:34:39.679 --> 00:34:41.481 
壓縮的在線文檔資料

00:34:42.014 --> 00:34:45.518 
如果想了解加速框架的其他內容

00:34:45.853 --> 00:34:49.188 
可以看看我們以往的WWDC講座視頻

00:34:50.724 --> 00:34:53.659 
我們還有壓縮vDSP的簡單代碼

00:34:54.094 --> 00:34:56.230 
還可以參加論壇討論

00:34:56.663 --> 00:35:01.134 
如果是一般性諮詢
可以聯繫開發顧問保羅·登博

00:35:02.536 --> 00:35:06.106 
這裏就是相關講座
我們介紹過I/0模型

00:35:06.273 --> 00:35:08.976 
Metal Swift 如果想
瞭解更多詳情

00:35:09.243 --> 00:35:12.012 
可以去找這些講座的視頻看看

00:35:12.513 --> 00:35:13.347 
就是這樣

00:35:13.580 --> 00:35:15.983 
感謝大家光臨 希望在實驗室見到大家

00:35:16.149 --> 00:35:16.984 
非常感謝！