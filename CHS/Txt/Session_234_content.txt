构建基于文档的app
谢谢
下午好
我是迈克·赫斯一名来自iOSApps和框架团队的软件工程师
今天我和约翰尼斯·福特曼一起
在这里给大家讲讲怎样让你的基于文档的app脱颖而出
今天我们给你们写了一些示例代码会展示给你们
如何构建一个基于文档的app的两个主要元件
首先我们要向你演示如何构建一个很棒的“文档浏览器”
这样你的用户就可以很快找到他们感兴趣的文档
需要处理的文档
其次我们要向你们演示如何构建一个能够和文档正确进行交互
协调处理并发阅读程序和写入程序比如iCloud驱动守护进程
这样一个很棒的文档编辑器
我们稍后会深入讲一下iCloud驱动守护进程
首先我们来看看“文档浏览器”
那么什么是基于文档的app？
我们认为一个文档就是一个单一的独立的实体
用户也把它理解为一个单一的实体
那么基于文档的app就是一个能够管理这些文档列表、
把文档展示给用户以便用户对它们进行
查看 编辑 重命名的这样一个app
比如说Keynote就可以对Keynote文档列表
进行管理
而Numbers这个应用程序就可以管理Numbers电子表格文档列表
就连Garage Band也可以对Garage Band歌曲文档进行管理
我们把这些都看作基于文档的app
现在我们就来深入讲一讲我们如何构建我们的“文档浏览器”
一个很棒的“文档浏览器”有四个主要元件
首先我们希望能够以对我们的用户
有意义的方式列出我们的文档就像我们在这个
示例代码中这样根据文档名对文档进行了分类
我们的用户就可以理解我们的app的流程
其次我们认为你应该使用缩略图这样文档可见性
可以很棒你的用户只需要一瞥
就可以快速找出他们感兴趣的文档
需要处理的文档
第三我们想要展示我们的app中所有可用的文档
包括位于其它app的容器内的文档
比如示例中的这个文档它是位于
共享iCloud Drive容器上
第四，我们认为保存一个最近访问的文档列表
是个不错的主意这样用户就可以快速返回
他们当前正在处理的文档
现在我们看看怎样找出我们的
“文档浏览器”上的文档
一个笨办法可能是使用NSFileManager尝试列出
你在云端的文档
但是这些结果是不完整的
比如说在iCloud有一个文档的概念
文档位于那里 但是内容还没有实现
本地可见的文档就是说
还没有下载到磁盘上的文档
NSFileManager并不能正确获得这些文档
此外如果你试图通过NSFileManager来列出你的文档
那么外部文档就不会包括进来
那么你列出的也就不是你的app可用的所有的文档
我们来快速看一下
假如说你用的是NSFileManager API
如果你用的是NSFileManager你可能会获得文档一
以及这里的文档二它们都已经完整下载到了
我们的app的容器的硬盘上
但是你遗漏了位于iCloud的
文档三这个文档
并且你也遗漏了位于另一个app容器上的文档四
而我们的用户已经授予了你的app访问那个文档的权限
因此当你列出你的文档时你肯定不会想用NSFileManager API
你想用的肯定是NSMetadataQuery
我们来看看NSMetadataQuery的工作原理
NSMetadataQuery会获得所有你的app可用的文档
包括位于iCloud的文档三
以及位于另一个app的容器但是用户已经授权了我们的
app查看那个文档权限的文档四
重点要注意的是这里还有个文档五同样位于另一个app的容器
但是用户并未授予我们的app查看那个文档的权限
文档五并没有包括在NSMetadataQuery结果中
因为如果我们把那个文档展示给用户
那就构成了隐私泄漏
让我们用NSMetadataQuery
找出我们位于云端的文档
那么流程是怎样的呢？
首先你要创建你的NSMetadataQuery
然后NSMetadataQuery就会经过一个初始收集阶段
列出所有当前对你的app可用的文档
初始收集阶段完成后
你会得到一条通知然后你只需要在你的app的UI
主线程上把这些初始文档显示出来就可以了
但是NSMetadataQuery并不是到此就完事了
此外当云端状态发生变更时你会收到更新通知
比如在这里iCloud Drive守护程序
向我们的app的容器内下载了一个新文档
我们就在我们的NSMetadataQuery
上收到了关于这个文档的通知
然后你只需要计算变更动画
比如在这里我们可能想要向我们的CollectionView
插入一个CollectionView单元
然后只需要把这个更新过的UI显示在我们的主线程上
既然我们已经知道了怎样找出我们的文档
我们再来看看怎样用文档缩略图
让我们的UI更棒
我们认为在你的UI显示缩略图是一个不错的主意
因为它可以给你的用户提供视觉语境
这样你的用户只需要一瞥就可以找到他们感兴趣的文档
需要处理的文档因为他们有了不错的缩略图
他们就可以很快找到文档
iOS 9上有项新特性会自动为你创建某些特定的
通用文档类型的缩略图
比如说大的图像文件举个例子
现在我们再来看看你加载你的缩略图
显示在你的app的UI的工作流程
这里要重点注意的是
加载缩略图涉及向内存中加载数量可能很大的数据
可能会很慢因此加载你的缩略图数据时你肯定不想阻塞你的主线程
首先让我们看一个工作流程实例应该可以
这就是我们的示例代码app的工作流程
首先在我们的示例代码中我们有一个CollectionView
CollectionView让我们加载一个CollectionView单元
我们要通过一个后台进程安排读取缩略图
因为我们尚未缓存完毕缩略图
现在我们并不会等待完成读取缩略图
我们要立即返回一个带有占位图像的
CollectionView单元这样用户就知道那里有图像
之后某个时间完成读取缩略图后
我们会通知我们的CollectionView
需要重新加载那个单元
然后我们只要在我们的UI的那个单元上显示我们的缩略图就可以了
好的 然我们已经知道了怎样找出文档怎样用漂亮的缩略图
把它们显示出来我们再来看看怎样管理最近列表
我们认为你可能想用最近列表
因为最近访问的文档通常就是用户
正在处理的文档
因此存储这些文档的这样一个列表是个不错的主意
这样你的用户就可以快速返回文档中
同样地一个笨办法可能是使用NSURLs来存储一个
最近访问的文档的最近列表
但是像之前NSFileManager已经出现的那样
这样有很多缺陷
我们来快速看一下
假如说我们向最近访问的文档存储一个NSURLs列表
但是在我们的app不运行时iCloud Drive守护程序移动了文档
比如像这样移动到了一个新文件夹
现在NSURL就成了一个受损引用没法解算我们的文档
在磁盘上更改后的位置
因此我们不能靠它来存储我们的最近列表
存储最近列表的正确方法是使用安全范围书签
这里如果我们向这个文档存储了一个安全范围书签
而iCloud Drive守护程序再次把这个文档
移动到了一个文件夹那么书签就会自动更新
解算文档在磁盘上的新位置因此当我们管理我们的最近列表时
我们应该使用安全范围书签
我想快速做个演示
看看我们如何管理我们的最近列表
如何加载缩略图
好的让我们在这里启动我们的示例代码
我们尚未向我们的app中加载缩略图
但是举例来说如果我使用新的多任务处理
功能打开iCloud Driveapp 我们就可以看到
这些文档的缩略图已经在那里了
我们只需要加载它们显示到我们的app的UI上即可
我们来看看它在代码中是什么样的
好的 首先我们来讲讲如何在代码中管理我们的最近列表
这里有件重要的事情
当我们在这里保存对象时我们使用了
“标记带有选项数据”的方法来进行标记
这里重要的是要传递“适合标记文档”选项
这样我们就可以稍后进行解算
我们的app启动后我们使用书签
调用了“经由解算标记数据”NSURL构造符方法
这是我们之前保存的然后我们得到了一个URL
就是我们的文档在磁盘上的更新后的位置
这里重要的是有了这个返回的URL
我们需要调用“开始访问资源的安全范围”
防止这个文档是另一个app的容器内的文档
否则我们就无法读取这个文档因为...这个文档的读属性
因为这样就会让我们的沙盒
访问到这个文档
那么对于缩略图来说我们已经为你在示例代码中
写好了这个很棒的缩略图缓存类
可以为我们的app缓存我们的缩略图
这会让我们如释重负
比如调度在后台进程中加载缩略图等等
然后通知我们的CollectionView
我们需要重新加载单元
我们最后一个没有实现的
是这里的这个代码块
它会从磁盘上加载我们的缩略图
我们只需要在带有一个缩略图字典键的URL上
调用“获取键的承诺项目资源值”这个NSURL方法
然后我们就会得到一本缩略图字典
然后我们只需要从字典上抽出UIImage然后把它返回到
我们的缩略图类这样我们就可以显示它
这里重要的是使用“获取键的承诺项目资源值”
来代替“获取键的资源值”
因为文档可能还没有实现内容本地可用
这样即使尚未下载我们也可以展示我们的缩略图
我们需要做的就是重新部署下
这样我们的app里就有了一些很棒的缩略图
是在后台加载的这样当我们示例代码中
滚动时它们就不会阻塞我们的滚动
好的让我们回到幻灯片
关于构建一个“文档浏览器”我们学到了什么？
首先我们学到了我们应该使用
NSMetadataQuery而不是其它方法来找出我们的文档
这样我们就可以找到所有我们的app可用的文档
其次我们学到了我们应该在我们的app的UI展示缩略图
这样我们就可以构建一些很棒的UI
我们的用户也可以很快找到他们正在处理的文档
最后我们学到了我们应该使用书签
而不是其它方法来存储我们的最近列表
这样用户就可以快速回到
他们正在处理的文档
那么我想请约翰尼斯·福特曼上台来
给你们讲讲如何构建文档编辑器
谢谢 迈克
迈克刚才向你们展示了
如何在你的应用程序内构建一个漂亮的“文档浏览器”
当然这会让我们的app非常漂亮
但是同等重要的
甚至可能更重要的是你的应用程序中
你的用户可以加载编辑文档的那一部分
毕竟用户就是为了这个目的而试图使用你的应用程序
在我们开始讲整个加载写入变更文档之前
我们先来快速看看一个叫做
文件的协调性的概念
我在这里讲的是什么？
在我们新的现代基于多任务处理的世界中
这个概念指的是多个app访问显示同一文件
举个例子我们可以在iCloudDrive app显示
你的文档容器内的全部文件的概述的同时
让你的app运行并且让用户编辑这个文档
或者还有一种更保守的方法
即使你的用户没有使用这个两个在前多任务处理视图
也可能经常出现iCloudDrive同步守护程序
可能想要访问这个文档进行云端同步
而同时你的用户正在编辑这个文档
实际上这是一种非常常见的情况
因为用户正在编辑这个文档
他们把这个文档保存到了磁盘
这个文档当然就发生了变化因此iCloud Drive守护程序
就想确保它在云端也进行更新了
因此这是一种常见的情况
我们来看看你的用户正在磁盘上
编辑这个文档这一具体案例
当然你的app看起来正在运行中
用户正在进行编辑
同时你的应用程序正在
自动保存定期把这个文档写入磁盘
这样我们在某一时刻有一个写入操作
然后之后某个时刻我们又有用户编辑
变更文档的这样一个操作然后我们又有一个写入操作
很好 我们假设在某个时刻我们的用户充分利用了
这个多任务处理功能也就是说
当他们编辑这个文档时他们还同时
运行着另外一个应用程序
这个其它应用程序可能之前对这个文档有一个引用
并不会立即进行状态恢复
举例来说即试图从磁盘上读取这个文档
现在你可以看到这种情况很糟糕
因为当我们读取这个文档时同时还有
另外一个应用程序对它进行写入操作
这实际上就是我们的应用程序
我们得到的就是这个不一致的读取
当然这很不幸
我们正在写入这个文档但是同时
另一个应用程序又正在读取这个文档
数据仅仅写了一半到磁盘另一半还没有写入
出现这种怪异的不一致的数据时
其它app可能就不知道应该怎么做
这种情况很糟糕
同样地即使我们设法挺了过去
我们第二次写入后别忘了
我们现在仍然正在第一个应用程序中编辑这个文档
其它应用程序现在仍然正在显示你的文档
其它应用程序现在正在显示你的文档的旧版本
我们就遇到了过时显示这样一个问题
当然出现这种情况很不幸
这里我们给你们准备了两个方便的解决方法
首先我们有了这个文件的协调性的概念
文件的协调性是一种分布式阅读程序/写入程序加锁机制
这就意味着虽然任何时候多个阅读程序
都可以读取同一个文档但是每次却只能有一个写入程序
这个写入程序会禁止其它任何阅读程序进行读取
这就意味着如果我们的应用程序
就像使用UIDocument那样使用正确的文件的协调性
这些机制就会生效
我们的读取操作就会被推迟到我们的写入操作完成后
这样我们就能始终保持
这个文档一致的形象
非常棒
我向你们保证这里还有一个机制
这里的这个机制是NSFilePresentation
NSFilePresentation是一种分布式修改机制
这就意味着我们的文件的协调性会
自动告诉所有其它的文件提出器
你的文档已经登记过了已经写入了磁盘
文件提出器需要对自身进行更新
这样在我们的第二次写入后我们就可以立即得到一个通知
我们就可以放心地更新我们的UI了
很好我们就是这样来确认我们的文档总是保存一致的形象
但是文档是什么？
当然我们首先需要创建一些文档
这样才可以显示文档让用户编辑文档
我们来看看这个
我们创建这些文档的目的是什么？
让我们想象下当我们实现我们的示例app时
我们在右上角有这样一个小的“加号”按钮
这是个加号按钮用户点击下
我们可能会弹出一个示例对话或是类似的东西
不过我们总会在某个时刻创建一个文档
在这里我们的主要目的是
给用户一个一致的显示
并且这个显示总是最新的
如果用户点击这个小加号按钮那就没什么大用
我们现在并不会在我们的“文档浏览器”内得到更新
用户就会困惑不解不知道发生了什么
用户可能会再点击几次这个加号按钮
现在我们有了五个不同的新文档这可不太妙
如果不使用文件的协调性我们最后就可能出现
现在这种情况当然了这是因为...
这就意味着我们在磁盘上创建了一个文档
之后某个时刻iCloudDrive守护程序注意到了
这个新文档然后通知我们的app
这个延迟可能在半秒左右
如果守护程序现在正忙延迟时间可能会更长
我们正是想要避免这种延迟
如果你使用文件的协调性那现在就很方便了
会直接替你完成
协同运行会与你用来在你的浏览器中显示文档的
NSMetadataQuery一起
协力也就是在协调完成后
进行回路循环立即告诉
你正在运行的查询出现了
一个新的更新后的文档
这样我们就干掉了这个令人厌恶的延迟
当然这里还是要提醒你们一件事
因为我们是在磁盘上进行写入
无论我们往磁盘上写入什么都需要时间
当然了在主线程上执行任何需要
时间的操作都很不幸
因为它会阻塞主线程让你的应用程序在用户看来
就像成了一个结巴
当然了解决这个也很容易
我们要使用一个后台进程
来发送这一协同运行来确保
我们的操作不会阻塞主线程
幸运的是我们仍然...
因为我们仍然在用这个协同运行
我们就仍然可以在我们的UI上得到立即更新的显示
这是因为我们的NSMetadataQuery
仍然是直接更新的
你甚至都不需要把这个信息弹回给主线程
这是因为我们是在直接更新
NSMetadataQuery
很好 另一个常用的操作是删除某个文档
对于你的用户来说这是再正常不过的事
这个文档他们不用了他们想把这个文档删掉
这样就不会弄乱他们的工作区
删除文档背后的基本理念仍然是一模一样的
我们会通过我们的后台线程协调某个写入操作
在本次写入时执行删除操作然后通过NSMetadataQuery
回送给主线程及时进行更新
很好 你就是这样通过你们的后台进程对创建删除文档进行管理的
我们来看看你到底想用这些文档干什么
当然你想显示这些文档
也就是说你想读写这些文档
现在我们强烈推荐你使用
UIDocument来读写文档
UIDocument会实现NSFileCoordination调用
这样可以确保你在任何时候进行读写文档时
都是以一种协调的方式进行
此外它还会实现NSFilePresentation
确保会立即通知这个文档发生了变更
可以在你的显示中立即更新了
我们来看看怎样读取一个文档
你创建一个UIDocument对象然后在这个UIDocument实例中
简单调用这个“完成后打开”方法
这种方法会通过一个后台工作队列
取出一个协调读取
这样你的应用程序就可以保持完美的性能和响应性
同时你的文档可以对自身进行读入
那么现在你需要做的
就是实现“通过内容载入”这个方法
这种方法会在协调读入中简单调用
因此就被这个协调读入给封装了
这就意味着在那里读入任何你想要的东西
都是绝对安全的 请听清楚是来自那个文档
那么你需要做的就是取出内容
然后把它们填入你的文档数据
现在这里还有一种方法
你也可以选择实现这种方法
它会取出一个NSURL而不是一大堆数据
你也可以把这个方法用于举例来说流文档
有时候你可能更有理由这么做
这是因为举例来说磁盘上的文档格式与你在内存中想要的格式完全不同
完成后我们只需要回送给主队列
然后调用你提供给我们的完成块
在那个完成块中你可以举例来说
为你的文档推送更新你的新界面
很好读入一个文档的原理就是这样的
不过别忘了麦克告诉过你们
这个概念叫做“约定”
一项“约定”指的是iCloud Drive守护程序允诺给你的app
某个文档就在那里但是还没有进行下载
这就意味着对这个文档进行读入
就可能会触发一次下载
当然了如果你像我们一样
生活在真实的世界中很明显下载有时候会很慢
依据你的文档大小下载可能
需要一段时间
你的用户可能把这次下载归咎于你的app出了问题
这很不公平这不是你的错
本次下载所处的网络连接很慢需要一点时间
我们在iOS 9中为你准备了一项新特性我们公开了一种通过
新的NSProgressReporting协议
在UIDocuments上显示进度的方法
实现这个非常简单
NSProgressReporting协议在你的UIDocument实例上公开了一项
进度属性这项进度属性是我们填写的显示给你我们的进度如何了
基本上这就是下载状态的一项简单的百分比
我们现在通过一个状态变换公开了这项NSProgress属性
这样你就可以把它显示为你在你的文档状态上
监听到的状态变换通知
当状态发生变换时你就可以看到带有下列内容的新标志
“你好我在这里公开了一条进度”
然后你只要显示这个进度就可以了
举例来说在一个UIProgress视图上显示一个进度
过去往往比较复杂
这是因为它公开了一项你需要把值观测键入
这个进度视图的属性
当然我们也意识到了这一点还是在iOS 9上
我们在UIProgress视图新公开了一项观测进度属性
你就可以直接把NSProgress弄到进度视图
你只需要把NSProgress分配给
进度视图的“观测进度”属性
它就会自动更新它的计数
对你来说这非常方便
谢谢 那么你只需要监听下次状态变换
监听这样的信号：“你好我们把这个进度搞完了”
此时你可能想取消显示你的UIProgress视图
准备显示新的文档控制器
很好 这就是读入文档
当然我们还想写入文档
写入文档和读入文档是对称的
我们写入文档的方式就是在一条后台进程上
取出一个协调文件的协调性
这个略微有点不同不是由你来启动它
而是由UIDocument自动通知说现在非常适合
保存文档
比如说因为有一阵没有编辑进来
或者因为文档上次保存后已经过去了一段时间
或者因为用户把你的应用程序放到了后台
那么这个时候保存文档就非常合适
不过这种实现方式和读入一个文档是非常
对称的我们只需要在你的UIDocument实例上
调用“类型内容”
然后你把你从那里返回的NSData实例填进去
非常好 这里还有一件事
此时写入一幅缩略图也非常方便
正如麦克告诉你们的我们会为某些非常特定的文档
格式自动生成缩略图不过有很大几率你正在构建的东西
和我们正在构建的东西并不完全一致
因此如果你没有使用我们的非常通用的格式来
进行构建像图像或者简单文本
那么你就想自己写入缩略图
现在你这样实现的方式
我们称之为在你的UIDocument上
“自行写入文件属性”方法
使用这种方法你只需要当成你的属性字典的一部分
返回一个UIImage实例
在这个实例中我们会在写入你的文档
包含于同一协调写入上进行写入
这就意味着如果此时用户
在一个单独的窗格中打开了“文档浏览器”
他们就不会看到不一致的状态
很好 这里重点需要记住的是这是在一条后台进程上调用的
这就意味着在任何情况下
你都不能用UIViews来写入...来渲染你的缩略图
UIViews不属于线程安全因此你需要确保你的缩略图
渲染是通过举例来说
Core Graphics或者textKit
或者任何其它我们在我们的平台上提供的线程安全渲染机制来进行
在iOS 8上访问一个文档的唯一机制是通过一个副本来访问
原因在于一般来说应用程序
不能访问彼此的沙盒
因此如果我们有两个应用程序沙盒那么从一个沙盒
移动到另一个沙盒的唯一方式就是第一个应用程序
在另一个应用程序的沙盒内生成一个副本
现在通过使用UIDocument菜单视图控制器我们就可以松口气了
它允许你的应用程序在另一个应用程序的容器内进行拉取
不过一般来说你不会仅仅打开一个文档就算了
每次打开这个文档都会生成一个副本
当然 处理这些副本就非常方便了
因为你现在其它应用程序的容器内有一个你的
文档的副本用户会对它进行修改
这样你就会得到这个文档的第二个版本
现在举例来说回到你的应用程序中
用户想打开这个文档
这样就会生成第三个副本
现在漂浮着的你有文档的三个不同的版本
这很不幸因为用户会感到困惑不解
不知道哪个版本是最近的版本
这种情况可不太妙
现在在iOS 9中我们有了这个漂亮的新机制
叫做“就地打开”
这意味着通过使用文档交互控制器
你的应用程序可以授予另一个应用程序
访问一个文档的权限
文档还是一模一样的
这不是一个副本而是对这个文档的一个副本
当然了这就意味着另一个应用程序就可以进行编辑
然后通过展示文件这一魔法
直接反射到你的应用程序中
当然了这对用户来说就非常方便
这包括通过iCloud Driveapp以及通过Spotlight
打开的文件
这就意味着你的用户任何时候在iCloud Drive app中
浏览他们的文档时我们就可以直接就地打开那个文档
这个背后的机制和“文档菜单视图控制器”
中使用的机制非常相似
这就意味着如果你的应用程序已经对此提供支持了
那么对你来说支持这种机制就不费吹灰之力
即使你现在不支持UIMenuViewController
采用这种机制也不费吹灰之力
因为这并不是多么神奇的东西
你获得一个URL后
就把它放入你稍后将要展示的一个UIDocument实例中 
我们现在来快速看看你怎样可以对此提供支持
就像我之前说的非常简单
首先你要告诉我们你对此提供支持了
记住当我们试图找出我们是否要
就地打开这个文件时你的app可能在那时并不会启动
因此你要事先告诉我们
你需要在你的Info.plist中采用“LS支持就地打开文档”
这个键来告知我们
根据你用的是Objective-C还是Swift不同
你只需要把它设置成为“是”或者“真”即可
这样就可以告诉我们你的应用程序可以处理这个了
你还需要再写一点代码
是一种新的委托方法
那个看起来怎么样？
假如说你已经在这里打开了文档
这样假设很合理这是因为你的app是基于文档的
因此你实现的方法肯定就和我们在这里看到的非常类似
现在你的方法肯定得到了一个NSURL
因为这个NSURL是系统为你的app创建的
临时副本你就需要把这个副本复制到
你自己的容器然后打开这个复制文件
这一小块代码的作用就是这个
现在首先要做的是在这里采用我们的新方法
这种新方法和旧方法非常相似
它只是取得了一本选项字典
对之前的方法的参数进行封装
重要的是其中的一个参数是“就地打开”键
现在你要做的，就是看看这个“就地打开”键
是否为真如果这个键为真
那么你的应用程序应该就可以就地打开这个文件了
这就意味着它不应该生成副本
很简单你不应该再做你之前不得不做的事了
现在你有了这个URL
你只需要照着之前的打开方式打开它就可以了
支持就地打开就是这么简单
很好 我们来总结下今天学到的东西
我们已经看过了怎样让你的app性能响应性很高
看过了使用NSMetadataQuery来展示一组文档并且当云端
有变更发生时及时更新这些文档
这种方法有多么漂亮
我们还看到了怎样使用书签来实现最近访问机制
这样你的用户就可以很快返回
他们之前的状态...他们之前所处的文档
当然有些事情我们没有说
但是也非常合理
即你也可以使用书签来实现状态恢复
这样你的用户就可以直接返回他们之前所处的状态
我们还看到了怎样使用缩略图让你的应用程序非常美观
看到了怎样实现进度显示确保你的用户
始终清楚在他们的应用程序内发生了什么
最后我们也看到了实现就地打开有多么容易
就地打开是个很棒的新机制你的用户就可以直接在
你的应用程序内打开文档
而不用复制多份副本
我们今天发布的一个示例代码对所有的这些概念
都做了一个漂亮的展示
这个示例代码实际上就是麦克之前在演示中
向你们演示的那个
它实现了所有的这些特征特性
即在一个“文档浏览器”中创建文档
展示文档生成这些文档的变更动画
当然还有写入缩略图当然还有就地打开
如果你需要获得技术支持我们建议你去我们的论坛
你可以看到在这个链接下面我们也有很棒的资料
如果你想了解关于使用“UIDocument菜单视图控制器”
的更多信息
来实现拉取机制，而不是就地打开工具的拉取机制
这样你的应用程序就可以从另一个应用程序的容器内拉取文档
或者你对如何实现基于UIDocument的应用程序略感兴趣
我们建议你观看我们去年的会议
即去年的会议234
当然你在网上也找得到
那么谢谢你抽出时间参会
祝你下午过得愉快