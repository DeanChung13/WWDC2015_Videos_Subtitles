00:00:20.053 --> 00:00:22.823 
Metal技術最新內容 第一部分

00:00:31.064 --> 00:00:31.899 
下午好

00:00:32.499 --> 00:00:33.867 
歡迎來到WWDC 2015

00:00:40.040 --> 00:00:40.874 
歡迎參加

00:00:40.941 --> 00:00:42.843 
《Metal技術最新內容》
講座的上半場

00:00:44.411 --> 00:00:46.914 
本週的三次講座中

00:00:46.980 --> 00:00:48.482 
有許多Metal的內容

00:00:49.550 --> 00:00:51.919 
實際上 我們已經
在API中加入很多新內容

00:00:51.985 --> 00:00:54.288 
所以決定要把
《Metal技術的最新內容》

00:00:54.354 --> 00:00:56.456 
講座分爲兩部分

00:00:58.258 --> 00:00:59.293 
那麼今天

00:00:59.359 --> 00:01:01.929 
我主要
對過去12個月的Metal

00:01:02.196 --> 00:01:05.331 
生態系統進行
扼要回顧

00:01:06.466 --> 00:01:09.536 
像諸位這樣的開發人員
已經運用Metal

00:01:09.603 --> 00:01:10.904 
創造了很多應用

00:01:12.639 --> 00:01:14.541 
我會介紹我們
今年推出的

00:01:14.842 --> 00:01:16.076 
部分新功能

00:01:16.910 --> 00:01:18.912 
最後 我們會
通過具體實例

00:01:19.213 --> 00:01:21.048 
介紹
app瘦身技術

00:01:21.181 --> 00:01:22.349 
將Metal如何與

00:01:22.749 --> 00:01:25.352 
系統的其他部分
相整合

00:01:28.589 --> 00:01:30.691 
在下半場《Metal
技術最新內容》講座中

00:01:30.757 --> 00:01:32.960 
丹·大汀和安娜·蒂科諾娃

00:01:33.026 --> 00:01:34.361 
將詳細介紹今年

00:01:34.661 --> 00:01:36.763 
我們用Metal新推出的

00:01:36.830 --> 00:01:38.699 
一款非常棒的支持庫

00:01:39.666 --> 00:01:41.535 
或是兩個
這樣的支持庫

00:01:42.503 --> 00:01:45.906 
MetalKit可爲API
提供便捷

00:01:45.973 --> 00:01:48.575 
讓你可以生成出色的
Metal應用

00:01:49.576 --> 00:01:51.945 
和MetalPerformance
Shaders

00:01:52.279 --> 00:01:54.715 
我們高度優化的着色器庫

00:01:55.082 --> 00:01:57.885 
可以直接從
應用調用

00:02:00.754 --> 00:02:02.923 
最後 在後一場講座中

00:02:02.990 --> 00:02:03.924 
菲爾·貝內特

00:02:03.991 --> 00:02:07.327 
會深入介紹利用...
Metal應用

00:02:07.528 --> 00:02:10.097 
實現
可能的最好

00:02:10.330 --> 00:02:11.698 
表現的出色技巧

00:02:12.999 --> 00:02:14.768 
在本次講座中

00:02:14.835 --> 00:02:18.839 
我們將
介紹最新GPU

00:02:19.072 --> 00:02:21.375 
System Trace工具
所以一定要看看

00:02:25.879 --> 00:02:27.281 
去年的WWDC上

00:02:27.347 --> 00:02:29.716 
我們介紹了
iOS 8的Metal技術

00:02:31.518 --> 00:02:34.588 
目標是
圖形的重新實現

00:02:34.655 --> 00:02:37.191 
並計算API
在我們的平臺上

00:02:37.257 --> 00:02:41.395 
給你提供最好的GPU表現

00:02:42.396 --> 00:02:46.266 
我們通過讓你和
GPU之間的軟件

00:02:46.466 --> 00:02:48.402 
發揮最大效用實現這些

00:02:51.638 --> 00:02:53.207 
爲更形象地說明

00:02:53.273 --> 00:02:55.275 
我們現在來看

00:02:55.342 --> 00:02:57.878 
在去年的WWDC
舉的例子

00:02:57.945 --> 00:02:59.546 
其中描述

00:02:59.613 --> 00:03:02.883 
GPU和CPU每幀
完成的工作

00:03:04.251 --> 00:03:05.419 
在本例中

00:03:05.485 --> 00:03:08.722 
頭部工具條
代表CPU所用時間

00:03:09.156 --> 00:03:12.192 
底部工具條代表
GPU時間

00:03:13.227 --> 00:03:15.863 
正如大家所見
目前CPU密集

00:03:16.930 --> 00:03:19.766 
GPU在幀的部分位置
比較空閒

00:03:21.335 --> 00:03:22.469 
有了Metal 我們可以

00:03:22.536 --> 00:03:26.340 
大幅減少GPU
API開銷

00:03:26.740 --> 00:03:28.008 
有效地

00:03:29.576 --> 00:03:31.478 
將GPU
作爲高幀數的瓶頸

00:03:32.713 --> 00:03:35.549 
這其中最棒的是
你可以利用CPU

00:03:35.616 --> 00:03:37.718 
額外的空閒時間

00:03:38.285 --> 00:03:39.620 
讓遊戲效果更好

00:03:41.088 --> 00:03:43.690 
例如 可以增加
更多物理應用或AI

00:03:45.058 --> 00:03:47.160 
如果你可以簽署更多

00:03:47.561 --> 00:03:49.530 
繪製調用來增加
場景的複雜性

00:03:52.132 --> 00:03:53.400 
但是我們不會止步於此

00:03:54.301 --> 00:03:57.504 
Metal還可以實現
成本較高的操作

00:03:57.971 --> 00:03:59.406 
例如 着色器編譯

00:03:59.840 --> 00:04:02.376 
和狀態確認

00:04:02.743 --> 00:04:05.412 
從每幀數千次的繪製時間

00:04:06.313 --> 00:04:08.815 
到發生頻率不高的

00:04:09.683 --> 00:04:11.885 
加載時間均有涉及
更好的是在部分情況下

00:04:11.952 --> 00:04:12.786 
是構建時間

00:04:13.520 --> 00:04:16.322 
這樣用戶
根本不會發現任何影響

00:04:19.125 --> 00:04:20.260 
此外

00:04:20.327 --> 00:04:21.894 
在iOS 8中

00:04:21.962 --> 00:04:24.798 
我們不僅爲iOS設備

00:04:24.865 --> 00:04:28.068 
引入了計算或首次
面對此類計算

00:04:28.802 --> 00:04:33.807 
而且還提供了
圖形和計算

00:04:34.107 --> 00:04:36.476 
API之間的凝聚
整合性內容

00:04:37.244 --> 00:04:41.682 
以便在支持Metal的設備上
有效交叉進行渲染

00:04:41.849 --> 00:04:43.417 
和計算操作

00:04:47.521 --> 00:04:48.689 
最後

00:04:48.755 --> 00:04:49.723 
通過Metal

00:04:49.790 --> 00:04:51.258 
你的應用可以

00:04:51.325 --> 00:04:53.794 
更高效地
運用多線程

00:04:54.094 --> 00:04:55.929 
而不會受到API的影響
可以實現

00:04:56.730 --> 00:04:59.466 
多線程編碼

00:05:02.035 --> 00:05:03.537 
結果會
非常出色

00:05:04.605 --> 00:05:05.572 
去年

00:05:05.639 --> 00:05:07.107 
我們展示了

00:05:07.174 --> 00:05:10.711 
Epic開發的《禪境花園》演示

00:05:10.944 --> 00:05:13.847 
其中用到Metal
實現場景中十倍

00:05:13.914 --> 00:05:15.382 
數量的繪畫調用

00:05:17.451 --> 00:05:20.888 
我們還展示了EA的
《植物大戰殭屍》技術演示

00:05:21.421 --> 00:05:25.025 
其中使用Metal
把控制檯渲染引擎

00:05:25.459 --> 00:05:26.894 
才能得到支持

00:05:28.328 --> 00:05:31.031 
這就爲開發界
設定了高標準

00:05:31.765 --> 00:05:34.501 
在去年 我們見證了
充分利用Metal API

00:05:34.568 --> 00:05:36.470 
而推出的部分

00:05:36.937 --> 00:05:39.640 
水平極高的
作品

00:05:41.308 --> 00:05:43.644 
諸如Super
Evil Mega Corp公司

00:05:43.710 --> 00:05:45.612 
推出的MOBA
Vainglory遊戲

00:05:46.513 --> 00:05:49.816 
其中運用了Metal
實現每秒60幀的效果

00:05:51.718 --> 00:05:54.021 
迪斯尼的《Infinity:Toy
Box 2》

00:05:54.488 --> 00:05:55.522 
Metal使其

00:05:55.589 --> 00:05:57.925 
可將控制器
圖形和遊戲

00:05:58.292 --> 00:06:00.527 
體驗帶到了iOS

00:06:02.629 --> 00:06:04.598 
Gameloft的
《Asphalt 8》

00:06:04.998 --> 00:06:07.234 
可以運用Metal

00:06:07.401 --> 00:06:10.270 
提高遊戲可玩性
將遊戲中的渲染速度

00:06:10.337 --> 00:06:11.772 
比對手高出3倍

00:06:13.874 --> 00:06:15.609 
但還不僅是遊戲方面

00:06:16.844 --> 00:06:18.679 
隨着用於iPhone的

00:06:19.546 --> 00:06:21.048 
新版本Pixelmator推出

00:06:21.114 --> 00:06:22.249 
Metal被用於
強大的

00:06:22.316 --> 00:06:23.917 
變形工具中的

00:06:24.017 --> 00:06:26.587 
加速圖形
處理功能

00:06:28.288 --> 00:06:29.122 
實際上

00:06:29.923 --> 00:06:31.625 
相關反響非常強烈

00:06:32.226 --> 00:06:33.527 
有相當數量的

00:06:33.594 --> 00:06:35.095 
主要內容和
遊戲開發人員

00:06:35.162 --> 00:06:36.396 
在OS X上使用Metal

00:06:38.165 --> 00:06:41.301 
因爲我們對在iOS平臺上

00:06:41.702 --> 00:06:42.769 
推出領先的遊戲

00:06:43.103 --> 00:06:45.606 
控制檯引擎所做承諾
大部分這樣的內容

00:06:45.939 --> 00:06:47.441 
才能得到支持

00:06:48.008 --> 00:06:49.743 
這包括

00:06:49.810 --> 00:06:51.512 
Unity
Epic的《虛幻引擎4》

00:06:51.912 --> 00:06:52.980 
EA的《寒霜》

00:06:53.380 --> 00:06:55.516 
移動引擎

00:06:59.019 --> 00:07:00.754 
去年 我們還展示了

00:07:00.821 --> 00:07:01.989 
Metal怎樣在

00:07:02.055 --> 00:07:05.959 
應用訪問GPU的
全局圖景中發揮作用

00:07:06.593 --> 00:07:09.963 
一方面 我們有着
高水準的2D和

00:07:10.030 --> 00:07:12.232 
3D場景圖像API

00:07:12.599 --> 00:07:14.902 
以提供難以置信的

00:07:14.968 --> 00:07:16.670 
功能和便捷

00:07:16.970 --> 00:07:18.238 
另一方面

00:07:18.305 --> 00:07:19.239 
通過Metal

00:07:19.306 --> 00:07:22.109 
我們提供了
GPU的直接訪問路徑

00:07:22.910 --> 00:07:24.912 
這樣你可以爲

00:07:25.379 --> 00:07:27.414 
應用所做的事情

00:07:28.415 --> 00:07:30.083 
就會多了很多
如果選擇使用

00:07:30.150 --> 00:07:31.585 
更高級的API

00:07:32.085 --> 00:07:33.020 
最棒的是

00:07:33.086 --> 00:07:35.722 
我們可以在
幕後實現很多改進

00:07:36.223 --> 00:07:38.025 
你可以從中受益

00:07:38.091 --> 00:07:40.861 
而我們不需改動
一行代碼

00:07:42.829 --> 00:07:43.931 
今年

00:07:43.997 --> 00:07:46.466 
我們很高興
宣佈了

00:07:47.000 --> 00:07:49.703 
我們做到了這些
並讓Metal

00:07:49.970 --> 00:07:51.672 
在整個系統技術中表現得
更強大更高效

00:07:52.506 --> 00:07:55.275 
我相信
這將會提升

00:07:55.342 --> 00:07:56.777 
用戶在我們的
平臺上的體驗

00:08:00.581 --> 00:08:04.184 
這也是支持Metal
設備的很棒的一年

00:08:05.018 --> 00:08:09.556 
iPhone 5S和iPad
Air在去年的WWDC上

00:08:10.524 --> 00:08:13.427 
都是主打產品
隨着iPhone 6

00:08:13.861 --> 00:08:16.663 
6+和 iPad Air 2的推出

00:08:16.730 --> 00:08:18.866 
我們現在有了支持Metal設備的

00:08:18.932 --> 00:08:21.068 
難以置信的安裝基礎

00:08:22.035 --> 00:08:23.437 
但是當然
還不止於此

00:08:24.838 --> 00:08:26.473 
我們很高興地宣佈

00:08:26.540 --> 00:08:29.610 
將Metal納入了
OS X平臺

00:08:33.113 --> 00:08:34.948 
我們在所有的

00:08:35.015 --> 00:08:37.818 
傳送配置中
都廣泛支持Metal

00:08:37.885 --> 00:08:42.789 
實際上 自2012年起
所有的Mac就已支持Metal

00:08:44.024 --> 00:08:46.793 
當然 這意味着
我們會支持所有

00:08:46.860 --> 00:08:50.364 
三家GPU廠商：
Intel AMD和Nvidia

00:08:53.333 --> 00:08:55.569 
其他好消息還包括

00:08:55.636 --> 00:08:58.071 
我們將大家熟悉的

00:08:58.138 --> 00:09:00.908 
iOS上的所有工具
也都加在了Mac平臺

00:09:01.608 --> 00:09:03.310 
這其中包括Frame

00:09:04.478 --> 00:09:06.680 
Debugger
Shader Profiler

00:09:07.047 --> 00:09:09.283 
和所有API分析工具

00:09:10.017 --> 00:09:11.451 
這相當了不起

00:09:11.652 --> 00:09:14.121 
我們瞭解調試複雜圖形

00:09:14.188 --> 00:09:16.190 
和計算
應用的難度

00:09:16.623 --> 00:09:19.860 
並認爲這對
大家在OS X上的

00:09:19.927 --> 00:09:20.928 
開發工作
意義重大

00:09:22.362 --> 00:09:23.931 
當然 所有這些在

00:09:23.997 --> 00:09:26.567 
OS X El
Capitan版本

00:09:26.934 --> 00:09:28.936 
搭建的種子中可以獲得
如今這一版本可以下載

00:09:31.004 --> 00:09:32.406 
OS X上的Metal

00:09:32.472 --> 00:09:35.042 
是你所熟悉的同樣API

00:09:35.509 --> 00:09:36.577 
用的是iOS

00:09:37.044 --> 00:09:38.378 
增加了幾項主要功能

00:09:39.580 --> 00:09:42.316 
新款API支持設備選擇

00:09:43.150 --> 00:09:44.384 
離散內存

00:09:44.718 --> 00:09:46.186 
和新的紋理格式

00:09:46.687 --> 00:09:49.089 
Metal可以讓
你將iOS應用帶入

00:09:49.156 --> 00:09:51.859 
OS X變得異常容易

00:09:54.127 --> 00:09:55.529 
這裏有幾個實例

00:09:55.596 --> 00:09:57.497 
開發人員正是
這樣做的

00:09:58.665 --> 00:10:01.768 
大家從主題演講中聽到
我們在與Epic合作

00:10:02.236 --> 00:10:05.506 
將其iOS Metal
開發代碼帶到

00:10:05.839 --> 00:10:07.474 
Mac中的《虛幻引擎》

00:10:08.775 --> 00:10:10.544 
Epic運用Metal

00:10:10.744 --> 00:10:13.180 
和延遲渲染器

00:10:13.247 --> 00:10:16.350 
在《堡壘之夜》遊戲中
創建這種神奇的風格效果

00:10:18.452 --> 00:10:20.854 
此外 Unity在幾周內

00:10:20.921 --> 00:10:22.623 
就推出了他們的引擎

00:10:23.123 --> 00:10:25.659 
並展示了
他們的《海盜村》

00:10:25.726 --> 00:10:27.327 
演示

00:10:27.761 --> 00:10:31.298 
很高興能在OS X的Metal中
看到這樣的內容

00:10:33.600 --> 00:10:36.670 
我們在與
若干Mac開發者合作

00:10:36.904 --> 00:10:40.474 
幫助他們通過
Metal使用Metal的強大功能

00:10:43.977 --> 00:10:45.646 
同樣 大家從主題演講中聽到

00:10:45.712 --> 00:10:48.282 
數字內容
生成應用的相關介紹

00:10:49.449 --> 00:10:50.784 
Adobe這樣的開發者

00:10:50.851 --> 00:10:52.953 
在使用Metal訪問GPU

00:10:53.020 --> 00:10:54.888 
加速圖像處理能力

00:10:57.357 --> 00:10:58.825 
The Foundry公司

00:10:58.892 --> 00:11:00.594 
也在運用Metal

00:11:00.661 --> 00:11:04.097 
加速其3D
建模應用MODO

00:11:05.632 --> 00:11:06.900 
今天

00:11:06.967 --> 00:11:10.270 
來自The Foundry
公司的傑克•格里斯雷

00:11:10.604 --> 00:11:12.639 
來談談他們在OS X
使用Metal的經驗

00:11:14.741 --> 00:11:15.576 
歡迎傑克

00:11:15.642 --> 00:11:16.476 
謝謝 拉夫

00:11:19.913 --> 00:11:21.215 
大家好我是傑克•格里斯雷

00:11:21.281 --> 00:11:23.817 
在The Foundry公司
負責新技術部門

00:11:24.751 --> 00:11:28.121 
在The Foundry 我們爲
數碼藝術家創建工具

00:11:29.656 --> 00:11:31.491 
我們的軟件在全世界

00:11:31.558 --> 00:11:33.994 
用於遊戲 影視等領域

00:11:34.561 --> 00:11:37.064 
包括拍攝
真實的祕魯熊

00:11:38.465 --> 00:11:39.566 
變形怪物獵人

00:11:40.767 --> 00:11:42.102 
但並非僅限於
虛擬世界

00:11:42.870 --> 00:11:44.571 
我們的部分設計客戶
如阿迪達斯是

00:11:44.638 --> 00:11:45.839 
是在切實生產產品

00:11:47.140 --> 00:11:48.742 
如果你詢問設計師

00:11:49.476 --> 00:11:52.513 
他們會告知你 任何產品都是
經過成千上萬次試驗纔會成型

00:11:54.982 --> 00:11:56.283 
我們理解這一過程

00:11:56.350 --> 00:11:57.417 
我們創造的工具

00:11:57.484 --> 00:11:59.152 
就是針對此類支持

00:12:01.355 --> 00:12:03.323 
MODO是我們的著名3D

00:12:03.390 --> 00:12:05.526 
建模動畫和渲染系統

00:12:06.460 --> 00:12:08.762 
它可用來製作遊戲
電影和產品設計

00:12:09.129 --> 00:12:10.163 
等等很多不同的應用

00:12:11.231 --> 00:12:13.100 
我們的用戶創造出

00:12:13.467 --> 00:12:15.869 
非常精彩的畫面和動畫在真實世界和
虛幻世界中都有

00:12:18.138 --> 00:12:20.207 
在我們的MODO 9.01
最新版本中

00:12:20.841 --> 00:12:23.277 
對GPU渲染器做了修改

00:12:24.645 --> 00:12:27.581 
旨在爲設計者
提供儘可能

00:12:28.315 --> 00:12:30.317 
高質量的
流暢互動體驗

00:12:31.418 --> 00:12:34.054 
這樣做的好處在於
如果視口是實時

00:12:34.588 --> 00:12:36.256 
你就可以完成
數十倍單個軟件

00:12:36.323 --> 00:12:38.091 
渲染器的決定

00:12:40.928 --> 00:12:43.864 
在iOS中 我們已經
完成了部分早期工作

00:12:44.831 --> 00:12:47.868 
但是在幾個月前
我們有個絕好的機會

00:12:48.202 --> 00:12:49.803 
可以在OS X上
開始使用Metal

00:12:50.404 --> 00:12:52.539 
我們組織了一個小團隊
讓他們來接受挑戰

00:12:53.207 --> 00:12:56.143 
只給4周時間
來看他們可以將

00:12:56.510 --> 00:12:58.712 
生成多少新的MODO視口
並在Metal上運行

00:12:59.313 --> 00:13:01.849 
我們機會立刻會
得到一些很令人震驚的結果

00:13:05.853 --> 00:13:06.687 
雖然

00:13:06.753 --> 00:13:08.155 
這不過是
小三角

00:13:08.222 --> 00:13:10.057 
但是這代表了
我們的一個巨大里程碑

00:13:10.757 --> 00:13:13.594 
一旦我們可以做到這點
就可以很快的取得進步

00:13:14.228 --> 00:13:16.530 
我們的進攻計劃
其實是從下往上

00:13:17.130 --> 00:13:20.234 
並開始將新視口的功能
帶到了Metal

00:13:20.801 --> 00:13:22.135 
第一天

00:13:22.202 --> 00:13:23.337 
我們
是從環境開始入手

00:13:25.339 --> 00:13:27.708 
我們添加了更多的三角

00:13:31.245 --> 00:13:32.813 
加一點着色處理會

00:13:32.880 --> 00:13:34.748 
讓它看似更像是
真正的汽車

00:13:38.385 --> 00:13:39.887 
加上柔和的陰影

00:13:39.953 --> 00:13:40.888 
還有特殊的高光處理

00:13:40.954 --> 00:13:42.289 
加上了閃閃發亮的效果

00:13:42.356 --> 00:13:43.490 
人人都喜歡亮閃閃的東西

00:13:45.125 --> 00:13:47.327 
就這樣
四周後

00:13:47.394 --> 00:13:48.929 
大家還記得那個
單一的三角形嗎？

00:13:49.296 --> 00:13:50.697 
結果難以置信

00:13:54.701 --> 00:13:56.370 
把這些都放入Metal

00:13:56.436 --> 00:13:58.572 
僅僅用四周時間

00:13:58.872 --> 00:14:00.440 
我們就實現了

00:14:00.507 --> 00:14:02.442 
所有視口
都在Metal的MODO運行

00:14:03.977 --> 00:14:05.279 
很棒的一點是

00:14:05.345 --> 00:14:08.749 
這提供了跨iOS和OS X的
標準化渲染器

00:14:09.983 --> 00:14:13.353 
我們在兩個平臺間
生成了WYSIWYG工作流

00:14:15.889 --> 00:14:17.324 
那麼我們學到了什麼？

00:14:18.058 --> 00:14:20.227 
首先我們瞭解到
使用Metal充滿樂趣

00:14:20.861 --> 00:14:22.963 
我使用OpenGL工作
已經20年時間

00:14:23.030 --> 00:14:25.065 
我可以告知大家
API輕鬆易用

00:14:25.132 --> 00:14:27.067 
就像是呼吸新鮮空氣一般

00:14:29.002 --> 00:14:29.970 
其次

00:14:30.437 --> 00:14:32.139 
Metal中的
調試和

00:14:32.206 --> 00:14:33.807 
優化工具
也非常神奇

00:14:34.908 --> 00:14:35.742 
我剛說過

00:14:35.809 --> 00:14:37.411 
如果你在
GPU上做過調試

00:14:37.477 --> 00:14:38.846 
就會知道爲什麼這點很重要

00:14:40.214 --> 00:14:41.882 
Metal的速度非常快

00:14:42.516 --> 00:14:44.585 
在部分測試中
我們實現了3倍加速

00:14:45.252 --> 00:14:47.921 
這是在同樣的GPU
使用完全相同的數據的結果

00:14:49.590 --> 00:14:52.626 
繼續來看 我們對
新的視口有些很大的計劃

00:14:52.693 --> 00:14:55.963 
我們想將它整合到The
Foundry公司的所有工具中

00:14:56.463 --> 00:14:58.565 
希望 能很快
看到Metal

00:14:58.632 --> 00:14:59.867 
出現在
有趣的地方

00:15:00.801 --> 00:15:03.136 
請拉夫回到臺上
非常感謝

00:15:10.511 --> 00:15:11.345 
謝謝 傑克

00:15:14.515 --> 00:15:15.482 
非常好

00:15:16.583 --> 00:15:19.720 
接下來我會聊聊iOS 9和OS X
El Capitan

00:15:19.786 --> 00:15:22.890 
引入的
新功能

00:15:24.691 --> 00:15:25.659 
這樣的功能有很多

00:15:27.027 --> 00:15:28.262 
只能對我們

00:15:28.328 --> 00:15:29.796 
今年新增的功能
選擇性介紹一番

00:15:30.864 --> 00:15:33.500 
實在沒時間
各個都講一遍

00:15:33.834 --> 00:15:35.536 
我先來說說
子集問題

00:15:36.370 --> 00:15:38.472 
包括GPU系列集

00:15:38.872 --> 00:15:40.307 
我們的新內存模型

00:15:40.374 --> 00:15:41.675 
紋理壁壘

00:15:41.742 --> 00:15:43.644 
<br/>
和擴展的紋理支持

00:15:44.878 --> 00:15:46.213 
當然 我之前提過

00:15:46.280 --> 00:15:47.514 
在本週晚些時候的
講座中

00:15:47.581 --> 00:15:48.415 
大家可以
瞭解到

00:15:49.082 --> 00:15:50.717 
MetalKit
MetalPerformance

00:15:50.784 --> 00:15:52.853 
Shaders
新的Metal System

00:15:53.320 --> 00:15:54.888 
Trace工具等更多內容

00:15:56.823 --> 00:15:58.325 
我們現在就來詳細介紹

00:15:59.393 --> 00:16:01.395 
我想先從GPU開始

00:16:01.461 --> 00:16:02.896 
這是我們的Metal功能集

00:16:03.397 --> 00:16:06.200 
Metal定義了
專門針對生成GPU

00:16:06.266 --> 00:16:09.403 
硬件的功能集合

00:16:10.003 --> 00:16:13.040 
Metal調用這些GPU系列

00:16:14.741 --> 00:16:16.210 
因此GPU功能集

00:16:16.276 --> 00:16:19.780 
是由iOS或OS X平臺所定義

00:16:20.981 --> 00:16:23.116 
Family Name
主要針對

00:16:23.183 --> 00:16:24.384 
硬件生成

00:16:25.152 --> 00:16:26.220 
版本則可以

00:16:26.286 --> 00:16:29.156 
讓我們隨着時間推移
增加功能

00:16:30.424 --> 00:16:32.926 
詢問功能集
意義不大

00:16:33.861 --> 00:16:36.797 
只需在Metal設備上

00:16:36.864 --> 00:16:39.967 
調用supportFeature
Set 來決定是否GPU系列即可

00:16:42.269 --> 00:16:45.072 
這裏是iOS
功能集矩陣

00:16:46.073 --> 00:16:48.642 
大家會注意到
我們會支持

00:16:48.709 --> 00:16:50.777 
兩個主要GPU系列

00:16:50.844 --> 00:16:51.945 
和版本來區分

00:16:52.012 --> 00:16:54.248 
iOS 8

00:16:54.314 --> 00:16:56.383 
和
iOS 9功能

00:16:59.019 --> 00:17:00.287 
在OS X中

00:17:00.354 --> 00:17:02.990 
GPUFamily1 v1
功能集代表

00:17:03.056 --> 00:17:07.227 
我們將在OS X El
Capitan推出的新功能

00:17:07.828 --> 00:17:10.763 
這在桌面平臺
定義了支持Metal

00:17:10.830 --> 00:17:12.098 
設備的基礎

00:17:15.602 --> 00:17:16.603 
現在 我想談談

00:17:16.670 --> 00:17:20.240 
兩個新的着色器常數
更新我們所添加的API

00:17:21.175 --> 00:17:22.476 
首先來看看
背景

00:17:23.210 --> 00:17:25.878 
對於在命令
緩衝區的每個

00:17:26.280 --> 00:17:28.715 
繪畫編碼
都需要發送給

00:17:29.416 --> 00:17:30.684 
着色器部分常數數據

00:17:30.751 --> 00:17:32.786 
若要每個繪畫
都有單獨的

00:17:32.853 --> 00:17:34.354 
常數緩衝區
那麼效率就會變得極低

00:17:34.488 --> 00:17:36.490 
所以一般來說 大多數
Metal應用

00:17:36.557 --> 00:17:39.026 
會每幀分配
一個單獨的常數緩衝區

00:17:39.092 --> 00:17:40.594 
接着在爲
繪畫編碼時

00:17:41.595 --> 00:17:46.099 
將常數數據增加到緩衝區

00:17:47.267 --> 00:17:48.569 
代碼會是什麼樣呢？

00:17:49.803 --> 00:17:50.704 
首先 我們爲

00:17:50.771 --> 00:17:52.673 
常數緩衝區
和數據設置

00:17:53.440 --> 00:17:55.876 
正如示意圖
在繪圖環中

00:17:56.743 --> 00:17:59.880 
你發送新的
常數數據

00:17:59.947 --> 00:18:02.416 
或將新的常數數據
圈入常數緩衝器

00:18:03.483 --> 00:18:04.685 
現在 值得注意的是

00:18:04.751 --> 00:18:06.887 
setVertexBuffer調用

00:18:06.954 --> 00:18:09.056 
實際上在做兩件事

00:18:10.524 --> 00:18:12.059 
它在設置
常數緩衝區

00:18:12.960 --> 00:18:14.862 
也在更新
其中的偏移

00:18:15.629 --> 00:18:18.165 
現在 在這兩個
操作中 設置常數

00:18:18.899 --> 00:18:22.269 
緩衝區的調用
造價最高

00:18:23.036 --> 00:18:24.571 
Metald的API
可以實現

00:18:24.638 --> 00:18:26.974 
分離這兩個操作

00:18:27.341 --> 00:18:29.209 
並將造價高的調用

00:18:29.276 --> 00:18:30.744 
用來設置常數緩衝區

00:18:31.144 --> 00:18:33.347 
或頂點緩衝
在繪畫環之外

00:18:34.748 --> 00:18:37.317 
如果每幀有數千
繪圖調用

00:18:37.651 --> 00:18:39.319 
這就會有大量
的節約

00:18:41.722 --> 00:18:44.291 
但是如果你只有
少量的常數數據

00:18:44.491 --> 00:18:46.260 
讓Metal來管理
常數緩衝區效率

00:18:46.326 --> 00:18:47.995 
也許
會更高

00:18:49.496 --> 00:18:52.266 
Metal有setVertex
Bytes API

00:18:52.733 --> 00:18:54.835 
你可以用它來爲

00:18:54.902 --> 00:18:58.605 
每個繪畫調用增加新常數

00:19:00.841 --> 00:19:02.376 
實際上 關於這一點
我還要補充一些

00:19:02.809 --> 00:19:04.511 
我說過

00:19:04.578 --> 00:19:06.547 
如果只有
少量常數

00:19:06.613 --> 00:19:08.982 
API很好
可以有數十字節常數

00:19:09.917 --> 00:19:12.219 
如果有更大的
常數集

00:19:12.286 --> 00:19:13.754 
你想在

00:19:13.820 --> 00:19:15.455 
其他API中使用

00:19:16.356 --> 00:19:18.325 
很可能 這樣會
效果更好

00:19:20.394 --> 00:19:22.362 
好 我現在來談談
新的內存模型

00:19:24.631 --> 00:19:27.167 
新內存模型的目標
是支持統一

00:19:27.234 --> 00:19:29.670 
和離散的內存
系統 而無需

00:19:29.736 --> 00:19:32.105 
做出
太多改變

00:19:32.739 --> 00:19:34.842 
Metal現在支持
離散內存

00:19:34.908 --> 00:19:38.045 
這是高速內存
部分桌面的

00:19:38.111 --> 00:19:41.014 
GPU可以訪問

00:19:42.182 --> 00:19:43.483 
我們實現
這些的方式

00:19:43.951 --> 00:19:46.820 
是通過新的存儲模式

00:19:47.387 --> 00:19:49.022 
你可以明確

00:19:49.323 --> 00:19:50.424 
資源在
內存中的位置

00:19:51.124 --> 00:19:52.426 
模式可以是共享

00:19:53.060 --> 00:19:55.128 
專用和

00:19:55.562 --> 00:19:57.297 
託管狀態

00:19:58.398 --> 00:20:00.234 
在接下來的幻燈片中

00:20:00.300 --> 00:20:01.802 
我會依次來介紹

00:20:03.303 --> 00:20:05.939 
先來看看
共享內存模式

00:20:06.740 --> 00:20:09.376 
這就是在iOS 8

00:20:09.443 --> 00:20:10.744 
現有執行的
模式

00:20:11.445 --> 00:20:13.447 
在統一的內存系統
用於存儲

00:20:13.514 --> 00:20:15.983 
緩衝區或紋理的

00:20:16.049 --> 00:20:19.753 
內存共享
於CPU和GPU之間

00:20:21.421 --> 00:20:22.956 
內存只有
一份拷貝

00:20:23.524 --> 00:20:26.460 
內存在命令
緩存區邊界方面保持一致

00:20:26.894 --> 00:20:29.563 
也就是說
在通過CPU訪問之前

00:20:29.897 --> 00:20:31.865 
需要用GPU
做此番處理

00:20:32.633 --> 00:20:34.501 
這會令它易於使用

00:20:36.436 --> 00:20:38.505 
但在iOS 9

00:20:38.572 --> 00:20:40.374 
和OS X
El Capitan中

00:20:40.440 --> 00:20:43.777 
我們
引入了專用存儲模式

00:20:44.511 --> 00:20:45.812 
專用內存

00:20:45.879 --> 00:20:48.148 
只能
通過渲染 計算

00:20:48.482 --> 00:20:51.084 
或傳送操作
由GPU進行訪問

00:20:52.052 --> 00:20:54.788 
專用內存的優勢
在於性能

00:20:55.455 --> 00:20:57.658 
Metal可以用
最便於GPU

00:20:57.724 --> 00:21:00.260 
訪問的方式存儲數據

00:21:01.528 --> 00:21:03.830 
例如 使用
幀緩衝壓縮

00:21:06.567 --> 00:21:10.938 
專用存儲模式
與離散內存系統

00:21:11.338 --> 00:21:14.107 
配合很好
可以將資源

00:21:14.174 --> 00:21:16.743 
放入GPU可以最快
訪問的內存中

00:21:19.313 --> 00:21:21.615 
現在 只有在OS X中

00:21:22.049 --> 00:21:24.151 
我們引入了託管
存儲模式

00:21:24.351 --> 00:21:27.921 
有了託管內存
資源就可以在

00:21:27.988 --> 00:21:28.889 
離散內存

00:21:28.956 --> 00:21:30.624 
和系統
內存中進行存儲

00:21:31.024 --> 00:21:34.361 
Metal管理着兩個
拷貝的一致性

00:21:36.029 --> 00:21:38.899 
這樣可以提供
分享存儲模式的

00:21:38.966 --> 00:21:40.901 
便捷性和靈活性

00:21:40.968 --> 00:21:42.135 
在多數情況下

00:21:42.202 --> 00:21:44.338 
是專用存儲模式的性能

00:21:46.907 --> 00:21:49.610 
如果你有統一內存系統的

00:21:50.244 --> 00:21:52.546 
桌面系統

00:21:52.613 --> 00:21:54.047 
就你不必擔心

00:21:54.114 --> 00:21:55.749 
託管額外的
開銷

00:21:56.116 --> 00:21:59.119 
只有Metal維護的資源的
一份拷貝

00:22:02.789 --> 00:22:05.225 
如果要調整CPU
或GPU的數據

00:22:05.292 --> 00:22:07.461 
還有另外
兩方面需要

00:22:07.528 --> 00:22:09.596 
考慮

00:22:10.464 --> 00:22:11.331 
首先

00:22:11.398 --> 00:22:13.333 
如果要用
CPU調整數據

00:22:13.767 --> 00:22:17.804 
則要通過調用緩衝
didModifyRange

00:22:18.238 --> 00:22:21.008 
或紋理replaceRegion
API 讓Metal瞭解

00:22:22.342 --> 00:22:24.578 
同樣 如果要
讀回數據

00:22:24.912 --> 00:22:27.915 
則需要調用synchronize
Resource API

00:22:28.815 --> 00:22:29.983 
還要注意的是

00:22:30.050 --> 00:22:32.386 
在真正用CPU讀取

00:22:32.452 --> 00:22:34.855 
數據前 要等到
操作完成之後才行

00:22:38.492 --> 00:22:40.427 
我們現在來看
之前展示的

00:22:40.494 --> 00:22:42.563 
着色器常數升級實例

00:22:43.063 --> 00:22:46.266 
這個實例正在
使用共享內存

00:22:47.901 --> 00:22:49.803 
在離散內存系統中

00:22:49.870 --> 00:22:52.139 
你很想讓常數

00:22:52.506 --> 00:22:53.640 
在離散內存中

00:22:54.107 --> 00:22:56.610 
這就可能要用到
專用緩衝區

00:22:57.044 --> 00:22:59.613 
還是必須要
將轉移託管到緩衝區

00:23:00.480 --> 00:23:03.817 
使用託管緩衝區
則要簡單很多

00:23:03.884 --> 00:23:05.586 
有它就會相當容易

00:23:05.652 --> 00:23:07.387 
只需要
做兩點

00:23:08.255 --> 00:23:09.223 
首先

00:23:09.289 --> 00:23:11.959 
在生成
常數緩衝區時

00:23:12.025 --> 00:23:13.627 
必須明確
託管存儲模式

00:23:14.862 --> 00:23:15.696 
然後

00:23:15.762 --> 00:23:18.031 
要調用
didModifyRange

00:23:18.098 --> 00:23:22.002 
告知Metal 你已經用
CPU升級了常數

00:23:22.503 --> 00:23:23.470 
就這樣

00:23:23.537 --> 00:23:26.073 
代碼的其餘部分
仍然保持不變

00:23:28.642 --> 00:23:30.677 
值得注意的是
在默認情況下

00:23:30.744 --> 00:23:32.746 
緩衝區可以在所有平臺共享

00:23:34.047 --> 00:23:35.182 
在iOS

00:23:35.249 --> 00:23:37.618 
在默認狀況下
紋理也是同樣如此

00:23:38.118 --> 00:23:40.187 
但是在OS X上

00:23:40.654 --> 00:23:43.290 
我們選擇爲紋理託管

00:23:43.657 --> 00:23:45.025 
製作默認模式
因爲它可以允許

00:23:45.092 --> 00:23:47.828 
編寫攜帶版代碼
而不影響性能

00:23:50.831 --> 00:23:53.133 
但是在有些情況下
你不會想要

00:23:53.200 --> 00:23:54.434 
使用託管紋理

00:23:54.635 --> 00:23:55.569 
這就是其中之一

00:23:56.069 --> 00:23:57.371 
當你有幀緩衝區

00:23:57.437 --> 00:23:58.839 
或可渲染紋理時

00:23:58.906 --> 00:24:01.441 
你想用專用
存儲模式

00:24:01.508 --> 00:24:02.843 
還獲取最佳性能

00:24:03.510 --> 00:24:05.445 
如果只有GPU可以

00:24:05.712 --> 00:24:07.381 
訪問數據
這就非常重要

00:24:09.016 --> 00:24:11.985 
這就是我們在Metal中的
新內存模式

00:24:12.052 --> 00:24:14.588 
我想來介紹Metal中的
兩個部分功能

00:24:15.155 --> 00:24:18.058 
都是OS X特有的
我覺得你會喜歡

00:24:19.026 --> 00:24:20.961 
首先是分層渲染

00:24:21.495 --> 00:24:23.530 
API的意圖是要

00:24:23.597 --> 00:24:26.533 
讓你可以將繪製的

00:24:26.600 --> 00:24:28.969 
每個三角形的紋理

00:24:29.036 --> 00:24:30.604 
的具體層次
都能進行渲染

00:24:31.238 --> 00:24:34.041 
因此這可以是
數組紋理的切片

00:24:34.641 --> 00:24:36.677 
3D紋理的平面
或立體紋理的表面

00:24:37.077 --> 00:24:39.079 
在每個三角形的基礎上
你可以明確

00:24:40.714 --> 00:24:43.083 
要渲染哪一層

00:24:43.450 --> 00:24:45.919 
只要在頂點着色器中

00:24:45.986 --> 00:24:49.156 
明確數組索引即可

00:24:50.424 --> 00:24:53.160 
遊戲《堡壘之夜》
就是用的這種技術

00:24:53.360 --> 00:24:56.230 
爲部分環境照明
渲染立方體

00:24:56.296 --> 00:24:58.131 
貼圖的表面

00:24:58.298 --> 00:25:01.001 
我們認爲 你也會
覺得這個功能同樣有用

00:25:04.271 --> 00:25:06.840 
第二個功能
也是OS X所特有

00:25:07.174 --> 00:25:09.409 
就是紋理壁壘

00:25:10.644 --> 00:25:12.746 
在默認狀態
GPU會傾向於覆蓋

00:25:12.813 --> 00:25:14.648 
繪畫調用的執行

00:25:15.382 --> 00:25:17.317 
不能在隨後的調用中

00:25:17.384 --> 00:25:19.620 
可靠使用繪畫
調用的輸出

00:25:19.686 --> 00:25:22.189 
而無需某種形式的顯性同步

00:25:23.290 --> 00:25:24.992 
Metal現有一個API

00:25:25.058 --> 00:25:26.360 
可以在這些

00:25:26.426 --> 00:25:28.295 
繪畫調用之間插入壁壘

00:25:30.264 --> 00:25:31.398 
對於在OS X

00:25:31.465 --> 00:25:34.935 
執行有效的可編程
混合非常關鍵

00:25:37.337 --> 00:25:39.306 
API很易於使用

00:25:39.740 --> 00:25:41.608 
只是在你想要同步的
繪畫操作中間

00:25:41.675 --> 00:25:44.378 
插入壁壘

00:25:47.614 --> 00:25:49.616 
最後 當然不是
最不重要的內容

00:25:49.683 --> 00:25:50.617 
我談談

00:25:50.684 --> 00:25:53.787 
今年Metal的擴展
紋理支持

00:25:55.122 --> 00:25:57.758 
在默認條件下

00:25:57.824 --> 00:25:59.660 
iOS中所有紋理的

00:25:59.726 --> 00:26:02.896 
最大限制已經
增至8k

00:26:03.430 --> 00:26:06.266 
我們還增加了
OS X的立方體數組支持

00:26:07.000 --> 00:26:08.936 
在所有平臺上
的各板中

00:26:09.002 --> 00:26:11.939 
都能提高
防疊效果

00:26:13.440 --> 00:26:15.876 
我們還大量
增加了像素格式

00:26:15.943 --> 00:26:18.412 
便於在計算着色器
編寫

00:26:18.478 --> 00:26:20.714 
或讀取數據

00:26:24.551 --> 00:26:27.321 
還有是紋理
使用屬性

00:26:28.188 --> 00:26:30.324 
這可以實現
對紋理標籤

00:26:30.791 --> 00:26:33.694 
告知Metal 你準備
怎樣使用它們

00:26:33.894 --> 00:26:36.697 
Metal會對使用進行優化

00:26:37.531 --> 00:26:38.799 
例如

00:26:38.866 --> 00:26:40.534 
如果你有
可渲染紋理時

00:26:40.868 --> 00:26:42.769 
想要設置renderTarget

00:26:42.836 --> 00:26:44.938 
和shaderRead旗標

00:26:46.173 --> 00:26:47.374 
這會告知Metal

00:26:47.441 --> 00:26:48.909 
你計劃在紋理上

00:26:48.976 --> 00:26:51.044 
所渲染 然後還要
從中取樣

00:26:53.146 --> 00:26:54.414 
默認狀態下

00:26:54.481 --> 00:26:56.416 
使用是未知的

00:26:56.817 --> 00:26:59.987 
Metal不會做任何假設
紋理會如何使用

00:27:00.320 --> 00:27:02.222 
允許Metal在系統的
任何地方進行使用

00:27:05.893 --> 00:27:07.628 
與iOS不同

00:27:07.694 --> 00:27:08.962 
桌面
GPU 更喜歡

00:27:09.029 --> 00:27:11.565 
單獨境深
模板紋理

00:27:13.100 --> 00:27:16.370 
我們添加了兩個
新的組合境深模板格式

00:27:17.004 --> 00:27:18.238 
32-8格式

00:27:18.305 --> 00:27:21.875 
在所有
硬件

00:27:21.942 --> 00:27:23.911 
iOS和OS X
都會支持

00:27:24.645 --> 00:27:27.981 
不過只有部分會
支持24-8格式

00:27:28.549 --> 00:27:30.584 
如果這意味着
是精度要求

00:27:30.651 --> 00:27:32.085 
就需要檢查
是否可用

00:27:37.090 --> 00:27:39.059 
我們來談談
紋理壓縮

00:27:40.027 --> 00:27:43.030 
所以所用壓縮格式類型
取決於所

00:27:43.096 --> 00:27:44.398 
針對的設備

00:27:44.698 --> 00:27:46.733 
以及編碼的
數據類型

00:27:47.467 --> 00:27:48.569 
在iOS

00:27:48.635 --> 00:27:50.404 
我們支持
若干格式

00:27:50.470 --> 00:27:52.439 
包括PVRTC

00:27:52.506 --> 00:27:54.074 
ETC2

00:27:54.141 --> 00:27:55.609 
和EAC

00:27:55.676 --> 00:27:58.512 
對於GPUFamily2的
新增內容是

00:27:58.579 --> 00:28:01.014 
我們也支持ASTC

00:28:03.317 --> 00:28:06.553 
因此ASTC是高質量
壓縮

00:28:07.221 --> 00:28:08.655 
要比相同大小的

00:28:09.156 --> 00:28:11.859 
PVRTC和ETC
要好很多

00:28:12.926 --> 00:28:16.129 
它可以實現
對若干不同格式的

00:28:16.597 --> 00:28:18.465 
圖像內容

00:28:18.532 --> 00:28:19.733 
高度圖

00:28:19.800 --> 00:28:21.902 
法線圖等等進行編碼

00:28:25.172 --> 00:28:29.076 
它還提供了
尺寸和質量之間的

00:28:29.142 --> 00:28:30.544 
細粒度控制

00:28:30.777 --> 00:28:32.312 
每個像素爲
1到8 bits

00:28:32.913 --> 00:28:33.981 
在低端

00:28:34.047 --> 00:28:37.050 
這是PVRTC
所需的一般存儲

00:28:38.785 --> 00:28:39.920 
最後

00:28:39.987 --> 00:28:41.722 
如我之前提到

00:28:41.788 --> 00:28:44.224 
這隻在支持GPUFamily2的

00:28:44.291 --> 00:28:45.526 
設備上可用

00:28:45.592 --> 00:28:46.760 
所以 大家
要留意這點

00:28:51.098 --> 00:28:52.733 
最後 在OS X中

00:28:52.799 --> 00:28:55.002 
我們介紹了桌面GPU

00:28:55.068 --> 00:28:58.505 
支持的所有原生紋理
壓縮格式

00:28:59.840 --> 00:29:01.642 
這些BCn格式

00:29:01.708 --> 00:29:03.076 
大家
應該都很熟悉

00:29:03.744 --> 00:29:05.679 
如果是在桌面平臺

00:29:05.746 --> 00:29:07.281 
或遊戲控制檯工作過

00:29:07.347 --> 00:29:10.717 
你可能已經有了
這種格式的資產

00:29:12.252 --> 00:29:14.288 
這是我們的擴展
紋理支持

00:29:14.788 --> 00:29:17.291 
我今天就
介紹這些功能

00:29:19.493 --> 00:29:21.094 
我想換個話題

00:29:21.161 --> 00:29:22.296 
談談一種

00:29:22.362 --> 00:29:24.331 
名爲app瘦身的
新技術

00:29:24.531 --> 00:29:26.400 
在上次講座中
大家可能聽到過一些

00:29:27.668 --> 00:29:30.003 
這不是Metal特有的
功能

00:29:30.337 --> 00:29:31.638 
但是它是基於

00:29:31.705 --> 00:29:35.509 
以前我在講座中之前介紹的
GPU系列

00:29:36.710 --> 00:29:38.512 
首先 設定上下文

00:29:39.146 --> 00:29:41.582 
開發人員典型的遊戲開發

00:29:41.648 --> 00:29:44.184 
和開發流程
在我們的平臺上

00:29:44.251 --> 00:29:45.419 
基本是
這個樣子

00:29:46.820 --> 00:29:48.522 
你一般會有
藝術管道

00:29:48.589 --> 00:29:49.690 
來生成部分資產

00:29:51.491 --> 00:29:53.594 
資產是通過Xcode搭建

00:29:53.660 --> 00:29:55.295 
或自定義工具管道

00:29:55.362 --> 00:29:56.697 
是二進制格式

00:29:57.865 --> 00:29:59.466 
然後二進制格式再

00:29:59.533 --> 00:30:01.435 
發送到App Store的某處
這個具體的

00:30:02.236 --> 00:30:04.538 
或是相同的二進制
要部署到

00:30:04.605 --> 00:30:08.642 
你的所有用戶的
設備中

00:30:09.309 --> 00:30:10.377 
這樣很好

00:30:11.478 --> 00:30:13.146 
但是一旦開始有了
具備具體設備

00:30:13.213 --> 00:30:15.148 
功能的資產

00:30:15.215 --> 00:30:18.385 
就會開始遇到
一些問題

00:30:22.055 --> 00:30:23.724 
例如

00:30:23.790 --> 00:30:25.659 
如果
有些資產是專門針對

00:30:25.726 --> 00:30:26.960 
Metal設備

00:30:27.027 --> 00:30:29.930 
有些資產
是特別用於舊式設備

00:30:31.198 --> 00:30:33.700 
現在必須要下載
兩種版本

00:30:33.767 --> 00:30:36.103 
以便用於所有的用戶設備

00:30:37.971 --> 00:30:39.473 
顯然 這並不理想

00:30:41.942 --> 00:30:44.378 
App瘦身可以通過
允許按照功能

00:30:44.444 --> 00:30:47.748 
爲資產貼標籤 來解決這個問題

00:30:48.115 --> 00:30:50.751 
這樣只有
設備需要的資產

00:30:50.817 --> 00:30:54.421 
纔會真正
下載到設備中

00:30:55.923 --> 00:30:56.990 
具體怎麼做呢？

00:30:58.225 --> 00:30:59.593 
app瘦身

00:30:59.860 --> 00:31:02.095 
可以實現

00:31:02.162 --> 00:31:06.166 
跨越兩級來定義功能

00:31:06.733 --> 00:31:08.368 
即GPUFamily版本

00:31:08.435 --> 00:31:10.237 
和
設備內存大小

00:31:10.304 --> 00:31:12.906 
這就會生成一個矩陣
可以用來針對

00:31:12.973 --> 00:31:14.942 
具體設備

00:31:18.512 --> 00:31:21.281 
我們現在來看
典型的法線圖實例

00:31:22.783 --> 00:31:25.752 
理想狀態下 你希望將
法線圖壓縮存儲

00:31:26.520 --> 00:31:28.322 
EAC是不錯的
格式

00:31:29.523 --> 00:31:31.358 
但是因爲部分

00:31:31.425 --> 00:31:33.894 
就是設備不支持壓縮紋理

00:31:33.961 --> 00:31:36.163 
特別是EAC
你可能需要

00:31:36.230 --> 00:31:38.565 
該資產的
未壓縮格式

00:31:40.667 --> 00:31:43.837 
app瘦身可以
爲資產加標籤

00:31:43.904 --> 00:31:45.038 
並僅下載

00:31:45.105 --> 00:31:48.509 
壓縮格式到支持Metal的設備上

00:31:48.575 --> 00:31:51.879 
未壓縮版本到
舊式設備中

00:31:52.746 --> 00:31:55.115 
但是app瘦身
的功能還不僅如此

00:31:55.182 --> 00:31:56.750 
我們來繼續擴展實例

00:31:57.918 --> 00:31:59.786 
它可以支持
更多設備

00:31:59.853 --> 00:32:02.456 
具體在本例中
我們將生成5個資產

00:32:03.190 --> 00:32:06.660 
我們先從高分辨率的
ASTC版本

00:32:07.327 --> 00:32:10.230 
用於最強大的2GB設備

00:32:10.364 --> 00:32:13.500 
然後 我們會包括
稍低的分辨率

00:32:13.734 --> 00:32:16.270 
用於1GB版本的
設備

00:32:16.603 --> 00:32:20.007 
因爲部分Metal設備
並不支持ASTC

00:32:20.741 --> 00:32:22.476 
我們也會包括
EAC版本

00:32:23.510 --> 00:32:25.879 
然後 對於
舊式設備

00:32:25.946 --> 00:32:28.115 
我們有未壓縮
版本的資產

00:32:29.183 --> 00:32:31.818 
我們可以把這個
實例進一步擴展

00:32:31.885 --> 00:32:35.989 
通過最低未壓縮
資產的較低

00:32:36.590 --> 00:32:39.359 
分辨率的版本
用於較低端的設備

00:32:39.459 --> 00:32:40.561 
512MB的配置

00:32:42.196 --> 00:32:44.598 
你可能不希望
生成5個資產

00:32:45.098 --> 00:32:46.834 
但是我想要
說明的一點是

00:32:46.900 --> 00:32:49.236 
你有着極大的
靈活度來

00:32:49.303 --> 00:32:51.205 
鎖定具體設備

00:32:51.271 --> 00:32:54.041 
爲用戶生成
最佳體驗

00:32:56.643 --> 00:32:59.112 
Xcode整合了
很好的UI 可以

00:32:59.179 --> 00:33:01.648 
這樣來爲資產加標籤

00:33:03.116 --> 00:33:04.718 
首先需要做的是
定義你要

00:33:04.785 --> 00:33:07.654 
鎖定的
設備功能

00:33:09.256 --> 00:33:10.991 
這會生成
小矩陣

00:33:11.491 --> 00:33:13.293 
然後只需要

00:33:13.360 --> 00:33:14.995 
留下資產

00:33:15.062 --> 00:33:18.332 
以便與GPUFamily系列的

00:33:18.398 --> 00:33:21.235 
相互交叉和
準備鎖定的設備內存大小相匹配即可

00:33:22.970 --> 00:33:24.137 
這非常簡單

00:33:25.539 --> 00:33:26.740 
但是 當然我們

00:33:26.807 --> 00:33:28.709 
意識到並非所有的
開發人員都有

00:33:28.775 --> 00:33:31.144 
存在於Xcode的工具管道

00:33:31.211 --> 00:33:33.080 
所以我們也包括了這些

00:33:33.614 --> 00:33:36.450 
我們支持app瘦身的
JSON文件格式

00:33:36.517 --> 00:33:40.320 
以便明確
資產分類

00:33:41.288 --> 00:33:42.856 
正如在Xcode一樣

00:33:42.923 --> 00:33:45.359 
你需要明確GPUFamily版本

00:33:46.193 --> 00:33:48.562 
以及希望包含在
分類中的各資產的

00:33:48.629 --> 00:33:50.264 
設備類型

00:33:53.934 --> 00:33:56.203 
一旦將資產分類
定義完畢

00:33:56.970 --> 00:33:58.906 
怎樣在運行時間
獲取數據呢？

00:34:00.807 --> 00:34:03.577 
答案就是
NSDataAsset類

00:34:03.944 --> 00:34:06.680 
它可以提供
與運行設備的

00:34:06.747 --> 00:34:09.248 
功能相匹配的
資產

00:34:10.317 --> 00:34:13.286 
通過NSDataAsset
很容易做到

00:34:14.688 --> 00:34:15.688 
只要

00:34:16.989 --> 00:34:19.025 
用賦予
資產分類的名稱

00:34:19.092 --> 00:34:21.929 
分配NSDataAsset
對象即可

00:34:22.529 --> 00:34:23.730 
然後在數據中使用

00:34:25.465 --> 00:34:28.635 
通過我開始展示的
示意圖和法線圖

00:34:28.969 --> 00:34:30.469 
實例來把它
接合在一起

00:34:31.638 --> 00:34:33.774 
在這種情況下
你的藝術家可以

00:34:33.841 --> 00:34:36.476 
生成一系列法線圖
部分壓縮 部分未壓縮

00:34:36.543 --> 00:34:38.110 
鎖定你想要的
具體設備

00:34:39.980 --> 00:34:42.549 
可以通過Xcode
或自定義工具管道

00:34:42.616 --> 00:34:45.485 
做成二進制格式
包括很多資產的

00:34:45.552 --> 00:34:48.522 
龐大二進制格式
上傳到App Store

00:34:49.523 --> 00:34:51.324 
最棒的是

00:34:51.391 --> 00:34:53.025 
只有用戶所需的法線圖

00:34:53.092 --> 00:34:56.295 
纔會下載到
他們的設備中

00:35:02.903 --> 00:35:04.338 
這就是app瘦身

00:35:05.439 --> 00:35:08.408 
我們認爲 這將會
改變大家

00:35:08.475 --> 00:35:10.644 
在支持Metal的設備上

00:35:11.111 --> 00:35:12.746 
生成和部署內容的方法

00:35:14.781 --> 00:35:16.650 
這就是在過去12個月間

00:35:16.717 --> 00:35:19.386 
Metal生態系統

00:35:19.453 --> 00:35:20.621 
的旋風之旅

00:35:21.188 --> 00:35:23.290 
我們看到像諸位這樣的
開發人員 使用Metal

00:35:23.357 --> 00:35:24.825 
生成非常出色的內容

00:35:25.659 --> 00:35:27.828 
我們將Metal帶入了OS X

00:35:28.161 --> 00:35:31.832 
我們也將所有出色的
Metal GPU工具帶入OS X

00:35:33.333 --> 00:35:35.602 
我們引入了部分強大的
新款API

00:35:35.969 --> 00:35:37.337 
相信大家
一定會喜歡

00:35:38.372 --> 00:35:40.541 
最後 我們談到了
Metal怎樣與

00:35:40.607 --> 00:35:43.810 
系統相整合
通過app瘦身技術來實現

00:35:45.212 --> 00:35:47.514 
總之 這是
相當不錯的一年

00:35:47.581 --> 00:35:50.450 
我們非常渴望
看到大家

00:35:50.951 --> 00:35:52.886 
在來年能對Metal
有怎樣的出色應用

00:35:55.355 --> 00:35:57.858 
請來訪問我們的
在線文檔資料

00:36:00.093 --> 00:36:02.095 
還可以到支持論壇
看看

00:36:02.162 --> 00:36:04.064 
如果問題沒有
得到解答 當然還可以

00:36:04.131 --> 00:36:07.034 
聯繫我們的
遊戲技術開發顧問

00:36:07.100 --> 00:36:09.102 
阿蘭·斯卡夫

00:36:10.504 --> 00:36:12.306 
本週還有兩場講座

00:36:12.873 --> 00:36:15.742 
《Metal技術最新內容》下半場

00:36:15.809 --> 00:36:17.311 
安排在週四上午

00:36:17.377 --> 00:36:20.581 
《Metal性能優化技術》
講座則是

00:36:20.647 --> 00:36:22.015 
在週五

00:36:22.082 --> 00:36:23.684 
請務必要記得參加

00:36:24.117 --> 00:36:24.985 
非常感謝