00:00:20.087 --> 00:00:24.424 
高级 NSOperations
开发WWDC app

00:00:32.933 --> 00:00:34.902 
早上好
我叫菲利普·豪斯勒

00:00:35.002 --> 00:00:37.704 
我在框架组
从事Foundation相关工作

00:00:38.338 --> 00:00:41.008 
今天我们要讲的是
NSOperation

00:00:41.208 --> 00:00:42.843 
和NSOperation队列

00:00:43.477 --> 00:00:46.680 
这是两种极其强大的类

00:00:46.947 --> 00:00:48.949 
可将你的应用

00:00:49.283 --> 00:00:54.621 
从直线性运行任务

00:00:54.688 --> 00:00:57.958 
转变成为以目标为导向

00:00:58.225 --> 00:01:02.329 
和功能异步概念的
混合模式

00:01:03.063 --> 00:01:07.267 
现在 我很肯定
大家都已经看过这个应用

00:01:09.636 --> 00:01:11.338 
WWDC应用广泛使用

00:01:11.405 --> 00:01:14.641 
NSOperation
和NSOperation队列

00:01:15.809 --> 00:01:17.544 
使我们能够

00:01:21.048 --> 00:01:26.220 
一直通过从互联网下载内容
与数据库甚至是

00:01:26.386 --> 00:01:29.957 
出现提醒或展示视频的
概念同步

00:01:30.023 --> 00:01:33.360 
来完成各种不同的任务

00:01:33.961 --> 00:01:35.896 
大卫·德龙将带我们深入了解

00:01:36.330 --> 00:01:39.299 
NSOperation
和NSOperation队列

00:01:39.499 --> 00:01:43.971 
以及如何使用它们
执行实现WWDC应用

00:01:44.171 --> 00:01:45.572 
大卫

00:01:54.181 --> 00:01:55.015 
菲利普

00:02:01.722 --> 00:02:05.959 
我叫大卫·德龙
我是Apple的框架专员

00:02:06.159 --> 00:02:07.995 
同时
我也是WWDC应用的首席工程师

00:02:08.061 --> 00:02:11.131 
大家对WWDC应用应该都很了解了吧

00:02:13.267 --> 00:02:15.202 
今天 我们会讲到WWDC应用

00:02:15.269 --> 00:02:16.770 
和NSOperation

00:02:16.904 --> 00:02:19.473 
三个主要方面

00:02:20.140 --> 00:02:23.310 
首先 我们回顾一下
NSOperation的主要概念

00:02:23.510 --> 00:02:26.580 
如何理解它的API

00:02:26.647 --> 00:02:28.382 
以及充分利用
它的强大的状态机的优势

00:02:29.283 --> 00:02:32.619 
然后 我们将看看除了基础知识外

00:02:32.686 --> 00:02:35.889 
WWDC应用还面临的挑战

00:02:36.290 --> 00:02:37.491 
以及我们如何解决这些挑战

00:02:38.192 --> 00:02:41.128 
最后 我们会讲讲

00:02:41.428 --> 00:02:42.863 
部分已经提供给你们的样品代码

00:02:46.366 --> 00:02:48.969 
首先 我们来看看一些核心概念

00:02:53.106 --> 00:02:55.175 
不管任何时候
一旦你用了NSOperation

00:02:55.242 --> 00:02:58.011 
你也总是会用到
NSOperation队列

00:02:58.879 --> 00:03:01.448 
关于NSOperation队列

00:03:01.748 --> 00:03:04.351 
可以说其实就是一个高级调度队列

00:03:04.985 --> 00:03:07.554 
相信通过使用多线程优化技术

00:03:07.654 --> 00:03:09.423 
你们对调度队列都很熟悉了

00:03:10.390 --> 00:03:13.460 
现在 我们还提供基于
NSOperation队列的包装器

00:03:13.660 --> 00:03:15.529 
然我们可以获得一些功能

00:03:17.064 --> 00:03:18.131 
比如说

00:03:20.667 --> 00:03:24.471 
NSOperation队列
可以很容易取消

00:03:24.538 --> 00:03:27.808 
还未执行的操作

00:03:28.675 --> 00:03:31.578 
虽然你可以通过调度块来取消

00:03:31.945 --> 00:03:33.380 
这是很机智的做法

00:03:33.680 --> 00:03:36.216 
但是NSOperation队列
可以让操作更简单

00:03:39.052 --> 00:03:39.887 
另一个

00:03:39.953 --> 00:03:42.089 
你可从NSOperation
队列获得的是

00:03:42.155 --> 00:03:44.424 
一个属性 叫做最大并行操作计数

00:03:45.058 --> 00:03:47.427 
为更好的理解它

00:03:47.494 --> 00:03:48.729 
我们先来看一个小动画

00:03:52.165 --> 00:03:54.635 
若将NSOperation队列的

00:03:54.701 --> 00:03:57.037 
最大并行操作计数设为1

00:03:58.038 --> 00:03:58.972 
基本上

00:03:59.039 --> 00:04:00.908 
就可以将NSOperation队列

00:04:00.974 --> 00:04:02.509 
做成一个串行操作队列

00:04:04.278 --> 00:04:07.548 
在队列中加载多个操作

00:04:09.349 --> 00:04:12.219 
最大并行操作计数为1时

00:04:12.753 --> 00:04:15.522 
队列将一个一个完成操作

00:04:15.822 --> 00:04:17.156 
并按照顺序执行

00:04:17.791 --> 00:04:20.459 
在前一个操作未完成前

00:04:20.594 --> 00:04:22.362 
下个操作是无法开始的

00:04:23.564 --> 00:04:24.731 
这是一个串行队列

00:04:27.835 --> 00:04:30.137 
可是 通过默认

00:04:30.204 --> 00:04:32.439 
这个属性的数值是默认数值

00:04:32.940 --> 00:04:35.776 
意思是说和系统允许的一样多

00:04:36.443 --> 00:04:41.815 
也就是说操作队列
可以同时执行多重操作

00:04:41.882 --> 00:04:45.085 
正如系统资源所允许的那样

00:04:46.520 --> 00:04:48.088 
在这个案例中

00:04:48.155 --> 00:04:51.592 
操作队列可能一次执行
两个操作

00:04:53.627 --> 00:04:56.230 
可以改变像这个操作队列的
行为的能力

00:04:56.296 --> 00:04:58.198 
可以说是非常强大的

00:04:58.498 --> 00:05:00.868 
在操作队列创建时

00:05:00.968 --> 00:05:02.102 
我们并不需要做决定

00:05:07.841 --> 00:05:09.843 
这就是NSOperation队列

00:05:10.477 --> 00:05:12.379 
现在来看NSOperation

00:05:14.281 --> 00:05:17.551 
既然队列是调度队列之外的
高级包装器

00:05:17.951 --> 00:05:19.920 
我们也可以将NSOperation

00:05:19.987 --> 00:05:22.689 
理解成是调度块之外的
高级包装器

00:05:24.424 --> 00:05:25.626 
现在 一般来说

00:05:25.692 --> 00:05:28.662 
NSOperation运行时间

00:05:28.729 --> 00:05:30.931 
比块的运行时间
稍微多了些

00:05:31.798 --> 00:05:34.801 
块的执行通常只需几纳秒

00:05:34.868 --> 00:05:37.371 
甚至是毫秒

00:05:38.372 --> 00:05:42.309 
换句话说NSOperation
花费更长的时间

00:05:42.376 --> 00:05:45.145 
从数毫秒甚至到数分钟

00:05:45.245 --> 00:05:46.680 
随后我们会讲到这点

00:05:49.183 --> 00:05:51.885 
NSOperation
另一个很棒的地方是

00:05:51.985 --> 00:05:55.522 
因为它是一个类
可以被划分成子类

00:05:55.722 --> 00:05:59.159 
你也可以自定义它的执行逻辑

00:06:00.360 --> 00:06:02.496 
为将NSOperation
划分为子类

00:06:03.030 --> 00:06:04.798 
我们来看下它的生命周期

00:06:06.099 --> 00:06:08.068 
当你创建NSOperation时

00:06:09.636 --> 00:06:11.338 
它总是从一个被称为

00:06:12.739 --> 00:06:14.107 
待定状态的状态中
开始

00:06:14.274 --> 00:06:16.510 
所以 当它被初始化

00:06:16.844 --> 00:06:19.980 
并被放到操作队列时
这就是操作

00:06:21.515 --> 00:06:22.649 
现在 在某一时刻

00:06:23.183 --> 00:06:24.518 
操作已准备好可以开始执行

00:06:24.751 --> 00:06:26.253 
它进入就绪状态

00:06:26.320 --> 00:06:29.723 
准备就绪后

00:06:30.457 --> 00:06:32.626 
操作队列将完成队列排列

00:06:32.693 --> 00:06:34.261 
并开始执行

00:06:34.895 --> 00:06:38.632 
正如我所说的
这执行可能用掉数毫秒

00:06:38.699 --> 00:06:40.467 
或数分钟 甚至更长时间

00:06:44.738 --> 00:06:46.340 
执行结束后

00:06:47.774 --> 00:06:51.311 
操作进入完成状态
它的完成状态

00:06:52.679 --> 00:06:53.614 
非常的简单

00:06:55.649 --> 00:06:57.584 
操作可以做的另一件事是

00:06:57.651 --> 00:06:58.952 
可以在任何时候

00:06:59.620 --> 00:07:01.555 
进入取消状态

00:07:02.923 --> 00:07:04.625 
我们来看看取消

00:07:08.762 --> 00:07:11.431 
NSOperation中的
取消被定义为

00:07:11.498 --> 00:07:14.434 
一种简单的布尔属性被取消

00:07:15.235 --> 00:07:17.638 
理解这个属性的关键点是

00:07:18.138 --> 00:07:20.140 
它只改变

00:07:20.207 --> 00:07:21.542 
属性的状态

00:07:21.909 --> 00:07:24.211 
当你取消操作时
所出现的只是

00:07:24.278 --> 00:07:26.413 
布尔数值快速翻动

00:07:28.182 --> 00:07:30.651 
当你在划分
NSOperation子类时

00:07:30.717 --> 00:07:32.819 
取消NSOperation
意味着什么

00:07:32.886 --> 00:07:35.622 
取决于你的意图是什么

00:07:36.323 --> 00:07:37.191 
比如说

00:07:37.858 --> 00:07:40.527 
你的操作正在执行网络任务

00:07:40.594 --> 00:07:42.863 
取消操作意味着

00:07:42.930 --> 00:07:46.500 
取消网络通信

00:07:47.534 --> 00:07:49.036 
又或许

00:07:49.102 --> 00:07:51.638 
你的操作在执行一些数据处理

00:07:51.939 --> 00:07:54.241 
取消操作

00:07:54.308 --> 00:07:56.710 
可能就是放弃处理

00:07:57.411 --> 00:07:59.479 
所以当你划分
NSOperation子类时

00:07:59.646 --> 00:08:02.015 
务必观察数值变化

00:08:02.082 --> 00:08:05.085 
并在需要作出反应时
做出正确的反应

00:08:07.621 --> 00:08:08.755 
关于取消 你还需要知道

00:08:08.822 --> 00:08:11.825 
它对竞态条件很敏感

00:08:13.260 --> 00:08:14.294 
这是什么意思呢

00:08:14.628 --> 00:08:17.731 
试想一下
有个在后台执行的操作

00:08:18.465 --> 00:08:20.601 
或许在你的UI中

00:08:20.667 --> 00:08:22.069 
有个取消按钮

00:08:22.135 --> 00:08:23.570 
可以取消这个操作

00:08:25.172 --> 00:08:27.040 
若用户轻敲取消按钮

00:08:27.307 --> 00:08:29.643 
它需要一点时间

00:08:29.710 --> 00:08:33.113 
将取消信息从主队列

00:08:33.746 --> 00:08:35.282 
传递到后台的操作中

00:08:36.450 --> 00:08:39.285 
若在那段传递时间里

00:08:39.352 --> 00:08:41.989 
你的操作完成执行

00:08:42.655 --> 00:08:45.225 
那么你的操作将无法被取消

00:08:45.492 --> 00:08:48.362 
因为一个操作

00:08:48.662 --> 00:08:49.997 
无法从完成状态回到取消状态

00:08:51.131 --> 00:08:54.468 
所以知道这点很重要

00:08:54.535 --> 00:08:57.471 
你试图取消操作

00:08:57.771 --> 00:08:59.439 
但事实上 有些情况无法取消

00:09:00.941 --> 00:09:04.044 
然而 如果你不需要取消操作

00:09:04.378 --> 00:09:05.946 
那就很简单了

00:09:06.446 --> 00:09:08.715 
你所需做的 只是调用取消方法

00:09:11.185 --> 00:09:12.686 
这就是取消

00:09:14.354 --> 00:09:16.490 
现在来看看另一个有趣的状态

00:09:17.257 --> 00:09:18.425 
叫做就绪

00:09:20.894 --> 00:09:24.831 
NSOperation的准备
就绪就像取消一样

00:09:25.199 --> 00:09:28.368 
被定义成一种简单的布尔属性
即准备就绪

00:09:29.803 --> 00:09:31.438 
这个属性的意思是

00:09:31.839 --> 00:09:34.508 
操作已准备好可以执行了

00:09:35.375 --> 00:09:36.877 
我们来看看

00:09:36.944 --> 00:09:40.280 
它如何与操作队列中的
操作相互作用

00:09:41.648 --> 00:09:44.551 
再一次
我们有了串行操作队列

00:09:45.953 --> 00:09:48.055 
载入多个操作

00:09:48.121 --> 00:09:51.024 
所有操作都处在
最初的蓝色待定状态

00:09:52.226 --> 00:09:54.127 
尽管 比如 在这个案例中

00:09:54.328 --> 00:09:58.632 
第四个操作也在队列里

00:09:58.699 --> 00:10:02.936 
但是进入就绪状态的
第一个操作

00:10:03.070 --> 00:10:06.340 
才是即将被执行的第一个操作

00:10:06.940 --> 00:10:09.943 
所以一旦操作准备就绪
它就开始执行

00:10:11.411 --> 00:10:14.281 
随后 当其他操作准备就绪

00:10:14.848 --> 00:10:17.518 
它们将推进队列 并被执行

00:10:19.052 --> 00:10:21.088 
在这个案例中
因为这是一个串行队列

00:10:21.154 --> 00:10:25.559 
一次只能执行一个

00:10:25.692 --> 00:10:28.262 
若两个操作同时准备就绪

00:10:28.829 --> 00:10:31.131 
拥有较高优先权的操作
获得较早执行顺序

00:10:31.532 --> 00:10:33.333 
随后才是优先权较低的那个

00:10:33.934 --> 00:10:37.137 
当其他操作也准备就绪了

00:10:37.404 --> 00:10:39.973 
它们也将赢得队列
并被执行

00:10:42.042 --> 00:10:43.343 
以上简要介绍了准备就绪

00:10:46.180 --> 00:10:47.548 
那我们可以用它来做什么呢

00:10:49.383 --> 00:10:51.919 
我们可以用它来创建相关性

00:10:53.086 --> 00:10:57.090 
相关性是用来表达

00:10:57.491 --> 00:10:59.626 
操作的严格排序的一种方法

00:10:59.693 --> 00:11:03.163 
我们要先执行这个
然后执行那个

00:11:07.968 --> 00:11:10.170 
相关性灵活的地方在于

00:11:10.604 --> 00:11:12.105 
它提供了

00:11:12.172 --> 00:11:16.577 
准备就绪操作的基础定义

00:11:18.612 --> 00:11:19.847 
通过默认设置

00:11:20.414 --> 00:11:22.583 
当操作的相关性完成执行时

00:11:22.649 --> 00:11:25.452 
操作也准备就绪

00:11:25.519 --> 00:11:27.521 
该行为是自动的

00:11:30.090 --> 00:11:33.060 
相关性另一个灵活的地方在于

00:11:33.827 --> 00:11:36.563 
它们不受操作队列的限制

00:11:36.797 --> 00:11:37.631 
这是什么意思呢

00:11:38.365 --> 00:11:41.535 
若你的应用中有两个操作队列

00:11:43.103 --> 00:11:45.372 
第一个队列中的操作

00:11:45.439 --> 00:11:49.009 
可以取决于
第二个队列中的操作

00:11:49.443 --> 00:11:50.811 
随后我们会说说

00:11:50.878 --> 00:11:54.114 
它如何让
一些真正强大的模态成为可能

00:11:55.315 --> 00:11:57.851 
现在 在你的操作中创建相关性

00:11:58.285 --> 00:11:59.887 
很简单

00:12:00.654 --> 00:12:04.224 
我所需做的是
使用增加相关性方法

00:12:04.658 --> 00:12:05.626 
在这个案例中

00:12:06.026 --> 00:12:11.999 
操作B将取决于
操作A的成功执行

00:12:12.499 --> 00:12:17.571 
操作B将等到操作A执行
完毕后才开始执行

00:12:18.639 --> 00:12:19.907 
这是确定的

00:12:22.242 --> 00:12:26.713 
关于相关性 我们会碰到一些问题

00:12:27.314 --> 00:12:29.149 
比如操作停顿

00:12:30.350 --> 00:12:32.219 
如果我们有操作A

00:12:32.719 --> 00:12:37.257 
和取决于操作A执行的操作B

00:12:37.991 --> 00:12:38.926 
这没有问题

00:12:39.826 --> 00:12:45.832 
然而 要是我无意中
让A也取决于B

00:12:46.767 --> 00:12:49.736 
那么这两个操作将无法执行

00:12:50.037 --> 00:12:52.739 
因为它们彼此
都在等待对方完成

00:12:52.806 --> 00:12:56.410 
既然都在等 
那也就是没有开始了

00:12:57.277 --> 00:12:58.946 
所以 当你在你的应用中

00:12:59.012 --> 00:13:01.682 
创建相关性时 不要这么做

00:13:05.319 --> 00:13:08.922 
现在WWDC应用到处都在用相关性

00:13:09.723 --> 00:13:13.293 
一个很简单的例子
当你在你的app上

00:13:13.360 --> 00:13:16.396 
点击增加到收藏夹按钮时
会发生什么

00:13:16.563 --> 00:13:18.599 
这个很可能你们都做过

00:13:20.634 --> 00:13:21.768 
当你点击按钮

00:13:22.336 --> 00:13:24.304 
我们先首先创建一个操作

00:13:24.371 --> 00:13:25.572 
叫做登录操作

00:13:25.672 --> 00:13:30.077 
这个操作可确保你

00:13:30.143 --> 00:13:33.547 
使用开发者的名字和密码
登录到app上

00:13:34.081 --> 00:13:39.319 
接下来
我们将创建另一个操作

00:13:39.953 --> 00:13:41.355 
叫做用户信息操作

00:13:42.089 --> 00:13:45.158 
这个操作确保
你的用户名和密码

00:13:45.225 --> 00:13:48.929 
比如说 就是开发者的用户名和密码

00:13:48.996 --> 00:13:53.033 
而不是iTunes用户名和密码

00:13:53.834 --> 00:13:57.037 
这样你的Apple ID
就是开发者AppleID了

00:13:59.406 --> 00:14:02.176 
现在 WWDC应用的收藏夹

00:14:02.242 --> 00:14:03.477 
保存在CloudKit中

00:14:03.777 --> 00:14:06.246 
我就需要另一个操作

00:14:06.480 --> 00:14:09.016 
确保我们可以获得
你的iCloud账号

00:14:09.950 --> 00:14:11.451 
这是后台进行的

00:14:11.752 --> 00:14:14.054 
因为我并未请求允许

00:14:14.121 --> 00:14:16.123 
查看你在app上的
第一个和最后一个名字

00:14:17.291 --> 00:14:19.326 
我们需要确保你有一个
iCloud账号

00:14:20.093 --> 00:14:21.028 
最后

00:14:21.828 --> 00:14:24.531 
我们创建保存收藏夹操作

00:14:24.731 --> 00:14:25.799 
这取决于

00:14:25.866 --> 00:14:28.936 
成功完成
关于你是一名开发者的验证

00:14:29.336 --> 00:14:30.971 
和成功完成

00:14:31.038 --> 00:14:33.006 
你拥有iCloud账号的验证

00:14:35.409 --> 00:14:36.510 
这只是一个简单的例子

00:14:37.010 --> 00:14:38.745 
我们来看看复杂点的事例

00:14:41.548 --> 00:14:44.084 
当WWDC应用启动

00:14:44.151 --> 00:14:45.953 
我们需要一堆的设置

00:14:47.020 --> 00:14:50.691 
首先我们需要下载
一个小的配置文件

00:14:51.225 --> 00:14:52.860 
这个文件将提供一些信息

00:14:52.926 --> 00:14:53.827 
比如

00:14:53.894 --> 00:14:56.563 
应用的最新支持版本是什么

00:14:56.830 --> 00:14:58.866 
有什么特性 等等

00:15:00.901 --> 00:15:02.903 
所以 文件下载后

00:15:02.970 --> 00:15:04.638 
我们需要检查版本

00:15:04.705 --> 00:15:07.341 
确保所运行的版本
就是WWDC应用最新版本

00:15:08.742 --> 00:15:11.178 
app版本检查完毕后

00:15:11.645 --> 00:15:14.248 
就可以开始下载
一些有用的信息

00:15:14.681 --> 00:15:17.184 
比如新闻标签里的新闻

00:15:17.618 --> 00:15:21.154 
发布会时间表

00:15:21.221 --> 00:15:22.956 
时间表下载后

00:15:23.490 --> 00:15:26.093 
就可以开始导入
存放在iCloud中的收藏夹了

00:15:26.159 --> 00:15:28.729 
以及导入提交的反馈信息

00:15:28.896 --> 00:15:31.398 
在App中可以看到 另外

00:15:31.465 --> 00:15:33.400 
我们还可以下载视频文件

00:15:34.935 --> 00:15:37.971 
所有这些均需要
时间表事先准备就绪

00:15:39.106 --> 00:15:40.174 
最后

00:15:41.308 --> 00:15:44.311 
我们可以保存
NSManaged对象环境

00:15:45.112 --> 00:15:46.847 
在这里 我们保存了所有的信息

00:15:47.814 --> 00:15:49.783 
我们来看看

00:15:50.050 --> 00:15:51.919 
相关性和操作生命周期

00:15:52.653 --> 00:15:55.155 
如何影响这些操作的执行

00:15:55.522 --> 00:15:56.990 
我们要将它们

00:15:57.057 --> 00:15:58.992 
全部移到设定为待定操作状态

00:16:00.027 --> 00:16:01.328 
现在

00:16:01.395 --> 00:16:04.298 
下载app设置的第一个操作
没有相关性

00:16:04.565 --> 00:16:06.867 
因此它立刻准备就绪 可以执行

00:16:07.568 --> 00:16:11.205 
我们的操作队列即将完成

00:16:11.405 --> 00:16:13.774 
开始执行 随后它将完成执行

00:16:14.708 --> 00:16:15.742 
现在 当它完成时

00:16:16.910 --> 00:16:20.414 
版本检查操作

00:16:20.480 --> 00:16:21.582 
也立马准备就绪

00:16:22.049 --> 00:16:24.685 
推进队列 然后开始执行

00:16:27.054 --> 00:16:28.589 
当它完成时

00:16:28.655 --> 00:16:32.626 
第三个操作也同时准备就绪
可以开始执行

00:16:34.294 --> 00:16:36.463 
它们即将开始执行

00:16:37.865 --> 00:16:39.433 
当他们完成执行时

00:16:40.133 --> 00:16:42.669 
越来越多的操作
也准备好可以执行了

00:16:43.103 --> 00:16:45.472 
它们将推进队列 并开始执行

00:16:46.740 --> 00:16:48.842 
需要明白和注意的
一件重要事情是

00:16:48.909 --> 00:16:51.245 
在所有其他操作
全部执行完毕之前

00:16:51.612 --> 00:16:53.447 
保存环境的操作是

00:16:53.580 --> 00:16:58.018 
没办法准备就绪 等待执行的

00:16:58.719 --> 00:17:02.089 
通过使用相关性
可以确保

00:17:02.155 --> 00:17:06.292 
操作按照正确的顺序进行
不会出现失控的情况

00:17:06.926 --> 00:17:08.328 
所以现在 这个准备就绪

00:17:08.729 --> 00:17:11.198 
可以执行 完成了

00:17:11.397 --> 00:17:13.099 
这样App的启动就可以持续进行

00:17:14.233 --> 00:17:16.002 
以上就是关于相关性的内容

00:17:19.540 --> 00:17:22.742 
总的来说NSOperation
是一种极好的方法

00:17:22.809 --> 00:17:24.845 
可以用来提取代码中的逻辑

00:17:26.180 --> 00:17:28.615 
通过在操作中放入逻辑

00:17:29.216 --> 00:17:33.287 
简化逻辑变化

00:17:33.353 --> 00:17:36.056 
因为我们处理的是单独的工作

00:17:36.123 --> 00:17:38.125 
很多就像我们处理块一样

00:17:39.293 --> 00:17:40.661 
作为例子

00:17:41.495 --> 00:17:43.530 
今年的WWDC应用中

00:17:43.597 --> 00:17:47.601 
收藏夹和反馈的保存位置

00:17:47.668 --> 00:17:50.804 
从后端移到CloudKit

00:17:51.939 --> 00:17:53.707 
此刻 请大家想想

00:17:54.041 --> 00:17:58.145 
将你的应用从自定义
从你正在使用的任何服务上

00:17:58.245 --> 00:18:01.348 
转移到CloudKit上
需要做些什么

00:18:02.249 --> 00:18:05.219 
获得网络通信的
代码的所有地方

00:18:05.285 --> 00:18:08.288 
服务器供应商复杂事情的
所有相关性

00:18:08.355 --> 00:18:12.059 
如果你突然对这些变得很恐慌

00:18:13.227 --> 00:18:15.462 
这就是
应该使用操作了

00:18:16.763 --> 00:18:18.265 
在WWDC应用中

00:18:18.332 --> 00:18:21.602 
我们所有的网络通信都在操作之后进行

00:18:22.002 --> 00:18:24.238 
这意味着后台将从

00:18:24.304 --> 00:18:27.374 
使用自定义服务
变为使用CloudKit

00:18:28.008 --> 00:18:31.411 
我们要做的就是
重新编写这四个小的类别

00:18:31.612 --> 00:18:33.247 
这只需要花费我们不到一天的时间

00:18:33.313 --> 00:18:35.849 
然后还需要另外几天
来测试我们的改动

00:18:36.149 --> 00:18:38.785 
这个过程简单但是琐碎

00:18:41.388 --> 00:18:43.657 
现在 这所有的一切 也许会令你疑惑

00:18:43.724 --> 00:18:45.359 
那多线程优化技术呢

00:18:47.628 --> 00:18:50.330 
多线程优化技术绝对会占有一席之地

00:18:50.664 --> 00:18:52.566 
事实上
当你下载一组示例代码做准备时

00:18:52.633 --> 00:18:55.736 
仔细查看 你会发现

00:18:55.802 --> 00:18:59.106 
我们在示例代码中
使用了多线程优化技术

00:19:00.274 --> 00:19:02.976 
当无法完全使用
NSOperation时

00:19:03.544 --> 00:19:05.379 
比如 任何时候 当你需要

00:19:05.445 --> 00:19:09.650 
从一个队列到另一个队列调用一个方法

00:19:10.217 --> 00:19:12.152 
你都不需要将其打包进一个操作中去

00:19:12.719 --> 00:19:15.589 
你需要更快更简便的方法

00:19:16.089 --> 00:19:18.058 
如果你使用信号量

00:19:18.292 --> 00:19:19.459 
或调度组来做实现

00:19:19.526 --> 00:19:22.963 
这些都很适合使用多线程优化技术

00:19:25.299 --> 00:19:27.467 
所以 那些就是基础技术

00:19:28.735 --> 00:19:29.803 
现在看看更高级的技术

00:19:32.139 --> 00:19:35.175 
现在 我们意识到其中一件事
在WWDC应用中

00:19:35.242 --> 00:19:40.147 
我们实现了UI交互

00:19:40.581 --> 00:19:43.851 
但仍需其参与在操作链中

00:19:44.351 --> 00:19:45.919 
比如 身份验证

00:19:45.986 --> 00:19:48.055 
我们之前谈论了保存收藏夹

00:19:48.689 --> 00:19:50.023 
我们需要确保你已经登录了

00:19:50.190 --> 00:19:51.325 
但如果你没有呢

00:19:52.960 --> 00:19:57.564 
那么我们意识到
我们可以设置UI元素

00:19:57.631 --> 00:20:00.901 
UI功能存在于我们的操作之中

00:20:01.368 --> 00:20:04.071 
比如 在WWDC应用中

00:20:04.171 --> 00:20:06.440 
向上滑动的身份验证对话框

00:20:06.507 --> 00:20:08.642 
其实是NSOperation

00:20:11.211 --> 00:20:14.481 
无论何时 当你通过WWDC观看视频

00:20:14.848 --> 00:20:19.553 
我们都将其压缩为“观看视频”操作

00:20:20.020 --> 00:20:22.723 
所以 我们所要做的就是

00:20:22.890 --> 00:20:25.192 
用适宜的视频资源创立一个操作

00:20:25.259 --> 00:20:26.793 
并将其放置在我们的操作队列之中

00:20:27.060 --> 00:20:29.329 
而后一切就都将井然有序了

00:20:32.032 --> 00:20:36.904 
更甚者当你看见WWDC应用的报警

00:20:37.237 --> 00:20:40.140 
这也我们将UI放置到

00:20:40.207 --> 00:20:43.911 
NSOperation内部
的一个良好应用

00:20:45.379 --> 00:20:48.649 
当我们处理不同模态UI时

00:20:48.715 --> 00:20:51.418 
我们发现了潜在原则

00:20:51.485 --> 00:20:56.023 
所以 当一个UI逐步
接管了整个应用的资源

00:20:56.156 --> 00:20:59.393 
这时候可以进行打包

00:20:59.560 --> 00:21:02.329 
一起打包进
NSOperation之中

00:21:04.231 --> 00:21:05.532 
重申一下

00:21:05.599 --> 00:21:07.634 
当你第一次使用WWDC应用时

00:21:08.001 --> 00:21:09.203 
你会看见一个对话框

00:21:09.670 --> 00:21:12.472 
询问我们是否能够收集一些

00:21:12.539 --> 00:21:13.774 
你使用应用时的简单数据

00:21:14.842 --> 00:21:16.410 
对话框出现时

00:21:17.211 --> 00:21:18.645 
这个UI警报管理者

00:21:19.012 --> 00:21:21.915 
事实上开始在
NSOperation内部运行

00:21:24.685 --> 00:21:25.752 
或者是登陆页面

00:21:25.919 --> 00:21:27.988 
如果你尝试添加一些东西到收藏夹

00:21:28.055 --> 00:21:29.790 
或对某个板块留言反馈

00:21:30.691 --> 00:21:32.759 
这都是NSOperation

00:21:36.997 --> 00:21:38.665 
接下来我们会遇见的是

00:21:39.066 --> 00:21:42.169 
有时我们想执行简单的区块逻辑操作

00:21:42.236 --> 00:21:46.273 
但我们还想参与

00:21:46.340 --> 00:21:50.310 
内部的机械操作

00:21:50.878 --> 00:21:52.980 
所以我们转向区块操作

00:21:53.046 --> 00:21:54.281 
NS区块操作

00:21:54.348 --> 00:21:56.350 
以及我们创建的其他自定义操作

00:21:58.585 --> 00:22:01.355 
这就是一个
NSOperation在执行区块

00:22:01.688 --> 00:22:03.090 
也许你会问

00:22:03.156 --> 00:22:07.094 
那么 如果NSOperation
是区块的一个抽象概念

00:22:07.728 --> 00:22:09.396 
为什么我又会回过头来

00:22:09.463 --> 00:22:11.765 
在NSOperation
内部使用区块呢

00:22:13.066 --> 00:22:14.368 
那是因为通过

00:22:14.434 --> 00:22:16.470 
在NSOperation内部
设置区块

00:22:16.737 --> 00:22:20.073 
你可以获得

00:22:21.141 --> 00:22:23.010 
许多NSOperation的好功能

00:22:23.076 --> 00:22:25.445 
比如相关性

00:22:27.247 --> 00:22:29.183 
让我们看看我们能用它来做些什么

00:22:29.650 --> 00:22:34.755 
看看在WWDC应用中
当你点击反馈按钮时会发生什么

00:22:38.659 --> 00:22:40.327 
好的 离开反馈按钮

00:22:42.362 --> 00:22:43.931 
想执行一个segue

00:22:44.164 --> 00:22:46.567 
想呈现一个视图管理器

00:22:46.633 --> 00:22:52.472 
好让你给出五颗星表示非常满意
四颗星表示满意

00:22:54.341 --> 00:22:55.843 
我们会执行这个segue

00:22:56.176 --> 00:22:58.946 
所以我们将这个
segue设置在区块里面

00:22:59.246 --> 00:23:00.747 
然后将这个区块

00:23:01.081 --> 00:23:03.383 
放置进区块操作

00:23:04.785 --> 00:23:08.922 
现在我们允许你离开反馈
如果你已经注册完这个应用

00:23:09.389 --> 00:23:13.760 
所以我们需要验证
用你的开发者账号已经登录

00:23:13.827 --> 00:23:15.796 
就像我们添加收藏夹时做的那样

00:23:17.431 --> 00:23:20.634 
为了验证你拥有一个开发者账号

00:23:20.801 --> 00:23:22.636 
我们需要确定你已经成功登录

00:23:24.671 --> 00:23:30.043 
所以通过执行区块
操作内部的segue

00:23:30.577 --> 00:23:32.145 
我们能保证

00:23:32.913 --> 00:23:35.916 
在你登录之后

00:23:36.717 --> 00:23:38.552 
不会再呈现登录页面

00:23:40.454 --> 00:23:42.256 
这是非常强大的功能

00:23:42.623 --> 00:23:45.058 
我们在描述一个非常复杂的行为

00:23:45.125 --> 00:23:47.861 
一系列的事情

00:23:48.061 --> 00:23:50.531 
都是依靠使用操作和相关性

00:23:53.066 --> 00:23:55.502 
在我们编写WWDC应用过程中

00:23:55.569 --> 00:23:58.438 
我们注意到在某些情况

00:23:58.505 --> 00:24:00.841 
我们在重复大量的同样操作

00:24:00.941 --> 00:24:03.477 
比如 我们已经看到

00:24:03.544 --> 00:24:07.414 
注册和用户信息操作过几次了

00:24:09.650 --> 00:24:12.052 
那么我们就想如果能

00:24:12.119 --> 00:24:14.521 
创造一种自动操作方法

00:24:14.588 --> 00:24:15.722 
不是很好吗

00:24:16.857 --> 00:24:19.193 
所以我们提出一种方法

00:24:19.259 --> 00:24:21.762 
形成其相关的操作

00:24:22.596 --> 00:24:24.665 
换言之 我们想表达

00:24:24.731 --> 00:24:28.001 
就是我们不想执行那些总是

00:24:28.202 --> 00:24:31.572 
需要执行的事

00:24:32.873 --> 00:24:34.741 
所以 让我们在此看看

00:24:34.975 --> 00:24:36.643 
收藏夹和Cloudkit

00:24:37.845 --> 00:24:39.413 
或下载一个通行证

00:24:40.013 --> 00:24:41.682 
亦或看看

00:24:41.748 --> 00:24:44.551 
WWDC应用中需要登录的情况

00:24:47.788 --> 00:24:50.424 
所以 当你点击“添加收藏夹”按钮时

00:24:50.824 --> 00:24:55.162 
我们做的就是常见一个单一操作

00:24:55.562 --> 00:24:56.697 
来添加收藏夹

00:24:57.064 --> 00:25:00.234 
这将打包某些信息

00:25:01.001 --> 00:25:02.302 
如这个会议的标志

00:25:02.369 --> 00:25:05.305 
以及你是否想添加到收藏夹或进行移除

00:25:05.372 --> 00:25:07.074 
一个布尔标识符

00:25:08.976 --> 00:25:11.578 
现在 这个“收藏”操作

00:25:11.645 --> 00:25:14.081 
需要获得允许才能执行

00:25:14.615 --> 00:25:17.885 
所以它自动的形成了两个相关性

00:25:18.986 --> 00:25:21.421 
一个用来确认你是开发者

00:25:21.488 --> 00:25:23.624 
另一个保证我们获得iCloud账号

00:25:26.093 --> 00:25:29.663 
现在 这个操作保证了

00:25:29.730 --> 00:25:33.166 
你作为开发者能确保登录账号

00:25:33.600 --> 00:25:36.770 
所以形成了相关性

00:25:37.638 --> 00:25:39.039 
从而确保你登录成功

00:25:39.806 --> 00:25:42.409 
这样我们能够

00:25:43.243 --> 00:25:45.212 
简单保存应用密码

00:25:45.279 --> 00:25:47.748 
我们只需要创立一个单一操作

00:25:48.515 --> 00:25:51.318 
然后它会自动形成相关性

00:25:51.785 --> 00:25:55.822 
可能稍后 如果我们想要移除代码

00:25:56.590 --> 00:25:58.625 
那么需要登录才能添加收藏夹

00:25:58.959 --> 00:26:01.128 
我们只需移除一小段

00:26:01.461 --> 00:26:04.498 
执行收藏操作的代码

00:26:04.565 --> 00:26:07.234 
那么该相关性就被移除了

00:26:07.301 --> 00:26:10.671 
这样就移除了整个应用中的相关性

00:26:11.305 --> 00:26:13.373 
我们并不需要检查

00:26:13.440 --> 00:26:15.209 
每一个“添加收藏”位置

00:26:15.509 --> 00:26:16.677 
并改写它们的代码

00:26:23.050 --> 00:26:25.319 
现在 我们还想要确认

00:26:26.153 --> 00:26:28.655 
其他条件也得到满足

00:26:30.224 --> 00:26:33.760 
我们需要能够将准备状态进行扩展

00:26:34.161 --> 00:26:37.364 
在允许执行操作的情况下

00:26:37.664 --> 00:26:39.366 
进行扩展

00:26:40.267 --> 00:26:42.603 
我们可以举出一些示例

00:26:43.737 --> 00:26:47.541 
比如我们只想在确实连接到网络的情况
下才执行操作

00:26:47.741 --> 00:26:50.010 
比如 如果你尝试

00:26:50.077 --> 00:26:52.479 
在手机处于飞行模式
的情况下添加收藏夹

00:26:52.546 --> 00:26:55.449 
当然 我们不会
使用执行CloudKit操作

00:26:58.418 --> 00:27:01.855 
我们还想要确保

00:27:01.989 --> 00:27:04.625 
在抵达某个位置后执行一个操作

00:27:05.492 --> 00:27:07.728 
那么 我们需要有能够
表达该意图的方式

00:27:11.465 --> 00:27:14.134 
又或者 我们只想
在实际登录到app后

00:27:14.201 --> 00:27:17.070 
才执行特定的操作

00:27:18.972 --> 00:27:20.607 
因此 通过扩展这个概念

00:27:20.674 --> 00:27:23.243 
让操作已经准备就绪

00:27:24.044 --> 00:27:26.480 
我们可以更有效地执行操作

00:27:27.981 --> 00:27:31.818 
因此希望大家不会遇到这样的错误

00:27:32.386 --> 00:27:34.955 
如果遇到了 说明操作出错了

00:27:35.189 --> 00:27:38.625 
因为操作还未准备就绪执行

00:27:39.660 --> 00:27:41.862 
这种情况下

00:27:41.929 --> 00:27:42.996 
由于无法连接到网络

00:27:44.798 --> 00:27:47.334 
因此 扩展该准备状态

00:27:47.401 --> 00:27:48.802 
非常有用

00:27:53.240 --> 00:27:56.677 
另外 我们还有一些操作

00:27:56.743 --> 00:27:59.346 
我们可以同时执行

00:28:00.280 --> 00:28:02.950 
因此 我们想如果需要不断

00:28:03.016 --> 00:28:05.986 
创建相同的操作序列的话
那就很麻烦了

00:28:06.053 --> 00:28:08.455 
是否可以开发一个操作

00:28:08.789 --> 00:28:10.324 
然后在其之下

00:28:10.390 --> 00:28:12.926 
创建相同的操作序列？

00:28:13.861 --> 00:28:15.562 
一个普通例子是

00:28:15.629 --> 00:28:18.332 
下载文件然后

00:28:18.398 --> 00:28:21.502 
另存到本地空间

00:28:22.836 --> 00:28:24.505 
我知道大家

00:28:24.571 --> 00:28:25.973 
对这个非常熟悉了

00:28:26.406 --> 00:28:29.343 
那么 让我们看看
我们可以如何合并操作

00:28:30.010 --> 00:28:31.011 
从而简化流程

00:28:31.745 --> 00:28:34.615 
假设我们有一个一般类的数据操作

00:28:34.681 --> 00:28:36.316 
然后它和其他东西

00:28:36.383 --> 00:28:38.185 
互相关联

00:28:38.952 --> 00:28:41.188 
现在我们想植入一个想法

00:28:41.855 --> 00:28:44.391 
好的 我们想要它做两件事

00:28:44.458 --> 00:28:48.262 
首先要包括另一个
NSOperation

00:28:48.762 --> 00:28:51.899 
然后这个操作要执行下载任务

00:28:52.666 --> 00:28:55.002 
这是个简单独立的工作

00:28:56.670 --> 00:28:59.306 
然后它会创建第二个操作

00:29:00.040 --> 00:29:04.211 
用于下载另存

00:29:04.478 --> 00:29:05.612 
然后和下载操作相互关联

00:29:05.679 --> 00:29:08.482 
这样另存操作总会在下载之后执行

00:29:09.483 --> 00:29:12.786 
现在 通过将这两个操作打包

00:29:12.853 --> 00:29:14.788 
成一个更大的操作

00:29:15.389 --> 00:29:17.691 
我们可以轻松修改

00:29:18.158 --> 00:29:20.894 
我们数据的来源

00:29:21.328 --> 00:29:22.663 
数据的格式

00:29:22.930 --> 00:29:24.631 
甚至是处理错误的方式

00:29:25.465 --> 00:29:27.668 
而我们只需在一个地方

00:29:28.135 --> 00:29:30.671 
修改即可

00:29:30.737 --> 00:29:33.941 
在输入操作中修改
因为这里是app唯一可识别的位置

00:29:36.643 --> 00:29:39.546 
现在 你没有一定要提前清楚

00:29:39.813 --> 00:29:43.317 
你需要执行的操作是什么

00:29:44.751 --> 00:29:46.553 
在WWDC应用中

00:29:46.620 --> 00:29:49.089 
在编译时间 我们无法知道

00:29:49.489 --> 00:29:52.693 
保存到CloudKit上的收藏夹
有多少内容

00:29:53.126 --> 00:29:54.228 
这样我们需要一种方式

00:29:54.294 --> 00:29:57.431 
让我们可以进行动态操作编辑

00:30:00.300 --> 00:30:04.671 
因此 我们开发了封装器
称之为抓取收藏夹操作

00:30:05.539 --> 00:30:08.475 
而且由于我们正在
包装器下使用CloudKit

00:30:08.709 --> 00:30:11.812 
我们需要执行CK请求操作

00:30:12.646 --> 00:30:15.516 
因为CloudKit是基于
NSOperation开发的

00:30:16.750 --> 00:30:18.819 
这样 我们先要执行第一个请求操作

00:30:18.886 --> 00:30:21.688 
也许WWDC上有你收藏的一个会议

00:30:22.155 --> 00:30:24.725 
因此该操作会指向那里

00:30:24.892 --> 00:30:27.394 
并获取更多的收藏内容

00:30:27.995 --> 00:30:31.231 
因此 我们现在要继续执行请求操作

00:30:31.565 --> 00:30:33.367 
直到我们接收到反馈

00:30:33.433 --> 00:30:35.702 
说明我们已经全部获得了

00:30:36.904 --> 00:30:40.307 
因此 通过使用组合模式

00:30:40.607 --> 00:30:44.478 
我们仍可以通过一个“抓取收藏夹”

00:30:44.545 --> 00:30:48.248 
操作来表达我们的操作链

00:30:48.782 --> 00:30:50.250 
但是在其之下

00:30:50.717 --> 00:30:55.222 
实际上是按次序执行多个操作

00:30:57.791 --> 00:30:59.993 
现在 在代码中的情况看起来是这样的

00:31:01.128 --> 00:31:03.497 
我们的操作有一种执行方法

00:31:03.564 --> 00:31:05.766 
而且这是所有操作的起点

00:31:06.800 --> 00:31:07.935 
因此第一次

00:31:08.535 --> 00:31:12.005 
抓取收藏夹
操作开始执行后

00:31:12.272 --> 00:31:14.107 
这里会进行初始请求

00:31:14.575 --> 00:31:18.512 
我们要为你查找收藏的会议记录

00:31:19.780 --> 00:31:21.748 
这样我们会发出请求操作

00:31:22.316 --> 00:31:24.885 
然后提交给这个方法
称之为执行请求操作

00:31:26.453 --> 00:31:28.422 
这是执行请求操作

00:31:30.023 --> 00:31:32.593 
请求操作完成后

00:31:32.793 --> 00:31:34.161 
我们需要先检查

00:31:34.228 --> 00:31:36.163 
看看是否有错误

00:31:36.396 --> 00:31:38.599 
如果有 我们要中止流程先处理错误

00:31:40.701 --> 00:31:44.137 
如果没有错误 但是存在指针

00:31:44.638 --> 00:31:46.440 
这是CloudKit
通过指针告诉我们

00:31:46.607 --> 00:31:48.976 
还有其他有待抓取

00:31:49.543 --> 00:31:52.980 
那么 我们要使用该指针在序列后

00:31:53.046 --> 00:31:55.015 
创建下一个CK请求操作

00:31:55.816 --> 00:32:00.487 
然后进行半递归式调用执行请求操作

00:32:00.888 --> 00:32:04.558 
这是我们执行多个请求操作的方法

00:32:06.493 --> 00:32:09.863 
另外 如果没有指针或者错误出现

00:32:10.097 --> 00:32:13.133 
那么是CloudKit
指示我们已经抓取完毕

00:32:13.400 --> 00:32:15.736 
这样我们可以开始导入

00:32:16.970 --> 00:32:18.372 
已经下载好的记录了

00:32:26.113 --> 00:32:28.649 
在开发过程中

00:32:28.715 --> 00:32:32.986 
有几次我们遇到视图故障

00:32:33.720 --> 00:32:35.789 
我们认为是视图故障

00:32:36.557 --> 00:32:39.326 
现在 也许大家都有
在使用app过程中

00:32:39.760 --> 00:32:41.128 
警告跳出的经历

00:32:41.895 --> 00:32:44.064 
在你准备点击关闭的时候

00:32:44.131 --> 00:32:45.432 
另一个警告又跳出来

00:32:46.133 --> 00:32:48.402 
这时你想 哦 好吧
这是发生了什么呢？

00:32:48.802 --> 00:32:50.537 
也许又在你要点击关闭的时候

00:32:50.737 --> 00:32:52.472 
又有一个跳出来

00:32:52.539 --> 00:32:55.342 
因此画面总是反反复复

00:32:55.409 --> 00:32:57.144 
你甚至不确定现在看到的是第一个警告

00:32:57.211 --> 00:32:59.046 
还是第几个警告

00:33:00.314 --> 00:33:03.951 
我们是如此想要避免
这种令人厌烦的情况

00:33:06.186 --> 00:33:07.955 
另一个我们想要的是

00:33:08.021 --> 00:33:09.923 
我们想要确保

00:33:10.791 --> 00:33:15.762 
你只会一次观看一个视频

00:33:15.829 --> 00:33:18.866 
这个问题WWDC应用现在还无法明白

00:33:18.932 --> 00:33:20.367 
如何正确处理

00:33:20.434 --> 00:33:23.170 
因此我们想要确保无论你做什么

00:33:23.670 --> 00:33:25.305 
我们都不会允许你这么做

00:33:27.908 --> 00:33:29.877 
另一个我们想确认的是

00:33:29.943 --> 00:33:32.446 
我们不会一次试图

00:33:32.513 --> 00:33:35.883 
加载多个基本数据库

00:33:37.384 --> 00:33:41.655 
因此 我们想出一个方法
用于描述互斥性

00:33:41.955 --> 00:33:47.661 
这种方法是在一个时候
只执行一种特定的操作

00:33:49.730 --> 00:33:52.599 
现在 也许你在想 哇
这个想法真复杂

00:33:52.666 --> 00:33:54.501 
具体我们如何办到呢

00:33:55.802 --> 00:33:57.437 
实际上很简单

00:33:58.272 --> 00:34:00.040 
现在我们回到那个警告的例子

00:34:01.508 --> 00:34:04.578 
假设我们创建一个操作用于显示警告

00:34:04.811 --> 00:34:06.079 
并警告用户

00:34:06.146 --> 00:34:08.549 
然后我们将其放到操作序列中

00:34:08.715 --> 00:34:11.251 
也许需要等待一下
让其他操作先完成

00:34:11.451 --> 00:34:14.721 
也许操作已经完成了一半
我们不确定

00:34:15.755 --> 00:34:17.090 
但之后发生了些事

00:34:17.591 --> 00:34:20.793 
而且我们决定再创建另一个警告操作

00:34:21.594 --> 00:34:23.096 
好的 我们要做的就是

00:34:23.330 --> 00:34:25.966 
让第二个警告操作

00:34:26.033 --> 00:34:28.168 
与第一个相关联

00:34:29.101 --> 00:34:33.841 
这正是跨队列相关性
强大之所在

00:34:34.708 --> 00:34:36.909 
因为不论警告操作

00:34:37.010 --> 00:34:40.947 
在哪个队列中执行

00:34:41.447 --> 00:34:44.885 
只要第二个操作与第一个相关

00:34:45.418 --> 00:34:52.092 
那么第二个操作
只有在第一个操作结束后才可以执行

00:34:52.926 --> 00:34:56.362 
而且 由于某些奇怪原因

00:34:56.429 --> 00:34:58.866 
我们决定创建更多的警告操作

00:34:59.066 --> 00:35:02.102 
更多的警告操作 只要我们设定

00:35:02.169 --> 00:35:05.973 
下个操作与之前的相关即可

00:35:06.039 --> 00:35:10.310 
就像一张时间关联表一样

00:35:10.811 --> 00:35:14.014 
我们可以确保操作

00:35:14.081 --> 00:35:15.382 
将彼此产生互斥性

00:35:16.817 --> 00:35:19.019 
真是功能强大啊

00:35:20.020 --> 00:35:21.522 
通过使用相关性

00:35:22.022 --> 00:35:26.260 
我们可以确保应用的行为正确

00:35:26.527 --> 00:35:29.329 
我们可以确保用户

00:35:29.396 --> 00:35:30.631 
不会同时收到多个警告

00:35:30.764 --> 00:35:34.067 
我们可以确保用户

00:35:34.134 --> 00:35:35.536 
不会一次试图观看多个视频

00:35:35.836 --> 00:35:40.307 
我们可以确保用户

00:35:40.374 --> 00:35:42.643 
不会同时加载两份数据

00:35:45.812 --> 00:35:47.948 
因此 以上是我们遇到的一些挑战

00:35:48.015 --> 00:35:51.485 
并尝试在编写WWDC
用的时候解决

00:35:52.052 --> 00:35:53.086 
还有更多

00:35:54.288 --> 00:35:56.456 
但我们认为这些真的很酷

00:35:56.857 --> 00:35:58.592 
而且我们会想到更为简单的方法

00:35:58.659 --> 00:36:00.160 
去解决我们遇到的问题

00:36:02.129 --> 00:36:04.731 
那么 我们现在谈谈样本代码

00:36:07.134 --> 00:36:10.237 
在WWDC网站上的样本代码部分

00:36:10.304 --> 00:36:12.406 
你可以找到一段样本代码

00:36:12.472 --> 00:36:14.107 
叫做高级 NSOperations

00:36:14.708 --> 00:36:16.610 
这是一个简单的app

00:36:16.677 --> 00:36:18.078 
用于显示最近的地震

00:36:19.012 --> 00:36:20.447 
但是这个app是

00:36:20.514 --> 00:36:22.716 
完全基于NSOperations的

00:36:23.417 --> 00:36:25.018 
而且该app的操作

00:36:25.085 --> 00:36:26.954 
是我们之前

00:36:27.020 --> 00:36:30.524 
从WWDC的app中提取出来

00:36:31.158 --> 00:36:32.392 
然后放进去的

00:36:32.759 --> 00:36:34.561 
这个app中的这些代码

00:36:34.628 --> 00:36:36.296 
实际上已经有好几年的历史了

00:36:36.530 --> 00:36:37.497 
非常稳定

00:36:40.367 --> 00:36:45.205 
现在 初级类别就是样本代码

00:36:45.639 --> 00:36:49.209 
这是NSOperations
的基础子类别

00:36:50.110 --> 00:36:52.312 
在样本代码中

00:36:52.379 --> 00:36:54.381 
我们在才操作中加入了两个关键特性

00:36:55.682 --> 00:36:56.517 
首先

00:36:58.085 --> 00:37:00.120 
是条件

00:37:00.187 --> 00:37:01.421 
之后我们会谈谈这点

00:37:02.456 --> 00:37:06.159 
第二个概念我们称之为“观测器”

00:37:07.261 --> 00:37:08.829 
现在在样本代码中

00:37:08.896 --> 00:37:11.632 
我们已经有许多不同种类的操作代码

00:37:11.965 --> 00:37:14.635 
我们有群操作

00:37:14.768 --> 00:37:18.272 
方便进行更多的内部操作

00:37:19.006 --> 00:37:22.476 
另外 在样本代码中
我们还有操作子类别

00:37:22.976 --> 00:37:26.013 
允许你获取
NSURLSession任务

00:37:26.413 --> 00:37:29.082 
并在NSOperation
中进行处理

00:37:29.349 --> 00:37:33.554 
这样你可以让不同任务之间进行关联

00:37:33.620 --> 00:37:37.391 
或者进行条件设定 或者设置观测器

00:37:38.225 --> 00:37:40.994 
这里有一个示范操作
用于请求你当前的位置

00:37:41.328 --> 00:37:43.096 
有时候这非常有用

00:37:43.163 --> 00:37:45.399 
我们要做的就是稍微等待一下

00:37:45.899 --> 00:37:47.234 
这里甚至还有一种操作

00:37:47.301 --> 00:37:48.836 
可以向用户显示

00:37:49.002 --> 00:37:50.771 
带按钮和块处理程序的警告

00:37:52.072 --> 00:37:54.074 
因此 NSOperation
的样本代码中

00:37:54.141 --> 00:37:56.844 
有非常多的子类

00:37:58.812 --> 00:38:02.249 
现在 操作有了条件的概念

00:38:02.583 --> 00:38:05.152 
一个条件指的是一个协议

00:38:05.219 --> 00:38:07.454 
我们定义的协议

00:38:07.521 --> 00:38:09.990 
这样 对于操作而言

00:38:10.691 --> 00:38:13.360 
可以表示它是如何生成相关性的

00:38:14.928 --> 00:38:17.998 
如何定义互斥性
以及如何扩展预备状态概念

00:38:19.833 --> 00:38:21.702 
这样 我们在样本代码中

00:38:21.969 --> 00:38:24.104 
提供了一些条件

00:38:24.304 --> 00:38:27.241 
其中之一是互斥性通用条件

00:38:27.841 --> 00:38:29.610 
这种条件表示一个操作

00:38:29.877 --> 00:38:33.580 
与相同类属的其他操作

00:38:33.647 --> 00:38:36.116 
是互相排斥的

00:38:37.284 --> 00:38:40.554 
这里我们还有可达性条件

00:38:40.621 --> 00:38:42.422 
这样通过一行代码

00:38:42.589 --> 00:38:44.491 
你可以方便地通过操作表达

00:38:44.791 --> 00:38:47.361 
只有在网速很好的情况下才执行

00:38:48.161 --> 00:38:51.498 
另外 我们还有非常多的许可类条件

00:38:52.199 --> 00:38:53.133 
比如

00:38:53.200 --> 00:38:56.637 
只有在使用特定的Cloudkit
container的情况下

00:38:56.703 --> 00:38:57.638 
才执行操作

00:38:58.071 --> 00:39:00.507 
或者当我们使用日历

00:39:00.574 --> 00:39:02.843 
或者使用照片库
或者使用通讯录

00:39:02.910 --> 00:39:05.646 
或者其他你设定条件的情况下才执行操
作

00:39:07.481 --> 00:39:08.448 
这就是条件操作

00:39:10.317 --> 00:39:12.920 
最后是操作观测器

00:39:15.088 --> 00:39:19.426 
操作观测器也是一种协议

00:39:19.493 --> 00:39:22.829 
通过这种方法

00:39:22.963 --> 00:39:27.067 
在操作过程中

00:39:27.134 --> 00:39:28.769 
操作会注意重要事件的值

00:39:29.102 --> 00:39:31.438 
比如开始执行 终止执行

00:39:31.738 --> 00:39:34.942 
以及如果该操作决定

00:39:35.309 --> 00:39:38.645 
生成稍后被执行的另一个操作

00:39:38.712 --> 00:39:43.150 
从而生成一个警告操作

00:39:44.885 --> 00:39:48.188 
另外我们有许多观测器示例

00:39:48.889 --> 00:39:49.756 
比如超时

00:39:50.724 --> 00:39:53.527 
通过在操作中简单加入超时观测器

00:39:54.394 --> 00:39:56.964 
这样观测器会进行观测确保

00:39:57.030 --> 00:39:58.365 
操作在你设定的时间范围内

00:39:58.432 --> 00:40:00.734 
执行完毕

00:40:01.134 --> 00:40:02.236 
并且 如果超时

00:40:02.302 --> 00:40:04.104 
那么观测器将自动取消操作

00:40:05.739 --> 00:40:08.976 
我认为一项利器的是背景观测器

00:40:09.409 --> 00:40:12.613 
当你将背景观测器
设定到一个操作中后

00:40:12.679 --> 00:40:16.583 
观测器会观测UI应用的状态

00:40:17.117 --> 00:40:18.652 
如果应用进入背景

00:40:19.353 --> 00:40:21.889 
那么观测器将

00:40:21.955 --> 00:40:24.625 
自动启动背景任务

00:40:25.158 --> 00:40:26.827 
然后在操作完成后

00:40:27.261 --> 00:40:29.029 
自动终止任务

00:40:29.696 --> 00:40:31.932 
这样 如果你正处理某些重要操作

00:40:31.999 --> 00:40:34.434 
比如也许你正上传数据到服务器

00:40:34.501 --> 00:40:36.436 
而你不想被终端或者暂停

00:40:37.471 --> 00:40:39.206 
一个方法是你可以

00:40:39.273 --> 00:40:42.142 
添加背景观测器到操作中

00:40:42.609 --> 00:40:46.079 
这样可以确保你在背景
有足够多的时间

00:40:46.146 --> 00:40:48.348 
这样你可以完成该上传操作

00:40:49.917 --> 00:40:52.019 
另一种方法很酷

00:40:52.085 --> 00:40:54.154 
是网络活动指示器观测器

00:40:54.888 --> 00:40:57.658 
你可以将这个观测器添加到操作中

00:40:57.724 --> 00:40:59.126 
当其启动后

00:40:59.193 --> 00:41:01.795 
观测器将在状态栏中

00:41:02.596 --> 00:41:07.167 
对互动指示器进行数值递增操作

00:41:07.234 --> 00:41:08.836 
然后当操作停止后

00:41:09.203 --> 00:41:10.971 
进行数值递减操作

00:41:11.305 --> 00:41:15.943 
这样你可以同时进行多个网络操作

00:41:16.510 --> 00:41:19.413 
并且添加其中一个网络指示器

00:41:19.479 --> 00:41:21.181 
或者观测器后

00:41:21.248 --> 00:41:23.317 
观测器会自动

00:41:23.383 --> 00:41:25.953 
显示和隐藏网络活动指示器

00:41:26.019 --> 00:41:28.155 
从此 管理这种复杂的事情

00:41:30.457 --> 00:41:32.793 
都可以完全交给操作了

00:41:33.126 --> 00:41:35.095 
而所有这一切都可以自动进行
实在是酷

00:41:35.696 --> 00:41:37.231 
另外在样本代码中

00:41:37.564 --> 00:41:39.933 
我们还提供了其他的观测器

00:41:40.000 --> 00:41:43.670 
比如能够添加任意代码块
到这三个事件中

00:41:43.971 --> 00:41:45.806 
然后让其自动重新执行

00:41:47.241 --> 00:41:48.909 
以上就是样本代码的情况

00:41:49.610 --> 00:41:52.713 
乍看之下 代码很像一个简单的应用

00:41:52.779 --> 00:41:55.849 
但是仔细一看 里面很精妙

00:41:55.916 --> 00:41:58.385 
我真的推荐大家下载看看

00:42:00.187 --> 00:42:01.321 
那么 总之

00:42:02.656 --> 00:42:06.059 
使用操作可以对应用
进行逻辑抽象处理

00:42:06.593 --> 00:42:11.632 
通过在操作中加入你的逻辑
而且之后很容易进行修改

00:42:11.832 --> 00:42:15.335 
比如我们如何将WWDC应用
跳转到使用CloudKit

00:42:15.602 --> 00:42:17.704 
这只是一个简单的改变

00:42:19.106 --> 00:42:23.777 
使用相关性可以表达
应用之间的关系

00:42:24.077 --> 00:42:28.382 
这样可以很容易
确保特定行为之间的关系

00:42:28.515 --> 00:42:30.717 
比如A行为之后必须是B行为

00:42:34.087 --> 00:42:34.922 
另外

00:42:35.822 --> 00:42:38.926 
操作让你可以描述复杂的行为

00:42:39.393 --> 00:42:43.130 
比如互斥性或者整合

00:42:43.497 --> 00:42:46.200 
这对于操作来说很简单

00:42:48.569 --> 00:42:52.539 
而且NSOperation能够允许
你花费非常少的心思

00:42:52.806 --> 00:42:54.875 
就能执行非常强大的功能

00:42:56.276 --> 00:42:58.245 
因此 我们未大家提供了相关的会议

00:42:58.645 --> 00:43:00.414 
接下来的会议是

00:43:01.215 --> 00:43:04.318 
“建立响应以及GCD的高效应用”

00:43:04.551 --> 00:43:06.653 
我们期待大家也参与GCD

00:43:06.720 --> 00:43:10.123 
这是一项非常好的实用技术

00:43:10.190 --> 00:43:12.893 
因此 我鼓励大家出席会议
或者观看视频

00:43:13.260 --> 00:43:16.096 
看看如何在你的应用中使用GCD

00:43:16.763 --> 00:43:18.031 
另外 如果你想要了解更多

00:43:18.098 --> 00:43:21.368 
关于我们的框架是如何
使用NSOperation的

00:43:21.435 --> 00:43:24.872 
你可以查看今年的CloudKit
提示和技巧大会

00:43:25.205 --> 00:43:27.941 
或者去年的
“高级CloudKit”大会

00:43:31.178 --> 00:43:34.381 
另外 我们在WWDC网站上
提供了样本代码供大家使用

00:43:34.448 --> 00:43:35.782 
建议大家去看看

00:43:36.450 --> 00:43:40.621 
我还想鼓励大家阅读开发者库中的
“线程编辑指导”部分

00:43:40.854 --> 00:43:43.290 
这里有很多有用的信息

00:43:43.524 --> 00:43:45.893 
方便大家使用NSOperation

00:43:46.360 --> 00:43:49.263 
如果你需要任何技术支持

00:43:49.396 --> 00:43:51.632 
我们建议大家可以在开发者论坛上发帖

00:43:51.832 --> 00:43:53.467 
请教
或者联系开发者技术支持部

00:43:54.902 --> 00:43:57.237 
非常谢谢
希望大家继续享受接下来的部分