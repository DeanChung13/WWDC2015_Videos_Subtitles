Swift性能優化
早上好 歡迎來到“Swift性能優化”演講現場 
我的名字是那達夫我將與我的同事邁克爾
和喬一起向大家展示如何
優化你的Swift程序
現在我們編譯器團隊的工程師熱衷於讓代碼運行得快
我們相信如果你的app得到高度優化
你可以創造出令人歎爲觀止的作品
如果你有同樣的看法那麼這個演講適合你聽
今天我首先要講一講在過去的幾年中
我們對編譯器所做的一些新的優化
之後邁克爾將描述Swift語言的底層實現
並就如何編寫高性能的
Swift代碼給大家一些建議
最後喬將演示如何使用工具來識別
和分析你的Swift代碼中的性能瓶頸
Swift是一個靈活並且安全的編程語言
有很多的功能包括閉環 協議 泛化
當然還有自動引用計數
現在你們中有些人可能把這些特性與運行緩慢聯繫在一起
因爲程序必須做更多的工作來實現這些高級功能
但Swift是一種非常快速的編程語言
可以編譯爲高度優化的本地代碼
那麼我們如何讓Swift迅速運行呢?
好 我們將編譯器優化的
目標設定爲所有的這些高級功能實現了這些目標
就可以確保那些高級功能造成的負擔是最小的
現在 我們有很多編譯器優化
但是我們沒有足夠的時間去逐一回顧
所以我決定給你們舉一個編譯器優化的例子
這種優化稱爲消除邊界檢查
在屏幕上你們可以看到一個非常簡單的循環
這個循環用數字13對陣列中的所有
元素進行掃描從而對陣列的內容進行加密
這種加密方式並不好
在陣列邊界以外進行讀寫
是一個嚴重的錯誤
也可能有安全隱患
而Swift則可以對你的程序進行保護它添加了一些代碼
能夠檢查阻止程序在陣列邊界以外進行讀寫
現在 問題是這種檢查會拖慢代碼的運行速度
另一個問題是它會阻擋其他優化
例如在運行這種檢查時
我們就不能將這段代碼向量化
所以我們已經實現了一個編譯器優化
以便將這種檢查置於循環之外使檢查的代價
可以忽略不計因爲我們並不是對陣列邊界以內遇到的
循環中的每次迭代都進行檢查
我們只在進入陣列時進行一次檢查
所以這是一個非常強大的優化
它使得數字代碼運行得更快
好吧 這是一個優化的一個例子
而我們有很多優化
我們知道這些優化起到了作用
而且非常有效因爲我們正在跟蹤數以百計的程序
和基準測試程序在過去的一年裏
我們注意到這些程序的運行速度顯著加快
每次我們添加一個新的優化
每次我們對現有的優化進行改進
我們都會注意到這些程序變得更快
現在大家不會有興趣逐一瞭解
這些程序所以我決定介紹其中的五個
現在大家在我身後的屏幕上看到的程序來自多個領域
一個是面向對象的程序
另一個是數字型的 另一個是函數型的
我相信這些程序代表了
如今用戶以Swift語言編寫的代碼類型
正如大家所見在過去的一年
這些程序明顯運行得更快
加快了兩到八倍之間這非常了不起
現在這些程序在發佈模式下進行了優化
但我知道你們也關心未優化的
程序的性能因爲你們花費大量的時間
編寫代碼進行調試並將其在模擬器運行
所以你們關心未優化程序的性能
所以這五個項目是相同的均處在調試模式
他們都未經優化
所以你們可能會問自己 等等
對優化器的改進是如何提高未優化代碼的性能的
對吧 我們做了兩件事使未優化的代碼運行得更快
首先 我們改進了Swift的運行時組件
運行時組件負責分配內存
訪問元數據以及類似這樣的事情
所以我們對它進行了優化
我們做的第二件事是現在我們能夠
更好地優化Swift標準庫
標準庫是含有陣列實現代碼詞典和設置的組件
所以通過更好地優化標準庫
我們能夠提升未優化程序的性能
我們知道在過去的一年經過優化
和未經優化的程序的性能都顯著增強
但是爲了瞭解全部的情況我想給大家做一個
Swift與Objective-C語言的比較
現在在屏幕上你可以看到兩個非常著名的基準測試程序
這是Richards和DeltaBlue
都是以面向對象的風格編寫的
根據這兩個程序的測試
Swift要比Objective-C快得多
在演講的這個階段
我不會告訴你們爲什麼Swift要比Objective-C快
但是我向諸位保證我們還會回到這張幻燈片
而且我們將談到爲什麼Swift更快
好 現在我要講些不一樣的東西
我想談談一個新的編譯器優化模式
叫做“模塊整體優化” 
它可以讓你的程序運行速度明顯加快
但在那之前我想談談Xcode編譯文件的方式
Xcode是單獨編譯每個文件的
這是一個很好的理念
因爲它可以在計算機的多個核心中並行編譯很多文件
這樣很好
它也可以重新編譯需要更新的只讀文件
所以很好
但問題是這種優化器的處理範圍僅限於一個文件
有了模塊整體優化模式編譯器能夠
一次優化整個模塊這樣的優勢很明顯
因爲它可以分析所有數據
並進行積極的優化
現在 構建整體優化模式需要更長的時間
但生成的二進制代碼通常運行得更快
在Swift 2中我們對模塊整體優化模式
進行了兩個主要的改進
首先們添加了新的依靠模塊整體
優化模式的優化
所以你們的程序有可能運行得更快
第二我們能夠實現編譯管道某些部分並行
所以在模塊整體優化模式中的編譯組件應該使用更短的時間
在我身後的屏幕上你可以看到兩個程序
它們在模塊整體優化模式下運行得更快
因爲編譯器能夠做出更好的決策
它能分析整個模塊的信息並據此做出更積極的優化
在Xcode 7中我們對優化級別菜單進行了一些更改
現在模塊整體優化是你們可以選擇的選項之一
所以我鼓勵你們在你們的程序中嘗試
模塊整體優化模式
說到這一點我想邀請邁克爾上臺
給大家講解Swift代碼的底層實現
並給大家一些關於編寫高性能Swift代碼的建議
謝謝大家
謝謝 那達夫
今天我想跟大家談談
Swift編程語言及其性能特徵的三個不同方面
對於每個方面我都會給出具體的技術大家可以用它們
來提高你們的app的性能
讓我們首先說說引用計數
一般來說編譯器可以消除大部分引用計數的負擔不需要任何幫助
但是有時候你還是會發現由於引用計數的負擔造成的代碼減速
今天我將展示兩種技術 你們可以利用
它們來減少甚至消除這種負擔
讓我們首先看看引用計數和類的關係
從而瞭解引用計數的基礎知識
這裏有一個代碼塊
它包含一個C類一個包含一個
可選C的函數和幾個變量定義
讓我們逐行看看代碼執行情況
首先我們從分配C類的新實例開始
並將其分配給變量X
注意在類別實例的頂部有一個包含數字1的框
它代表了類實例的引用計數
當然這是1 因爲目前只有一個類實例的引用 即x
然後我們將X分配給變量y
這將創建一個新的類實例的引用
導致我們增加類實例的引用計數給我們一個引用計數 2
然後我們中止了y並打開了foo
但是實際上我們並沒有中止y本身
相反我們創建了一個臨時的C並把y賦值到C
它可以充當類別實例的第三個引用
這可以導致我們再一次增加類別實例的引用計數
然後當foo退出時C被摧毀導致我們減少類別實例的引用計數
使引用計數爲2
最後我們賦值零到y和x
使類別實例的引用計數爲零
然後它被收回
注意每次我們做了一個任務
我們必須執行引用計數操作
來保持類別實例的引用計數
這是很重要的因爲我們必須一直保持記憶安全
現在對於熟知Objective-C的你們來說
當然沒有什麼新的情況發生
減量和增量被謹慎的保留
和解除
但是現在我想告訴你
一些也許更獨特更新奇的事情
也就是說結構是如何引用計數相互影響的
我要開始了...讓我們開始討論先觀察一個不包含引用的類別
這裏有一個類別點
當然 它不包含任何引用
但是它有兩個特性x和y都是浮點數
如果我存儲其中一個點在一個數組中
當然因爲它是一個類別所以我不會把它直接存儲在數組中
相反我把參照點存儲在數組中
所以當我對該數組進行迭代
並初始化循環變量p的時候
我實際上創建了一個到類別實例的新的引用
這意味着我必須執行引用計數的增加
然後,當P在循環變量的最後被摧毀的時候
我必須減少引用計數
在Objective-C中我們必須時常地
做簡單的數據結構比如點
一個你可以使用來自Foundation像NSRA數據結構的類別
然後無論你何時操作簡單的數據結構
你將會使類別產生負荷
在Swift裏我們可以使用結構...
在這種情況下我們可以使用結構解決問題
而不是一個類別
所以讓我們把點做成結構
現在我們能夠將各個點直接存儲到這個數組中
因爲Swift數組能夠直接存儲結構組
更重要的是因爲一個結構本身不需要引用計數 而且這個結構的屬性
也不需要引用計數
所以我們可以直接捨棄之前所有引用的計數在循環中
現在讓我們思考一個更加複雜的例子
假設一個結構中包含一個引用的參數
雖然一個結構其本身在任務中並不需要引用計數變量
就像我之前提到的但是它確實需要這種變量
如果一個結構中包含了一個引用參數
這是因爲分配一個結構
和獨立分配每一個屬性是等價的
所以考慮到我們之前看到的關於結構的點
它能夠很有效的被複制當我們分配它的時候就沒有引用的計數
假設有一天我在我的app上工作
我決定... 好吧我想要使每一個點
都能被畫成不同的顏色
所以我在我的結構中添加了一個UI顏色屬性
當然 Ui顏色是一個類這實際上是在我的結構中添加了一個參數
現在這就意味着在任何時刻我要分配這個結構
和獨立分配這個結構中的UI顏色
都是等價的這就意味着我必須執行一個對計數參數的修改
現在雖然使用一個包含計數參數的結構的代價並不高
我的意思是 我們通常使用類並且類也有相同的特性
現在我想給你們展示一個更加極端的例子
即一個包含很多計數字段參數的結構
這裏我有一個結構用戶我將使用它來模擬用戶在一個我寫的app中
並且每個用戶都有一些跟它相關聯的數據 即
三個字符串 一個作爲用戶的名字
一個作爲用戶的姓氏
一個作爲用戶的地址
我也有一個空間來存儲數組和一個字典
來存儲與用戶相關的特定的app數據
即使這些所有的參數都是數值類型的
在其內部 包含一個類
這個類用來管理內部數據的生命週期
這就意味着每次我分配這些結構中的一個參數
每次我都要將這個參數推送到一個函數中
事實上我不得不進行五次計數參數的修改工作
好 我們可以使用包裝函式類來操作
這裏我再次使用用戶結構
但是這次不是隻依靠它自己
它包含在一個包裝函式類中
我還可以使用類引用來操作這個結構
更重要的是如果我把這個引用當作一個函數
或我聲明-或我簽名-
用這個引用來初始化一個變量
我只是在做一個引用計數增量
現在 重要的是要注意到
這裏語義有了變化
我們已經從使用真值語義
改變爲引用語義
這樣就會導致意想不到的數據共享可能會導致
不可思議的結果或你沒想到的事情
但是有一種方式
你可以具有真值語義並且從這個最優化中受益
如果你想了解更多
請進入用值類型來構建更好的應用程序的講座
在Swift明天的任務中
在下午2:30它將是一場精彩的講座
我真的建議你去
現在我們已經談論了引用計數
我想繼續討論有關通用型的內容
這裏我有一個通用函數min
它是通過類型T的通用性 符合Swift標準庫的比較協議
從源程序的角度來看
這看起來不那麼大我的意思是它只有三行
但是實際上 幕後要比想的多的多
例如這裏實際發出的代碼
這裏我還是使用僞-Swift來代表編譯器發出的代碼
編譯器發出的代碼不是這三行 而是這
首先要注意編譯器在使用間接法來比較X和Y
這是因爲我們可以輸入兩個整數
到min函數或者我們可以輸入兩個浮點數
或是兩個字符串或我們可以輸入任何可比較類型
這樣編譯器在所有的情況下都是正確的
並且能夠處理它們中的任何一個
另外因爲編譯器不知道
是否T要求引用計數更改
它必須插入另外的間接法
這樣min T函數就能處理兩種類型T
要求引用計數和不要求引用計數的類型T
例如 對於整數而言Swift運行時內僅未進行上行調用
在這兩種情況下編譯器都處於保守模式
因爲在這種模式下編譯器須能處理任一T類系統數據
幸運的是編譯器優化能夠幫助我們消除重載
編譯器優化也稱爲泛型特殊化
本文中的函數foo將兩個整數傳遞給泛型函數min-T
執行泛型特殊化時
編譯器首先調用了函數min和foo
並且發現兩個整數被傳遞給了本文中的泛型函數min-T
編譯器可以查看
泛型函數min-T的定義因此其能夠克隆函數min-T
並且將克隆的函數進行特殊化處理
方法是將泛型類型T替換爲特殊化類型Int
隨後針對函數Int優化特殊函數
並消除與這個函數相關的所有重載
因此這樣會刪除所有引用計數即不必要的引用計數調用
並且我們可以直接對這兩個整數進行比較
最後 編譯器將泛型函數min-T的調用替換爲
特殊函數min Int的調用
以便進行進一步的優化
泛型特殊化是一個非常強大的優化方法
但其也有一個不足之處 即泛型定義的可見性
這類例子包括本文中函數min-T的泛型定義
這裏我們對包含兩個整數的泛型函數min-T進行計算
在這種情況下我們可以執行泛型特殊化嗎？
即使由於我們分別對文件1.Swift和文件2.Swift
進行編譯編譯器可以看到兩個整數被傳遞給了
泛型函數min-T
但當編譯器編譯文件1時
文件2中函數的定義
對編譯器來說不可見
因此當編譯文件1時
編譯器不能查看泛型函數min-T的定義
因此我們必須調用泛型函數min-T
但是如果我們啓用了全模塊優化情況會是怎樣的呢？
如果我們啓用了全模塊優化
就會同時對文件1.Swift和文件2.Swift進行編譯
這意味着當同時編譯文件1或文件2時
文件1和文件2中的定義都是可見的
所以基本上這就意味着即使min-T泛型函數在文件2中
我們編譯文件1的時候可以看到它
因此我們能夠將min-T泛型函數具體化爲Min int
並用min int替換調用min-T的命令
這是能較爲明顯地體現出模塊優選的整體作用的第二個案例
這個案例中編譯器能進行類屬指明的唯一
原因是啓動整個模塊優化時
編譯器能得到附加信息
既然已經講過了泛型那我想再講講
動態調度技術以作總結
這裏我有一個寵物類的類層次結構
可以注意到寵物類具有方法噪聲 屬類型
以及一個方法噪聲處理法用以處理方法噪聲
還可以注意到寵物類的一個子類狗類可以覆蓋噪聲
現在再考慮產生噪聲的函數
這是一個很簡單的函數
它帶有一個參數p這是寵物類的一個特徵
即使這個大括號裏牽涉的信源不多
但後臺的運行卻比我們想象得要多
比如下面的Swift僞碼並不是編譯器發出的
名稱和噪聲不是直接被調用的
而是通過編譯器發出代碼
注意此處調用
名稱getter方法和方法噪聲的間接性
編譯器必須插入這一間接性
因爲它不知道在當前的類層次結構下
屬類名和方法噪聲是否應該被子類覆蓋
這一案例中的編譯器只會發出--
如果能夠證明沒有名稱或者噪聲的子類的覆蓋的話
只會發出直接調用命令
在噪聲的案例中這恰恰就是我們想要的
我們想要噪聲能夠被這個應用程序編程接口中的子類覆蓋
我們想形成這種效果就是在一個寵物類的案例中真的
有子類狗類的話如果我調用噪聲這隻狗會叫
而在一個真正的寵物類的案例中
如果我調用噪聲我們會聽到貓叫
這完全是合理的
但在名稱的案例中這實際上是不合需要的
這是因爲在這個應用程序編程接口中
名稱不是...永遠不是被覆蓋的
對名稱進行覆蓋是不必要的
我們可以通過約束這個應用程序編程接口的類層次結構來建立模型
我今天要向你們介紹
可以用來約束你們的API類層次結構的兩種Swift 語言特徵
其一是對繼承的約束
其二是通過存取控制約束存取
讓我們先談談繼承約束也就是最後一個關鍵詞
當某API包含的一項聲明上
有最後一個關鍵詞時
該API即傳遞着一個信息該聲明在任何時候都不會被子類覆寫
舉一個聲音製作的例子
默認情況下編譯程序一定會採用間接法
調用getter 以給出名稱
因爲如果沒有更多信息則無法知道
名稱是否被子類覆寫
但是我們知道在該API中名稱在任何時候都不會被覆寫
我們也知道在該API中
並不是要名稱能夠被覆寫
那麼我們就可以通過對名稱附上最後一個關鍵詞
對此進行執行和傳達
之後編譯程序會看名稱並意識到 哦
這個在任何時候都不會被子類覆寫
而動態分配即間接法可被刪除
既然我們已經講了繼承約束
我就要稍微介紹一下存取控制
該API中證明pet和dog均在單獨的文件中
即在pet.Swift和dog.Swift中但是屬於相同的模塊 即模塊A
除此之外還有一個叫做Cat的pet子類
它屬於另一個模塊但是在文件cat.Swift中
我要問的問題是
編譯程序能夠向noiseimpl發出直接調用指令嗎？
默認情況下不能
這是因爲在默認情況下編譯程序必須假定
該API是要noiseimpl
在Cat 和Dog這樣的子類中被覆寫
但是我們知道事實上並非如此
我們知道noiseimpl是pet.Swift私有實現詳細信息
在pet.swift以外不應可見
我們可以通過在noiseimpl上附上這個私有關鍵詞
從而實現該目的
一旦我們在noiseimpl上附上這個私有關鍵詞
noiseimpl在pet.Swift以外不再可見
這意味着編譯程序可立即知道
在cat或者dog中不會出現任何覆寫情況
因爲它們均不在pet.Swift中
並且在pet.Swift中只有一個執行noiseimpl的分類即Pet
此時編譯程序可向noiseimpl發出直接調用的指令
我們已經討論過private
下面來討論全模塊優化與訪問控制間的交互作用
Pet類我們已談論很多接下來我們將談論dog子類
謹記Dog類是Pet類的子類
它包含內部訪問但不含公共訪問
如果我們調用Dog類中的noise函數
沒有更多信息編譯器必須間接嵌入
因爲編譯器不知道模A不同文檔中是否存在Dog子類
當全模塊優化生效時
編譯器了獲得了模寬的可視度
可以看到模型中所有文檔
當然編譯器也能看到dog類沒有子類
因此編譯器可以直接調用
Dog類實例中的noise函數
需要特別關注的是你必須開啓全模型優化模式
卻不用改變任何代碼
通過給編譯器提供更多的信息
使編譯器理解類層次體系
更多的信息實現了免費優化
卻不增加我的工作量
現在讓我們回顧那達夫之前介紹的圖表
在面向對象基準測試中
爲什麼Swift比Objective-C快很多？
爲什麼Objective-C中
的編譯器不能通過Ob-C信息發送消除動態分配
不能通過它進行內聯 不能進行分析
編譯器必須假設
Ob-C另一側存在信息發送
但在Swift中 編譯器有更多信息
它可以看到另一側的確定信息
能夠消除大量實例中的動態分配
這類實例中
顯著快速的代碼
帶來更多運行結果
因此請使用final關鍵字
與API's intent進行通訊
這有助於編譯器理解你的類層次體系
並實現額外優化
但是應謹記根據變化情況
對現有客戶進行更新
並在已發佈版本中試用全模型優化
這一工具可以優化編譯器性能
比如讓它變得更加強勁和專業化
通過讓編譯器能更好得理解你的應用程序接口中的類繼承體系
你不需要做什麼
就可以體會到更及時的動態內存清空的好處
現在有請喬來做介紹
他將爲你們展示該如何使用這些技術和工具
來讓你們的應用程序
獲得更好的性能體驗
謝謝你 邁克爾
我叫喬是這個工具團隊裏的一名工程師
今天我將要給你們演示這一工具通過一個運行起來有些慢的程序
來 讓我們開始吧
好 現在我們的快速應用程序正在緩緩得啓動
我要做的就是接着繼續點擊運行按鈕
在其下拉列表中選擇Profile
這會使我們的應用在發佈模式下運行
然後再以模板選擇器的形式啓動工具
以便於我們可以好好的描述一下它
鑑於它還在緩緩運行讓我們從時間分析模板開始
在工具界面中只需點擊 錄製
當你的應用開始啓動本工具會自動在後臺開始錄製記錄它的動作
在這裏可以看到我們所運行的程序在我做任何目標操作之前
它正以60幀每秒的速率運行
一旦我把這些粒子加入屏幕中
它們四處擴散 彼此躲避
正如我想要的那樣這時我們的程序運行速度
變成了每秒38幀
我們失去了接近三分之一的效率
現在我們正視這一問題
退出原來的應用 回到本工具中
讓我們來放大一下以便看清發生了什麼
只需要拖動這個 向這邊拖動
就可以非常便捷得進入視圖快速跟蹤模式把你的數據加入水平時間軌
然後呢？
在跟蹤視圖中可以看到我們這個應用的CPU使用情況
在我做任何操作之前我們看左邊CPU使用率非常低
當我加入這些粒子CPU變得很高
你們可以看到通過移動你的鼠標
並停懸在這個ruler視圖以內這些取值是什麼
你們可以看到我們先是大約10%左右沒有做更多
隨後大約100%所以我們的CPU達到飽和
爲了提升我們的性能
我們需要將目前的工作量減少多少
那麼我們正在做哪些工作？
下面的該詳細信息面板由此進入
所以這是我們所有的線程
繼續將此再開啓一點
你們可能從調試程序中的Xcode內側看到起就熟悉這個調用棧
Start、calls main、calls NSapplication main等等
但是Instruments要告訴你們的是你在該功能內
包括其子功能內 要花費多少時間
即第一欄的Running Time
我們可以看到有11,220毫秒或者說我們99%的時間
花在了NSApplicationMain或者其調用的程序上
第二欄 即Self是從功能本身取instrument的時間
因此不包括其子功能
所以我要做的是看看self數在哪裏變大
即該功能實際在哪裏進行大量工作
你可以繼續逐一開啓 搜尋
但是需要花點時間
我們倒是建議你由此向右
這樣放大了詳細信息視圖
而Instruments將在你的應用程序中顯示最重的那一個堆棧蹤跡
在這裏所取次數最多
在此你可以再次看到我們的主線程用了11,229毫秒
從Start開始灰色符號爲系統框架
黑色符號如Main是你的代碼
我要做的只是向下看這個列表
看它是否有大一些的跳躍即大約此時有我們感興趣的事情發生
如果我向下掃過該列表數字慢慢變小
但是在我到這裏看到從大約9000到大約4000的跳躍之前
沒有出現大的跳躍
那麼那裏有事情發生我打算繼續進行點擊我的代碼
而Instruments已經自動擴展了左側調用樹
這樣你就能看到你剛剛點擊了什麼
讓我將此框起來
這裏在發生什麼？
好,讓我往回來一點
這是NSFiretimer調用驅動我的仿真速率是60幀/s
這是我的粒子Sim.app代理更新程序
驅動仿真的Swift程序
在它們之間是個古怪的類似objc的東西
這只是個thunk本質上,它是嵌入式函數的解釋器
可以使我的代碼在SWIFT
的NSFiretime中進入Objective-C
這就是它的作用 另外我們可以忽略它
現在我們看到更新程序佔有89%系統時間
所以我們需要繼續優化這個程序
其它東西我不關心
接下來我將會把它隱藏起來專注於這個更新程序
通過點擊右邊的這個箭頭
你看 這個周圍的東西都隱藏了
運行時間已重置爲100%
只是幫你做些心理數學
仔細看看這個函數做了哪些工作
更新Phase Avoid調用找到最近的鄰居
這裏進入到非常有意思的部分了
看Swift release佔用40%系統時間
Swift retain佔用35%系統時間
只是這兩個函數 我們就佔用了3/4的系統時間
僅僅是個管理引用計數的更新程序
差的遠
接下來幹啥？
恩 如果我雙擊尋找最近的鄰居程序
這調用了那些retains和release
Instruments將顯示源代碼
然而Swift是自動引用計數語言
所以你不會直接看到這些release和retain
但你能如果你翻到反編譯視圖
點擊按鈕
Instruments將會顯示編譯器實際產生的代碼
你可以在這找找這裏有很多的調用
這個release佔用了23%時間
這裏有更多的retain和release
這是另一個release
它們到處都是對於這我們該怎麼做？
讓我們回到代碼找到粒子文件
這是類粒子
所以它是一個默認的內部類
它符合協作協議
好的
下面是...這是尋找最近的鄰居程序之前它會佔用所有的時間
現在我知道當更新時間器啓動時
代碼會在屏幕上每一個粒子上去調用尋找最近的鄰居程序
那麼這個內部循環開始
遍歷屏幕上的每一個粒子
這裏我們有一個N2算法
循環的工作是產生非常巨量的時間值
我們所做的優化工作將有很大作用
看，發生了什麼？
在我們訪問這些粒子時
我們有循環了有一些retain和release的開銷
這是正在調用的屬性getter這個.ID屬性
前面邁克爾說過的
既然這是一個內部類
這裏應該有一些
跨越這些屬性getter的Swift文件
我們執行這些屬性getter
的動態調度這些屬性getter都有retain/release開銷
接下來是一個求距離平方的函數調用
事實上它有十幾個源代碼行
我們再一次去做動態調用程序
所有的開銷和retain release開銷都一樣
對這個代碼我們能做點什麼
恩 這是個完整代碼
這是我寫的 我完了
我的粒子類是完整的 不需要子類
我應該通過把這個類標記爲final
把我的意圖告訴編譯器
就是這麼一點改變讓我們繼續 再次配置應用 看看
現在編譯器能夠編譯這個文件了
也知道這個粒子文件
沒有其它的子類了 抱歉
這意味着它能夠進行其它的優化了
可以直接調用這些函數
甚至讓它們內部聯結或者其它的優化
這可以減少我們之前的開銷
打開記錄 這次加載這些粒子
看看這次它們以60幀/s的速度運行
讓我們回到優化前的每秒20幀
不錯
然而你可能會猜到
第二節是衝突當我們換一個算法
現在它們相互衝突了
幀速率下降了25%回到了45幀/s
我們再次面臨性能問題回到Instruments
看看 發生了什麼
我們將把之前做的再做一遍把這個放大一點
點擊Snap Track to Fit現在怎麼樣？
看左邊 這是迴避階段
變好了 提升了大約30%到40%
這是我們每秒60幀的原因
看右邊這是衝突階段
現在這會佔有100%的CPU性能
幀速率又下來了
再做一次剛纔做的事調用數據樹
仔細看看這個窗口中有
迴避階段的數據運行良好
也有衝突數據這是需要我真正去關註解決的
迴避階段的樣本會平滑我們的結果
所以我將設置一個時間過濾器讓我能只看衝突階段
很簡單
只需要在時間線中點擊和拖拽就行
現在我們的細節窗格更新了
只顯示我們的衝突階段了
現在我們再做一次
從頭回到我們的擴展細節視圖
向下看這個列表看有跳躍的地方
有趣的事情發生了從8000毫秒
到2000毫秒
所以我去點這裏的衝突檢測類
Instruments再次自動展開了調用樹
讓我們看看這裏發生了什麼
88%的時間花在了這裏的運行時間步進程序很好的挖掘點
再來一次 點右邊這個關注箭頭
現在我們只看運行時間步進程序
看看它在做什麼
好 25%的時間用在了
Swift.array.underscore返回元素節點這個項目上
當你看這個三角括號裏的A時
意味之你正在調用函數的通用格式和所有需要的開銷
你會再次在Swift數組的三角括號裏的A這個位置看到
這是個有效的子腳本
當你把三角括號換成方括號也是一樣的
所以我們正在調用的是通用屬性getter
在這三個通用函數之間
我們看到大約50%的時間用在了這三個通用函數
我們怎麼做才能消除這些開銷呢
好 回到Xcode
這是我的衝突檢測文件
這是衝突協議我的粒子會服從這些協議
這是通用類 類檢測
T類型會符合一個衝突協議
它做的是它的衝突數組這是通用的T類型
下面的是我們的運行時間步進程序
這是我們開銷的地方
這個函數做了什麼
恩 它遍歷了我們所有的衝突從一個數組訪問了一個衝突
調用了大量的屬性getter
這裏更多
這是個內部循環調用像前面我們做的一樣
我們把另一個衝突從數組中拉出來
然後是所有的屬性getter
我們做了很多的通用操作我們應該把這些都幹掉我們怎麼做呢？
這次你可以看我的衝突檢測類就在Swift文件裏
然而這個用戶在用這個類的App代理
程序中這個Swift文件的粒子它在這個模型的另一部分
我們要轉到 Whole Module Optimization
很簡單點工程
在build設置參數中
確定是所有的在build設置參數找到優化
這是優化參數那達夫之前演示過的
你只要把你的release生成參數切換到全模型優化
現在當我們配置的時候
編譯器正在查看所有的文件創建一個更優的二進制文件
但是讓我們看看會發生什麼
我們將第三次運行時間分析器
開始記錄 60幀/s
添加粒子衝突的階段仍在運行以60幀/s的速率
好 我希望這沒什麼變化一直很好
然後我們轉到衝突階段
現在它仍運行在60幀/s
所有的配置只需幾分鐘
和一些小的調整
我們讓程序變得快多了
好的 歸納一下我們今天看到的
我們知道Swift是一種靈活的編程語言
使用安全的自動引用計數完成內存管理
這些強大的功能讓人
愉悅的編寫代碼雖然這帶來一些額外i的開銷
我們想做的是讓你專注於你的APIs和代碼
當你在編寫它們時保持高效思維
你怎麼確定額外開銷呢
在Instruments分析你的應用程序
在開發代碼的全生命週期裏
當你發現問題時都需要這樣做
你會更快更準更容易的定位問題的原因
尤其是你的APIs發生變化時
有些在線文檔當然你可以去Developer Forums
得到Swift問題的答案和解決方案
說到解決方案今天3:30在Mission有一個深度案例分析
專門討論時間分析器比我們今天講的更深入
像之前邁克爾提到過的使用Swift的數值類型可以建立更好的應用
如你今天所看到的謝謝你們