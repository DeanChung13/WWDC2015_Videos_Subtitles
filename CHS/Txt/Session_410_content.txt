Xcode中的持续集成和代码覆盖
早上好
欢迎参加“Xcode中的持续集成和代码覆盖”
我的名字是马特·莫里亚蒂我是Xcode团队的一名工程师
今天 能在这里给大家讲讲我们在Xcode中推出的一些工具
我感到激动万分这些工具可以帮助你们
从测试中受益更多我们也希望它们可以激励你写更多的测试
今天 我们先来讲讲
Xcode Server
Xcode Server是我们捆绑到Xcode上的一项
持续集成产品
然后我们再来讲讲XcodeServer
和Xcode 7中有什么新料
并且重点关注下我们今年引入的新的代码覆盖特性
会议的下半程我们会来讲一些
Xcode Server更多的高级特性
这些特性可以允许你把它集成到
你的团队的独特的工作流程上
当然了 在会议整个过程中
我们都会通过演示向你们展示这些东西是如何实现的
让我们开始吧
Xcode Server是我们通过Xcode 5
引入Xcode的一项特性
它是关于对一个叫做“持续集成”的进程提供支持的
持续集成的目的 是为了提高你们团队的协作效率
让你们得以打造更好的软件
那么这意味着什么？
这意味着定期把你的全部代码取下来
然后进行构建、测试让构建错误、测试失败等问题
尽快浮出水面
这样你就可以立即修复它们
你们实现持续集成的方式有很多
但是我们认为Xcode Server更加适合像你们一样的
app开发者原因有两个
第一个原因设置它很容易
因为与OS X Server进行了集成
如果你已经在你的Mac上安装了OS X Server和Xcode
那么你离让一个持续集成服务器定期测试你的项目
就很近了
第二个原因XcodeServer和Xcode有深度集成
我们深谙如何构建Xcode项目
深谙如何兼容设备等等此类的事情
这样我们就可以尽量少地问你们问题
就可以设置完毕定期检查你的代码
在我们展开讲之前我想先讲几个我们在谈起
Xcode Server时要提到的概念
第一个概念你可能已经熟悉了
哪怕你之前从没有用过Xcode Server
这个概念就是Scheme
每次你在Xcode中运行你的项目或者测试时
你运行的就是一个Scheme
一般来说会自动为你创建Scheme
不过你也可以创建你自己的定制Scheme
它们基本上就构成了构建你的项目的“食谱”
告诉你构建的目标是什么运行的测试包是什么
传递给你执行的自变量是什么 诸如此类的事情
当需要设置Bot时对Xcode Server来说
Scheme就非常重要了
Bot是我们倾向于把它当成你的团队的一员
它其实就是采取某种特定的方案构建好
然后根据你定义的日程表运行
并完全遵照你的说明执行某些操作
然后把结果汇报给你
每当我们按照日程表运行你的项目时
我们就称之为集成
它就好比是把你的团队每个成员所做的变更集成到一起
然后看看结果如何
既然我们都已经达成共识了
那么就让我们来谈谈Xcode 7
和Xcode Server中有什么新料
如果在Xcode 6之前你就用过Xcode Server的话
你就知道每次你对一个Bot进行编辑时
我们会让你重新走一遍生成Bot的整个工作流程
不过提前填写好了很多值
如果你只是想做一些简单的变更比如添加一个触发器
修改你的方案诸如此类的事情
那么这就有点单调乏味了
现在我们有了这个选项卡式的界面 
你就可以进去完成你想要的更改然后退出
看来大家都是选项卡式工作流程的粉丝
我们还对Xcode 7中的源代码管理做了多项改进
而我们之前则是会试图自动处理
你的源代码管理并且向你隐藏了细节不过我们现在让你看到了
更多 这样你就可以清晰地看到你的Bot将要校验的储存库是哪个
并且你还可以选择不要校验某些储存库
对于你要校验的储存库来说现在你可以看到并且选择
你要校验的分支是哪个而不是...
谢谢
而不是寄希望于Xcode希望它自行正确搞明白
我们还改进了源代码管理的安全性
具体来说指的就是SSH指纹对比
以及自签名证书
这两项都不会自动成为安全的输送方式
它们要求你信任你连接的服务器
这样如果服务器之后发生了变更
你就知道它们有了新的指纹它们可能在冒充你以为你正在连接的服务器
之前Xcode会自动信任这些服务器
而不做任何验证
现在我们要求你明确信任这些中的哪些服务器
然后我们会把指纹储存起来这样如果之后它发生了变更
我们就不会从错误的服务器上进行校验
我们同样也更新了你在你的集成中看到的多个报告
所以说测试报告也整理过了更紧凑了
现在在你的测试中看出断言故障就更加容易了
日志视图的性能提升也得到了大幅提升
之前我们试图向你展示你的全部日志的堆叠视图
但是当你视图展开某项日志时
这就出现了明显的性能代偿
现在我们一次只向你展示一条日志 
你可以通过左上角的弹出按钮来选择日志
现在查看大的日志文件也非常快了
提到持续集成让Xcode Server脱颖而出的一件事情
是它知道Xcode项目会产生
什么类型的问题它还知道
构建错误是什么样的知道测试失败是什么样的
它不会仅仅向你显示一些原始的纯文本日志文件
让你自己仔细查看然后找出发生了什么问题
说到此类问题我们做了很多巧妙的事情
就是为了让这些问题浮出水面 对你有所裨益
当你运行集成时...
Xcode 6中同样也是如此...
我们会向你展示这个漂亮的报告告诉你在你的构建中出了什么问题
因为我们会把这次集成和之前的集成进行对比
我们就能让新问题浮现出来这样我们就可以精确定位出
是哪次集成出了问题是哪次提交把某个特定的问题带进来了
这样的话找到原因查出问题所在修复问题就非常容易了
围绕“问题” 我们在Xcode 7中还添加了一些新东西
假如说你现在看到发生了一个问题
你要么可以看到是不是你的错 这样你好修复
它要么你可以看到问题的原因
比如我就知道那里错了我就可以
进去快速修复它把这个搞定
然后你可以认领问题这样你的名字就放上去了
这样当你的团队中的每个人查看报告时
他们就可以看到这个这样他们就知道自己不用
操心这个事了因为你已经在处理了
如果问题是间歇性的或者是你知道
已经修复了的问题你就可以
把它们“消音”一段时间
它们就会从报告中消失
这样的话你可以集中精神关注那些
确实需要你关注的事而不用和你知道
已经解决了的事情搅和到一起
不过关于Xcode Server最棒的一点是我们能在多大程度上
和Xcode引入的其它各项特性进行交互
因为我们在Xcode 7上有一些很棒的新特性
我们也专门拿出时间把这些特性集成到了
Xcode Server
我想看看其中的几项特性
用户界面测试是Xcode 7上的新特性
我们专门对此进行了处理
确保了它能完美兼容Xcode Server
当你运行Mac测试或者iOS模拟器测试时
我们会在你的服务器后台
创建一个全屏会话
你的全部测试都是在那里
运行的这就意味着你无需担心启动
你的应用程序时 是否处于适用于Xcode 2的正确环境中
我们会替你搞定它
如果你用的是真实的iOS设备
那么你就可以看到UI测试在设备上
逐句通过应用程序
用户界面测试是以一个高水平的标准
对你的应用程序进行测试的绝佳方式
测试的方式和你的用户看到的一致
并且会对所有的不同层在一起的相互交互进行测试
如果你同时还有一个服务器在各种设备上运行这些测试那就更棒了
对于一项方案来说
“点播资源”是iOS 9上的一项新特性
通过避免在你的包中存储太多的资源
它就可以让你的apps包更小
如果你的app已经上架了App Store
App Store就会替你充当主机
这样 当需要的时候你的应用程序就可以下载
这些资源而当你不用的时候就可以从磁盘上删除
那么当你在发布之前需要做内部产品质量测试
需要测试你的应用程序的构建
并且你的app已经上架App Store了
对于资源来说那时候会发生什么？
那时候 App Store就不会再为这些资源充当主机了
你做的变更太快App Store没法再充当主机了
但是如果你是从Xcode Server上
获取的内部产品质量构建
并且你是让你的集成为你生成了你安装到
你的设备上的IPAS那么这就会自动为你进行处理
你不需要勾选选项框你什么也不用做Xcode Server
会自行知道在你的应用程序内有了点播资源
它就会在自己的服务器上为这些资源充当主机
如何找到这些资源
最后 我还想再讲讲Xcode 7上的另外一项
新的特性这项特性和Xcode Server
以及持续集成都配合的天衣无缝
这就是“代码覆盖”
“代码覆盖”就是一种对你的 测试的值进行度量的工具具体来说
当我们运行测试时我们想知道实际运行的
代码是什么
因为你很容易就会出现你的应用程序上有一大堆
测试套件你很难进行变更
你不注意的话就不会出现回归这种情况
但是你怎么知道你到底需要多少项测试才算足够？
假如说我有一个应用程序并且有二百项单元测试
但是这些测试却仅仅覆盖了我的应用程序的20%？
要是这样的话它们可不像我想的那样有用
因此代码覆盖为的就是把这些信息呈现给你
这样你就可以做出明智的决策
它可以让你运行你的测试并且正确度量运行的代码
是哪个更重要的是度量出完全未经测试的代码是哪个
这个代码就是当你继续添加新的特性时
可能出现回归的代码而你之前是不会从你的测试中知道的
因此我们认为对于那些真的在意测试的团队来说
代码覆盖真的很重要
这也是我们把代码覆盖集成到Xcode的原因
像其它很棒的Xcode特性一样
代码覆盖在构建时就和LLVM有着紧密集成
因此当你在你的方案中收集启用的代码覆盖时
编译器就会对你的代码进行指导
我们就可以计算每个表达的执行频率
然后我们就会在IDE中把这个信息呈现给你
我们现在有两种方式可以实现这一点
第一种是当你进到你的测试的报告导航器中
你之前在Xcode 6中就可以这么做 不过现在在
Xcode 7中有了一个贴有“覆盖”标签的新标签
如果你查看这个报告你就可以根据目标 文件
以及方式进行查看这样就可以知道你的应用程序
的各个不同部分的覆盖情况
这样你就可以从一个较高的层面来查看你的应用程序
然后向下挖掘下 看看值得你注意的部分是哪个
如果我发现某种方法的覆盖率是75%
这也算是个好消息
但是我并没有获得怎样才能进行修复的信息
我不知道我的代码的哪些分支测试到了哪些分支没有测试到
当你悬停在这些方法或者文件上时
我就可以点击弹出的箭头这些就会显示出源代码编辑器
我们就可以在那里通过内联注释 高亮显示你的
应用程序中未被覆盖的部分
对于那些已被覆盖的部分来说 我们则会告诉你
它们在测试中被执行的次数
代码覆盖在Xcode IDE中本身就已经很棒了
不过我想当你把它放到XcodeServer上时 它会更棒
你在那里有一个Bot在各种设备上
运行你的项目
集成和Bot的一个特别之处在于
你可以设置它们在一系列的设备上运行
而不是一次仅能运行在一台设备上
就像你在Xcode中所做的那样
当你这么做的时候我们会集中向你展示你全部
设备的覆盖数据并且我们以橙色高亮显示
在你的设备上有着不同的覆盖的方法 目标 或者文件
这样你就可以看看这些不一样的地方
看看它是否属于bug还是属于某种预期行为
你在不同的设备上有不同的代码覆盖
这相当普遍尤其是在用户界面代码中
你在不同的设备上可能有不同的代码
比如一台iPad和一部iPhone就不同
Xcode Server还可以为你提供的一件事情
是一份存储追踪你的项目的存在期的档案
这样当你查看某个集成的代码覆盖时
我们就可以高亮显示变更发生的时间 
这些变更在代码覆盖中的方法以及文件
这样你就可以精确定位到某次具体的提交集合
档案还使得我们可以显示趋势 之前在Xcode 6中
我们有构建历史图表以及你的Bot的测试历史图表
这样当你添加更多的测试的时候你就可以看到图表发生变动
你就可以看到事情进展如何
你的Bot的稳定性如何
不过现在我们又有了一项新的代码覆盖图
可以表明随着时间的变化你的项目的整体覆盖趋势
这样的话 你就可以知道举例来说是否有所提升
这样你就可以知道当你添加特性时
你是否需要给这些特性添加测试
或者你是否需要给之前没有覆盖到的特性添加测试
或者也可能出现向下的趋势这是因为你进展太快了
没有对你刚加的特性进行测试
这样 就可以帮助你做出明智的决策
决定下一步该怎么办决定如何分配你的开发时间
当然了 如果你在你的工作区使用大屏幕来显示你的
Bot的整体状况那么在你的项目的测试数量
下面我们还会向你显示你的整体覆盖百分比这样你就可以密切注视它
好的
现在我想请我的同事埃里克上来
请他给大家演示一些Xcode以及Xcode Server上的
代码覆盖特性
谢谢 马特
我要向你们演示一个我们开发的供内部使用的
应用程序我们用它来跟踪大家互相
欠下的请喝咖啡的次数
去年你可能已经看过这个应用程序了
自那之后我们又做了一些改进
它的基本规则是如果有人替你修复了一个bug
或者你欠了别人一个人情那么你就需要请对方喝咖啡
我们专门有一个应用程序对此进行跟踪
和其它优秀的应用程序一样我们也有单元测试
来确保当我们添加新的特性时
不会影响到已有的工作代码
对这些进行测试只算成功的一半
当对应用程序进行实际的全面测试时
我不知道我能坦然面对的单元测试有多少个
我想看看覆盖情况看看情况如何
不过也许我们没有那么多的测试
让我们来看看
实际上 在我来这儿之前我已经运行过了测试
我们可以直接在设备上看看测试结果
我们只有七项测试
这可很不妙
不过这是一个小的应用程序
也许这已经足以覆盖所有的事情了
最起码这些测试都通过了所以开局不错
我们来看看覆盖情况
如果我们来看看这里的覆盖报告
我们就可以看到这个应用程序被分解成了两个目标
我们有一个UI层面的应用程序即coffeeboard.app
测试覆盖情况不太好
不过没关系 这是一个UI应用程序我应该给它写一些UI测试
我更关心这个基础水平的框架
我们可以在这里看到只有50%测试覆盖
这可不太妙因为如果我们努力的话就可以实现100%覆盖
看起来真正落后的类是这个事务类
如果我们看看这个事务类
我们就可以看到这里有一堆的类
在我们的各项单元测试中并没有被调用到
我们创建了一些事务我们可以看到它们在
初始化程序中被调用了
但是我们并没有实际用它们来做什么事
我再来解释下我们的app
它有一项很棒的特性
使用了我们的一个专属算法
如果我欠马特两杯咖啡而他又欠我一杯咖啡
那么我们就会把这两个数字合并就成了我欠马特一杯咖啡
因为算法是秘密的我就想确保
这个算法经过了仔细测试因为数学
不是我的强项我就更得确保不出问题
我们来看看它的源文件
就像马特说过的那样我要使用那个悬停后
显示出来的箭头直接进到我的源码编辑器
这里我们可以看到一大堆深色的高亮显示区域
在我的源码编辑器中使用了默认的背景色的
代码在这里背景色是白色
就是已经在测试中覆盖了的代码所以我并不太需要担心它们
我更关心的是那些以灰色背景显示的代码
我可以确认它们未被覆盖到因为在右边这里
我们可以看到一堆“零”
表明这个代码从未通过我的任何单元测试
这可不好
现在让我们在这个单元测试中导航下 然后再来看看这个
如果我到事务测试那里
我就可以发现我并没有任何测试
这就出问题了
让我们现在把它修复
我要在这里创建一个小的空白区
写一些Swift代码
当然了 我假设你们都有神奇的宏命令
可以为你们添加各种单元测试
我们就是这样开发程序的不是吗？
我要在设备上运行下测试
这需要一点时间
就像马特说过的那样当你的代码运行时
我们会用LLVM对你的代码进行指导 这样我们就可以
看到到底运行的是哪个表达式
趁着它在我的设备上运行我要去看看方案
要记住既然它是LLVM的一项特性
那么它在Xcode上也是可选项
打开它的方式是进到方案编辑器
然后选择测试操作
然后确保“收集数据覆盖”那个勾选框已经勾选了
这样就可以确保我得到覆盖数据
时间正好我的所有测试都成功了
太好了 只要我用神奇的宏命令来构建 就总会成功
如果我现在看看测试报告 我可以看到
我有更多的单元测试
但这并不是故事的全部
我们再看一次覆盖报告
这里 我们能看到一张更漂亮的图片
如果我在上面放大下我们就可以看到我现在覆盖了76%
虽然不是100%覆盖但是已经比我们之前的情况好得多了
我要把事务类再次显露出来
这里我们可以看到更多的这些类现在得到了覆盖
我现在测试的是合并代码之前我一直很担心这些代码
害我损失了好多睡眠时间
这里有件有趣的事如果我们返回源编辑器
然后看看等效方法
如果你之前注意的话当时它只是被部分覆盖了
我们在这里就可以看到原因所在
我们看看这个等效方法
我们并没有把我们的事务类同某个不是事务类的类进行对比
因此这个返回的假值永远不会在任何我们的单元测试中被调用到
当你查看不同的分支时能够看到这个覆盖情况
用处会很大尤其是当你的代码中有很多
分支逻辑你知道会出现边界情况
这样的话你就可以确保当你写你的单元测试时每种边界情况都能覆盖到
我们还可以看到这个代码被覆盖了多次
因此你是否知道你的代码中有这种多个实例到底同一路径
但是最终却并不相同的情况就非常重要
你需要全部覆盖它们
刚才我做的事情都非常单独枯燥
因此我希望有人能替我整天跑这些测试
我就不需要担心这个不需要对它们进行对比
但是有人告诉我预算表中没有雇佣一名
实习生来做这件事的钱
我们来看看Xcode Server
我已经为此设置了一个Bot 跑在一个已经
有了这个提交的不同分支我们来看看这个Bot
就像刚才马特在幻灯片中演示的那样
当Bot运行了二十四小时后
当它运行了一段时间后我们就可以从更高层面
对我的项目进行一次总览
顶部这里 我们为你显示了高阶统计数字
你可以看到任何时间任一周、时、月、年
或者自从你的Bot运行以来的统计数字
然后我们可以看到构建历史
在这里 我们会为你显示随着时间变化的错误报警以及问题分析
在这个实例中我之前有一些报警
不过我已经修复了它们
所以现在我们显示没有问题
对于持续集成来说接下来的两个图表
可能是最重要的前提是假设你的项目构建的很干净
没有报警或者错误
那就是你的测试
在这个例子中我们可以看到我之前有几个测试失败
不过我还是在持续添加测试
这很棒 不过我们真正想看到的是 顺利通过的测试数量
持续增长并且这些测试也让代码覆盖持续增长
如果你的测试增加了但是覆盖情况却没有增加
那么你实际增加的价值就没有你想象的大
如果我看下上次集成的覆盖情况
这是我刚刚进行的提交你们没有看到
但是我保证我确实提交了
我们就可以直接进到覆盖报告
当我本地跑我的测试时这个看起来
就和我们在Xcode中看到的很像
和Xcode中的类似我们也是按照目标
按照不同的类进行了划分
我可以展开那个事务类
看到相同的方法覆盖层次也一模一样
不过有两个不同之处
在这个例子中我就可以在报告中看到
随着时间推移发生的变化
这样我就不用再查看两份报告
看看覆盖是否有所增加了
尤其是在改动不大的情况下
我们就可以让它显示在这里了
现在 在CB foundation.framework
我的覆盖率比之前提高了22%
尤其是事务类的覆盖率也增加了48%
下面这里我们用橙色高亮显示了一件
有趣的事即设备的差异之处
实际上在Xcode Server报告内
我可以点击这个复选框让设备的差异之处立即
显示出来
在这个例子中看起来这个详细视图控制器
并没有在我的iPhone上显示出来
这实际上并不意外
在这个例子中 我们的应用程序用的是分割视图
除非有人点一下否则第二个视图控制器
并不会在iPhone上显示出来
我们的单元测试并没有执行那个代码
这并没有什么特别不寻常不过你要确保
如果出现此类事情
那么它们不会出乎你的意料
这也就是我们为什么让你们可以在Xcode Server中
很容易看到不同种类的设备的差异之处的原因所在
这样就可以很容易找出本来应该被覆盖的代码
实际上没有覆盖到
这个就是显示了代码覆盖的持续集成
那么我要再请马特来给大家谈一些
Xcode Server更多的高级特性
谢谢 埃里克
就像埃里克刚刚说过的我要来给大家谈一些
Xcode Server更多的高级特性
我知道你们很多开发者都对扩展Xcode Server
把它和你们团队的工作流程的一部分集成起来很感兴趣
我们知道你们并不能仅仅靠Xcode Server
这个工具就能搞定一切因此我们想给你们提供
让Xcode Server和你们手上的所有
工具兼容完全拟合你们团队的方式
我们有两种方式今天我要就如何把Xcode Server
集成到你使用的所有工具上谈一谈
首先是触发器
触发器是在Xcode 6中引入的引入触发器的目的
是为了在你的Bot以及你的集成的生命周期内
把定制操作集成到上面
触发器可以是邮件通知提供关于你的集成
集成运行情况出现了什么问题
提交者是谁等等此类事情的细节
以及配置信息或者你也可以选择某种程序语言
把触发器写成任意脚本
我们默认使用Bash来跑这些脚本
因此你可以向你的触发器中输入任何老的shell命令
照样可以生效
但是如果你照着写命令行工具那样
在你的脚本顶部包含了一个hash bang
我们就会用它你也可以使用任何你喜欢的解释器
如果你愿意的话 你甚至还可以用Swift来写你的触发器
埃里克稍后会给你们演示下
触发器可以在你的集成运行之前或者之后运行
每一段代码都能让你的Bot
做一些很酷的事
在你的源代码之后集成运行之前
运行的触发器会进行检验
这点很重要因为这就意味着你可以访问
你的项目 并且在构建之前进行任何你想要的自动变更
集成之后运行的触发器可以根据集成的结果进行控制
这样触发器就可以仅在集成成功时或者仅在测试失败时运行
它们也可以访问很多关于你的集成中发生了
什么事情的信息
我们提供访问这些信息的一种方式是通过
环境变量来访问
这个仅仅是当你的脚本运行时定义的某些变量的样本
任何值得你用的脚本语言都能让你很容易地理解
这些环境变量让你可以把它们用起来
我们举个例子看看你能用它们做什么
去年我们演示了一个触发器每当完成一项集成的时候
触发器就会在一个逾限聊天室内贴出一条消息
我们是使用了Bot的名称集成的数量
以及结果来实现的
把它设置起来很容易很快
这里我想请你们注意两件事
因为它们看起来比较怪看起来不协调
对于运行的集成以及相应的Bot来说
我们有一个BotID和一个集成ID
如果我们只给你这些那就有点怪了
你用一个ID做不了什么事
这个ID是一个任意的字符串
那这个字符串有什么好处？没有用户想看这个字符串
这个字符串本身做不了什么事 但是当这个字符串
和Xcode Server API结合起来后事情就非常有趣了
Xcode ServerAPI构成了
Xcode ID和Xcode Server
通信的基础
你也可以控制这个API为你自己所用
用它来做一些很有趣的事
和大多数网络服务APIs一样这个API构造时遵循的也是
开源的 相沿成习的标准
我们在服务器和客户端之间使用HTTPS来进行来回的安全通信
通过那个加密渠道我们使用基本认证来进行认证
我们的API遵循的是一个REST
模式像Bot和集成一样与资源进行交互
使用标准的HTTP谓词比如获取、发布、打补丁、
删除等等 在这些资源上执行操作
当然了 我们还使用了JSON来对数据进行来回通信
JSON用起来很简单解析起来也很简单
它是网络服务的通用语
大家都在用它
对你来说XcodeServer这个雄心勃勃的扩展器
是个好消息因为这意味着无论你偏好什么样的编程语言 什么样的环境
你肯定都能找到表达HTTPS以及JSON的方法
也就意味着你能够让几乎所有的东西同Xcode Server进行交谈
我们来看看我们都能怎样使用这个API
我们能问我们的服务器的最简单的问题是什么？
我们从这个问题开始我的服务器上有什么Bot？
这个很简单
我们向Bot资源发一个get请求
如果你看看那里的URI你就可以看到我们是通过端口
20,343进行通信的 我们所有的API请求都有一个API前缀
这个并不重要但是当你们在你们自己的服务器上
尝试这个API的时候我希望你们记住这一点
当我们发送完那个请求后我们就得到了一个JSON对象
告诉我们得到的结果的数量
给我们提供一个与结果自身相关的阵列
每个JSON对象都代表一个在我们的服务器上设置 配置的Bot
和大多数Bot一样Bot也有一个ID它们也有一个名字
和你在创建它们时在Xcode中给的一样
它们也有各个配置参数和你在设置Bot时
设置的配置参数一样
好的 那么我们还能做什么？既然有了一个Bot
我们来看看这个Bot运行了什么样的集成
现在我们可以访问那个Bot的集成子资源了
这样做我们就可以得到一个和我们之前
看到的非常相似的结果除了现在的结果...
代表集成而不是代表Bot
但是集成也同样属于资源它们也有自己的ID
一件有趣的事是我们也保存了
集成上的Bot的快照这很重要
因为随着时间推移你的项目会发生变更
你可能采用新的Xcode特性 类似这样的事
当你编辑的时候 机器人程序的配置也可能发生变更
因此我们存储了一张集成的快照
这样当集成运行时你就可以知道到底你的
Bot是怎样配置的
我们同样会跟踪你的集成的构造过程的步骤
完成后你可以在那里看到一个结果
你还可以看到你的集成发生的各种不同的问题的分类
之前的集成的变更的分类
这些都是之前我向你们展示的get请求
非常适合收集信息
不过如果你在用API的话你可能想用它做些事情
那么我们到底可以做什么事 来对我们的服务器产生影响呢？
我们可以手动触发一个集成
也许我们有某种不属于Xcode Server内置调度
程序的自动化流程我们就希望使用这个流程
来为某些Bot触发集成
这个实现起来也很容易我们可以使用相同的URL
把我们的HTTP方法改成一个post
这样的话我们就从“我想列出这个Bot的集成”变成了
“我想为这个bot创建一个新的集成 ”
如果我们发出这个请求
我们就可以得到一个代表一项集成的对象
和你们之前看到的很相似不过这个对象轻了很多
在构造过程中集成上面设置了许多项属性
不过这个集成会仅仅处于挂起状态
直到构造程序在队列中捡起它开始实际运行它
在我们的API中大部分的post终点都要求你
在主体中放置一些JSON
然后说明这是这个资源的属性
这是我正在创建的事物的属性
在这里集成属于某种特例
因为Bot在本质上已经成了那个样子
它们已经成了每个新的集成的模板
因此它们知道创建一个新的集成它们需要知道的一切
或者说 它们最起码知道一般情况下需要知道的一切
你也可以对你的集成有某种影响
举例来说如果你想要一个运行时非常
干净、没有残余物构造块效应
的集成那么你就可以通过向主体中
传递某些JSON 告诉主体这个集成在运行之前应该先进行
清理这种方式来实现
这里有一个例子是你能用我们的API做什么事情的例子
现在我想把埃里克请回来请他给你们做一个
Xcode某些高级特性的演示
再次感谢 马特
就像马特所说的我们要通过这个项目
向你们演示一些Xcode Server的高级特性
和你们中的许多人一样
我们这个app也是内部开发的
不过我们也想把它分发出去我想要非常容易地就能区分我的内部构建
以及我的外部构建
对此 最常见的一个策略是如果我们看看我们的“资产目录”
我们就可以看到两张不同的图片
在第一个例子中我们可以看到标准app图标
就是这个白色的咖啡杯
对于我们的内部构建来说
我们想要始终显示一个黑色的咖啡杯图标
把它作为一个内部标记
这样的话 当我们在我们的设备上运行内部构建时
我们就知道它们是内部构建
而不是我们可能上架App Store或者通过我们的正常通道
分发出去的外部构建
这就非常有用当我们发现一个bug时
我们就知道就希望只有我们能看到这个bug
还有一种方式我们可以用来区分我们的内部app
就是当我们运行内部构建时
我们通常都有一个设置包
在那个设置包中像很多应用程序一样
我们会定义一个版本在这里就是版本2.0
因为我们刚刚做了一些很大的变更
2.0对于我们内部用户来说已经足够完美了
不过向App Store提交时我们不会提交这个版本
不过对于内部使用来说我们可能还想要一些更多的细粒度信息
再进一步具体来说 我们想让构建有某种唯一标识符
在这个例子中我想用Xcode Server来区分
构建是来自在我的服务器上的哪个集成
我到Bot那里看看
这个Bot和我之前用的一样
我要编辑下这个工作流程
正如马特说的那样现在这是完全非线性的
因为我对触发器最感兴趣我就直接到那里了
让我们开始第一...
开始我们的第一步 变更图标
我要打开一个我已经写好的触发器脚本
在这个例子中这是一个简单的批处理脚本
因为我们要做的都是简单的文件操作
我们要使用XES源目录环境变量
来找出那个app图标的路径
然后我们要把它删掉
然后我们要把我们的服务器版本取出来
把它移动到这个位置
那么这就会成为一个集成前触发器
因为我们想让它在我们的源代码检查完毕
准备构建但是并没有真的进行构建时运行
我要把它当成一个运行脚本触发器来复制
现在对设置包进行设置就会有点棘手了
我可以使用一个批处理脚本来设置 但是那就需要手动
编辑大量的批处理脚本或者在一个批处理脚本中
放大量的plist代码会很痛苦
那么我要启用一个Swift触发器
在这个例子中和bash触发器类似
我要给用户宾·斯威夫特设置为使用hash bang
我还没有写完所以请等我一下
我要获取导入基础 我在那里就可以
获得我想从Swift获得的其它额外的权限
导入基础后我要使用NSProcess信息
来获得我在bash中其它脚本上使用的
那些环境变量
在这个例子中就是XCS源目录
然后我要找到我所有的设置包
这里 有了Swift事情就更有趣了
我可以在Swift中把plist当成一本字典载入
我并不需要亲自手动对plist文件进行任何编辑
当我想往上面添加什么东西时 这就非常有用
我只需要在swift中创建一个新的字典常量
然后把它塞进我的字典中
这里我们把集成编号的环境变量设置成这个构建编号标题
最后在完成脚本之前
我要把它写出到磁盘
这样 当我们实际构建时它就可以在我的设置包中被拾取到
为此 我只需要在下面添加另一个触发器
好的
现在我有了两个触发器
现在 我就可以在这里推送“现在开始集成”按钮
得到一个新的集成但是我想在服务器上
用一些马特提到的API来实现这个
我要再启用一个我拥有的应用程序
如果我们看这里我们就能看到一个应用程序
它已经连接到了插入我的电脑的一个串行设备上
它使用了示例代码的某些输入/输出套件
那么我们就要来读取那个缓冲器
无论我们什么时候在那个缓冲器上看到有内容我们就要运行这一代码块
我要打开一个NSURL会话我要调用能够获得所有的Bot的API
这只不过是本地主机
马特之前提到过的端口API/Bot
就会成为get方法
我要调用它使用NS JSON序列化API然后在各个Bot中
进行读取 找出咖啡板Bot的ID
我想集成的就是那个Bot
有了那个ID 我就可以像马特之前展示的那样
使用Bot/我的
通用唯一标识符/集成创建一个新的URL
把那个请求切换成一个post请求
这样就会创建一个新集成
为此我们并不真的在意集成要做什么事
要触发这个
我设法绕过安全机制取得了这个有趣的小按钮
我要把它插入我的Mac
然后我要运行这个应用程序
我们要再试试
在我运行之前确保它完全连接好了
不想操之过急 好的
很好 现在应用程序开始运行了拾取了调制解调器
我要在我的Bot这里放大下
然后等一会儿就是用这个按钮
创建一个新的集成
就是完全用我们的API中的这个按钮
我不想等待集成完毕我要直接向你们展示
发生了什么 在这里我们可以看到集成
我可以把它安装到我之前使用的本地设备上进行测试
安装 如果我打开QuickTime
你们就可以看到我看到的东西...好的
这是我的设备
你可以看到我们在设备上有了内部图标
尽管我从来没有把它切换成本地
我们是从服务器上下载的现在我们的app
我们知道 是一个内部构建
这些就是Xcode Server上面的一些更多的高级特性
我要请马特再讲讲你们可以在实验室的什么位置找到我们
诸如此类的事情
马特？
好的 谢谢 埃里克
太棒了
我最喜欢按下大大的红色按钮 进行集成了
这里还有一些更多的你们可以在我们的API中使用的端点
或者最起码说对于你们这些开发者来说是这样的
这些还有很多的端点但是它们是被锁定的仅限内部使用
我们想要的是真正的安全确保当集成在运行时不会和太多的东西混杂在一起
尤其与客户端服务器之间的交互
你可能会在更多的地方而不仅仅是你的网络上
把你的服务器公开出去
不过当我们稍后上传了这个开发视频以及幻灯片后
我建议你引用这个幻灯片在你们自己的服务器上尝试这些端点
然后看看你们会得到什么
看看对于你们团队来说有什么有趣的事
今天我们看了我们在Xcode上对Xcode Server所在的改进
无论是从质量方面来说
还是从采用添加到Xcode 7中的新测试特性
来说 尤其是新的代码覆盖特性
用来度量你的应用程序代码在你的测试中
实际被用到的情况真是再合适不过了
当然了我们也向你们演示了扩展
Xcode Server通过触发器以及Xcode Server API把它
更好地与你们的团队进行集成的两种方法
要获取更多信息我们有一个
开发者库有一个“持续集成指导”
当然了你也可以在开发者论坛上
贴出任何问题
有几场会议与此相关
它们都已经结束了
有些是刚刚结束的
昨天结束的是“Xcode中的UI测试”不过我建议你们去看看视屏
今天我们也谈及了UI测试但是我们并没有向你们演示
它在Server中是如何运作的
它的自动化程度很高不过UI测试特性真的很棒
我建议你们去试试
如果关于如何使用XcodeServer你想了解更多信息
那么去年我们在Xcode 6会议中演示了如何从头开始
设置你的服务器如何在“持续集成”中
初始设置你的Bot
谢谢大家 祝你们在苹果全球开发者大会剩余的时间内过得愉快