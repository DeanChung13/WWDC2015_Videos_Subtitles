深入分析
謝謝
謝謝 我是查德·伍爾夫
我是克里斯·馬克爾
我們是蘋果的性能工具工程師
這是會議412
我們會深入談一下“分析”
也就是談一下Instruments中的時間分析器以及如何用它
來優化你的應用程序
當你想要找出你的應用程序把大部分時間都花在哪裏了
的時候你就可以求助於時間分析器
舉個例子
當你試圖查明應用程序在
運行時間內做了什麼事時時間分析器就會非常有用
你想看到具體調用情況
我們的會議會這樣分成若干部分
我們將會談談爲什麼我們想要舉辦一場專門針對
時間分析器的會議的動機
不過會議會以向你們演示展示它的工作原理的細節
你的應用程序在源代碼級別
以下的工作原理爲中心
最後我們會就你們如何自行使用時間分析器
給你們一些小竅門
首先快速談談我們的動機這次會議是受
“Instruments 7”的直接啓發
“Instruments 7”的目的是展示新的外觀新的感覺
它意味着新的工藝圖並且還意味着我們想讓這種
新感覺更具響應性想讓這種新感覺更流暢
我們會從在各個方面對我們的UI進行優化
我們還想嘗試新的圖形風格
我們過去就想嘗試新的圖形風格
但是我們現有的圖形代碼的性能不足
我們知道我們不得不把注意力放在渲染上面
因爲它是應用中的一塊硬骨頭
Instruments必須處理成百上千
有時候甚至是數以百萬的數據點 Instruments必須把這些
處理成一個非常容易理解的表達
那裏的算法複雜性毫無疑問就很高了
對於我們來說 這就意味着我們必須對我們的應用程序中
特別重要的一部分進行重寫也就是對位於app頂部的軌跡視圖進行重寫
整個冬季 克里斯和我拿出了新的軌跡視圖的設計
開始根據一系列的原型進行構建
我們並沒有在Instruments中直接生成原型
而是爲了簡單起見 把它拆分到了一個單獨的應用程序中
這就是我們最近的一個原型的樣子
當我們生成原型時我們做了一件事 我們設置了
一項“性能預算”
當我們分層堆放功能特性的
時候 我們會依據這項“預算” 不斷地對
我們的代碼的性能進行評估
當我們超出了“預算”時我們就會藉助於時間分析器
看看到底是我們的應用程序的哪一部分出了問題
有時候很容易就可以修復而有時候則不然
因爲我們生成的是原型
所以即使我們需要進行一些大的結構改變才能把
性能拉回正道這也是相當容易的
當我們把它集成回Instruments時
我們會再次藉助於時間分析器
找出我們的集成點中的“熱點”
這樣經過幾次迭代後我們最終得到了Instruments 7
這個版本實現了我們的性能目標
時間分析器幫助我們“熬過”了這個冬天
爲此我們興奮不已因此當蘋果全球開發者大會
來臨時 我們想開一次會議談談時間分析器
談談它善於解決哪些問題
我們想要和你們分享我們寫軌跡視圖時的經驗
我們今年所做的就是在iOS上創建了一個演示應用程序
它和軌跡視圖的第一個原型看起來很像
我們也給自己設定了性能目標
我們想要繪製十萬個數據點
我們想要平移和縮放的幀速爲完美的每秒鐘六十幀
我們還想讓它支持第一代iPad mini
我們選擇第一代iPad mini的原因是...
你知道我說的是什麼...
如果它能支持第一代iPadmini 那麼它在其它的平臺上
尤其是後面的平臺上也就沒問題
克里斯會向你們展示這個應用程序
他會對它進行時間剖析他會向你們展示把這些東西
組合到一起時我們發現了什麼東西
謝謝 查德 這裏我有Xcode的原型應用程序
我想點出幾樣東西
當我們初步實現時我們發現 我們根本就處理
不了不到十萬個的數據點
一開始 我們先從一萬個數據點開始
還有一點也很重要你應該在你的發版構建上進行
時間剖析因爲你肯定想在你進行
剖析時 把編譯器的優化利用起來
我要開始剖析應用程序了
我要從產品菜單中選擇“剖析”
這樣就會構建應用程序把它安裝到iPad上
並且顯示出Instrument模板用戶
這裏 時間分析器已經爲我們選擇好了
我要點擊“選擇”
這裏 你可以在我們的軌跡視圖中看到Instruments
我們過一會兒再回來看這個
現在我要開始錄製了
點擊“錄製”按鈕我們向你展示了app
我想要強調下 你們在這裏看到的 這個並不是模擬器
這是QuickTime對app上已有的東西進行的鏡像
這是我們的圖表我要開始滾動
滾動沒有什麼不好我要通過收聚進行縮小
剛開始還不錯不過之後就開始卡了
這可不太妙
最後我要用我的手指進行
前後滾動我正在移動我的手指
但是顯示器並沒有更新太卡了
性能表現太糟糕了
我們來看看發生了什麼
讓我們回到Xcode中回到Instruments中
我們把分析器停下來
快速讓你們看看新的軌跡視圖
這裏我們看到了CPU使用情況
它指的是在某個特定的時間單位內
平均的CPU使用情況
這裏的時間單位取決於你當前的縮放程度
當我使用我的app時你可以看到不同的部分
那裏消耗的時間是不同的
這是滾動 這是縮小這是縮小時進行前後滾動
關於軌跡視圖 還有一點很棒 就是我可以使用這個
縮小手勢來放大我感興趣的某段數據
如果你用的不是Trackpad那麼你可以按住選項鍵
上下滾動來進行放大和縮小
我想看看這段特定的數據
就是這裏的這個活動
剛纔我在這裏進行了滾動
爲此我要使用一個過濾器只需單擊並拖動
就可以把那些特定的樣例給選中這樣我就可以專注於
那個特定的數據
我要在下面這裏創建更多的空白
下面這裏是我們的詳細視圖
它可以向我們顯示我們在某個特定的函數
或者方法內擁有的時間分析器的樣本百分比的數量
這樣我們就有了符號名
這是我們的百分比這是我們的符號
當你進行時間剖析時你通常所做的第一件事是把這個擴展開來
然後查看某種...在這裏對數字進行對比
這裏是具體的方法函數
看看突出來的是什麼類型的情況 
你知道的那些值得你進行調查的情況會顯示出來
還有一個選項 如果我們認真看看檢查器窗格
點擊擴展開的細節 我們就能看到最厚重的堆棧蹤跡
這是針對主線程的
當我進行時間剖析希望提高性能時
我就會關注這裏因爲這裏是最物有所值的
我們來看看發生了什麼
主線程調用了應用程序的主線程 進行循環
核心動畫開始工作了
沒有什麼異常情況發生
實際上這就是剖析時常見的事
你想看看應用程序最常乾的事情是什麼
但是看起來它並沒有做什麼特別的事情
那裏什麼也沒有
沒有要求在這裏計算第四十個斐波納契數也沒有做什麼其它異常的事
但是 你知道的看看這個調用棧
看看這個堆棧蹤跡我知道了我的應用程序做了什麼事
這是一個簡單的原型app它的作用就是
構建一個路徑並且繪製一個路徑
實際上 我能夠看到這裏有一個調用一個CG環境路徑
它沒有被我的代碼根據堆棧蹤跡調用到
就在這裏佔據了很大一塊時間
我要點擊下那個看看它
如果我們看看我們的調用樹
我就可以看到一些有趣的事
我們可以看到根據這個調用樹
這個繪製路徑會被這個
繪製分層法在UI試圖上調用
它還會爲圖形視圖調用我們的drawRect
這佔據了大量的時間
這就是app所做的其中一件事
如果我看看這裏的那個時間環境繪製路徑佔據了
你知道 樣本的55%但是這個drawRect佔據的卻非常少
這就很有趣了如果我在drawRect方法上
右擊下我就可以看到源代碼
我知道了如果你看看底部那裏
我就可以從drawRect方法上調用繪製路徑
但是在哪個樣例中都顯示不出來
只是在添加路徑
這可不太尋常
因爲我的預期是我的drawRect方法
運行需要一段時間
它只是我的app完成的一半
看這個我注意到
drawRect返回了一個空白
最後調用的方法是環境繪製路徑
這可能就是所謂的“尾部調用消除”
查德會給大家講講什麼是“尾部調用消除”
以及如何對它進行驗證
好的 要解釋剛纔克里斯看到的情況
我們就需要理解時間分析器是怎樣知道在你的應用程序內調用什麼的
這個的技術含量就比較高了我會一步一步向你們講解
左邊是drawRect的代碼右邊則和你想象的堆棧
在UIKit調用drawRect之前爲那個線程找到的一樣
當向drawRect進行調用時
和大多數函數 方法所做的事情一樣
它會建立自己的調用幀
它會首先推送鏈路寄存器以及堆棧上的
幀指針的上一個值的返回地址
現在drawRect知道了怎樣返回它的調用程序怎樣恢復幀指針
下一件發生的事是我們得到幀指針設置成新的基礎
然後drawRect會給它的局部變量
編譯程序的暫存空間騰出空間
現在我們有了一個drawRect的幀
現在代碼開始運行了我們到繪製路徑那裏
繪製路徑做的事也相同它把自己的幀推送到了堆棧上
時間分析器的工作方式就是在內核中使用一項服務
以每秒1000x的速度對CPU所做的事進行採樣
在這個例子中如果我們採一次樣
我們就可以看到 我們是在環境繪製路徑中運行的
然後內核會看下幀指針寄存器
看看函數幀的基礎在哪裏
然後找到調用它的程序的返回地址
現在我們可以看到那個drawRect是在繪製路徑中調用
如果我們想看看drawRect中
調用了什麼我們就可以使用我們推送到
堆棧上的幀指針來找到drawRect的基礎
然後繼續返回堆棧直到我們到達底部
這就是一次回溯
如果我們有足夠的回溯並且把它們放到
調用樹視圖你就可以搞清楚在你的應用程序內發生了什麼
我想指出一點堆棧上的幀指針
是絕對必須的
如果你編譯代碼時關閉了fomit-frame-pointer
想要進行和我們這裏一樣的時間剖析
讓我們看看這個優化實例
啓用編輯器優化後drawRect
就是進行編譯的
同樣地我們有一個drawRect幀
我們要準備調用繪製路徑了
你可以注意到 當繪製路徑返回drawRect時就完成了
什麼也不需要做
它就會返回回來
它返回時會彈出堆棧結構
恢復幀指針的上一個值
然後回到調用程序
編譯器看到這個後會想
爲什麼繪製路徑需要用到drawRect的堆棧結構的東西？
明明不需要的此外返回它的調用程序時
爲什麼要返回drawRect？
那麼它就會把代碼重新整理成這樣
它會彈出堆棧結構恢復幀指針
然後直接向繪製路徑進行回調
這就意味着我們無需再跳回調用程序了
解釋這個要比讓你們直接看到更困難
讓我們想象一下 當運行這個代碼時它會是什麼樣的
我們會彈出堆棧結構去掉局部變量
我們會把幀指針恢復成初始值
鏈路寄存器的值
然後我們跳回繪製路徑代碼的開頭
繪製路徑會使用它在鏈路寄存器中找到的值
幀指針中找到的值把它自己的幀推送回堆棧
從繪製路徑的透視圖中它會直接在
UIKit的環境中從繪製層上得到調用
此時如果我們進行一次時間採樣
我們就可以看到同樣的情況
即使發生的不是實際的調用序列
時間分析器看到的就是這樣
我們在我們的調用樹上最後看到的就是這個
這就叫“尾部調用消除”在高度優化的代碼上
很常見也有一些好處
它能夠節省堆棧內存
節省堆棧內存時它會讓緩存保持“熱度”
然後重新利用內存緩存和數據
它對遞歸代碼有着深刻影響
尤其是尾部調用遞歸代碼在那裏 一個函數或者方法
會最後調用自身然後返回回來
無需推送這些幀一個遞歸函數內的
尾部調用消除就可以讓性能和迭代版本
一樣好所以堆棧就不會增長
並且性能也很優秀
這個優化也能兼容高度遞歸代碼
如果爲了剖析你想把它關掉
顯示一個更清晰的堆棧蹤跡
你就可以到項目的構建設置中把它關掉
並且把編輯器標誌
從CFLAGS設置成FNO-optimize-sibling-calls
關掉優化
不幸的是性能同時也會受到影響
但是這樣你可以在時間分析器中得到更好一個的結果
如果你選擇忍受它你想要知道是否發生了
尾部調用消除那麼你該怎麼做？
你可以看看反彙編調用最後調用的情況
如果是個普通的調用那麼它會使用指令的
一個分支和家族鏈接那裏是第一個實例
那就意味着它會跳到新函數
並且在鏈路寄存器內保存返回的值
如果是一個尾部調用並且我們需要直接跳到
直接跳到新函數內 那麼它就是一個直接的分支指令沒有BL
那就是一個指令和鏈路的調用指令
分支就是一個轉移指令
如果你看看它你會發現很眼熟
現在就由克里斯來決定了他可以禁用優化 重新編譯
或者他也可以繼續由你決定
我要看看反彙編
在Instruments詳細視圖的右上角那裏
有一個按鈕查看反彙編 如果我點擊下
我就可以看到那個方法的反彙編
我們就可以確認添加路徑環境調用是一個分支和鏈路
環境調用繪製路徑是一個簡單的分支
我確信這是一個尾部調用消除的例子
我在調用樹上看到的55%的調用都不屬於我的drawRect
它們本來應該屬於我的drawRect
這是個好消息
現在我知道了drawRect就是我的最重的堆棧結構
我的最重的堆棧蹤跡
消耗了我55%到60%的時間
很好 我知道應該優化哪裏了
我要優化drawRect開始吧
我們來看看這個drawRect
看看這個drawRect 如果有張桌子的話我早就掀了
優化的地方不多
很難想出一個能用的更簡單的
但是又能用的drawRect
我們有四個函數調用 環境你知道的 CG調用
這個drawRect沒有起到多少作用
那麼這個實際上就是進行剖析時
一個很常見的事
你看了下自己的“熱點”和代碼
發現你沒有多少能直接在代碼中進行修改
提高你的性能的地方
你知道 這個節點你該做什麼？
你知道 除了掀桌子晚上在枕頭上嚎啕大哭之外
我們所做的事 就是仔細檢查開始查看核心圖像文檔以及其它繪圖
你知道 Cocoa繪圖資料
我們無意中發現了這裏的這個特殊的屬性
這是drawsAsynchrously
你瞧！這是一個“讓我的代碼更快”按鈕
是一位蘋果工程師創建的
非常棒
在那個上面 你可以看到
我從資料中複製出來粘貼都了那裏
它說了幾件有趣的事
首先它說 它可能提高性能也可能不會提高性能
你應該衡量得失
你懂得 好了 爸爸
我們開始度量吧
我們看看這個能否提高性能
這次 要啓動Instruments我要給Instruments進行
運行command-I
它會做同樣的事情
它會構建應用程序安裝到設備上
顯示出模板選擇器
需要一點時間
還需要一點時間
還得再需要一點時間
好了 我還想使用另外一種快捷方式 如果你看看下面的選擇按鈕
如果我按住選擇按鈕它就變成了“剖析”
這就意味着着當我點擊這個按鈕時
應用程序就會開始錄製
會替我省一兩步
我現在點了
現在時間分析器出來了
會對app進行度量
我要快速進行一些前後滾動
捕捉一些數據
我想夠了
讓我們把錄製停下來
我要進行過濾獲得具體滾動數據
如果我們到下面這裏看看細節視圖
很有希望
實際上上你們可以看到這裏有多個線程
線程正在發揮作用
這很好
如果我們繼續如果我按住選項
點擊提示三角符號我就可以看到這個線程在
調用什麼這是一些羣調用
一些CG調用 很好
這就是繪製代碼
我們繼續一個接一個檢查下
按住這個選項鍵
羣調用 CG調用
很好 這個看起來很有希望
我是多線程理論上我的app應該更快了
但是 多線程並不一定意味着更快
我們應該確認它真的在幫我們做事
有一種方法可以確認 我碰巧知道這臺設備有兩個CPU
如果CPU以最大性能
並行運行 那麼我應該會看到在我圖表上面這裏
看到200%的CPU使用情況
但是我看不到有超過100%的情況
那麼這就是某種警告信號了它並不一定意味着兩個
CPU沒有同時工作
它只是意味着我應該進一步檢查下
那麼我們怎樣進一步檢查？
Instruments就有我們稱之爲“策略”的東西 
它指的是對數據進行劃分的不同方法爲的是查看數據
這裏有三個
第一個是Instrument策略即默認值
我們在這裏看的就是
第二個是CPU策略
它顯示的是每個CPU或者CPU的數據 相關數據
最後一個是線程策略
它給你顯示了每個線程處理的細節情況
我們來看看CPU策略
我們可以看到我們擁有的每個CPU
我們可以看到它們做了多少功
在底部我們可以看到組合使用情況
這裏有一件很棒的事可以做當我放大的足夠大
圖表向我顯示的細節就會發生變更
它就會顯示那個CPU是否處於活躍狀態 
而不再顯示平均使用情況
它就會顯示活躍或者不活躍而不再顯示平均使用情況
現在每個CPU都顯示了一個在線狀態或者離線狀態是否處於工作中
這裏你可以注意到CPU從來沒有一起工作中
這裏沒有並行性
你懂得 這可不好
如果我們還想試試傷口撒鹽我們可以看看線程策略
它可以向我們顯示每個圖標
每個圖標代表了時間分析器採集的一個樣本
你可以點擊 看看調用堆棧
這裏的這個是位於一個後臺線程上
你可以看到核心圖形調用這是主線程
你可以看到主線程...我們在主線程上進行的工作
你可以看到 如果我放大到合適的程度
應該就是這裏了我滾動下
你可以看到兩個線程並沒有真的同時工作過
它是從一個線程跳到另一個線程
因此drawsAsynchronously並沒有真的爲我們做什麼事
從理論上來說它可能會拖慢我們
我們不僅進行了繪製而且還進行了管理
你懂得 核心圖形系統對它工作的線程進行了管理
類似這種的事情 並沒有什麼實質作用
我會把它關掉
我會再掀一張桌子
不很清晰神奇按鈕沒多大作用
我們現在該怎麼做？
同樣這也是時間剖析中一個很常見的情況
你嘗試了很多事但是大部分都不起作用
我們往回退一步
app會怎麼做？
它構建了一條路徑然後描繪了一條路徑
我們已經看過繪製路徑代碼了
我們來考慮下構建路徑代碼
就在這裏
我們想做的事就是調查下我們構建的實際路徑
這個代碼的作用就是循環數據元素
創建一條路徑然後爲每個數據元素向那個路徑中一行
我們想知道我們向那個路徑中添加了多少行
時間分析器就可以告訴我們這個信息
它不能告訴你某個特定的方法
函數被調用了多久被調用了多少次
它不知道一個被調用了僅僅
幾次的慢函數同一個被調用了很多次的快函數之間
有什麼區別
在這個例子中 我們要藉助於NSLog 我們就可以實現
一個情況 即我們每次添加一個路徑 我們就放大計數器一次
然後當我們循環結束時我們就把它錄入
重點要指出的是NSLog並不是一個
很快的函數
在高性能代碼中你不會想讓它出現的
除了收集診斷信息或者進行調試以外
你可能不會想用它做任何其它事情
當你用完後把它從代碼中刪掉
在這個例子中 我們僅僅添加註釋 這樣你可以看到
我們發現 我們在例子中的這個點這裏添加了十萬行
這是沒有必要的
事實上 這臺設備上無論如何也顯示不了十萬行
尤其是當你縮的足夠小所有的數據
就都需要適合一百個屏幕點
沒理由在那裏繪製十萬行
我們繪製一百行就可以了
這樣工作就少了很多
我們繼續 創建一個執行來實現它
如果是多個數據元素數據點位於一個單一的
屏幕點那麼它就會找出最大值
繪製一條單一的行
如果我們使用一百個屏幕點我們就會創建一百個屏幕行
我們來切換到那個執行
我們對它的感覺很好
我們把元素數量的上限改成了十萬
而不是一萬
我們看看這對我們是否有幫助
我要使用command-I來啓動Instruments
因爲Instruments已經打開了它就會把它弄到
前臺立即開始錄製
好了 一個新的錄製
我們來滾動下滾動看起來沒問題
我再縮小下
縮放性能也有了非常大的提高
需要的時間更多因爲我要縮小的數據更多了
看起來真的很好
我要進行前後滑動
現在它能很好地追蹤我的手指了
它能跟得上我的手指真棒
萬歲！都搞定了！
還差一點
當我們前後滾動時
如果我們看一下我們使用的CPU的實際數量
我們就可以看到 你懂得有時候會降到60%
通常是七十到八十秒
從技術上說我們實現了我們的性能目標
我們要做的我們接下來要對這個app
原型做什麼？
我們添加了一些附加特性
我們知道我們需要比這裏更多的淨空
我們怎樣能讓它更快？我們怎樣能讓這個app更好？
我們怎樣實現性能目標？
我們專注下這個
我們來過濾下那個數據
我要給我自己一點空間
在這個例子中我要按住選項鍵
點擊“主要”把它展開
我就可以到這裏看到這裏的這個方法
你懂得 現在繪製路徑就足夠快了
反而是構建路徑成了瓶頸
我想關注下這個方法
我要點擊下“聚焦”按鈕
它會把方法中的所有事情移動到一邊
把這個方法中
我們的百分比標準化
這個方法把55%的時間用在了獲取下個元素上
把10到11%的時間用在了objc msgSend上
關於objc msgSend我知道的是
它是一個超快的方法
它是經過極致優化的
但是如果我能把那個10%拿回來 我還是想要
如果我們看看我們代碼裏面我們就可以看到它已經 
很乾淨了
我們大部分的時間都花在了獲取下個元素上
這裏的這個百分比 要比樹狀視圖中的略微高一點
因爲它包括了objc msgSend的時間
如果我把它去掉這個迭代程序就更快了
希望我就可以實現我想要的性能提升
請查德給我們講講如何實現這一點
我們來談談objc msgSend
無論你何時使用方括號符號
無論你何時使用點符號來訪問一個對象的屬性
編輯器就會把它隱式插入
它的目的是查找選擇器的實現方法
然後調用那個方法
我們如何在Objective-C中進行動態分派
要講的東西還很多
Objc msgSend非常快也不會推送堆棧結構
當你看你的時間剖析時
通常來說你不會看到它的效果
你能看到它的時機就是在一個完美的例子中
就像我們在我們的迭代程序中看到的那樣
我們要做的就是迭代超過十萬個點
用一個小的方法主體稱之爲“獲得下一個方法”
只需增加一對值返回一個結構即可
那麼接下來要發生的就是Objective-C消息發送
開銷時間會積累到一個可測量的程度
是否有方法可以避開開銷呢？
不一定
Objective-C從設計上就是一種動態語言
要訪問對象和類的方法你就必須
進行objc msgSend調用
每次它都會這樣做因爲你可以在運行時間
轉換方法執行
Objective-C內沒有編譯時間
比如說我想調用這個特殊的方法主體
這裏唯一的異常是 如果你進行所謂的“方法緩存”
你可以自己查找方法執行
然後通過函數指針調用它
一般來說我不推薦你們這麼做
你可以想象的到它很脆弱
一般來說 根據我的經驗它沒有給過我期望的性能你得想想我們起初
到這裏的目的是什麼
我們到這裏的原因獲得下個元素方法有一個小的方法主體
即使你通過函數指針調用它你也必須對自變量
進行整理把幀推送到堆棧上
並且在你完成後把它們彈出來
你們在上一組幻燈片中看到的正是這個
開銷可能會很大增加後會再返回
我想要指出的是方法緩存並不像
直接插入那樣快在這個例子中
我們真正想實現的是直接插入那個小的方法主體
我們在Objective-C中該怎樣實現？
你還有其它選項
首先 你本來應該用 C
你本來應該用結構而不是一個
迭代程序舉例來說 你可以向這個方法中傳遞一個C線
如果你想要那個OO特點你可以使用C++
你在Objective-C中使用C++的方法
是把文件從a .m重命名爲a .mm
然後你就可以使用C++語法
因爲通常Arc是默認打開的
然後你取出Objective-C對象把它們放進
STL容器內把它們放到你的類和結構的實體變量中
這很方便你也可以得到C++的性能好處
我在Instruments中大量用它以便在軌跡視圖
以及Instruments其它關鍵的地方儘可能地快
根據我的親身經驗這個有一個主要的下降趨勢
你需要提前知道你的代碼的哪一部分會
從C++中受益哪一部分代碼會從
Objective-C中受益
有時候像我們在演示示例中那樣
你可能在那裏犯錯誤並且直到進行剖析才意識到
我們是用Objective-C寫了我們的
Objective-C沒有意識到它在我們的時間剖析中有多慢
除了我剛剛提到的這些你還有其它更好的選項嗎？
當然了 你知道的已經有了
Swift非常完美因爲不像Objective-C
Swift只有在註釋爲動態時它纔是動態的
如果你確保性能關鍵類是內部的
並且使用整體模塊優化
編譯器或者整體工具鏈就可以確定何時只有
一個方法執行
並且把它內聯到調用點讓你的性能有明顯的提升
尤其是對迭代程序這個例子
因爲我們是在生成原型在Swift的視圖控制器中
重寫迭代程序就非常容易了
克里斯之前幹過這個
我有一個Swift執行已經就緒了
這是Objective-C執行的一個簡易的接口
採用了他們在今天上午的會議上提出的關於...
...優化Swift代碼的幾點建議
具體來說就是打開整體模塊優化
讓我們來剖析下這個Command-I
它會開始構建
安裝到設備上
它會開始進行剖析
好的 我要把應用程序提前這樣你們就能看到
這是滾動
看起來不錯
縮小
好了
縮小
非常棒 非常快
要縮小很多數據
現在 如果我前後移動它移動的就非常快了
太棒了
謝謝 實際上我們可以到這裏
看看CPU使用情況
你懂得我們取得的優化超過了
我們的預期去掉objc msgSend
我們本來預期會有5到6%的提升 這個有點低
如果我關掉這個提示三角符號 你就可以看到
它們兩個以此運行 你可以看到之前的運行更低...
當前的運行很明顯更低
事實上如果我到這兒
查找我的構建路徑方法現在我就必須進行搜索
這就是你進行搜索的方法
如果我點擊command-F這個對話就會顯示出來
我可以輸入構建路徑 
它會在這裏給我顯示我的方法
如果我們看看這個 你就可以在這裏看到我的Swift代碼
我的獲得下一個調用就在這裏
沒有在任何樣例中顯示出來
你懂得沒有樣例包括了這個
爲什麼？因爲Swift能夠把它內聯
鞭子意味着這裏沒有函數開銷
沒有方法調用開銷等等
因爲迭代程序的代碼和其餘的代碼是內聯的
它就有了進一步優化這就解釋了出現比我們預期的
更高的性能的原因
它是忽略了動態調度
查德 你還有什麼想對大家說的麼？
當然了 我們還剩五分鐘！
當你自行探索Instruments時這裏有一些小竅門
首先要指出的是在錄製設置下面
叫做“錄製等待線程”
我提到過我們使用樣例
活躍CPU的服務和內核
但是如果你有空閒的線程被一個加鎖阻塞或者等待
輸入/輸出你就可以勾選這個複選框
服務就同樣也會對空閒線程進行採樣
如果你有代碼和加鎖爭奪支配權
那麼當你激活錄製等待線程時
你會看到熱區顯示出來
我還發現了另外一件有趣的事
在“顯示設置”中調用樹那裏
調用樹被反轉了過來
打個比喻就是它把調用樹顛倒了過來
在樹的底部節點看到的就不是葉子
那就是沒有被調用到任何地方的函數
它們顯示到了頂部
如果某個實用功能同時被五六個地方調用了
你把調用樹反轉過來看看到底是誰在調用
那個特定的函數
它給你提供了調用樹上的數據的一個不同的視角
當你在調用樹上右鍵點擊一個節點
你就可以看到環境菜單這也是那裏的一件有趣的事
我經常做的一件事就是給調用者記賬
那麼你就可以給調用者的方法記一筆欠函數的賬
你可以給調用者記一筆欠整個框架庫的賬
那裏還有一個選項可以修剪子樹
如果你當時不想處理某個具體的問題
你可以把它從數據上修剪掉然後專注於你想專注的事情
我們從中學到了什麼？
就是通過這個我要提醒你們的第一件事
就是提前合併性能目標
如果你像我們一樣進行了一個大的性能重寫
你要首先設好預算然後對它進行監視
因爲一旦你開始在它的頂部分層放置大量的代碼
要改變就很難了
其次 要經常進行度量
在我們的整個演示中我們用時間分析器進行了時間剖析
我們用那個數據來找出“熱區”
然後把它返回最後我們就得到了一個運行良好的應用程序
如果你還是不明白 可能你可能很幸運 直接點吧
我會從一個測量開始然後把它當成領頭羊來追隨
第三 這個對我來說很重要
我鼓勵你們深入挖掘下去
你第一眼看到的某些性能問題可能
看上去是無解的
你說別人的的代碼中就出現過這種問題
或者是運行時間的副效應
我們給出你時間分析器運行時間的詳細資料的
原因給出你反彙編視圖的樣子
就是想向你們展示那是一個細節豐富的一個完整的世界
用它你就可以像我們今天一樣解決性能問題
我鼓勵你們帶着創造性去進一步挖掘
看看像這樣的會議
我知道你們能夠修復問題 實現你們想要的性能目標
只要你今天開始幹就行
史蒂芬·萊塞是我們的開發工具福音傳道者
如果你有問題的話就可以聯繫他
與我們相關的會議是“能量調試問題”
證明瞭如果你在CPU上的代碼是有效的 CPU耗能就會更低
那次會議是週三舉行的
明天還會有一個關於iOS以及Watch OS的會議
好消息是 時間分析器也能用於watch上的app
這是一項大福利
祝你們在會議剩餘的時間內過得愉快