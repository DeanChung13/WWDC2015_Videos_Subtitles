在Swift中 如何使用數值類型來打造更好的app
大家好 我是道格·格雷戈爾
今天我和我的同事比爾·達德利
我們會講講在Swift中 如何使用數值類型來打造更好的app
首先我們來談談
引用語義 
然後我們會深入探討下不變性 把它作爲引用語義提出的某些問題的
解決方案
深入探討數值語義、數值類型
尤其是它在Swift的工作原理數值類型在實踐中的應用
然後探討引用類型和數值類型
在Swift中的混合
讓我們開始吧
引用語義
引用語義在Swift中就是用來定義一個類
這是一個很簡單的溫度組別
我們以攝氏度來存儲我們的溫度數值
想得到這個不錯的計算華氏溫度屬性
這樣我們可以始終以正確的單位得到它
溫度的簡單、抽象版本
讓我們試着把它用到一些簡單的代碼上
我們創建一個家庭 實例再創建一個溫度實例
把我們的恆溫器設置成溫和的七十五華氏攝氏度
現在我們來決定...晚餐時間快到了
我想烤一些鮭魚肉
因此我把烤箱的溫度設置成425度然後點擊“烤制”
走開一點
爲什麼這裏這麼燙？出了什麼事？
你知道發生了什麼事我們實現的就是非有意的共享
想想對象圖表
我們有自己的房子
裏面有一個恆溫器和烤箱
我們還有這個溫度指向的溫度對象
當我們設置我們的恆溫器時
我們把它作爲溫度連接到相同的對象
事情看起來不錯直到我們進行轉變
現在這個非有意的或者意想不到的分享
讓我們把我們的恆溫器設置成了
四百二十五華氏攝氏度
此時已經玩完了
但是爲了度量起見讓我們把我們的恆溫器連接到烤箱
因爲我們已經搞砸了
那麼我們做錯了什麼呢？
在這個有引用語義的世界裏
你想要阻止分享 你就要進行復制
知道了嗎？讓我們來這樣試試
好的 把溫度設置成七十五
華氏攝氏度
當我設置我的恆溫器的溫度時我就會生成一個副本
我就得了一個全新的對象
我的恆溫器的溫度指向的也就是它
當我改變我的溫度變量的溫度時
並不會對它產生影響 很好
現在我來設置烤箱的溫度
我又生成了一個副本
現在從技術上來講我並不需要最後的這個副本
在堆上浪費時間分配內存創建這個另外的副本效率很低
但是這樣更安全因爲上次我錯過了一個副本
結果把我烤熟了！
給點力吧 這是週五的會議讓我喘口氣吧
我們把這個稱之爲“保護性拷貝”
我們進行拷貝並不是因爲
我們知道我們需要它 而是因爲偶爾
或者過一段時間後需要用它
調試這些問題是相當困難的
無論我們什麼時候
把一個溫度指定到我們的烤箱某處忘記進行點拷貝太容易了
我要在我自己的烤箱中烤一烤這個行爲
好 我完了 我完了 對不起 對不起
通常來說我需要給恆溫器做同樣的事
不是嗎？
有了一大堆樣本我們正在進行復制粘貼
你遲早會來敲我的門問我借
一項語言特徵
我們先來談複製Cocoa和Objective-C
在Cocoa有一個NSCopying協議的概念
它對複製的意義進行了編碼
你有很多的數據類型這NSstring NSArray
NSURLRequest etcetera
這些都遵從NSCopying因爲你需要安全地對它們
進行復制
我們的系統中需要大量的複製
因此你有足夠的理由看到大量的“保護性拷貝”
NSDictionary會對你放到字典中的鍵進行保護性拷貝 爲什麼？
若要遞給NSDictionary一個鍵 進行插入
然後又做了變更改變了它的hash值
打斷NSDictionary內部變度
然後埋怨我們讓你出了bug
這可不是我們想要的
想要的是在NSDictionary保護性拷貝
在這個系統中 這是正確的答案但是不幸的是
進行這些額外的複製會讓我們損失性能
我們會把這些都弄到Objective-C
帶有複製屬性的語言層面
來對每個單一的賦值進行保護性拷貝
以此來避免這些問題 這確實有用
這個保護性拷貝確實有用
不過還不夠好
你仍然會有一堆的bug
因此這些引用語義有問題
出現了變異
也許這裏的問題不在於引用語義
而在於變異本身
也許應該移動到帶有引用語義的不可變數據結構
如果你和函數式語言社區某個人談一談
他們會說 是的
幾十年前我們就開始這麼做了
它確實可以提高那裏的情況
因此如果沒有副效用你就不會出現非有意的副效用
不可變引用語義是一種在系統中工作的
一致的方法
它沒有那些我們在我們的溫度小示例中出現的意外後果
問題在於不變性也有不足
它可能導致不佳的界面
語言工作的方式就是 它的一部分
我們生活在一個我們可以讓事情產生變異的世界中
這也是它的一部分 我們想到狀態
變異的狀態 因此單純在一個
不可變的世界中進行思考有時候對我們來說
是比較怪的
有效映射到機器模型
也是問題
最後你還是不得不着手處理機器碼
在一個有狀態寄存器、狀態緩存、
狀態內存、
狀態存儲的CPU上運行
把一個不可變算法映射到那個層級效率並不總是那麼容易
我們來講一講其中的幾點
我們把我們的這個溫度類拿出來
通過讓它成爲不可變的增加它的安全性
我們把攝氏度存儲屬性從一個var變成一個let 你不能再改了
然後華氏溫標計算器屬性的設值函數沒有了
因此無論你做什麼
你都不能再改變溫度狀態
爲了方便起見我們添加一些初始化程序
好的 我們來談談不優美的...
不優美的不可變界面
要是我說我把我的烤箱溫度調整
十華氏溫度 這是一個簡單的操作
加號就是十度 可以了 好了
如果我們把變化去掉我們又該怎麼做？
我們就必須抓住烤箱的溫度對象
創造另外一個有新值的溫度對象
對吧？這就有點不太好看了代碼更多
也浪費時間在堆上分配另一個對象
我們並沒有在這裏擁抱不變性
因爲我們是做了一個使烤箱本身發生變化的賦值
如果我們在這裏自始至終
擁抱不可變引用的概念
我們就可以創建一個新的溫度放到一個新的烤箱中
然後放到一個新家中
不美觀！讓我們再搞點理論知識做一些數學題
埃拉托色尼選篩法是一種計算質數的古老的算法
它使用了變異 非常適合在地上用棍子
畫出事情
這是Swift中變異版本的執行
我們來演示下以便你明白它背後的想法
你首先要做的是：創建一個陣列
注意var 因爲我們要改變這個陣列
注意這個陣列來源於兩個、三個質數
是從你計算的數字中求出來的
我們這裏是二十
現在每次通過外層循環
我們就會選擇陣列中的下一個數字
那個數字是一個質數P
內循環要做的就是走過P的所有倍數
把它們設爲零將它們從陣列中抹除
如果是一個質數的倍數
那麼你就不是質數
再回到外層循環
我們獲取下一個數字 這是一個質數
我們從陣列中把它所有的倍數抹除
這是一個非常簡單的算法
想想地上的棍子
你就是在把事情劃掉
一旦我們迭代
完畢我們就到這裏
進行最後一個簡單的操作 也就是說
陣列中所有我們未歸零的東西
就是我們的結果的一部分
我們用一個過濾器來處理它
算法非常簡單 完全基於變異的
但不是不能在沒有變異的
世界裏表達它
你當然可以的
爲此 我們要使用Haskell
因爲它是一個單純的函數式語言
是的 我知道大家都愛它 好的
這是Haskell的公式化
如果你讀過Haskell 它很美
它是函數式的 它一點也不會發生變異
這是個類似執行它對Swift做了變動
因此也能是函數式的如果你想讓它懶一點
對於讀者來說這是一個練習
沒有那麼難
我們來演示下這個算法的工作原理
因爲非常相似
我們的陣列就從二開始 直到二十
在這個簡單的例子中 如果沒有數字
那裏沒有質數
那是第一個“If語句”這是小事情
你要做的就是我們把第一個數字取出來
它就始終是質數
把它和其餘的數字分割開來
Haskell通過模式匹配實現它
我們在這裏可以分層
我們把那個質數拿出來在這個陣列其餘的元素這裏
運行一個過濾器操作
僅僅複製那些不是
那個質數的倍數的東西
現在我們遞歸 再來一次
把“三”拆分 這是我們的新質數
然後運行這個過濾器
把所有三的倍數消除等等
這裏發生的
就是你以構建這個左斜 實際質數來結束
這樣它們就都會連接在一起
理念是相似的
非常相似
但是算法不同
因爲它的性能特徵不同
這個結果來源於梅莉莎·歐內爾發表的
一篇絕妙的論文 她稱之爲“真實的埃拉托色尼篩選法”
她向Haskell社區展示了他們摯愛的篩選法
並不是真實的篩選法
因爲它並不會作爲真實的篩選法來運行
她仔細查看了Haskell中非常複雜的執行
那又回朔到了性能特徵
讀一下那篇論文 看一看 非常酷
我想讓你們嘗試下爲什麼會出現這種情況
看看這個Haskell列表推導
或者下面等價的Swift過濾器
在這個不變版本中這個操作會遍歷陣列中的
每個單一元素
然後執行一個除運算看看下一步中
它是否還應該在那裏看看它是否是P的倍數
在原始的變異算法中我們只會遍歷質數的
倍數以及那些...當然了
隨着你得到越來越大的數字 就會變得越來越稀疏
你訪問的元素更少 此外
你只需要在到達下個元素進行一次加法
這樣你每個元素所做的工作就更少了
這是有關係的
不變版本不像變異版本的效率那樣高
後者無需做很多的功
我們再回到Cocoa
你看到了在Cocoa中使用不變性Cocoa Touch框架
它們有很多日期 Ui圖片 NSNumber等
它們是不可變類型
有了這些不可變類型安全性就可以得到提高
這是件好事因爲你就無需
擔心複製了
你無需擔心你的共享會產生非有意的副效用
但是當你用它工作時你也會看到缺點
在Objective-C中給自己一個小任務
我想從我的主目錄開始通過添加逐次路徑元件
獲得某些目錄的方式 來創建一個
NSURL
我想在引用語義世界中 無需變異
就可以實現這一點
因此我創建了一個NSURL
每次通過循環時 我就通過附加下一個
路徑元件 來創建一個新的URL
這個算法並不是非常好 真的
每通過一次我就創建一個NSURL另一個對象
舊的對象就會消失然後NSURL就會在每次通過
循環時 複製所有的串式數據
那裏的效率不是很高
道格 你按錯了
你應該把所有的這些元件收集到一個NSArray
然後使用帶路徑元件的文件URL
就這樣吧 不過要記住我們是在這裏擁抱不變性
這樣當我創建我的陣列時我會創建一個帶有特定
對象的NSArray 好的
這是主目錄
每次通過時我創建一個新的陣列
多加一個對象
我仍然是二次的
我仍然是在複製元素
我複製的不是串式數據
這樣好一點
我仍然是在複製元素
這就是爲什麼我們不在Cocoa世界中完全擁抱
不變性的原因 因爲這樣說不通
而如果你在更加本地化的
地方使用易變性 就說得通了
把你所有的元件收集到一個NSMutable陣列
然後使用帶路徑元件的文件URL返回到那個
不可變NSURL
因此不變性是件好事
它讓引用語義世界的推論更加容易了
但是你又不能完全選擇不變性
否則你會瘋掉
這樣我們就到了數值語義
對於數值語義我們想採用一個不同的方法
我們喜歡變異
它很有價值 如果正確使用的話用起來很容易
問題在於正如我們看到的在於共享
你已經知道了數值語義的工作原理無論你是在
Objective-C中還是在Swift中你都應該始終用它
道理很簡單：如果你有兩個變量
從邏輯上來講這些變量中的數值是不同的
我有一個整數A我把它複製到一個整數B
當然了它們是等價的 它是一個副本
我來改變B
如果我告訴你A也會變 你會說我瘋了
這些是整數
它們在我們用過的
每種語言中都有數值語義
到CGPoint中舉例來說
從A複製到B改變B 對A不會產生
任何影響
你已經習慣這一點了
如果CGPoint的行爲不是這樣
你肯定會大吃一驚
數值語義的理念就是把我們已經知道並且理解爲
最基本類型的事物像數字以及包含數字的
小的結構把它向外擴展
讓它能夠兼容更多、更豐富的類型
在Swift中字符串屬於數值類型
你創建了A從B複製到A然後對B做出某種改變
這不會對A產生任何影響
因爲它是一個數值類型
A和B是不同的變量
因此從邏輯上來說它們是不同的
知道了嗎？那麼爲什麼陣列表現的方式也是一模一樣呢
創建A複製到B 然後改變B
對A沒有影響
它們是完全不同的值
最後一點是字典 當然了
它就是一個集合
你把數值語義放進去然後向你返回的
也是數值語義
這裏很棒的一點是數值類型的構成非常漂亮
因此你就可以在數值語義的世界中非常容易地構建
非常豐富的抽象物
在Swift中所有的基本類型整數、兩倍數、
字符串、字符等等它們都是數值類型
它們都有這個基本行爲
從邏輯上說 這兩個變量它們是不同的
我們在它們頂部構建的全部集合...
陣列、集合、字典...
當給予它們數值類型時它們都是數值類型
你用來構建自己的類的語言抽象
這裏的類包括元組、結構和枚舉
當你把數值類型放進去時你得到的仍然是數值類型
再說一遍 在數值語義世界中構建
豐富的抽象物十分容易
數值類型上還有重要的一點
就是你有一個兩個值等價兩個數值類型
變量等價的概念
它們保持同樣的值
重要的是那個恆等式並不重要
因爲可有任何數字的複製
重要的是存儲在那裏的實際值
你怎樣拿到那個值並不重要
我給你們講幾件非常愚蠢的事
我們這裏有A把它設置成五還有B
我們把B設置成二加三
當然了 A和B是等價的
你一直是這麼用的
如果整數不是這麼用的你就理解不了了
因此把那個概念擴展一點
當然了對CGPoints來說也是如此
如果不是這種方式的話 你也理解不了
爲什麼字符串的行爲方式不是一模一樣呢？
我怎樣得到“你好 蘋果全球開發者大會”這個串不重要
字符串是數值相同運算符需要把它表示出來
你可能會讓它非常瘋狂非常愚蠢
這裏我要進行一些排序操作
歸根結底我有整數的兩個陣列
整數有同樣的值
因此這些東西是等價的
當構建一個數值類型 非常重要的點是
要遵從“相等”協議
因爲那裏的每個數值類型都是相等
這就意味着它有等於操作符
來進行對比 但是操作符的運作方式
必須合乎情理
它需要是反身的、對稱的、及物的
爲什麼這些屬性很重要？
除非你拿到你的代碼 否則你不理解
如果我從A複製到B 
那麼我期待A等於B B等於A
當然了 爲什麼不相等呢？
如果我之後又從B複製到C那麼C、B、A 
它們都是等價的 我有哪個數字不重要因爲唯一重要的是值
而不是恆等式
幸運的是 實現這些非常容易
讓我說就是拿出CGPoints
用“相等”協議擴展實現相同運算符
當你在其它數值類型上構成數值類型時
一般來說你只需要使用
下面的所有數值類型的
等號操作
好的讓我們把它弄回我們的溫度類型
我們現在生成一個結構
我們要把攝氏度切換回一個var我們就可以改變它
它現在就有了數值語義
很明顯 我們給了它相同運算符
我們來把它用到我們之前的例子中很好
創建家庭 創建溫度 把溫度設爲華氏
七十五度 哇！
編譯器停在這裏了 發生什麼了？
我們試着改變溫度的一個屬性
這項屬性的描述是“let”
它是一個常量 不能更改
我們來滿足編譯器
把它改成var 現在可以改變它了
一切都進展順利
爲什麼呢？家庭指向了烤箱內的恆溫器
恆溫器和烤箱都有了各自的溫度數值
實例
它們是完全不同的不會共享
它們在結構中碰巧也是內聯的
你的內存使用情況以及性能都更好了
這很棒 數值語義讓我們的生活更容易
有了我們的例子讓我們繼續
把所有的事情都變得有數值語義
房子的結構裏面有一個恆溫器結構
一個烤箱結構 整個世界都是數值語義
我們需要對我們的代碼做的變更就是 現在家庭是可變化的了
因爲我們改變了家庭的恆溫器的溫度
對 那是家庭、恆溫器的一個變異溫度的一個變異
好的 現在就到了一個非常重要的地方
因爲Swift的不變性工作模型數值語義在Swift中
運行的天衣無縫
如果在Swift中有一個“let”那麼它就是數值類型
這意味着當某個東西損壞了你的進程的內存時
這個值不會很快發生改變
這是一個健壯的語句
它意味着推論出“let”的事情非常容易
不過我們仍然允許有變異
你可使用var 說這個變量是能變的
對於我們的算法來說 這就非常有用
注意這個變更是非常本地的
我可以變更這個變量但是除非我告訴它
除非我在其它地方做出改變否則它是不會影響到
我的項目中的其它地方的
這樣就有了這個非常漂亮的受控易變性
其它地方有了可靠的保證
這裏有趣的一件事是當你使用數值類型、把它們
傳遞到線程邊界時你就可以避免這些類型
出現競態條件
我創建數字
把它們傳遞給某些會異步處理
事情的進程
我本地改變數字 然後再來一次
有了一個引用語義陣列這是一個競態條件
有時候 它會把你吹炸
有了數值語義 你每次都能得到復件
每次都能得到邏輯復件
因此 就沒有競態條件
它們不會同時到達相同的陣列
好的這個聽起來像一個性能問題 不是嗎？
每次我們通過一個參數傳遞數字時我們就會進行一次拷貝
好的 關於數值語義另外重要的一點是
複製很“廉價”
這裏的“廉價”我的意思是時間常數“廉價”
我們從基礎開始構建這個app
當你有基本類型時
那些低層次的東西 整數、兩倍數、浮點數等等
複製它們很“廉價”
你複製的只是幾個字節
除非是在處理器中進行復制的
你就可以用兩倍數、整數等等構建結構
就像CG點是由兩個CG浮點數構建的一樣
任何這種結構 枚舉或者元組
它們的字段數量是固定的在那裏複製每個東西
都是時間常數的
因此複製整個東西也是時間常數的
好的
對於定長的東西來說 這很棒
那麼對於可擴展的東西來說字符串、陣列、字典
又是怎樣呢？
我們在Swift中處理這些東西的方式是“寫入時複製”
這樣就可以讓複製很“廉價”
就是一些固定數量的引用計數操作來對“寫入時複製”
值進行復制
當你進行改變時 你有了一個var
然後你就可以變更它我們也就製作一份副本
並且在其上工作
因此你就是背後分享
但並不是邏輯分享
從邏輯上來說 這些仍然是不同的值
這樣你的數值語義的性能特徵
就很棒 編程模型也很棒
我們非常喜歡數值語義編程模型
從邏輯上說 不同的變量始終是不同的
你想讓它是本地控制時 就有變異概念
一個有效的變異
但是你還有這些嚴格的“let”保證
意味着它不會在其它地方改變
復件很“廉價”我們就可以一起工作
好的 我想交給我的同事
比爾·達德利他會談談數值類型和實踐
謝謝 道格 大家好
剛纔道格已經給我們講了數值類型的工作原理
它們如何與引用語義進行對比
我們來談談使用數值類型構建一個真實的實例
我們要做的就是把一個實例組織在一起
然後我們通過幾個不同的值、一個圈和一個多邊形
構建一個簡單的圖表
讓我們從圓開始吧
這是圓心 這是半徑
都是取自標準庫的幾個
數值類型
當然了我們想要實現相同運算符
equals相等操作符
我們只需要對比這些類型就可以實現
同樣地因爲它們是內置於標準庫的
我們只需要把它們用起來就行這是因爲我們用的是取自庫的
簡單類型來構建
下一個是多邊形
它有一個角落陣列
每個角落都是一個另一個CG點同樣地
這些CG點也是數值類型
因此我們的陣列也是一個數值類型
我們的比較也很直接
只要在那使用equals相等操作符
確保我們實現了“相等”操作符即可
現在我們要做的就是把這些類型放入我們的圖表
把多邊形和圓都放進去
製作一個圓的陣列也很直接
製作一個多邊形的陣列 同樣也很直接
因此我們可以製作任何類型的陣列
我們要做的 就是製作一個兩者都包含的陣列
在Swift中這樣做的機制是使用一項協議
我們會創建一個叫做Drawable的協議
我們的子類型都會實施
那個協議 然後我們把它們放到
我們的圖表中的一個陣列中
“Swift中面向協議編程”這場會議中有很多信息
今天3:30會再次召開
若你還沒有看過的話
我強烈建議你們去看看
或者看看視頻
這是我們的Drawable協議
很直接 也很簡單上面有一種方法即“繪製”
當然了 我們想在我們的兩種類型上實施它
我們會創建一個多邊形擴展
實施那個繪製方法 然後它會調用
Core Graphics繪製多邊形
圓也是 同樣的情況
那麼我們要做的就是調用Core Graphics
構建圓的表示
現在再回到我們的圖表
得到了這個可繪製的被調項目陣列
我們需要創建一個方法 添加項目
它被標記爲了“變異的”因爲那會改變它自身
我們要實現這個繪製方式來對那個項目列表進行
簡單迭代並且調用列表上的
每個項目的繪製方式
我們來以圖解的方式 看看它
我們創建一個圖表稱之爲doc
我們創建一個多邊形然後把它添加到陣列上
我們再創建一個圓也把它添加到陣列上
現在我們的陣列內有了兩項可繪製物
注意它們的類型是不同的
當我們再創建一個文檔並且說doc2等於doc
得到了一個邏輯上不同的、全新的實例
從邏輯上說它和第一個實例是分開的
我現在可以返回doc2進行更改 當我進行更改時
當然了它對doc沒有影響
我把那個圓改成一個多邊形
陣列有數值語義即使集合是
即使是不純一的
那麼它的內部就有了多邊形那個陣列內的圓
也是一個值
當然了 我們想把我們的圖表的結構做成“相等”的
因此我們把協議實現
我們看到的這是一個非常直接的
實現
但 如果我們那樣做編輯器就會說
“等等方程式兩邊的兩個值 我沒有equals相等操作符”
對於在該方程式的兩邊這兩個值
再說一次 我推薦你們去看面向協議的編程
我們在那裏講了它的所有的原理細節
我們本次會議專注的是數值語義
可繪製物有個叫做“繪製”的單一方法
圖表也有一個叫做“繪製”的方法
把我們的圖表變成一個可繪製物
我們只需要把那個聲明加到它上面
現在我們的圖表像鴨子一樣嘎嘎叫 那它就是一隻鴨子了
那麼接下來的就非常有趣了
我可以創建一個新的圖表並把它添加到我現有的圖表
那裏有了三種不同的類型
不過它們都包含在那個陣列中
它是圖表的一個新的實例
但是我還可以再進一步
把那個文檔加到陣列中
如果這些是引用語義
我們來看看繪製方法
如果這個是引用語義
它就會無限遞歸
因爲當我在我的圖表上調用“繪製”時 它就會遍歷
項目列表並且在列表上找到它自己
然後就會再次調用“繪製”出現無限遞歸
不過我們用到是值
因爲它是一個值添加到我的圖表的
一個完全分開的、不同的實例
而不是doc
因此不會出現無限遞歸
我剛剛繪製了兩個多邊形以及兩個圓
既然已經講過了 純粹由數值類型構建
一個對象樹
我們來講怎樣混淆數值類型和引用類型
在Objective-C中
你已經習慣了始終把原始數據類型放到你的引用類型中
在Objective-C中就是這樣構建東西的
但是另一方面這會產生一些有趣的問題
我們必須仔細考慮這些問題
如果我們構建一個數值類型我們就想要確保
那個數值類型維持自身的數值語義
哪怕它裏面有一個引用
如果我們要那麼做
我們就必須仔細考慮那個問題
我們該怎樣處理這個事實：
它裏面有一個引用 兩個不同的值可能
指向了同一件事？
我們就必須解決那個問題
我們要仔細考慮的
另一件事是：它會對等式產生什麼樣的影響？
讓我們從一個帶有不可變類的
簡單例子開始 UIImage
創建一個要成爲 可繪製物的圖片結構
它對UIImage有一個引用
我們用舊金山的這幅美麗的
照片來創建一個實例
如果我們再創建一個“圖片2”現在
“圖片”和“圖片2”就都指向了同一個對象
如果你看這個你會想比爾騙我們了
這肯定會出問題 就像那個
溫度一樣
但是這不是因爲UIImage是不可變的
因此我們不用擔心“圖片2”會改變位於它下方的
“圖片”
不要擔心第一個圖片會猝不及防受到
改變的影響
我們想要確保我們實現這個等式
你可能會看到這個然後想“沒問題”
我要使用三元組相等操作符
它會對比引用看看
那些引用是否相同
對於這個例子來說當然沒問題 不過我們還必須
認真考慮下 當我們使用
同樣的底層位圖創建兩個UI圖片時會發生什麼？
我們想讓它們也相等、同等 在這個例子中
因爲我們是在對比引用 它們就不會相等
因此 說這兩個圖片
不相同 就錯了
想要使用我們從UIImage上的NSObject繼承“是等效方法”
來進行對比
這樣不管是否在相同的對象上
我們都可以確信引用類型獲得正確的回覆
我們來談談如何使用可變的對象
在這裏有一個BezierPath
它也會實現“可繪製物”
但是整個實現是由這個可變的
引用類型UIBezierPath構成的
在這個讀取實例中當我們進行“Is Empty”時
一起都正常
沒有進行任何改變因爲不會和任何其它的
實例混雜到一起
但是下面的這個我們有這個“向點添加線”方法
如果我們有兩個BezierPaths指向這個方法
它就會造成問題
我們在那裏並沒有“改變中”這個關鍵字
那是一個符號 表明我們知道我們正在進行改變
“向點添加線”在那裏但是編譯器並沒有對着
大喊大叫 告訴我們這一點這是因爲路徑是一種引用類型
我們很快會再看看它
如果有兩個BezierPath實例並且都通過這個改變
指向了同一個UIBezierPath實例
如果我做出改變 那麼
它就會讓另一個實例措手不及
這種情況可不妙
我們就沒法維持數值語義
我們需要修復它
我們修復的方式是使用“寫入時複製”
我們需要確保在我們寫入那個路徑之前
已經製作了它的一個副本
因此要向我們的BezierPath中
引入一些新事物
首先我們想要讓我們的路徑實例是私有的
其次想要實現這個讀取計算路徑屬性
並從那裏返回我們的私有實例變量
我們也想爲寫入計算屬性
創建一個路徑路徑標記爲“改變中”
那麼它就會 事實上改變狀態
我們把它標記爲“改變中”把路徑設爲與我們現有路徑的
新副本等同
現在我們有了一個讀取副本我們還可以獲得一個寫入副本
那麼我們改變我們的實現來反映這一點
在“Is Empty”方法中我們會調用我們的讀取副本
在下面的改變方法那裏
我們會調用寫入路徑
關於這個 很棒的一點是編譯器會對我們大喊大叫
說：“寫入屬性路徑標記爲了
改變中 這個方法沒有
標記爲改變中 ”
我們就從編譯器得到了幫助在我們搞錯時
幫助我們弄明白
在一個圖表中瀏覽下它 瀏覽下路徑
我通過說“Path To”又創建了一個
當然 我可以讀取它
沒問題 當我對它寫入時
建了另一個BezierPath實例
路徑二還是不明白已經發生了一次變異
因此我不會在路徑二後面引入一些意料之外的變異
現在我們來談談如何在實踐中使用這些東西
這裏我們有我們的多邊形類型 我們要通過
添加一個會返回給我們對那個多邊形進行描述的
BezierPath的方法對它進行擴展
我們創建BezierPath通過點進行迭代
向這些點中添加線二
現在缺點就是那個“添加線到點”方法
會複製每次調用
因此它的表現可能不那麼好
因此我們應該創建一個UIBezierPath實例
然後就地改變那個可變的引用類型
當我們弄完後用那個BezierPath創建一個
數值類型新的實例且返回那個BezierPath
這樣生成UIBezierPath副本
或者生成個UIBezierPath實例而不是生成多個副本、實例
在Swift中 有一個很棒的特性
可以通過它知道對象是否被惟一地引用
這樣我們就可以利用它
這個結構和BezierPath中看到的類似
我們可以利用我們有這個惟一引用屬性這一事實
我們就可以肯定
有些東西是被惟一引用的
如果我們知道那個引用類型是惟一引用
我們就可以避免製作副本
標準庫會自始至終使用那個特性
使用那個特性也可以進行很多很棒的性能優化
這樣酒吧數值類型以及引用類型混合了
儘管事實是通過使用“寫入時複製”
你在可變類型上有這些引用你也想要確保你可以維持數值語義
現在我想看一個非常酷的特性  我們現在能做的
就是把一個模型類型當做一個值來實現
然後實現一個撤銷棧
那麼我要創建一個圖表以及一個圖表陣列
有了各個變異 我會把我的doc添加到我的圖表陣列中
那麼我創建並附加它
我添加了一個多邊形並且把它附加到了撤銷棧
我創建了一個圈並且把它附加到了撤銷棧
現在在我的撤銷棧裏我有三個不同的圖表實例
它們沒有引用同一件事情
這些是三個不同的值
因此可用它來實現一些很酷的特性
假設這個位於一個app內我有一個“歷史”按鈕
我點擊這個“歷史”按鈕我得到了返回到
我的撤銷棧的我的圖表的全部狀態列表
我就可以允許用戶點擊其它東西
並且及時返回
我就不用在某個陣列中保存如何撤銷添加那個屬性
或者撤銷添加其它東西
它會直接返回上一個實例
也就是剛剛繪製的那個實例
這是一項超級強大的特性 事實上
Photoshop大量使用這一特性以便實現他們的各個
與歷史相關的東西
當在Photoshop打開一幅圖片
幕後發生了什麼？
Photoshop會對那個照片分層、切塊
不論照片有多大切分成一堆小的圖塊
每個這種圖塊都是數值 含圖塊的文檔
同樣也是一個數值
如果我進行改變比如說把這個人的襯衫
從紫色變成綠色在那個圖表的兩個實例中唯一
被複制的就是包含了這個人的襯衫的
圖塊
這樣即使我有兩個不同的文檔
舊狀態和新狀態 我唯一需要當成那個
結果來使用的新數據
就是包含了這個人的襯衫的圖塊
小結一下 我們講了數值類型
講了它給你們的應用程序帶來的很棒的特性
把它和引用類型做了對比向你們演示了數值類似
是如何修復某些問題的
期間我們演示了一個實例讓你們看了一些你們可以
通過使用數值類型添加到你們的應用程序上的
很酷的特性
我迫不及待想看到這些東西在你們的app中是如何發揮作用的
有一些相關的會議 你可以觀看視頻
或者如果你有時間的話 今天3:30
有關於面向協議編程的會議
如果需要更多信息你總可以給斯蒂芬發郵件
或者訪問我們的論壇資料中也有一些
很棒的信息
謝謝 祝你們在蘋果全球開發者大會的剩餘部分愉快