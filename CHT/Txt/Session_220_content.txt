Core Data 新中的內容
下午好！歡迎收看第 220 課
我叫瑞西 衛爾瑪稍後斯克特 佩瑞將跟我一道
爲您展示今年Core Data 中的新內容
不過 在我們進入正題之前
我想給大家講一下什麼是Core Data
現在 你們中的很多已經開發了這些很棒的有漂亮 UI 的 app
你們已經把它與從外部數據源獲取的
或者來自於提供給你們的
資源框架的數據結合起來
那麼當你處理那些對象的時候
你將創建一個複雜的圖形並將所有的那些更改向UI傳遞
然後當你的用戶對 UI 做出更改的時候
您將把所有的那些改動推送回到您的對象圖
並推送回到您的數據源
那麼 Core Data讓這個變得容易
Core Data將爲您管理對象圖
簡單告訴我們一點關於您的 Cocoa 模型
以及對象模型編輯器的信息告訴我們一點
關於您的對象和它們的屬性的信息
以及它們的相互關係而我們將負責剩下的工作
而且我們也將在您選擇的後臺維持它
不管它是 SQLite或是您自己設定的存儲方式
於是 隨着你不斷導入對象你的各種關係將發生改變
而Core Data將爲您維護這些關係
因此如果您在您的對象模型設置任何通用刪除規則
我們將刪除一個對象
並將按照你的定義根據規則統一刪除
在你的對象圖裏找到對象也是特別容易的
只須使用一個NSFetchRequest
並賦給它一個 predicate
來找到你在尋找的對象
我們將爲你扎到它們
批處理也很方便
這讓你從讀取請求得到的數據集裏面
僅提取一小部分對象
讓您在檢查數據集的時候需要處理的數據變少
此外NSFetchRequest 的
另一個特性是關係的預讀取
告訴我們一個需要讀取的對象
我們會預讀取所有與其相關的對象所以當你遍歷那一關係的時候
你將仍然在內存中進行
然後你只須把所有這些綁定到 UI
你把一個NSFetchResultController
綁定到一個餐桌視圖就像我們這裏所做的一樣
而當我刪除蘋果醬時
我的 UI 會相應地更新
然後當我插入更多對象時我添加了香蕉麪包
我的 UI 也會相應更新
這些都爲你處理所有的關鍵視圖行爲
以及更改通知 Core Data都會爲你進行處理
抱歉
不過可能有一種情況
您的用戶正在主上下文操作一個對象
而在背景上下文也在導入同樣的新對象
而且可能正在更新目前用戶
正在操作的對象
這就引入了“多寫入者衝突”的概念
在 Core Data 中這裏它也爲您進行了處理
我們爲所有對象進行版本描述並讓您設定合併策略
如果您不捨得合併策略我們將在您將其存入上下文時
默認出錯
並提示您出現了衝突錯誤
讓您以自己認爲合適的方式處理衝突
或者您可以從我們已提供的策略中
選擇多個合併策略
不管它是在內存中還是在持久存儲中
不管是持久存儲優於內存還是相反
選擇最適合您的最適合您的特定情況的
一旦您選用了 Core Data你會有幾大好處
我要給特別大家講兩個
真正最大的好處
出色的內存可升級性以及積極的延遲加載
那是什麼意思呢？就是說我們僅當您在內存中
需要那些對象的時候我們才加載它們
採用Core Data會導致佔用空間的大幅減小
您需要維護的代碼減少 50 到 70%
讓您有更多的時間
開發您的 app 的新特性
然後您就可以加入
App Store中已在使用Core Data的
40多萬個 app 了
Core Data 的概述到此爲止
現在讓我們進入新內容
我們爲您準備的所有新的 API
首先讓我們從NSManagedObject
和一個新的屬性
hasPersistentChangedValues開始
以前您可能已經用過hasChanges
這是一個相當基礎的髒標誌如果你碰了這個對象
我們會將其標誌爲髒的 dirty
但是通過hasPersistentchangedValues
我們將確保對象的屬性
與持久存儲中的不同確保您不會有任何誤報
NSManagedObject的新特性還包括
objectIDsForRelationshipNamed
這個非常適合用於大型關係
因爲將不會在內存內將整個關係實體化
而是會將已經歸類的
一系列對象的ID返還給您
這讓您能夠以更小的規模檢查這些對象的ID
並且以處理您的更小的對象
讓我快速地爲您展示一個代碼示例
這裏是我的人物對象
而我請求它的關係對象ID“family”
這會給我全部關係然後我可以
去讀取這些關係每批 100 個
然後以每次100個的速度遍歷這些關係
這讓我把向內存的輸入維持在相當小的水平
而且易於管理
讓我們繼續往下講NSManagedObjectContext
和一個名爲refreshAllObjects的新方法
RefreshAllObjects所做的事情和你料想的完全一樣
它把您的上下文中的對象更新
但是保留未被保存的更改
而且與reseton the context不同的是
您對對象的引用仍然有效
因此 您不必重取任何引用
而它最適合用於打破可能已出現的循環引用
循環引用是當你遍歷一個雙向關係時
你陷入循環中
此外NSManagedObjectContext的新特性還包括：
對於那些在您的存儲中使用多個協調程序的朋友
MergeChangesFromRemoteContextSave
將從一個協調程序接收通知
並將其用於另一個協調程序的上下文
這讓您在您的上下文中有最新的行數據
而我們將爲您照看
所有必要的上下文
在 Core Data 中偶爾你會遇到某個特別的例外
而那對於開發者
將是非常容易識別的
那就是無法加載某個錯誤
爲什麼Core Data無法加載這個錯誤呢?
好了 正如我早些時候提到的在延遲加載對象方面
Core Data 是非常積極的您在內存中
將只有對象圖中的一部分而且當我們試圖遍歷一個關係時
我們將可以回到磁盤
並發現那個對象已經被刪除了
什麼是比遇到例外更好的事情？
有很多
我們已經在
NSManagedObjectContext上面
推出了一個新的屬性
它讓你能夠設置一些基礎的
faultingDelegatedAPI
目前
shouldDeleteInaccessibleFaults
默認爲 yes
如果我們遇到一個錯誤我們將把它標記爲deleted
而任何缺失的屬性都將是null或0
這讓您的app持續這一對象
並將其當作一個已被刪除的對象處理
您將不會再崩潰但是您將可以繼續下去
並且向用戶展示他們預期將會看到的東西
現在關於
NSPersistentStoreCoordinator
我們要介紹兩個新的 API
我們推出了這兩個新的API是因爲我們發現開發者
在如何清理他們的持久存儲方面存在問題
你們中的一些人做過這樣的事情
您已經經過或繞過Core Data API 層
而直接操作你的數據庫
不幸的是帶來了意想不到的後果
您可能讓壞卷描述符保持開放狀態
所以我們爲您提供了
destroyPersistentStoreAtURL
就像 addPersistent StoreAtURL一樣
你做出了同樣的選擇
而且你可以破壞那一持久存儲區
而我們將遵守所有的鎖定協議
並將所有相關文件清理出來放到您已選擇使用的
特定類型的存儲區
以那種同樣的方式
我們推出了replacePersistentStoreAtURL
這和破壞的模式類似而如果目標數據庫並不存在
我們將只須把它複製到位即可
一個大家都曾遇到的問題是副本
一個帶有副本的數據庫是無用的
你已經寫了大量的代碼
來確保你沒有副本
這裏 Core Data也可以幫你
首先讓我們看下爲了發現副本
你們可能已用過的常見模式
即“尋找或創建”模式
在這裏 如你所見我建立了一個讀取請求並且
我必須尋找一個特別的對象
看它是否存在然後才能創建它
如果它確實存在 我就更新它
不過這種模式可能是相當有風險的而且如果我有
來自於多個數據源的線程的話它可能導致多個副本
而Core Data今年已爲您提供了保護
只須告訴我們在一個實體內的哪些屬性應是唯一的
我們就將確保該實體的所有實例
都保持那一唯一屬性不管它是電子郵件 零部件編號
通用產品代碼 等等我們將確保它在
它在所有實例中都是唯一的
當唯一實例唯一約束條件
被用於對象創建後的未被修改的數值時
是最佳的
通常當你創建對象的時候這些唯一約束條件
應被一次性設定然後在對象存續期間永不更改
更改它們可能導致衝突
因爲您的唯一屬性可能會與
有同樣的唯一屬性的另一個對象衝突
那時候您就可以使用我們之前
在合併策略中講到的恢復方法
來解決那些問題
此外 任何從具有唯一約束條件的父實體
繼承的實體也將繼續那些約束條件
在上面的例子中您可以看出父實體有一個已被確認的
UUID約束條件作爲唯一約束條件
子實體已經添加了電子郵件
作爲對其唯一約束條件的補充
現在我想爲您快速展示一下
如何利用唯一約束條件
那麼這裏我們將使用食譜 app我們前些年一直在爲您展示
可以在開發者門戶將其下載
我們增加了一個新性能即右下方的 import 導入
這讓我可以導入任何我喜歡的
與蘋果相關的食譜
這裏我們回退你看到我增加了
所有我喜歡的蘋果食譜然而我的 UI 並不是非常直觀
用戶在點擊的時候
可能會懷疑哪裏出錯了
不幸的是他們已複製了他們的數據
這裏我們可以有很大的改善
讓我們回到 Xcode並看一下我們的對象模型
而這裏我們在設置我們的實體我將選擇一個食譜
而現在我這裏有了一個新選擇
就在右邊叫做 unique 唯一
這讓我指定那些屬性
對於這個特定實體是唯一的
在此例中我們將有源 ID 和永久性 ID
那麼現在當我運行這個食譜app時
我們將看到我有一個原始清單
我可以把它導入然後選擇我的蘋果食譜
但是我也缺乏耐心
沒看到任何 UI所以我不斷點擊
這次我們有了單一對象代表它們全部
不必尋找或創建任何副本任何代碼
您的唯一約束條件確保了您的唯一性
然而有了所有那些副本並不是理想的
刪掉副本可能需要做大量工作
這時候就要斯克特 佩瑞出場了
他將向我們展示我們對此能做些什麼
謝謝 瑞西！
那麼假如您已經有了一個app
而且您已經有了所有這些已被複制的數據
現在您必須把它們全部刪除
今天您必須要做的是將它們全部從內存中提取出來
抱歉 是從存儲中...一旦它們進入內存
你將它們標記以便刪除然後您必須將其
存儲到持久性存儲中如果您有很多對象
您將不得不一次又一次地刪除
以維持足夠低的內存佔用
讓您的 app 維持活躍狀態
若只是爲了將它們刪除而將對象加載到內存中
似乎有點愚蠢
今年我們已推出了一種新的 API
它的形式是NSBatchDeleteRequest
NSBatchDeleteRequest的工作原理
類似於NSBatchUpdateRequest
在於它直接在持久性存儲中發揮作用而無須向內存中加載任何對象
你可以使用NSFetchRequest的一個實例創建它
指定一個實體一個或更多的存儲
並使用predicate來源或限制來分割數據
以您希望的任何方式
批刪除請求會返回一個方框型
NSBatchDeletesResult
而你可以對請求進行配置
以便返回一個默認的成功或失敗
被刪除的對象的總數
或該方框中的對象的對象ID
這樣的做法有幾個限制
因爲對象都沒有被加載到內存中
更改並沒有別反映到上下文中
而且您的驗證規則都沒有被運行
各種關係將被酌情刪除或作廢
但是那是你得到的所有保證
也有“無對象通知”
我們認爲這對有大量副本的人們
將確實是有幫助的
現在我想爲大家展示它如何工作
那麼我這裏有同樣的食譜 app
而且帶有一份從我的經理那裏拷貝來的數據庫
他說他的一個孩子拿到了它
並且添加了大量的食譜比如數以千計
如果我們以舊的方法檢查它
那麼我們將只是用一個讀取請求
讀取我們想要刪除的所有對象
然後對它們全部進行迭代刪除它們
然後以我們設置的每批1000的規模
保存更改
如果您試着這麼做
我們可以在這裏的控制檯看到它會耗費一點時間
你可以看到我們在...
由於我們在進行以成千上萬計算的批處理
我們現在正在進行第一批現在仍在進行中
這會耗費一點時間我們將不會站在這裏等着它
如果我們在一個合適的點闖入我們可以強制停止app
並再次嘗試使用批刪除
讓我們把這些刪了
使用與我們之前使用的同樣的讀取請求
建立一個重複刪除請求然後我們
將選擇一個計數器resultType
以便我能夠看到我們做了些什麼
這裏我們將執行它
它的代碼少得多而且只有一個執行請求
沒有循環沒有與對象的互動
如果我們運行這段代碼
...我們將回到這裏
這裏你可以看到在查詢語句中編輯器
建立了一個觸發器它刪除了所有
需要被清理的關係我們也就完成了這點工作
回到下邊簡單地看一些食譜
那麼現在我們就可以應用這些唯一約束條件了
那就是NSBatchDeleteRequest
接下來我想談一下模型的版本控制model versioning
當我們創建新版本的食譜app時
爲了支持“導入”這一特性
我們不得不對食譜實體添加兩個屬性
來源以及外部 ID瑞西 早些時候給大家演示過了
在進行這個工作期間我們打開了模型
添加了兩個屬性然後構建並運行
我們立刻就遇到了錯誤
我突出顯示了最重要的部分
我們遇到了一個遷移問題因爲版本已經發生了變化
但是我忘記加入起初的源模型
因爲我們就是在它基礎上做出更改的
而爲了創建新模型而複製舊模型的模式
確實不方便
進行您的app的迭代
而如果您忘記將某個模型部署到運行該版本的客戶手中
那確實是危險的
這似乎就是自動的輕量級遷移爲您發揮作用的時候了
現在我們的 iOS 9和 OS X11
有模型緩存功能
不管你何時創建或遷移存儲
或者僅是在新的 iOS 上
打開較舊的模型用來創建它的受管理的對象模型
被緩存到存儲內並且當輕量級遷移任務
它們無法找到合適的源模型的時候
這可以作爲一種最後一搏的嘗試
有幾個限制
這隻適用於 SQLite 存儲
而且對重量級遷移
不提供緩存版本
如果您在進行重量級遷移那您就該讓您的版本準備就緒
因爲您需要知道您的遷移是來自何方 去往何處
瑞西 稍早時談到了我們添加的 API
而我現在想談的是一些變化
對於 iOS 9 和iOS X 1010
Core Data採用了您已經在
Objective-C中看到的所有語言特性
包括泛型和空值
我們也利用了一個調用的新屬性它讓向下轉換變得容易一些
您在其他講座裏面可能沒有看到
但這對Core Data來說確實是方便的
因爲如果你正在與一個對象類型ID互動
您可以將其向下轉換到甚至完全不適合的類型
你可以爲某個類型設置屬性
但是它只能被向下轉換到該種類型的子類型
這將會在編譯器上爲您的代碼增加很多安全性
因爲當一個緩存似乎毫無意義時
它會限制發出警報
爲了使用泛型已生成的子類也已被更新
以便滿足大量的關係以及空值的需求
而且我們已經對子類的生成機制
做出了一些其他的更改
在 Xcode 6 中您會有一個執行文件
和一個頭文件用於使用同時包含Core Data聲明
和放置您的所有代碼的空位的Objective-C
它被用過之後就被扔掉了
但是如果你更改了自己的版本
更新日期就會變得有些不方便
因此在 Xcode 7 中我們增加了一個新的文件
這個文件是一個擴展或類別
取決於頭文件中
包含所有你熟悉的聲明的語言
那麼現在 頭文件和執行文件是屬於你自己的
不管你何時更新模型你所需做的就是更新這個文件
關於變化就說那麼多
我想談一下我們棄用的東西
我們將在 iOs9 和OS 1010 中
去掉confinementConcurrency
它已經被標爲“棄用”我們將在以後去掉它
因爲對於新的受管理的對象上下文
Confinement是默認行爲因此我們也已經將其棄用
因此未來您將使用init concurrencyType
爲您的上下文使用
專用隊列或主隊列
如果您已經
進行到了區塊 API這確實是一個不錯的主義
封裝操作大大簡化了您對
自己的模型代碼的推演而對CoreData的併發性調試支持
也增強了很多
我強烈建議查看在線文稿
今年 Core Data指南已被徹底更新
而 亞當·斯威夫特 也介紹了區塊 API
他在 WWDC 2011 中的
《Core Data on iOS中的新內容》
講得確實不錯
最後我想談一下性能
隨着時間推移我們開始爲模型增加屬性
由於這些年對我們的app不離不棄您的用戶攜帶的數據量在增大
而我們試圖查詢和顯示數據的方式
也在變得更加有趣 更加先進
我們的 app 也在維持很快的速度
但是您怎樣避免突然出現性能問題呢？
在開發過程中您處理的是
已知的可能較小的數據集
比您的客戶將要處理的要小
而模擬器又比僅僅維持設備運行所需快得多
儘管它對開發非常有幫助
用戶將會使用帶有生產數據的設備
幸運的是我們提供一些工具
讓您發現能夠表明性能問題的模式
因此在它們在您的客戶手裏成爲問題之前
您就可以解決它們
我想講三個需要注意的事情
首先是關係錯誤
這是 Core Data 工具
我們剛剛運行了食譜 app
在緩存缺失的工具項目下我們立刻看見
我們在三個想要顯示的對象上的緩存丟失了
如果我們查看中間的那一列我們會看到它們的食譜類型
而現在你還記得我們今年開發這個食譜 app 時
我們對其進行了更新以便讓主列表視圖
在顯示食譜本身的同時顯示食譜的類型
但是我們從未更改讀取請求
我們可以通過向我們用來查看
NSFetchResultsController的
查詢命令增加一個
relationshipKeypathsForPrefetching
來解決這個問題
現在 那些-那第一組
丟失的緩存將不再是個問題
如果我們回到同樣的工具
並且在稍後時再看下app裏面
我們可以看到當我們查看一個食譜的詳情時
我們也引發了幾個
對數據庫的查詢
這是因爲詳情查詢控制器從列表獲得模型對象
然後在詳細視圖裏面我們顯示
那個食譜中的所有原料
我們不能使用預讀取操作
因爲那樣我們將預讀取列表視圖中顯示的
所有食譜的所有原料
在詳細視圖中在控制器中
我們必須執行另一個讀取請求以便讓那些原料出現在內存中
現在我們已經將9個查詢變成1個
而我們仍能在食譜上使用這一關係
對其遍歷並且與它返回的數據集互動
因爲數據是在多個對象間共享的
最後如果我們看一下Core Data 工具視圖中的
讀取工具我們可以看到
第一個讀取請求花費的時間超過了我們的預期
它讀取了 85 個對象
當時我們只有 85 個對象
如果我們有3萬個對象的話就像我在的示範中演示的那樣
這將確實是糟糕app 甚至很可能不會啓動
在 Mac Pro上它花費了15 毫秒
那在 iOS 上會有大量的掉幀
那麼爲解決這個問題我們能做的就是增加
我們向讀取結果控制器輸入的讀取請求的批的大小
以便讓對象僅按顯示的需要從存儲讀取
我想展示的最後一項內容是...sequence blocking
如果您的讀取確實複雜且耗費大量時間
那麼您可以通過在程序上使用這個參數找到它們
而它會在您的讀取請求運行的同時
開始輸出相關數據
這種情況下我們有一個查詢而它所花費的時間
大約是十分之一秒
返回了 85 行結果
那是相當慢的
我們將看一下如何做得更好
如果我們向控制檯的更高處滾動
我們看到它輸出了我們正在使用的文件
我們可以使用SQLite連接那個文件
以便弄清楚正在發生的情況
如果我們把查詢粘貼進去
在 EXPLAIN QUERYPLAN之後
SQlite將告訴我們它將試圖做些什麼
以便用這個圖表來回答我們的查詢
這裏有幾個需要注意的事情
我們可以將其作爲衡量性能如何的度量指標
第一個是掃描表掃描表就是說SQLite
將觸探每行內容 檢查每行內容以完成查詢
而在食譜表裏面就像是稍早些時候一樣
我們有 3 萬行內容而我們將進行兩次檢查
因此那將不會太快
我們將進行考查 讓它變得更好
此外 我們還使用臨時 B 樹
在這一步 SQLite利用數據創建其自身的內存架構
以便實現排序或快速搜索
現在使用臨時 B-樹是因爲這裏的這個group by
如果我們更仔細地看一下
它是因爲外部 ID 中的來源
通過使用複合索引我們應能夠讓這個過程加快
在Core Data模型編輯器中我們可以在這裏的右側
添加一個複合索引
現在如果我們退出 SQLite重建我們的項目
執行遷移並且用SQLite連接到新的數據庫
我們會發現我們正在使用索引
使用索引意味着搜索將會很快
使用覆蓋索引更快這意味着那一步的結果
是按照下一步需要的自然順序排列的
因此我們已經完全清除了臨時 B 樹
但我們仍有這個掃描表
在這種情況下我們將匹配重複對象
這是我們在示範中使用的查詢目的是找到需要刪除的對象
它必須掃描整個表格它的速度是可以更快的
剩下的唯一要做的事是確保我們不碰主線程
在此例中我們將使用一個專用隊列上下文
但是如果您打算創建某些複合數據
以便向用戶展示
您可能希望使用這個同步讀取請求
它將在主線程工作的時候離開主線程
然後當得到結果的時候再返回
那麼這些就是在您的 app 中需要留意的三種主要模式
它們讓您能夠在性能問題
真正成爲問題之前解決它們
關於今年CoreData中的新內容就講到這裏
如果您發現任何問題請將其提交
對立刻重新寫出的示例app代碼有一個獎勵
它的錯誤會最先得到修復
但是我們也有興趣聽到
你們希望在Core Data中看到的東西
功能上的要求 改善方面的想法而如我所言
今年的文稿指南已全部經過修改因此如果您發現任何相關問題
我們也將樂於瞭解
如需更多信息請訪問開發者門戶
我們的文稿以及示例代碼
您可以在開發者論壇或通過 DTS 獲得支持
感謝您的蒞臨！