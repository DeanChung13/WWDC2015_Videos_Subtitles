Metal性能優化技術
早上好 
歡迎來到Metal性能優化技術
我是菲利普·班尼特 來自GPU軟件性能團隊 
我們的特別嘉賓  
來自GPU軟件開發者技術團隊的塞爾哈特·特欽
將爲我們展示一個非常棒的新工具  
對你的Metal app進行配置我相信你會喜歡這個工具的
到目前爲止WWDC上的Metal
在Metal Part 1新特性介紹會上
討論了iOS 9和OS X ElCapitan上Metal的新特性
在Metal Part 2新特性介紹會上
我們會介紹兩個新架構 
MetalKit和Metal性能着色器
讓我們更容易開發Metal app
在最後部分  
我們將回顧有什麼工具適合調試和分析Metalapp
我們也將探討一些關於從Metal app中
獲得最佳性能的最優方法
我們來看看工具
Metal調試和分析工具
若你已經在iOS上做Metal app開發 
你應該對Xcode 
以及配套Metal工具很熟悉了
現在 我們將快速看一下
框架調試程序
這裏是Metal app中一個單幀捕獲 
左邊是一個框架導航器 
顯示所有存在於框架內的
狀態和Draw調用
渲染編碼器命令緩衝器分組 
如果你正在使用調試標籤  
那麼調試標籤也會對它們進行分組
是渲染attachment視圖 
顯示除任何深度和網板attachment外
與現有渲染pass有關的所有color attachment
它顯示當前Draw調用的框架高亮區
這讓你可以很便利地操縱你的框架 
接下來是資源檢查器  
你可以檢查app所用的所有資源  
從緩衝器到紋理到渲染attachment
你可以查看所有不同的格式  
分開位圖水平 立方形地圖  
TD陣列 這些特徵它都有
我們有狀態檢查器  
它可以檢查app上所有Metal對象的屬性 
繼續 我們有GPU報告  
用於測量現有框架上的每一幀 
並對CPU和GPU進行計時
此外 它也在框架中顯示  
消耗最大的渲染和計算編碼器
以幫助你縮小消耗最大的着色器 
和Draw調用的範圍
最後 我們有着色器分析器和編輯器 
這個工具很棒  
可用來調試和分析着色器  
因爲它可讓你在聯機中  
微調着色器並對他們重新編譯  
這樣你就無需對app重新編譯了
你或許已經知道了  
所有這些很棒的工具 
都可用來在OS X El Capitan試Metal app
工具能夠很好協助Xcode的使用
它可以讓你在整個系統中分析app性能  
現在 你也可以使用 
類似Metal系統尋蹤工具的方法
分析Metal的性能
這是iOS 9的一個最新工具
它可讓你在CPU和GPU中
分析Metal app
我們來看一下
我們從分析應用中的Metal API使用開始  
然後是驅動程序 再到GPU 
在GPU你可以看到單獨處理階段 
verse X片段 隨機計算  
然後到真實的顯示器硬件
現在 塞爾哈特·特欽將爲我們演示
這個很棒的新工具  
有請他上臺
謝謝你 菲利普 大家好
今天我想爲大家展示一個非常酷的東西 
Metal系統尋蹤
Metal系統尋蹤是最新的Metal開發工具
Metal系統尋蹤是Metal iOS app上
一款性能分析和追蹤工具  
是整套工具的一部分 
它讓你可以隨時掌握應用的全系統概述  
在顯卡上 它也可讓你獲得細分到
微秒的細節信息
我必須強調一下 它很重要 
它是首次出現在我們的平臺上的 
幸虧有了Xcode 7 和 iOS 9
言歸正傳 我們繼續 來嘗試一下
我將啓動工具  
我們在模板選擇器上
你可以看到這裏有個新的模板標誌  
Metal系統尋蹤Metal標誌
我將進行選擇
對工具很熟悉的人
知道我剛用它當中的四個工具創建了一個新文件  
在時間軸的左手邊可以看到這個文件 
我們來快速瀏覽一下這些工具  
和在時間軸中顯示的數據
我們繼續在iPad中選擇Metal app 
作爲目標app和開始記錄 
好了
現在Metal 系統尋蹤是一款工具內的記錄工具 
這個工具叫Windowed Mode
本質上說 它捕捉軌道 形成環形緩衝區
這可讓你隨時進行記錄 
重要的是 在你發現需要調查的問題時  
可以停止記錄
這時候
工具將收集所有已經收集的追蹤數據處理一會兒 
以一個時間軸作爲結束 時間軸看起來像這樣
這裏有很多東西正在運作  
放大一下 可以看得更清楚些
控制選擇鍵 選擇一個時間軸裏  
我想要放大的  
感興趣的區域
我可以通過追蹤器手勢操縱時間軸  
兩個手指滑動到滾動和收縮 以進行縮放 
你可以看到 在我進一步放大時  
我可以在時間軸裏看到更多的細節 
所以 在這裏 我們看什麼呢？
基本上 我們看到是  
Metal應用圖形處理過程中
所有圖層集合中
圖形深層信息
時間軸裏不同的顏色
代表每個框架不同的工作量
磁道本身相當的靈敏 
這裏的每個盒子代表每個軌道的相關開始時間  
結束時間和所用時間 
從頭開始 然後往下一直處理  
我們使用Metal框架的應用
接下來 我們有顯卡驅動 它處理你的命令緩衝器
如果你有任何着色器編輯活動中等框架  
它同樣也會在軌道中體現 
這由GPU硬件軌道進行跟蹤  
顯示的是在GPU中
執行渲染和計算指令
最後 我們有顯示面軌道 
基本上 這就是在設備上顯示的框架 
好了
在這裏你可以看到的其他東西是這些標籤 
這邊的這兩個標籤陰影bufferG buffer和lighting
是我用編碼器標籤的屬性
分配到Metal代碼中的編輯器裏的
這些標籤帶着與它們相關的工作負荷 
沿着傳遞路徑傳送  
這使得Metal系統尋蹤中
追蹤場景渲染pass
非常簡單
我強烈建議你充分地使用它 
有些東西太小 無法安裝標籤  
你可以將鼠標懸停在尺子上就可以看到
一個工具提示 同時顯示標籤和持續時間 
基本上 這裏的軌道順序映射 
Metal指令沿着顯卡
傳遞路徑運作的順序
讓我們繼續跟隨命令緩衝器 沿着管道向下
在軌道頂端 我可以看到我的應用使用的是
Metal命令緩衝器和編碼器
尤其是這裏 我看到的是命令緩衝器
和渲染計算編碼器的
創建時間和提交時間
頂端有命令緩衝器  
底部有相關的編碼器 這個編碼器是 
由命令緩衝器直接嵌入其中而創建
現在 注意這個箭頭 箭頭在進入下個軌道
命令緩衝器的提交時間上 
在Metal系統尋蹤中  
這些箭頭代表
不同水平傳遞路徑間的依賴性 
例如 當提交了命令緩衝器  
它的下一站是圖形顯示器驅動  
如果將其可以放大 就會看到更多信息 
看看我們獲取到到了多少信息
它真的真的很快 CPU仍在處理
幾乎沒有佔用多少內存
同樣的 一旦編碼器處理完畢  
我就可以跟隨這些箭頭了
這些編碼器將被提交到GPU軌道
用同樣的方式跟隨箭頭  
可以看到GPU正在處理我的編碼器
這個GPU軌道被分成三個不同線路 
一個是vertex處理  
一個是碎片 一個是計算
比如說 我可以看到陰影緩衝途徑的
陰影緩衝渲染代碼  
它正在仔細查看它的vertex處理階段  
然後移到碎片階段 這個階段剛好
和G buffer和lighting 階段重疊
這些東西很好
這裏有個簡要的信息vertex碎片不只是
計算着色器處理時間 同樣也計算處理成本
比如說 我們正在iOS上運行  
它是一個圖塊類延緩體系結構 
所以vertex處理成本也將 
包含圖塊成本 這些需要記住
最後 一旦框架完成渲染 
表面也將在顯示器中結束 
這點顯示在在底部的軌道中
基本上 它顯示框架進入顯示器的時間
以及在裏面呆了多長時間
在它下面 有同步軌道 
顯示的是被與個別同步事件
相應的峯值分開的同步間隔
最後 在頂部有細節視圖
細節視圖和你在
其他工具看到的類似
它在選擇的工具使用基礎上 
提供環境細節
比如說現在 
我選擇了Metal應用工具 
就可以擴大這個 看看所有的框架 
所有的命令緩衝器 
和與有關層級的編碼器
如果你想看精確定時 這個軌道就很有用
若我轉到編碼器清單 
精確創建提交時間
或進程的起始位置
非常有用
酷！這裏的時間軸
對應這圖形管道
這是一個非常強大的工具
iOS 9和Metal中是首次出現
所以要怎麼用 才能解決你的問題呢？
或有問題的app是什麼樣的？
繼續 我將打開一個不同的軌道 
爲你進行展示
等下菲利普將爲你
詳細講解Metal性能
以及如何使用它解決你的問題 
我將簡要講講工具的
工作流程和一些小竅門
首要的是你需要關心
你的CPU和GPU並行
你可以看到 我打開的標有 
Problem Run標籤的軌道 
比我們上一個軌道要稀疏
因爲我們有不少同步點 在這些點裏 
事實上 CPU正在等待GPU
你需要確保將它消除掉 
同樣的 需要尋找另一個有用的東西 
就是你在時間軸裏看到的模式
這些框架都是同一場景的一部分 
所以它們的時間局部性很高
任何你看到的分歧 都可能指向一個問題 
你應該進行調查
另一個重要的東西是顯示面軌道
理論上 若幀速率目標是60幀每秒 
這些面將在顯示上停留
一個單一的VSync間隔
所以我們可以看到每VSync間隔 
顯示面就會被交換
比如這個特別的框架 停留了三個間隔 
所以我們以20 fps進行運行 
另一個非常有用的東西是着色器編輯軌道 
不管着色器編輯器何時在軌道里開始生效 
它都直接爲你顯示相關信息 
需要特別避免的一件事是 
將工作提交到着色器編輯器中等框架
因爲它將浪費你的CPU週期
這個週期你原本可以用在其他的事情上的
菲利普等下會詳細說到這點
最後 你應該儘早並經常進行分析
像這樣的工作流程將幫你解決問題
而且可讓解決問題變得簡單
Xcode通過爲創建產品提供一個配置文件啓動選項 
對你有所幫助
它將自動創建一個已安裝
在設備上的app的發佈版本 
啓動一個按照你選擇模板運行的工具
好了 這是Metal系統尋蹤
適合所有支持Metal的iOS設備
你可以試一下我們期待你的反饋和建議
現在有請菲利普上臺 
他將爲我們展示一些主要的Metal性能 
以及如何使用工具對他們進行鑑別謝謝
謝謝你 塞爾哈特 你的信息量很大
我們會講到前面提到的Metal性能
一些最優方法 我們也將看看 
如何使用這些工具進行診斷
並遵循最優方法
讓我來介紹一下我們的app樣本 
更確切地說是app樣本的一個系統軌道 
我們馬上可以看到一些性能問題
首先 CPU和GPU之間沒有並行
那是非常強大的設備 
實現最大性能的唯一方式
是立即運行它們 然而 它們似乎正在等待什麼
你可以看到 CPU中處理框架之間
有大量的延遲
有一個異常的22毫秒
這裏不能有任何拖延 發生什麼了？ 
來看一下CPU實際活躍週期 
它超過了框架截止期限
我們希望每秒有60幀
所以所有的東西必須在16毫秒內解決我們已經超出時間 失效了
GPU方面看起來也不樂觀 
這是個漫長的拖延與CPU上的相稱 
因爲CPU花費了大量的時間卻沒做成任何事 
也無法爲下個框架排隊等候
此外活躍的GPU週期超過框架截止期限 
我們努力達到每秒60幀 
但是事實每秒只有20幀
我們可以做些什麼呢？
讓我們看看基礎的東西
首先檢查一下Metal設計和性能主要原則
在前面的狀態中它正在創建耗費資源的對象 
現在 在傳統app上 特別是在內容加載過程中將發生的
app編譯所有來自源的着色器 
着色器可能有數個 甚至上百個 
這是個相當耗時的操作
現在共享編譯才進行到一半 
因爲着色器需要全部編譯到
與各種使用狀態相結合的
GPU管道狀態中
所以一些app可能
試圖進行預熱
通常情況下 當着色器和狀態第一次 
在Draw call中使用時 就會出現設備編輯
這是個壞消息 想象一下 你有一個競賽遊戲 突然間 
你轉了個彎 添加了很多新對象 
幀速率也下降了
這真是的很糟糕
預熱所做的就是
你釋放大量
帶顯示狀態和不同着色器組合的W Draw調用 
這樣讓驅動程序可以進行編輯相關GPU管道狀態
所以當使用
組合狀態和着色器時 
所有的一切都準備好了 幀速率也不會下降了
在實際的渲染循環中 
它們是典型的狀態設置 
當你開始考慮做一些事情時 
或許你將做些Draw調用
所以Metal路徑就是事先移除資源消耗多的對象
着色器可以在脫機狀態下從源代碼進行編輯
它免去了不少的工作量
我們提前移到狀態定義
你定義你的狀態 
GPU管道狀態被編譯成
這些狀態對象
所以當你開始Draw調用時 
就沒有所謂的設備編輯 
所以也就不在需要警告了
它已經成爲歷史了
它們已經爲Draw調用備好渲染循環了 
許多Draw調用
基本上
Metal通過以下方式加速狀態定義
分離Draw命令裏消耗多的狀態確認和編輯 
從而允許你將其推出渲染循環
併爲真實的Draw調用
保持渲染循環
現在 這些資源消耗型狀態
被打包到不可變狀態對象中 
目的是一旦創建 就可以被重複使用
現在 回到app樣本 
你可以看到中等框架上有些渲染器編輯正在發生 
這裏我們大約浪費了一毫秒
根本沒用
倘若看一下Xcode的框架調試器 
看看在單個框架上發生的所有這些
看看所有的這些對象
都不是我們想要的
你應該看的是這些 
創建框架命令緩衝器
獲取drawable以及紋理
剩下的東西 就都是多餘的了
我們來說說這些消耗大的對象 
以及應該何時創建它們
我們從着色器庫開始
這些是你的編譯着色器庫
現在 你真正要做的是 在離線狀態下 對它們進行編譯
你可以使用Xcode 
項目上任何Metal源文件
都將被入默認庫
你的app或許有它自己的自定義目錄管道 
你或許並不是必需使用這個方法
因此 我們提供了命令行工具 
它可以被合併到你的管道中
如果在運行時間裏 
你免不了要從源裏編輯着色器
最好是進行異步創建
所以當你創建庫 同時 
你的app確切的說是調用線程 
可以繼續做其他事情 
一旦着色器庫創建完成 
你的app也會得到相關信息
需在你的app創建的首個對象
是設備和命令隊列
這些代表着你將使用的GPU 
以及安排好的命令緩衝器的順序
現在 正如我們所說的 你想要
在app初始化過程中 創建這些 
因爲創建它們消耗太大 
你想讓它們可以在app的使用週期裏被重複使用
而且當然你想爲每個使用的GPU都創建一個
接下來是很有趣的東西 渲染
和計算管道狀態 
它們壓縮了所有的可編程GPU管道狀態 
因此它準備了所有的描述符vertex格式器腳本 
渲染緩衝器格式 
並把它們編譯成真實的原管道狀態
現在 因爲這是個消耗多的操作 
你應該在你加載內容時 創建這些管道對象 
而且它們應該可以被不斷循環使用
現在 因爲有了這些庫 
你也可以用這些方法 
對它們進行異步創建
一旦創建完畢 
完成處理器將通知你的app
需要提到一點 除非你真的需要它們 
要不然就不要獲取反射數據了 
因爲這是個消耗很大的操作
接下來是深度網板和取樣器狀態
這些是GPU管道狀態固定功能 
在你加載內容時 
你應該和其他管道狀態一起對其進行創建
現在 你或許已經結束了許多深度網板
和樣品器狀態 但你無需擔憂 
因爲Metal實現將在內部
散列狀態 並創建大量副本 
所以 你無需擔憂
接下來我們有了GPU消耗的真實數據了
你獲得了紋理和緩衝器
再一次 你應該在加載內容時 
對其進行創建 並儘可能的重複使用 
因爲這是一項與配置
和釋放資源有關的消耗
乃至動態資源 你或許無法
提前將它們完全初始化但是你至少應該
創建優先存儲
我們很快就會講到這部分的詳細信息
現在簡要說一下 
所以 對於消耗大的狀態顯然應該提前創建 
它們是着色器庫 
可在離線的時候進行創建
設備和命令序列 在你初始化
app的時候進行創建
渲染和計算管道狀態 
在你加載內容的時候進行創建 
固定功能管道狀態 
深度網板和取樣器狀態 
也是在你加載內容時進行創建 
最後是app使用的紋理和緩衝器
我們繼續 在app示例中遵循
這些最優方法或許你還記得它是這樣的
曾有些着色器編輯每幀都會出現中間幀情況 
現在 我們什麼都沒有了
已經節約了大概CPU時間的一毫秒
開端不錯不過我們要看下
能否很快的做得更好
預先創建消耗多的狀態和對象 
並使它們可以被重複使用
特別是 在脫機狀態下編輯你的着色器源 
你想將渲染循環保持在它原本的樣子 
這是Draw調用 
擺脫了所有的對象創建 
對於那些你無法全部預先創建的資源該怎麼辦？
我們正在談論這些動態資源 
所以我們該對它們做什麼？我們該如何有效地創建並管理它們呢？
現在 通過動態資源 
我們來談談那些一經創建 
就可能被CPU修改很多次的資源
一個好的例子是緩衝器着色器常量 
以及一些東西 比如在CPU中產生的粒子系統 
所擁有的任何動態vertex和指示緩衝器  
除動態紋理外
或許你的app有一些紋理 
它在框架間的CPU上進行修改
理想的狀態是 如果可以
你會選擇將這些資源放在某處 
以方便CPU和GPU有效地使用
當你創建資源時 
你可以通過使用共享儲存模式選項進行操作
這在存儲器裏創建資源
資源由CPU和GPU共享
事實上 這是iOS上的默認儲存模式 
iOS設備已經統一存儲器架構 
所以相同的存儲器可在CPU和GPU之間進行共享
現在 關於這些共享資源的事情是 
CPU完全無法同步使用
它可以通過指示器自由地修改數據
事實上 對於GPU正在使用的數據
對CPU而言是毀滅性的的數據 
CPU很容易就可以對其進行干涉
我們想要避免這種情況
但我們應該怎麼做？
一個簡單的做法是爲資源配備一個單一緩衝器
在資源裏 我們有一個常量緩衝器
這個緩衝器在CPU裏進行更新 並隨後被GPU所消耗
現在 倘若CPU想要
修改常量緩衝器裏的任何數據 
它就必須等到GPU完成後 才能開始
唯一方法是 
它是否在等待命令緩衝器在命令緩衝器裏 
資源是調用於完成GPU進程
在這個示例中 我們使用等待至完成
所以我們空等着等於CPU也在空等着 
直到GPU完成處理 
CPU才能繼續並修改緩衝器
而緩衝器將在下個框架中被GPU消耗
這真的很不好 
因爲不僅CPU儲存了GPU也儲存了 
因爲CPU沒有時間爲下個框架操作排隊等候
這是在app示例中所發生的
CPU在空等等待GPU完成每個框架 
你引入了大量的存儲週期 
是的 CPU和GPU之間並沒有並行
顯然 你需要更好的方法 
你或許會冒險爲每個框架創建新緩衝器 
因爲你需要他們
但是正如我們前面所提到的 
這並不是一個好辦法 
因爲創建緩衝器
需要經常消耗
如果你有很多大的緩衝器他們會積累 
你不會真的想這麼做的
你應該做的是 使用一個緩衝器組合
這裏我們有三重緩衝組合 
裏面有三個緩衝器這些緩衝器是在CPU更新 
然後被GPU消耗掉的
爲什麼是三個？
我尤其要建議你限制
命令緩衝器數量 最多三個 
實際上 每個命令緩衝器有一個緩衝器
通過利用一個信號 
阻止CPU超過GPU太多 
我們可以確保在CPU上更新緩衝器仍是安全的
返回讀取第一個緩衝器時 
當GPU在處理過程中
與其拿一堆惱人的樣本代碼
我將示範的很棒的例子
是Metal UniformStreaming示例 
它將展示如何做到這點
若你感興趣 我建議你隨後檢驗一下它
回到app示例 你應該還記得 
在CPU上 每個框架之間
有這些被削弱性能的權重
在使用一個緩衝組合更新動態數據後 
我們設法極大地減少
CPU處理和GPU處理之間的差距
我們還有些同步性問題 
但我們將只簡要地看一下
我們已經取得很大的進步 
總之 你想要緩衝
動態共享資源 
因爲它是在框架之間更新這些的最有效的方式 
你通過使用我提到過的緩衝器和組確保安全
現在 我將講一些東西 
確切地說 實際上是一件
我不想提前做的事情 
那關係到你何時獲得你的appDrawable服務
Drawable外觀是領域裏app的窗口 
它是你的app渲染它的可視內容進去的東西 
這要麼是在顯示器上直接顯示 
要麼是組成管道的一部分
從Core AnimationMetal圖層檢索Drawable
但這些Drawable數量有限 因爲事實上 它們相當的大 
而我們既不想大量保存它們 
也不像在我們需要的時候對它們進行配置
所以這些Drawable非常有限 
而一旦它們在硬件中顯示了 
在顯示間隔
預先drawable 被放棄了
如果你集成實際的顯示硬件 
顯示管道的每個階段可能在任何點 
爲一個GPU爲Core Animation
在你的app裏抓取Drawable
你的app通過調用下個Drawable方法 
抓取了一個Drawable外觀
當調用Current RenderPass Descriptor時 
可以執行MetalKit 
一旦Drawable適用方法將只能返回 
若那時恰巧有個適用的可取值 
它將立即返回
很好 你可以使用框架 繼續做
然而 若沒有適用的app 
確切地說爲它調用 它將被封鎖直至 
至少下個顯示間隔正在等待一個Drawable
可能會很久
60幀每秒
我們在說16毫秒
真是一個壞消息
所以這就是樣本app所做的事情？
這就是執行中巨大差距的解釋？
我們來看看Xcode是怎麼說的
我們轉到框架導航器 
看看這裏的框架導航器
Xcode與陰影緩衝編碼器
之間似乎存在問題
這裏有個小警告
詳細看一下 
事實上 我們確實比實際需要的早
調用了下個Drawable方法
下個代碼提供了一些非常明智的建議 
應該在真正需要這個Drawable的時候 再調用它
所以這個是如何與樣本app相適應？
這裏 在樣本app中 我們有數個pass 
在陰影pass前的每個框架開始時獲得Drawable
這實在太早了因爲直到最後的pass 
我們纔將一切拖離屏幕 
直到我們渲染UI pass時我們才需要一個Drawable
所以獲取下個Drawable的最佳位置是
自然地剛好早於UI pass
我們繼續 做出改變 隨後將調用移到 
下個Drawable 
來看看問題是否被解決了
你已經看到了 是的 它做到了
我們移動第二個同步點 
現在在框架上的處理和在CPU上的處理之間再無任何拖延了
這是個巨大的改進 
建議很簡單 僅在你真的需要
Drawable的時候 再獲取它
這是在真的使用渲染pass之前
這將確保你隱藏任何長延時 
這些延時在沒有適用的Drawable時就會出現
你的app可以繼續做有用的工作 
知道真的需要一個Drawable時 
就會出現一個適用的
從這點來說 目前爲止 我們做得非常好
但是仍有改進的空間 
所以 爲什麼我們不看看GPU的效能
而不是降到非常低的水平？
試圖最優化着色器或改變紋理格式 
諸如此類的
爲什麼不看我是否可以提供一般的建議
就是這麼巧 這就是了這涉及到我們如何使用
Render Command Encoders
Render Command Encoders是用來 
爲單個渲染pass創建Draw命令的 
一個單一渲染pass在顏色獲得attachment的一個不動集 
以及深度和網板attachment上其作用 
一旦開始pass 就不能變動attachment了 
你可以改變作用在它們上面的行動 
比如深度網板狀態 
顏色蒙版和調配
這個值得記住
現在 在iOS設備GPU上 
尤其重要的渲染編碼器使用方式 
取決於它們的結構方式
它們是基於圖塊的延遲渲染器
每個Render Command Encoder
可產生2個GPU pass
首先 你有vertex階段 它在編碼器中
變換所有的幾何體 然後執行剪貼
着色 然後將所有的幾何體裝到
屏幕空間圖塊裏
緊接着是碎片階段 它通過決定
哪些對象是可見的
來處理所有的對象圖塊
然後只有可見像素才能被處理
所有的碎片處理髮生在
快速芯片圖塊緩衝器上
現在 在渲染結束時 
你只需存儲顏色緩衝器
你只是放棄了深度緩衝
甚至有時你有多個color attachment 
你也只需存儲其中一個
不在每個pass存儲圖塊數據 
你就節省了不少帶寬
你避免了寫出整個框架緩衝器
這對於性能來說很重要 
因爲它不必加載每個貼圖的數據
所以Xcode告訴了我們什麼？
它能否爲我們提供 -確切地說 
我提到每個編碼器相當於
一個vertex pass和一個碎片pass
這甚至在MT編碼器中也適用 
這個是相當重要的
這裏 事實上 我們有兩個G buffer編碼器 
而第一個似乎沒繪製任何東西 
我猜這是誤操作造成的 
事實上 它對性能還是有影響的
但是看下app的系統軌道就可以知道
由於空編碼器在GPU中消耗了2.8毫秒 
由此推測它剛爲我們所有的attachment
三個顏色和兩個深度
和網板寫出了清晰的顏色
這個特殊框架GPU處理時間 
總計是22毫秒
現在 如果我們移除MT編碼器 
這可以很容易就做到 因爲MT編碼器本就不該
在第一個位置時間就降到了19 非常好 
只需做極少的事情 就達成目標
所以小心這些MT編碼器 
若你不打算在pass進行任何繪製 
就別啓動編碼
我們來詳細看一下
來看看樣本app上的渲染pass 
並看看我們都有些什麼
所以我們有一個陰影pass 
它轉化成了一個深度緩衝器
有一個G buffer pass 
它轉化成3個color attachment
一個深度和網板attachment
有這三個lighting pass
它用來自G buffer pass的渲染attachment數據
要麼通過紋理單位進行取樣 
要麼加載到框架緩衝器內容
當lighting pass使用這個數據時 
它們完成lighting和輸出 
使之成一個單一積聚對象 
這個對象被多次使用
最後你有一個用戶界面pass 
在這個pass上 用戶界面元素在屏幕上
被畫出並被展示出來
所以 這是否是編碼器最有效的設置？
再一次 我們調用Xcode框架調試器 
看看它是否還有什麼問題
再一次 是的 它做到了 
它和sunlight編碼器不協調
我們來詳細看一下 
使用命令編碼器並沒有什麼效率
使用Xcode就足夠了 它可以告訴我們 
事實上 我們應該聯合哪一些 
我們繼續 來合併一些pass 
與其合併兩個 不如合併三個 
他們都在同一個上起作用color attachment
我們繼續 進行合併 
這裏 我們有6個pass 
現在他們將把它們合併成4個
所以對於性能GPU方面會有什麼影響呢？
我們轉到GPU 系統軌道
這裏可以看到 我們從21毫秒 
6個pass降低到18 而且不需要
寫出所有的加載 存儲所有的attachment數據
真是好極了 
但是 是否能在進一步呢？
讓我們回到app 
我們有4個pass它是否真的可以
合併G buffer和lighting pass免去存儲
5個attachment並將所有的一切都保存在芯片上？
是的 它真的可以 
我們可以通過巧妙的使用可編程調配做到這點 
這裏 我不會講太多細節 
我們所做的是 將兩個編碼器合併成一個
現在 三個渲染編碼器被留下來 
我們必須加載並存儲極少的attachment數據 
從帶寬方面來說
這是個巨大的勝利
來看看有什麼影響
事實上 並不多
這簡直是出乎意料 
我們只減掉了大約1毫秒
不是很好
我原本希望可以減掉更多的 
再一次 Xcode能否挽救我們？
我們轉向Xcode框架調試器
來詳細看下爲G buffer編碼器
加載和存儲帶寬
它顯示的是 事實上我們仍然加載和存儲了大量的數據 
原因很簡單
看起來似乎是我們並未爲每個attachment
正確設置加載和存儲行動
我們只想存儲第一個color attachment 
除了深度和網板attachment外 
其他的都要放棄 我們當然也不想加載
這些放棄掉的color attachment
所以 若我做了個簡單的變動 讓加載
和存儲行動變得更合適 
加載帶寬就被減到0 
我們也大量減少
存儲attachment數據的數量
所以現在有什麼影響呢？
先前 GPU上 
三個pass就花了17毫秒
現在 它減到14毫秒
更接近一些了
簡而言之 不要浪費你的渲染編碼器 
想在它們上面儘可能的多做些有用的工作 
那就不想畫任何東西的時候 
就別啓動編碼
如果你可以在Xcode的幫助下 
合併渲染到同一attachment上的編碼器
這將讓你獲益良多
在GPU方面 我們做得相當好 
事實上 我們是在我們的框架預算之內 
但我們是否能在CPU上做些什麼呢？
如果你記得 我想事實上我們仍然 
有點超出我們的框架預算
多線程怎麼樣？
多線程會如何幫助我們？
在多線程方面Metal允許我做些什麼？
很幸運Metal在考慮了多線程的基礎上 
設計出來的它有一個非常有效的線程安全 
和一些多線程渲染工具的可擴展方法
它允許你在不同的線程上同時對多重命令緩衝器進行編碼 
你的app控制了
正在執行編碼的命令
我們來看一下可能的情境 
在這個情境裏我們可能嘗試一些多線程 
開始之前 我想要強調 
在你開始對你的渲染進
行多線程處理之前 
你應該積極尋找
達到最佳單線程性能的可能
在你開始進行多線程處理之前 
確保資源足夠 
好了 這裏有個示例 裏面有兩個渲染pass 
事實上CPU對這兩個pass進行編碼時間太長 
導致我們錯過了框架截止期限
所以 如何改進呢？
我們可以繼續 
對兩個pass採用並行編輯
不僅是設法減少每幀的CPU時間 
副作用是 第一個渲染pass會 
更快地被提交到GPU中
在Metal對象方面這個看起來是怎麼樣的？
如何一起使用呢？
照例從命令隊列中的Metal設備開始 
現在這個示例 
我們將有三個線程 
每個線程需要一個命令緩衝器 
這兩個線程每個都有一個RenderCommand Encoder 
在單獨的pass上起作用 
第三個線程上 我們可能有
持續執行的多重編碼器
爲多線程展示方法
可以是非常靈活的 
一旦編碼完成了  
命令緩衝器就會被提交到命令隊列中
所以 你會怎麼設置呢？
非常簡單
你爲每個線程創建一個命令緩衝器 然後繼續 
像往常一樣初始化渲染pass 
現在 重要的一點是命令 
在命令裏 命令緩衝器將被提交到GPU中
有可能這對你很重要 
所以你通過調用命令緩衝器裏的 
Enqueue方法執行它 
它在命令隊列裏保存了位置 
所以當緩衝器運作時
它們將按照排列的順序被執行
這點很重要 需要記住
因爲隨後爲每個線程創建渲染編碼器 
然後繼續在分開的線程中對繪製進行編碼 
然後提交命令緩衝器
真的很簡單 
其他可能從多線程中
獲益的情境怎麼樣？
這裏 我們有兩個pass 
其中一個比另一個明顯長很多
可以將它分離嗎？
是的 可以 
我們將它分成兩個單獨的pass 
這裏 我們有三個線程 
一個在第一個渲染pass上起作用 
另兩個則在第二組塊上起作用
再一次 通過使用多線程 
我們沒有超過框架截止期限 
我們在CPU上節省了一些時間 
可以用來做我們喜歡的事
無需更多的Metal工作 
我們怎麼確切地說這看起來像什麼？
再一次 我們有設備和命令隊列 
在這個示例中 我們將用到三個線程 
但是我們只想用一個命令緩衝器 
有Render CommandEncoder的特別格式 
Parallel Render Command Encoder
現在 這允許你越過多重線程 
爲單個編碼器分離工作在iOS上使用這個尤其重要 
因爲它確保線程的工作量
隨後在GPU中被合併成一個單個pass
所以pass之間並無加載和存儲 
如果你將在多重線程裏拆分
一個單個pass使用這個就很重要了
從Parallel RenderCommand Encoder裏 
我們創建了三個從屬命令編碼器 
現在每個都將編碼成命令緩衝器 
因爲我們正在多重線程化 
編碼可能在不同的時間裏被完成 
無需特別的命令
然後命令緩衝器提交到隊列 
現在 它完全可行 
你甚至可以有並行
Parallel Render Command Encoders
多線程可能性並非無止境 
但是非常的靈活
你也可以有我們剛看到的 
你可以有第四個線程 
連續地執行編碼器
所以我們如何設置？
每Parallel Render Command Encoder 
創建一個命令緩衝器開始 
不管有多少個使用中的線程 
你只需要一個命令緩衝器
然後 和往常一樣 繼續初始化渲染pass 
然後創建真實的並行編碼器 
現在 這裏是重要的顯存位寬 
在我們創建附屬編碼器時 
創建編碼器的命令決定 
編碼器提交到GPU的順序 
在你爲多線程編碼分離工作量時 
就需要考慮到這點
然後我們繼續 編碼繪圖 分離線程 
然後爲每個附屬編碼器完成編碼 
現在 第二個重要的點是 
所有的附屬編碼器必須在我們結束
並行編碼器編碼之前完成編碼
如何執行 取決於你 
最後 命令緩衝器致力於隊列 
所以 我們繼續 我們決定對我們的app多線程化 
看看都有什麼 
先前 我們有連續編碼或pass 
這個用了CPU時間的25毫秒 
現在 我們找到一種方法即在一個線程裏編碼陰影pass
在其他線程上編碼G bufferpass和UI pass 
現在時間減到少15毫秒 
這是一個改進 
我們同樣也在CPU上節省了一些時間
直到多線程化進行 
如果你發現你仍在CPU範圍內 
而且你已經做了所有你能做的調查 
確定app上沒有愚蠢的事正在進行 
那你就可以從多線程化裏獲益了 
你可以在多線程上
同時編碼渲染pass
但是你決定在多線程裏分離
一個單個pass
想用Parallel RenderCommand Encoder來做
現在 我從這部分學到了什麼？
我們介紹了Metal系統尋蹤工具
它真的很棒
它爲你的app Metal性能提供了新理解 
你想要和Xecode一起配合使用 
進行早期分析 並經常進行分析
正如我們看到的 你也應該試着 
遵循陳述過的最優方法 
所以你想提前創建消耗多的狀態 
並儘可能重複使用狀態
我們想要緩衝動態資源 
所以我們可以在框架之間進行有效修改
而不會引起任何拖延
我們想要確保我們在適當的時候
在正確的點上獲得Drawable
通常在最後的可能時刻 
我們想確保我們有效使用 
Render Command Encoders
我們沒有任何空的編碼器 
我們把爲相同attachment所寫的
任何編碼器都合併成一個
然後 倘若發現我們還在CPU範圍內 
正如在這裏案例中看到了我們可以考慮由Metal提供 
用來將渲染多線程化的方法
所以 我是怎麼做的？
現在 看我們的app 
我們沒有任何執行期着色器編輯 
GPU工作量在框架截止期限內 
很好 
本來就是CPU的工作量 
在CPU上框架之間的處理沒有差距 
我們甚至可以決定進行多線程
我們節省了不少時間 可以用來做其他事情 
我們設法達到我們的對象 
在這個示例中 它是60幀每秒
做得好！
現在 演講結束了 如果你需要 
這部分提到的更多信息 
你可以訪問我們的開發者門戶網站 
你可以在開發者論壇註冊 
任何詳細的問題或一般詢問 
你可以將它們發送給艾倫 卡夫 
他是我們的圖像和遊戲技術專員 
感謝你們來參加這個演講 
希望你不會覺得無聊 
請享受WWDC剩下的部分
謝謝