下午好
大家好感谢大家能来参加讲座
我是泰德·克热梅内克我在Apple管理Swift团队
阿莱克斯和我很高兴也很荣幸
和大家讲讲在编译时使用Swift
来发现编码的更多问题
这是个相当宽泛的话题 所以我们
所以我们决定主要谈两个问题
首先是利用Swift 2中的新语言术语供给
以便轻松允许应用利用新的API
与此同时部署更早的版本
在更早的讲座中我们简要谈过这个话题
我们马上要深入探讨设计
方法的理念所解决的问题
以及如何在代码中实现最佳应用
然后 阿莱克斯会谈谈如何
使用富类型系统协议和枚举
甚至还有协议扩展以便在在自己的代码中
执行应用不变性并定义解决许多应用开发模板
我们先来看第一个话题
利用新API
这类话题已经讲了很多遍很多人对此都很熟悉
对Apple而言 我们继续在
每个OS版本中推出丰富的API
让大家有机会在应用中构建不错的功能
对吗？这是我们这么做的部分原因 不是吗？
这里的谜题是app具备已有用户 对么？
他们目前...
他们不必使用最新的OS
在iOS 有较快的使用率
但是这不是说人人都会立刻采用
还有些人出于各种原因完全不会使用
那么你会面临一系列选择你会怎么做呢？
你是否会继续
并要求app使用最新OS？
好 那你获得所有的新API 可这的确成问题
因为你会搞砸
要知道 你会损失用户
这些是会购买你的app的人群
你是否应该走到相反的极端
控制使用新API？
这样就会获得所支持的
最早版本OS的最小公分母
这样做很糟糕因为你会影响到
原本可以向用户提供的丰富
功能
当然 要知道有鱼和熊掌兼得的办法
可以采用新API与此同时还
可以部署更早的版本
所以很长时间以来 我们在技术上
都支持这种做法
当然 可以在Objective-C和Swift中均可如此
可是现实中 如今这是个非常
痛苦的体验
在Swift 2中 我们尽可能不让它这么痛苦
我们通过开发人员告知的当前问题
关于部署较早版本
并设法解决语言中的问题
来实现这一点
现在基本模型并未改变 对吧？
对于开发而言在我们的平台上
一直希望大家使用最新SDK
对吗？这会导致应用中所有可能
用到的API都混到了
一起
然后 可以切换app的部署目标
说明你想要退回的时间
从画面来看这样就非常简单
就像是版本的滑动视窗
设置最新的基底SDK
把部署目标设置到视窗的
最早版本 对么？
从概念来讲 很简单
那么在谈到在Swift 2中 
如何采用新功能和API之前我们先来看
现有方法中的问题
基本上而言 你必须编写app
以便应对更早版本的主OS中API缺失的问题 对吗？
还有几个问题需要单独考虑
整个框架的缺失类方法 
函数 甚至部分枚举值
在更早的版本中不得使用
但是令人烦心的是你必须逐一
解释所有这些问题
对框架而言很是麻烦 要决定
我把它连接到应用时 这个
框架是可选项
如果不这样做app就会在启动
较早版本的OS时 出现问题
然后是API本身实际运用
我们先来看类
基本上来说你是在编写app
因此它会有不同表现
这将是有条件的行为
例如当新的API可用app就会做些不同的事情
因此条件逻辑并不是问题
问题在于怎样为行为实现条件化
在这张幻灯片上是用来检测可用性的
典型方法
你来查询Objective-C的运行时间
这个类会在运行时间出现么？
问题是这有点谎言的味道
对吗？我是说类可以有
但是这不意味着你可以使用
API会经常开始是内部API 
在OS中 
它们会在生成和演进的地方呆上一阵在对外发布时
API的行为
可能已经完全改变
即便这样的检测在运行时间成功了
这也不能说明实际使用
这款API时会绝对安全
而是说 如果在OS版本上你使用的时间太过于早 
基本上会在应用中加上定时炸弹
原本你以为API会按照一定方式表现 现在会完全遭到破坏
这会令开发人员多次受到打击
因此是个严重问题
另一个问题是太容易出错
来看这个新款API
通过几项特色功能
我的代码完全有效结果却出了差错
数据在NS数据资产之前很久引入的
代码还会编译 若在最新的OS上检测
它甚至会成功运行
那么只是在更早版本的设备上
运行代码 才会出现问题
对吗？这与通常的测试场景完全不符
在部分情况下
只需要用户来发现这个问题
即将出现的情况是当你试图使用这个类时运行时间会崩溃
很容易因为简单的小错出现问题
方法和类的问题基本一样
可能会出现输入错误
如果检测属性的可用性
你现在必须了解属性的选择器
同时还要拼写正确
此外语法也完全不同 对吗？
来检测API但是语法不一样
函数也有着同样问题
你会犯同样的错误不过可以有
其他方式来编写
那么 如果有枚举那你就被完全骗到了
你不知道 怎样的解决方案才合适
选择器对映射完全没有反应
那就要手动OS版本检测
来看这个表格感觉就像是你希望
改正的所有簿记问题
都在这里
这是个非常伤感的故事
现在我们看到的是的确成问题的
编程模型
对吗？技术上可行但是很难做到
我们希望你利用新款API
与此同时继续支持所有的用户
我们需要解决这些问题
在Swift 2中情况有所改变
把改变构建在语言当中
要以怎样架构app为主 那么
有其他方法可行时可以考虑
使用这些API
你理解 会有条件性行为
但是你会主要关注于此
然后有编译器作为支持
如果用不安全的方式使用API 就会出现错误
还要有统一的句法这样就不必考虑
类 方法函数甚至映射问题
这些都在所用的句法中处理好了
编译器了解你该用的句法
如果你没有做对 它会告诉你正确做法
因为编译器会一直参与其中
在Swift中我们使用模型
所有可选链接可以帮你来处理
那么这样效果如何这里是来自核心位置的部分API
比如说 我在部署iOS 9
因此使iOS 9 SDK
并设置iOS 9的部署目标
编译器可以在SDK中看到该信息
因此这是在Objective-C头文件中
还可以作为Swift中生成的界面来查看
因此类被引入iOS 2中
方法稍后会引入iOS 8
因为我在运行iOS 9
可以无条件使用这款API
如果我在iOS 8部署也仍然没有问题
但是如果我一路退回iOS 7 
编译器可以看到正如我们可以在幻灯片上看到
使用这种方法并不安全
需要请求使用授权
编译器会告诉你这是不安全代码
是错误
它会禁止你构建这个代码
并会提供不错的安全性检测
它会提供可以解决
这一问题的不同方法
这里有注解 你是否需要安全检测？
会有附上的解决办法 如果接受
代码就重写 像这样
现在有汇编组合静态执行
和运行时间执行
这就是散列可用句法
基本上 编译器扫描可以看到代码块中的
所有内容最新的iOS OS X或安全执行这些API
所需的具体版本
是什么？
然后会使用在散列可用的
所提到版本进行适当的运行时间检测
编译器会把它插入其中
你不必猜测如何完成 会高效完成
并做缓存这样就可以安全使用
在SDK中使用该信息
会实现高保真因此会得到真正安全的模式
有些人会问
为什么要在OS版本中进行检测呢
不是提供过对以往内容
所做的指南么？
原因是做簿记实在太难
至少当你查询运行时间时 
你会得到部分真相 但是在很多情况下即便是真相也会有出入
逻辑上来讲 和app开发人员交谈
要知道 你希望构建在app上的体验
都发起在用户正在
运行的主OS上 对么？
在每个OS版本中都有一批新的API
这些基本上定义了你可以执行的
各种功能而用户在使用
不同版本的OS 因此 他们在逻辑上
打破了你的app所具备的
行为类别 对么？
所有这些在逻辑一致性上都有区别
同样 它也不会检测某款API的存在
因为你通常准备同时使用若干API
这其实说不过
某款API的存在并非表明其他
也会存在
信息位于SDK中编译器可以为你
完成簿记工作
编译器涉及到真正的规则改变者
它使得可用性检测非常可靠
可以假设编译器在做着正确的事情
你尽可放心是在
通过定义解决整类问题
因为你在用编译执行
而且自然会进入多个平台
比如 我之前有这个NSData资产实例
如果我想让代码以OS X和iOS为目标
我可以简单扩展句法称我也在
其他平台检测其最小可用性
星级表明基本上在所有其他情况下
在本例中应该是Watch OS
我们把它放在那里显性调用
潜在的流程控制
对于其他没有明显提及的平台
会执行指定条件
基本上是真和假
我们本想调用这些分支
它们仍将被采用
因此 我们想显性调用
可读性行为
现在可读性检测会在Swift 2中
自然构成用于控制流的可供性
比如 你之前已经构建了app 希望
进行这类检测 然后执行部分功能
否则什么都不做只要摆脱困境即可
这与新的保安声明相结合
可以像这样调整编码
保安声明下面的的所有内容
都有散列可用标签提供的
可用性
因此自然会找到方法
来构成应用的因素
比如 你之前已经在iOS 7上做过部署
我会把iOS 7中可用的API代码染成绿色
绿色条代表代码块中
可以安全使用iOS 7或更早版本
因此这基本上是编译器
对世界的看法
如果我想用iOS 8 API我已经把它的代码
涂成橙色 你需要对它进行可用性检测
否则 你会从编译器收到一个错误
你可以认为在代码块中
你有特权
决定什么API可以调用
一旦我出了代码块特权就不复存在
就只能调用iOS 7 API
如果我想调用iOS 9 API我可以进行不同的检测
这会在代码块中提供不同范围的特权
它是极具可组合能力和可读性的模型
比如 我在根据
部分API是否可用构建
具备整套不同功能的app
我想对此进行分解
我不是只把一束代码加入条件语句
我希望把它分解放入不同的函数中
这很容易做到
可以声明另一个函数
比如出于教学目的我的函数使用iOS 8
我准备从条件代码块中调用
问题在于编译器不知道
你要做什么要知道
只有完成检测才能调用这个
在默认状态下编译器会确认
你锁定iOS 7
我假设你在这个函数中 只使用
iOS 7 API
如果你想用iOS 8API那么就要进行检测
这不太好 对吧？
这里并未提供方法来真正分析app
还会导致冗余检测
你可以告知编译器你的意图
这样SDK本身会有这些方法和类的
添加可用适应
称这是可以用于API的最小OS
在自己的代码上也可以使用同样的注解
表示除非已经进行过适当的
可用性检测否则不得调用该函数
一旦出现这种情况
编译器会以不同方式看待代码
然后可以完全删除检测
即额外的可用性检测安全使用iOS 8 API
这可以组合使用
因为其他函数也有相似注解
如果函数有着相同的API特权 
可以直接调用它们
如果在进行可用性检测时
想通过更多特权调用API
那么这样很方便构成 很容易理解
代码的构成方法
如大家的预期这也适用于方法
这样可以标注类为可用
但是具体方法 也许不可用
如果需要 你可以在调用更可用的
具体方法前 举例说明该类
你需要进行检测
在要求最小的可用性时 如果想标识
整个类的话这样会奏效 
如果这样做 除非进行过可用性检测
否则甚至连举例说明类都不可能
那你会获得API可用性
完整的全部传递闭包
这会自然引发 可以使用的更多技巧
比如 你已有较早版本中的自定义模糊视图 
Apple会推出更具体的UI视图子类 
你想使用新版本
在主OS上使用它们
你想通过可用性保护实现这类
运行时间多态 那么如果你在
运行OS 要使用原生UI
否则就要使用自定义的
这样获得对象的客户端
并不需要在乎你运行的OS版本
到底是哪个
你已经完全提供了关注点的分离
当用到协议做同样的事情
效果会很好可提供不同的执行
可以有闭包不同的函数
可以实现完全不同的新方法分析代码
并获得你所期待的安全性
我们觉得可用性检测相当棒
我觉得它的确提供了具有凝结力
的安全方法来使用新款API并部署到更早版本
统一的句法提供了真正安全的编程模型
但是更重要的是它提供了正常分析app的方法
你可以阅读app
可以阅读代码并理解
可以期待不变性
我觉得这一点 非常强大
接下来我把讲台交给阿莱克斯
他来介绍使用Swift强大类型系统的其他方法
以便在自己的应用中执行不变性
谢谢 泰德
大家好我是阿莱克斯•米基科夫斯基
是Apple的示例编码员
在过去的一年半时间
我都在教开发人员如何用Swift编写Cocoa app
我对于Swift和Cocoa有着清晰的梦想
怎样才能让二者在一起实现安全的
编译时间 安全应用
今天我想介绍我已有部分想法 
并解释大家可以从中使用的
部分范例并把这些概念
运用到各自的应用当中
这样你也可以编译时间安全代码
现在我还没有告知大家 但是在这些想法中
我还想到了独角兽
我开发了独角兽app来看一下
我设想的不同独角兽
首先 我想介绍我应用中的
Asset Catalog 标识符
每个人都在UIKit中用到它
我的独角兽浏览app相对简单
在Asset Catalog中我已经加入3个独角兽图像
我现在想看看当我从Asset Catalog生成图像
代码会是什么样
你会注意到
我在搭建的3个图像
每个图像我都向UIKit UI
图像API传递一个字符串
不知道Asset Catalog UIKit实际上提供了怎样的资产
所以我必须打开这些图像
才能在应用中使用它们
非常不巧
因为已在Asset Catalog定义Asset Catalog标识
我不希望这里出现重复信息
此外 这里我只会使用3个图像
可是在整个应用中我会用到许许多多
问题是很难找到你的代码中
是否有输入错误幻灯片上是
这些错误会引发的反应
基于这些 你可能会希望进行修改我明白
但是确实很难回去把它们都找出来
那么经典的解决方案应该是有个
全局常数
这样可以在应用的各个地方使用
同样的常数
如果使用正确那就可以把独角兽
图像按照你的想法再找回来
但还是要打开图像 因为编译器
不清楚框架也不知道
你是否会
提供有效的常数名称
此外 可以提供随机的为API提供随机流
运行时间会出现致命错误
因为NSUbiquity身份改变节点
通知还是字符串可以有效传递至
UI图像指定API
我们来看看怎样解决这个问题
我们要做的是严格的类型解决方案
我们在代码中将字符串传递到各处
我们希望的是强大的类型解决方案
希望可以将字符串映射到
新的类型
这会让我们编码解决
怎样搭建应用至
编辑器的信息
这样可以把非选择性UI图像
返回到代码的各处
解决方案就是
针对应用进行枚举
我们在应用中定义的枚举
如果来看之前定义的代码
我不希望代码是这幅样子
我想每次生成UI图像对象都传递枚举
这样我就不必
在代码中打开返回值
怎么实现呢？
首先我希望
定义UI图像的嵌套类型 以便在
枚举大小写和Asset Catalog中
定义的字符串表达之间提供
映射
我们将之定义为嵌套类型
这样可以存储在AssetCatalog的其他资产
也可以使用这种方法
一旦这么做就非常简单
我可以在枚举大小写和字符串表达之间
提供大小写映射
对所有其他的情况也可以这样
这种方法的真正好处在于
如果我不小心有输入错误 如果
我不小心从什么地方复制粘贴了字符串
出现了重复编译器就会
警告或者报错 告诉我
在枚举中出现了重复问题
编译器可以这样帮忙 实在太好了
现在我们已经定义了新类型
我所需要做的就是返回再编写便利初始化函数
其中使用这个枚举而不是字符串
并将枚举的原始值转至UIKit
定义的UI图像命名初始化函数
如果我们回来再看代码
可以把独角兽放在所希望的任何地方
如果我们再来看像以前那样出现输入错误会怎样
现在编译器可以告知出现了输入错误
因为我们已经把应用结构的
信息编入了代码之中
如果修复这个问题编译器错误也不复存在
我们来谈谈这么做的好处
首先是我们的常数位于中心
如果将新的图像加入Asset Catalog
我准确知道该在哪里添加图像常数
还有一个好处是这样做不会污染
全局命名空间
我可以有在Asset Catalog中定义的若干对象
可以在其中运用这个办法
最好的一点是 当构建UI图像对象时
在应用中可以只用这些
枚举情况中的一种
所以编译器可以帮你实现这点
现在你可以将非选择性图像返回到
代码中的任何地方 因此不必担心
强行打开的问题
这是我们在独角兽浏览器app中所用的非常
独特的方式但我希望你们想想
怎样在自己的代码中使用枚举
以提供其他种类的富映射
你们可以不只是作为字符串使用
还可以使用整数甚至是选择器
有很多机会
在自己的代码中定义这些映射
现在来深入探讨枚举 但是我想
先说说联线标识符
因为在代码中始终要
使用到它
现在 我的想法越发强烈
我必须研制出一款app 让我真正跟踪
独角兽 并在运行中下载它们
我有更复杂的应用
如果来看故事板
就会变得非常简单
我只有单独的视图控制器 可以
联线其他两个视图控制器
对于所有这些视图控制器而言
我定义了一个联线标识符
我需要看看当我们覆盖
联线准备来配置独角兽浏览器
视图将呈现的
视图控制器时 代码会是什么样
我们覆盖了这种方法 执行这一点的
经典办法是打开
联线标识符字符串
现在 在我使用完全相同的字符串之前
我是按照故事板中的联线定义的字符串
编辑器对此还一无所知
当我只打开这两个字符串时
编译器会告诉我
这并非是穷尽性检测
我必须加入默认情况因为编译器不知道
我已经提供了有效映射
但是如果我加入了新的视图控制器
必须有个全新的联线 那会怎样？
我怎么才能知道在代码中
哪里需要改变 这个逻辑？
我们来看看再次通过枚举
该怎么解决这个问题
我定义了独角兽浏览器视图控制器的嵌套类型
它将代表联线标识符的情况
和故事板字符串表达
之间的映射
我们来看 怎么实现用更强大的类型
联线方法准备
首先 我要做的是
从故事板联线对象抓取联线
标识符字符串
并从原始值中构建联线
识别符枚举
我还会提供部分运行时间
检测调试以防我并未
为新的联线识别符 提供有效的
枚举情况
从这里 我可以打开枚举 而不是字符串
这非常棒 因为我必须打开
两种情况 编译器知道我在枚举中
只定义了两种情况所以我必须在代码中打开
如果我们在枚举中添加了新的联线标识符
编译器就会告知 我们并未
进行穷尽性转换以便我们在枚举中
打开的代码各处
编译器就会告诉我们
在哪里更新逻辑
这对字符串解决方案来说是个极大的好处
我们可以这样重写联线准备
但是 有时需要通过标识符 
人工启动执行联线
在本例中 我想要引入一束独角兽
下载它们在Web上 下载图像
显示新的视图控制器
我们来看看 这些代码是什么样子
那么经典的解决方案是将字符串
传递至带有标识符方式的执行联线
我们已经定义了这种枚举
我们只是想使用已经提供的
这种映射
相反 我们想用枚举
怎么做呢？
其实 非常简单
我们可以通过标识符方法定义UIKit定义执行联线
的过载其中采用了枚举而不是字符串
然后用枚举的原始值调用UIKit 定义方法
如果我们返回用枚举调用
方法的代码它完全是按照我们的预期运转
这就是针对独角兽浏览器视图
控制器的绝佳解决方案
但是如果再复杂一点会怎样？
我希望看看我们刚才做的结构
看怎样才能把它应用到
独角兽浏览器以外的视图控制器
我们做的是在枚举情况
及其故事板上的字符串表达之间
提供映射
我们还增加了使用该映射的
执行 以便获得应用中
更强大的类型系统
但如果我们增添新的视图控制器
我们希望做同样的事情
需要不得不复制所有那些工作我不希望这么做
我真正想做的是从视图控制器提取
执行 并定义松散映射因为联线标识符的枚举
会具体针对视图控制器
通过这样做 我们可以为多种
视图控制器使用该执行
不论其类层次如何
通过重复使用这个执行可以避免许多
糟糕的类层次
我们会通过协议 来实现这一点
所以我定义了一个新的协议
我们会称之为联线处理类型
我们的视图控制器需要与它
相一致
我希望定义刚提到的映射
现在它将成为联线标识符枚举
我们希望确保联线标识符和
原始可显示协议相一致
这个协议是个关于各类型支持的
枚举的重要执行细节
编译器可以自动为你合成
关于协议定义就是这些
我现在需要用Swift 2.0的功能
受限制的协议扩展
来实际添加将成为我们的
泛性可重用代码的执行
我们将扩展联线处理类型
接下来我们对之加以限制
如果这些限制条件满足的话 我们只想让执行
加入其中
第一个限制条件是满足协议的类型为
UI视图控制器子类
这将会让我们在协议扩展中
调用UI视图
控制器方法
第二点是我们想确定
联线标识符映射是位于
映射情况和字符串之间
我们已经定义了有限制条件的协议扩展
我们所需要做的就是添加执行
我们要通过之前定义的标识符 
采用联线现有执行 
并将完全相同的执行加入代码
如果我们返回独角兽浏览器视图控制器
我们只需在新类型中加入一致性
我们已经满足了协议的所有相关类型限制条件
因为我们已经识别了这个联线
标识符枚举
如果我们进入处理行为方法 我们可以
用完全相同的方式调用代码 但我们在联线处理类型中重用执行
我们可以这样通过标识符方式
重用表现联线但是要是调用联线准备
或联线处理准备会怎样？
我需要定义便捷方式
其中会采用故事板对象
并返回联线标识符枚举
这是在协议扩展中完成
我要再次做的是使用之前定义的执行
返回我们用代码
生成的联线标识符枚举
如果来看为联线方式所做准备
结果就变得非常简单
我们所需要做的就是通过联线的
联线识别符 打开结果返回这是我们刚定义的方法我们只需要提供
两种情况打开方法和之前的完全相同
但是我们有这个泛型解决方案
我们来谈谈这么做的好处
当我们将之添加到 联线标识符枚举中时
编译器完全了解我们在故事板上
定义的联线
可以确保我们在代码中
处理了所有可能的情况
通过使用协议扩展我们具有可重新使用的解决方案
我们可以在符合新协议的任何视图
控制器上使用这个执行
我们还有便捷句法
可以在不同的
视图控制器上使用方法句法
不一定必须是 自由函数
这是在独角兽浏览器app中可以使用协议和
有限制方式的协议扩展的 
独特方式但是大家都有许多其他有趣应用
我想让大家做的是思考一下
怎样在自己的应用中使用协议和
相关类型限制条件来编码部分
应用的结构到编译器这样它可以帮你
实现编译时间安全性
我想让你们想想
怎样使用协议扩展
在自己的应用中分享执行
避免一系列糟糕的类层次问题
泰德和我今天说得够多了但是希望大家从中领会到
编译器是来帮助大家的
泰德说的是如何在新API中安全利用这一点
现在 这可以通过编译器大部分完成
编译器知道有什么这不是具体针对
哪个OS的版本
我和大家介绍的是应用的强大类型
强迫应用实现不变性
并利用编译器
让它知道应用的限制条件
并把这些信息编入代码
这样编译器可以帮你分析
编译时间的问题而不是在运行时间
若要了解更多详情
建议大家在线观看《基于协议的Swift编程》
讲座 如果你自己对Cocoa和Swift
有明晰的梦想建议你仔细看看这两个示例
编目示例有联线处理类型协议的实例
DemoBots使用了
在协议中使用枚举的一系列有趣方法
实现编译时间安全性
若要了解更多详情可以查看
Swift LanguageDocumentation
我们还有开发人员论坛如有任何问题 
你们也可以联系斯特凡
感谢大家希望能在实验室见到大家