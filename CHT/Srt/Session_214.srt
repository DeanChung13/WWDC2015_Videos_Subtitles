00:00:20.220 --> 00:00:23.056 
《有關On Demand Resources之簡介》

00:00:23.123 --> 00:00:23.957 
下午好

00:00:25.859 --> 00:00:29.029 
歡迎來到今天關於On Demand
Resources的介紹會議

00:00:29.096 --> 00:00:30.364 
我是史蒂夫·列瓦倫

00:00:30.764 --> 00:00:32.299 
我們今天將給你們準備了些什麼呢

00:00:32.366 --> 00:00:34.301 
嗯 我們還是先給你們說說

00:00:34.368 --> 00:00:37.471 
On Demand Resources
或者是ODR的大致情況

00:00:37.871 --> 00:00:41.909 
我們來比較一下使用ODR App
與沒有使用它的區別吧

00:00:43.010 --> 00:00:45.345 
我們將爲ODR開發人員
以及用戶們

00:00:45.412 --> 00:00:48.448 
列出ODR App的
所有特性和優勢

00:00:49.650 --> 00:00:52.753 
然後我們將
深入研究ODR的細節

00:00:53.020 --> 00:00:55.989 
結構以及如何構建等問題

00:00:56.957 --> 00:00:59.993 
接下來我們將給你演示
使用Xcode

00:01:00.360 --> 00:01:03.130 
並將新的ODR API添加到庫裏

00:01:04.565 --> 00:01:09.670 
最後 我們將演示
和構建最優ODR API的最佳實踐

00:01:09.736 --> 00:01:11.338 
並整理成一個小片段

00:01:12.172 --> 00:01:13.006 
咱們開始吧

00:01:13.874 --> 00:01:16.510 
我們得先理解

00:01:16.577 --> 00:01:20.013 
傳統App的進展狀況
才能理解ODR的進展

00:01:20.514 --> 00:01:23.383 
這個App現在將會有一個
可執行的部分

00:01:23.450 --> 00:01:27.087 
這是編譯好的Swift
Objective-C C++

00:01:27.354 --> 00:01:29.089 
以及一些基礎資料

00:01:29.523 --> 00:01:32.292 
和遊戲等級資料
例如 假設這是一個遊戲

00:01:33.327 --> 00:01:36.163 
當開發人員對這個遊戲
或App感到滿意

00:01:36.230 --> 00:01:37.798 
於是你們上傳到App Store裏

00:01:38.632 --> 00:01:41.134 
這樣 用戶可以購買
這個App或遊戲

00:01:41.335 --> 00:01:42.836 
然後他們得到整個程序

00:01:43.003 --> 00:01:44.605 
並下載到設備上

00:01:45.138 --> 00:01:46.773 
然而他們下載的東西
並不單單如此

00:01:47.040 --> 00:01:52.713 
其中也包含開發人員爲所有用戶編寫的
其他有趣的東西包括App和遊戲

00:01:53.480 --> 00:01:55.949 
他們其實是如此有趣

00:01:56.183 --> 00:02:00.954 
人們下載得再多也
覺得不夠而事實亦如此

00:02:01.021 --> 00:02:03.690 
設備上沒有足夠多的空間

00:02:04.157 --> 00:02:05.325 
因此我們怎麼要做呢

00:02:05.792 --> 00:02:08.695 
好吧 我們能做的就是
觀察每個App

00:02:08.762 --> 00:02:11.632 
發現並非每個部分都被使用

00:02:11.899 --> 00:02:12.733 
我舉個例子

00:02:12.799 --> 00:02:15.435 
我的遊戲級別是7級

00:02:15.802 --> 00:02:17.871 
我肯定不想再待在1級

00:02:17.938 --> 00:02:20.941 
而且長時間內
我可能也到不了30級

00:02:21.341 --> 00:02:22.509 
如此一來

00:02:22.576 --> 00:02:24.845 
我們就開始考慮ODR

00:02:25.145 --> 00:02:27.614 
現在讓我們來看ODR的
一個App吧

00:02:28.682 --> 00:02:29.650 
在這種情況下

00:02:29.850 --> 00:02:31.318 
我們開始使用相同的比特

00:02:31.385 --> 00:02:32.886 
沒有去掉任何東西

00:02:32.953 --> 00:02:35.122 
但我們要做的是梳理

00:02:35.189 --> 00:02:37.257 
每個遊戲級別的資料

00:02:37.991 --> 00:02:40.160 
然後我們將整個東西
上傳到商店

00:02:40.794 --> 00:02:43.530 
現在當客戶購買這個App時

00:02:44.264 --> 00:02:46.300 
他們得到可操作的基礎資料

00:02:46.433 --> 00:02:48.535 
也許有Level 1的遊戲裝備

00:02:49.236 --> 00:02:50.270 
這不是雙關語

00:02:50.337 --> 00:02:51.839 
我們已經在遊戲中了

00:02:51.905 --> 00:02:55.142 
因爲他們能闖過
遊戲的Level 1

00:02:55.342 --> 00:02:57.878 
購買和使用App與
Level 1的時間

00:02:57.945 --> 00:03:01.515 
比那些下載整個App更快

00:03:01.849 --> 00:03:04.484 
而且使用更少的磁盤空間

00:03:06.119 --> 00:03:08.188 
用戶現在開始玩這個遊戲

00:03:08.655 --> 00:03:10.257 
並開始玩Level 1

00:03:10.991 --> 00:03:13.327 
一個設計良好的ODR App

00:03:13.393 --> 00:03:15.929 
需要能預測
比如下一個等級

00:03:16.063 --> 00:03:17.564 
因此 需要進行下載資料

00:03:18.332 --> 00:03:19.967 
用戶繼續玩

00:03:20.033 --> 00:03:21.869 
打到Level 2

00:03:22.402 --> 00:03:25.439 
然後ODR內置的緩存機制

00:03:25.506 --> 00:03:27.608 
通知你不再使用Level 2

00:03:27.674 --> 00:03:29.209 
並且作上標記

00:03:29.643 --> 00:03:30.544 
資料還在那兒

00:03:30.611 --> 00:03:31.545 
我們什麼都不用做

00:03:31.612 --> 00:03:34.548 
只需要記住不再用它

00:03:34.615 --> 00:03:37.217 
但會一直保留設備上

00:03:37.284 --> 00:03:38.886 
這樣空間就慢慢少了

00:03:38.952 --> 00:03:40.487 
無法儲存下一個級遊戲

00:03:40.721 --> 00:03:43.991 
我們檢查設備上
其他可能釋放資源的空間

00:03:44.057 --> 00:03:46.393 
僅剩下這個遊戲的...

00:03:46.660 --> 00:03:49.630 
ODR內容 僅此而已

00:03:49.696 --> 00:03:50.631 
在這種情況下

00:03:50.697 --> 00:03:53.534 
緩存機制可以一步釋放空間

00:03:53.600 --> 00:03:55.802 
比如 我有1級的內容

00:03:55.869 --> 00:03:57.771 
我可以將它釋放

00:03:57.971 --> 00:04:00.073 
這樣然後用戶可以
繼續玩下一級遊戲

00:04:00.641 --> 00:04:03.210 
這是ODR的基本理念

00:04:03.277 --> 00:04:04.344 
從遊戲的購買

00:04:04.411 --> 00:04:07.548 
到玩遊戲時間更短

00:04:07.748 --> 00:04:10.217 
佔據設備空間更小

00:04:10.284 --> 00:04:11.752 
更易於...

00:04:11.818 --> 00:04:12.653 
管理

00:04:15.489 --> 00:04:18.591 
現在讓我們談談ODR

00:04:18.825 --> 00:04:20.527 
爲開發人員提供的所有亮點

00:04:21.495 --> 00:04:25.365 
首先 這顯然是一個
動態加載的內容體系

00:04:25.432 --> 00:04:27.868 
你們可能已經使用過
這樣的系統

00:04:27.935 --> 00:04:30.070 
但是我們添加了一些新特性

00:04:30.671 --> 00:04:32.272 
首先我們可以在App Store中

00:04:32.339 --> 00:04:34.408 
儲存該App的內容

00:04:35.342 --> 00:04:39.513 
第二 我們可以在安裝
和請求安裝App時

00:04:39.680 --> 00:04:42.883 
下載內容
事實上我們可以

00:04:43.784 --> 00:04:45.819 
隨時自動化...

00:04:46.053 --> 00:04:47.554 
操作下載

00:04:49.389 --> 00:04:52.526 
最後還包括我提到的
智能緩存機制

00:04:52.593 --> 00:04:53.427 
正如剛剛提到的

00:04:53.894 --> 00:04:56.763 
所以 我們可以騰出空間來

00:04:56.964 --> 00:04:58.232 
加載新的東西

00:04:59.933 --> 00:05:00.968 
最後

00:05:01.468 --> 00:05:05.072 
App Store傳統App
最大是4千兆字節

00:05:05.906 --> 00:05:07.508 
但是ODR App

00:05:07.574 --> 00:05:09.977 
現在可以達到20千兆字節

00:05:10.544 --> 00:05:12.546 
當然 這些大多數
都是ODR的內容

00:05:13.914 --> 00:05:14.748 
好的

00:05:15.048 --> 00:05:16.149 
因此 這是開發者的優勢

00:05:16.216 --> 00:05:17.985 
但對於用戶的好處又是什麼呢？

00:05:19.186 --> 00:05:21.288 
首先 我們可以...

00:05:21.655 --> 00:05:23.557 
改善安裝體驗

00:05:24.558 --> 00:05:27.094 
一個傳統的DLC系統

00:05:27.160 --> 00:05:28.695 
使用該技術的遊戲

00:05:29.029 --> 00:05:30.931 
會有這樣的體驗

00:05:30.998 --> 00:05:32.199 
用戶下載App時

00:05:32.266 --> 00:05:34.735 
他們都非常期待玩這個遊戲

00:05:34.801 --> 00:05:35.636 
他們啓動遊戲

00:05:35.736 --> 00:05:38.939 
然後 不是吧
遊戲還需要下載一些新的內容

00:05:39.439 --> 00:05:43.710 
有了ODR 我們可以確保
新內容就在設備上

00:05:43.777 --> 00:05:45.612 
App只是看上去已經安裝而已

00:05:45.679 --> 00:05:48.649 
因此用戶體驗會更好

00:05:50.083 --> 00:05:50.918 
第二

00:05:51.318 --> 00:05:53.287 
由於我們在設備上佔用的
空間更小

00:05:53.353 --> 00:05:56.190 
在任何時候都更容易管理

00:05:56.256 --> 00:05:58.358 
App佔用的空間小

00:05:58.425 --> 00:06:02.629 
我們就可以
存放更多的App在設備上

00:06:02.696 --> 00:06:04.998 
這對用戶來說
永遠都是一件好事

00:06:06.733 --> 00:06:08.435 
最後
對於用戶來說

00:06:08.635 --> 00:06:10.370 
同樣的
由於有更多的空間

00:06:10.437 --> 00:06:12.706 
我們可以在App Store雲端

00:06:12.940 --> 00:06:14.675 
存儲更多App或是遊戲

00:06:15.642 --> 00:06:19.279 
例如 我們可以有更豐富和
昂貴的遊戲等級

00:06:19.580 --> 00:06:22.349 
對於用戶
同樣是一件好事

00:06:23.717 --> 00:06:24.551 
好的

00:06:25.052 --> 00:06:27.988 
現在讓我們深究
一些關於ODR的細節

00:06:29.289 --> 00:06:32.092 
首先
對於IOS 9系統是應用瘦身

00:06:33.227 --> 00:06:36.063 
而且可以很好地與應用分割兼容

00:06:36.129 --> 00:06:37.898 
如果你錯過了之前

00:06:37.965 --> 00:06:39.433 
關於應用分割會議

00:06:39.499 --> 00:06:43.871 
討論如何將App 下載到
特定設備

00:06:44.404 --> 00:06:45.539 
讓我給你舉一個例子

00:06:45.739 --> 00:06:46.640 
你編寫一個App

00:06:46.707 --> 00:06:49.943 
目標是各種不同型號的
iPhone和iPad

00:06:50.711 --> 00:06:52.579 
當iPhone用戶來到

00:06:52.646 --> 00:06:53.881 
購買App後

00:06:54.114 --> 00:06:57.284 
應用分割可以確保
他們所得到的資源是必須的

00:06:57.351 --> 00:06:58.986 
而且是適合該
iPhone版本的

00:06:59.520 --> 00:07:01.321 
在此之前
用戶會下載所有的

00:07:01.388 --> 00:07:03.257 
包括適合iPad的資源

00:07:03.924 --> 00:07:06.860 
因此 現在結合應用分割

00:07:07.160 --> 00:07:08.829 
和ODR之後

00:07:08.896 --> 00:07:10.330 
彼此雙方都收益

00:07:10.397 --> 00:07:12.566 
它佔用的空間更小

00:07:12.733 --> 00:07:15.536 
我們使App運行更快

00:07:15.669 --> 00:07:18.205 
App持續穩定性更好

00:07:18.272 --> 00:07:20.474 
在設備上佔用的空間更小

00:07:21.909 --> 00:07:22.743 
好的

00:07:23.644 --> 00:07:24.478 
那麼

00:07:25.145 --> 00:07:26.980 
一個ODR App是什麼樣的呢

00:07:27.047 --> 00:07:27.915 
它是如何構建的呢

00:07:28.182 --> 00:07:30.284 
它與如今的App很類似

00:07:30.617 --> 00:07:31.451 
但是

00:07:31.919 --> 00:07:35.923 
他能夠將遊戲裏的等級
和資料梳理開

00:07:36.423 --> 00:07:37.891 
我們把這叫做資料包

00:07:38.659 --> 00:07:41.128 
剩餘的App
仍是你的 .app

00:07:41.995 --> 00:07:46.366 
現在 運用Xcode
和簡單的標籤進行分組

00:07:46.433 --> 00:07:49.002 
例如 這些是我在遊戲
Level 1中的所有資料

00:07:49.069 --> 00:07:50.103 
假設的說

00:07:50.437 --> 00:07:51.438 
這非常容易設置

00:07:53.440 --> 00:07:56.109 
你可以將它標記爲簡單的文件
或一整個文件夾

00:07:56.176 --> 00:07:58.612 
例如 這是Level 2的
整個文件夾

00:08:00.147 --> 00:08:02.082 
現在 你可以標記什麼呢

00:08:03.250 --> 00:08:05.919 
幾乎.app裏的任何東西都可以

00:08:06.386 --> 00:08:07.221 
例如

00:08:07.654 --> 00:08:08.488 
圖像

00:08:08.922 --> 00:08:09.756 
聲音

00:08:10.357 --> 00:08:11.825 
數據和文字

00:08:12.059 --> 00:08:13.594 
很多有腳本的遊戲

00:08:14.595 --> 00:08:17.030 
同樣還有App內購買的內容

00:08:17.097 --> 00:08:19.900 
那麼現在你可以
將程序內購買的物品

00:08:20.367 --> 00:08:22.636 
和通過ODR下載的
實際購買的內容

00:08:22.703 --> 00:08:24.338 
相結合起來

00:08:24.404 --> 00:08:26.473 
利用其它ODR API

00:08:26.540 --> 00:08:27.574 
實現管理

00:08:28.775 --> 00:08:30.911 
唯一無法獲得的是可執行內容

00:08:30.978 --> 00:08:34.448 
即編譯好的Swift
Objective-C、C、C++

00:08:34.581 --> 00:08:35.716 
這些會留在 .app裏

00:08:37.083 --> 00:08:37.918 
好的

00:08:38.818 --> 00:08:39.653 
那麼

00:08:40.187 --> 00:08:41.788 
這些內容將存儲在哪裏

00:08:42.389 --> 00:08:43.789 
好的 我提出其中一個位置

00:08:43.857 --> 00:08:45.158 
顯然它是在App Store

00:08:46.226 --> 00:08:48.762 
我們存儲在App Store
並且按需供應

00:08:49.596 --> 00:08:52.733 
但在開發過程中
Xcode代替了App Store

00:08:52.799 --> 00:08:55.569 
無論你是針對
設備還是模擬器進行開發

00:08:55.903 --> 00:08:58.572 
它存儲在你的App中
並根據需求傳輸

00:09:00.040 --> 00:09:03.010 
現在 Xcode的另一款工具是
Xcode服務器

00:09:03.510 --> 00:09:05.445 
你可以把它設置在自己部門中

00:09:05.946 --> 00:09:09.750 
這樣可以獲取服務器上的
ODR和App

00:09:09.816 --> 00:09:11.351 
例如 按照你所安排的

00:09:11.418 --> 00:09:13.320 
Q/A工程組測試你的App

00:09:15.222 --> 00:09:18.992 
正如你所期望Test
Flight完全整合了ODR

00:09:20.027 --> 00:09:22.563 
最後 假如你要爲公司部署一款App

00:09:22.930 --> 00:09:26.800 
實際上你可以在公司的
網絡服務器上存儲ODR內容

00:09:26.867 --> 00:09:28.569 
並設置安全登錄

00:09:28.635 --> 00:09:31.071 
以確保不是所有人
都可以獲取該內容

00:09:32.472 --> 00:09:34.174 
這ODR內容的存儲位置了

00:09:35.843 --> 00:09:36.677 
好的

00:09:36.844 --> 00:09:38.245 
那麼 該如何開始的呢

00:09:38.779 --> 00:09:40.614 
嗯 作爲一個開發者
你要做的第一件事情是

00:09:40.681 --> 00:09:43.650 
看看你所有的App資料

00:09:43.817 --> 00:09:45.185 
並且識別它們

00:09:45.352 --> 00:09:46.720 
你需要對它們進行分類

00:09:47.821 --> 00:09:50.657 
再次重複 你可以
用簡單的字符進行標記

00:09:51.024 --> 00:09:53.160 
這些是我遊戲
Level 1的所有資料

00:09:53.794 --> 00:09:55.829 
這些是我遊戲
Level 2的資料

00:09:55.929 --> 00:09:58.532 
而且你知道
等級間有一些共享的資料嗎

00:09:59.233 --> 00:10:00.067 
它們就在那裏

00:10:00.133 --> 00:10:02.569 
你可用多重標籤標記資料

00:10:02.669 --> 00:10:06.206 
以顯示共享內容 防止重複

00:10:07.374 --> 00:10:10.444 
這部分是爲準備好使用ODR的人
設計的首個部分

00:10:10.511 --> 00:10:12.145 
作爲開發者 這是你的工作

00:10:12.246 --> 00:10:15.382 
現在Xcode起作用了
它將所有這些標籤

00:10:15.749 --> 00:10:17.451 
和組放到資料包中

00:10:18.085 --> 00:10:20.754 
在這個案例中
我們用三個資料包做結尾

00:10:21.655 --> 00:10:23.257 
資料包1爲Level 1

00:10:23.757 --> 00:10:25.359 
資料包2爲Level 2

00:10:25.659 --> 00:10:27.861 
最後以介於資料包1和2之間

00:10:27.928 --> 00:10:30.130 
的資料包3作結尾

00:10:30.731 --> 00:10:32.266 
再一次
請避免重複

00:10:33.767 --> 00:10:36.136 
好了 Xcode起作用了

00:10:36.203 --> 00:10:37.771 
現在輪到開發者了

00:10:39.306 --> 00:10:40.974 
首先你要做的是

00:10:41.041 --> 00:10:42.509 
請求資料

00:10:42.609 --> 00:10:44.444 
我需要Level 1的所有東西

00:10:45.045 --> 00:10:46.914 
出來兩個資料包

00:10:47.214 --> 00:10:49.449 
都屬於Level 1

00:10:49.683 --> 00:10:52.819 
然後是介於Level 1
和Level 2之間的共享資料

00:10:53.320 --> 00:10:55.522 
因爲已經接入共享資料包

00:10:55.923 --> 00:10:57.324 
在我們請求Level 2時

00:10:57.791 --> 00:10:58.792 
我們得到這些資料

00:10:59.259 --> 00:11:01.528 
而這些共享資料
也已經在我的設備上了

00:11:02.629 --> 00:11:06.600 
以上是關於ODR概念以及

00:11:06.967 --> 00:11:09.069 
如何建立一個ODR請求的概述

00:11:09.136 --> 00:11:10.971 
現在 有請託尼·帕克上臺

00:11:11.238 --> 00:11:13.807 
爲我們展示使用API Xcode中
發生了什麼

00:11:13.874 --> 00:11:14.708 
託尼

00:11:20.547 --> 00:11:21.381 
謝謝你 史蒂芬

00:11:21.915 --> 00:11:25.018 
我叫託尼·帕克
我是Apple Foundation組的經理

00:11:25.385 --> 00:11:28.689 
史蒂芬爲大家介紹了
ODR系統如何工作的基本信息

00:11:29.022 --> 00:11:31.191 
現在我們將詳細講API

00:11:31.592 --> 00:11:34.027 
即在你的App 中
實際用來處理這些請求的API

00:11:35.362 --> 00:11:37.497 
關於API你必須知道這個

00:11:37.564 --> 00:11:41.535 
這是Foundation中的新類叫
NS Bundle Resource Request

00:11:43.070 --> 00:11:45.472 
這個類遵照命令設計模式

00:11:45.539 --> 00:11:48.609 
意思是你將用一組選擇
建立一個對象

00:11:49.076 --> 00:11:51.778 
包括你喜歡用的標籤

00:11:52.246 --> 00:11:54.181 
隨後你告訴它開始它的請求

00:11:56.450 --> 00:11:58.452 
這樣 你就可以按需創建對象了

00:11:58.719 --> 00:12:01.388 
因爲系統會參照
高級選項計算標籤

00:12:02.089 --> 00:12:05.125 
所以 如果有不同部分
使用ODR App

00:12:05.325 --> 00:12:07.427 
且可能有重疊標籤

00:12:07.761 --> 00:12:09.596 
你就不需要每次都創建管理類

00:12:09.663 --> 00:12:11.465 
跟蹤你已經用過的那些

00:12:11.532 --> 00:12:13.133 
我們將爲你處理這些問題

00:12:15.936 --> 00:12:18.705 
最重要的一點 即設計出發點是

00:12:19.006 --> 00:12:23.076 
請求與實際資料利用
不掛鉤

00:12:23.777 --> 00:12:26.313 
意思是說
那些你已在App 中使用的

00:12:26.380 --> 00:12:28.682 
以及你已經非常熟悉的API

00:12:28.749 --> 00:12:31.185 
比如NS Bundle
URL For Resource

00:12:31.451 --> 00:12:33.887 
包含URL內容的NS Data數據

00:12:33.954 --> 00:12:35.923 
或UI Image
imageNamed

00:12:36.123 --> 00:12:38.425 
這些API將保持不變

00:12:38.792 --> 00:12:40.594 
你只需事先告訴系統

00:12:40.661 --> 00:12:42.262 
使用一個請求對象

00:12:42.462 --> 00:12:44.765 
告訴系統 這個對象裏
的資料是你想顯示的

00:12:47.701 --> 00:12:49.603 
這個對象組成一個
非常簡單的狀態機

00:12:49.670 --> 00:12:51.205 
從初始化開始

00:12:52.272 --> 00:12:53.740 
在預估資料需求時

00:12:53.807 --> 00:12:56.143 
我們跳轉到請求狀態

00:12:57.611 --> 00:12:59.813 
我們回到結束處理器回調

00:12:59.880 --> 00:13:03.350 
它將告訴我們
那些資料可以獲得

00:13:03.884 --> 00:13:06.887 
以及你可以繼續使用
剛討論的API

00:13:07.521 --> 00:13:08.922 
或告訴我們發生的錯誤

00:13:09.156 --> 00:13:11.124 
當然 在使用ODR時

00:13:11.191 --> 00:13:14.061 
會有一些錯誤
這些需要告訴用戶

00:13:14.361 --> 00:13:16.430 
錯誤可能包括
我們需要下載內容

00:13:16.496 --> 00:13:18.198 
但沒有適用的網絡

00:13:18.565 --> 00:13:20.767 
或儘管已經做了清理

00:13:20.834 --> 00:13:23.170 
設備裏仍沒有足夠的空間
儲存這些內容

00:13:23.604 --> 00:13:25.906 
不管是什麼情況
你都需要告訴用戶

00:13:25.973 --> 00:13:27.875 
或許他們有辦法解決這些問題

00:13:28.809 --> 00:13:30.644 
所以若有適用的資料

00:13:30.777 --> 00:13:32.980 
就像我說的請繼續使用它們

00:13:33.480 --> 00:13:36.483 
同樣重要的是當你用完這些資料

00:13:36.683 --> 00:13:37.818 
請告訴我們

00:13:37.885 --> 00:13:39.686 
你可以用這兩種方法告訴我們

00:13:39.987 --> 00:13:42.990 
第一種
在這個類中調用明確的API

00:13:43.257 --> 00:13:45.225 
告訴我們你已經完成這個內容

00:13:46.026 --> 00:13:48.462 
第二種 允許種類解除分配

00:13:48.529 --> 00:13:50.030 
允許對象解除分配

00:13:50.430 --> 00:13:51.832 
在這種情況下

00:13:51.899 --> 00:13:54.201 
我們將爲你結束請求

00:13:56.537 --> 00:13:58.138 
這是基本方法

00:13:58.605 --> 00:14:00.040 
首先 初始化程序

00:14:00.274 --> 00:14:02.109 
你可看到這裏有字符串

00:14:02.209 --> 00:14:04.478 
這就是正在請求
你所感興趣的標籤

00:14:05.512 --> 00:14:07.047 
開始請求的方法叫做

00:14:07.114 --> 00:14:11.151 
beginAccessingResources
WithCompletionHandler

00:14:11.218 --> 00:14:12.452 
你可看到有個結尾

00:14:12.519 --> 00:14:13.954 
裏面有NSR Error證據

00:14:15.189 --> 00:14:16.356 
最後 這種方法

00:14:16.423 --> 00:14:17.691 
會告訴系統請求完成完成

00:14:17.891 --> 00:14:20.661 
明確
endAccessing Resources調用

00:14:22.596 --> 00:14:24.131 
接下來 我將展示

00:14:24.198 --> 00:14:25.899 
已經在運行中的API

00:14:34.341 --> 00:14:35.175 
好了

00:14:35.309 --> 00:14:38.846 
這是演示app 叫做iTravel

00:14:39.012 --> 00:14:41.882 
之所以叫這個名字

00:14:42.216 --> 00:14:44.618 
是因爲它是一本旅行手冊
提供所有你感興趣的

00:14:44.685 --> 00:14:46.954 
以字母i開頭的國家信息

00:14:47.621 --> 00:14:50.457 
你可以看到
今天用到的兩個國家是

00:14:50.724 --> 00:14:52.459 
冰島和意大利

00:14:52.993 --> 00:14:54.328 
現在 這個App是說明

00:14:54.394 --> 00:14:56.897 
On Demand Resources
用法的很好的例子

00:14:56.964 --> 00:14:57.998 
原因是...

00:14:58.065 --> 00:15:00.300 
用戶購買這個app時

00:15:00.534 --> 00:15:04.972 
或許對獲取冰島和意大利的
信息並不感興趣

00:15:05.305 --> 00:15:07.274 
或至少不需要同時獲得
兩個信息

00:15:07.407 --> 00:15:09.543 
所以 我們可以通過

00:15:09.610 --> 00:15:11.678 
只下載所需內容

00:15:11.745 --> 00:15:13.480 
以減小安裝和下載大小

00:15:14.081 --> 00:15:15.482 
在使用ODR之前

00:15:15.549 --> 00:15:18.085 
我想要簡單的展示一下
如何使用它

00:15:18.452 --> 00:15:20.587 
首先訪問冰島

00:15:21.788 --> 00:15:24.725 
你可以看到我在這裏拿到
興趣點清單

00:15:25.225 --> 00:15:26.793 
我從中選擇一個

00:15:27.227 --> 00:15:29.429 
裏面可能有些優質的圖片

00:15:29.496 --> 00:15:30.964 
或指南文本

00:15:31.265 --> 00:15:34.134 
興趣點清單裏的每一點
都有不少圖片

00:15:34.535 --> 00:15:36.904 
你可以看到
這些增加了不少數據信息

00:15:39.573 --> 00:15:41.675 
而意大利 也是一樣的

00:15:42.042 --> 00:15:44.011 
但是內容不同

00:15:46.813 --> 00:15:48.682 
我們來看看如何創建這個App

00:15:51.852 --> 00:15:53.620 
我們今天將花大量的時間
來講一個類

00:15:53.687 --> 00:15:56.323 
就是
Album TableViewController

00:15:56.390 --> 00:15:58.992 
這是個視圖控制器

00:15:59.059 --> 00:16:01.361 
控制這個興趣點清單中的視圖

00:16:02.062 --> 00:16:03.297 
讓我來展示下它如何工作的

00:16:04.498 --> 00:16:06.166 
當我們繼續這個視圖

00:16:06.400 --> 00:16:09.570 
會有這個函數 叫做loadAlbum

00:16:09.636 --> 00:16:11.572 
接下來的問題是
我們想看那個相冊

00:16:11.638 --> 00:16:13.540 
意大利或冰島

00:16:14.842 --> 00:16:15.809 
設置標題

00:16:15.876 --> 00:16:18.512 
我們把這項輔助函數
叫做populateTable

00:16:19.146 --> 00:16:21.048 
現在 在populateTable
函數裏

00:16:21.148 --> 00:16:24.351 
我們將使用
NSBundle´s URLForResource

00:16:24.551 --> 00:16:26.053 
尋找JSON文件

00:16:26.119 --> 00:16:29.823 
這個文件介紹所有興趣點和清單
以顯示題注

00:16:30.791 --> 00:16:33.594 
我們使用NSData的
contentsOfURL方法

00:16:33.660 --> 00:16:35.229 
從磁盤裏讀取JSON文件

00:16:35.629 --> 00:16:38.365 
我們使用NSJSONSerialization
對其進行解析

00:16:38.465 --> 00:16:40.467 
我們在這裏
創建一些更詳細標籤文本

00:16:40.701 --> 00:16:42.669 
最後重載tableView

00:16:43.070 --> 00:16:45.105 
tableView裏的數據源

00:16:45.172 --> 00:16:47.374 
使用UI Image.imageNamed

00:16:47.441 --> 00:16:49.476 
顯示信息 獲取圖片

00:16:51.178 --> 00:16:52.746 
重點是

00:16:53.013 --> 00:16:55.148 
在這個App中使用ODR

00:16:55.449 --> 00:16:57.918 
植入Table中的功能無需變動

00:16:58.318 --> 00:16:59.152 
再說一次

00:16:59.219 --> 00:17:02.256 
現在你用來獲取磁盤中文件內容

00:17:02.456 --> 00:17:07.394 
或找出像NSBundles這種文件
所用的所有API保持不變

00:17:09.396 --> 00:17:10.364 
我們首先要做的是

00:17:10.430 --> 00:17:12.665 
在App中增加一些標籤

00:17:12.999 --> 00:17:16.069 
做到這點
我將在這裏創建檢測點

00:17:16.803 --> 00:17:19.506 
你可以看到
我已經處理過我的App

00:17:19.573 --> 00:17:22.041 
裏面有個叫Resources的組

00:17:22.409 --> 00:17:25.212 
以及包含部分內容的文件夾

00:17:25.345 --> 00:17:28.048 
這個包含所有冰島的圖片

00:17:28.715 --> 00:17:30.417 
這個包含所有意大利的圖片

00:17:31.285 --> 00:17:33.754 
和我剛纔討論的這些JSON文件

00:17:35.489 --> 00:17:36.456 
接下來 我將接續

00:17:36.523 --> 00:17:40.661 
併爲冰島選擇JSON文件
和文件夾

00:17:41.195 --> 00:17:43.764 
並查看檢測點的右邊

00:17:44.097 --> 00:17:47.201 
你可以看到這裏有個新的叫
On Demand Resource標籤

00:17:47.367 --> 00:17:49.269 
所以我所需做的是開始打字

00:17:50.304 --> 00:17:52.506 
內容將被標記爲冰島

00:17:53.106 --> 00:17:54.908 
用同樣的方法
處理意大利的內容

00:17:56.443 --> 00:17:57.644 
內容 好了

00:17:59.580 --> 00:18:02.449 
接下來我們只需 以便
當然了

00:18:02.516 --> 00:18:05.752 
正如Steve說過的
告訴Xcode如何將你的內容分開

00:18:06.086 --> 00:18:07.554 
現在 下一部分是

00:18:07.788 --> 00:18:09.289 
告訴運行中的系統

00:18:09.590 --> 00:18:11.091 
我們預計什麼時間

00:18:11.158 --> 00:18:12.893 
需要這些內容備好可用

00:18:13.293 --> 00:18:15.262 
我們將在視圖控制器中
進行操作

00:18:15.762 --> 00:18:18.899 
首先我要在我的類中
增加一個I var

00:18:18.966 --> 00:18:20.400 
以保存我們剛說的類

00:18:20.467 --> 00:18:22.803 
NSBundleResourceRequest

00:18:23.003 --> 00:18:25.105 
當視圖控制器進行拆分時

00:18:25.172 --> 00:18:27.007 
我現在要做的是充分利用

00:18:27.441 --> 00:18:30.143 
我們很好地控制這個對象

00:18:30.210 --> 00:18:31.812 
這樣 我們可以控制使用時間

00:18:32.079 --> 00:18:34.314 
當它完成拆分時
我們知道請求也完成了

00:18:34.381 --> 00:18:36.650 
我們允許系統對其解除分配

00:18:36.717 --> 00:18:39.353 
這將告訴系統
我們處理好內容了

00:18:41.221 --> 00:18:44.324 
下一步 在loadAlbum函數
調用populateTable前

00:18:44.558 --> 00:18:45.526 
我們將先...

00:18:45.826 --> 00:18:46.827 
創建請求

00:18:46.994 --> 00:18:49.263 
進入一組標籤
在這個情況下

00:18:49.329 --> 00:18:51.865 
進入意大利
或冰島中的一組標籤

00:18:53.200 --> 00:18:54.034 
我們稱之爲

00:18:54.101 --> 00:18:56.937 
beginAccessingResources
WithCompletionHandler

00:18:57.004 --> 00:18:57.971 
結果出來後

00:18:58.038 --> 00:18:59.373 
這個結尾將被調用

00:19:00.140 --> 00:19:01.808 
或許會產生錯誤

00:19:02.142 --> 00:19:04.778 
在主線程中 這個完成處理程序

00:19:04.845 --> 00:19:06.113 
將在非主線程中被調用

00:19:06.480 --> 00:19:08.949 
我們首先檢查
並確保錯誤是0

00:19:09.316 --> 00:19:10.918 
若不是0
那就是出現錯誤了

00:19:10.984 --> 00:19:12.252 
正如我們先前所討論的

00:19:12.319 --> 00:19:15.689 
這需要告訴使用者
我將在輔助函數裏進行操作

00:19:16.590 --> 00:19:20.360 
然後調用剛使用過的
populateTable函數

00:19:20.661 --> 00:19:22.029 
再一次
沒有變動任何東西

00:19:22.729 --> 00:19:24.231 
繼續 並再一次運行App

00:19:24.298 --> 00:19:25.299 
看看會是什麼樣的

00:19:30.070 --> 00:19:32.039 
現在 我訪問冰島

00:19:32.306 --> 00:19:34.708 
可以看到我的內容在這邊

00:19:35.142 --> 00:19:36.810 
因爲我們已經做了請求

00:19:36.877 --> 00:19:39.680 
我可以選擇一些圖片或興趣點

00:19:40.047 --> 00:19:42.115 
所有的內容都準備就緒了

00:19:42.182 --> 00:19:44.384 
就好像從一開始它們就是
App的一部分一樣

00:19:45.185 --> 00:19:48.088 
現在我們爲你展示
Xcode新調試特徵

00:19:48.155 --> 00:19:49.690 
若你以你認爲的方式

00:19:49.990 --> 00:19:51.592 
使用這些請求對象

00:19:51.658 --> 00:19:52.960 
它將幫助你更好的進行理解

00:19:53.627 --> 00:19:55.095 
即新的調試計量器

00:19:55.762 --> 00:19:57.731 
我將把調試計量器視圖
放在這裏

00:19:57.798 --> 00:19:58.799 
選擇磁盤

00:19:59.299 --> 00:20:01.835 
你可以看到
在中間我們有一個新部分

00:20:01.969 --> 00:20:03.537 
叫做
On Demand Resources

00:20:03.604 --> 00:20:05.873 
它列出你App中所有的標籤

00:20:06.740 --> 00:20:07.975 
比如冰島和意大利

00:20:08.108 --> 00:20:09.209 
他們的大小

00:20:09.409 --> 00:20:10.777 
和現在的狀態

00:20:11.211 --> 00:20:13.680 
你看到冰島的狀態是在使用中

00:20:13.981 --> 00:20:15.115 
這就說得通了

00:20:15.182 --> 00:20:17.284 
因爲我們在這裏查看冰島內容

00:20:17.651 --> 00:20:19.887 
在我看部分圖片時
它保持使用中的狀態

00:20:20.320 --> 00:20:22.556 
但若我回到主內容目錄

00:20:22.789 --> 00:20:25.626 
它的狀態由使用中變爲已下載

00:20:25.926 --> 00:20:28.295 
因爲請求對象已解除
系統知道我們

00:20:28.562 --> 00:20:31.465 
不再使用這些內容了

00:20:32.966 --> 00:20:35.702 
我們並未立即
從磁盤中刪除信息

00:20:35.769 --> 00:20:37.771 
所以當你回到冰島時
內容仍舊可用

00:20:38.005 --> 00:20:40.040 
它的狀態也變成使用中

00:20:41.141 --> 00:20:43.076 
讓我們看看訪問意大利時
會出現什麼

00:20:45.679 --> 00:20:47.414 
現在
你看到需要花一些時間

00:20:47.648 --> 00:20:48.982 
內容纔會出來

00:20:49.449 --> 00:20:52.252 
原因是...

00:20:52.419 --> 00:20:56.190 
意大利標籤遠比冰島的大

00:20:56.256 --> 00:20:57.691 
有130兆字節

00:20:58.392 --> 00:21:00.994 
這裏需要做兩件很重要的事

00:21:01.228 --> 00:21:05.465 
首先需要減小標籤內容大小

00:21:05.532 --> 00:21:07.401 
將其分成小的組塊

00:21:07.701 --> 00:21:10.838 
隨後我們會詳細說明

00:21:11.305 --> 00:21:12.940 
現在
我想要告訴你

00:21:13.006 --> 00:21:16.410 
如何使用App中的進度報告

00:21:16.743 --> 00:21:17.578 
並配合使用

00:21:17.644 --> 00:21:20.013 
NS Bundle Resource Request

00:21:20.080 --> 00:21:23.383 
這樣在你下載內容時
就可以告訴用戶一些信息

00:21:23.450 --> 00:21:25.519 
以幫助他們理解接下來
會發生什麼

00:21:27.254 --> 00:21:28.789 
讓我們回到

00:21:29.456 --> 00:21:32.559 
AlbumTableViewController類

00:21:35.996 --> 00:21:37.764 
接下來要做的是利用

00:21:37.831 --> 00:21:40.701 
支持NS Progress的
NSBundleResourceRequest的優勢

00:21:40.767 --> 00:21:41.869 
這是個基礎類

00:21:41.935 --> 00:21:47.207 
你可在你的App中
用它來報告進程和構建進程

00:21:48.475 --> 00:21:50.844 
NS Progress支持鍵值觀察

00:21:51.211 --> 00:21:55.282 
所以我們要做的是增加
視圖控制器作爲進度的觀察點

00:21:55.649 --> 00:21:57.284 
並更新

00:21:57.651 --> 00:22:00.387 
改變屏幕上部分UI
一個UI進度視圖

00:22:00.454 --> 00:22:02.055 
並對一些詳細標籤文本
做出反應

00:22:03.724 --> 00:22:06.360 
這裏 在創建請求後

00:22:06.827 --> 00:22:08.795 
調用addObserver

00:22:09.129 --> 00:22:10.464 
這類將是觀察者

00:22:11.098 --> 00:22:14.301 
請求的進度屬性
正是我們觀察的對象

00:22:15.602 --> 00:22:18.338 
進度中的關鍵路徑是
fractionCompleted

00:22:18.872 --> 00:22:20.607 
和往常一樣 使用KVO時

00:22:20.841 --> 00:22:23.277 
指定唯一的內容指示器很重要

00:22:23.577 --> 00:22:25.212 
這個我已經在文件的某處
進行定義

00:22:25.979 --> 00:22:29.516 
我將繼續並顯示一個
UI progressView

00:22:29.583 --> 00:22:31.752 
這個進度視圖已經
連接到我的故事板中

00:22:33.353 --> 00:22:36.757 
當收到迴應
就可以移除Observer了

00:22:36.823 --> 00:22:40.727 
因爲之後
我們不在對更新的進度感興趣了

00:22:41.395 --> 00:22:45.132 
然後在主線程中
我們將繼續顯示...

00:22:45.199 --> 00:22:47.467 
不好意思
是繼續隱藏UI 進程視圖

00:22:47.534 --> 00:22:50.304 
因爲我們不想要用戶
盯着完整的進度指示器一直看

00:22:50.971 --> 00:22:54.208 
所以我們本身也是觀察點

00:22:54.274 --> 00:22:55.309 
隨後在第二部分

00:22:55.375 --> 00:22:58.345 
在數值變化時 採取一些行動

00:22:58.545 --> 00:23:00.480 
這裏採取的是傳統的KVO方法

00:23:00.647 --> 00:23:02.649 
observeValueForKeyPath

00:23:02.716 --> 00:23:03.884 
首先需要檢查

00:23:03.951 --> 00:23:07.087 
通過檢查內容指示器
和關鍵路徑

00:23:07.154 --> 00:23:09.556 
確保那就是我們感興趣的
觀察更新

00:23:10.057 --> 00:23:11.892 
在主線程中 再一次

00:23:11.959 --> 00:23:14.461 
因爲更新將在非主線程中出現

00:23:14.528 --> 00:23:18.665 
我們將通過設置進度屬性
更新UI進度視圖

00:23:18.832 --> 00:23:23.370 
我們將通過使用它的
localizedDescription方法

00:23:23.437 --> 00:23:26.540 
充分利用自動局部描述的
NS Progress支持

00:23:28.842 --> 00:23:30.644 
讓我們繼續 並再次運行
看看它將如何工作

00:23:36.483 --> 00:23:38.485 
所以這次 當我訪問意大利時

00:23:38.619 --> 00:23:41.522 
你可以看到在詳細標籤文本
底部已經更新

00:23:41.588 --> 00:23:45.359 
可以顯示完成百分比
隨後 一旦下載完成

00:23:45.425 --> 00:23:48.161 
UI進度視圖將告訴用戶

00:23:48.228 --> 00:23:49.263 
已經發生的變化

00:23:50.163 --> 00:23:52.566 
所以 再一次 我們並不着急
刪掉這些內容

00:23:52.633 --> 00:23:54.568 
這樣當我們再次返回
訪問意大利時

00:23:54.835 --> 00:23:56.737 
你可以看到內容立馬就顯示了

00:23:57.171 --> 00:24:00.574 
因爲這些內容已經存儲在
On Demand Resources系統中

00:24:02.009 --> 00:24:03.310 
現在回到幻燈片

00:24:11.251 --> 00:24:13.654 
關於展示中
進度報告部分的一些東西

00:24:14.121 --> 00:24:15.689 
所以 再一次 通過查看進度

00:24:15.756 --> 00:24:18.992 
你可以找到請求進度的信息

00:24:19.860 --> 00:24:23.197 
我們同樣支持取消 暫停

00:24:23.263 --> 00:24:24.965 
重新開始請求
這些方法本身並不是請求

00:24:25.032 --> 00:24:27.401 
它們可在NSProgress中找到

00:24:29.536 --> 00:24:32.539 
現在 事實上在iOS 9
和 OS X 10.11中

00:24:32.606 --> 00:24:34.808 
Foundation中
NSProgress類

00:24:34.875 --> 00:24:36.643 
我們已經做了很多重大改進

00:24:37.077 --> 00:24:38.612 
想知道如何使用它們

00:24:38.812 --> 00:24:42.616 
如何大規模的將這類整合
到你的App

00:24:42.950 --> 00:24:43.917 
和其他地方

00:24:43.984 --> 00:24:46.687 
真的建議你
關注週五的演講

00:24:46.753 --> 00:24:48.555 
《進度報告的最佳範例》

00:24:51.225 --> 00:24:53.360 
在內容還未準備就緒之前

00:24:53.627 --> 00:24:56.930 
beginAccessing方法
將繼續運行並下載內容

00:24:57.364 --> 00:24:58.799 
然後 有時候你只想

00:24:58.866 --> 00:25:01.001 
使用磁盤中已經有的內容

00:25:01.068 --> 00:25:02.302 
不想再進行下載

00:25:02.669 --> 00:25:05.205 
你可以使用假定請求做到這點

00:25:05.906 --> 00:25:06.773 
方法如下

00:25:06.840 --> 00:25:10.010 
conditionallyBeginAccessing
ResourcesWithCompletionHandler

00:25:10.077 --> 00:25:10.911 
你可看到

00:25:11.178 --> 00:25:13.013 
這裏的結尾有布爾參數

00:25:13.080 --> 00:25:14.781 
所以不管是是還是否

00:25:14.882 --> 00:25:17.150 
答案取決於內容可用還是不可用

00:25:18.018 --> 00:25:21.121 
所以根據狀態機

00:25:21.355 --> 00:25:22.723 
我們從初始化開始

00:25:23.323 --> 00:25:25.325 
通過調用這個方法

00:25:25.392 --> 00:25:26.560 
進入假定請求狀態

00:25:27.194 --> 00:25:29.663 
不管它是否可用
你都將得到迴應

00:25:29.897 --> 00:25:32.165 
若可用 資料也將可用

00:25:32.232 --> 00:25:33.667 
就好像你已經調用了其他方法

00:25:33.734 --> 00:25:36.803 
所以 再一次 確認調用
endAccessingResources

00:25:36.870 --> 00:25:38.438 
或允許對象解除分配

00:25:38.872 --> 00:25:41.141 
若不可用
此時你可以做選擇

00:25:41.208 --> 00:25:42.209 
你可以...

00:25:42.910 --> 00:25:43.744 
什麼都不做

00:25:43.810 --> 00:25:46.847 
也可以調用
beginAccessingResources方法

00:25:46.914 --> 00:25:47.981 
進行下載

00:25:50.017 --> 00:25:54.955 
最後 我講講此類中
API兩個優先權

00:25:55.122 --> 00:25:56.757 
第一個叫做加載優先權

00:25:57.090 --> 00:25:58.625 
這個是雙重的

00:25:58.692 --> 00:26:02.162 
它爲你的App中
未解決的請求排序

00:26:02.663 --> 00:26:04.064 
數值爲從0到1

00:26:04.231 --> 00:26:06.867 
所以數值1指最高優先權

00:26:06.934 --> 00:26:08.602 
數值0指最低優先權

00:26:09.136 --> 00:26:10.804 
當我們處理這些數值時

00:26:10.904 --> 00:26:15.709 
它將提示系統哪個未解決的
請求應該優先處理

00:26:16.176 --> 00:26:19.112 
因爲數值只在
你的app中進行比較

00:26:19.179 --> 00:26:21.515 
並未在系統中的App進行比較

00:26:21.615 --> 00:26:23.450 
你可利用這些數值

00:26:23.517 --> 00:26:26.053 
根據你的需要對請求進行排序

00:26:27.487 --> 00:26:29.423 
這裏有個常量可以使用

00:26:29.489 --> 00:26:31.491 
它叫做緊急裝載優先權

00:26:32.593 --> 00:26:34.761 
當用戶只需等待下載完成
而無需做其他事時

00:26:34.828 --> 00:26:36.430 
就可以使用這個常量

00:26:36.697 --> 00:26:38.198 
隨後我們會詳細講到這點

00:26:40.200 --> 00:26:42.636 
第二種優先權叫做保存優先權

00:26:43.136 --> 00:26:47.140 
這個方法指的是
在app中未使用的標籤清除排序

00:26:47.207 --> 00:26:49.209 
這裏並不需要特別的請求

00:26:49.276 --> 00:26:51.578 
這是它成爲NSBundle
延伸功能的原因

00:26:51.879 --> 00:26:54.681 
由一個標籤
或一組標籤進行替代

00:26:55.082 --> 00:26:57.084 
數值範圍從0到1

0數值表示最不需要保存


00:26:59.686 --> 00:27:01.388 
1數值表示最需要保存

00:27:02.256 --> 00:27:05.125 
所以在碰到磁盤存儲空間問題時

00:27:05.192 --> 00:27:07.461 
你可通過它告訴系統

00:27:07.861 --> 00:27:10.364 
哪些數值最需要保存

00:27:10.797 --> 00:27:13.634 
只在你自己的App中進行比較

00:27:13.700 --> 00:27:15.769 
而不是在系統的App中進行比較

00:27:17.104 --> 00:27:18.906 
以上就這些
有請史蒂芬上臺

00:27:18.972 --> 00:27:21.341 
說說使用ODR的最佳範例

00:27:23.810 --> 00:27:24.645 
謝謝你 託尼

00:27:28.282 --> 00:27:31.485 
好的 現在我們對ODR
有了整體的瞭解

00:27:31.552 --> 00:27:33.820 
我們知道它是什麼
並觀看了如何使用它

00:27:34.254 --> 00:27:38.192 
現在來說說
我們如何建立最佳ODR app

00:27:38.825 --> 00:27:41.695 
現在開始對資料做標籤之前

00:27:41.762 --> 00:27:44.798 
首先需要考慮你的app的反應

00:27:45.232 --> 00:27:48.368 
因爲這將告訴你對資料做標籤
需做到哪種程度

00:27:48.869 --> 00:27:51.605 
關於你可能如何使用ODR內容

00:27:51.672 --> 00:27:54.308 
這裏我可以提供三種模式

00:27:55.142 --> 00:27:58.712 
第一種模式
這個就像託尼的iTravel app

00:27:59.046 --> 00:28:02.282 
我們無法預測用戶將去哪裏

00:28:02.716 --> 00:28:04.051 
這是隨機訪問

00:28:04.484 --> 00:28:05.986 
在隨機訪問app中

00:28:06.053 --> 00:28:09.590 
特別是資料比較大的時候

00:28:09.656 --> 00:28:12.759 
你想要的內容標記了很多資料

00:28:12.826 --> 00:28:14.328 
並逐步讀取

00:28:14.394 --> 00:28:16.530 
所以一旦用戶做出決定

00:28:16.830 --> 00:28:18.599 
他們立即就可以在UI中

00:28:18.665 --> 00:28:20.367 
看到那個決定的部分進度

00:28:21.435 --> 00:28:24.471 
第二種模式叫做有限預測

00:28:24.538 --> 00:28:27.875 
某種程度上來說
這就像開放式世界遊戲

00:28:28.308 --> 00:28:32.012 
它可能是無窮種可能性

00:28:32.079 --> 00:28:35.082 
在具體時間點時
它只是有限的子集

00:28:35.148 --> 00:28:37.117 
再次 你要做的是

00:28:37.184 --> 00:28:40.454 
擁有許多標籤
標記比少的內容

00:28:40.721 --> 00:28:42.222 
逐步讀取

00:28:42.289 --> 00:28:45.359 
也需要準備好放棄那些

00:28:45.526 --> 00:28:48.262 
用戶選擇不看的內容

00:28:48.328 --> 00:28:52.399 
比如 就像遊戲玩家
在世界範圍移動

00:28:52.466 --> 00:28:54.468 
他們離開一些地方一樣

00:28:54.535 --> 00:28:55.636 
你需停止使用索引資料

00:28:55.702 --> 00:28:58.672 
去掉
NSBundleResourceRequest對象

00:28:59.706 --> 00:29:02.843 
現在 第三種模式是
已經在我例子中使用的模式

00:29:02.910 --> 00:29:04.111 
就是遊戲中的等級

00:29:04.178 --> 00:29:06.280 
這是直線型進度式遊戲

00:29:06.346 --> 00:29:08.081 
就像第一人稱的射擊遊戲

00:29:08.448 --> 00:29:09.550 
在這個案例中

00:29:09.616 --> 00:29:11.752 
作爲一名開發者

00:29:11.818 --> 00:29:15.522 
你最大的任務是
提早預估下一步需求

00:29:16.023 --> 00:29:17.591 
但是你非常肯定

00:29:17.658 --> 00:29:19.593 
所有的內容都是必要的

00:29:19.660 --> 00:29:21.595 
所以你將只開始加載那些

00:29:21.662 --> 00:29:26.567 
在一定合理時間內
可被加載的內容

00:29:26.633 --> 00:29:27.467 
好了

00:29:27.901 --> 00:29:29.169 
說到時間

00:29:29.236 --> 00:29:32.206 
這裏有個插曲
講到你如何使用ODR API

00:29:32.272 --> 00:29:34.041 
所以我們給自己一個時間線

00:29:34.107 --> 00:29:36.977 
即從app開始到退出

00:29:38.011 --> 00:29:40.180 
現在 設計合理的ODR App

00:29:40.247 --> 00:29:43.250 
應該可以很好的
提早預測需求資料

00:29:43.851 --> 00:29:45.285 
請記住 這是網絡型app

00:29:45.352 --> 00:29:47.321 
它將必須從App Store

00:29:47.487 --> 00:29:49.456 
或我們剛檢查過的其他地方下載

00:29:49.590 --> 00:29:50.691 
但這需要花些時間

00:29:51.291 --> 00:29:53.427 
因此 在需要使用資料的時候

00:29:53.560 --> 00:29:56.897 
且當調出
beginAccessing Resources

00:29:56.964 --> 00:29:58.532 
如果還未安裝到設備上

00:29:58.899 --> 00:30:00.767 
那麼會自動開始下載

00:30:01.969 --> 00:30:05.806 
當前 這是善用網絡資源

00:30:05.873 --> 00:30:08.475 
和解決資料尚未準備就緒

00:30:08.542 --> 00:30:11.411 
就需要使用的最佳辦法

00:30:12.012 --> 00:30:14.848 
而且 在這種情況下
你可以通過進度屬性

00:30:14.982 --> 00:30:17.618 
和NS Bundle
Resource Request

00:30:17.684 --> 00:30:19.219 
加快託尼之前提到的進度UI

00:30:19.686 --> 00:30:22.689 
分享一下屏幕
同時讓下載繼續進行

00:30:23.056 --> 00:30:25.292 
這時候 已經完成下載了

00:30:25.592 --> 00:30:27.361 
資料已經準備就緒

00:30:27.427 --> 00:30:28.962 
你可以關閉下載界面

00:30:29.196 --> 00:30:31.064 
然後開始使用資料了

00:30:31.932 --> 00:30:33.767 
一旦資料使用完畢

00:30:33.834 --> 00:30:37.271 
你們絕對會想要調出
endAccessingResources

00:30:37.671 --> 00:30:41.275 
或者允許NS Bundle
Resource Request對象解除分配

00:30:41.441 --> 00:30:43.544 
以便讓系統知道你已經使用完畢

00:30:44.011 --> 00:30:47.214 
另外 這不代表我們會關閉服務
並刪除記錄

00:30:47.281 --> 00:30:48.582 
我們只是在這裏提醒大家而已

00:30:49.349 --> 00:30:52.119 
因此
這是需要清楚的基本時間線

00:30:52.186 --> 00:30:54.788 
並且你們還可以同時發出多個請求

00:30:55.389 --> 00:30:57.891 
只需要記得本部分的基本內容即可

00:30:58.659 --> 00:30:59.493 
好的

00:31:00.727 --> 00:31:01.562 
現在

00:31:01.628 --> 00:31:03.664 
我已經談了ODR

00:31:03.730 --> 00:31:06.900 
如何通過改善其安裝體驗
而提高用戶體驗

00:31:07.768 --> 00:31:09.203 
因此 具體怎麼完成呢？

00:31:09.269 --> 00:31:10.871 
我們需要大家的幫助

00:31:11.738 --> 00:31:12.840 
作爲開發者

00:31:12.906 --> 00:31:14.975 
你們需要做的是考慮用戶

00:31:15.042 --> 00:31:17.644 
在登錄到app後所需要的資料

00:31:18.712 --> 00:31:21.248 
當你們瞭解是什麼之後
比如遊戲Level 1

00:31:21.415 --> 00:31:22.316 
已經準備就緒

00:31:22.683 --> 00:31:24.084 
然後你們需要設置資料標籤

00:31:24.151 --> 00:31:28.555 
並放到Xcode的
初始安裝標籤UI

00:31:29.823 --> 00:31:31.959 
這會通知ODR系統去確認

00:31:32.025 --> 00:31:33.994 
所有資料的標籤...

00:31:34.127 --> 00:31:35.295 
在app被...

00:31:36.129 --> 00:31:38.432 
完全安裝好之前

00:31:38.498 --> 00:31:40.968 
可以被下載

00:31:41.034 --> 00:31:43.103 
這樣 當顯示完全安裝好之後

00:31:43.170 --> 00:31:45.005 
用戶點擊標籤後就準備就緒了

00:31:45.072 --> 00:31:46.306 
這時候準備開玩了

00:31:46.740 --> 00:31:49.776 
在App Store看到的
App的大小

00:31:50.077 --> 00:31:52.212 
是 .app大小

00:31:52.713 --> 00:31:56.450 
以及初始ODR內容的大小之和

00:31:56.683 --> 00:31:58.018 
因此 需要明白這點

00:31:58.085 --> 00:31:59.987 
此外 我們將在之後會談談這點

00:32:00.787 --> 00:32:03.457 
好的那麼 現在我們可以談談

00:32:03.524 --> 00:32:05.292 
自動化安裝app和ODR內容

00:32:05.359 --> 00:32:10.297 
但此時用戶還未實際登錄

00:32:10.430 --> 00:32:12.933 
因爲你們也可以
自動設定這段時間

00:32:13.534 --> 00:32:16.503 
可以這麼做
以確保遊戲的Level 2

00:32:16.570 --> 00:32:19.439 
或者教程之類可以開始下載

00:32:19.506 --> 00:32:21.708 
也許某些用戶想要看看教程

00:32:21.775 --> 00:32:22.809 
其他人不會想看

00:32:22.876 --> 00:32:26.446 
因此你應當確保app
即使沒有教程

00:32:26.747 --> 00:32:28.182 
也能夠實際運行教程

00:32:28.248 --> 00:32:29.516 
但是最好還是確保有教程

00:32:29.783 --> 00:32:30.884 
爲了這麼做

00:32:31.552 --> 00:32:34.788 
你們還可以使用Xcode
的資料標籤UI

00:32:34.855 --> 00:32:38.592 
然後將標籤放進
預取標籤命令部分

00:32:38.992 --> 00:32:41.261 
在你放到該部分的命令順序

00:32:41.328 --> 00:32:43.463 
是實際上下載這些標籤的順序

00:32:44.765 --> 00:32:45.599 
好的

00:32:46.867 --> 00:32:48.735 
現在談談緩存

00:32:48.802 --> 00:32:50.437 
我們之前提到緩存

00:32:50.504 --> 00:32:52.005 
而且還展示了系統是

00:32:52.406 --> 00:32:55.876 
如何爲新等級騰出
Level 1的空間

00:32:56.710 --> 00:32:59.746 
首先 需要了解的是
我們會清理內容

00:32:59.813 --> 00:33:01.782 
但只在系統內存佔用度
不高的情況進行

00:33:02.583 --> 00:33:06.086 
另外 也只有ODR內容會被清理

00:33:07.020 --> 00:33:08.689 
當我們這麼做的時候

00:33:08.856 --> 00:33:11.692 
這裏有幾個屬性會發揮作用

00:33:11.758 --> 00:33:14.094 
通知我們是否要

00:33:14.494 --> 00:33:17.364 
刪除哪個資料包

00:33:18.465 --> 00:33:19.499 
很明顯

00:33:20.067 --> 00:33:22.336 
是刪除上次使用的那個資料包

00:33:22.402 --> 00:33:23.303 
因此 如果...

00:33:23.670 --> 00:33:25.873 
玩遊戲Level 1的時候是
上週週二

00:33:26.373 --> 00:33:30.244 
那麼 很可能會在前一天
完成Level 1的時候就被刪除

00:33:32.145 --> 00:33:35.215 
另外 正如託尼之提到的保留優先權

00:33:35.282 --> 00:33:37.518 
這指的是對標籤設置
的優先級

00:33:37.985 --> 00:33:40.821 
因此 這是你自己的排序
我們也會加以考慮

00:33:42.589 --> 00:33:45.492 
最後 我們會考慮
app的運行狀態

00:33:45.993 --> 00:33:48.662 
我們不會在資料包
正在使用的情況下

00:33:48.962 --> 00:33:51.131 
刪除運行中的app的
任何資料包

00:33:53.934 --> 00:33:56.870 
現在有幾種策略

00:33:57.137 --> 00:33:59.206 
用於保留ODR內容

00:33:59.907 --> 00:34:02.109 
其中之一是避免過度清理

00:34:02.543 --> 00:34:03.744 
什麼意思呢？

00:34:03.810 --> 00:34:05.045 
我可以舉個例子

00:34:05.379 --> 00:34:07.881 
比如說系統需要100 MB空間

00:34:08.681 --> 00:34:09.949 
那麼系統在進行整機搜索

00:34:10.016 --> 00:34:11.618 
然而沒有找到夠大的空間

00:34:12.452 --> 00:34:14.955 
通過我們剛提及的屬性

00:34:15.522 --> 00:34:17.224 
系統會定位到你的資料包

00:34:17.291 --> 00:34:19.659 
容量爲512 MB

00:34:20.561 --> 00:34:22.429 
我需要清理資料包

00:34:22.496 --> 00:34:23.797 
以符合空間要求

00:34:24.031 --> 00:34:27.266 
因此 我們需要
過度清理412MB

00:34:27.768 --> 00:34:30.337 
所以你的資料包體積
最好是小一點

00:34:30.603 --> 00:34:33.040 
正如我剛提及的 這也有好處

00:34:33.106 --> 00:34:35.909 
因爲想要快點下載好
而且享用內容

00:34:36.275 --> 00:34:38.078 
因此體積越小就越好

00:34:38.212 --> 00:34:40.781 
但是體積越小就越不容易被過度清理

00:34:42.748 --> 00:34:43.583 
好的

00:34:44.351 --> 00:34:46.553 
另一件你們可能想做的是

00:34:46.887 --> 00:34:49.790 
對任何事設置1.0的優先權

00:34:50.324 --> 00:34:51.925 
但這麼做並無卵用

00:34:52.259 --> 00:34:55.195 
這麼做只會讓系統認爲

00:34:55.262 --> 00:34:57.397 
更多的資料重要性是相等的

00:34:57.531 --> 00:35:00.300 
特別是當系統在對app
進行清理的情況下

00:35:00.601 --> 00:35:03.437 
因此 需要謹慎使用優先權設置

00:35:06.306 --> 00:35:08.108 
最後請再次確認

00:35:08.175 --> 00:35:10.143 
因爲當你做完標註我們會看

00:35:10.410 --> 00:35:14.581 
上次endAccessingResources
的使用日期

00:35:14.915 --> 00:35:18.051 
確認允許NS Bundle
Resource Request對象

00:35:18.185 --> 00:35:19.520 
儘快解除分配

00:35:19.820 --> 00:35:22.389 
這會讓系統知道
你將如何使用該資料

00:35:22.456 --> 00:35:24.258 
這樣系統會給出最佳決策

00:35:26.293 --> 00:35:28.195 
好的
現在 我想開始談談

00:35:28.262 --> 00:35:30.330 
性能方面的事情

00:35:31.498 --> 00:35:34.568 
其中之一是我們在
本次會議想做的事

00:35:34.635 --> 00:35:38.939 
是鼓勵大家
提前在後臺下載內容

00:35:40.040 --> 00:35:42.543 
但是我們不想要讓大家

00:35:43.010 --> 00:35:46.313 
浪費更太多的系統資源

00:35:46.613 --> 00:35:48.081 
超過app所能容納的資源

00:35:48.582 --> 00:35:51.785 
因此 我們平衡了
下載速度 資源

00:35:51.852 --> 00:35:53.086 
CPU和其他屬性

00:35:53.153 --> 00:35:55.022 
這樣我們只有在下載
和使用資料包的時候

00:35:55.088 --> 00:35:56.456 
纔會消耗系統資源

00:35:57.224 --> 00:35:58.058 
這是預設情況

00:35:58.492 --> 00:36:01.762 
但如果有需要
或者想要自行進行管理

00:36:01.828 --> 00:36:03.797 
或者想要完全手動操作

00:36:03.864 --> 00:36:05.866 
那麼你可以在這裏設置緊急優先

00:36:06.400 --> 00:36:08.435 
系統會忽略平衡設置

00:36:08.502 --> 00:36:11.038 
我們將會以最快速度下載內容

00:36:11.638 --> 00:36:15.542 
正如託尼提到的
當你提供載入畫面時

00:36:15.976 --> 00:36:17.177 
那時候就是設置的好時機

00:36:17.611 --> 00:36:20.948 
但實際上你的App
可能與CPU不兼容

00:36:21.014 --> 00:36:23.283 
與我們在系統這樣操作情況一樣

00:36:24.451 --> 00:36:25.586 
因此 這完全取決於你

00:36:27.821 --> 00:36:29.022 
而且

00:36:29.223 --> 00:36:31.191 
我們應該討論性能測試

00:36:32.392 --> 00:36:35.362 
你需要爲ODR的App做
現世測試

00:36:35.629 --> 00:36:38.165 
ODR App是一個
基於網絡的App

00:36:38.832 --> 00:36:41.001 
因此當你使用USB將你的設備

00:36:41.068 --> 00:36:43.904 
連接到你的MacBook Pro

00:36:43.971 --> 00:36:44.972 
並運行Xcode

00:36:45.038 --> 00:36:47.975 
那不是真實的場景

00:36:48.041 --> 00:36:49.142 
真是太快了

00:36:49.910 --> 00:36:51.144 
所以你要做的是

00:36:51.445 --> 00:36:56.216 
使用TestFlight或Xcode
服務器來測試你的App

00:36:57.518 --> 00:37:01.989 
然後使用Developer Tools
Network Link Conditioner

00:37:02.689 --> 00:37:05.259 
來測試各種網絡條件

00:37:06.059 --> 00:37:08.362 
你的App在ODR內容下載時

00:37:08.529 --> 00:37:10.564 
可能會出問題

00:37:11.064 --> 00:37:12.999 
事實上
我建議你在任何網絡App上

00:37:13.066 --> 00:37:14.868 
使用這個工具

00:37:14.935 --> 00:37:15.769 
真的很好用

00:37:15.836 --> 00:37:17.271 
如果之前你還沒有使用過它

00:37:17.337 --> 00:37:19.439 
那我現在做個簡短說明

00:37:20.140 --> 00:37:21.675 
當你把你的...

00:37:22.109 --> 00:37:23.243 
設備通過USB連接到

00:37:23.310 --> 00:37:25.279 
MacBook Pro上
運行Xcode時

00:37:25.546 --> 00:37:27.314 
然後設置設備時候會看到這個條目

00:37:27.381 --> 00:37:29.583 
一個開發者條目

00:37:29.883 --> 00:37:32.586 
你點擊後會看到大量的

00:37:32.653 --> 00:37:38.825 
開發者設置
您可以使用日誌等等

00:37:38.892 --> 00:37:41.762 
中間有Network
Link Conditioner

00:37:42.162 --> 00:37:43.530 
點擊你看到的選項

00:37:43.897 --> 00:37:45.165 
您可以看到

00:37:45.232 --> 00:37:47.501 
你可以用來造成App斷網時的

00:37:47.568 --> 00:37:51.839 
各種情況的... 各選擇

00:37:52.239 --> 00:37:56.009 
要用它 啓用Network
Link Conditioner

00:37:56.210 --> 00:37:59.012 
然後決定你想要創建
什麼類型的情況

00:37:59.413 --> 00:38:02.015 
也許你想模仿100%的無網絡狀態

00:38:02.316 --> 00:38:03.851 
或非常緩慢的網絡

00:38:04.384 --> 00:38:07.154 
或者高延時DNS查找

00:38:07.654 --> 00:38:10.591 
或者你只是想重創
非常糟糕的網絡

00:38:11.258 --> 00:38:15.696 
這便是使用ODR App的最佳工具

00:38:17.364 --> 00:38:18.198 
好的

00:38:18.699 --> 00:38:20.200 
說到網絡問題

00:38:20.267 --> 00:38:24.605 
你可能會遇到幾個網絡錯誤

00:38:25.005 --> 00:38:26.173 
其中一個

00:38:26.240 --> 00:38:27.741 
沒有網絡

00:38:27.975 --> 00:38:31.078 
如果你的App需要ODR內容
卻沒有網絡

00:38:31.211 --> 00:38:33.714 
那麼你需要準備好處理這種情況

00:38:35.048 --> 00:38:38.719 
您可能遇到的另一個問題
是資源不可用

00:38:38.785 --> 00:38:41.488 
這基本上意味着
我們認爲ODR的內容

00:38:41.555 --> 00:38:43.557 
在一個特定的位置
然而不是那麼回事兒

00:38:44.091 --> 00:38:47.227 
一般的原因 例如在公司內部

00:38:47.294 --> 00:38:50.130 
建立自己的服務器並有人管理

00:38:50.197 --> 00:38:52.366 
移動服務器文件等

00:38:52.533 --> 00:38:55.702 
但是還沒準備好
讓用戶使用App

00:38:56.170 --> 00:38:58.172 
所以要隨時準備應對錯誤發生

00:38:59.907 --> 00:39:02.442 
另一類錯誤可能會遇到

00:39:03.510 --> 00:39:05.012 
就是存儲空間有關的問題

00:39:06.280 --> 00:39:07.814 
所以ODR在任何時候

00:39:07.881 --> 00:39:12.786 
將允許你有最大的2G的應用空間

00:39:13.453 --> 00:39:15.489 
這意味着你的App
正在運行的時候

00:39:15.689 --> 00:39:19.126 
你已經調用標籤2G的

00:39:19.459 --> 00:39:22.396 
beginAccessingResources

00:39:22.696 --> 00:39:25.532 
用完後卻沒調用
endAccessingResources

00:39:25.599 --> 00:39:28.702 
你不允許NS Bundle
Resource Request

00:39:28.769 --> 00:39:30.304 
進行終止處理

00:39:30.604 --> 00:39:32.339 
所以佔用2G空間

00:39:32.673 --> 00:39:34.241 
然後你又去啓動另一個請求

00:39:34.441 --> 00:39:36.944 
你會再次得到一個請求錯誤

00:39:37.010 --> 00:39:37.845 
回叫反饋

00:39:38.312 --> 00:39:39.646 
所以要注意

00:39:41.348 --> 00:39:44.718 
當然我們可能在
本地存儲在設備上

00:39:44.785 --> 00:39:46.753 
遇到空間不足的情況

00:39:46.820 --> 00:39:48.188 
你就會收到通知

00:39:48.822 --> 00:39:51.158 
這可能是因爲你下載太多

00:39:51.225 --> 00:39:55.128 
或者你發出該下載請求太久

00:39:55.762 --> 00:39:57.497 
所以還是需要隨時準備
處理這些問題

00:39:57.564 --> 00:39:59.333 
這時候你可以採取一些處理步驟

00:39:59.399 --> 00:40:00.234 
你可以停止任何

00:40:00.300 --> 00:40:03.504 
不再需要的ODR內容的
Accessing Resources

00:40:04.671 --> 00:40:06.840 
另外 你可以看看本地設備上
儲存的是什麼資料

00:40:06.907 --> 00:40:08.642 
也許是一些緩衝數據

00:40:08.709 --> 00:40:10.444 
或者一些已不在需要用到的文件

00:40:10.878 --> 00:40:12.946 
你可以清理一下並進行刪除

00:40:15.949 --> 00:40:17.885 
那麼 現在我們來談談蜂窩數據

00:40:18.852 --> 00:40:21.588 
再次說明ODR App
是一款網絡型應用

00:40:22.189 --> 00:40:25.025 
因此需要使用到蜂窩數據開關

00:40:25.893 --> 00:40:28.028 
用於控制其他App的網絡連接

00:40:28.262 --> 00:40:30.097 
因此 如果關閉開關

00:40:30.163 --> 00:40:32.165 
那麼就不能獲取到ODR文件

00:40:33.467 --> 00:40:36.737 
如果開啓開關
並且你正在下載ODR內容

00:40:37.171 --> 00:40:39.773 
那麼通過蜂窩數據下載的任何數據

00:40:39.940 --> 00:40:42.843 
將算是該App產生網絡數據

00:40:43.577 --> 00:40:45.812 
因此 我們鼓勵大家一定確保

00:40:45.879 --> 00:40:48.415 
什麼是所需的 什麼是不再需要的

00:40:49.016 --> 00:40:50.884 
我們不希望用戶
產生高額的網絡費用

00:40:53.153 --> 00:40:54.021 
最後

00:40:54.421 --> 00:40:56.123 
100MB的蜂窩下載限制

00:40:56.190 --> 00:40:58.292 
仍適用於ODR App 

00:40:58.926 --> 00:41:01.395 
因此 要確認.app本身

00:41:01.461 --> 00:41:02.930 
和初始ODR的數據

00:41:02.996 --> 00:41:05.666 
是否超過App Store的
App體積限制

00:41:06.033 --> 00:41:08.135 
如果超過100 MB

00:41:08.335 --> 00:41:10.704 
那麼你的App不會
通過蜂窩數據下載

00:41:10.771 --> 00:41:12.506 
正如一般的App
超過100 MB的話

00:41:12.573 --> 00:41:14.174 
就不會通過蜂窩數據下載一樣

00:41:15.209 --> 00:41:16.043 
因此

00:41:16.210 --> 00:41:18.645 
需要注意App的大小

00:41:20.914 --> 00:41:24.017 
最後 正如前面所說

00:41:24.084 --> 00:41:26.687 
你們還需要注意一些
重要的統計數據

00:41:27.888 --> 00:41:29.022 
首先

00:41:29.556 --> 00:41:32.025 
雖然App Store現在可以儲存

00:41:32.492 --> 00:41:35.162 
超過20G的ODR App 

00:41:35.429 --> 00:41:37.030 
但是對於.app而言...

00:41:37.965 --> 00:41:39.833 
只有最高2g的空間

00:41:39.900 --> 00:41:41.335 
那麼 你的
.app本身如何呢？

00:41:41.401 --> 00:41:43.504 
請記得
當我們分解.app中的資料時

00:41:43.570 --> 00:41:45.472 
我們分解的資料包
那麼.app本身呢？

00:41:45.572 --> 00:41:48.008 
.app最高可以有2G

00:41:48.275 --> 00:41:50.878 
剩下的ODR內容可以有20G

00:41:52.813 --> 00:41:58.018 
另外 初始ODR和預取ODR內容
最高也是2G

00:41:58.085 --> 00:42:00.387 
該內容是我們在
Xcode的UI中設置的

00:42:01.121 --> 00:42:04.758 
用於在App安裝過程中
和後續過程中下載數據

00:42:04.992 --> 00:42:06.593 
你最高可以有2GB

00:42:06.827 --> 00:42:08.629 
合起來 2GB

00:42:10.531 --> 00:42:12.399 
正如我剛剛所說

00:42:12.466 --> 00:42:15.035 
只能在同一時間使用最高2G

00:42:16.837 --> 00:42:18.705 
最後 給定的資料包

00:42:19.039 --> 00:42:21.341 
最高可以有512MB

00:42:22.743 --> 00:42:25.379 
因此 如果使用一個標籤
標記一堆資料

00:42:25.546 --> 00:42:29.716 
且提及超過512M
那麼Xcode將發出警告

00:42:29.783 --> 00:42:33.320 
但是Xcode會允許你繼續
開發App或者遊戲

00:42:33.754 --> 00:42:36.623 
但是當你提交到
App Store之時

00:42:36.924 --> 00:42:39.560 
會收到提交失敗的錯誤信息
並解釋原因

00:42:41.395 --> 00:42:44.531 
好的 總結一下
On Demand Resources

00:42:44.598 --> 00:42:47.034 
是一款動態加載內容系統

00:42:47.835 --> 00:42:49.369 
服務器在App Store之中

00:42:50.137 --> 00:42:51.438 
這樣可以允許app...

00:42:51.672 --> 00:42:55.242 
在安裝期間自動和在有要求提出下
下載其內容

00:42:56.210 --> 00:42:58.445 
你可以對下載內容設置優先級

00:42:59.746 --> 00:43:01.181 
我們有了智能緩衝機制

00:43:01.248 --> 00:43:06.553 
因此當我們等級提升後
會爲後面的級別騰出空間

00:43:07.387 --> 00:43:09.489 
在App Store有
20G的空間供你使用

00:43:10.991 --> 00:43:14.461 
因此 如果想知道更多信息
我們有關於ODR一份新文件

00:43:15.128 --> 00:43:16.296 
還有簡單的代碼

00:43:17.030 --> 00:43:19.633 
以及開發者論壇可爲你答疑解惑

00:43:20.367 --> 00:43:21.468 
如果你仍有疑問

00:43:21.535 --> 00:43:24.137 
你可以聯繫我們的
App Frameworks專員

00:43:24.972 --> 00:43:26.740 
如果你錯過了

00:43:26.940 --> 00:43:30.611 
關於ODR大會等其他技術的大會

00:43:31.144 --> 00:43:35.249 
你可以到開發者網站去觀看視頻

00:43:35.883 --> 00:43:36.717 
接下來

00:43:37.050 --> 00:43:40.754 
會有一場託尼在星期五所說的
關於ODR進程

00:43:41.788 --> 00:43:45.726 
和實驗的大會
時間是明天11點到1點30

00:43:45.993 --> 00:43:49.329 
託尼和我以及
ODR工程組將出席會議

00:43:49.396 --> 00:43:51.064 
回答你們的任何疑問

00:43:51.131 --> 00:43:52.900 
幫助你們開始使用ODR內容

00:43:53.800 --> 00:43:55.769 
並聽取大家的建議

00:43:56.670 --> 00:43:57.504 
非常感謝