00:00:20.754 --> 00:00:23.524 
Xcode的app切割

00:00:24.191 --> 00:00:26.460 
早上好 我是安德斯

00:00:26.793 --> 00:00:30.531 
欢迎你们来参加404会议
Xcode的app切割

00:00:32.533 --> 00:00:35.602 
APP切割在这个舞台上已经多次提及

00:00:35.769 --> 00:00:40.107 
但从你们昨天
提出的问题和问题数量看来

00:00:40.174 --> 00:00:41.842 
很多人深感兴趣并且仍有疑问

00:00:42.509 --> 00:00:45.379 
所以在这个会议上我们会讲的更详细些

00:00:45.946 --> 00:00:48.081 
尤其是关于

00:00:48.148 --> 00:00:52.319 
当今
APP切割如何影响APP传播途径

00:00:52.553 --> 00:00:54.788 
我们会看看其工作原理以及改善

00:00:56.123 --> 00:00:57.090 
我们会讨论

00:00:57.157 --> 00:01:01.161 
如何进行高效的APP切割

00:01:01.628 --> 00:01:03.697 
减少内存占用率

00:01:05.632 --> 00:01:06.667 
然后我们要讨论

00:01:06.733 --> 00:01:08.135 
这对你工作流程的意义

00:01:08.302 --> 00:01:11.772 
当你在开发和测试应用以及
提交到App Store等过程中

00:01:13.941 --> 00:01:15.442 
现在我们快速浏览一下

00:01:15.509 --> 00:01:17.044 
当前的APP是如何传播的

00:01:17.744 --> 00:01:20.314 
你会使用
Xcode开发iOS系统app

00:01:21.281 --> 00:01:23.951 
然后测试并提交应用商店

00:01:25.252 --> 00:01:26.186 
当你提交时 

00:01:26.253 --> 00:01:30.157 
App会被标记上开发者证书

00:01:31.024 --> 00:01:35.229 
在经过检验后
App Store会重新证书标记

00:01:35.562 --> 00:01:37.531 
然后上架以供下载

00:01:40.234 --> 00:01:43.604 
然后有一台设备下载了你的App

00:01:43.670 --> 00:01:47.541 
这样设备就获得了你上传的的App

00:01:47.875 --> 00:01:49.409 
现在我们来看看里面的内容

00:01:50.644 --> 00:01:52.579 
首先 这是你的执行代码

00:01:53.180 --> 00:01:56.383 
这里有很多资源
几乎所有的东西都罗列在内

00:01:58.218 --> 00:02:01.221 
有些App代码很繁重 很多

00:02:01.288 --> 00:02:02.923 
资源也比较少

00:02:03.423 --> 00:02:06.226 
有些则正好相反 媒体文件较多

00:02:06.293 --> 00:02:08.529 
大部分是资源

00:02:09.596 --> 00:02:11.598 
我们举一个例子看一看

00:02:14.067 --> 00:02:19.373 
现在代码基本上
有两种版本64位或32位

00:02:19.439 --> 00:02:21.508 
实际上 还可能是RMV7

00:02:21.675 --> 00:02:24.478 
也包括NRV64切片

00:02:24.745 --> 00:02:29.416 
为了在
Apple硬件上运作良好RMV7

00:02:31.485 --> 00:02:34.021 
当然 资源中如果有图像的话

00:02:34.087 --> 00:02:38.625 
你会使用
1X 2X 3X或Retina

00:02:38.859 --> 00:02:41.361 
以使图像在各类设备上运行良好

00:02:44.198 --> 00:02:46.300 
你也许会想对图像进行一部分区分

00:02:46.466 --> 00:02:48.468 
分为适用iPhone的 

00:02:48.669 --> 00:02:50.003 
和适用iPad的

00:02:52.105 --> 00:02:56.543 
如果是
游戏app或者是3D图像型APP 

00:02:56.910 --> 00:03:00.714 
那么1X和2X在处理文本压缩和

00:03:00.781 --> 00:03:04.451 
文字模块方面并无太大意义

00:03:06.286 --> 00:03:09.957 
事实上 如果想利用
OpenGL AS和Metal语言

00:03:10.023 --> 00:03:12.759 
那么可能需要不同类型的资源纹理

00:03:12.960 --> 00:03:14.695 
而且还进行进一步的区分

00:03:14.761 --> 00:03:16.496 
优质和劣质文件

00:03:16.630 --> 00:03:20.300 
这样都能让设备在
不同内存大小上良好地运行

00:03:20.367 --> 00:03:24.438 
在任何设备上运行
取决于内存大小的图像清晰度

00:03:25.506 --> 00:03:26.907 
可能你还有声频资料

00:03:27.307 --> 00:03:29.710 
所以你还可能需要根据比特率进行区分

00:03:31.411 --> 00:03:35.482 
当然还有其他数据 像是游戏等级

00:03:35.782 --> 00:03:38.452 
又或者你的app需要认证文件

00:03:38.519 --> 00:03:40.554 
可能有些模板及其他一些信息

00:03:40.988 --> 00:03:45.259 
无法让设备进行区分
所有设备上都可能发生这种事

00:03:47.027 --> 00:03:49.596 
实际上
现在很多App都有所有类型的数据

00:03:49.930 --> 00:03:54.301 
所以你可能要费力进行归类

00:03:54.368 --> 00:03:57.137 
做好备注

00:03:57.304 --> 00:03:59.640 
这样相应资料才能安装在相应的设备上

00:04:01.008 --> 00:04:04.311 
这再好不过
这实际上就是APP切割的优势所在

00:04:05.145 --> 00:04:06.747 
如果你有一个iPad Mini

00:04:07.714 --> 00:04:11.018 
当它运行的时候 会运行RMV7切割

00:04:11.285 --> 00:04:13.654 
iPad等设备也是如此

00:04:14.688 --> 00:04:17.457 
另外APP切割所做的就是

00:04:17.524 --> 00:04:20.527 
在运行时决定加载资料

00:04:20.928 --> 00:04:22.296 
放到Store的资料

00:04:22.896 --> 00:04:25.666 
设备上的内容就是保存到设备上

00:04:26.033 --> 00:04:30.470 
始终保存在设备上
虽然不会在iPad1上下载

00:04:30.537 --> 00:04:34.942 
所以RM 64切割
无法在ipad Mini上使用

00:04:35.542 --> 00:04:38.345 
那么 
为什么要全部上传到Store中呢？

00:04:40.247 --> 00:04:41.982 
在App Store上

00:04:42.416 --> 00:04:45.953 
我们将为ipad
Mini预构建一个定制版本 

00:04:47.688 --> 00:04:50.657 
iPhone 6+也是如此

00:04:50.724 --> 00:04:53.927 
这时候 我们使用3X art
work RM 64等

00:04:54.428 --> 00:04:55.362 
此类的工具

00:04:55.796 --> 00:04:57.264 
值得注意的是

00:04:57.331 --> 00:05:02.903 
你仍会上传包括各种原图变体

00:05:02.970 --> 00:05:05.439 
和其他资源的通用APP  

00:05:05.772 --> 00:05:08.609 
于是在App Store里

00:05:08.675 --> 00:05:09.977 
切割就会发生

00:05:11.445 --> 00:05:14.147 
实际上 App Store的作用是

00:05:14.214 --> 00:05:18.752 
查看你的App能够支持的不同设备
即使不同设备特性

00:05:19.253 --> 00:05:21.788 
然后再查看App中的实际内容

00:05:21.889 --> 00:05:25.692 
以及你如何
使用1X 2X等工具进行标注

00:05:25.759 --> 00:05:30.163 
然后Store
会预制并分离被下载的IPA

00:05:30.230 --> 00:05:33.267 
我们来看一个已经看过的例子

00:05:33.500 --> 00:05:36.570 
这是个演示箱 曾在美国展示过

00:05:37.938 --> 00:05:39.673 
在这个例子中 我们有一个App

00:05:40.440 --> 00:05:42.309 
74兆字节的通用APP

00:05:42.743 --> 00:05:46.513 
适用于所有架构和设备

00:05:47.214 --> 00:05:50.717 
通过切割 我们得到16至29兆字节

00:05:51.084 --> 00:05:55.789 
平均在22兆字节的文件

00:05:56.156 --> 00:05:58.625 
我们在这款App上运行切割

00:05:58.892 --> 00:06:00.861 
实际上 其中产生了19种变量

00:06:00.928 --> 00:06:02.963 
包括不同的特性组合

00:06:03.330 --> 00:06:07.634 
这一些都在后台自动进行

00:06:07.701 --> 00:06:10.771 
而你只需对app内容进行标注即可

00:06:12.573 --> 00:06:14.408 
这是第一级保存 实在酷

00:06:14.675 --> 00:06:16.410 
但是 有改善的空间吗？

00:06:16.476 --> 00:06:18.245 
当然了 有

00:06:18.946 --> 00:06:23.517 
设备上有些资料是我们一直使用到的

00:06:23.584 --> 00:06:24.952 
首先 代码

00:06:25.352 --> 00:06:29.489 
那里可能会有一些原图比如故事板
当你启动你的应用程序

00:06:30.090 --> 00:06:32.693 
或者将原图添加到主菜单

00:06:32.759 --> 00:06:34.428 
让我们假设
你需要不断使用这些原图

00:06:35.729 --> 00:06:38.198 
然后还有其它这些东西  

00:06:38.265 --> 00:06:41.502 
这个应用程序之后会需要用到
但现在不需要用到

00:06:41.568 --> 00:06:45.506 
你之前听过的一个典型例子
比如游戏的第19级

00:06:46.106 --> 00:06:49.676 
正在玩游戏第一级的用户
还不需要19级的资料

00:06:50.544 --> 00:06:51.945 
同样地 还有其它例子

00:06:52.012 --> 00:06:53.747 
如果App是文件类应用

00:06:53.814 --> 00:06:55.482 
那么媒体模板就会比较丰富

00:06:55.816 --> 00:06:58.585 
你可能会想把这些推向市场

00:06:58.785 --> 00:07:02.422 
为了提供丰富的体验
你可能要有很多的模板

00:07:02.589 --> 00:07:05.826 
但是它们可能会占用很多空间
你可能会根据需要进行下载

00:07:06.560 --> 00:07:09.496 
对于音频工具也是这样的或者此类的

00:07:11.265 --> 00:07:13.467 
很好的示范例子是

00:07:13.534 --> 00:07:16.069 
许多用户看过一次就不再想让文件

00:07:16.136 --> 00:07:17.371 
占用设备的空间

00:07:18.739 --> 00:07:22.009 
如果我们看看我们以前讨论过的

00:07:22.342 --> 00:07:24.478 
应用切割其实应用已经进行简化了

00:07:24.545 --> 00:07:26.246 
因而只剩下一个结构

00:07:26.313 --> 00:07:31.785 
以及一种资源类型的质量变体

00:07:33.820 --> 00:07:37.090 
下一等级划分 我们可以做的只有

00:07:37.157 --> 00:07:41.728 
在了解应用程序的特定区域后才能执行

00:07:41.862 --> 00:07:44.531 
就是基于给定的时间所需要的资料

00:07:44.731 --> 00:07:46.700 
因为这些是基于你的代码逻辑

00:07:47.434 --> 00:07:51.405 
因此在这个例子中我们有图像

00:07:51.705 --> 00:07:53.607 
Metal着色器诸如此类的

00:07:54.007 --> 00:07:56.043 
我们可以把这些分为共享的

00:07:56.310 --> 00:07:59.446 
以及归入到
应用程序本身时刻所必须的一类

00:07:59.880 --> 00:08:02.850 
我们可以按需选择

00:08:03.951 --> 00:08:05.319 
通过划分

00:08:06.386 --> 00:08:09.156 
实际上你就可以减小

00:08:09.223 --> 00:08:12.259 
应用程序占用的基础空间
这样就可以保存更多文件

00:08:13.427 --> 00:08:17.264 
在这种特定的情况下
使用Xcode建立的

00:08:17.331 --> 00:08:20.634 
标记资源包就会被清除

00:08:20.801 --> 00:08:23.904 
保存到App Store中的IPA

00:08:24.972 --> 00:08:27.007 
你可以根据需要进行下载

00:08:27.608 --> 00:08:29.409 
你可以指定其中的一部分

00:08:29.476 --> 00:08:32.078 
作为初始下载 当用户下载展示的

00:08:32.145 --> 00:08:34.347 
应用程序并在进度条达到百分之百之后

00:08:34.982 --> 00:08:37.251 
应用程序就准备就绪了

00:08:37.351 --> 00:08:39.152 
App已经有了一些初始内容

00:08:40.453 --> 00:08:44.324 
你可以根据需要下载更多的内容

00:08:44.558 --> 00:08:48.195 
这已经不是存储在设备上应用程序包里

00:08:48.262 --> 00:08:51.698 
也不会备份到iCloud存储空间里

00:08:51.765 --> 00:08:55.335 
而是存储在系统内存中

00:08:55.936 --> 00:08:58.505 
系统可以进行高速缓存资源

00:08:58.572 --> 00:09:00.908 
并按需加载资源

00:09:02.242 --> 00:09:03.310 
因此在这种情况下

00:09:03.377 --> 00:09:06.613 
假如你在这个场景中
实际上我们会有更多的空间

00:09:06.680 --> 00:09:08.348 
而不仅只有三个等级的空间

00:09:08.415 --> 00:09:10.617 
我们可以有更多的等级空间

00:09:10.684 --> 00:09:12.419 
假如你不使用按需加载资源的话

00:09:12.553 --> 00:09:16.156 
当我们来到第四级系统会自动清理

00:09:16.223 --> 00:09:21.128 
最近使用过的资源包包括你的第一级资
源

00:09:21.695 --> 00:09:22.696 
对于第五级同样如此

00:09:24.164 --> 00:09:26.733 
如果用户有段时间没使用你的应用程序

00:09:26.867 --> 00:09:29.670 
以及其它需要下载需加载资源的App

00:09:30.037 --> 00:09:31.405 
则可进行空间回收

00:09:31.471 --> 00:09:32.873 
当应用程序再次被使用时

00:09:32.940 --> 00:09:34.141 
则再次自动下载

00:09:36.076 --> 00:09:38.979 
说说一些关于 按需加载资源的事

00:09:39.546 --> 00:09:43.116 
你通过
在Xcode中标记资源建立资源包

00:09:43.183 --> 00:09:47.421 
昨天你观看了一个简短演示

00:09:47.788 --> 00:09:51.425 
今天晚一点的时候
将会有一整个环节说明按需加载资源

00:09:53.594 --> 00:09:56.897 
资源包可以包含任何不可执行资源

00:09:57.664 --> 00:10:00.767 
应用切割在在资源类型下

00:10:00.834 --> 00:10:02.236 
资源目录起作用

00:10:02.302 --> 00:10:05.305 
通过按需加载资源
你可以下载任何的松散文件并标记它们

00:10:05.372 --> 00:10:07.941 
它们会成为资源包一部分
然后从App Store中下载

00:10:08.008 --> 00:10:09.676 
它们存储在App Store中

00:10:10.043 --> 00:10:12.579 
你把
它们一起提交到App Store

00:10:12.646 --> 00:10:16.416 
作为IPA的一部分
但是App Store会把它们分开

00:10:17.217 --> 00:10:18.318 
并单独存储

00:10:19.653 --> 00:10:22.856 
它们会根据代码在需要时被下载

00:10:23.257 --> 00:10:24.992 
它们作为必需品被回收

00:10:26.326 --> 00:10:29.229 
它们就像其它内容一样被切割

00:10:29.763 --> 00:10:32.366 
因此你可以把资源包放在这里

00:10:32.432 --> 00:10:36.436 
实际上 如果你在资源包里标记资源

00:10:36.503 --> 00:10:39.907 
Xcode会自动为你建立

00:10:41.208 --> 00:10:42.376 
在资源目录里面

00:10:45.078 --> 00:10:47.247 
我们来看下储存大小

00:10:47.314 --> 00:10:51.618 
对了 今天下午4：30分

00:10:51.685 --> 00:10:53.320 
在太平洋大厦会有一个会议

00:10:54.788 --> 00:10:58.192 
让我们看看 我们得到什么种类的储存
程序片切割后

00:10:58.525 --> 00:11:02.663 
我们得到的程序片平均为22兆字节

00:11:03.397 --> 00:11:04.531 
在这种情况下 

00:11:04.598 --> 00:11:09.670 
我们得根据核心app
下载5-11兆字节的内容

00:11:10.103 --> 00:11:13.173 
而资源本身则是11-18兆字节

00:11:13.240 --> 00:11:16.476 
关键是并非所有文件

00:11:16.543 --> 00:11:18.312 
同时存在在设备中

00:11:19.046 --> 00:11:21.748 
所以总量大约有8兆字节

00:11:21.815 --> 00:11:23.217 
这是一个非常精简的app

00:11:23.283 --> 00:11:27.387 
但你可以看到它是一个巨大的运用程序
尤其是它有大量媒体资源文件

00:11:27.888 --> 00:11:30.424 
更精简app的就会很有帮助

00:11:32.593 --> 00:11:36.496 
更小的APP更好的使用体验

00:11:36.930 --> 00:11:40.934 
有些设备有8GB的空间

00:11:41.001 --> 00:11:45.405 
我们会小心使用这些空间
没必要用的东西不会占用你的设备容量

00:11:46.940 --> 00:11:51.645 
通过app简化设备就可支持更多应用

00:11:52.713 --> 00:11:57.417 
更棒的是这同时也意味着
更短的下载用时 更少的电线传送

00:11:57.918 --> 00:12:01.822 
更不容易超过100MB的限制

00:12:03.924 --> 00:12:04.892 
这使你下载的应用

00:12:05.993 --> 00:12:08.128 
这意味着你可以使用

00:12:08.428 --> 00:12:11.098 
更多类型的设备而不受太多限制

00:12:11.164 --> 00:12:14.434 
如果你一直很想使用那种

00:12:14.501 --> 00:12:17.337 
不但可以在大功率设备上运行地很好

00:12:17.938 --> 00:12:20.707 
而且也可以
在低能耗设备上使用的Metal 

00:12:20.774 --> 00:12:24.178 
有更好的用户体验 那该怎么做呢 

00:12:24.244 --> 00:12:26.480 
下面这个能使你克服其中一些限制

00:12:26.547 --> 00:12:28.015 
你可以现在就提交 

00:12:28.081 --> 00:12:33.787 
提交到Store
和用户下载的体积都变小

00:12:36.056 --> 00:12:38.692 
这意味着你确实

00:12:38.759 --> 00:12:42.896 
可以长期利用回收的空间

00:12:42.963 --> 00:12:45.332 
处理之前因为容量问题

00:12:45.399 --> 00:12:46.733 
而不能安装的应用

00:12:46.800 --> 00:12:48.869 
这不是说你又得占据大量的容量 

00:12:48.936 --> 00:12:51.805 
相反的 这意味着当你面临容量不够

00:12:51.872 --> 00:12:55.709 
而又想放
更多的东西进app时可以更自由

00:12:57.878 --> 00:13:02.549 
现在 我想请我的同事帕特里克·海宁

00:13:02.616 --> 00:13:04.484 
来告诉你们具体如何做到这一点

00:13:07.721 --> 00:13:08.555 
谢谢你 安德斯

00:13:11.758 --> 00:13:12.793 
我是帕特里克·海宁

00:13:12.860 --> 00:13:15.095 
我想谈论一些关于
资源切割的更多一些细节

00:13:16.697 --> 00:13:18.632 
它的工作原理是什么呢

00:13:20.601 --> 00:13:22.202 
好吧 非常高兴告诉大家

00:13:22.269 --> 00:13:24.505 
资源切割和App简化已经无缝

00:13:24.571 --> 00:13:27.641 
整合到Xcode的开发
 输出和工作流之中了

00:13:27.708 --> 00:13:29.142 
也许你们已经很熟悉

00:13:29.209 --> 00:13:30.644 
如何开发应用

00:13:32.079 --> 00:13:35.916 
这一切的改善

00:13:35.983 --> 00:13:38.352 
可以让你真正
实现资源切割和App简化的关键在于

00:13:38.418 --> 00:13:44.024 
我们为产品开发和资源目录
设立工作流 

00:13:44.391 --> 00:13:49.296 
并同时考虑了
各种不同设备和变量从而方便开发应用

00:13:51.231 --> 00:13:53.500 
那么你需要做的是什么呢

00:13:54.701 --> 00:13:59.506 
如果你已经习惯使用
iOS的app 亦或者

00:14:00.707 --> 00:14:04.945 
习惯开发iOS应用

00:14:05.012 --> 00:14:07.214 
那么你们
会使用1X 2X 3X原图 

00:14:07.281 --> 00:14:11.285 
适应各类尺寸的屏幕 

00:14:11.818 --> 00:14:13.687 
甚至可能早就在使用

00:14:13.754 --> 00:14:17.090 
iOS 7的资源目录了

00:14:18.892 --> 00:14:20.327 
这一些确实也是你必须要有的

00:14:20.894 --> 00:14:24.431 
什么是资源目录 它们有什么作用呢

00:14:25.265 --> 00:14:26.967 
资源目录就是根据

00:14:27.034 --> 00:14:29.169 
资源的相关设备特征

00:14:29.236 --> 00:14:31.405 
进行资源组织的功能

00:14:31.505 --> 00:14:33.507 
因此非常重要且具有针对性

00:14:35.008 --> 00:14:36.577 
这里需要重点强调一下

00:14:37.211 --> 00:14:39.146 
为了能利用应用简化功能

00:14:39.379 --> 00:14:42.816 
你的资源必须处于资源目录内才行

00:14:43.250 --> 00:14:45.185 
我们无法处理松散资源

00:14:45.886 --> 00:14:50.257 
这不能限制这项强大功能

00:14:50.324 --> 00:14:51.592 
以后我们会进行改善

00:14:51.959 --> 00:14:53.026 
需要重点说明

00:14:54.895 --> 00:14:56.597 
所以我刚刚提到了设备特征

00:14:56.897 --> 00:15:00.767 
因为在资源目录内

00:15:00.834 --> 00:15:03.837 
资源可以用设备关键组特征进行优化

00:15:04.204 --> 00:15:06.306 
这包括你很熟悉的

00:15:06.373 --> 00:15:11.111 
屏幕分辨率
 2X 3X和其他系列设备

00:15:11.478 --> 00:15:15.816 
不管它是ipad还是 iPhone

00:15:18.285 --> 00:15:23.457 
更新
Xcode 7的iOS 9系统后 

00:15:23.790 --> 00:15:25.192 
我们在设备硬件特征的基础上

00:15:25.259 --> 00:15:26.727 
开发了一组设备特性

00:15:27.327 --> 00:15:30.998 
尤其是图片处理能力和内存级别

00:15:31.765 --> 00:15:34.201 
这确实引起了两个需求

00:15:34.268 --> 00:15:38.005 
第一 我们可使用的一系列设备

00:15:38.071 --> 00:15:39.540 
性能特点更多强大

00:15:39.606 --> 00:15:41.475 
从最低终端到最高终端设备各有不同

00:15:41.542 --> 00:15:45.579 
单一的资源并不适用于

00:15:45.779 --> 00:15:48.015 
所有类别的设备

00:15:48.315 --> 00:15:52.686 
对于最终的使用体验
会是怎样真的很难达成一致

00:15:53.153 --> 00:15:57.658 
这对高端和低端的内存级别都是一样的

00:15:57.858 --> 00:16:02.763 
新的设备特性使你能
给不同的功能制定相应的资源

00:16:04.831 --> 00:16:08.235 
资源目录里又有哪些内容呢 

00:16:10.571 --> 00:16:13.373 
好吧 目前为止 

00:16:13.440 --> 00:16:15.776 
在我们所推出的资源目录中 
最热门的是image

00:16:16.977 --> 00:16:21.715 
这主要是你应用里的原图资源

00:16:22.282 --> 00:16:26.353 
特别是位图资源和载体类型

00:16:26.420 --> 00:16:30.490 
你的图片可以是
png jpg或者pdf的格式

00:16:30.557 --> 00:16:33.794 
这些会先压缩以节省空间

00:16:33.861 --> 00:16:36.964 
编译成最佳的传送格式

00:16:37.030 --> 00:16:42.569 
然后通过
UI工具包的API传送到你应用 

00:16:46.373 --> 00:16:50.477 
iOS 9和Xcode7更新后有了

00:16:51.111 --> 00:16:53.080 
新的的数据类别

00:16:53.614 --> 00:16:54.882 
至少一个新的数据类别

00:16:55.549 --> 00:16:56.817 
那就是Name数据

00:16:57.751 --> 00:16:58.785 
这是用来做什么的呢

00:16:59.453 --> 00:17:03.390 
Name数据让你可以
随心所欲的储存文件内容

00:17:04.625 --> 00:17:06.660 
现在 可能你们会担心的事情是 

00:17:06.727 --> 00:17:08.362 
我们只是根据内容

00:17:08.428 --> 00:17:10.830 
对资源目录进行简化 

00:17:10.897 --> 00:17:14.601 
你们会问
如果我尝试简化非Image类的资源

00:17:14.667 --> 00:17:16.203 
这正是Name数据的作用所在

00:17:16.270 --> 00:17:20.440 
Name数据让你可以
在资源目录中随意放入文件

00:17:20.507 --> 00:17:23.310 
并根据硬件水平进行分类

00:17:23.377 --> 00:17:25.244 
正如我之前提到的

00:17:27.247 --> 00:17:30.584 
然后 在运行时 
可以使用OS X系统UI工具包

00:17:30.651 --> 00:17:35.722 
新的NSDataAsset
类别在app内进行内容检索

00:17:37.224 --> 00:17:39.092 
侧边栏在这里

00:17:39.393 --> 00:17:42.796 
资源目录的特征 

00:17:42.863 --> 00:17:46.800 
正如我描述的Name数据和其他特点

00:17:46.867 --> 00:17:48.368 
在OS X系统中也有

00:17:48.435 --> 00:17:50.637 
我们不会在OS X系统中

00:17:50.704 --> 00:17:53.807 
进行应用简化
但是在目录里储存资源制品格式可以

00:17:53.874 --> 00:17:55.876 
用于从所有目标上获取资源 

00:17:55.943 --> 00:17:58.345 
包括OS X系统和Watch

00:17:58.412 --> 00:18:00.347 
所有这些功能都能起作用

00:18:00.414 --> 00:18:01.615 
API在所有平台均可使用

00:18:01.949 --> 00:18:04.084 
简化只适用于iOS系统

00:18:04.651 --> 00:18:05.619 
侧边栏结束

00:18:07.254 --> 00:18:10.791 
在Xcode 7 和iSO 9
系统我们引入了另一种新的数据类型 

00:18:10.858 --> 00:18:14.761 
就是Sprite地图集

00:18:15.429 --> 00:18:21.802 
这意味资源目录
和SpriteKit已经实现整合

00:18:23.604 --> 00:18:26.373 
让你们可以使用一般的方式
可以让你分组图像资源

00:18:26.440 --> 00:18:28.408 
以一种普通的方式在资源目录内组织 

00:18:28.475 --> 00:18:30.444 
并重命名为Sprite地图集 

00:18:30.511 --> 00:18:32.412 
另外可以在创建时候

00:18:32.579 --> 00:18:36.884 
自动创建纹理地图集

00:18:36.950 --> 00:18:42.256 
从而在图像资源里
检索SK纹理地图集类型

00:18:42.890 --> 00:18:44.458 
一项关键功能是 

00:18:44.758 --> 00:18:49.696 
如果你已经在iPhone
iPad上完成常规组织 

00:18:50.063 --> 00:18:54.401 
那么它将自动创建

00:18:54.535 --> 00:18:57.971 
编译好的纹理地图集的简化版本 

00:18:58.105 --> 00:19:01.675 
然后作为简化资源 

00:19:01.775 --> 00:19:05.979 
与AppStore上和我稍后会谈到
的其他工作流简化的版本一致

00:19:07.948 --> 00:19:11.118 
那么我们如何
从资源目录中进行app简化呢 

00:19:12.553 --> 00:19:14.922 
好的 这实在很简单
也许大家已经猜到了 

00:19:15.222 --> 00:19:18.225 
每个资源目录中的资源都有标记 

00:19:18.525 --> 00:19:23.263 
用于描述资源相关特征
以及有用的特征

00:19:24.865 --> 00:19:28.268 
在创建之时当我们建立流程后

00:19:28.702 --> 00:19:31.004 
这些特征会在资源

00:19:31.071 --> 00:19:32.806 
和相关简化app变体之间建立路径

00:19:34.107 --> 00:19:37.678 
就是这么简单
我想要在这里重点说明一下

00:19:38.679 --> 00:19:41.081 
资源目录已经存在好一会儿了

00:19:41.148 --> 00:19:43.417 
它们可以让你能够在运行的时候

00:19:43.483 --> 00:19:45.986 
选择适合请求该资源的

00:19:46.353 --> 00:19:48.088 
设备的正确资源

00:19:48.155 --> 00:19:51.625 
在简化app变体路径方面

00:19:51.725 --> 00:19:55.195 
也是基于同样的算法
和一样的选择标准

00:19:55.529 --> 00:19:58.699 
如果你的
app今天在不同设备上工作正常 

00:19:58.765 --> 00:20:01.435 
那么app简化也同样工作正常 

00:20:01.735 --> 00:20:04.238 
因为它们使用同一个原理

00:20:06.707 --> 00:20:11.478 
好了我之前提到单词组织 

00:20:12.112 --> 00:20:13.780 
我想要再强调一下

00:20:14.114 --> 00:20:18.252 
有效对
资源目录进行归类绝对是关键所在

00:20:18.952 --> 00:20:19.820 
为什么呢？ 

00:20:19.987 --> 00:20:23.056 
因为对资源进行

00:20:23.323 --> 00:20:27.494 
大规模标注意味着
程序片变体中的冗余数据就越少

00:20:28.128 --> 00:20:32.699 
你不会
获取app变体产生的额外数据 

00:20:32.866 --> 00:20:35.802 
而这些数据在目标设备上运行时

00:20:35.869 --> 00:20:38.105 
是不会使用到的

00:20:39.373 --> 00:20:43.377 
例如 即使应用之前可以正常工作 

00:20:43.443 --> 00:20:48.248 
但是如果只是在一台设备上使用那么就
没有必要保留通用资源了 

00:20:48.315 --> 00:20:53.120 
考虑一下比如你的iPad上的应用有
自己的UI弹出按钮

00:20:53.187 --> 00:20:54.755 
是在iPhone上的应用

00:20:54.821 --> 00:20:59.393 
却不会在你的iphone上显示出来

00:20:59.459 --> 00:21:02.863 
通用资源的话可以使用可以显示正常

00:21:02.930 --> 00:21:07.034 
但是
现在我们可以重新访问并进行归类 

00:21:07.100 --> 00:21:09.970 
这样就无需
传送到iPhone版本的应用上 

00:21:10.470 --> 00:21:15.108 
因为在那里没法显示
好的

00:21:16.143 --> 00:21:17.644 
以上是基础的知识

00:21:17.711 --> 00:21:19.980 
关于该系统工作的原理

00:21:20.047 --> 00:21:23.784 
我们来举个例子 
说说具体的工作流程

00:21:23.884 --> 00:21:25.085 
以及如何产生影响的

00:21:27.154 --> 00:21:28.622 
首先说说创建

00:21:28.689 --> 00:21:30.257 
你是如何创建资源目录的

00:21:30.891 --> 00:21:34.361 
创建资源目录内容的首要方法是

00:21:34.428 --> 00:21:36.496 
通过Xcode上的资源目录编辑器

00:21:38.131 --> 00:21:41.401 
在IDE上使用用户界面很简单

00:21:41.468 --> 00:21:43.570 
或许你对此很熟悉了

00:21:44.104 --> 00:21:48.408 
创建一个新资源

00:21:48.475 --> 00:21:50.811 
只需增加一个新项目

00:21:51.879 --> 00:21:53.647 
你可以看到这里有个值域

00:21:53.714 --> 00:21:56.717 
这里 你可以看到数据集 
图像集 Sprite地图集

00:21:56.783 --> 00:21:59.353 
以及其他平台的其他数据类型

00:22:01.622 --> 00:22:03.490 
当你将这增加到项目中时

00:22:03.557 --> 00:22:06.093 
你可以看到在左边
有一个组织数组和范围

00:22:06.159 --> 00:22:08.695 
显示的是设备特征
你可根据这些特征进行分类

00:22:08.762 --> 00:22:14.201 
并显示你想要的资料丰富性

00:22:14.768 --> 00:22:18.238 
将资源放到合适的源中

00:22:18.639 --> 00:22:20.974 
然后离开 前往种类完成了

00:22:23.277 --> 00:22:25.212 
好极了 用起来很简单

00:22:26.046 --> 00:22:30.284 
倘若你的团队无法在资源
产品里使用Xcode将会怎么样

00:22:31.652 --> 00:22:33.754 
倘若这是个游戏工作室

00:22:33.820 --> 00:22:36.990 
在现有资源工具链和管道上投资巨大

00:22:37.057 --> 00:22:40.694 
但对于创造出合适原图的

00:22:40.827 --> 00:22:43.397 
内容工程师或设计者来说
现有的资源工具链和管道

00:22:43.463 --> 00:22:45.866 
并不适合使用Xcode这将会怎样

00:22:46.800 --> 00:22:50.337 
很高兴的告诉你们我们考虑到这种情况

00:22:50.671 --> 00:22:53.740 
我们仔细地设计了资源目录特征

00:22:53.807 --> 00:22:56.610 
与简化相配使之适用于这些情况

00:22:58.045 --> 00:23:00.314 
我们特别地将它设计成

00:23:00.380 --> 00:23:04.151 
很容易从现有资源管道

00:23:04.218 --> 00:23:05.786 
导出图像集和数据集

00:23:06.787 --> 00:23:07.988 
如何做到这点呢

00:23:09.723 --> 00:23:13.193 
我们将通过
XC资源来源工件格式进行讲解

00:23:13.493 --> 00:23:17.698 
我很高兴的告诉大家
我们将进行文件编制和发行

00:23:18.098 --> 00:23:21.034 
使得外部工具链

00:23:21.101 --> 00:23:22.903 
可以很容易的执行这个格式

00:23:24.638 --> 00:23:28.575 
这算不上什么格式

00:23:28.642 --> 00:23:31.745 
因为它只是JSON标记上一个简单的
文件夹结构而且很容易配合使用

00:23:32.246 --> 00:23:33.814 
我想要强调的是

00:23:34.314 --> 00:23:39.853 
这并不是下面提到的这种格式
先创建 然后导入Xcode中

00:23:39.920 --> 00:23:42.055 
然后就变成了一个项目工件

00:23:42.456 --> 00:23:44.992 
这是源工件格式

00:23:45.058 --> 00:23:47.194 
在创建时 

00:23:47.594 --> 00:23:49.396 
Xcode创建系统就开始用来

00:23:49.463 --> 00:23:51.532 
处理和产生最后执行成品

00:23:53.500 --> 00:23:56.470 
我们来看看它的细节信息

00:23:56.904 --> 00:24:02.009 
来看看先前说过的
例子AirPlay图像原图

00:24:02.276 --> 00:24:03.944 
在磁盘中看起来是这样的

00:24:04.011 --> 00:24:05.145 
事实上 这就是格式

00:24:05.812 --> 00:24:06.780 
非常简单

00:24:06.980 --> 00:24:09.550 
它所包含的是一个文件夹命名约定

00:24:09.616 --> 00:24:10.984 
包含资源的名字

00:24:11.051 --> 00:24:13.654 
这是使用UI图像名称在代码中

00:24:13.720 --> 00:24:15.589 
重新得到的名字

00:24:16.490 --> 00:24:19.159 
随后文件夹里包含了单独原图源

00:24:19.593 --> 00:24:24.932 
我想指出的是
尽管在这个特别例子中

00:24:24.998 --> 00:24:28.435 
用了一个众所周知半标准文件命名约定

00:24:28.502 --> 00:24:30.771 
来显示比例系数和设备习语

00:24:30.938 --> 00:24:32.739 
但它并不需要

00:24:32.806 --> 00:24:34.675 
任何特别的文件命名约定

00:24:34.741 --> 00:24:36.944 
你可以使用任何工作流程

00:24:37.010 --> 00:24:38.679 
或工具链或任何你所喜欢的方法

00:24:39.346 --> 00:24:40.347 
为什么可以做到这样

00:24:40.547 --> 00:24:42.950 
因为在这个设计中

00:24:43.016 --> 00:24:45.452 
有重要的第三元素
即contents.JSON文件

00:24:46.920 --> 00:24:49.022 
contents.JSON文件

00:24:49.256 --> 00:24:52.593 
包含所有资源标记信息

00:24:52.659 --> 00:24:54.228 
并将信息连接在一起

00:24:54.294 --> 00:24:55.796 
并告诉系统

00:24:55.863 --> 00:24:59.533 
与特别资源有关的特性

00:25:00.200 --> 00:25:02.369 
来看看

00:25:02.903 --> 00:25:07.574 
先前在Xcode编辑器上显示的
AirPlay图标

00:25:07.641 --> 00:25:09.309 
现在看起来是这样子的

00:25:09.476 --> 00:25:11.378 
你可以看到 它非常的简单明了

00:25:12.045 --> 00:25:16.416 
这只是单独图像中的一个数组你可以看
到单独文件名称

00:25:16.483 --> 00:25:20.854 
然后是设备习语和比例系数标记信息

00:25:21.355 --> 00:25:24.691 
这些属性你看到的这些关键数值组

00:25:24.758 --> 00:25:26.693 
就是将被记录在

00:25:26.760 --> 00:25:28.295 
SES源工件格式中的东西

00:25:30.464 --> 00:25:34.968 
举个高一级的例子 名字数据

00:25:35.102 --> 00:25:38.705 
我们叫它数据集
不出所料 看起来很相似

00:25:38.772 --> 00:25:41.308 
再一次 里面有单独源的文件名

00:25:41.375 --> 00:25:44.411 
然后是通用型标识符

00:25:44.678 --> 00:25:47.614 
和存储器的属性

00:25:47.781 --> 00:25:48.815 
或显卡未来集类

00:25:50.284 --> 00:25:52.452 
你可看到 它真的很好配合使用

00:25:52.519 --> 00:25:54.454 
你可以看到它是如何操作的

00:25:54.521 --> 00:25:57.224 
如何命名文件名和属性

00:25:57.291 --> 00:26:00.227 
这也是为什么不管你在

00:26:00.294 --> 00:26:03.463 
数据集和图像集加入什么名字没有关系

00:26:03.530 --> 00:26:05.999 
重要的是
contents.JSON是正确的

00:26:08.836 --> 00:26:10.637 
你可以用它来做什么呢

00:26:10.704 --> 00:26:12.439 
这是用来做什么的呢

00:26:13.140 --> 00:26:16.043 
我来举个例子

00:26:16.109 --> 00:26:18.679 
假设有用Xcode创建的图像集

00:26:19.046 --> 00:26:20.514 
我将展示的这个假设工作流程

00:26:20.581 --> 00:26:23.650 
是在PhotoShop中
使用PhotoShop CC生成器

00:26:26.587 --> 00:26:29.556 
假设你的设计者创建了漂亮的原图

00:26:29.623 --> 00:26:32.826 
他们决定今天iPad是蓝色的

00:26:32.893 --> 00:26:33.961 
iPhone是红色的

00:26:34.027 --> 00:26:35.362 
这只是我们工作的方法

00:26:35.829 --> 00:26:36.964 
设计者有时会这么做

00:26:39.366 --> 00:26:41.468 
他们有漂亮的主文件

00:26:42.069 --> 00:26:44.471 
并在这里陈列所有这些变体

00:26:44.538 --> 00:26:47.274 
事实上 

00:26:47.341 --> 00:26:49.343 
他们用生成器工作流程
创建了主文件

00:26:49.409 --> 00:26:51.245 
打开图像资源生成

00:26:51.512 --> 00:26:53.981 
由合适的命名约定

00:26:54.047 --> 00:26:57.684 
构造他们的层级清单

00:26:57.951 --> 00:27:00.354 
默认层级直接导出到一个图像集

00:27:00.988 --> 00:27:04.391 
有一个生成器的特别版本

00:27:04.958 --> 00:27:08.428 
他们小心地进行扩展

00:27:08.495 --> 00:27:12.699 
这是产生
contents.JSON假想事例

00:27:12.966 --> 00:27:15.269 
这就是将从
PhotoShop工作流程中输出的

00:27:15.569 --> 00:27:17.738 
对于以前使用过生成器的人来说

00:27:17.871 --> 00:27:20.707 
他们很熟悉照片布局了

00:27:20.774 --> 00:27:21.842 
这是资源文件夹

00:27:22.009 --> 00:27:24.745 
里面有生成的图像集 

00:27:24.811 --> 00:27:29.716 
所有不同的原图实体
和contents.JSON

00:27:30.450 --> 00:27:33.921 
我们要做的仅是拖出图像集

00:27:33.987 --> 00:27:35.989 
并将图像集放到
XE资源文件夹下的文件夹中

00:27:36.056 --> 00:27:39.593 
之后就可以进入竞态

00:27:43.330 --> 00:27:47.534 
就这样简单说来就是
带Xcode项目的动态集成

00:27:49.469 --> 00:27:51.305 
唯一的要求是

00:27:51.371 --> 00:27:55.676 
从一个Xcode项目文件水平来说
你的项目必须有XE资源文件夹

00:27:55.742 --> 00:27:58.512 
这是唯一的要求

00:28:00.047 --> 00:28:01.982 
里面的所有内容

00:28:02.549 --> 00:28:06.019 
都必须有一个任意层级 任意结构

00:28:06.520 --> 00:28:09.022 
它必须符合图像集和数据集

00:28:09.089 --> 00:28:13.694 
你可以按照任意深度进行嵌套

00:28:14.261 --> 00:28:16.864 
你可以使用
受它支配的自己的文件系统组织

00:28:17.064 --> 00:28:19.166 
假设你正确授权图像集和数据集

00:28:19.366 --> 00:28:23.103 
在创建时Xcode将递归地下降层级

00:28:23.203 --> 00:28:28.408 
发现所有图像集 数据集
和传播地图集并自动进行创建 

00:28:31.044 --> 00:28:34.581 
现在你知道怎么创建资源目录了

00:28:35.115 --> 00:28:37.451 
现在进入下一步 创建

00:28:39.253 --> 00:28:42.456 
或许最普通最重要的创建工作流程是

00:28:42.789 --> 00:28:45.259 
坐在座位上
在Tether设备的app上作

00:28:45.592 --> 00:28:49.630 
或者你在模拟器上操作

00:28:49.696 --> 00:28:51.765 
此种情况下如何简化应用呢

00:28:51.832 --> 00:28:53.534 
很高兴的告诉你

00:28:53.600 --> 00:28:56.637 
创建和运行工作流程

00:28:56.703 --> 00:29:00.541 
可自动地为现有有效运作目标简化资源

00:29:01.074 --> 00:29:02.109 
在Xcode中

00:29:02.910 --> 00:29:05.312 
意思是说 每次进行创建

00:29:05.712 --> 00:29:07.681 
事实上它仅会对

00:29:07.748 --> 00:29:10.617 
你正在使用的目标设备分析

00:29:10.684 --> 00:29:15.989 
产生并自动创建适当的执行资源目录

00:29:17.424 --> 00:29:21.461 
所有的模拟器和设备均支持这功能

00:29:22.930 --> 00:29:25.566 
这是利用应用简化

00:29:25.632 --> 00:29:28.335 
绝佳的范例

00:29:29.736 --> 00:29:31.171 
这个功能是

00:29:31.238 --> 00:29:33.674 
由已经在目标编辑器资源目录显示的

00:29:33.740 --> 00:29:37.978 
新创建设置激发或控制的

00:29:38.145 --> 00:29:40.447 
仅在有效资源下启用创建

00:29:41.982 --> 00:29:43.650 
这很方便

00:29:43.717 --> 00:29:46.386 
倘若 你试着解决

00:29:46.453 --> 00:29:48.255 
一个由应用简化引起的问题将会怎么样

00:29:48.322 --> 00:29:50.591 
倘若简化全面影响了
特定的目标设备情况会怎么样

00:29:50.657 --> 00:29:54.862 
为此 你可以不断拨动开关

00:29:57.631 --> 00:29:59.833 
此创建工作流程的其他优势是

00:29:59.900 --> 00:30:03.070 
极大的加快重复编译

00:30:03.136 --> 00:30:04.238 
或增量编译

00:30:04.304 --> 00:30:06.673 
在应用内容繁多的时候尤其适用

00:30:07.007 --> 00:30:12.346 
它只处理并
只与当下适合目标的源进行匹配

00:30:12.412 --> 00:30:16.250 
当它创建一个应用的
普通版本时

00:30:16.316 --> 00:30:19.520 
并不需要像以前一样每一个都需做完

00:30:20.888 --> 00:30:22.256 
另一个重要优势是

00:30:22.322 --> 00:30:25.626 
对于一个特别设备或一组设备

00:30:25.692 --> 00:30:28.862 
可以很容易测试

00:30:29.263 --> 00:30:30.697 
若你想要理解

00:30:30.764 --> 00:30:34.334 
目录变动对简化输出的影响

00:30:34.401 --> 00:30:37.004 
整体创建应用的大小或
用户体验的其他方面的影响

00:30:37.237 --> 00:30:40.407 
你可以迅速变动这些目录创建并运行 

00:30:40.641 --> 00:30:44.811 
随后通过在其他设备
和Xcode中运行目标间进行转化

00:30:44.878 --> 00:30:49.550 
来检查其他设备
可以极其快速简单地测试这些变动

00:30:53.220 --> 00:30:56.590 
创建就讲到这里 接下来是什么呢

00:30:56.657 --> 00:30:58.325 
传播

00:30:58.392 --> 00:31:03.297 
这是简化应用的基本步骤

00:31:05.699 --> 00:31:08.468 
现在 有很多方法

00:31:08.535 --> 00:31:10.337 
可用来传播你的iOS应用

00:31:11.171 --> 00:31:13.307 
使你能够传播你的iOS应用

00:31:13.373 --> 00:31:15.542 
最大且最有效的一个 

00:31:15.609 --> 00:31:18.245 
当然是你的终端用户 顾客

00:31:18.312 --> 00:31:21.114 
通过AppStore
购买正在使用的用户这是最核心的 

00:31:21.181 --> 00:31:25.719 
安德斯提到
这是你提供普通IPA的地方

00:31:26.320 --> 00:31:27.888 
商店做了这个工作

00:31:27.955 --> 00:31:30.023 
处理了所有简化变体

00:31:30.090 --> 00:31:32.226 
当用户购买app时

00:31:32.292 --> 00:31:35.662 
它将从商店里自动选择适合设备的变体

00:31:35.729 --> 00:31:38.065 
下载并进行安装完成了 完全自动的

00:31:38.265 --> 00:31:39.233 
不需要操心什么

00:31:39.733 --> 00:31:42.202 
在发布应用前

00:31:42.536 --> 00:31:47.875 
你或许也想为beta C
测试者创造完全相同的体验

00:31:48.242 --> 00:31:53.413 
也可通过TestFlight支持测
试传播我们将通过简化传播

00:31:56.016 --> 00:31:58.652 
然后 当然有ad hoc和企业传播

00:31:58.719 --> 00:32:01.788 
这是个常用方法
可用来在你的组织中传播应用

00:32:01.855 --> 00:32:04.725 
或在你的组中进行QA测试其他事情

00:32:05.692 --> 00:32:08.695 
这是传播极其重要的一种方法

00:32:08.762 --> 00:32:12.499 
我们也在其中创建了简化支持

00:32:12.566 --> 00:32:16.003 
最后 还有已经更新的Xcode服务

00:32:16.637 --> 00:32:19.006 
和Ecos服务器

00:32:19.072 --> 00:32:21.675 
用来支持传播简化应用

00:32:22.042 --> 00:32:23.510 
随后 我会讲到更多细节

00:32:24.545 --> 00:32:30.017 
上述方法的自动化程度非常高

00:32:30.083 --> 00:32:31.885 
你无需做太多事情

00:32:32.252 --> 00:32:35.589 
等下要我要讲的是

00:32:35.656 --> 00:32:37.491 
Ad hoc企业解决方案

00:32:37.558 --> 00:32:40.894 
这里 你需要自己托管传播流程

00:32:40.961 --> 00:32:44.998 
你可能需要理解
他们是如何放到一起如何运作的

00:32:45.432 --> 00:32:47.134 
我们现在就来说这个它们是如何运作的

00:32:48.836 --> 00:32:52.039 
Xcode中已增加的一个功能是

00:32:52.206 --> 00:32:54.875 
现在 对于特别设备

00:32:54.942 --> 00:32:56.343 
你可以从组织器中导出

00:32:56.610 --> 00:33:00.480 
若你将测试一个创建或要将创建切换到

00:33:00.547 --> 00:33:02.149 
制定设备 非常管用

00:33:02.216 --> 00:33:05.052 
你可立即创建一个IPA

00:33:05.118 --> 00:33:07.521 
用于直接指向到特定设备和为特定设备
提供的组织器

00:33:10.991 --> 00:33:15.162 
未来 我们将为你提供一种方法

00:33:15.229 --> 00:33:19.166 
可在所有的兼容设备上

00:33:19.233 --> 00:33:22.936 
导出所有简化变体

00:33:23.003 --> 00:33:25.839 
为应用的所有
可能支持设备提供完整的传播单元

00:33:25.906 --> 00:33:27.174 
这很重要

00:33:27.241 --> 00:33:30.711 
你或许不知道或能够为

00:33:30.777 --> 00:33:33.013 
所有的设备生成所有的简化变体

00:33:33.080 --> 00:33:35.549 
你想要获得全组信息

00:33:37.384 --> 00:33:40.854 
事实上 它将做的是

00:33:40.921 --> 00:33:43.824 
处理你所有的普通app创建存档

00:33:45.993 --> 00:33:49.596 
生成适合所有不同兼容设备的

00:33:49.663 --> 00:33:52.099 
所有简化变体
并将它们放入一组产品中

00:33:54.234 --> 00:33:57.271 
现在 你有很多应用

00:33:58.038 --> 00:34:03.544 
你或许会问自己 何才能为设备

00:34:03.610 --> 00:34:06.446 
获取一个正确的应用 是个大问题

00:34:06.713 --> 00:34:09.716 
将app发送到企业和adhoc设备

00:34:09.783 --> 00:34:11.185 
最常用的方法是

00:34:11.251 --> 00:34:12.452 
空中安装

00:34:14.321 --> 00:34:16.723 
随后我会讲到这个
化配合使用并会讲到如何与简

00:34:16.790 --> 00:34:20.827 
第一步保存为ad hoc或企业传播

00:34:20.893 --> 00:34:25.899 
这很重要 包了传播显示选项

00:34:25.966 --> 00:34:28.768 
左下角的复选框

00:34:29.837 --> 00:34:30.904 
这是用来做什么

00:34:32.206 --> 00:34:34.007 
它的作用是

00:34:34.074 --> 00:34:37.678 
当Xcode在生成IPA的导出集时

00:34:37.744 --> 00:34:40.681 
它将为它所生成的每个app变体

00:34:40.746 --> 00:34:42.783 
生成一个含有URL的显示清单

00:34:42.850 --> 00:34:44.585 
它将通过app变体的支持产品类型

00:34:45.351 --> 00:34:50.924 
更重要的是 将编插入索引
由不同产品门类区分支持

00:34:51.592 --> 00:34:52.693 
取决于那app的门类

00:34:53.927 --> 00:34:55.161 
影响在于

00:34:55.395 --> 00:35:00.767 
当设备试图安装app时

00:35:00.834 --> 00:35:03.036 
使用空中显示PO清单

00:35:03.403 --> 00:35:06.139 
它将会过一遍清单为设备 

00:35:06.373 --> 00:35:08.942 
产品类型找到合适的URL

00:35:09.276 --> 00:35:12.045 
并对其进行安装 

00:35:12.346 --> 00:35:13.180 
这就是它的运作方式

00:35:13.247 --> 00:35:17.351 
概念上与简化应用商店
实际所发生的相类似

00:35:17.718 --> 00:35:20.420 
但所有的这些移动块

00:35:20.487 --> 00:35:25.125 
都是由你通过Xcode进行生成并在
Web服务器上进行托管

00:35:26.793 --> 00:35:28.962 
倘若更进一步将会怎么样

00:35:30.030 --> 00:35:33.367 
这就是
Xcode服务器持续集成服务所做的

00:35:36.637 --> 00:35:38.939 
Xcode服务器所做的是

00:35:39.006 --> 00:35:41.775 
为创建代管和传播简化app

00:35:41.842 --> 00:35:43.577 
包括代管按需资源包

00:35:43.644 --> 00:35:45.012 
将我刚描述的原理

00:35:45.245 --> 00:35:48.582 
变成完整解决方案

00:35:51.318 --> 00:35:52.853 
非常简单

00:35:53.187 --> 00:35:55.923 
Xcode服务器
你在Xcode中创建集成盒

00:35:55.989 --> 00:35:59.493 
与Xcode服务器展开配合使用

00:36:00.360 --> 00:36:03.497 
项目自动创建应用

00:36:03.564 --> 00:36:06.667 
生成变体生成显示P清单

00:36:07.134 --> 00:36:09.636 
甚至在你在Xcode服务网站上

00:36:09.803 --> 00:36:13.473 
选定设备和选择特别创建的地方

00:36:13.674 --> 00:36:16.410 
覆盖web服务你所需做的

00:36:16.610 --> 00:36:18.245 
只是点击安装按钮

00:36:18.445 --> 00:36:20.614 
以及我先前所描述的
对显示P清单进行定位

00:36:20.681 --> 00:36:22.482 
牵引合适变量的所有原理

00:36:22.549 --> 00:36:25.719 
它是自动进行的

00:36:26.453 --> 00:36:30.324 
将设备指向Web服务并运行很简单

00:36:30.557 --> 00:36:33.126 
我鼓励你来看一看这个 尤其是

00:36:33.193 --> 00:36:35.195 
感受一下所有的一切是如何运作的

00:36:35.863 --> 00:36:39.166 
我鼓励你看看

00:36:39.233 --> 00:36:43.337 
这个模式和你在进行托管可能用来创建
你自己的企业传播工作流程

00:36:43.403 --> 00:36:48.242 
或ad hoc
传播工作流程的模式是相同的

00:36:48.976 --> 00:36:51.044 
所有的这些你都可以自己创建

00:36:53.447 --> 00:36:56.850 
整合各功能的Xcode服务

00:36:56.917 --> 00:36:59.753 
是使用空中显示的简化app变体的

00:36:59.820 --> 00:37:02.623 
一种流线型的安装方法

00:37:03.490 --> 00:37:07.127 
漂亮简单的解决方案  一站式

00:37:09.663 --> 00:37:12.099 
好了 我们刚讲的是

00:37:12.165 --> 00:37:14.868 
如何创建资源目录从而进行app划分

00:37:15.002 --> 00:37:16.703 
我们讲了

00:37:17.204 --> 00:37:18.939 
它如何与你的创建工作流程相结合

00:37:19.106 --> 00:37:21.375 
我们也讲了传播的不同方法

00:37:21.441 --> 00:37:23.010 
app简化如何与它们相互作用

00:37:23.911 --> 00:37:25.245 
现场交给安德斯

00:37:25.312 --> 00:37:27.114 
请安德斯为我们做总结

00:37:31.985 --> 00:37:32.819 
谢谢你  帕特里克

00:37:35.322 --> 00:37:37.491 
好了 在这部分 我们看了 

00:37:37.558 --> 00:37:40.460 
app传播工作流程是如何运作的

00:37:41.862 --> 00:37:44.164 
以及如何改进app简化

00:37:46.099 --> 00:37:49.269 
你可以帮助它变得更加有效的方法

00:37:49.336 --> 00:37:55.409 
当你恰地标记资源和传播特征

00:37:56.510 --> 00:38:01.048 
对于你的工作流程来说
在测试及提交到App Store

00:38:01.815 --> 00:38:04.017 
这意味着什么在这里需要进行一些操作

00:38:04.518 --> 00:38:05.352 
你所应做的是

00:38:05.786 --> 00:38:08.522 
不断开发资源的定制版本

00:38:08.589 --> 00:38:11.358 
太好了 为你想开发出最好的app

00:38:11.425 --> 00:38:13.594 
并在所有的设备上运作良好

00:38:13.894 --> 00:38:15.095 
使用app简化

00:38:15.162 --> 00:38:17.898 
现在稍微放宽了上传大小限制

00:38:18.565 --> 00:38:22.135 
每个用户将只获得他们所需的

00:38:23.170 --> 00:38:25.506 
不断开发资源的定制版本

00:38:26.240 --> 00:38:29.643 
使用资源目录使你的资源系统化

00:38:29.710 --> 00:38:33.447 
正如帕特里克提到的 你可以
在其中放置数据和Sprite地图集

00:38:33.514 --> 00:38:37.384 
且这些可根据设备进行改变

00:38:39.386 --> 00:38:42.356 
同样地
使用Xcode测试你简化app变体

00:38:42.789 --> 00:38:44.491 
这个现在变得很重要

00:38:44.558 --> 00:38:45.993 
因为我们是

00:38:46.059 --> 00:38:47.628 
根据每个设备所需进行资源传播的

00:38:48.161 --> 00:38:51.231 
正如帕特里克所提到的
你可通过使用Xcode目标做到这个

00:38:51.298 --> 00:38:56.737 
使用Xcode
服务器创建多样的简化变体

00:38:56.803 --> 00:38:59.006 
并在真实的设备上进行测试

00:39:01.675 --> 00:39:06.480 
充分利用按需资源 资源进行标记

00:39:06.547 --> 00:39:08.849 
使它们成为按需加载

00:39:08.916 --> 00:39:11.118 
资源包的一部分

00:39:14.087 --> 00:39:18.692 
我将检索数个地方以获取更多信息

00:39:18.992 --> 00:39:21.094 
一是app简化指南

00:39:21.161 --> 00:39:23.630 
app传播指南中的章节

00:39:24.364 --> 00:39:27.434 
可在Apple的开发者网站上找到

00:39:27.601 --> 00:39:30.270 
另一个是资源目录格式文件

00:39:30.337 --> 00:39:32.673 
这个将
会放到Apple的开发者网站上

00:39:35.008 --> 00:39:36.543 
我们有相关联的会议

00:39:36.610 --> 00:39:37.845 
第一部分已经有了

00:39:37.911 --> 00:39:39.246 
你可以通过录像进行了解

00:39:39.913 --> 00:39:42.716 
另一点是
SpriteKit有什么新特性

00:39:42.783 --> 00:39:46.553 
这个在20分钟后

00:39:47.187 --> 00:39:51.358 
会详细讨论

00:39:51.592 --> 00:39:53.393 
它侧重于按需资源部分
今天4:30在太平洋大厦进行

00:39:53.460 --> 00:39:55.028 
我鼓励你们参加这会议

00:39:55.429 --> 00:40:00.067 
明天1:30在Mission会议上

00:40:00.501 --> 00:40:02.836 
将详细讨论DemoBots

00:40:03.704 --> 00:40:04.938 
我们有许多实验室

00:40:05.005 --> 00:40:07.908 
欢迎来我们的实验室学习更多信息

00:40:07.975 --> 00:40:09.776 
继续观看WWDC的其他部分