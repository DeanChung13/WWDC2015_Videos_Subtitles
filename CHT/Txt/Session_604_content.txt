SpriteKit 新功能 
大家好歡迎來到“SpriteKit新功能 ”講座
今天 我們將要告訴大家一系列很棒的
新功能和改進
我知道在座的各位中有很多人是第一次來聽SpriteKit講座
首先 我想要花幾分鐘來
回顧我們所要講的是什麼
SpriteKit是蘋果2D遊戲和圖形的框架
我們將給你提供集成的物理運動 
離子運動模擬 動作
以及動畫 當然 還有計算機子圖
我們啓動（這個項目）是想要將SpriteKit做得不僅僅是強大
而且要非常容易上手使用
我們希望一個之前完全沒有做過遊戲的人
能夠來到我們的平臺
開始使用SpriteKit
並且能夠花很少的時間得到提高並熟悉（SpriteKit）
我們非常期望能夠傳達出一些東西
能夠使你專心致志地做你最擅長的事情
那就是做出最棒的遊戲
我們將SpriteKit設計成
可以在iPhone、iPad以及Mac上工作
並且你也能夠通過這個平臺將你的app
應用到多個平臺上這也就意味着
你能夠直接在Mac上設計原型
並測試你的SpriteKit遊戲
在你將它（遊戲）安裝到一個設備上之前
可以說 有了SpriteKit 遊戲構架的開發能夠做到事半功倍
在剛開始的時候我們花費了大量的精力在我們的工具上
在後續的幾年裏我們也在持續地進行投資
就是爲了能夠
讓你能夠像編輯整個畫面一樣編輯粒子效果
直到今年年初也同樣
能夠對運動和動畫進行編輯
只需要在寫代碼前
加入一段Xcode即可
現在 我們可以開始講解這個構架有哪些新功能了
第一點 也是開發人員強烈要求的一點
就是視窗
視窗是指
當我們在討論你的場景的時候這部分（場景）是可見的
在任何時候通過SpriteKit視角
現在的這種工作方式是如果你想要移動你的鏡頭
你不得不移動你遊戲中的每一塊幾何圖案
或者如果你想要跟隨你的一個英雄人物
穿越你的整個遊戲界面
你就需要做這些計算
現在這樣的工作
但是它並不像我們想象中的那樣直觀
如果你想要對這些遊戲實體進行物理模擬 
當你移動他們的實際位置時
你可以從中看到一些僞影
我們認爲我們能夠做的更好
接下來我們介紹SKCameraNode.
通過CameraNode
我們允許你能夠簡單的指定你看到的部分
變得可視化 鏡頭通過
展現你的場景中所包含的
可視化中心來達到這樣的效果
這樣你就可以在你的畫面中任意移動
CameraNode
同樣的你也可以在你的畫面中移動其他的
所有的遊戲實體
我們在SKScene中設置了一個屬性
這個屬性將允許你選擇你想使用的包含這些場景的鏡頭
在你的場景中你可以選擇多個鏡頭
同樣你也可以通過屬性選擇活動的鏡頭
如果你不理會屬性 即其缺省值爲零
我們將會保存所有你今天的使用記錄
並且所有的SpriteKit渲染效果
都和從前一樣不會改變
但是SKCameraNode中最棒的功能是
它作爲一個節點存在
這就意味着你能夠使用SpriteKit節點中
所有偉大的功能
你可以訪問我們的動作數據庫
這樣你就能夠在鏡頭上運行這樣的動作（數據）
你也可以使用我們的約束系統
這樣你就能夠對鏡頭進行約束
你可以讓它與遊戲實體相結合
你也可以讓它總是保留在
距離你遊戲中物體的一定範圍內
除了移動鏡頭之外你還能夠通過這些節點的屬性
來控制旋轉和尺度
例如
在這樣一個遊戲中 
我想將鏡頭放到一旁
我可能應用一些移動動畫
來揭示我的視線中有壞人
在我將我的遊戲角色放在視線中央之前
之後我可以應用一些尺度命令 
來實現鏡頭的變焦操作
我甚至可以使用我們的跟蹤路徑運動
如果我想要鏡頭跟蹤一個貝塞爾曲線
如果我真的非常想讓我的用戶感到噁心
我可以旋轉鏡頭
或者將鏡頭在場景中到處扔來扔去
所以現在在SpriteKit中你完全可以控制你的遊戲
哪些部分是可見的
我認爲這將會是你的工具中的一件很棒的新品
對鏡頭的改進
同樣的我們也針對音頻做了很多工作
我們添加了一個SKAudioNode
允許你在你的SpriteKit遊戲中
添加位置和環境的背景音
我們藉助了我們去年發佈的Apple強大的
AV音頻引擎構架
如果你對這個並不熟悉
它允許你指定你的語氣音量
並能夠作爲特定環境中的聲音發射器
它可以回放你制定位置
偵聽器獲得的聲音
在SpriteKit中我們將爲你做好所有的畫線工作
所有你需要做的工作就是通過文件名或者URL指定
你想要播放的背景音樂
我們將會使用AudioNodes 
跟隨你指定的偵聽器的位置在你的場景中定位
並畫出音頻曲線 讓你能夠更容易地
身臨其境地在遊戲中定位你的音頻
如果你想深入一點 親自動手
你也可以通過底層AVAudioNode的
一個節點的屬性 去掉所有的約束
在那裏設置所有的你想要的東西
爲了掩飾這種效果
你能夠使用
最新的技術將其添加到你的SpriteKit遊戲中
現在我又一個例子
這裏是我的製作的一個地精
我打算讓他作爲我的聽衆
所以我把我的偵聽器位置放在這裏
我已經在我的場景中添加了一個火球
這是我的音頻資源
在這裏我已經將其作爲一個SKAudioNode添加了進來
我重新播放這個音樂的時候
注意聽這個音頻的效果怎麼樣
當火球在整個場景中來回運動的時候
你能夠注意到
它變得更加飽滿 更加集中 聲音也更大了
當它靠近我們的偵聽器時
從遠到近
直到來到場景這一邊現在我們聽一下
很酷 不是嗎？
除了這些額外的設置
我不需要做任何事情來處理這些特效
當他們在遊戲場景中運動的時候他們已經和
驅動遊戲運行的邏輯聯繫在了一起
同樣的今年我們也重點關注了引用和實例化
我們知道你花了很多時間爲你的遊戲設計
內容和動畫 我們也希望你能夠在
任何你想用的地方重新使用這些內容
我們將允許你能夠爲你的節點和動作創建序列化數據文件
創建序列化數據文件
並將其作爲一個引用參數添加進來
而不是簡單的加載到你的場景中
這樣
你每次對資源文件進行修改之後
將會自動地對你的遊戲內容產生影響
我怎麼做這個節點呢?
我設計了一部分場景作爲節點
可以是一個背景元素或者是Xcode編輯器中的一些畫面
接下來我可以通過Xcode將這些文件
拖放到主場景中
接下來它會自動地創建一個參數
這些都是爲你設置好的
如果你想寫代碼來完成這些事情同樣可以
你可以手動構建一個SKReferenceNode
爲其分配一個文件名或者URL
當這些內容在你的遊戲中是第一次發佈時
我們會將你的包中這些內容的最新版本的
文件進行上傳
我們同樣能夠這樣處理一些動作
通過這些動作作品
能夠看出我們的新動作編輯器是多麼的偉大
同時那些你在Xcode中創作的動作你都 有命名的權利
這些名字將是你在遊戲中使用它們時候的關鍵字
我們在SKAction中添加了
一個名叫actionNamed的篩選器
它的作用就像
textureNamed對於SKTexture一樣
你可以輸入你想要的動作的名字
我們將自動在你的App包中的
序列化動作文件中 找到
一個最合適的文件
然後將其在應用程序中呈現出來
在你的遊戲中請頻繁使用這個功能
我們做了所有的關於內存的工作
我們可以保證你的遊戲中所有相同的動作絕對不會
從硬盤中重複地加載多次
有時候你可能會想要讓同一個動作重複多次
但它會播放得時快時慢
我們添加了一個額外的選擇器
它將允許你能夠覆蓋操作的持續時間
這是一個智能時間軸
所以即使你使用的是嵌套組和序列中的嵌套 動作
它將動態規劃新的時間軸
這樣 每個時間區間內的動作組件
都將會是一樣的大小
這些都是爲可重複使用組件設計的工具
這些可重複使用組件你可以在同一個遊戲的同一個場景
或者跨越多個不同的遊戲中使用
我們同樣在構架中添加了一系列新的動作
所以現在我們有了這些位置AudioNodes
就能夠通過動作更好的控制回放
我們已經添加了播放,暫停,回放速度
以及操作體積和立體平移等開關
我們也在幀動畫中做了一些改動
在SpriteKit中我們一直都有通過紋理動作運動
做出來的基於幀的動畫
但是去年我們在SpriteKit中引入了lighting
通過lighting
你不僅能夠在你的場景中爲Sprites自動生成
也能夠自主添加常規的紋理動作
然後我們可以在運行時動態的點亮他們
通過在你的場景中移動光節點
這種做法對於穩定的元素來講很方便
但是如果我有一個基於幀的動畫例如這個東西
我們想要這些高亮和陰影部分
在當前位置分開
我們不想要腿前面所在的區域高亮
所以 我們添加了一個
正常紋理運動的動畫
所以你可以使用這個 在正常的動畫
與每一幀之間 進行同步
如果我在我的人物上運行了這種動畫並給場景添加了lighting
你就會看到所有的高亮區域 陰影都能與每一幀保 持同步
無論我的人物如何跑動
這些就是我們添加到構架中的新功能
我們也做了很多其他的工作使這些功能能夠與
系統的其他部分更好的結合在一起
更好的發揮已經添加到我們平臺上的
新硬件和構架的優勢
首先我想講的是Metal
我們正在開發SpriteKit
並且我們正準備將它直接鏈接到IOS和 Mac的Metal平臺上
將能夠在任何支持Metal的設備上使用
以及那些不會自動降級到OpenGL的設備上
這意味着你的CPU使用率會降低
這意味着作爲一個開發人員你將會得到更好的繪製調用性能
以及更好的電池使用壽命
因爲將能夠做到零運動請求
我們將自動升級所有的SpriteKit程序
你不需要重新編譯
或重新提交
只要它支持Metal 你就能夠運行
如果你對自定義着色器感興趣的話
我們也同樣顧及到了
如果你的遊戲中有自定義着色器
我們幾乎支持所有的Metal變體的升級
同樣能夠在支持Metal的設備上很好地運行
接下來是Swift
我們看了整個API的文件
並且我們向其中添加了可空性限定符
我們採用了Objective-C泛型數組類型
用作參數或者返回類型
這將是你能夠很方便的
從Swift中訪問SpriteKit的所有功能
這也能夠給你的軟件提供增強版的安全性
增強版的安全性無論你是使用Swift
還是Objective C
現在我想講一下SceneKit
或許你並不知道Scenekit
我們允許你用SceneKit體現SpriteKit
也可以用SpriteKit體現SceneKit
今年我們允許你能做到的更多一點
可以直接在SceneKits遊戲中使用
所有你知道和你喜歡的SpriteKit過渡效果
你甚至都不需要用SpriteKit去做
你可以像使用門一樣使用這個轉換器剪輯
甚至你的SceneKit遊戲中基於轉換效果的核心圖片
同樣能夠有很好的效果
這個版本的SceneKit同樣支持
Metal背景下的內容
我們可以自動匹配好
如果你有一個支持在Metal上運行的SceneKit遊戲 
我們通過使用Metal
可以使你得到SpriteKit內容
去過你有一個支持GL上運行的SceneKit遊戲
我們可以通過使用OpenGL使你得到SpriteKit
你永遠不會產生額外的開銷
在兩個API之間進行轉換時
今年我們也發佈了一個全新的構架
叫做 GameplayKit
這個構架很棒
它將提供給你創建一個遊戲邏輯結構所需的所有基礎
就像Entity/Component系統一樣
作爲狀態機
而且還提供了非常棒的工具
例如AI對手和確定性隨機源
有一點我非常喜歡
那就是它能夠爲你的遊戲提供一個路徑尋找的解決方案
我相信很多SpriteKit工程師會對這個功能感興趣
GameplayKit中尋路的工作方式是
你指定一個可穿越的導航圖
在你的遊戲世界中
之後你將會在這些節點之間連線
並給出一個相關成本
只要你給出了這個地圖
GameplayKit 將計算出地圖上
這兩個點之間的最優路徑
我怎樣在遊戲中設置呢？
加入我這裏有一個SpriteKit遊戲
我的英雄在下面的這個角 我...嗯…
假如我想讓他移動到某一個目的地
然後在我的地圖上指定幾個障礙物
障礙物是不可穿越的地區
將這些數據給GameplayKit之後
給我的想要穿越地圖的角色周圍設置一個緩衝半徑
GameplayKit 會將緩衝半徑計算進去
自動擴展所有的障礙物
這樣我們不會進入任何障礙物的緩衝半徑中
然後在地圖中創建有效的連接圖
並且只創建有效的連接
所以我們永遠不會穿越這些障礙物
然後你就可以在你的遊戲中使用這些來進行
尋路操作
這個功能並不專屬於 SpriteKit
所以你可以在SceneKit中使用GameplayKits
SpriteKit, OpenGL, Metal
等等任何類型的遊戲都可以
如果你使用的是SpriteKit我們可以使它變得更容易
你甚至都不需要創建障礙物
你可以使用Sprite界限直接創建障礙物
你可以根據你在Sprite上設置的物理主體
創建障礙物
甚至從與你遊戲中Sprite相關紋理的
Alpha透明度信息中創建障礙物
這給了你一種非常簡單的在SpriteKit軟件中利用
GameplayKits尋路的方法
就像我之前說的
構架只是我們工作的一部分
今年我們對我們的工具進行了大量非常棒的改進
接下來我想將這些交給Norman
來講解
謝謝你 提姆
開發遊戲是一個複雜並且不斷迭代的過程
遊戲的各個部分需要像玩遊戲一樣不斷迭代
以保證一個遊戲的趣味性
動畫 用來確保一個角色移動的流暢性
藝術性 用來保證屏幕上的像素點
能夠流行起來
作爲一個遊戲工程師你不僅會遇到迭代問題
你還會遇到可伸縮性問題
我要怎樣才能跨越多個等級複製我的設計呢？
在蘋果公司我們當初啓動設計SpriteKit 的工程時
我們不僅想要爲你提供一個高性能
且易用的API
而且要爲你提供一個可伸縮和迭代的工具
這樣我們就能專注於開發遊戲
從SpriteKit 構架的第一個版本發佈
我們已經開發並
持續向Xcode中
添加了多個工具
讓我來給你們展示一下作爲一個SpriteKit用戶
你能夠使用哪些工具
第一個要介紹的是紋理地圖集
使用texture atlas的第一個主要好處就是
能夠提升性能
SpriteKit通過紋理地圖集將大量的圖片調用命令最小化
併發送給GPU以達到優化效率的目的
我們不想強迫我們的用戶適應手動
創建這些紋理地圖集的過程
每次對資源進行修改的時候
這些手動的過程都必須從頭再來一遍
所以我們開發了一個自動的紋理地圖集生成器
在Xcode中
創建一個這種地圖集
就像拖拽一個文件夾到你的工作區中一樣簡單
同樣的我們在開發的時候也會自動做一些事情
每一張資源圖片
都會自動經歷一個複雜的後期處理過程
例如我們會爲圖片修剪Alpha透明像素
但是這並不會在屏幕上有任何體現
如果旋轉90度能夠讓這些圖片更緊湊
或者能得到一個更小的地圖集的話 我們會進行這樣的旋轉
對於每一個資源圖片 
我們都會對其進行其邊緣的審查
如果其實完全不透明的
我們將會對其邊緣進行壓縮
當你在場景中堆疊這些圖片時
你不會看到任何接縫
這就是紋理地圖集自動生成器
今年我們將它做得更好了
現在你可以生成紋理地圖集
來代替資源目錄了
使用資源目錄生成地圖集
有兩個主要好處
第一
你可以精確地
爲你的目標設備
適配到合適分辨率的圖片
你不需要嚴格按照你的圖片名字的後綴來查找
例如添加2X或者添加2X到iphone
所有的這些都能在在UI中設計好
第二個
有點就是我們現在支持 ...
在資源目錄中
每一組的目標分辨率
將會根據他們設備的獨立紋理來生成
當用戶打開App Store
並下載下來你的SpriteKit授權遊戲時
只有與他或她的設備
相適配的地圖集纔會被下載下來
這不僅能夠使下載時的帶寬最小
同樣能夠使其安裝到用戶手機的時間最短
同樣能夠最小化應用程序的存儲開銷
另外 紋理地圖集支持基於命令資源
基於命令的資源是一個全新的API
它使你能夠在遊戲運行的情況下
從網上下載藝術資源流
SpriteKit也集成了這種功能
這種資源是通過標籤來識別的
例如
這是我的Inspector中的Xcode寫的背景元素
我可以指定一個與其相關聯的標籤
我把它叫做一級背景
這些就是標籤 你可以通過這些標籤
檢索這個資源
並且開啓背景流媒體
當你的程序調用它的時候
粒子效果
可以有效地幫助你準確的建立起遊戲
我們將這個構架中的SKEmitterNode
作爲一個強大且靈活的APIs
提供給你來使用
強大並靈活也有缺點
那就是你需要設置49個屬性
你需要對這49個屬性
進行排列組合
來達到你想要的視覺和感覺效果
你需要做的就是花費更多的時間
因爲我們在Xcode中
開發了一個粒子編輯器
它是使用同一個SpriteKit呈現驅動
可以讓你能夠
在你的工作區中直觀的看到它
所以你無需編寫任何代碼
就能夠對這49個屬性進行調整和改變
也無需重建你的遊戲
這些粒子將作爲一個很小的數據文件導出
並能夠被序列化
也能夠部署在多個等級或者多個項目中
SpriteKit同樣支持Quick Look.
例如 我正在努力學習新的Swift
我創建了一個全新的場景
並努力地在SpriteKit API中使用
全新的Swift 2.0語言
我正在做的事情就是創建一個壞蛋角色
就叫壞人 這是一個Sprite節點
它是一個叫做車罩的單獨紋理複製出來的
另外 我創建兩個子節點 
在這個壞人節點之下
一個有屋頂的紋理
另一個有樹幹的紋理
這裏會發生什麼呢？
SpriteKit的部分屏幕中將會呈現這些看不見的東西
當你努力去
內觀一個Sprite節點的時候
它會將結果爲你呈現在窗口中
這樣 你試着學習一個新的語言或者
更改一個對象的每一步都會呈現出來
你將會在窗口中看到實時的變化
另外SpriteKit中的Quicklook
同樣支持
在你調試程序的時候
無論你是使用Swift
還是Objective-C
無論他們是在IOS設備上運行
還是在Mac OS X上運行
這裏我想試着去調試一個我寫的程序
我觸發了一個斷點
目標過程其實停止了 
但是我們仍然能夠
隱藏這部分顯示並呈現出目前的紋理
並在調試器中顯示出來
所以你能夠清楚地知道
這個紋理是我之前調試的
並將它抓取出來分配給了一個SKSpriteNode
去年 IOS8中我們發佈了一個虛擬場景編輯器
他允許你建立一個完整的場景佈局
並不需要編寫任何代碼
你不僅可以設置場景中每一個
可選節點的位置 旋轉和尺度
你同樣可以定義其物理屬性例如
圖片 重力 質量和摩擦
你也可以進行這些物理仿真的
實時模擬
而這些並不需要你登陸遊戲或者重新編譯你的程序
SpriteKit也將支持一些先進的渲染技術
例如自定義着色器等
在這一層上 這個瀑布的背景和
霧的底部實際上我使用了
兩個自定義着色器
要添加着色器 
他就像打開幫助編輯器一樣簡單
它會自動在你的當前場景中顯示出來
當然這是渲染過後的
並向你展示附有源代碼的
助理編輯器
你在助理編輯器中
所做的任何實時的修改
都會自動進行編譯
打開OpenGL或者Metal
會爲你提供一個真正實時的視窗
而不是都建整個遊戲
跨越整個層
以及特定的節點
觸發這個事件來確定我是否真的發送了一個流給OpenGL或者Metal
無論是否編譯成功
這將節省很多迭代的時間
今年我們花了大量的時間來
對虛擬場景編輯器進行改進升級
第一個請求的類型是自定義的
現在 在我的英雄角色所處的這一層
我可以將它指定爲一個類
這個類的名字叫做角色類
當場景被反序列化運行時
無論你的程序是用Objective-C還是用Swift寫的
正確的類將會被創建並實例化
並加載到場景中 在場景運行的時候
另外
從SKNodes項目開始的第一天起
我們就一直忙於它的支撐工作
現在你能夠使用編輯其中的
鏡頭節點
音頻節點定位 
以及ReferenceNode
來設計你的場景
能夠在編輯器中看到鏡頭髮送
準確的時間軸、縮放因子
以及動作
而並不需要
編譯整個遊戲是多麼酷炫的一件事
你也可以
設置SKAudioNode的位置
並將之移動
來親自聽實時的音效變化
以確定你在場景中想要的效果是否設置正確
今年 前端工具中最激動人心的功能是
能夠設計
複雜的動作
你可以通過基礎構建模塊
設計出一個非常複雜的動作
我們已經將其作爲SpriteKit的動作部分提供給了大家
它是基於時間線的
和Xcode中的其他編輯器一樣
他也支持實時可視化
你不僅可以
用它來開發2D動作
也可以用來爲SceneKit設計3D動畫
都是同樣的編輯器
你也可以創建電影動畫
電影動畫可以作爲場景動畫的一部分
當場景加載的時候任何包含這種動作的節點
都會自動運行起來
你也可以創建交互式動畫
例如循環動畫
或者跳轉動畫從窗臺掉落
通過一行或兩行代碼出發摺疊動畫
在不同的遊戲場景中
這裏有一個場景
我將鏡頭設計爲移動的
現在鎖定遊戲角色
角色開始運動
運行行走動作循環
穿越整個場景 這就是開場
你也可以在五分鐘之完成這些
今年2D和3D的前端工具中
另一個主要關注點就是
能夠做引用和實例化
在SpriteKit上
一直是支持對動作或節點的引用
這些都是你場景中的藝術資源
這些都是可重複使用的組件
這些都是數據文件
能夠在不同的工程中
不同的人之間 不同的層次上共享
在使用這些引用文件時
你不需要寫任何代碼
創建引用動畫非常簡單
我們在Xcode中提供一種全新的SK動作文件模板
你可以打包一個純粹的動畫文件
設計好所有的複雜的動畫
將之命名
使這些動作可以被SKAction檢索
使用actionNamed選擇器
創建正確的實例並將之添加到你的場景中
任何引用的動作都將會被自動篩選出來
放到一個對象庫中
如果你想在不同的場景中
或者不同的層中
再次使用這些動作 這只是一個
從對象庫中拖放的問題
創建一個引用節點也很簡單
就像在你的工作區中拖一個SKS文件
放到你的場景中一樣簡單
對於這些引用
我們會自動在編輯器中
生成SKReferenceNode實例
併爲你分配合適的URL
你同樣可以使用API創建一個自定義節點收藏夾
例如 我有一個鳥籠
我打算用它作爲一個
不同的層之間的層道具
我可以在多個層之間建立起來
並將其實例化
任何對鳥籠原設計的修改
都會被自動地反映到
每一個引用了這個設計的實例中
這樣你就能夠在編輯器中手動地
修改和更新引用文件了
接下來我想邀請泰勒上臺來給大家
演示一下Xcode中的這些新功能
謝謝你諾曼
就像你看到的那樣
我們爲SpriteKit和Xcode 7增加了很多優秀的功能
我想通過展示一個簡單地例子向
你們展示它們是如何在你的開發流中集成工作的
這個例子展示了創建一個簡單的層添加場景
創建一些互動的遊戲等內容
好的看這裏 我剛剛創建了一個遊戲工程
我在這個工程中添加了一個層
我們創建了一些平臺和一個角色
我想做的第一件事就是在其中創建環境
添加一些背景和前景元素
放在從前我會直接在場景中做這些事情
然後一個個複製我所需要的實例
如果我需要修改一些東西的話這很快就會變得非常麻煩
因爲我需要對非常多不同的點進行修改
並且很難重複使用
現在我們用ReferenceNode
解決了這個問題
所以在這裏我創建了我的環境中
所需要的所有的元素並將其放在單獨的文件中
這樣我就得到了一個有瀑布的背景
和一個有霧氣效果的前景
引用這些內容文件所需要進行的操作
就是將其拖放到我的層中
現在 我們自動創建一個
包含所有元素的ReferenceNode你會注意到
前景的Z值被保留了下來
當我們將它添加到我的場景中的時候
接下來創建一些複製來填充起來這一層
你會注意到我複製了ReferenceNode
其本身
而不是我所引用的場景中的
單獨的元素
這在我之後的工程中會顯得很棒
例如 當我想要跟換背景紋理時
因爲它並不是特別合適
我做的這個平臺 
我不需要改變我現有的三個實例
我可以打開我單獨的資源
只需要做一次修改
改動的地方就會自動送給所有的實例
在這個層中
接下來
我想在我的層中創建一個跳轉場景
我會使用我們剛纔介紹的
新的動作編輯器來做
放在從前 你只能在代碼中創建動作
這非常不容易看到
所以我們想要開發一中編輯器能夠很容易的創建複雜的動作
並給你實時的
你正在創建的圖像信息
訪問動作編輯器
你可以點擊左下角的按鈕
你會看到顯示出來
你的場景中的所有節點以及時間軸
其中包含所有的動作
我們能夠看到我們的角色已經有了一個動作
這是一個由紋理動作組成的動畫
我們將它放在一個空閒的幀內
現在點擊播放
我們可以看到我們的角色在我們的場景中
動了起來
接下來在我們的層中創建一個跳轉場景
我們準備讓角色穿過這一層
要做到這些
我們需要過濾出來我們的玩家互動編輯器和
我們的對象庫中的動作
我們爲你提供了一組動作構件
可以用來創建更加複雜的動作
這正是我接下來要做到的事情
我們首先添加一個移動的動作
到我們的跳轉場景中
我需要做的所有事情就是拖放從對象庫拖放到時間軸中
現在對於這個運動
我們可以看到在X方向上有850個單位組成
我們想要將這個動作做得更緩慢更自然
現在點擊這個播放
我們可以看到我們的角色是這樣跑的
這有點快所以我們需要修改持續的時間
將這個動作拖長大概2秒
我想要調整一下時間軸
所以現在運行一下
這時的運動就有了一個更合理的速率
現在我想讓角色在穿越屏幕的時候跑起來
所以我要添加一個帶有紋理動作的動畫
要定義我們準備使用的動畫
我可以打開媒體庫
過濾下來我們的奔跑的框架
我可以選擇之後將其簡單地拖動到我們的運動中
現在我們運行一下
可以看到角色將會做這個動作
當然 如果我們只使用一次的話
我們可以添加一個循環
這樣就能在其移動的整個時間段中持續下來
我可以點擊角落裏的這個循環按鈕創建一個循環
我能夠看到
循環的所有控制參數
我可以增加迭代的次數 
也可以減少 也可以自定義循環
在這個例子中我想要讓它循環兩次
接下來我將調整一下持續時間來適應我們的運動過程
現在我們就得到了我們的角色跑着穿越整個場景的動畫
接下來 我們在層中添加兩個溝
讓這個角色跳過它們
在動作編輯器中我們可以定向清除我們動作中的時間點
在剛剛到達溝的旁邊的時候我可以清除掉
然後添加一個其他的動作
我們可以正好對齊我們剛纔擦除的地方
對於這個移動我們會在Y軸方向移動100個單位
我將其設置成緩慢輸出
這樣在到達我們跳躍的頂部的時候角色的動作會變慢
在到達溝的中間的時候我會再做一次擦除
調整一下持續時間 使角色能夠在
達到最高點的時候剛好到達溝的中間
然後複製我們動作的第一部分然後翻轉
得到一個完整的跳躍運動
跳躍的最後一步
我準備再創建一個動畫
包含跳躍的構架
同樣的方法打開媒體庫 過濾下來我們的跳躍構架
添加到動作中
現在我們的角色就能夠從第一個溝上面跳過去
當然 我們還有一個溝
我需要做的就是複製我剛剛添加的動作
然後替換但是接下來我們會碰到同樣的問題
那就是在地圖上的哪裏進行修改
我將要對每一個複製的實例進行修改
很可能我會在不同的層中
重複使用這些動作
甚至可能在不同的工程中
我們用同樣的方式解決了這個問題
就是允許你引用運動
我們在Xcode中引入一個新文件
這是一個SpriteKit動作文件夾
這個文件夾中放了一些動作文件
這些動作文件的名字
你可以在場景、工程或者代碼中全局引用
接下來 選定動作文件  
創建一個這樣的文件夾
並將其轉換成引用的形式
我準備給它命名 將其命名爲跳躍
我們可以選擇一個動作文件夾放進去
在這個例子中我會新建一個新的文件夾
我給這個文件夾命名爲角色動作
因爲我打算將所有的跟角色有關的動作都放進這個文件夾
將這個文件添加到我們的工程
現在你會看到我們創建的這些動作
例如跳躍已經在跳躍文件夾的下面了
並且在我們的場景中
我們可以引用這些動作
現在你放到這個文件夾中的動作
已經完全從所有的場景或者工程中獨立了出來
但是在一些場景中某些背景下
你經常會想要修改他們
我們允許你設置一個預覽窗口
你可以分配你文件夾中的任何動作在你的場景中的任何節點
例如我可以在這個場景中的任何節點預覽我 的跳躍動作
或者打開一個自己的場景
在角色的不同角度
例如 我可以預覽角色左邊或者
右邊跳躍動作是怎樣的
所以現在 在這裏 我們繼續 
回到擦除第二個溝的地方 在對象庫中
我們可以用可以引用的動作
自動填充進去
因爲我剛纔創建的跳躍動作
已經自動放在了對象庫中我就能夠將它拖放進去
現在我們就完成了我們的跳轉場景讓我們欣賞一下
看起來很棒
現在我想向你展示一下怎樣在代碼中使用
而不僅僅是一個跳轉場景
我想要做的就是在每一個角色可能存在的地圖中
都創建一個動作 然後通過代碼引用它
我要創建一個引用
這個可引用的動作叫跑
其中包含我們動畫
我也同樣對對空文件這麼處理
現在開始 刪除這些
因爲現在我們要把這些做成交互式的
現在你可以看到
我們的動作文件夾中
包含了三個地圖
現在通過代碼使用這些動作
你所要做的就是使用我們剛纔介紹的新選擇器
動作名稱選擇器 
給它們提供我們剛剛創建的動作的名稱
空 跑 和跳躍
現在當我運行我們的遊戲時
你能夠看到我剛纔創建的動作現在正在遊戲中使用着
交互式的
這一點最強大的地方在於
當你想要修改你的動作時
我可以直接打開動作文件夾
例如 讓角色在跳躍的時候翻個筋斗
我可以打開這裏然後添加一個旋轉的動作到跳躍上
給它賦值負360 緩進緩出
現在我們不編譯就運行我們的遊戲
我們可以看到發生了改變
我剛做的修改已經提交給了角色
現在這一層看起來已經很棒了
所以最後要做的事情就是創建一個漂亮的電影動畫開場
將角色引入到這一層
我可以通過創建一個SKCameraNode到場景中的方式實現
讓我們在鏡頭節點中定義一個Viewport
我們可以開始使用我剛添加的鏡頭
來分配我們的場景
作爲電影動畫開場我想用從這個角落開始
使用鏡頭放大
我準備放大這裏的霧氣
最棒的是因爲這只是一個SKNode 
我可以向鏡頭中添加動作
過濾下來適應我們的鏡頭
之後添加一個有兩個動作的移動
我準備要做的電影動畫開場
就是講鏡頭平移到這一層的中心
同時縮放
第二步我將要把X軸的值
設置爲507作爲中 心
同時將Y軸的值設置爲384個單位並作爲中心
並將這些設置爲
緩進緩出
我打算在我們打開我們的場景半秒鐘後
開始移動我們的動畫
並耗時3秒將其平移過去
同樣我添加了第二個動作並給其半秒鐘從我們的動畫中抵消
在動畫結束後同時結束
現在 在短短時間內
我們創建了一個電影動畫式的開場
我們也已經結束了這一層
接下來讓我們看一下它現在什麼樣子
這就是你現在可以使用SpriteKit和Xcode 7
做的事情了
與此同時 我想將話題重新交給提姆
讓它來爲你們總結一下
謝謝泰勒
這真的是一個非常棒的工作
我相信大家有目共睹
這對於SpriteKit工程師來講
將會是超級棒的一年
我們新增了AudioNode,也新增了CameraNode
我們也有了可以引用的動作和節點
也有了一個全新的
基於運動編輯器的集成在Xcode中的時間軸
我們整合了紋理地圖集和資源目錄
並給你提供了新的功能
例如基於命令的資源庫和更加簡潔的App
同時也使SpriteKit適配所有的支持Metal的設備
讓你能夠更容易地訪問
全新的GamePlayKit構架
如果你需要更多的信息
請訪問我們的開發者網站
或者撥打諮詢電話
聯繫我們的圖形專家AllanSchaffer 
還有幾個與之相關的會議
如果你想對GamePlayKit
或者SceneKit瞭解更多的話
我們也有一些實驗室
第一個就是SpriteKit實驗室
現在馬上就會啓動
大家放鬆 跟我們一起下樓
我們將很樂意回答你們的所有問題
非常感謝請享受您的會議