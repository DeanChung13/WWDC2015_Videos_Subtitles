00:00:20.053 --> 00:00:22.856 
Metal性能優化技術

00:00:31.532 --> 00:00:32.466 
早上好 

00:00:32.533 --> 00:00:36.170 
歡迎來到Metal性能優化技術

00:00:36.537 --> 00:00:39.439 
我是菲利普·班尼特 
來自GPU軟件性能團隊 

00:00:39.940 --> 00:00:42.009 
我們的特別嘉賓  

00:00:42.075 --> 00:00:46.847 
來自GPU軟件開發者
技術團隊的塞爾哈特·特欽

00:00:46.914 --> 00:00:50.050 
將爲我們展示一個非常棒的新工具  

00:00:50.117 --> 00:00:53.053 
對你的Metal app進行配置
我相信你會喜歡這個工具的

00:00:54.988 --> 00:00:58.625 
到目前爲止WWDC上的Metal

00:00:59.193 --> 00:01:03.130 
在Metal Part 1
新特性介紹會上

00:01:03.564 --> 00:01:08.368 
討論了iOS 9和OS X El
Capitan上Metal的新特性

00:01:10.270 --> 00:01:11.805 
在Metal Part 2
新特性介紹會上

00:01:11.905 --> 00:01:13.874 
我們會介紹兩個新架構 

00:01:13.941 --> 00:01:16.510 
MetalKit
和Metal性能着色器

00:01:16.877 --> 00:01:19.313 
讓我們更容易開發Metal app

00:01:20.514 --> 00:01:22.482 
在最後部分  

00:01:22.549 --> 00:01:28.322 
我們將回顧有什麼
工具適合調試和分析Metalapp

00:01:28.755 --> 00:01:31.458 
我們也將探討
一些關於從Metal app中

00:01:31.525 --> 00:01:33.727 
獲得最佳性能的最優方法

00:01:35.662 --> 00:01:37.164 
我們來看看工具

00:01:37.364 --> 00:01:38.866 
Metal調試和分析工具

00:01:38.999 --> 00:01:42.903 
若你已經在
iOS上做Metal app開發 

00:01:42.970 --> 00:01:45.772 
你應該對Xcode 

00:01:45.839 --> 00:01:47.574 
以及配套Metal工具很熟悉了

00:01:50.978 --> 00:01:52.713 
現在 我們將快速看一下

00:01:52.779 --> 00:01:54.047 
框架調試程序

00:01:55.682 --> 00:01:59.253 
這裏是Metal app
中一個單幀捕獲 

00:02:00.254 --> 00:02:03.790 
左邊是一個框架導航器 

00:02:04.291 --> 00:02:07.060 
顯示所有存在於框架內的

00:02:07.528 --> 00:02:08.862 
狀態和Draw調用

00:02:08.929 --> 00:02:14.001 
渲染編碼器命令緩衝器分組 

00:02:14.067 --> 00:02:16.370 
如果你正在使用調試標籤  

00:02:16.436 --> 00:02:19.907 
那麼調試標籤也會對它們進行分組

00:02:21.408 --> 00:02:24.011 
是渲染attachment視圖 

00:02:24.077 --> 00:02:26.947 
顯示除任何
深度和網板attachment外

00:02:27.214 --> 00:02:31.618 
與現有渲染pass有關的所有
color attachment

00:02:32.186 --> 00:02:35.756 
它顯示當前Draw調用的框架高亮區

00:02:36.056 --> 00:02:38.725 
這讓你可以很便利地操縱你的框架 

00:02:40.093 --> 00:02:43.463 
接下來是資源檢查器  

00:02:43.931 --> 00:02:46.834 
你可以檢查app所用的所有資源  

00:02:48.402 --> 00:02:53.040 
從緩衝器到
紋理到渲染attachment

00:02:53.106 --> 00:02:55.609 
你可以查看所有不同的格式  

00:02:55.676 --> 00:02:59.379 
分開位圖水平 立方形地圖  

00:02:59.446 --> 00:03:01.982 
TD陣列 這些特徵它都有

00:03:04.151 --> 00:03:05.853 
我們有狀態檢查器  

00:03:06.053 --> 00:03:10.390 
它可以檢查app上
所有Metal對象的屬性 

00:03:11.825 --> 00:03:15.028 
繼續 我們有GPU報告  

00:03:15.095 --> 00:03:17.965 
用於測量現有框架上的每一幀 

00:03:18.699 --> 00:03:21.768 
並對CPU和GPU進行計時

00:03:22.002 --> 00:03:25.639 
此外 它也在框架中顯示  

00:03:25.706 --> 00:03:28.942 
消耗最大的渲染和計算編碼器

00:03:29.510 --> 00:03:32.746 
以幫助你縮小消耗最大的着色器 

00:03:32.813 --> 00:03:34.615 
和Draw調用的範圍

00:03:36.683 --> 00:03:40.754 
最後 我們有着色器分析器和編輯器 

00:03:41.221 --> 00:03:42.789 
這個工具很棒  

00:03:43.156 --> 00:03:46.026 
可用來調試和分析着色器  

00:03:46.326 --> 00:03:49.429 
因爲它可讓你在聯機中  

00:03:49.496 --> 00:03:52.799 
微調着色器並對他們重新編譯  

00:03:52.866 --> 00:03:54.835 
這樣你就無需對app重新編譯了

00:03:56.270 --> 00:03:58.205 
你或許已經知道了  

00:03:58.272 --> 00:04:00.507 
所有這些很棒的工具 

00:04:00.574 --> 00:04:03.677 
都可用來在OS X El 
Capitan試Metal app

00:04:05.712 --> 00:04:09.249 
工具能夠很好協助Xcode的使用

00:04:09.316 --> 00:04:14.188 
它可以讓你
在整個系統中分析app性能  

00:04:14.788 --> 00:04:15.923 
現在 你也可以使用 

00:04:15.989 --> 00:04:18.425 
類似Metal系統尋蹤工具的方法

00:04:19.760 --> 00:04:22.896 
分析Metal的性能

00:04:23.397 --> 00:04:25.966 
這是iOS 9的一個最新工具

00:04:26.466 --> 00:04:28.569 
它可讓你在CPU和GPU中

00:04:28.635 --> 00:04:30.270 
分析Metal app

00:04:30.737 --> 00:04:31.839 
我們來看一下

00:04:33.207 --> 00:04:37.377 
我們從分析應用中
的Metal API使用開始  

00:04:38.679 --> 00:04:42.082 
然後是驅動程序 再到GPU 

00:04:42.149 --> 00:04:44.985 
在GPU你可以看到單獨處理階段 

00:04:45.052 --> 00:04:47.588 
verse X片段 隨機計算  

00:04:48.355 --> 00:04:50.290 
然後到真實的顯示器硬件

00:04:52.059 --> 00:04:54.094 
現在 塞爾哈特·特欽將爲我們演示

00:04:54.161 --> 00:04:55.095 
這個很棒的新工具  

00:04:55.162 --> 00:04:58.031 
有請他上臺

00:05:03.737 --> 00:05:05.572 
謝謝你 菲利普 大家好

00:05:06.607 --> 00:05:09.076 
今天我想爲大家
展示一個非常酷的東西 

00:05:09.142 --> 00:05:12.212 
Metal系統尋蹤

00:05:12.446 --> 00:05:15.616 
Metal系統尋蹤是
最新的Metal開發工具

00:05:16.650 --> 00:05:19.286 
Metal系統尋蹤是
Metal iOS app上

00:05:19.353 --> 00:05:22.823 
一款性能分析和追蹤工具  

00:05:23.290 --> 00:05:25.092 
是整套工具的一部分 

00:05:26.059 --> 00:05:30.063 
它讓你可以隨時
掌握應用的全系統概述  

00:05:30.864 --> 00:05:35.569 
在顯卡上 它也可讓你獲得細分到

00:05:35.636 --> 00:05:37.337 
微秒的細節信息

00:05:37.404 --> 00:05:39.239 
我必須強調一下 它很重要 

00:05:40.407 --> 00:05:43.377 
它是首次出現在我們的平臺上的 

00:05:43.443 --> 00:05:46.847 
幸虧有了
Xcode 7 和 iOS 9

00:05:47.481 --> 00:05:50.684 
言歸正傳 我們繼續 來嘗試一下

00:05:52.352 --> 00:05:55.222 
我將啓動工具  

00:05:55.556 --> 00:05:57.491 
我們在模板選擇器上

00:05:58.425 --> 00:06:01.495 
你可以看到這裏有個新的模板標誌  

00:06:01.562 --> 00:06:03.230 
Metal系統尋蹤Metal標誌

00:06:03.297 --> 00:06:04.565 
我將進行選擇

00:06:06.433 --> 00:06:08.669 
對工具很熟悉的人

00:06:08.735 --> 00:06:14.041 
知道我剛用它當中的四個工具
創建了一個新文件  

00:06:14.942 --> 00:06:16.977 
在時間軸的左手邊
可以看到這個文件 

00:06:18.045 --> 00:06:20.747 
我們來快速瀏覽一下這些工具  

00:06:20.814 --> 00:06:22.516 
和在時間軸中顯示的數據

00:06:22.983 --> 00:06:26.553 
我們繼續在
iPad中選擇Metal app 

00:06:26.620 --> 00:06:28.622 
作爲目標app和開始記錄 

00:06:33.493 --> 00:06:34.661 
好了

00:06:34.728 --> 00:06:37.998 
現在Metal 
系統尋蹤是一款工具內的記錄工具 

00:06:38.065 --> 00:06:39.833 
這個
工具叫Windowed Mode

00:06:39.900 --> 00:06:42.970 
本質上說 它捕捉軌道 
形成環形緩衝區

00:06:43.036 --> 00:06:45.439 
這可讓你隨時進行記錄 

00:06:46.173 --> 00:06:51.311 
重要的是 
在你發現需要調查的問題時  

00:06:51.378 --> 00:06:52.579 
可以停止記錄

00:06:53.280 --> 00:06:54.281 
這時候

00:06:54.348 --> 00:06:58.685 
工具將收集所有
已經收集的追蹤數據處理一會兒 

00:06:58.752 --> 00:07:01.088 
以一個時間軸作爲結束 
時間軸看起來像這樣

00:07:02.222 --> 00:07:03.991 
這裏有很多東西正在運作  

00:07:04.057 --> 00:07:05.792 
放大一下 可以看得更清楚些

00:07:06.860 --> 00:07:09.162 
控制選擇鍵 選擇一個時間軸裏  

00:07:09.830 --> 00:07:11.465 
我想要放大的  

00:07:11.532 --> 00:07:13.467 
感興趣的區域

00:07:14.501 --> 00:07:17.538 
我可以通過追蹤器手勢操縱時間軸  

00:07:17.871 --> 00:07:22.442 
兩個手指滑動到滾動和收縮 
以進行縮放 

00:07:23.010 --> 00:07:24.912 
你可以看到 在我進一步放大時  

00:07:25.445 --> 00:07:27.080 
我可以在時間軸裏看到更多的細節 

00:07:30.184 --> 00:07:32.085 
所以 在這裏 我們看什麼呢？

00:07:33.086 --> 00:07:35.055 
基本上 我們看到是  

00:07:35.455 --> 00:07:40.160 
Metal應用圖形處理過程中

00:07:40.761 --> 00:07:43.030 
所有圖層集合中

00:07:44.932 --> 00:07:48.569 
圖形深層信息

00:07:48.635 --> 00:07:51.605 
時間軸裏不同的顏色

00:07:51.672 --> 00:07:53.941 
代表每個框架不同的工作量

00:07:55.042 --> 00:07:57.711 
磁道本身相當的靈敏 

00:07:58.612 --> 00:08:02.583 
這裏的每個盒子代表
每個軌道的相關開始時間  

00:08:02.649 --> 00:08:04.284 
結束時間和所用時間 

00:08:06.420 --> 00:08:09.156 
從頭開始 然後往下一直處理  

00:08:09.223 --> 00:08:12.960 
我們使用Metal框架的應用

00:08:13.861 --> 00:08:18.732 
接下來 我們有顯卡驅動 
它處理你的命令緩衝器

00:08:19.132 --> 00:08:21.635 
如果你有任何
着色器編輯活動中等框架  

00:08:21.702 --> 00:08:23.570 
它同樣也會在軌道中體現 

00:08:25.439 --> 00:08:28.075 
這由GPU硬件軌道進行跟蹤  

00:08:28.542 --> 00:08:30.410 
顯示的是在GPU中

00:08:30.477 --> 00:08:33.179 
執行渲染和計算指令

00:08:33.714 --> 00:08:37.049 
最後 我們有顯示面軌道 

00:08:37.116 --> 00:08:40.587 
基本上 這就是在設備上顯示的框架 

00:08:41.755 --> 00:08:42.589 
好了

00:08:43.490 --> 00:08:47.528 
在這裏你可以
看到的其他東西是這些標籤 

00:08:48.962 --> 00:08:52.833 
這邊的這兩個標籤陰影buffer
G buffer和lighting

00:08:53.467 --> 00:08:55.469 
是我用編碼器標籤的屬性

00:08:55.536 --> 00:09:00.474 
分配到Metal代碼中的編輯器裏的

00:09:01.742 --> 00:09:06.580 
這些標籤帶着與它們相關的工作負荷 

00:09:06.647 --> 00:09:08.448 
沿着傳遞路徑傳送  

00:09:08.782 --> 00:09:10.217 
這使得Metal系統尋蹤中

00:09:10.284 --> 00:09:12.052 
追蹤場景渲染pass

00:09:12.119 --> 00:09:13.086 
非常簡單

00:09:13.153 --> 00:09:15.122 
我強烈建議你充分地使用它 

00:09:15.923 --> 00:09:19.193 
有些東西太小 無法安裝標籤  

00:09:20.060 --> 00:09:23.931 
你可以將鼠標懸停在尺子上就可以看到

00:09:23.997 --> 00:09:28.435 
一個工具提示
 同時顯示標籤和持續時間 

00:09:30.070 --> 00:09:36.176 
基本上 這裏的軌道順序映射 

00:09:36.343 --> 00:09:39.146 
Metal指令沿着顯卡

00:09:39.213 --> 00:09:41.748 
傳遞路徑運作的順序

00:09:42.316 --> 00:09:47.588 
讓我們繼續
跟隨命令緩衝器 沿着管道向下

00:09:49.790 --> 00:09:53.861 
在軌道頂端 
我可以看到我的應用使用的是

00:09:53.927 --> 00:09:56.396 
Metal命令緩衝器和編碼器

00:09:56.964 --> 00:10:00.234 
尤其是這裏 我看到的是命令緩衝器

00:10:00.300 --> 00:10:02.970 
和渲染計算編碼器的

00:10:03.036 --> 00:10:04.338 
創建時間和提交時間

00:10:05.372 --> 00:10:07.741 
頂端有命令緩衝器  

00:10:08.308 --> 00:10:14.248 
底部有相關的編碼器 這個編碼器是 

00:10:14.314 --> 00:10:17.618 
由命令緩衝器直接嵌入其中而創建

00:10:18.352 --> 00:10:24.057 
現在 注意這個箭頭 
箭頭在進入下個軌道

00:10:24.124 --> 00:10:27.361 
命令緩衝器的提交時間上 

00:10:28.228 --> 00:10:31.064 
在Metal系統尋蹤中  

00:10:31.131 --> 00:10:32.299 
這些箭頭代表

00:10:32.399 --> 00:10:34.234 
不同水平傳遞路徑間的依賴性 

00:10:34.434 --> 00:10:37.404 
例如 當提交了命令緩衝器  

00:10:37.871 --> 00:10:40.874 
它的下一站是圖形顯示器驅動  

00:10:40.941 --> 00:10:44.545 
如果將其可以放大 
就會看到更多信息 

00:10:45.879 --> 00:10:47.981 
看看我們獲取到到了多少信息

00:10:48.448 --> 00:10:51.385 
它真的真的很快 CPU仍在處理

00:10:51.451 --> 00:10:52.853 
幾乎沒有佔用多少內存

00:10:54.121 --> 00:10:57.724 
同樣的 一旦編碼器處理完畢  

00:10:57.791 --> 00:11:00.994 
我就可以跟隨這些箭頭了

00:11:01.161 --> 00:11:03.997 
這些編碼器將被提交到GPU軌道

00:11:05.065 --> 00:11:07.401 
用同樣的方式跟隨箭頭  

00:11:08.435 --> 00:11:12.539 
可以看到GPU正在處理我的編碼器

00:11:13.540 --> 00:11:17.110 
這個GPU軌道被分成三個不同線路 

00:11:17.177 --> 00:11:18.478 
一個是vertex處理  

00:11:18.545 --> 00:11:20.814 
一個是碎片 一個是計算

00:11:22.015 --> 00:11:26.453 
比如說 我可以看到陰影緩衝途徑的

00:11:26.520 --> 00:11:28.088 
陰影緩衝渲染代碼  

00:11:28.856 --> 00:11:31.158 
它正在仔細查
看它的vertex處理階段  

00:11:31.225 --> 00:11:34.161 
然後移到碎片階段 這個階段剛好

00:11:34.228 --> 00:11:36.330 
和G buffer
和lighting 階段重疊

00:11:36.396 --> 00:11:37.798 
這些東西很好

00:11:38.832 --> 00:11:45.072 
這裏有個簡要的信息
vertex碎片不只是

00:11:45.672 --> 00:11:51.211 
計算着色器處理時間 
同樣也計算處理成本

00:11:51.278 --> 00:11:53.780 
比如說 我們正在iOS上運行  

00:11:53.847 --> 00:11:56.216 
它是一個圖塊類延緩體系結構 

00:11:56.617 --> 00:11:59.453 
所以vertex處理成本也將 

00:11:59.520 --> 00:12:04.391 
包含圖塊成本 這些需要記住

00:12:05.826 --> 00:12:09.796 
最後 一旦框架完成渲染 

00:12:10.664 --> 00:12:14.434 
表面也將在顯示器中結束 

00:12:14.735 --> 00:12:16.637 
這點顯示在在底部的軌道中

00:12:19.106 --> 00:12:23.477 
基本上 它顯示框架進入顯示器的時間

00:12:23.544 --> 00:12:24.878 
以及在裏面呆了多長時間

00:12:25.612 --> 00:12:28.582 
在它下面 有同步軌道 

00:12:29.283 --> 00:12:31.685 
顯示的是被與個別同步事件

00:12:31.752 --> 00:12:36.190 
相應的峯值分開的同步間隔

00:12:39.459 --> 00:12:42.930 
最後 在頂部有細節視圖

00:12:43.897 --> 00:12:44.932 
細節視圖和你在

00:12:44.998 --> 00:12:46.800 
其他工具看到的類似

00:12:46.867 --> 00:12:49.269 
它在選擇的工具使用基礎上 

00:12:49.336 --> 00:12:50.938 
提供環境細節

00:12:51.505 --> 00:12:52.372 
比如說現在 

00:12:52.439 --> 00:12:55.042 
我選擇了Metal應用工具 

00:12:55.108 --> 00:12:59.413 
就可以擴大這個 看看所有的框架 

00:12:59.479 --> 00:13:01.481 
所有的命令緩衝器 

00:13:01.548 --> 00:13:02.683 
和與有關層級的編碼器

00:13:03.550 --> 00:13:07.754 
如果你想看精確定時
 這個軌道就很有用

00:13:07.821 --> 00:13:09.156 
若我轉到編碼器清單 

00:13:09.590 --> 00:13:11.158 
精確創建提交時間

00:13:11.225 --> 00:13:13.227 
或進程的起始位置

00:13:13.293 --> 00:13:14.428 
非常有用

00:13:15.996 --> 00:13:20.868 
酷！這裏的時間軸

00:13:20.934 --> 00:13:24.605 
對應這圖形管道

00:13:25.405 --> 00:13:27.407 
這是一個非常強大的工具

00:13:27.608 --> 00:13:31.445 
iOS 9和Metal中是首次出現

00:13:32.779 --> 00:13:35.983 
所以要怎麼用 才能解決你的問題呢？

00:13:36.049 --> 00:13:38.352 
或有問題的app是什麼樣的？

00:13:38.886 --> 00:13:40.587 
繼續 我將打開一個不同的軌道 

00:13:40.654 --> 00:13:42.055 
爲你進行展示

00:13:42.222 --> 00:13:44.591 
等下菲利普將爲你

00:13:44.658 --> 00:13:48.662 
詳細講解Metal性能

00:13:49.329 --> 00:13:52.833 
以及如何使用它解決你的問題 

00:13:53.901 --> 00:13:55.903 
我將簡要講講工具的

00:13:55.969 --> 00:13:59.373 
工作流程和一些小竅門

00:14:00.707 --> 00:14:03.610 
首要的是你需要關心

00:14:03.677 --> 00:14:05.712 
你的CPU和GPU並行

00:14:06.847 --> 00:14:09.516 
你可以看到 我打開的標有 

00:14:09.583 --> 00:14:11.552 
Problem Run標籤的軌道 

00:14:12.286 --> 00:14:15.856 
比我們上一個軌道要稀疏

00:14:16.290 --> 00:14:18.959 
因爲我們有不少同步點 在這些點裏 

00:14:20.527 --> 00:14:22.462 
事實上 CPU正在等待GPU

00:14:22.529 --> 00:14:24.498 
你需要確保將它消除掉 

00:14:26.233 --> 00:14:32.406 
同樣的 需要尋找另一個有用的東西 

00:14:32.472 --> 00:14:33.807 
就是你在時間軸裏看到的模式

00:14:34.341 --> 00:14:37.845 
這些框架都是同一場景的一部分 

00:14:37.911 --> 00:14:39.713 
所以它們的時間局部性很高

00:14:40.480 --> 00:14:42.783 
任何你看到的分歧 
都可能指向一個問題 

00:14:42.850 --> 00:14:44.651 
你應該進行調查

00:14:45.185 --> 00:14:48.655 
另一個重要的東西是顯示面軌道

00:14:50.090 --> 00:14:53.961 
理論上 若幀速率目標是60幀每秒 

00:14:56.096 --> 00:14:59.867 
這些面將在顯示上停留

00:15:00.601 --> 00:15:02.569 
一個單一的VSync間隔

00:15:05.405 --> 00:15:07.407 
所以我們可以看到每VSync間隔 

00:15:07.474 --> 00:15:08.876 
顯示面就會被交換

00:15:08.942 --> 00:15:11.411 
比如這個特別的框架 
停留了三個間隔 

00:15:11.478 --> 00:15:13.380 
所以我們以20 fps進行運行 

00:15:16.683 --> 00:15:21.154 
另一個非常有用的
東西是着色器編輯軌道 

00:15:21.455 --> 00:15:24.258 
不管着色器編輯器
何時在軌道里開始生效 

00:15:24.324 --> 00:15:26.226 
它都直接爲你顯示相關信息 

00:15:26.627 --> 00:15:28.762 
需要特別避免的一件事是 

00:15:29.530 --> 00:15:33.800 
將工作提交到着色器編輯器中等框架

00:15:33.867 --> 00:15:35.569 
因爲它將浪費你的CPU週期

00:15:35.636 --> 00:15:38.005 
這個週期你原本
可以用在其他的事情上的

00:15:38.071 --> 00:15:40.807 
菲利普等下會詳細說到這點

00:15:41.742 --> 00:15:46.413 
最後 你應該儘早並經常進行分析

00:15:47.814 --> 00:15:51.752 
像這樣的工作流程將幫你解決問題

00:15:51.818 --> 00:15:54.354 
而且可讓解決問題變得簡單

00:15:54.421 --> 00:15:58.559 
Xcode通過爲創建產品
提供一個配置文件啓動選項 

00:15:58.625 --> 00:16:00.093 
對你有所幫助

00:16:00.160 --> 00:16:02.796 
它將自動創建一個已安裝

00:16:02.863 --> 00:16:05.265 
在設備上的app的發佈版本 

00:16:05.332 --> 00:16:09.002 
啓動一個按照你選擇模板運行的工具

00:16:10.404 --> 00:16:14.107 
好了 這是Metal系統尋蹤

00:16:15.108 --> 00:16:19.346 
適合所有支持Metal的iOS設備

00:16:20.614 --> 00:16:24.051 
你可以試一下
我們期待你的反饋和建議

00:16:24.685 --> 00:16:27.621 
現在有請菲利普上臺 

00:16:28.121 --> 00:16:32.826 
他將爲我們展示
一些主要的Metal性能 

00:16:33.260 --> 00:16:36.396 
以及如何使用工具對他們進行鑑別
謝謝

00:16:43.704 --> 00:16:46.039 
謝謝你 塞爾哈特 你的信息量很大

00:16:47.107 --> 00:16:52.212 
我們會講到前面提到的Metal性能

00:16:53.981 --> 00:16:56.750 
一些最優方法 我們也將看看 

00:16:56.817 --> 00:16:58.652 
如何使用這些工具進行診斷

00:16:58.719 --> 00:17:00.954 
並遵循最優方法

00:17:01.388 --> 00:17:04.858 
讓我來介紹一下我們的app樣本 

00:17:05.526 --> 00:17:07.828 
更確切地說
是app樣本的一個系統軌道 

00:17:08.127 --> 00:17:12.733 
我們馬上可以看到一些性能問題

00:17:13.165 --> 00:17:17.371 
首先 CPU和GPU之間沒有並行

00:17:18.005 --> 00:17:21.441 
那是非常強大的設備 

00:17:21.541 --> 00:17:24.578 
實現最大性能的唯一方式

00:17:24.944 --> 00:17:29.049 
是立即運行它們 
然而 它們似乎正在等待什麼

00:17:30.617 --> 00:17:33.220 
你可以看到 CPU中處理框架之間

00:17:33.287 --> 00:17:35.589 
有大量的延遲

00:17:36.089 --> 00:17:37.691 
有一個異常的22毫秒

00:17:37.758 --> 00:17:40.060 
這裏不能有任何拖延 發生什麼了？ 

00:17:41.128 --> 00:17:45.632 
來看一下CPU實際活躍週期 

00:17:46.300 --> 00:17:48.535 
它超過了框架截止期限

00:17:48.602 --> 00:17:50.504 
我們希望每秒有60幀

00:17:50.571 --> 00:17:54.741 
所以所有的東西必須在16毫秒內解決
我們已經超出時間 失效了

00:17:55.609 --> 00:17:58.512 
GPU方面看起來也不樂觀 

00:17:58.579 --> 00:18:02.549 
這是個漫長的拖延與CPU上的相稱 

00:18:02.616 --> 00:18:05.652 
因爲CPU花費了
大量的時間卻沒做成任何事 

00:18:05.719 --> 00:18:09.489 
也無法爲下個框架排隊等候

00:18:09.923 --> 00:18:16.163 
此外
活躍的GPU週期超過框架截止期限 

00:18:16.663 --> 00:18:19.032 
我們努力達到每秒60幀 

00:18:19.099 --> 00:18:21.168 
但是事實每秒只有20幀

00:18:22.703 --> 00:18:25.005 
我們可以做些什麼呢？

00:18:25.772 --> 00:18:28.375 
讓我們看看基礎的東西

00:18:28.542 --> 00:18:34.715 
首先檢查一下
Metal設計和性能主要原則

00:18:35.782 --> 00:18:40.754 
在前面的狀態中
它正在創建耗費資源的對象 

00:18:44.591 --> 00:18:48.929 
現在 在傳統app上 
特別是在內容加載過程中將發生的

00:18:48.996 --> 00:18:53.367 
app編譯所有來自源的着色器 

00:18:53.433 --> 00:18:57.404 
着色器可能有數個 甚至上百個 

00:18:57.471 --> 00:18:59.940 
這是個相當耗時的操作

00:19:01.241 --> 00:19:04.244 
現在共享編譯才進行到一半 

00:19:04.912 --> 00:19:07.948 
因爲着色器需要全部編譯到

00:19:08.015 --> 00:19:13.754 
與各種使用狀態相結合的

00:19:13.820 --> 00:19:15.556 
GPU管道狀態中

00:19:16.356 --> 00:19:18.926 
所以一些app可能

00:19:19.760 --> 00:19:22.663 
試圖進行預熱

00:19:23.430 --> 00:19:26.867 
通常情況下 當着色器和狀態第一次 

00:19:26.934 --> 00:19:30.838 
在Draw call中使用時 
就會出現設備編輯

00:19:31.438 --> 00:19:35.108 
這是個壞消息 想象一下 
你有一個競賽遊戲 突然間 

00:19:35.175 --> 00:19:37.911 
你轉了個彎 添加了很多新對象 

00:19:37.978 --> 00:19:39.046 
幀速率也下降了

00:19:39.112 --> 00:19:40.047 
這真是的很糟糕

00:19:40.514 --> 00:19:43.083 
預熱所做的就是

00:19:43.150 --> 00:19:47.688 
你釋放大量

00:19:47.754 --> 00:19:50.958 
帶顯示狀態和
不同着色器組合的W Draw調用 

00:19:51.525 --> 00:19:57.497 
這樣讓驅動程序可以進行編輯
相關GPU管道狀態

00:19:57.564 --> 00:19:59.533 
所以當使用

00:20:00.300 --> 00:20:02.569 
組合狀態和着色器時 

00:20:02.636 --> 00:20:05.772 
所有的一切都準備好了
 幀速率也不會下降了

00:20:06.874 --> 00:20:08.509 
在實際的渲染循環中 

00:20:08.575 --> 00:20:11.512 
它們是典型的狀態設置 

00:20:12.112 --> 00:20:13.914 
當你開始考慮做一些事情時 

00:20:13.981 --> 00:20:16.016 
或許你將做些Draw調用

00:20:17.451 --> 00:20:23.223 
所以Metal路徑就是事先移除
資源消耗多的對象

00:20:23.957 --> 00:20:26.894 
着色器可以在脫機狀態下
從源代碼進行編輯

00:20:27.728 --> 00:20:30.397 
它免去了不少的工作量

00:20:31.632 --> 00:20:34.935 
我們提前移到狀態定義

00:20:35.002 --> 00:20:37.704 
你定義你的狀態 

00:20:38.438 --> 00:20:40.274 
GPU管道狀態被編譯成

00:20:40.340 --> 00:20:42.376 
這些狀態對象

00:20:43.210 --> 00:20:46.513 
所以當你開始Draw調用時 

00:20:46.580 --> 00:20:48.715 
就沒有所謂的設備編輯 

00:20:48.849 --> 00:20:51.585 
所以也就不在需要警告了

00:20:51.652 --> 00:20:52.886 
它已經成爲歷史了

00:20:53.754 --> 00:20:56.823 
它們已經
爲Draw調用備好渲染循環了 

00:20:56.890 --> 00:20:58.692 
許多Draw調用

00:21:00.027 --> 00:21:01.595 
基本上

00:21:02.462 --> 00:21:05.899 
Metal通過以下方式加速狀態定義

00:21:06.333 --> 00:21:10.571 
分離Draw命令
裏消耗多的狀態確認和編輯 

00:21:11.038 --> 00:21:13.473 
從而允許你將其推出渲染循環

00:21:13.540 --> 00:21:16.009 
併爲真實的Draw調用

00:21:16.076 --> 00:21:17.744 
保持渲染循環

00:21:19.880 --> 00:21:22.282 
現在 這些資源消耗型狀態

00:21:22.349 --> 00:21:25.886 
被打包到不可變狀態對象中 

00:21:26.353 --> 00:21:30.557 
目的是一旦創建 就可以被重複使用

00:21:31.725 --> 00:21:33.927 
現在 回到app樣本 

00:21:35.929 --> 00:21:39.600 
你可以看到中等
框架上有些渲染器編輯正在發生 

00:21:39.800 --> 00:21:41.768 
這裏我們大約浪費了一毫秒

00:21:42.636 --> 00:21:44.972 
根本沒用

00:21:46.740 --> 00:21:50.577 
倘若看一下Xcode的框架調試器 

00:21:51.078 --> 00:21:53.046 
看看在單個框架上發生的所有這些

00:21:53.113 --> 00:21:55.549 
看看所有的這些對象

00:21:55.616 --> 00:21:56.817 
都不是我們想要的

00:21:56.884 --> 00:21:59.620 
你應該看的是這些 

00:21:59.686 --> 00:22:02.122 
創建框架命令緩衝器

00:22:02.689 --> 00:22:04.825 
獲取drawable以及紋理

00:22:05.325 --> 00:22:07.528 
剩下的東西 就都是多餘的了

00:22:08.762 --> 00:22:12.466 
我們來說說這些消耗大的對象 

00:22:12.533 --> 00:22:13.800 
以及應該何時創建它們

00:22:13.867 --> 00:22:16.303 
我們從着色器庫開始

00:22:17.304 --> 00:22:21.341 
這些是你的編譯着色器庫

00:22:22.376 --> 00:22:26.046 
現在 你真正要做的是 
在離線狀態下 對它們進行編譯

00:22:27.047 --> 00:22:31.585 
你可以使用Xcode 

00:22:31.785 --> 00:22:33.921 
項目上任何Metal源文件

00:22:34.087 --> 00:22:35.722 
都將被入默認庫

00:22:36.623 --> 00:22:42.529 
你的app或許
有它自己的自定義目錄管道 

00:22:42.796 --> 00:22:45.132 
你或許並不是必需使用這個方法

00:22:45.666 --> 00:22:48.836 
因此 我們提供了命令行工具 

00:22:48.902 --> 00:22:51.738 
它可以被合併到你的管道中

00:22:53.707 --> 00:22:55.742 
如果在運行時間裏 

00:22:55.809 --> 00:22:58.946 
你免不了要從源裏編輯着色器

00:22:59.913 --> 00:23:02.783 
最好是進行異步創建

00:23:03.984 --> 00:23:07.621 
所以當你創建庫 同時 

00:23:07.688 --> 00:23:10.057 
你的app確切的說是調用線程 

00:23:10.123 --> 00:23:12.826 
可以繼續做其他事情 

00:23:12.926 --> 00:23:16.930 
一旦着色器庫創建完成 

00:23:16.997 --> 00:23:19.166 
你的app也會得到相關信息

00:23:22.436 --> 00:23:25.606 
需在你的app創建的首個對象

00:23:25.672 --> 00:23:27.541 
是設備和命令隊列

00:23:28.842 --> 00:23:32.145 
這些代表着你將使用的GPU 

00:23:32.212 --> 00:23:36.250 
以及安排好的命令緩衝器的順序

00:23:37.851 --> 00:23:40.053 
現在 正如我們所說的 你想要

00:23:40.120 --> 00:23:42.289 
在app初始化過程中 創建這些 

00:23:42.356 --> 00:23:44.758 
因爲創建它們消耗太大 

00:23:44.825 --> 00:23:48.795 
你想讓它們
可以在app的使用週期裏被重複使用

00:23:49.596 --> 00:23:52.933 
而且當然
你想爲每個使用的GPU都創建一個

00:23:54.568 --> 00:23:57.171 
接下來是很有趣的東西 渲染

00:23:57.237 --> 00:23:58.839 
和計算管道狀態 

00:24:00.007 --> 00:24:03.944 
它們壓縮了
所有的可編程GPU管道狀態 

00:24:04.344 --> 00:24:09.116 
因此它準備了所有的
描述符vertex格式器腳本 

00:24:09.850 --> 00:24:11.618 
渲染緩衝器格式 

00:24:11.685 --> 00:24:14.087 
並把它們編譯成真實的原管道狀態

00:24:15.322 --> 00:24:17.424 
現在 因爲這是個消耗多的操作 

00:24:17.491 --> 00:24:21.962 
你應該在你加載內容時 
創建這些管道對象 

00:24:22.462 --> 00:24:24.998 
而且它們應該可以被不斷循環使用

00:24:26.533 --> 00:24:28.101 
現在 因爲有了這些庫 

00:24:28.168 --> 00:24:30.204 
你也可以用這些方法 

00:24:30.270 --> 00:24:31.772 
對它們進行異步創建

00:24:32.072 --> 00:24:33.440 
一旦創建完畢 

00:24:33.507 --> 00:24:35.542 
完成處理器將通知你的app

00:24:38.512 --> 00:24:42.616 
需要提到一點 除非你真的需要它們 

00:24:42.983 --> 00:24:44.952 
要不然就不要獲取反射數據了 

00:24:45.018 --> 00:24:47.254 
因爲這是個消耗很大的操作

00:24:48.989 --> 00:24:53.093 
接下來是深度網板和取樣器狀態

00:24:53.660 --> 00:24:56.763 
這些是GPU管道狀態固定功能 

00:24:57.497 --> 00:24:59.099 
在你加載內容時 

00:24:59.166 --> 00:25:02.936 
你應該和其他管道狀態一起
對其進行創建

00:25:03.770 --> 00:25:09.643 
現在 你或許已經結束了許多深度網板

00:25:09.710 --> 00:25:11.879 
和樣品器狀態 但你無需擔憂 

00:25:11.945 --> 00:25:15.682 
因爲Metal實現將在內部

00:25:15.749 --> 00:25:19.219 
散列狀態 並創建大量副本 

00:25:19.286 --> 00:25:20.454 
所以 你無需擔憂

00:25:22.089 --> 00:25:26.026 
接下來
我們有了GPU消耗的真實數據了

00:25:26.093 --> 00:25:29.763 
你獲得了紋理和緩衝器

00:25:30.497 --> 00:25:33.233 
再一次 你應該在加載內容時 

00:25:33.934 --> 00:25:37.771 
對其進行創建 並儘可能的重複使用 

00:25:37.871 --> 00:25:42.109 
因爲這是一項與配置

00:25:42.176 --> 00:25:44.011 
和釋放資源有關的消耗

00:25:45.045 --> 00:25:48.815 
乃至動態資源 你或許無法

00:25:48.882 --> 00:25:51.785 
提前將它們完全初始化
但是你至少應該

00:25:51.852 --> 00:25:54.955 
創建優先存儲

00:25:55.155 --> 00:25:57.691 
我們很快就會講到這部分的詳細信息

00:25:58.892 --> 00:26:00.928 
現在簡要說一下 

00:26:01.762 --> 00:26:07.401 
所以 對於消耗大的狀態
顯然應該提前創建 

00:26:08.001 --> 00:26:09.903 
它們是着色器庫 

00:26:09.970 --> 00:26:11.972 
可在離線的時候進行創建

00:26:13.006 --> 00:26:15.909 
設備和命令序列 在你初始化

00:26:16.176 --> 00:26:18.245 
app的時候進行創建

00:26:18.779 --> 00:26:21.315 
渲染和計算管道狀態 

00:26:22.015 --> 00:26:23.917 
在你加載內容的時候進行創建 

00:26:24.284 --> 00:26:26.753 
固定功能管道狀態 

00:26:26.820 --> 00:26:28.722 
深度網板和取樣器狀態 

00:26:29.990 --> 00:26:32.059 
也是在你加載內容時進行創建 

00:26:32.125 --> 00:26:33.760 
最後是app使用的紋理和緩衝器

00:26:34.728 --> 00:26:40.033 
我們繼續 在app示例中遵循

00:26:40.701 --> 00:26:42.536 
這些最優方法
或許你還記得它是這樣的

00:26:42.736 --> 00:26:46.507 
曾有些着色器編輯
每幀都會出現中間幀情況 

00:26:47.608 --> 00:26:49.309 
現在 我們什麼都沒有了

00:26:49.376 --> 00:26:52.713 
已經節約了大概CPU時間的一毫秒

00:26:53.180 --> 00:26:55.082 
開端不錯不過我們要看下

00:26:55.148 --> 00:26:56.517 
能否很快的做得更好

00:26:57.084 --> 00:27:02.022 
預先創建消耗多的狀態和對象 

00:27:02.089 --> 00:27:05.125 
並使它們可以被重複使用

00:27:05.392 --> 00:27:10.097 
特別是 在脫機狀態下
編輯你的着色器源 

00:27:10.230 --> 00:27:13.033 
你想將渲染循環保持在它原本的樣子 

00:27:13.100 --> 00:27:14.168 
這是Draw調用 

00:27:14.701 --> 00:27:16.069 
擺脫了所有的對象創建 

00:27:18.238 --> 00:27:23.210 
對於那些你無法全部預先創建的資源
該怎麼辦？

00:27:23.744 --> 00:27:26.246 
我們正在談論這些動態資源 

00:27:26.813 --> 00:27:30.918 
所以我們該對它們做什麼？
我們該如何有效地創建並管理它們呢？

00:27:32.286 --> 00:27:34.488 
現在 通過動態資源 

00:27:34.821 --> 00:27:38.525 
我們來談談那些一經創建 

00:27:38.926 --> 00:27:43.630 
就可能被CPU修改很多次的資源

00:27:44.064 --> 00:27:48.569 
一個好的例子是緩衝器着色器常量 

00:27:50.704 --> 00:27:55.776 
以及一些東西 
比如在CPU中產生的粒子系統 

00:27:55.843 --> 00:27:58.912 
所擁有的任何動態
vertex和指示緩衝器  

00:27:59.813 --> 00:28:02.216 
除動態紋理外

00:28:02.282 --> 00:28:04.384 
或許你的app有一些紋理 

00:28:04.451 --> 00:28:06.420 
它在框架間的CPU上進行修改

00:28:07.654 --> 00:28:09.156 
理想的狀態是 如果可以

00:28:09.223 --> 00:28:12.793 
你會選擇將這些資源放在某處 

00:28:12.860 --> 00:28:15.495 
以方便CPU和GPU有效地使用

00:28:16.463 --> 00:28:18.232 
當你創建資源時 

00:28:18.498 --> 00:28:21.602 
你可以通過使用
共享儲存模式選項進行操作

00:28:22.202 --> 00:28:25.239 
這在存儲器裏創建資源

00:28:25.305 --> 00:28:27.307 
資源由CPU和GPU共享

00:28:27.841 --> 00:28:31.278 
事實上 
這是iOS上的默認儲存模式 

00:28:31.345 --> 00:28:35.916 
iOS設備已經統一存儲器架構 

00:28:35.983 --> 00:28:39.586 
所以相同的存儲器
可在CPU和GPU之間進行共享

00:28:40.988 --> 00:28:44.992 
現在 關於這些共享資源的事情是 

00:28:45.058 --> 00:28:48.061 
CPU完全無法同步使用

00:28:48.495 --> 00:28:53.100 
它可以通過指示器自由地修改數據

00:28:53.934 --> 00:28:59.173 
事實上 對於GPU正在使用的數據

00:28:59.239 --> 00:29:01.408 
對CPU而言是毀滅性的的數據 

00:29:01.475 --> 00:29:03.443 
CPU很容易就可以對其進行干涉

00:29:03.777 --> 00:29:05.112 
我們想要避免這種情況

00:29:05.612 --> 00:29:07.247 
但我們應該怎麼做？

00:29:09.249 --> 00:29:13.120 
一個簡單的做法是
爲資源配備一個單一緩衝器

00:29:14.054 --> 00:29:16.857 
在資源裏 我們有一個常量緩衝器

00:29:16.924 --> 00:29:21.261 
這個緩衝器在CPU裏進行更新 
並隨後被GPU所消耗

00:29:22.496 --> 00:29:24.131 
現在 倘若CPU想要

00:29:24.198 --> 00:29:27.968 
修改常量緩衝器裏的任何數據 

00:29:28.702 --> 00:29:31.371 
它就必須等到GPU完成後 才能開始

00:29:31.438 --> 00:29:34.141 
唯一方法是 

00:29:34.208 --> 00:29:38.412 
它是否在等待命令緩衝器
在命令緩衝器裏 

00:29:39.112 --> 00:29:41.481 
資源是調用於完成GPU進程

00:29:41.882 --> 00:29:45.452 
在這個示例中 
我們使用等待至完成

00:29:46.086 --> 00:29:49.756 
所以我們空等着
等於CPU也在空等着 

00:29:49.823 --> 00:29:51.725 
直到GPU完成處理 

00:29:52.192 --> 00:29:54.695 
CPU才能繼續並修改緩衝器

00:29:54.761 --> 00:29:57.164 
而緩衝器將在下個框架中被GPU消耗

00:29:58.198 --> 00:30:00.067 
這真的很不好 

00:30:00.133 --> 00:30:04.304 
因爲不僅CPU儲存了
GPU也儲存了 

00:30:04.671 --> 00:30:07.441 
因爲CPU沒有時間爲
下個框架操作排隊等候

00:30:09.309 --> 00:30:13.714 
這是在app示例中所發生的

00:30:14.615 --> 00:30:20.454 
CPU在空等
等待GPU完成每個框架 

00:30:20.521 --> 00:30:24.124 
你引入了大量的存儲週期 

00:30:24.191 --> 00:30:27.194 
是的 CPU和GPU之間並沒有並行

00:30:28.161 --> 00:30:30.831 
顯然 你需要更好的方法 

00:30:31.732 --> 00:30:35.836 
你或許會
冒險爲每個框架創建新緩衝器 

00:30:35.903 --> 00:30:36.837 
因爲你需要他們

00:30:37.704 --> 00:30:40.874 
但是正如我們前面所提到的 

00:30:40.941 --> 00:30:42.176 
這並不是一個好辦法 

00:30:42.242 --> 00:30:44.545 
因爲創建緩衝器

00:30:44.611 --> 00:30:46.079 
需要經常消耗

00:30:46.847 --> 00:30:50.150 
如果你有很多大的緩衝器
他們會積累 

00:30:50.217 --> 00:30:52.152 
你不會真的想這麼做的

00:30:53.086 --> 00:30:57.691 
你應該做的是 使用一個緩衝器組合

00:30:58.258 --> 00:31:00.427 
這裏我們有三重緩衝組合 

00:31:01.061 --> 00:31:05.199 
裏面有三個緩衝器
這些緩衝器是在CPU更新 

00:31:05.265 --> 00:31:06.800 
然後被GPU消耗掉的

00:31:07.434 --> 00:31:08.302 
爲什麼是三個？

00:31:08.869 --> 00:31:11.972 
我尤其要建議你限制

00:31:12.039 --> 00:31:15.275 
命令緩衝器數量 最多三個 

00:31:15.676 --> 00:31:20.414 
實際上 每個命令緩衝器有一個緩衝器

00:31:21.381 --> 00:31:24.017 
通過利用一個信號 

00:31:24.084 --> 00:31:27.788 
阻止CPU超過GPU太多 

00:31:28.388 --> 00:31:32.993 
我們可以確保在
CPU上更新緩衝器仍是安全的

00:31:33.660 --> 00:31:36.530 
返回讀取第一個緩衝器時 

00:31:36.597 --> 00:31:39.066 
當GPU在處理過程中

00:31:40.901 --> 00:31:43.504 
與其拿一堆惱人的樣本代碼

00:31:43.570 --> 00:31:47.007 
我將示範的很棒的例子

00:31:47.508 --> 00:31:49.910 
是Metal Uniform
Streaming示例 

00:31:49.977 --> 00:31:52.246 
它將展示如何做到這點

00:31:53.413 --> 00:31:56.016 
若你感興趣 我建議你隨後檢驗一下它

00:31:57.317 --> 00:31:59.853 
回到app示例 你應該還記得 

00:31:59.920 --> 00:32:02.356 
在CPU上 每個框架之間

00:32:02.890 --> 00:32:06.059 
有這些被削弱性能的權重

00:32:07.294 --> 00:32:12.633 
在使用一個緩衝組合更新動態數據後 

00:32:13.500 --> 00:32:17.171 
我們設法極大地減少

00:32:17.237 --> 00:32:20.140 
CPU處理和GPU處理之間的差距

00:32:20.674 --> 00:32:23.043 
我們還有些同步性問題 

00:32:23.110 --> 00:32:25.245 
但我們將只簡要地看一下

00:32:26.547 --> 00:32:28.582 
我們已經取得很大的進步 

00:32:29.716 --> 00:32:32.252 
總之 你想要緩衝

00:32:32.319 --> 00:32:34.288 
動態共享資源 

00:32:34.555 --> 00:32:38.091 
因爲它是在
框架之間更新這些的最有效的方式 

00:32:38.892 --> 00:32:44.865 
你通過使用我
提到過的緩衝器和組確保安全

00:32:47.467 --> 00:32:50.337 
現在 我將講一些東西 

00:32:50.871 --> 00:32:52.573 
確切地說 實際上是一件

00:32:52.639 --> 00:32:55.042 
我不想提前做的事情 

00:32:55.843 --> 00:32:59.279 
那關係到你何時
獲得你的appDrawable服務

00:33:01.048 --> 00:33:04.618 
Drawable
外觀是領域裏app的窗口 

00:33:04.685 --> 00:33:08.455 
它是你的app
渲染它的可視內容進去的東西 

00:33:08.755 --> 00:33:13.193 
這要麼是在顯示器上直接顯示 

00:33:13.360 --> 00:33:15.796 
要麼是組成管道的一部分

00:33:16.797 --> 00:33:21.735 
從Core Animation
Metal圖層檢索Drawable

00:33:22.402 --> 00:33:26.306 
但這些Drawable數量有限 
因爲事實上 它們相當的大 

00:33:26.907 --> 00:33:29.643 
而我們既不想大量保存它們 

00:33:29.710 --> 00:33:33.180 
也不像在我們需要的時候
對它們進行配置

00:33:33.981 --> 00:33:37.351 
所以這些Drawable非常有限 

00:33:37.551 --> 00:33:40.587 
而一旦它們在硬件中顯示了 

00:33:40.654 --> 00:33:42.756 
在顯示間隔

00:33:42.823 --> 00:33:44.525 
預先drawable 被放棄了

00:33:45.659 --> 00:33:49.530 
如果你集成實際的顯示硬件 

00:33:50.230 --> 00:33:53.367 
顯示管道的每個階段可能在任何點 

00:33:53.867 --> 00:33:57.704 
爲一個GPU
爲Core Animation

00:33:57.771 --> 00:33:59.773 
在你的app裏抓取Drawable

00:34:01.742 --> 00:34:05.212 
你的app通過
調用下個Drawable方法 

00:34:05.279 --> 00:34:07.114 
抓取了一個Drawable外觀

00:34:07.881 --> 00:34:12.152 
當調用Current Render
Pass Descriptor時 

00:34:12.219 --> 00:34:14.454 
可以執行MetalKit 

00:34:16.089 --> 00:34:20.761 
一旦Drawable適用
方法將只能返回 

00:34:21.495 --> 00:34:24.665 
若那時恰巧有個適用的可取值 

00:34:24.731 --> 00:34:26.099 
它將立即返回

00:34:26.166 --> 00:34:29.902 
很好 你可以使用框架 繼續做

00:34:29.969 --> 00:34:32.773 
然而 若沒有適用的app 

00:34:32.840 --> 00:34:35.342 
確切地說爲它調用 它將被封鎖直至 

00:34:35.442 --> 00:34:39.880 
至少下個顯示
間隔正在等待一個Drawable

00:34:39.947 --> 00:34:41.181 
可能會很久

00:34:41.248 --> 00:34:42.549 
60幀每秒

00:34:42.616 --> 00:34:44.618 
我們在說16毫秒

00:34:45.652 --> 00:34:47.387 
真是一個壞消息

00:34:48.522 --> 00:34:52.626 
所以這就是樣本app所做的事情？

00:34:52.693 --> 00:34:56.964 
這就是執行中巨大差距的解釋？

00:34:58.098 --> 00:34:59.633 
我們來看看Xcode是怎麼說的

00:35:00.567 --> 00:35:02.269 
我們轉到框架導航器 

00:35:02.870 --> 00:35:06.273 
看看這裏的框架導航器

00:35:06.340 --> 00:35:08.909 
Xcode與陰影緩衝編碼器

00:35:08.976 --> 00:35:10.911 
之間似乎存在問題

00:35:12.646 --> 00:35:13.847 
這裏有個小警告

00:35:14.982 --> 00:35:16.383 
詳細看一下 

00:35:17.417 --> 00:35:20.187 
事實上 我們確實比實際需要的早

00:35:20.254 --> 00:35:22.623 
調用了下個Drawable方法

00:35:23.257 --> 00:35:25.592 
下個代碼提供了一些非常明智的建議 

00:35:25.659 --> 00:35:28.562 
應該在真正需要這個Drawable
的時候 再調用它

00:35:29.663 --> 00:35:32.566 
所以這個是如何與樣本app相適應？

00:35:34.168 --> 00:35:37.638 
這裏 在樣本app中 
我們有數個pass 

00:35:38.071 --> 00:35:44.211 
在陰影pass前的
每個框架開始時獲得Drawable

00:35:44.278 --> 00:35:48.115 
這實在太早了
因爲直到最後的pass 

00:35:48.182 --> 00:35:49.850 
我們纔將一切拖離屏幕 

00:35:50.384 --> 00:35:56.123 
直到我們渲染UI pass時
我們才需要一個Drawable

00:35:56.690 --> 00:35:59.560 
所以獲取下個
Drawable的最佳位置是

00:35:59.626 --> 00:36:02.095 
自然地剛好早於UI pass

00:36:04.665 --> 00:36:09.603 
我們繼續 做出改變 
隨後將調用移到 

00:36:09.670 --> 00:36:11.405 
下個Drawable 

00:36:12.172 --> 00:36:14.741 
來看看問題是否被解決了

00:36:15.209 --> 00:36:18.245 
你已經看到了 是的 它做到了

00:36:18.445 --> 00:36:22.950 
我們移動第二個同步點 

00:36:23.417 --> 00:36:28.956 
現在在框架上的處理和在CPU上的處
理之間再無任何拖延了

00:36:29.590 --> 00:36:30.924 
這是個巨大的改進 

00:36:33.594 --> 00:36:36.430 
建議很簡單 僅在你真的需要

00:36:36.496 --> 00:36:38.131 
Drawable的時候 再獲取它

00:36:38.866 --> 00:36:41.835 
這是在真的使用渲染pass之前

00:36:42.836 --> 00:36:47.674 
這將確保你隱藏任何長延時 

00:36:47.741 --> 00:36:51.879 
這些延時在沒有適用的
Drawable時就會出現

00:36:52.012 --> 00:36:55.816 
你的app可以繼續做有用的工作 

00:36:55.883 --> 00:36:58.118 
知道真的
需要一個Drawable時 

00:36:58.252 --> 00:36:59.520 
就會出現一個適用的

00:37:01.989 --> 00:37:05.392 
從這點來說 
目前爲止 我們做得非常好

00:37:06.326 --> 00:37:07.728 
但是仍有改進的空間 

00:37:08.462 --> 00:37:12.232 
所以 爲什麼我們不看看GPU的效能

00:37:12.799 --> 00:37:15.402 
而不是降到非常低的水平？

00:37:15.536 --> 00:37:19.439 
試圖最優化着色器或改變紋理格式 

00:37:19.506 --> 00:37:20.774 
諸如此類的

00:37:20.841 --> 00:37:22.809 
爲什麼不看我是否可以提供一般的建議

00:37:23.911 --> 00:37:26.313 
就是這麼巧 這就是了
這涉及到我們如何使用

00:37:26.380 --> 00:37:29.416 
Render 
Command Encoders

00:37:31.118 --> 00:37:35.822 
Render Command 
Encoders是用來 

00:37:35.956 --> 00:37:40.294 
爲單個渲染
pass創建Draw命令的 

00:37:40.861 --> 00:37:45.365 
一個單一渲染pass在顏色獲得
attachment的一個不動集 

00:37:45.432 --> 00:37:49.269 
以及深度和網板
attachment上其作用 

00:37:49.336 --> 00:37:53.006 
一旦開始pass 
就不能變動attachment了 

00:37:53.073 --> 00:37:56.677 
你可以改變作用在它們上面的行動 

00:37:56.743 --> 00:37:59.513 
比如深度網板狀態 

00:37:59.580 --> 00:38:02.816 
顏色蒙版和調配

00:38:02.883 --> 00:38:05.018 
這個值得記住

00:38:06.954 --> 00:38:10.157 
現在 在iOS設備GPU上 

00:38:10.224 --> 00:38:16.363 
尤其重要的渲染編碼器使用方式 

00:38:16.430 --> 00:38:19.066 
取決於它們的結構方式

00:38:19.533 --> 00:38:22.503 
它們是基於圖塊的延遲渲染器

00:38:23.270 --> 00:38:26.006 
每個Render 
Command Encoder

00:38:26.507 --> 00:38:28.775 
可產生2個GPU pass

00:38:29.676 --> 00:38:34.481 
首先 
你有vertex階段 它在編碼器中

00:38:34.548 --> 00:38:41.154 
變換所有的幾何體 然後執行剪貼

00:38:41.221 --> 00:38:47.761 
着色 然後將所有的幾何體裝到

00:38:47.828 --> 00:38:49.396 
屏幕空間圖塊裏

00:38:50.464 --> 00:38:54.434 
緊接着是碎片階段 它通過決定

00:38:54.501 --> 00:38:57.938 
哪些對象是可見的

00:38:58.005 --> 00:39:01.942 
來處理所有的對象圖塊

00:39:02.009 --> 00:39:05.779 
然後只有可見像素才能被處理

00:39:07.014 --> 00:39:10.017 
所有的碎片處理髮生在

00:39:10.083 --> 00:39:12.419 
快速芯片圖塊緩衝器上

00:39:13.754 --> 00:39:16.590 
現在 在渲染結束時 

00:39:16.657 --> 00:39:19.393 
你只需存儲顏色緩衝器

00:39:19.459 --> 00:39:21.361 
你只是放棄了深度緩衝

00:39:21.895 --> 00:39:26.266 
甚至有時你有多個
color attachment 

00:39:26.333 --> 00:39:28.168 
你也只需存儲其中一個

00:39:28.535 --> 00:39:33.774 
不在每個pass存儲圖塊數據 

00:39:33.841 --> 00:39:35.742 
你就節省了不少帶寬

00:39:35.809 --> 00:39:38.745 
你避免了寫出整個框架緩衝器

00:39:38.812 --> 00:39:40.714 
這對於性能來說很重要 

00:39:40.781 --> 00:39:44.651 
因爲它不必加載每個貼圖的數據

00:39:47.421 --> 00:39:50.591 
所以Xcode告訴了我們什麼？

00:39:50.691 --> 00:39:53.660 
它能否爲我們提供 -確切地說 

00:39:55.863 --> 00:40:01.101 
我提到每個編碼器相當於

00:40:01.168 --> 00:40:04.471 
一個vertex pass
和一個碎片pass

00:40:05.272 --> 00:40:08.408 
這甚至在MT編碼器中也適用 

00:40:08.475 --> 00:40:10.143 
這個是相當重要的

00:40:10.777 --> 00:40:13.580 
這裏 事實上 
我們有兩個G buffer編碼器 

00:40:14.181 --> 00:40:17.284 
而第一個似乎沒繪製任何東西 

00:40:17.351 --> 00:40:19.253 
我猜這是誤操作造成的 

00:40:19.987 --> 00:40:23.290 
事實上 它對性能還是有影響的

00:40:24.758 --> 00:40:26.627 
但是看下app的系統軌道
就可以知道

00:40:27.961 --> 00:40:33.267 
由於空編碼器
在GPU中消耗了2.8毫秒 

00:40:34.001 --> 00:40:39.139 
由此推測它剛爲
我們所有的attachment

00:40:39.206 --> 00:40:41.742 
三個顏色和兩個深度

00:40:41.975 --> 00:40:44.278 
和網板寫出了清晰的顏色

00:40:46.346 --> 00:40:50.551 
這個特殊框架GPU處理時間 

00:40:50.617 --> 00:40:52.886 
總計是22毫秒

00:40:54.555 --> 00:40:56.957 
現在 如果我們移除MT編碼器 

00:40:57.024 --> 00:41:00.327 
這可以很容易就做到 
因爲MT編碼器本就不該

00:41:01.261 --> 00:41:05.332 
在第一個位置時間就降到了19 
非常好 

00:41:05.399 --> 00:41:06.800 
只需做極少的事情 就達成目標

00:41:07.167 --> 00:41:09.469 
所以小心這些MT編碼器 

00:41:09.536 --> 00:41:11.839 
若你不打算在pass進行任何繪製 

00:41:11.905 --> 00:41:14.241 
就別啓動編碼

00:41:17.644 --> 00:41:19.646 
我們來詳細看一下

00:41:19.746 --> 00:41:22.783 
來看看樣本app上的渲染pass 

00:41:22.850 --> 00:41:24.284 
並看看我們都有些什麼

00:41:25.485 --> 00:41:27.387 
所以我們有一個陰影pass 

00:41:27.454 --> 00:41:30.090 
它轉化成了一個深度緩衝器

00:41:30.991 --> 00:41:32.426 
有一個G buffer pass 

00:41:32.492 --> 00:41:34.661 
它轉化成3個
color attachment

00:41:34.728 --> 00:41:36.763 
一個深度和網板attachment

00:41:37.464 --> 00:41:40.167 
有這三個lighting pass

00:41:40.234 --> 00:41:45.138 
它用來自G buffer pass
的渲染attachment數據

00:41:45.272 --> 00:41:48.342 
要麼通過紋理單位進行取樣 

00:41:48.408 --> 00:41:51.311 
要麼加載到框架緩衝器內容

00:41:52.546 --> 00:41:57.117 
當lighting pass
使用這個數據時 

00:41:57.618 --> 00:42:00.087 
它們完成lighting和輸出 

00:42:00.153 --> 00:42:02.789 
使之成一個單一積聚對象 

00:42:02.856 --> 00:42:04.157 
這個對象被多次使用

00:42:04.858 --> 00:42:07.394 
最後你有一個用戶界面pass 

00:42:07.461 --> 00:42:10.531 
在這個pass上 
用戶界面元素在屏幕上

00:42:11.098 --> 00:42:12.466 
被畫出並被展示出來

00:42:13.967 --> 00:42:18.071 
所以 這是否是編碼器最有效的設置？

00:42:18.872 --> 00:42:22.576 
再一次 
我們調用Xcode框架調試器 

00:42:22.643 --> 00:42:24.178 
看看它是否還有什麼問題

00:42:25.312 --> 00:42:26.813 
再一次 是的 它做到了 

00:42:26.880 --> 00:42:29.616 
它和sunlight編碼器不協調

00:42:30.450 --> 00:42:31.852 
我們來詳細看一下 

00:42:32.486 --> 00:42:35.522 
使用命令編碼器並沒有什麼效率

00:42:36.857 --> 00:42:38.926 
使用Xcode就足夠了 
它可以告訴我們 

00:42:38.992 --> 00:42:41.862 
事實上 我們應該聯合哪一些 

00:42:43.564 --> 00:42:47.668 
我們繼續 來合併一些pass 

00:42:48.168 --> 00:42:51.371 
與其合併兩個 不如合併三個 

00:42:51.438 --> 00:42:54.141 
他們都在同一個上起作用
color attachment

00:42:54.908 --> 00:42:56.710 
我們繼續 進行合併 

00:42:56.910 --> 00:42:58.612 
這裏 我們有6個pass 

00:42:59.246 --> 00:43:01.682 
現在他們將把它們合併成4個

00:43:02.950 --> 00:43:06.954 
所以對於性能
GPU方面會有什麼影響呢？

00:43:07.888 --> 00:43:11.425 
我們轉到GPU 系統軌道

00:43:12.459 --> 00:43:16.864 
這裏可以看到 我們從21毫秒 

00:43:16.930 --> 00:43:20.934 
6個pass降低到18 而且不需要

00:43:21.001 --> 00:43:23.770 
寫出所有的加載 
存儲所有的attachment數據

00:43:24.505 --> 00:43:25.839 
真是好極了 

00:43:27.241 --> 00:43:29.042 
但是 是否能在進一步呢？

00:43:30.143 --> 00:43:31.845 
讓我們回到app 

00:43:32.746 --> 00:43:39.686 
我們有4個pass它是否真的可以

00:43:39.753 --> 00:43:44.658 
合併G buffer和
lighting pass免去存儲

00:43:44.725 --> 00:43:49.062 
5個attachment
並將所有的一切都保存在芯片上？

00:43:50.063 --> 00:43:52.599 
是的 它真的可以 

00:43:52.666 --> 00:43:56.570 
我們可以通過巧妙的
使用可編程調配做到這點 

00:43:57.638 --> 00:43:59.373 
這裏 我不會講太多細節 

00:43:59.439 --> 00:44:04.144 
我們所做的是 
將兩個編碼器合併成一個

00:44:04.711 --> 00:44:07.381 
現在 三個渲染編碼器被留下來 

00:44:08.048 --> 00:44:12.386 
我們必須加載並存儲
極少的attachment數據 

00:44:12.452 --> 00:44:13.921 
從帶寬方面來說

00:44:13.987 --> 00:44:15.455 
這是個巨大的勝利

00:44:16.690 --> 00:44:18.659 
來看看有什麼影響

00:44:19.993 --> 00:44:21.161 
事實上 並不多

00:44:21.428 --> 00:44:23.497 
這簡直是出乎意料 

00:44:23.564 --> 00:44:26.200 
我們只減掉了大約1毫秒

00:44:26.667 --> 00:44:28.101 
不是很好

00:44:28.168 --> 00:44:29.603 
我原本希望可以減掉更多的 

00:44:30.971 --> 00:44:33.740 
再一次 Xcode能否挽救我們？

00:44:34.675 --> 00:44:36.944 
我們轉向Xcode框架調試器

00:44:38.245 --> 00:44:41.615 
來詳細看下爲G buffer編碼器

00:44:42.015 --> 00:44:43.817 
加載和存儲帶寬

00:44:45.886 --> 00:44:50.490 
它顯示的是 事實上我們仍然加載
和存儲了大量的數據 

00:44:51.491 --> 00:44:53.694 
原因很簡單

00:44:54.127 --> 00:44:57.564 
看起來似乎是
我們並未爲每個attachment

00:44:58.031 --> 00:45:00.701 
正確設置加載和存儲行動

00:45:01.535 --> 00:45:05.706 
我們只想存儲第一個
color attachment 

00:45:06.106 --> 00:45:08.909 
除了深度
和網板attachment外 

00:45:08.976 --> 00:45:11.745 
其他的都要放棄 我們當然也不想加載

00:45:12.546 --> 00:45:14.982 
這些放棄掉的
color attachment

00:45:16.416 --> 00:45:21.221 
所以 若我做了個簡單的變動 讓加載

00:45:21.288 --> 00:45:24.124 
和存儲行動變得更合適 

00:45:24.825 --> 00:45:28.128 
加載帶寬就被減到0 

00:45:28.195 --> 00:45:31.832 
我們也大量減少

00:45:31.899 --> 00:45:33.734 
存儲attachment數據的數量

00:45:35.302 --> 00:45:38.472 
所以現在有什麼影響呢？

00:45:39.273 --> 00:45:41.875 
先前 GPU上 

00:45:42.242 --> 00:45:44.912 
三個pass就花了17毫秒

00:45:45.812 --> 00:45:48.582 
現在 它減到14毫秒

00:45:48.649 --> 00:45:49.550 
更接近一些了

00:45:51.718 --> 00:45:55.489 
簡而言之 不要浪費你的渲染編碼器 

00:45:55.589 --> 00:45:58.158 
想在它們上面
儘可能的多做些有用的工作 

00:45:59.059 --> 00:46:01.695 
那就不想畫任何東西的時候 

00:46:01.762 --> 00:46:03.330 
就別啓動編碼

00:46:05.265 --> 00:46:10.437 
如果你可以在Xcode的幫助下 

00:46:10.504 --> 00:46:13.073 
合併渲染到同一
attachment上的編碼器

00:46:13.140 --> 00:46:15.008 
這將讓你獲益良多

00:46:17.110 --> 00:46:20.380 
在GPU方面 我們做得相當好 

00:46:20.480 --> 00:46:24.151 
事實上 
我們是在我們的框架預算之內 

00:46:25.485 --> 00:46:28.488 
但我們是否能在CPU上做些什麼呢？

00:46:29.690 --> 00:46:32.693 
如果你記得 我想事實上我們仍然 

00:46:32.759 --> 00:46:34.394 
有點超出我們的框架預算

00:46:35.863 --> 00:46:37.331 
多線程怎麼樣？

00:46:37.397 --> 00:46:39.099 
多線程會如何幫助我們？

00:46:40.234 --> 00:46:43.303 
在多線程方面
Metal允許我做些什麼？

00:46:44.505 --> 00:46:48.575 
很幸運
Metal在考慮了多線程的基礎上 

00:46:49.510 --> 00:46:53.480 
設計出來的
它有一個非常有效的線程安全 

00:46:53.547 --> 00:46:57.284 
和一些多線程渲染工具的可擴展方法

00:46:58.085 --> 00:47:03.090 
它允許你在不同的線程上
同時對多重命令緩衝器進行編碼 

00:47:03.891 --> 00:47:04.958 
你的app控制了

00:47:05.025 --> 00:47:07.895 
正在執行編碼的命令

00:47:09.396 --> 00:47:12.199 
我們來看一下可能的情境 

00:47:12.266 --> 00:47:14.034 
在這個情境裏
我們可能嘗試一些多線程 

00:47:14.968 --> 00:47:17.271 
開始之前 我想要強調 

00:47:17.337 --> 00:47:20.374 
在你開始對你的渲染進

00:47:20.440 --> 00:47:21.742 
行多線程處理之前 

00:47:21.808 --> 00:47:24.178 
你應該積極尋找

00:47:24.244 --> 00:47:26.680 
達到最佳單線程性能的可能

00:47:27.214 --> 00:47:30.017 
在你開始進行多線程處理之前 

00:47:30.083 --> 00:47:32.119 
確保資源足夠 

00:47:34.288 --> 00:47:38.358 
好了 這裏有個示例 
裏面有兩個渲染pass 

00:47:39.326 --> 00:47:45.933 
事實上CPU對
這兩個pass進行編碼時間太長 

00:47:45.999 --> 00:47:51.638 
導致我們錯過了框架截止期限

00:47:53.006 --> 00:47:54.741 
所以 如何改進呢？

00:47:55.375 --> 00:47:57.878 
我們可以繼續 

00:47:58.278 --> 00:48:00.113 
對兩個pass採用並行編輯

00:48:00.881 --> 00:48:06.186 
不僅是設法減少每幀的CPU時間 

00:48:07.287 --> 00:48:10.991 
副作用是 第一個渲染pass會 

00:48:11.058 --> 00:48:13.493 
更快地被提交到GPU中

00:48:16.997 --> 00:48:19.700 
在Metal對象方面
這個看起來是怎麼樣的？

00:48:20.934 --> 00:48:22.369 
如何一起使用呢？

00:48:22.836 --> 00:48:26.240 
照例從
命令隊列中的Metal設備開始 

00:48:28.175 --> 00:48:29.576 
現在這個示例 

00:48:29.643 --> 00:48:30.844 
我們將有三個線程 

00:48:31.912 --> 00:48:34.414 
每個線程需要一個命令緩衝器 

00:48:36.416 --> 00:48:41.755 
這兩個線程每個都有一個Render
Command Encoder 

00:48:41.822 --> 00:48:44.291 
在單獨的pass上起作用 

00:48:45.325 --> 00:48:50.430 
第三個線程上 我們可能有

00:48:51.131 --> 00:48:52.432 
持續執行的多重編碼器

00:48:53.033 --> 00:48:55.035 
爲多線程展示方法

00:48:55.102 --> 00:48:57.371 
可以是非常靈活的 

00:48:58.305 --> 00:49:00.641 
一旦編碼完成了  

00:49:00.707 --> 00:49:03.410 
命令緩衝器就會被提交到命令隊列中

00:49:04.978 --> 00:49:07.181 
所以 你會怎麼設置呢？

00:49:08.549 --> 00:49:09.783 
非常簡單

00:49:10.651 --> 00:49:15.189 
你爲每個線程創建一個命令緩衝器 
然後繼續 

00:49:15.255 --> 00:49:18.926 
像往常一樣初始化渲染pass 

00:49:19.593 --> 00:49:23.130 
現在 重要的一點是命令 

00:49:23.197 --> 00:49:26.934 
在命令裏 
命令緩衝器將被提交到GPU中

00:49:27.835 --> 00:49:29.937 
有可能這對你很重要 

00:49:30.270 --> 00:49:33.874 
所以你通過調用命令緩衝器裏的 

00:49:34.308 --> 00:49:37.277 
Enqueue方法執行它 

00:49:37.344 --> 00:49:40.814 
它在命令隊列裏保存了位置 

00:49:41.148 --> 00:49:43.584 
所以當緩衝器運作時

00:49:43.984 --> 00:49:47.154 
它們將按照排列的順序被執行

00:49:47.754 --> 00:49:49.890 
這點很重要 需要記住

00:49:50.490 --> 00:49:55.095 
因爲隨後爲每個線程創建渲染編碼器 

00:49:55.762 --> 00:50:00.067 
然後繼續
在分開的線程中對繪製進行編碼 

00:50:00.133 --> 00:50:02.102 
然後提交命令緩衝器

00:50:02.736 --> 00:50:04.471 
真的很簡單 

00:50:06.840 --> 00:50:08.742 
其他可能從多線程中

00:50:08.842 --> 00:50:11.245 
獲益的情境怎麼樣？

00:50:13.080 --> 00:50:15.249 
這裏 我們有兩個pass 

00:50:15.782 --> 00:50:18.018 
其中一個比另一個明顯長很多

00:50:18.819 --> 00:50:20.621 
可以將它分離嗎？

00:50:20.888 --> 00:50:22.189 
是的 可以 

00:50:22.523 --> 00:50:25.692 
我們將它分成兩個單獨的pass 

00:50:26.059 --> 00:50:27.261 
這裏 我們有三個線程 

00:50:27.895 --> 00:50:29.830 
一個在第一個渲染pass上起作用 

00:50:29.897 --> 00:50:33.400 
另兩個則在第二組塊上起作用

00:50:34.234 --> 00:50:37.037 
再一次 通過使用多線程 

00:50:37.104 --> 00:50:39.740 
我們沒有超過框架截止期限 

00:50:40.407 --> 00:50:42.776 
我們在CPU上節省了一些時間 

00:50:42.843 --> 00:50:45.245 
可以用來做我們喜歡的事

00:50:45.779 --> 00:50:48.115 
無需更多的Metal工作 

00:50:49.650 --> 00:50:52.953 
我們怎麼確切地說這看起來像什麼？

00:50:54.521 --> 00:50:58.358 
再一次 我們有設備和命令隊列 

00:50:59.526 --> 00:51:02.296 
在這個示例中 我們將用到三個線程 

00:51:03.864 --> 00:51:06.733 
但是我們只想用一個命令緩衝器 

00:51:09.069 --> 00:51:13.273 
有Render Command
Encoder的特別格式 

00:51:13.340 --> 00:51:16.076 
Parallel Render 
Command Encoder

00:51:16.176 --> 00:51:21.448 
現在 這允許你越過多重線程 

00:51:21.815 --> 00:51:26.053 
爲單個編碼器分離工作
在iOS上使用這個尤其重要 

00:51:26.453 --> 00:51:30.457 
因爲它確保線程的工作量

00:51:30.524 --> 00:51:34.194 
隨後在GPU中
被合併成一個單個pass

00:51:34.261 --> 00:51:38.699 
所以pass之間並無加載和存儲 

00:51:38.832 --> 00:51:41.335 
如果你將在多重線程裏拆分

00:51:41.401 --> 00:51:43.971 
一個單個pass
使用這個就很重要了

00:51:45.506 --> 00:51:47.941 
從Parallel Render
Command Encoder裏 

00:51:48.008 --> 00:51:52.012 
我們創建了三個從屬命令編碼器 

00:51:53.213 --> 00:51:56.783 
現在每個都將編碼成命令緩衝器 

00:51:57.184 --> 00:52:01.054 
因爲我們正在多重線程化 

00:52:01.522 --> 00:52:03.190 
編碼可能在不同的時間裏被完成 

00:52:03.257 --> 00:52:05.692 
無需特別的命令

00:52:06.860 --> 00:52:09.530 
然後命令緩衝器提交到隊列 

00:52:10.597 --> 00:52:12.666 
現在 它完全可行 

00:52:12.733 --> 00:52:15.135 
你甚至可以有並行

00:52:15.202 --> 00:52:18.105 
Parallel Render 
Command Encoders

00:52:18.539 --> 00:52:22.776 
多線程可能性並非無止境 

00:52:22.843 --> 00:52:23.710 
但是非常的靈活

00:52:24.444 --> 00:52:26.780 
你也可以有我們剛看到的 

00:52:26.847 --> 00:52:28.882 
你可以有第四個線程 

00:52:28.949 --> 00:52:32.085 
連續地執行編碼器

00:52:34.188 --> 00:52:36.557 
所以我們如何設置？

00:52:38.325 --> 00:52:42.729 
每Parallel Render 
Command Encoder 

00:52:42.796 --> 00:52:43.897 
創建一個命令緩衝器開始 

00:52:44.431 --> 00:52:46.233 
不管有多少個使用中的線程 

00:52:46.300 --> 00:52:47.701 
你只需要一個命令緩衝器

00:52:49.436 --> 00:52:54.141 
然後 和往常一樣 
繼續初始化渲染pass 

00:52:55.209 --> 00:52:58.979 
然後創建真實的並行編碼器 

00:52:59.613 --> 00:53:01.014 
現在 這裏是重要的顯存位寬 

00:53:02.516 --> 00:53:05.452 
在我們創建附屬編碼器時 

00:53:06.019 --> 00:53:09.790 
創建編碼器的命令決定 

00:53:09.857 --> 00:53:12.659 
編碼器提交到GPU的順序 

00:53:12.726 --> 00:53:15.462 
在你爲多線程編碼分離工作量時 

00:53:15.529 --> 00:53:18.432 
就需要考慮到這點

00:53:20.434 --> 00:53:24.605 
然後我們繼續 編碼繪圖 分離線程 

00:53:25.205 --> 00:53:28.709 
然後爲每個附屬編碼器完成編碼 

00:53:29.977 --> 00:53:31.712 
現在 第二個重要的點是 

00:53:31.778 --> 00:53:35.883 
所有的附屬編碼器必須在我們結束

00:53:35.949 --> 00:53:39.253 
並行編碼器編碼之前完成編碼

00:53:40.220 --> 00:53:41.922 
如何執行 取決於你 

00:53:42.923 --> 00:53:46.059 
最後 命令緩衝器致力於隊列 

00:53:48.295 --> 00:53:52.633 
所以 我們繼續 
我們決定對我們的app多線程化 

00:53:53.600 --> 00:53:54.601 
看看都有什麼 

00:53:56.103 --> 00:54:00.641 
先前 我們有連續編碼或pass 

00:54:01.842 --> 00:54:07.114 
這個用了CPU時間的25毫秒 

00:54:08.248 --> 00:54:15.022 
現在 我們找到一種方法
即在一個線程裏編碼陰影pass

00:54:15.856 --> 00:54:20.661 
在其他線程上編碼G buffer
pass和UI pass 

00:54:21.662 --> 00:54:24.264 
現在時間減到少15毫秒 

00:54:25.299 --> 00:54:27.835 
這是一個改進 

00:54:27.901 --> 00:54:32.105 
我們同樣也在CPU上節省了一些時間

00:54:34.174 --> 00:54:36.810 
直到多線程化進行 

00:54:36.877 --> 00:54:40.380 
如果你發現你仍在CPU範圍內 

00:54:40.581 --> 00:54:42.616 
而且你已經做了所有你能做的調查 

00:54:42.683 --> 00:54:46.220 
確定app上沒有愚蠢的事正在進行 

00:54:46.854 --> 00:54:49.289 
那你就可以從多線程化裏獲益了 

00:54:50.023 --> 00:54:51.825 
你可以在多線程上

00:54:51.892 --> 00:54:54.061 
同時編碼渲染pass

00:54:54.761 --> 00:54:57.831 
但是你決定在多線程裏分離

00:54:58.298 --> 00:54:59.499 
一個單個pass

00:54:59.967 --> 00:55:03.403 
想用Parallel Render
Command Encoder來做

00:55:06.673 --> 00:55:09.409 
現在 我從這部分學到了什麼？

00:55:10.944 --> 00:55:13.313 
我們介紹了Metal系統尋蹤工具

00:55:13.380 --> 00:55:14.681 
它真的很棒

00:55:14.748 --> 00:55:17.818 
它爲你的app Metal
性能提供了新理解 

00:55:18.619 --> 00:55:21.688 
你想要和Xecode一起配合使用 

00:55:21.822 --> 00:55:23.290 
進行早期分析 並經常進行分析

00:55:25.592 --> 00:55:27.461 
正如我們看到的 你也應該試着 

00:55:27.528 --> 00:55:29.830 
遵循陳述過的最優方法 

00:55:30.631 --> 00:55:34.234 
所以你想提前創建消耗多的狀態 

00:55:34.301 --> 00:55:35.836 
並儘可能重複使用狀態

00:55:36.970 --> 00:55:39.940 
我們想要緩衝動態資源 

00:55:40.440 --> 00:55:44.077 
所以我們可以在框架之間進行有效修改

00:55:44.144 --> 00:55:45.212 
而不會引起任何拖延

00:55:46.747 --> 00:55:50.083 
我們想要確保我們在適當的時候

00:55:50.150 --> 00:55:52.352 
在正確的點上獲得Drawable

00:55:52.719 --> 00:55:54.621 
通常在最後的可能時刻 

00:55:56.089 --> 00:55:58.592 
我們想確保我們有效使用 

00:55:58.659 --> 00:56:00.761 
Render
 Command Encoders

00:56:00.827 --> 00:56:03.163 
我們沒有任何空的編碼器 

00:56:03.230 --> 00:56:06.800 
我們把爲相同
attachment所寫的

00:56:06.867 --> 00:56:08.535 
任何編碼器都合併成一個

00:56:10.103 --> 00:56:14.141 
然後 
倘若發現我們還在CPU範圍內 

00:56:14.208 --> 00:56:18.679 
正如在這裏案例中看到了
我們可以考慮由Metal提供 

00:56:18.946 --> 00:56:20.380 
用來將渲染多線程化的方法

00:56:22.049 --> 00:56:23.150 
所以 我是怎麼做的？

00:56:25.853 --> 00:56:27.788 
現在 看我們的app 

00:56:28.322 --> 00:56:30.791 
我們沒有任何執行期着色器編輯 

00:56:31.692 --> 00:56:36.597 
GPU工作量在框架截止期限內 

00:56:36.663 --> 00:56:37.531 
很好 

00:56:38.198 --> 00:56:40.267 
本來就是CPU的工作量 

00:56:41.368 --> 00:56:45.372 
在CPU上框架之間的處理沒有差距 

00:56:48.442 --> 00:56:51.578 
我們甚至可以決定進行多線程

00:56:52.179 --> 00:56:54.848 
我們節省了不少時間 
可以用來做其他事情 

00:56:56.550 --> 00:56:58.952 
我們設法達到我們的對象 

00:56:59.019 --> 00:57:01.021 
在這個示例中 它是60幀每秒

00:57:01.088 --> 00:57:02.089 
做得好！

00:57:05.225 --> 00:57:08.562 
現在 演講結束了 如果你需要 

00:57:08.629 --> 00:57:11.298 
這部分提到的更多信息 

00:57:11.365 --> 00:57:14.535 
你可以訪問我們的開發者門戶網站 

00:57:14.902 --> 00:57:18.005 
你可以在開發者論壇註冊 

00:57:18.906 --> 00:57:22.543 
任何詳細的問題或一般詢問 

00:57:22.609 --> 00:57:26.079 
你可以將它們發送給艾倫 卡夫 

00:57:26.146 --> 00:57:27.881 
他是我們的圖像和遊戲技術專員 

00:57:29.483 --> 00:57:32.319 
感謝你們來參加這個演講 

00:57:32.386 --> 00:57:34.788 
希望你不會覺得無聊 

00:57:34.855 --> 00:57:37.891 
請享受WWDC剩下的部分

00:57:38.292 --> 00:57:39.293 
謝謝