00:00:21.355 --> 00:00:23.056 
欢迎参加《Swift最新内容》讲座

00:00:29.096 --> 00:00:31.832 
我是克里斯·拉特纳
我来主讲前半部分

00:00:31.899 --> 00:00:35.702 
我的同事约翰·迈克考尔
则会在下半部分介绍最新内容

00:00:36.637 --> 00:00:38.705 
在开始之前我觉得先来看看

00:00:38.772 --> 00:00:41.475 
我们想做什么
这很有趣也许会有帮助

00:00:41.542 --> 00:00:44.444 
Swift 2的目标是什么
以及它背后的思想是什么？

00:00:45.412 --> 00:00:47.548 
我们主要追求三个目标

00:00:48.282 --> 00:00:49.950 
首先 基础架构 

00:00:50.350 --> 00:00:55.155 
我们希望Swift语言的核心功能
和核心行为以及工具都非常出色

00:00:55.856 --> 00:00:59.426 
许多内容都需要很多在座的朋友

00:00:59.793 --> 00:01:01.395 
在使用Swift过程中产生的反馈

00:01:01.461 --> 00:01:06.133 
其中很多都是...

00:01:06.700 --> 00:01:09.770 
我非常感谢大家所提供的所有反馈

00:01:10.170 --> 00:01:11.872 
大家通过实际使用产生的出色反馈

00:01:12.272 --> 00:01:14.675 
才使得Swift得以不断完善

00:01:15.909 --> 00:01:17.277 
第二 是安全

00:01:18.712 --> 00:01:20.247 
安全性是Swift的核心价值

00:01:21.315 --> 00:01:24.451 
我们的确希望能很容易地编写安全代码

00:01:24.885 --> 00:01:27.287 
我们觉得错误处理结构的新可用性

00:01:27.821 --> 00:01:29.990 
将成为实现这一目的的杰出方式

00:01:30.791 --> 00:01:32.092 
第三是 美观

00:01:33.093 --> 00:01:34.528 
我们希望代码可以非常美观

00:01:35.028 --> 00:01:38.365 
作为编程人员 
我们整天都在和代码打交道

00:01:38.432 --> 00:01:40.000 
这一点对我们非常重要

00:01:40.400 --> 00:01:44.771 
我们在Swift中的新增内容使其
更容易写出自然美观的代码

00:01:45.839 --> 00:01:48.709 
今天我们介绍Swift的五项新内容

00:01:50.811 --> 00:01:53.180 
在我们详细介绍
Swift 2最新内容之前

00:01:53.247 --> 00:01:54.448 
我认为有必要说明

00:01:54.515 --> 00:01:57.351 
Swift 1.2
已经实现了长足进步

00:01:57.518 --> 00:01:58.986 
它不过是在三个月前发布

00:02:00.153 --> 00:02:02.756 
由于时间所限我们没办法
详细介绍这个版本

00:02:02.890 --> 00:02:05.158 
但是如果你感兴趣而且还没有看到过

00:02:05.459 --> 00:02:09.530 
可以看看Swift编程语言书籍
和Xcode 6版本发布说明

00:02:10.663 --> 00:02:12.432 
我们来详细介绍基础架构部分

00:02:14.134 --> 00:02:18.372 
基础架构是关于改进Swift语言的
核心行为以及它该如何通力配合

00:02:18.872 --> 00:02:20.574 
这里有许多小细节

00:02:20.641 --> 00:02:23.810 
这感觉像是在漫无目的地漫步
但是要跟上思路

00:02:24.511 --> 00:02:25.579 
我们先从枚举讲起

00:02:26.780 --> 00:02:29.917 
枚举是Swift最好的功能之一

00:02:30.284 --> 00:02:33.153 
这里我用枚举来
列举一些常见的家养宠物

00:02:34.755 --> 00:02:37.658 
枚举的出色在于它们很容易定义和使用

00:02:38.659 --> 00:02:42.596 
另一方面
如果你已将它们用于游乐场或打印出来

00:02:43.063 --> 00:02:45.098 
你可能就会想要更多

00:02:46.300 --> 00:02:50.470 
在Swift 2枚举可以携带足够的
可以打印的反射信息且效果非常好

00:02:56.610 --> 00:02:58.111 
接下来相关值

00:02:59.046 --> 00:03:03.183 
枚举的出色还在于
它们是差别联合类型的理想模型

00:03:03.417 --> 00:03:04.484 
当有两种不同类型的值

00:03:04.551 --> 00:03:08.522 
需要在同一内容中进行保存时
这就会非常有用

00:03:08.589 --> 00:03:09.423 
对吗？

00:03:09.690 --> 00:03:11.391 
相关值非常强大

00:03:11.458 --> 00:03:13.961 
也许你会用任何一个类型
编写明显的内容

00:03:15.462 --> 00:03:16.964 
这是用来做模型的理想方法

00:03:17.030 --> 00:03:20.901 
但是当你使用时
会有些不快之处

00:03:22.069 --> 00:03:24.571 
这就太糟糕了
大家都不希望是这样

00:03:24.705 --> 00:03:26.807 
有了Swift 2这就不成问题

00:03:32.579 --> 00:03:33.914 
我们再看看递归

00:03:34.515 --> 00:03:37.384 
Swift中的枚举就是代数数据类型

00:03:37.651 --> 00:03:41.655 
在其他语言中
递归代数数据类型非常强大

00:03:41.722 --> 00:03:42.890 
可以做出相当棒的事情

00:03:43.624 --> 00:03:47.094 
问题在Swift中
这些值在枚举中都是内联保存

00:03:47.761 --> 00:03:49.263 
这意味着如果是递归枚举

00:03:49.396 --> 00:03:53.534 
它将会无限令当前的设备很难承受

00:03:53.700 --> 00:03:58.505 
也许在明年会有这方面的变通方案

00:03:58.672 --> 00:04:02.943 
大家可能都见过箱型
可以以此作为参考

00:04:03.010 --> 00:04:05.245 
但是要打破模式匹配
就会很难看 很可怕

00:04:07.014 --> 00:04:08.415 
在Swift 2中有更好的方法

00:04:08.615 --> 00:04:10.784 
在beta 1中还不太好

00:04:10.984 --> 00:04:13.120 
不过很快
你就可以间接标识自己的情况

00:04:13.687 --> 00:04:16.656 
可以自然地进行表达模式匹配
效果也很棒

00:04:18.291 --> 00:04:20.127 
我们来继续介绍范围

00:04:24.932 --> 00:04:26.967 
有些时候你想重复使用某个名称

00:04:27.167 --> 00:04:29.770 
也许是想确定某个之前发布的资源

00:04:30.804 --> 00:04:34.808 
我们引入了可以介绍显性范围的
新Do语句

00:04:35.542 --> 00:04:38.879 
在本例中 我们只想
时不时和网络挑衅打交道

00:04:38.946 --> 00:04:41.381 
但是我们需要紧紧地约束它们

00:04:42.349 --> 00:04:46.153 
在讲座稍后 我们介绍错误处理部分时
Do语句就会非常重要

00:04:46.753 --> 00:04:50.023 
但是把Do作为关键字
会导致一些潜在歧义

00:04:50.591 --> 00:04:53.961 
这种歧义不是针对编译器
而是在我们读码时会有歧义

00:04:54.895 --> 00:04:57.231 
你不会常常看太长的语句底部

00:04:57.297 --> 00:04:58.599 
我们还有Do While循环

00:04:59.867 --> 00:05:05.038 
通过语句的字符集了解它在做什么

00:05:06.540 --> 00:05:08.041 
我们需要让它变得非常简单

00:05:08.408 --> 00:05:11.578 
通过看语句的字符集关键字就一目了然

00:05:11.912 --> 00:05:15.649 
所以我们把Do While
循环更名为Repeat

00:05:16.049 --> 00:05:18.852 
一看到顶部
你就可以知道这是个循环

00:05:18.986 --> 00:05:19.953 
这样就非常简单

00:05:24.491 --> 00:05:25.826 
我们再看看选项集合

00:05:26.460 --> 00:05:31.198 
选项集合是轻量级超级高效的方法
来表现一组布林值

00:05:31.765 --> 00:05:34.234 
如果你们以前见过
并用过不同的Cocoa API

00:05:34.368 --> 00:05:36.870 
并且用过See Like句法
和Or句法

00:05:37.804 --> 00:05:39.773 
这类基本句法实际上非常不错

00:05:41.141 --> 00:05:45.512 
问题在于当你使用其他句法时
就不会是这样

00:05:45.579 --> 00:05:48.081 
你用零值生成选项集合...

00:05:48.582 --> 00:05:49.449 
这不太合理

00:05:49.516 --> 00:05:53.620 
因为选项集合和可选类型是
完全不同的概念结果却混为一谈

00:05:54.188 --> 00:05:56.089 
你从按位操作将之提取出来

00:05:56.156 --> 00:05:59.826 
这样非常麻烦而且非常容易出错
你也会很容易犯错

00:06:00.427 --> 00:06:02.796 
有了Swift 2
我们会采用选项集合

00:06:02.863 --> 00:06:04.198 
这样会更糟糕

00:06:04.264 --> 00:06:06.800 
因为Swift1.2 是 
一类集合类型

00:06:07.234 --> 00:06:12.005 
上述组合使得选项集合
似乎退回到C语言

00:06:12.573 --> 00:06:13.407 
而事实就是如此

00:06:15.742 --> 00:06:18.345 
但是Swift 2解决了这个问题
它将选项集合变得像集合

00:06:18.879 --> 00:06:21.682 
这就是说选项集合和集合
现在都是带方括号

00:06:22.216 --> 00:06:25.052 
也就是说你会获得
带方括号空集的空集

00:06:25.485 --> 00:06:29.089 
你也会得到整套标准集合API
来与选项集合相配合

00:06:29.223 --> 00:06:30.757 
这样做非常容易而且效果极佳

00:06:36.563 --> 00:06:37.431 
还有一个好处是

00:06:37.497 --> 00:06:40.234 
你可以用更简单的方式
定义自己的选项集合

00:06:40.968 --> 00:06:43.270 
你现在只需要定义自己的集合类型

00:06:43.470 --> 00:06:47.107 
或结构类型
集合的结构类型

00:06:48.075 --> 00:06:50.744 
以符合新的选项集合类型协议

00:06:51.478 --> 00:06:53.881 
找到存放位数的存储

00:06:53.947 --> 00:06:57.217 
定义需要放入选项集合中的元素

00:06:58.318 --> 00:07:01.955 
只需要简单进行定义
你就可以获得我们谈到的所有句法

00:07:02.589 --> 00:07:05.959 
这就是相当棒的一点
它不需要进行任何编译器匹配

00:07:06.460 --> 00:07:08.929 
这可以通过一个新功能

00:07:08.996 --> 00:07:11.398 
名为Default Implementations

00:07:12.065 --> 00:07:14.368 
和选项集合类型提供的
Protocols自动实现

00:07:14.434 --> 00:07:17.304 
我们实在没时间在这里详细介绍

00:07:17.571 --> 00:07:19.540 
Default Implementations
和Protocols

00:07:19.606 --> 00:07:22.142 
但是我们有一场相当棒的讲座
详细介绍协议方面的内容

00:07:23.710 --> 00:07:25.579 
我们来谈谈函数和方法

00:07:27.414 --> 00:07:31.451 
Swift将函数和方法统到
单一的函数声明中

00:07:31.818 --> 00:07:37.291 
将两个完全不同的概念放在类型系统中
构成一个漂亮的函数核

00:07:37.457 --> 00:07:38.859 
这样做非常棒

00:07:39.560 --> 00:07:42.062 
这个漂亮的函数核
就是Swift的关键部分

00:07:42.696 --> 00:07:45.032 
在你想要调用这些内容时
就会立刻分解

00:07:45.933 --> 00:07:47.734 
因为它们用的是不同的参数标签

00:07:48.435 --> 00:07:50.938 
这对很多人来讲都相当麻烦

00:07:52.406 --> 00:07:53.841 
如果我们来看这是从何而来

00:07:53.974 --> 00:07:56.610 
可以看出Swift是效仿
Objective-C的先例

00:07:57.244 --> 00:07:58.812 
C语言并无参数标签

00:07:59.079 --> 00:08:01.648 
参数标签对Objective-C
的方法而言非常重要

00:08:01.915 --> 00:08:02.883 
Swift也是如此

00:08:04.017 --> 00:08:06.119 
在Swift 2中
我们不仅解决了个问题

00:08:06.954 --> 00:08:10.390 
现在函数和方法是同样的声明句法

00:08:10.958 --> 00:08:12.326 
它们按照同样的方式发生作用

00:08:13.827 --> 00:08:17.297 
当你调用全局函数时
你在默认状态下提供参数标签

00:08:19.433 --> 00:08:20.834 
所有内容都是统一的

00:08:25.806 --> 00:08:29.176 
因此需要了解的关键内容是
这会影响到纯粹的Swift代码

00:08:29.243 --> 00:08:32.145 
如果声明Swift中的全局函数
你就会在默认状态获得这个行为

00:08:33.246 --> 00:08:37.083 
从C语言引入的函数会继续
按照它们一贯的方法行为

00:08:37.150 --> 00:08:41.020 
因为在C语言函数中的参数名称
不是API的组成部分

00:08:41.087 --> 00:08:42.256 
也不会被当做是API

00:08:42.990 --> 00:08:46.860 
但是我们希望Swift代码可以继续
将函数标签包括在参数中

00:08:47.794 --> 00:08:51.732 
如果要想要深入了解
这里还有更多内容

00:08:52.666 --> 00:08:55.202 
Swift函数使用参数

00:08:55.536 --> 00:08:58.972 
参数为每个值有不同名称

00:08:59.573 --> 00:09:01.808 
当你用句法声明某项内容时

00:09:02.075 --> 00:09:03.644 
你会获得默认行为

00:09:04.678 --> 00:09:09.216 
参数获得的两个名称
一个是调用者看到的外部名称

00:09:09.483 --> 00:09:11.618 
一个是执行方看到的内部名称

00:09:12.186 --> 00:09:17.724 
在默认状态下第一个的参数并未
向其外部客户端显示标签名称

00:09:17.925 --> 00:09:20.327 
你可能会在
执行方法时用到

00:09:21.495 --> 00:09:26.333 
同样 第二个和之后的参数
都是默认为内外相同

00:09:26.400 --> 00:09:30.504 
这就是为何你会看到
有该参数的参数标签

00:09:31.238 --> 00:09:35.042 
这种模型最棒的一点是
当你理解这点就可以对之进行自定义

00:09:35.375 --> 00:09:39.179 
例如 在本例中可以将标签

00:09:39.246 --> 00:09:41.415 
放在第一个参数上
这样你会知道它是什么

00:09:41.882 --> 00:09:44.451 
只要重复参数名称
即可实现

00:09:44.785 --> 00:09:45.719 
这非常简单

00:09:46.320 --> 00:09:47.821 
同样 如果想要删除某些内容

00:09:47.888 --> 00:09:52.292 
你可以用下划线显性设置该名称
表明要删除参数标签

00:09:52.926 --> 00:09:56.763 
这么做我们就犯下了
最严重的命名错误

00:09:56.830 --> 00:09:58.232 
让布林值没有标签

00:09:58.966 --> 00:09:59.800 
好的!

00:10:02.336 --> 00:10:04.071 
更好的一点是

00:10:04.137 --> 00:10:07.808 
发生的整个改变会令标签在
系统中更为显著

00:10:07.875 --> 00:10:10.344 
让API如此便于使用

00:10:10.944 --> 00:10:13.914 
而且这会让我们将复杂简化很多

00:10:14.381 --> 00:10:16.116 
现在函数和方法都在同样发挥作用

00:10:16.583 --> 00:10:18.919 
我们还可以取消默认函数的特殊规定

00:10:19.319 --> 00:10:20.654 
这里还有非常奇怪的句法

00:10:20.721 --> 00:10:23.290 
谁也不记得它是什么
现在也不见了

00:10:23.423 --> 00:10:24.258 
这样就会好得多

00:10:25.792 --> 00:10:27.094 
我们接着会谈到编译器

00:10:27.561 --> 00:10:30.230 
谈到警告和错误消息
是编译器而成的

00:10:31.131 --> 00:10:33.734 
这里的代码是合理代码

00:10:33.800 --> 00:10:35.235 
也许你之前写过类似内容

00:10:35.302 --> 00:10:36.503 
我要更新一点内容

00:10:37.771 --> 00:10:41.008 
如果你使用Swift 1编译器
它会生成这个样子

00:10:42.476 --> 00:10:46.213 
我不了解大家会怎样
这并没有什么用

00:10:47.247 --> 00:10:48.949 
Swift 1.2则要好很多

00:10:49.116 --> 00:10:53.053 
Swift 1.2会生成错误消息
并告知我出现了问题

00:10:53.153 --> 00:10:55.756 
现在我发现无法对之赋值

00:10:56.156 --> 00:10:57.624 
当然这还不够好

00:10:57.791 --> 00:11:01.128 
我们继续研究编译器
生成的错误消息和警告

00:11:01.495 --> 00:11:05.566 
在Swift 2中 它表示
“你不能给x赋值因Self不可变”

00:11:06.099 --> 00:11:10.270 
Xcode会告知你可以把方法
标为可变 这样就解决了问题

00:11:11.171 --> 00:11:13.273 
这是个很棒的方法
我觉得很多人...

00:11:13.340 --> 00:11:16.343 
它会帮助很多人
更好地了解Swift中的可变性模型

00:11:16.643 --> 00:11:17.978 
并让代码更为出色

00:11:24.818 --> 00:11:27.287 
当然这才只是一个实例
这样的例子还有很多

00:11:27.688 --> 00:11:31.992 
我们还添加了警告的实例

00:11:32.059 --> 00:11:34.728 
如果你的变量声明为常数

00:11:34.795 --> 00:11:37.464 
我们就会生成警告
要使用Let来替代Are

00:11:37.931 --> 00:11:42.936 
Swift移植工具会在许多情况下
用Let替代Are自动移动许多代码

00:11:43.804 --> 00:11:47.708 
我们都会警告如果你声明一个值
无论是Let还是Are都不要使用

00:11:48.275 --> 00:11:51.044 
如果你使用函数方法

00:11:51.912 --> 00:11:52.913 
然后忽略结果

00:11:52.980 --> 00:11:56.283 
因为你可能是想使用变异方法

00:11:56.450 --> 00:11:57.851 
我们会对所有这些生成警告

00:11:58.051 --> 00:11:59.653 
还有简单的实例

00:12:00.754 --> 00:12:01.955 
我们来谈谈SDK

00:12:05.425 --> 00:12:08.829 
这是Swift的核心内容
它与Cocoa配合很好

00:12:09.062 --> 00:12:10.931 
有了Objective-C API

00:12:11.265 --> 00:12:16.203 
Swift编译器不清楚指针是否应为
零以及集合的元素类型是什么

00:12:16.837 --> 00:12:19.139 
我们引入了若干
Objective-C的新功能

00:12:19.406 --> 00:12:21.275 
包括表达可空性的能力

00:12:21.642 --> 00:12:24.745 
Objective-C的
集合元素类型

00:12:25.412 --> 00:12:27.948 
有整系列的其他功能

00:12:28.115 --> 00:12:31.118 
为Swift的Objective-C
代码提供优质体验

00:12:31.952 --> 00:12:33.387 
最棒的一点是

00:12:33.487 --> 00:12:37.057 
Apple的框架工程师
完成一项杰出的工作

00:12:37.124 --> 00:12:39.593 
他们采用了所有这些
现代Objective-C功能

00:12:39.893 --> 00:12:44.398 
在Swift的各种平台上
Cocoa SDK整体表现都很出色

00:12:44.464 --> 00:12:45.532 
而你无需做任何工作

00:12:46.567 --> 00:12:49.169 
不过
如果你有Objective-C代码

00:12:49.236 --> 00:12:51.872 
也许在你项目中混合并
匹配了Objective-C代码

00:12:52.206 --> 00:12:55.776 
也许你想在Swift中拥有更美观的
Objective-C框架

00:12:56.210 --> 00:12:59.580 
今天晚些时候
可以看看部分讲座内容了解更多功能

00:12:59.646 --> 00:13:02.216 
这样你就可以提供
出色的Swift体验

00:13:02.983 --> 00:13:04.651 
你可能需要看看视频

00:13:06.720 --> 00:13:07.788 
我们来谈谈单元测试

00:13:08.355 --> 00:13:11.558 
在整个工具组
测试都是非常重要的

00:13:11.625 --> 00:13:13.427 
Swift中的测试功能非常不错

00:13:14.561 --> 00:13:16.096 
不过访问控制则不然

00:13:16.530 --> 00:13:22.503 
问题是Swift要求你将符号
Public标为对单元测试束可见

00:13:22.736 --> 00:13:26.373 
如果可以测试
就不应该公开大量内容

00:13:27.007 --> 00:13:29.576 
Swift 2和Xcode 7
解决了这一问题

00:13:30.277 --> 00:13:32.479 
现在你的代码会自动搭建成特殊模式

00:13:32.779 --> 00:13:34.147 
表示这是测试中

00:13:34.381 --> 00:13:37.651 
它们默认可以访问你的公开和内部符号

00:13:38.051 --> 00:13:40.220 
你必须要用到新的app...

00:13:45.125 --> 00:13:49.196 
更棒的一点是
这不但非常容易 而且...

00:13:49.429 --> 00:13:51.465 
你仍可以为发布构建
获得正确的行为

00:13:51.532 --> 00:13:55.102 
这样可以获得很好的性能
以及访问控制的保护收益

00:13:55.602 --> 00:13:57.171 
我们有一系列关于测试的讲座

00:13:57.437 --> 00:14:01.308 
我强力推荐《Xcode的UI测试》

00:14:02.075 --> 00:14:03.243 
我们来谈谈富批注

00:14:04.044 --> 00:14:06.413 
游乐场非常棒

00:14:06.480 --> 00:14:09.249 
Xcode可能帮你在编辑器中
使用批注句法 富批注句法

00:14:09.416 --> 00:14:13.587 
搭建漂亮的Swift游乐场

00:14:13.954 --> 00:14:16.056 
句法是Markdown中的一个变量

00:14:16.390 --> 00:14:19.927 
非常不错 很出名 很流行
是很好的句法

00:14:20.260 --> 00:14:22.095 
我们也可以使用文档评论

00:14:22.496 --> 00:14:28.202 
这是说你可以
构建漂亮的富文档评论

00:14:28.435 --> 00:14:30.103 
并在API上为客户显示

00:14:30.170 --> 00:14:32.539 
如果你在生成库
你可以做很棒的事情

00:14:34.041 --> 00:14:35.375 
最后 Xcode的移植工具

00:14:36.043 --> 00:14:38.946 
在Xcode 7中
一打开Swift 1项目

00:14:39.012 --> 00:14:40.447 
它就会弹出信息

00:14:40.881 --> 00:14:42.482 
“我可以为你升级到Swift 2”

00:14:42.983 --> 00:14:44.284 
这大概需要两步骤

00:14:44.351 --> 00:14:46.720 
你可以选择自己的目标
然后它会提供一个dif

00:14:47.221 --> 00:14:49.590 
Swift 2移植工具
实际上非常不错

00:14:49.823 --> 00:14:52.159 
这其中包括从Swift 1

00:14:52.226 --> 00:14:55.529 
转移到Swift 2的
大部分问题和情况

00:14:55.829 --> 00:15:00.234 
包括错误处理模型 
从内容到方法的转移和SDK的改变

00:15:00.434 --> 00:15:05.639 
及诸多的选项集合改变
都搭建在移植工具之中

00:15:05.873 --> 00:15:07.007 
效果相当不错

00:15:08.041 --> 00:15:12.613 
Swift 2中还有相当多的内容 
现在我们没时间一一介绍

00:15:13.413 --> 00:15:14.648 
如果你们对更多详情感兴趣

00:15:14.715 --> 00:15:17.284 
建议看看Swift编程语言书籍

00:15:17.351 --> 00:15:18.352 
已经有新版本推出

00:15:19.186 --> 00:15:22.689 
Xcode 7版本发布说明中
也详细介绍了这方面的改变

00:15:23.690 --> 00:15:25.626 
我们来继续讲模式匹配

00:15:27.628 --> 00:15:31.832 
大家最初遇到模式匹配
也许是在if-let语句中

00:15:32.566 --> 00:15:35.936 
最好使用可选类型

00:15:37.304 --> 00:15:42.109 
有条件地打开
然后将结果捆绑到安全的名称上

00:15:42.609 --> 00:15:43.577 
这非常棒

00:15:44.111 --> 00:15:46.346 
当然 好东西远不止这些

00:15:46.413 --> 00:15:49.650 
我们都曾经见过“金字塔厄运”

00:15:50.150 --> 00:15:52.853 
是指太多if-let语句堆在一起

00:15:52.920 --> 00:15:55.022 
突然代码已经有15层高

00:15:55.088 --> 00:15:56.156 
你完全搞不懂它

00:15:56.723 --> 00:16:01.762 
Swift 1.2通过在if语句中
引入复合条件解决了这个问题

00:16:02.062 --> 00:16:03.397 
这会就自然多了

00:16:03.463 --> 00:16:04.965 
你可以在内联

00:16:05.399 --> 00:16:09.002 
查看多个可选类型和布林条件 
效果好多了

00:16:09.536 --> 00:16:11.505 
这并没有解决提早退出的问题

00:16:12.272 --> 00:16:18.178 
我给大家看几个也许是
最可怕的JSON处理代码

00:16:18.712 --> 00:16:20.280 
随着时间的推移 情况会改善

00:16:20.380 --> 00:16:21.582 
我们来看这个

00:16:22.115 --> 00:16:25.219 
我从无类型JSON字典中取出各种域

00:16:25.352 --> 00:16:28.388 
我取出名称转化为字符串生成可选类型

00:16:28.555 --> 00:16:29.723 
如果不匹配 我就要想办法

00:16:30.290 --> 00:16:32.960 
同样 取出年信息
转化为In

00:16:33.026 --> 00:16:34.161 
如果不匹配 需要救助

00:16:34.695 --> 00:16:37.664 
如果取出很多值
更常见是最好能采取救助方式

00:16:37.731 --> 00:16:42.236 
而不是深埋在代码中
这种模式更常见

00:16:43.036 --> 00:16:47.741 
这种方式的问题在于
完成时需要强迫打开可选值

00:16:49.076 --> 00:16:50.177 
这里我只使用一次

00:16:50.244 --> 00:16:53.013 
但是如果你有一组代码都使用它们
你就需要到处都要强迫打开

00:16:53.747 --> 00:16:55.382 
你需要做些事情来解决

00:16:55.449 --> 00:16:57.618 
打开可选类型是不错方法

00:16:57.684 --> 00:17:02.155 
它将强迫打开放入不安全的Mecca

00:17:03.557 --> 00:17:08.762 
可能这样做也不大对
也非常难看

00:17:09.229 --> 00:17:10.931 
我们引入了新的Guard语句

00:17:11.098 --> 00:17:13.400 
看待Guard的方法就是
它要做检查

00:17:13.599 --> 00:17:16.203 
若是检查不匹配
就会做救助

00:17:16.770 --> 00:17:18.739 
你可以用过很多Guard语句

00:17:18.872 --> 00:17:20.840 
现在我们来做可选检查

00:17:20.907 --> 00:17:22.643 
我们将一个值绑在名称上

00:17:23.109 --> 00:17:25.012 
它可以发挥作用的方式是

00:17:25.078 --> 00:17:28.949 
是确保Else退出当前的范围

00:17:29.383 --> 00:17:31.552 
可以用两种方式的一种来完成

00:17:31.618 --> 00:17:36.523 
返回 抛出 跳出
有很多方式可以退出范围

00:17:37.758 --> 00:17:38.592 
很好

00:17:38.659 --> 00:17:41.261 
你还可以调用No Return函数

00:17:41.328 --> 00:17:43.197 
例如Precondition Fail
或Abort

00:17:43.263 --> 00:17:44.731 
这些都是停止的不错方法

00:17:45.699 --> 00:17:49.336 
这还可以确保编译器了解安全性和

00:17:49.403 --> 00:17:54.074 
和贯穿代码之后可以看到的确定性

00:17:54.741 --> 00:17:57.444 
如果把这个用在我们的例子中
肯定会边的更好

00:17:57.578 --> 00:17:58.979 
因为我们可以用Guard校对

00:17:59.046 --> 00:18:03.584 
如我们所愿
进行安全 简洁的检查

00:18:04.785 --> 00:18:05.953 
还有一点很棒的是

00:18:06.153 --> 00:18:11.725 
这些都构建在If语句的富复合条件中

00:18:12.226 --> 00:18:13.493 
现在可以将它们合并在一起

00:18:13.560 --> 00:18:16.330 
根据Guard语句 
检查多个布林值和可选类型

00:18:16.396 --> 00:18:19.566 
和我们稍后介绍的其他情况

00:18:19.633 --> 00:18:20.467 
这相当棒

00:18:27.608 --> 00:18:32.813 
我们再看看模式匹配
更强大更有趣的形式 开关语句

00:18:33.680 --> 00:18:37.985 
我觉得开关语句也许是
许多人喜爱的Swift功能

00:18:38.318 --> 00:18:41.288 
因为在开关语句中可以
实现许多模式匹配功能

00:18:41.622 --> 00:18:43.557 
你可以检查可选类型 

00:18:43.790 --> 00:18:46.960 
可以做类分层结构检查
可以检查范围

00:18:47.427 --> 00:18:49.696 
在开关语句中可以实现许多功能

00:18:50.697 --> 00:18:53.600 
当你要写许多条件语句时
这会很棒

00:18:53.700 --> 00:18:55.569 
但是当你只想检查一个条件时 

00:18:55.636 --> 00:18:57.204 
在语句构成方面些笨重

00:18:57.738 --> 00:19:01.041 
它们只能是表达详尽
你必须承认这很麻烦

00:19:01.808 --> 00:19:04.244 
我们所做的是
将模式匹配和开关 条件结合

00:19:04.645 --> 00:19:08.348 
将其带到其他控制语句中

00:19:08.782 --> 00:19:11.451 
这个实例可以写成新的If条件 

00:19:11.785 --> 00:19:15.422 
检查之后 可以做模式匹配
将可变名称绑到语句中

00:19:21.228 --> 00:19:25.265 
我们又向前进了一步
Swift还有一个出色的语句 循环

00:19:26.066 --> 00:19:28.836 
在...循环中
需要完成一些过滤的情况是很常见的

00:19:29.369 --> 00:19:32.739 
有些语言甚至需要
引入全新的语言结构

00:19:32.806 --> 00:19:35.943 
例如列出对此类模式的模型理解

00:19:36.577 --> 00:19:38.178 
通过Swift 2我们完成两项任务

00:19:38.245 --> 00:19:43.183 
我们在...语句中
添加了简单的布林值内联过滤器

00:19:43.917 --> 00:19:47.621 
但是大家也可以在循环中完成

00:19:48.722 --> 00:19:50.390 
全面的模式匹配为你提供强大的条件

00:19:56.163 --> 00:19:59.399 
关于模式匹配的内容
我只能匆匆介绍这些

00:19:59.700 --> 00:20:02.703 
我们介绍了新的Guard语句
非常适合提前退出

00:20:03.003 --> 00:20:06.507 
讲了将模式匹配放到语言各处

00:20:06.874 --> 00:20:08.742 
我们并未谈及其他的改进内容

00:20:08.809 --> 00:20:10.611 
在你开始使用Swift时
就会发现它们

00:20:11.178 --> 00:20:12.946 
谢谢
接下来有请约翰上台

00:20:13.013 --> 00:20:15.082 
他会告知大家
可用性检测方面的内容

00:20:21.355 --> 00:20:22.189 
谢谢 克里斯

00:20:23.557 --> 00:20:25.392 
我们经常推出新功能

00:20:25.626 --> 00:20:28.262 
大家可能听说过
Force Touch

00:20:30.030 --> 00:20:34.735 
Force Touch是硬件功能
当然它还有一系列API

00:20:34.935 --> 00:20:36.970 
正如NSButton中的这个

00:20:37.471 --> 00:20:42.242 
可以让我来改变按钮
对拖拽的反应方式

00:20:43.343 --> 00:20:46.280 
如果我想在自己的app中
采用这个功能

00:20:46.880 --> 00:20:48.081 
将非常简单 对吧？

00:20:48.148 --> 00:20:50.517 
我得编写一些新的事件处理代码

00:20:50.918 --> 00:20:52.452 
然后我需要用到按钮

00:20:52.519 --> 00:20:55.422 
设置热加载属性

00:20:56.223 --> 00:21:00.394 
问题是这在我的开发
设备上效果可能会不错

00:21:00.460 --> 00:21:03.130 
但是当我把它移交到测试硬件时

00:21:04.131 --> 00:21:06.266 
几乎肯定就会出现崩溃

00:21:07.000 --> 00:21:10.370 
这是因为这是个新的API

00:21:10.437 --> 00:21:12.172 
是在X v10.3中引入

00:21:12.706 --> 00:21:16.944 
在这种情况下 和大多数人一样

00:21:18.378 --> 00:21:24.685 
你仍然会需要支持较早版本的OS

00:21:25.552 --> 00:21:28.388 
我怎么解决这个问题呢?

00:21:28.455 --> 00:21:34.661 
我以前常用的解决办法是
我会让方法的错误信息不存在

00:21:34.728 --> 00:21:36.897 
我来看看这种方法是否存在

00:21:37.831 --> 00:21:41.134 
一方面人们开发了
许多不同的惯用语法来实现这一点

00:21:41.201 --> 00:21:44.972 
这是个常见惯用语
使用Responds到Selector

00:21:46.740 --> 00:21:50.577 
问题是这是个容易出错的模式

00:21:51.311 --> 00:21:57.584 
例如 我必须指出选择器是什么

00:21:57.684 --> 00:22:00.988 
从部分Swift语言功能做映射

00:22:01.054 --> 00:22:04.157 
到部分Objective-C选择器

00:22:04.424 --> 00:22:06.760 
这些细节没有必要全部了解

00:22:07.461 --> 00:22:11.265 
要知道编译器也没有帮我检查

00:22:11.331 --> 00:22:15.536 
因为我本来也不愿检查
编译器所提供的内容

00:22:16.436 --> 00:22:19.673 
例如 在本例中我实际上忘记加冒号

00:22:19.740 --> 00:22:22.709 
意思是说检查永远不会为真

00:22:23.410 --> 00:22:25.746 
有了Swift 2
我们有更好的解决方案

00:22:26.680 --> 00:22:29.650 
在默认状态下要确保

00:22:29.716 --> 00:22:35.022 
不要使用部署目标上
最小且不可用的API

00:22:35.756 --> 00:22:37.257 
如果我做这样的事情...

00:22:42.863 --> 00:22:45.666 
如果我做这样的事情
我会经常进行诊断

00:22:46.099 --> 00:22:50.938 
这样我可以有
某种安全核心假设

00:22:51.004 --> 00:22:54.508 
只要我的代码...
只要我的项目完全编译

00:22:54.775 --> 00:22:58.345 
它至少不会包含这种小的部署问题

00:22:58.912 --> 00:23:02.816 
当然这还不全是兼容性的问题

00:23:02.916 --> 00:23:08.155 
但这可以帮你使用新的API

00:23:09.389 --> 00:23:13.627 
我确实想要用这个
怎么办呢?

00:23:14.261 --> 00:23:17.731 
我们添加了新的
#available条件

00:23:18.532 --> 00:23:24.304 
在#available中
你可以列出想要测试的OS版本

00:23:24.671 --> 00:23:27.407 
最后你会用这个星号确定

00:23:27.541 --> 00:23:32.613 
是否在代码里没有的新OS

00:23:32.713 --> 00:23:35.516 
你至少要在这里诊断可用性

00:23:36.850 --> 00:23:38.519 
我已经用了If语句 

00:23:38.585 --> 00:23:42.055 
但是我可以使用克里斯刚
展示给大家的Guard语句

00:23:42.256 --> 00:23:45.592 
这是在所有的地方
都完全相同的条件逻辑

00:23:45.726 --> 00:23:46.560 
就是这样

00:23:47.728 --> 00:23:49.630 
这是可用性检测

00:23:49.696 --> 00:23:51.632 
我们认为这是

00:23:51.698 --> 00:23:58.172 
让你在项目中 自动安全使用新版OS
 新功能的不错方法

00:23:59.072 --> 00:24:02.943 
稍后 我们会介绍更多详情
我非常建议大家能来听

00:24:05.712 --> 00:24:08.215 
接下来 我想谈谈协议扩展

00:24:09.149 --> 00:24:11.852 
扩展是Swift一大特色功能

00:24:12.486 --> 00:24:15.189 
我可以使用任意类型 如Array

00:24:15.489 --> 00:24:17.391 
并在其中加上我自己的方法

00:24:18.125 --> 00:24:23.463 
这一点很重要
但并不明显

00:24:23.530 --> 00:24:26.033 
方法是核心内容

00:24:26.099 --> 00:24:31.338 
这就是类型原生API表达的方式

00:24:31.605 --> 00:24:33.073 
当我添加扩展时

00:24:33.140 --> 00:24:38.979 
我实际添加了感觉像第一类型新功能

00:24:39.379 --> 00:24:45.853 
正如该类型的设计人员已经
加上的API核心类型

00:24:46.486 --> 00:24:49.022 
这会有很多优势

00:24:50.991 --> 00:24:54.461 
这里我加上了Count If方法

00:24:54.528 --> 00:24:58.498 
这就会针对间隔的数组

00:24:58.699 --> 00:25:02.002 
和返回True的次数调用闭包

00:25:02.636 --> 00:25:08.008 
在这种方法中并没有具体针对数组

00:25:08.275 --> 00:25:10.644 
这应该适用于任意集合

00:25:12.379 --> 00:25:17.551 
不过 在Swift 1
我无法用这方法来表达

00:25:18.118 --> 00:25:20.888 
为将这个泛型加到任意集合中

00:25:21.221 --> 00:25:23.023 
我必须要编写像这个样子的编码

00:25:24.491 --> 00:25:28.395 
正如很多人所指出的那样
这并不绝对优化

00:25:28.896 --> 00:25:32.833 
首先 这里有很多额外的句法

00:25:32.966 --> 00:25:36.904 
在其中所有这些尖角括号中有些盲区 

00:25:36.970 --> 00:25:40.040 
所有这些额外的外壳构成了这个泛型

00:25:41.275 --> 00:25:44.511 
其二 这不再是一种方法

00:25:45.312 --> 00:25:47.247 
因为首先它不再是方法

00:25:47.347 --> 00:25:50.884 
它不再像使用该类型的自然部分

00:25:51.518 --> 00:25:54.121 
第二 它很难被发现

00:25:54.555 --> 00:25:58.125 
它不会出现在数组的任何功能列表中

00:25:58.492 --> 00:26:04.164 
特别是它不会出现在功能列表
被完成提供的代码中

00:26:04.665 --> 00:26:10.704 
这意味着你写出
这么漂亮的Count If语句 

00:26:11.238 --> 00:26:16.043 
可是使用它的人都不知道它的存在
除非你指出来

00:26:19.179 --> 00:26:20.414 
好
那我们先回来

00:26:20.747 --> 00:26:24.151 
我们有这个扩展的数组
只要把方法加到数组中即可

00:26:24.484 --> 00:26:27.487 
为什么我们不能扩展...
我不知道...

00:26:27.588 --> 00:26:29.656 
执行集合类型的每项内容?

00:26:30.357 --> 00:26:33.427 
在Swift 2中 
我很高兴地说你可以

00:26:34.561 --> 00:26:38.966 
你可以扩展集合类型
而不是扩展数组

00:26:39.499 --> 00:26:40.334 
当你这么做的时候

00:26:40.400 --> 00:26:46.240 
你会自动把各处的方法
加到执行集合类型的每个类型中

00:26:46.573 --> 00:26:48.642 
不仅是从标准库中或是任何内容中

00:26:48.809 --> 00:26:55.082 
而是就在恰好
符合要求的你自己的类型中

00:26:56.283 --> 00:26:59.453 
这不仅有利于编写自己的泛型代码

00:26:59.520 --> 00:27:06.360 
而且我们发现这可以让我们修改
在Swift 1中不满意的许多内容

00:27:07.427 --> 00:27:12.432 
在Swift 1中有很多内容
都必须是全局函数

00:27:12.733 --> 00:27:16.003 
因为它们必须是泛型
或者因为我们写成了泛型

00:27:16.737 --> 00:27:21.842 
更糟糕的是 为了制作方法
我们选择了特殊条件的部分类型

00:27:21.909 --> 00:27:25.612 
例如
数组有许多这样的映射和过滤方法

00:27:26.079 --> 00:27:29.049 
其他类似Set的类型也许不会有

00:27:30.284 --> 00:27:34.721 
在Swift 2会有这些功能

00:27:34.955 --> 00:27:39.860 
这类过滤和映射功能
会通过扩展表达

00:27:39.960 --> 00:27:42.829 
这意味着在每个内容上都可用

00:27:43.297 --> 00:27:44.998 
还会更容易找到

00:27:45.332 --> 00:27:48.468 
这意味着使用标准库会更为统一

00:27:49.036 --> 00:27:51.104 
我们的确认为大家会喜欢它

00:27:58.378 --> 00:28:01.882 
我还没有介绍到新功能的

00:28:01.949 --> 00:28:05.519 
复杂度的三分之一

00:28:07.254 --> 00:28:11.258 
明天我们有场专门介绍
这方面内容的精彩讲座

00:28:11.725 --> 00:28:14.127 
我强烈建议大家能来听

00:28:14.194 --> 00:28:19.399 
它是关于Swift支持的协议中
杰出的新设计模式

00:28:20.334 --> 00:28:22.369 
讲座的其余部分是关于错误处理

00:28:23.270 --> 00:28:26.507 
我觉得很少有人
会喜欢琢磨错误处理

00:28:27.374 --> 00:28:29.076 
如果大家和我一样的话

00:28:30.344 --> 00:28:34.314 
思想深处都埋藏着这样的想法

00:28:36.483 --> 00:28:38.719 
但它真的很重要

00:28:38.785 --> 00:28:42.422 
当我们在看可以用Swift做点什么

00:28:42.890 --> 00:28:46.760 
使其真正成为更稳健
更具表现力的语言

00:28:47.127 --> 00:28:51.698 
我们觉得这里最重要的问题就是
要进行错误处理

00:28:53.634 --> 00:29:00.440 
当我们看其他语言Cocoa
中的解决方案

00:29:01.575 --> 00:29:03.177 
我们对这些并不满意

00:29:03.777 --> 00:29:08.282 
其中有太多问题
我们真的不很喜欢

00:29:09.316 --> 00:29:13.854 
要知道其中有些是基于自动传播错误

00:29:13.921 --> 00:29:16.323 
比如Objective-C语言中的
NSError

00:29:16.390 --> 00:29:19.793 
它生成了许多重复性的容易出错的代码

00:29:19.860 --> 00:29:23.730 
最后你不得不到处复制

00:29:23.997 --> 00:29:26.567 
这意味着很容易出错

00:29:26.900 --> 00:29:31.305 
更重要的是当你在自己周围传播错误时

00:29:31.772 --> 00:29:36.543 
隐形的默认行为就是
你在忽略错误

00:29:37.077 --> 00:29:39.146 
而这永远都不是正确的默认状态

00:29:39.413 --> 00:29:42.115 
你应该至少考虑一下错误

00:29:43.283 --> 00:29:48.388 
从另外一个角度而言
还有些语言可以显示传播错误

00:29:48.922 --> 00:29:50.324 
例如异常处理

00:29:50.624 --> 00:29:52.893 
但是我们也不喜欢这些的效果

00:29:52.960 --> 00:29:59.933 
很显然在这方面
人们很容易不去考虑这些错误 

00:30:00.000 --> 00:30:02.069 
最后你会掉到坑里

00:30:02.936 --> 00:30:07.274 
自己也不知道到底程序里出现哪些问题

00:30:07.474 --> 00:30:12.045 
你不明白控制怎样会
从一处流到另一处

00:30:12.513 --> 00:30:15.482 
而且这样也不是
安全可靠的编程模型

00:30:19.586 --> 00:30:22.422 
其实函数有三种以不同的方式出现问题

00:30:23.790 --> 00:30:28.128 
一种是许多函数以非常简单

00:30:28.495 --> 00:30:32.499 
而明显的方式出问题

00:30:32.999 --> 00:30:35.002 
例如 除非你在运行编译器

00:30:35.102 --> 00:30:39.840 
你可能并不在乎为什么要分析
字符串失败的整数

00:30:39.973 --> 00:30:45.279 
这种事情报告给用户没什么意思
也不会有趣

00:30:45.546 --> 00:30:48.015 
也许你想直接处理

00:30:48.782 --> 00:30:51.118 
以前我们就是
这样看待这个问题的

00:30:51.251 --> 00:30:53.820 
现在在Swift中
它得到了很好的解决

00:30:53.887 --> 00:30:55.689 
有了可选的结果

00:30:56.256 --> 00:30:58.091 
我们觉得不需要做任何事情

00:30:58.158 --> 00:31:00.060 
我们对现在的办法很是满意

00:31:01.695 --> 00:31:06.800 
从另外一个角度而言
在你的程序中有许多逻辑问题

00:31:07.134 --> 00:31:12.773 
比如程序 人员的错误
索引越界

00:31:13.073 --> 00:31:16.977 
人们使用NSException的
主要方式等等

00:31:18.812 --> 00:31:22.316 
对于这些问题
它们实际上不应该是可恢复的

00:31:22.649 --> 00:31:24.952 
当你可以恢复这类问题时

00:31:25.018 --> 00:31:30.357 
就会导致程序整体不太稳定

00:31:30.657 --> 00:31:37.164 
如果你随机从越界索引中恢复
你不清楚程序的状态究竟如何

00:31:37.564 --> 00:31:40.968 
你可能甚至会在应用中
产生安全问题

00:31:43.370 --> 00:31:44.771 
在中间的

00:31:45.672 --> 00:31:51.612 
是API可能出现错误的
各种具体情况

00:31:52.346 --> 00:31:54.281 
这些是我们真正想关注的内容

00:31:54.581 --> 00:31:58.285 
如今在Cocoa的内容
可以使用NSError 

00:32:01.788 --> 00:32:03.490 
我想给大家举个例子

00:32:03.957 --> 00:32:06.627 
这是个预飞方式
我有某个操作需要预飞

00:32:06.693 --> 00:32:09.062 
以确定它是否可以发挥作用

00:32:09.129 --> 00:32:11.965 
我相信 很多人之前都写过这样的内容

00:32:12.599 --> 00:32:15.469 
我想看看是否部分文档可以访问

00:32:15.536 --> 00:32:18.839 
然后我会重设与操作相关的状态

00:32:20.674 --> 00:32:23.343 
现在来看资源是否可访问

00:32:23.410 --> 00:32:25.712 
这个操作会发生错误

00:32:25.979 --> 00:32:27.981 
可以出现各种各样的错误

00:32:28.048 --> 00:32:29.583 
它应该报告一些内容

00:32:29.650 --> 00:32:35.255 
因为调用者希望知道为什么
有些内容不可访问

00:32:35.489 --> 00:32:38.091 
也许会根据原因进行不同的处理

00:32:40.160 --> 00:32:43.764 
如果我想使用NSError

00:32:44.598 --> 00:32:46.834 
最后代码就会变成这样

00:32:47.201 --> 00:32:50.904 
我会采用这个错误
在调用者之外进行传播

00:32:52.773 --> 00:32:56.143 
就是这种情况

00:32:56.210 --> 00:32:58.312 
有许多问题
我们当真不喜欢

00:32:59.346 --> 00:33:02.449 
它在我的逻辑中增添了许多模板

00:33:02.983 --> 00:33:07.387 
我原本是只有两行的紧凑函数

00:33:07.454 --> 00:33:09.690 
结果变成这样...

00:33:09.756 --> 00:33:13.026 
要知道其中有If语句
额外的嵌套 额外的参数

00:33:13.227 --> 00:33:14.494 
这里有很多内容

00:33:14.761 --> 00:33:20.400 
其目的就是为了表达有错误
我们正将它向调用者传播

00:33:22.169 --> 00:33:23.971 
更糟糕的是

00:33:26.807 --> 00:33:28.008 
这里还有个约定

00:33:28.609 --> 00:33:30.611 
你需要了解这个约定

00:33:30.677 --> 00:33:33.413 
根据这个约定
你必须手动执行才行

00:33:34.214 --> 00:33:36.350 
编译器无法帮到你

00:33:36.416 --> 00:33:40.521 
事实上我这里又犯了错

00:33:40.988 --> 00:33:44.825 
在这个约定中
当你返回False时就会有错误发生

00:33:44.892 --> 00:33:48.028 
我检查的时候
方法也不对

00:33:48.395 --> 00:33:51.298 
我不知道
他们怎么会信得过我来用编译器

00:33:54.067 --> 00:33:57.137 
我需要加上Not才能
得到我想要的行为

00:33:58.438 --> 00:34:01.175 
好的啊 不好意思

00:34:02.442 --> 00:34:05.946 
这就是不利因素
这也是我们喜欢它的原因

00:34:07.447 --> 00:34:10.984 
首先 可以通过读取这个代码

00:34:11.385 --> 00:34:14.955 
检查资源找到出现问题的部分

00:34:15.222 --> 00:34:17.491 
在名称上就说得很清楚
这就是在说错误

00:34:17.791 --> 00:34:21.594 
这是显性的错误处理内容
这是显性错误参数

00:34:22.728 --> 00:34:27.000 
同样很明显地
预飞也是很容易出有问题的操作

00:34:27.201 --> 00:34:31.438 
同样是显性错误参数 返回值 等等

00:34:32.672 --> 00:34:36.810 
其三是没有显性控制流

00:34:37.710 --> 00:34:43.016 
我可以看着它并了解其中
所有的内容

00:34:43.449 --> 00:34:48.054 
我可以像人类那样分析
而不是像编译器那样静态分析代码

00:34:48.188 --> 00:34:50.023 
作为人类
我可以看到这个代码

00:34:50.324 --> 00:34:51.958 
分析它在做什么

00:34:52.458 --> 00:34:56.563 
而不需要了解
每个我在调用的函数细节

00:34:59.733 --> 00:35:00.567 
好

00:35:00.701 --> 00:35:01.935 
我们返回这个例子中

00:35:02.069 --> 00:35:03.337 
它之前是这样

00:35:04.304 --> 00:35:07.040 
如果我用Swift编译
会发生什么情况？

00:35:09.610 --> 00:35:12.379 
我会受到错误消息
因为我没有处理错误

00:35:13.881 --> 00:35:19.586 
在Swift中有两个组件
可用来处理错误

00:35:21.221 --> 00:35:26.727 
第一个是在你调用API出现问题时
必须要用Try关键字

00:35:27.528 --> 00:35:29.096 
Try可以交流

00:35:29.363 --> 00:35:32.266 
它主要就是便于他人读取代码

00:35:32.466 --> 00:35:36.270 
它与你交流道，
“这里就是会出现问题的部分”

00:35:36.570 --> 00:35:40.040 
这是说 当你返回时
当你以后做维护的时候

00:35:40.374 --> 00:35:42.776 
我会直接...

00:35:43.644 --> 00:35:49.249 
Reset State
但并不是每次调用都需要这个函数

00:35:49.650 --> 00:35:51.718 
这里也许还有
很重要的内容需要我知道

00:35:52.085 --> 00:35:54.721 
当我首先编写代码时

00:35:55.055 --> 00:35:56.590 
这是我需要考虑的问题

00:35:56.857 --> 00:36:01.962 
Reset State在我每次
退出函数时 都需要调用吗？

00:36:02.663 --> 00:36:04.398 
对于预飞操作呢？
也许这还不够 

00:36:06.333 --> 00:36:10.037 
我没有以任何方式处理造成错误

00:36:10.404 --> 00:36:15.108 
这是因为在Swift中
在默认状态下 函数不可抛出

00:36:16.109 --> 00:36:19.513 
这是我们的设计的核心内容 

00:36:20.981 --> 00:36:23.984 
因为它意味着错误不可避免

00:36:24.551 --> 00:36:30.724 
你不必考虑所有内容都会
像Java或C#语言那样抛出异常

00:36:30.824 --> 00:36:32.960 
或是基本上
每种语言都在使用异常

00:36:35.128 --> 00:36:38.966 
相反 它是相当具体的内容

00:36:39.032 --> 00:36:42.069 
你知道自己需要是否要考虑将之抛出

00:36:42.269 --> 00:36:45.372 
当你在代码中调用它们时
它会标明Try

00:36:45.672 --> 00:36:47.674 
这一组合可以交流很多

00:36:49.276 --> 00:36:53.347 
好的 假设我先要向调用者
传播一个错误

00:36:53.914 --> 00:36:57.050 
为此 我只需告知编译器

00:36:57.117 --> 00:37:00.020 
“可以让它把错误抛出”

00:37:00.721 --> 00:37:01.889 
我就会抛出

00:37:03.457 --> 00:37:05.959 
这可能不是我想要处理的方式

00:37:06.093 --> 00:37:07.828 
这是个预飞方式

00:37:08.061 --> 00:37:11.765 
我可能想容忍错误

00:37:11.832 --> 00:37:15.469 
告知调用方预飞是否
成功

00:37:16.570 --> 00:37:18.005 
为此 我只能处理它

00:37:18.238 --> 00:37:21.141 
我就编写了Do Catch

00:37:22.509 --> 00:37:24.211 
在Do中的任何代码

00:37:24.811 --> 00:37:30.217 
其中转发的任何错误都会
像过滤所一样被捕获

00:37:31.251 --> 00:37:33.120 
在捕获之后会是什么

00:37:34.721 --> 00:37:36.423 
你在开关语句中
可以编写的任何内容

00:37:36.757 --> 00:37:42.829 
Swift的模式匹配句法
最强大之处在于它可以捕获

00:37:44.431 --> 00:37:47.668 
作为非常简单的常见句法改进

00:37:48.035 --> 00:37:54.241 
这类捕获是捕获的短板

00:37:54.308 --> 00:37:57.477 
并会带入这种特殊的错误变量

00:37:58.312 --> 00:38:00.647 
我还可以写出更精致的内容

00:38:00.714 --> 00:38:04.818 
例如 我可以处理某种错误

00:38:05.319 --> 00:38:08.288 
作为特殊情况
也许在我的预飞中可以接受

00:38:10.657 --> 00:38:13.627 
我不知道为什么不存在的文档可以接受

00:38:13.694 --> 00:38:17.731 
也许我真想看看它是否存在

00:38:18.031 --> 00:38:21.602 
出于某些许可原因它会不会真的使用

00:38:21.969 --> 00:38:23.003 
如果我想

00:38:23.136 --> 00:38:30.077 
我可以对错误代码和域名
直接做像这样的模式匹配

00:38:34.548 --> 00:38:38.619 
另外 还有第三种“处理错误”的方法

00:38:39.286 --> 00:38:41.555 
经常会有这种情况

00:38:42.022 --> 00:38:44.057 
你前提设置了

00:38:44.291 --> 00:38:51.031 
不应该抛出的具体调用

00:38:51.932 --> 00:38:55.469 
例如 也许这个文件在我的app束

00:38:55.802 --> 00:39:02.743 
我知道如果我无法
在自己的app束中读取文件

00:39:03.076 --> 00:39:04.711 
那就真的有问题了

00:39:04.912 --> 00:39:07.347 
也许没有办法可以恢复

00:39:08.382 --> 00:39:10.017 
在这个常见模式中

00:39:10.083 --> 00:39:14.421 
你可能会需要一个致命错误
因为错误抛出

00:39:16.023 --> 00:39:21.061 
它有个非常精简的关联句法 Try!

00:39:21.795 --> 00:39:24.097 
这会生成一个断言

00:39:24.598 --> 00:39:29.603 
其中Try中的代码
不会真正抛出

00:39:29.937 --> 00:39:32.272 
如果抛出
你的程序就会崩溃

00:39:32.339 --> 00:39:33.807 
就像是其他断言错误一样

00:39:34.474 --> 00:39:36.810 
这类问题可以很容易地调试解决

00:39:37.811 --> 00:39:39.580 
你不会总是想要用这类内容

00:39:39.646 --> 00:39:41.582 
但是当你需要它时
这非常方便

00:39:44.885 --> 00:39:45.886 
回来看一下

00:39:47.721 --> 00:39:48.689 
我捕获一个错误

00:39:49.389 --> 00:39:51.391 
错误是什么类型？

00:39:52.492 --> 00:39:54.328 
我们有个协议

00:39:54.461 --> 00:39:57.764 
搭建成标准库ErrorType

00:39:59.132 --> 00:40:05.906 
你可以抛出任何满足
ErrorType类型的值

00:40:06.540 --> 00:40:07.875 
当你捕获到问题时

00:40:09.042 --> 00:40:13.847 
也就是模式匹配的
ErrorType任意值

00:40:14.281 --> 00:40:15.949 
我们觉得重要的是

00:40:17.050 --> 00:40:23.390 
我们不会只跟踪是否要抛出的错误

00:40:23.790 --> 00:40:28.262 
这和Java不同 
你最后会有一个详尽的清单

00:40:28.328 --> 00:40:29.997 
列出可能会抛出的所有异常

00:40:30.130 --> 00:40:34.468 
然后每次改变错误时
你可能都会面对这个复杂的传播问题

00:40:36.003 --> 00:40:39.473 
跟踪错误是否抛出已经足够

00:40:39.706 --> 00:40:41.642 
几乎一直是如此

00:40:42.009 --> 00:40:43.243 
我们认为这是个很好的模型

00:40:45.212 --> 00:40:47.548 
你可以让自己的类型
符合ErrorType

00:40:47.614 --> 00:40:52.319 
这个过程要比Cocoa容易得多

00:40:54.188 --> 00:40:56.823 
枚举是表达的不错方法

00:40:57.424 --> 00:41:00.494 
它们可以很棒地表达一组相关问题

00:41:00.861 --> 00:41:01.929 
正如它们...

00:41:03.497 --> 00:41:04.831 
要知道的确如此

00:41:04.898 --> 00:41:09.303 
因为在枚举中
可以关联每个条件的数据

00:41:09.870 --> 00:41:12.339 
如果我想报告更丰富的错误消息

00:41:12.573 --> 00:41:15.175 
其中包括也许关于...

00:41:15.242 --> 00:41:17.411 
也许我在查看一些无效状态

00:41:17.477 --> 00:41:20.047 
我希望记住无效状态是什么

00:41:20.414 --> 00:41:26.286 
我可以将特例中的相关值
直接嵌入枚举中

00:41:28.522 --> 00:41:32.125 
为了让枚举作为错误可用 
你只需要让它

00:41:32.860 --> 00:41:35.395 
符合ErrorType即可

00:41:35.829 --> 00:41:39.499 
编译器会自动处理合成的细节

00:41:40.000 --> 00:41:45.939 
这要胜过处理生成
新NSError域名和相关内容

00:41:46.340 --> 00:41:48.375 
我们认为当你需要的时候

00:41:48.642 --> 00:41:53.981 
这将会对大家很有帮助
在自己的代码中表达抛出错误API

00:41:58.952 --> 00:42:01.388 
我们回到克里斯之前介绍的例子中来

00:42:01.922 --> 00:42:03.223 
这个JSON处理器

00:42:04.291 --> 00:42:07.761 
我用字符串中的Either返回错误

00:42:09.162 --> 00:42:11.899 
我们让它看起来
更像是Swift中的效果

00:42:12.933 --> 00:42:15.969 
首先 不是用字符串

00:42:16.236 --> 00:42:21.341 
我会用刚谈过的数据错误枚举

00:42:22.776 --> 00:42:23.911 
我必须抛出

00:42:24.077 --> 00:42:26.747 
为了抛出这些值 
我使用新的抛出语句

00:42:27.080 --> 00:42:28.115 
效果不错

00:42:29.183 --> 00:42:32.152 
另一方面是我需要修改返回类型

00:42:32.219 --> 00:42:34.121 
我不再返回Either类型

00:42:34.488 --> 00:42:39.359 
对于这类问题
每个调用者为检查错误

00:42:39.526 --> 00:42:42.129 
不会对返回值认真进行微管理

00:42:43.497 --> 00:42:49.136 
我做了修改
这样就会返回Person即抛出方式

00:42:49.469 --> 00:42:52.773 
这样我就不必在这些小细节上操心

00:42:54.608 --> 00:42:58.011 
我们再来一个新的例子
去除我们刚生成的方法

00:42:59.947 --> 00:43:05.352 
我们来解析JSON语句
我们解析一个人

00:43:06.220 --> 00:43:12.426 
我们用它来解析
涉及此人和一些内容的整个销售记录

00:43:17.664 --> 00:43:22.636 
有时候碰巧你需要知道

00:43:22.703 --> 00:43:26.206 
这是个人为的例子

00:43:26.273 --> 00:43:31.178 
不好意思
有时候我需要观察这类进程

00:43:31.812 --> 00:43:33.614 
我需要进行某种委托

00:43:34.648 --> 00:43:38.085 
我需要让它知道
我开始读取销售数据

00:43:39.820 --> 00:43:42.456 
我现在告知它
我开始读取

00:43:42.756 --> 00:43:45.993 
显然 我在完成读取时
也应该告知它

00:43:47.828 --> 00:43:49.563 
我可以把代码加在下面

00:43:49.630 --> 00:43:55.002 
问题是我在错误处理方面做得不对

00:43:55.369 --> 00:43:57.404 
很容易会...

00:43:57.471 --> 00:44:01.308 
如果我的委托在销售结束时

00:44:01.642 --> 00:44:08.048 
每次都调用Careful和
Variants设置

00:44:08.649 --> 00:44:13.453 
如果我的委托有变化
它希望在两端调用时都保持

00:44:13.687 --> 00:44:16.290 
如果我要搞糟进程
我把这事儿弄混了

00:44:16.690 --> 00:44:22.296 
这类问题常常会出现
会使得错误处理看似很脆弱

00:44:23.697 --> 00:44:27.534 
好的 当然
我可以这样解决问题

00:44:30.671 --> 00:44:34.741 
只要在这些抛出站点 
Did End Reading Sale加入调用

00:44:35.542 --> 00:44:39.813 
随后我仍没有处理
调用Process Person

00:44:39.880 --> 00:44:42.850 
为了做点什么
我必须把它加入Do Catch

00:44:43.984 --> 00:44:47.487 
这相当...相当繁琐

00:44:47.554 --> 00:44:48.856 
但是它的确容易出错

00:44:48.922 --> 00:44:53.427 
因为很容易
让我增添新的代码 新的处理方式

00:44:53.727 --> 00:44:57.898 
如果我当真做什么的话
它就会立刻过期

00:44:58.532 --> 00:45:00.267 
如果我忘记添加

00:45:00.334 --> 00:45:05.405 
Did End Reading Sale
到这个特殊路径

00:45:06.373 --> 00:45:08.475 
Swift 2有着更好的选项

00:45:09.042 --> 00:45:11.478 
叫做Defer

00:45:13.947 --> 00:45:16.750 
Defer语句生成一个动作

00:45:17.651 --> 00:45:19.019 
当你执行时

00:45:20.454 --> 00:45:25.959 
无论当前的范围
是什么动作都会 得以执行

00:45:27.094 --> 00:45:29.630 
如果我返回
如果我出现问题

00:45:29.963 --> 00:45:32.799 
如果我抛出错误
无论怎样

00:45:33.600 --> 00:45:36.270 
我都知道它会得到执行

00:45:37.437 --> 00:45:40.073 
这意味着当有人读取代码

00:45:40.474 --> 00:45:41.909 
维护代码时 

00:45:42.209 --> 00:45:44.411 
我会绝对有信心

00:45:44.912 --> 00:45:47.648 
无论我怎样结束读取销售数据

00:45:48.115 --> 00:45:51.418 
Did End Reading Sale都会执行

00:45:52.019 --> 00:45:54.621 
这是需要掌握的重要内容

00:46:07.467 --> 00:46:09.436 
我简要介绍一下执行情况

00:46:10.270 --> 00:46:15.175 
如果有谁习惯进行异常处理
也许会知道

00:46:15.242 --> 00:46:19.079 
在许多语言中 异常处理的执行方式

00:46:19.313 --> 00:46:23.450 
会非常受到被抛出的错误的影响

00:46:24.218 --> 00:46:29.122 
抛出错误的函数返回

00:46:29.389 --> 00:46:33.393 
也许会比按照正常方式

00:46:33.627 --> 00:46:36.797 
返回慢3个 甚至4个数量级

00:46:37.898 --> 00:46:42.703 
出于语言设计的某些方面的需要

00:46:43.337 --> 00:46:46.507 
我们并非是想在Swift中模仿什么

00:46:49.243 --> 00:46:50.611 
大家在这里只需要知道

00:46:50.677 --> 00:46:54.214 
Swift执行得更为平衡

00:46:55.315 --> 00:46:59.219 
基本上更像是调用者的If语句

00:46:59.686 --> 00:47:04.791 
这是说并非完全自由地
调用可抛出错误的内容 

00:47:05.225 --> 00:47:07.361 
但是这意味着你不必担心

00:47:08.729 --> 00:47:13.233 
我们的错误处理功能造价太高

00:47:14.501 --> 00:47:17.704 
如果出于实际情况中

00:47:17.905 --> 00:47:21.775 
对错误路径 效率的考虑
有些具体原因会令你无法使用它

00:47:25.112 --> 00:47:27.748 
最后 我要说一下Swift

00:47:28.348 --> 00:47:32.619 
Swift的错误处理设计
在Cocoa API中可以发挥作用

00:47:33.921 --> 00:47:38.959 
我们自动识别你在Cocoa中
见到的最常用约定

00:47:39.526 --> 00:47:44.865 
例如
具备NSError Out参数的方法

00:47:44.932 --> 00:47:45.933 
并将返回Bool值

00:47:46.567 --> 00:47:48.435 
自动变为抛出方法

00:47:48.502 --> 00:47:50.470 
Bool的返回值也会返回

00:47:51.371 --> 00:47:52.206 
同样地

00:47:53.106 --> 00:47:54.942 
如果它返回可选结果

00:47:55.075 --> 00:48:00.180 
我们会将模式识别为零值
表明是无效内容

00:48:01.849 --> 00:48:04.084 
因为是零值

00:48:04.985 --> 00:48:09.756 
它就不会再返回包括在
错误处理之内可选结果

00:48:15.362 --> 00:48:17.831 
有着这两条非常简单的规则

00:48:17.931 --> 00:48:22.603 
我们发现系统的大部分API都会输入

00:48:22.870 --> 00:48:28.408 
并自动无缝完美配合
这些新的Swift错误处理模型

00:48:28.809 --> 00:48:31.645 
我认为这是在Swift中
处理错误的伟大新方式

00:48:34.848 --> 00:48:37.351 
我强烈推荐大家去看看

00:48:37.451 --> 00:48:39.219 
你可能没有太多选择

00:48:39.286 --> 00:48:40.454 
它们到处都是

00:48:44.591 --> 00:48:47.060 
要知道
我们对这个设计非常自豪

00:48:47.394 --> 00:48:52.900 
我们认为这将极大改善
编码的稳健性和表达性

00:48:53.133 --> 00:48:56.570 
让你可以设计出非常不错的API

00:48:59.306 --> 00:49:00.274 
我来总结一下

00:49:01.475 --> 00:49:04.311 
我们一直在Swift 2方面
投入大量精力

00:49:04.378 --> 00:49:06.513 
为大家提供新的语言

00:49:06.580 --> 00:49:08.815 
通过Swift中的工具

00:49:09.383 --> 00:49:15.322 
推出Swift的编程的核心方面

00:49:16.390 --> 00:49:19.293 
为大家提供更安全更稳健的环境

00:49:20.227 --> 00:49:22.629 
整体提高产品水平

00:49:24.898 --> 00:49:28.068 
整个过程中
对我们而言 最珍贵的工具

00:49:28.335 --> 00:49:29.837 
就是大家的反馈

00:49:30.137 --> 00:49:31.905 
我们非常非常重视这些

00:49:32.139 --> 00:49:33.540 
我承诺一定会听取意见

00:49:35.542 --> 00:49:37.878 
如果你要告诉我们什么

00:49:38.245 --> 00:49:40.914 
当然 大家可以仅使用
错误报告工具即可实现这一点

00:49:41.281 --> 00:49:46.987 
但是大家也可以联系
斯蒂凡·莱瑟来开发人员论坛

00:49:47.054 --> 00:49:49.056 
我们大部分人始终都会在那里待着

00:49:49.356 --> 00:49:51.825 
我们非常乐于对任何问题进行答复

00:49:52.125 --> 00:49:53.527 
想听到大家的反馈

00:49:53.861 --> 00:49:56.029 
我们非常非常重视你们

00:49:57.164 --> 00:49:59.833 
非常感谢

00:50:03.036 --> 00:50:04.605 
希望大家喜欢WWDC 2015