Watch Connectivity介紹
早上好
歡迎來到Watch Connectivity介紹
我叫克里斯
今天 我的同事亞歷克斯將和我一起 
他隨後會上臺
我們很興奮爲你們展示 
我們一直在watchOS 2和iOS 9上做的東西
今天 我們要說的是 
幫助你們爲Watch app做出
更好更有反響的用戶體驗
爲了簡單說明我們的出發點
watchOS 1上的世界看起來像什麼
之前iOS app和WatchKit擴展都是依賴
iPhone的 且當時主要處理的是WatchKit app通信 
而且這二者都可以共享數據存儲
在watchOS 2 我們已經把WatchKit擴展
擴展到Watch之上 app在Watch可以運行更流暢了
這有不少的好處 
但是也意味着它們都各自使用自己的數據存儲
顯然 下個問題是 我們如何把數據 
搬到Apple Watch上 
這是我們今天要討論的內容
我們將爲你展示解決這個問題的兩個主要方法
如何將數據移到Watch上 
這是新框架WatchConnectivity
我們將它引入了watchOS 2 和iOS 9
然後這是可在Foundation上獲NSURLSession API
也適用於WatchKit擴展 
也已經集成到watchOS 2 
我想今天要討論的話題適用於
大多數Watch app 對於多數人來說也是適用的
今天展示中即將用到的大量示例
將會證明這一點
你可以看到 這個範圍很廣 我們希望每個人
都可以至少辨認出一種
我們先討論WatchConnectivity
這是我們引入watchOS 2 和iOS 9的新架構
它在兩個平臺中都適用 
幾乎所有的API在兩邊都適用
我們將會看到不少iPhone專用的 API
當你開始採用WatchConnectivity
你想做的第一件事是
仔細設置
我們建議儘早進行設置
在使用app的整個過程中 在兩方面都要
在Watch運行的WatchKit擴展和在iOS 9 app內部
你要確保使用代碼路徑進行設置
這樣一來 儘管是在後臺啓動
也還是可以被執行
所以不要把它放在裏面如視圖控制器View Did Load內
因爲當你在後臺啓動時 這些是不會被調用的 
所以在iOS app中
你做的第一件事是查看
是否支持WCSession  
你或許有一個通用的iOS app
意思是代碼可以在iPad上執行 
iPad無法使用WatchConnectivity
你在Watch上執行任何工作之前 請事先檢查一下 
因爲我們不想你浪費CPU做無用功
下一件事情是創建一個對象實例 
你可以通過調用Default Session進行創建
然後在會話對象上設置指派 
最後調用Activate
滴啊用後就可以繼續設置WCSession對象 
初始化所有屬性 而且一旦調用返回 
所有屬性將被更新
更新爲正確的初始化數值
同樣此刻 任何指派回調
任何向上尾接的內容會可以開始進入
這是爲什麼你需要
儘快執行上述步驟的原因
或許有內容正等着上傳到你的app上
所以 請確保提前處理這些步驟
一旦這些步驟完成
下一件你將想做的事情是 查看會話狀態
然後通知你的app  
iOS app和the Watch之間目前的關係如何
所以這些屬性只適用於iPhone app
它正在通知iOS與Watch的關係
所以沒有必要在你的Watch app上使用
因爲基本上不適用
在這個示例中  我們將使用一款新聞app
一款推送最近
有趣文章的應用
首先要做的是執行我們剛纔討論的設置過程
這應當在使用應用的時候儘快完成
下一步進行設備檢查 檢查該設備是否與Watch配對？
如果未配對 那麼相當於這是在iPad上運行
沒什麼需要做的了
你無法進行通訊
所以這個時候 你可能要停止所有在Watch上進行的工作
用戶會出去並買個新的Watch 
然後執行配對步驟
啓動Apple Watch app
操作配對 
設置這些設備
現在當你的app啓動後 
你會得到一個指派回調
說明Watch狀態會話改變了
當你檢查配對屬性的數值時 
你會看到返回爲真 
因爲設備已經配對了
所以 這時候你可以繼續
檢查下個屬性 也就是
Watch app是否安裝了？
如果還未安裝 那麼就沒法通訊 
工作到此爲止
但是 通過默認設置Watch app是默認安裝的 
但是用戶可能會由於某些原因 選擇不進行安裝
在這種情況下 用戶將接續執行並進行重新安裝
返回Apple Watch app
打開設備 如果你的Apple正在運行 
你將再一次獲得指派回調 
你就可以檢查該屬性數值了 
可見Watch App Installed返回爲真
現在 你可以進行通訊了
這時候說明你可以
使用Watch app開始進行通訊了
你需要輸入通訊的內容
無論何時一旦Watch App Installed值爲True 
另個屬性Watch Directory URL也可用 
你會發現一旦Watch App Installed值爲True
Watch Directory URL將會有一個非0值
這將指向在container創建的一個目錄
我們稍微深入地討論一下這個
目錄和它的內容 它的使用週期與
Watch AppInstalled屬性息息相關
WatchAppInstalled值從True變成False 
這個目錄和它的所有內容都會消失
無論何時 當值爲True時 
目錄會再次出現 但是是空目錄
我們建議你 僅在數據與
你的Watch app特別實例有關時才使用
實例是要說明什麼呢 
一些事物 比如最後隊列項目標記
就可以存儲在這
若用戶未安裝並重新安裝app 
那麼Watch app是從一個空的容器開始的
因此這個目錄以開始是沒有內容的 
你需要同步到app通訊的位置
其他你可以保存的事物有偏好設置
當用戶首次運行iOS app時 
你可能想讓他設置一下
想要的Watch app體驗
或許他不想顯示全部內容 
但想要顯示特別主題的前十條新聞 
比如國際新聞或體育新聞
這個位置就很適合來存儲這些設置
同樣 如果你正處理全尺寸的資料 
想生成適合Watch尺寸的資料 
你要壓縮圖片 音頻 視頻 
在提示傳輸時可使用WatchConnectivity
API 將這些資料儲存到這裏 隨後我們會說到這點
所以 這就是Watch 目錄
我們建議你將內容存儲在這 
因爲隨後我們會將內容清理掉 如果Watch消失了 
如果他未配對他的手錶 我們將自動清除這些內容
這樣就省去了管理的麻煩
最後會話狀態屬性是Complication Enabled
用戶並不能啓動Complication 
但可編輯Watch表面然後啓動 
之後你會收到同樣的的回調 
會話或狀態變換信號
當你查看屬性時 現在值將是True
你已經設置 會話WatchConnectivity
已知道watch的狀態是什麼的 
iOS app和Watch app 
之間是什麼關係
下一件事情是開始將信息傳輸到Watch上 
或從Watch傳輸到iOS app上
爲了這麼做 我將邀請亞歷山大 
他將爲我們講解通訊API
謝謝 好的所以就像克里斯說 你設置好了會話
也已經檢查過 設備已經配對了
Apple Watch app也已經安裝了
現在 我們從如何才能
在兩臺設備之間進行通訊
關於通訊 我們有不少分類
第一類是後臺傳輸
後臺傳輸意思是說 
在收到方看來內容並不是立即需要的
因爲內容不是立即需要的 
這意味着在傳輸這些內容時 
系統可以處理其他的事情
除了後臺傳輸外 我們還將講到
交互式信息傳輸
交互式信息傳輸是指
兩個實時溝通的app之間的通訊
所以 這時候兩個app都在使用中它們來回發送信息 
要求響應 之類的事情 
這裏有你可能需要使用
交互式信息傳輸的一些情況
假設你有一個遊戲 用戶正在同時使用兩個app進行遊戲時候 
或者你正在Apple Watch上 
你需要啓動iOS上的一些東西
比如你想要觸發iOS設備 
以便了解用戶位置
我們先來說說第一個 後臺傳輸
關於後臺傳輸 首先要講的是
app內容的類型 以及用戶如何
與這兩臺設備進行互動
還是用新聞app的示例 
這個新聞app有很多內容
它從服務器讀取了不少內容 
而且它斷定這些內容
對於Watch是有用的 
現在用戶並未在目前情況下使用Watch
所以在Watch方面來說 這些內容並不是立即需要的
當然啦iOS app 這個新聞app 
想要挑一些新聞 在系統裏列隊備好
以便系統可以挑選對的內容
進行傳輸
在用戶真的進行接收時
在這個示例中是Apple Watch 
系統將考慮電源和性能的情況
當條件都正確的時候內容將傳輸
它將在接收方這個示例中的Apple Watch中等待
直到用戶啓動接收app  
當接收app啓動 
內容將被傳輸過去 
app也可以更新它的狀態
這是後臺傳輸所提供的
它允許內容列隊等候
系統將爲你傳輸內容
這允許了發送方 發送方app退出
系統將處理接下來的一切
它允許系統挑選合適時間傳輸內容 
允許系統將信息存儲到
接收方 並等待接收app啓動
對於app上有的大部分內容 
我們建議你使用後臺傳輸
原因是 對於接收方來說 
大部分內容並不是立即所需的
當然啦 一旦接收app打開 就需要這些內容了
所以 我們來講講具體細節
我們有三種不同的後臺傳輸類型
第一種是應用上下文
應用上下文代表的是app提供給
另一方的最有趣的
信息單一集合
比如說在iOS方面 有個app 
它跟蹤用戶位置 根據用戶位置 
app挑選該位置附近的一個飯店 
並想推薦給用戶
除了在iOS方面分享飯店外 
也想在Apple Watch app上
顯示這個飯店
所以你可以將建議打包到
應用上下文中 
它將傳輸信息 
然後下次用戶在Apple Watch啓用
這個app時 內容就會出現 
推薦也會出現
可能想使用應用上下文的其他示例 
假設在iOS方面 你有一個社交app 
它讀取了一堆的帖子 並確定了
10個最有趣的帖子 
在Apple Watch設備上展示
用戶可看Apple Watch 
並立即可以看到有趣的信息了
你也可以將這排名前10的帖子
打包到應用上下文中他們將傳輸過去 
現在 應用上下文是
後臺傳輸最簡單的方法 
但如果你需要一些稍微複雜的東西 
或你需要進行排隊等候 而不是信息的一個單一集合
我們爲你提供兩種方法
第一種是用戶信息傳輸
這允許你傳輸你想打包的 
用戶信息字典的內存內容
舉個例子 假設你在Apple Watch上
有一個遊戲
用戶不斷升級繼續遊戲 
當用戶升級後繼續遊戲時 
你想將進度後臺同步到iOS app
iOS app將展示一些細微圖形 
說明用戶在每個等級是如何操作的
除了用戶信息傳輸 
我們還提供文件傳輸
非常類似
它允許你讓內容進行排隊等候 
在這個案例中 內容是一個文件
在這個展示中 接下來我們要講到的
關於文件傳輸的示例是 假設你有一個iOS app 
它可讓你對圖片進行編輯 
在編輯完圖片後 
用戶可挑選他們喜歡的
這些喜歡的圖片就是
想在Apple Watch顯示的
你可以在喜歡的圖片之間
使用文件傳輸進行傳輸
圖片可通過Apple Watch查看
用戶可以向他們的朋友進行展示之類的
讓我們一個一個來說
我們從應用上下文開始
爲了示範說明
我們使用社交網絡app
剛纔我提到 這個在iOS上的app
從社交網絡網站讀取所有的帖子
然後選出最有趣的 
發送到Watch app
關於應用上下文 首先要說的是這兩個屬性
第一個屬性Application Context
它是這樣一種屬性 先在發送方 
然後在接收方存儲最新內容 
Received Application
Context將在接收方存儲
最新收到的內容
假設這個iOS app已經讀取了一堆的帖子 
它也已經爲Watch打包好最有趣的那些
將調用UpdateApplication Context
這個方法讀取一個詞典 
代表你想要發送的最新最有趣的狀態
我們獲得這個內容 Update
Application Context被調用後 
將它疊加到Application Context屬性
這樣內容就在那裏了 
系統將決定傳輸內容的最佳時間 
或許是當用戶啓動他們的Watch的時候
現在 與此同時  
這個iOS app可以讀取更多內容
並決定它想發送到Watch 
最新的有趣信息
在這個示例中 它將再一次調用Update
Application Context
然後 我們將把那些內容
疊加到Application Context屬性
它將把舊的相關狀態清出 
並放入新的相關狀態 因爲我們真正在意的是
那些最有趣 最新的數據集合
這個新內容就在那裏了 再一次
等待系統挑選一個合適的時間 
將內容傳輸過去
一旦系統挑出合適的時間 
內容就會被傳輸過去
它將傳輸到到Apple Watch方
它將等待用戶啓動app 
即Apple Watch app
當app啓動後我們將把內容轉傳輸到
你的WatchKit擴展 
這裏是在Apple Watch上所有代碼執行的地方
所以以上是應用上下文的流程
我們來看一些代碼
你想做的第一件事是打包
你的上下文詞典 代表你想要發送的
最新狀態的詞典
調用Update Application
Context 你將使用詞典
關於代碼示例需要提的最後一件事情是Update
Application Context調用被打包到
Do Catch塊中這個調用通過調試是事先引導的
這是Swift的新錯誤處理方式 Update
ApplicationContext會返回一個錯誤
若錯誤被返回Catch塊將被激發 
我們強烈建議你
恰當的處理錯誤
所以這是應用上下文的發送方
我們來看看接收方
在接收方看來 
接收方將得到指派回調
Did Receive Application Context
它將向發送者
發送打包的字典
然後此時 接收者可以獲得內容 
並更新它的app狀態
關於API中這個指派回調
和所有指派回調我們需要知道的一件事是 
它們按照非主要串行隊列被返回
假若由於你因爲要更新某些UI 
而需要在主要隊列中做些事情 
需要在此內容或其他事情的基礎上 
發送到主要隊列 從而更新你的UI
以上是應用上下文
它是app爲另一方所提供的的 
最有趣的相關內容
它的行爲優先權確實更高 
這是因爲你重視接收方在意的內容
並處理最新內容而任何非最新的內容
都是無關緊要的
應用上下文有一個詞典
這個詞典有屬性清單類型
屬性清單類型是基本對象類型 比如數字 
字符串 基本集合型 字典 陣列
如果你想要更新屬性清單類型 
Apple有很棒的在線文件
所以 對於應用上下文 
我們有一些特別推薦的使用示例
對於Apple Watch app來說應用上下文真的很不錯 
因爲不少Apple Watch app展示
iOS所有信息的一個子集
如果app是這樣工作的 我們建議你
將那信息的子集放到應用上下文中 
讓它可發送到Apple Watch
除了這些app 
應用上下文在Glance上也很好用
Glance獲得app提供的
單個最有趣的數據段
我們建議你將該數據段
放到iOS方的應用上下文中 
這樣它就可以被傳輸到Watch方
當用戶掃過手錶表面顯示Glance時 
就可以看到數據了
結束應用上下文部分 現在將繼續談談
用戶信息傳輸
我們將用到的一個示例是 
Apple Watch上有個遊戲
用戶不斷升級從而進行遊戲 
當用戶升級後 你將把進度
後臺同步到iOS方 
iOS app展示一些細微圖形 
是關於用戶在該等級的信息用戶信息傳輸要講到的
第一件事是未解決的用戶信息傳輸隊列
這控制了所有
等待傳輸的內容
當用戶升兩級後 
這時候的當前狀態
進度位於
未解決的用戶傳輸隊列中
目前 用戶的等級是3級
一旦他們再次升級你將打包那些內容 
調用TransferUser Info 
然後傳遞一個描述進度的詞典
獲取到該詞典後系統將對其進行打包 
並將它放到未解決用戶輸入傳輸隊列中
現在這個內容將在這裏等待然後系統會根據電源情況
或在用戶開始使用iPhone的時候 
決定傳輸內容的最佳時機
內容將被傳輸和先前的API一樣
我們需要等待直到iOS上app啓動
當它啓動後 我們將傳輸內容 
現在iOS app可以更新這些圖形
以顯示用戶在Apple Watch遊戲中的進度
所以這是用戶信息傳輸流程
我們來看一些代碼
首先要做打包所有用戶信息詞典 
這代表的是你想要發送的
目前狀態的內容全部
然後你調用帶有那個詞典的
傳輸用戶信息
傳輸用戶信息返回一個用戶信息傳輸對象
對象包含你正在發送的字典 
倘若傳輸仍然在未解決隊列 
你可以選擇取消這個傳輸
除了返回這個傳輸對象 
我們也提供了一個方法用來獲取所有
仍在隊列中的未解決用戶信息傳輸
這方法返回一個數組 你可以迭代這個數組 
查看所有內容 
若你需要也可取消
所以這是用戶信息傳輸的發送方
我們來看下接收方
在接收方看來你將調用 
Did Receive UserInfo Transfer
和應用上下文和其他所有指派回調一樣 
這是在一個非主要串聯隊列中被返回的
一旦你獲得回調 就可以獲得
內容和詞典內容 然後可以更新app狀態
那是用戶信息傳輸
它有用戶輸入詞典
這些詞典和應用上下文詞典一樣 
裏面有屬性清單類型
這對於內存內容 比如遊戲進度而言 這種方法很好
我們允許你訪問
隊列中未解決的用戶信息傳輸
接下來 我們談談文件傳輸
文件傳輸中要用到的示例是
這個圖像編輯app
用戶可在iOS編輯圖片 
然後挑選他們喜歡的圖片 
這些喜歡的圖片就是我們想要
傳輸到Apple Watch上的
所以首先要說的是
未解決的文件傳輸隊列
這裏是所有文件傳輸
等待發送的地方
然後在接收方 文件在等待被轉交到
接收方app時 將被放入
Documents/Inbox文件夾
這時候的狀態是用戶有兩張喜歡的圖片 
兩個圖像正在隊列裏等待 
進程進行到第三個
一旦完成進程並且將它挑選爲
喜歡的圖片後 你將調用Transfer File
你將傳輸一個文件URL 它指向
你想要傳輸的文件 我們提供一個方法 
以詞典的方式傳輸附加的元數據
你可能想要增加一些元數據的一個情況是 
通過在每個元數據詞典中放一個標識符 
將一些文件集合在一起
接收方可以識別那個標識符 
把正在接受的文件聚集在一起
所以這是用戶喜歡的圖片
我們稱之爲文件傳輸
現在我們將獲得打包好的內容 
我們將把它放入未解決的文件傳輸隊列
它將在這裏等待 直到系統確定
傳輸內容的最佳時間
當系統確定傳輸內容的最佳時間後 
它將開始傳輸內容 
等待接收方啓動並接收內容
需要注意文件的一件事是 
文件可能會稍微大一些
文件越大 
傳輸的時間就越長
當傳輸的時候 你可能需要注意
電源和性能的情況
請注意如果準備傳輸的是大文件 
相比使用其他API 這種方法
可能花費更長的時間
現在接收者將啓動設備 
然後我們將傳輸這些圖像
現在Apple Watch app可以顯示這些圖像了
所以這是文件傳輸流程
我們來看一下代碼
首先你想做的是爲你想要傳輸的文件
獲取一個URL
然後打包你的元數據 最後
調用Transfer File 傳輸URL 
以及元數據詞典
之後返回一個文件傳輸對象 
文件傳輸對象包含URL 
元數據詞典 同樣你也可以
取消任何未解決的文件傳輸
和用戶信息傳輸一樣 我們允許你
撤銷所有未解決文件傳輸的數組
你可以迭代這個數組 檢查內容 
如若需要 也可以取消
所以這就是文件傳輸的發送方
現在我們來看看接收方
在接收方看來 接收方會收到
這個指派回調Did Receive File
關於這個指派回調 需要注意的是
它與前面兩個略有不同
首先獲得WCSession文件對象
這個對象只包含文件URL和元數據
關於這個回調的第二件事是
文件現在位於app container的
Documents/Inbox文件夾下
說到控制這個文件 你需要將文件移出
Documents/Inbox並放到另一個
永久位置
移出文件的主要原因是
在指派返回後
Documents/Inbox將被清空
意思是文件將和其他內容一起被刪除
所以重要的是在文件傳輸之前
將文件放到其他的位置 
需要記住一件事 如果你正在指派到
另一個隊列 因爲這是在從
非重要串行隊列返回的 
如果該指派不同步的話 
你需要在指派之前移動文件
所以這是文件傳輸
它和用戶信息傳輸非常相似但是它允許你
傳輸文件或文件列隊
我們允許你
訪問隊列中未解決的文件
我們也允許你傳輸附加元數據
我們建議你使用較小的元數據體積 
另外 這個元數據詞典
和其他我們說過的詞典一樣 
有屬性清單類型
所以以上是三種後臺傳輸模式
若接收放不是立即需要這些內容 
請用這些模式
但如果你需要實時來回傳輸信息 
你可以使用交互信息傳輸
交互信息傳輸指的是實時通訊 
兩個app當前都處於開啓狀態
而且正在來回發送信息
就像我先前提到的 這裏有你可能需要這麼做的一些示例
假設我們有一個遊戲遊戲中兩個UI都處於啓動狀態 
而你想要用戶與兩個UI同時進行交互
或者你正在使用Apple Watch 你需要
觸發iOS app 
比如查詢用戶的位置
如果要使用交互信息傳輸 
需要滿足特定條件
所以我們來說說這些條件
這些條件與我們引進的概念有關 
這個概念叫做可達性
可達性意思是
其他app也可以訪問內容
這要求其他app是可以訪問和啓動的
從而可以使用交互信息傳輸
你查看另一方是否可達的方法是 
在默認會話中我們有可達性這個屬性 這樣你可以進行查看 
現在 可達性的條件與之前的有些不同 
取決於你所處的平臺 不論你的代碼
是否在iOS app上執行
或是在WatchKit擴展上執行
我們一個一個來看
我們從iPhone開始
滿足可達性爲True的第一個條件是
設備需被連接
我們可以通過Bluetooth或Wi-Fi連接 
但是如果用戶將Watch放在家裏 
拿了iPhone去上班這種情況下設備就無法被連接 
交互信息傳輸就無法進行
iOS上可達性爲True 
需要滿足的第二個條件是
Watch app必須處於前臺操作狀態
意思是爲了在iOS上進行交換信息傳輸 
用戶必須與Watch app交互
一旦滿足以上兩個條件 
你的iOS app上可達性屬性也將爲True
所以這是iPhone方面
來說說Apple Watch方面
在你的WatchKit擴展設備上
可達性爲True的第一個條件是
必須連接設備
意思是說倘若用戶去跑步 沒帶iPhone
只帶了Watch
可達性就不會爲True設備將無法被連接
第二個條件是
WatchKit外設必須處於前臺運行狀態
提到WatchKit外設處於前臺運行狀態
是因爲在不少示例中
WatchKit外設可以在後臺運行
主要與complication有關
我們等下會談到這個
所以現在 當用戶使用你的app時
你的WatchKit外設
也將被啓動並被置於前臺運行狀態
這也就是說你可以使用交互信息傳輸
並且可達性屬性爲True
關於這個圖表 還需要注意的是
我們並沒有說iOS app當前正在運行
iOS app必須處於運行狀態  以對進來的信息作出反應
併發出自己的信息
所以當iOS app在WatchKit外設之外運行時
我們如何進入一個狀態呢
僅針對這個詞典將信息從Watch發送到iPhone
或者允許iOS app
在接收信息的基礎上在後臺啓動
我們拿這個做例子
你有一個運行追蹤器app
它需要發送信息到iPhone
告訴CoreLocation開始追蹤用戶的信息
所以這個app將打包一個信息
告訴iOS app開始運行CoreLocation
它將發出啓動信息
當系統受到這個信息時
我們將在後臺啓動iOS app
並傳輸那個信息
現在 兩個app都在運行  它們可以進行互動了
這個示例中的app
可以開始追蹤用戶位置
所以那是交互信息傳輸流
當你可以使用它時
它如何和可達性有關係
現在我們來具體講講
如何在你的代碼中使用它
我提供兩種不同類型的信息
第一種發出一個詞典
你使用詞典調用Send Message
這個調用攜帶詞典
加上一個回覆處理器和一個錯誤處理器
這個詞典和我們先前說過的詞典一樣 
裏面有屬性清單類型
除了詞典外
我們還引入了發送數據的方法
可調用Send Message Data發送數據
這個攜帶數據 相同的回覆處理器
和錯誤處理器
關於發送數據 
如果你有存儲自己信息的自定義數據
或你自己的序列化格式我們建議你使用這個
若你使用自己的序列化格式
我們強烈建議你使用小而快的格式
這樣用戶體驗更快
因爲內容可以更快進行傳輸
關於這些調用 我想要指出一點 就是回覆
你或許注意到了先前兩個調用中有回覆處理器
這個處理器是可選的
然而 在多數情況下 我們建議你使用它
原因是
這可讓接收者確認進來的信息
接收者可以確認它接收到信息
信息包含正確的內容
它也可以處理那些內容
這樣一來 發送方就知道它不需要再發送任何東西了
它不需要在發送新信息了
因爲它發的是錯誤的信息
回覆需要談到的另一部分是
接收方這邊的情況
如果發送者說 我想要回復 所以我將提供一個回覆處理器
與之相反的 如果發送者說
我不想回復 不提供一個回覆處理器 這時會發生什麼呢
這種情況下
接收方會收到單獨指派回調
這取決於我們是否應該提供回覆
我們來說說這些指派回調
第一種情況 發送者說
我需要回復 我爲系統提供一個回覆處理器
意思是接收方將收到這個指派回調
Did Receive Message它有一個回覆塊
你可以在接收者接收並處理信息之後調用回覆塊
接收者就可以決定
是否發回一些內容
或者如果信息是錯誤的  就發回一個錯誤
現在 從另一方面來說
倘若發送者並未提供一個回覆處理器
接收者將獲得
指派回調Did Receive Message
它沒有回覆塊
接收方可以處理進來的內容
然後就結束了
關於這兩個指派回調
需要注意的最後一件事是他們通過一個詞典
意思是說發送者使用發送信息
從發送方這邊發送出一個詞典
倘若 發送者使用發送信息數據發送數據
在接收方會收到一個類似的回調通過數據
現在 我們簡單瞭解了交互信息傳輸
將所有的這些放在一起 並進行編碼
你首先要做的是
檢查可達性
確保另一邊是確實可達的
然後 倘若可達性爲True那你就可以打包你的信息了
一旦你有了信息
你就可以使用詞典調用Send Message
然後期待收到一個回覆
所以我們將提供回覆處理器
我們想要處理我們的錯誤
所以我們將啓動錯誤處理器
使用WatchConnectivity
傳輸內容的不同方法
來總結一下所講的
關於WatchConnectivity
首先要做的是
設置會話
爲做到這個 你設置指派  調用Activate
你需在app的使用週期裏今早執行
這樣app就可以開始接收內容
然後檢查屬性
在檢查這些屬性時候 你可以查看會話狀態
一旦一切都好了
而且你知道Watch已經配對
同時Apple Watch app也安裝了
你就可以開始通訊了
第一種溝通是後臺傳輸
我們提供三種類型
第一種是應用上下文
這是信息的單一子集
這個子集是爲另一方app準備的
或者 倘若你需要列隊內容
你可以使用用戶信息傳輸或文件傳輸
除了後臺傳輸
在實時溝通方面
我們還可以使用交互信息傳輸
就是WatchConnectivity
它允許你的app進行設備對設備的通訊
我們非常期待
你們會如何使用這個API進行通訊
如何提供更棒的用戶體驗
接下來...將簡要說說NSURLSession
什麼是NSURLSession
它是一個現有的基礎類
它允許你爲服務器提出HTTP請求
從而讀取內容
它在watchOS 2上適用倘若在你的服務器上
有內容需要讀取 我強烈建議你使用它
它利用了Tetherless Wi-Fi特徵
在沒帶iPhone的時候Tetherless Wi-Fi
允許Apple Watch連接到已知的Wi-Fi網絡
若Apple Watch已經連接到已知Wi-Fi網絡
你可使用NSURLSession通過Wi-Fi網絡
連接到你的服務器並獲取信息
所以你會如何使用NSURLSession呢？
當你的服務器有新內容時你都可以使用它
這個和你通過iOS app進行的操作
非常的相似
我們建議根據Apple Watch的需求
定製發送到Apple Watch的內容
若你的服務器上有圖片
建議按照Apple Watch屏幕尺寸按比例決定圖片尺寸
若是一個新app
你只想在Apple Watch上顯示部分內容或許只是文本
我們建議你只截取你所需的部分
以上是關於NSURLSession的簡要介紹
在WWDC會議上 有關於這個API的部分
同樣也有在線資源部分
我們建議你看看這些
關於NSURLSession
最後要講的是使用WatchConnectivity
NSURLSession
再一次 我們有新app的示例
這個新app從它的服務器上讀取一些內容
而且它知道
Apple Watch app可能將讀取這些相同內容
下次用戶啓動Apple Watch app時
爲了不讓Apple Watchapp重新獲取內容
我將利用應用上下文
將內容從iOS傳輸到Watch
內容會不斷被傳輸進來
再啓動Apple Watch app會被傳輸到它上
Apple Watch app可以
顯示在iOS上看到的相同內容
而且它提供更多的細微體驗
用戶下次啓動Apple Watch app時
可能是數小時後
這也就說
服務器有更新的內容要讀取
所以 我們建議
除了在應用上下文獲取已經發送的內容外
使用帶NSURLSession的HTTP請求
從你的服務器上讀取絕對最新的內容
這樣在用戶等待新內容時
他們將看到在iOS上看到的相同內容
這樣將有更好的體驗
所以這是NSURLSession和
WatchConnectivity
現在 我們想要採用這兩種API我們想要爲你展示
如何使用它們獲取數據 放到complication中
關於這部分
有請克里斯上臺爲我們講解
謝謝你 亞歷克斯這些東西很酷 是吧
我想你們使用Watch Connectivity API
和NSURLSession API
做的東西 一定很棒
現在我們來討論complications
在深入講解之前
先確定大家看的是一個內容
這些是在Apple Watch上的
三個Watch表面 三個時鐘畫面
若你移除時鐘 
剩下的就是complications
每次用戶看時鐘畫面時
他們會看到少量信息
這將讓用戶可以快速獲得
最重要的信息
當你使用complication時
你將需要解決兩個主要任務
你需要知道如何更新時鐘畫面
第二件事是 你需要拿到用來更新時鐘畫面的內容
我們來討論一下 你如何簡單地更新時鐘畫面
其他會議上 有深入討論
在這個示例中
用一個天氣app有個月相complication
這個月相complication不需外部數據
它已經有它所需的全部信息
因爲它只需要數據和時間
所以它所關心的是如何更新時鐘畫面
爲做到這點它將使用新ClockKit API
watchOS 2引進的ClockKit框架
流程運作的方式是
我們將在後臺啓動WatchKit外設
當這發生時 我們將獲取到
一個CLK complications服務器例
你調用Shared Instance來實現
用Extend Timeline For Complication
進入正在更新的complication
接下來會發生的是
它們將調用ClockKit激發程序
然後開始問一堆的問題
它們詢問現有時間軸項目
這是即將顯示的內容之一
它們詢問先前的時間軸項目
未來的時間軸項目
最後它們詢問你的建議什麼時候這些數據纔算過時
這是給系統的建議
這樣我們才知道你什麼時候需要再次啓動
你可以進一步更新時間軸
以上是更新時鐘畫面的 簡要介紹
你可用ClockKit來做上述事情
你可以提供過去的
現在的 以及未來的內容
你的WatchKit外設將在後臺進行這些更新
而且你可以規定
所提供的的內容什麼時候過時
需要注意的一點是
WatchKit外設更新
complication動作是預設
所以你儘可能使之儘快完成
這樣就可以一整天保持啓動狀態
以更新你的complication
正如我提到的關於這個話題 有個很棒的演講
Creating Complications 
with ClockKit 如果你還沒看過 我們希望你去看一下
下一個你必須做的事是
如何將內容放到你的complication
有個特別的示例即初始激活
用戶首次進入時鐘畫面時
他可以進入對其進行編輯
會啓動你的complication
這裏指的是新app complication
此刻
那個complication的時間軸上
數據可能很少或甚至沒有數據
所以它對內容有大量的需求
馬上要做的是
立即在後臺啓動WatchKit外設
現在 你有很多方式可以獲得內容
所以 你可以初始化時間軸
你可以調用NSURLSession與服務器通訊
從而獲得內容
或可選擇使用WatchConnectivity
若你在這個特別情況下
使用WatchConnectivity
設備是連接的你會發現可達性爲True
這是亞歷克斯先前提到的
在特定情況下
這時候的這個屬性是True
這是其中之一
在這個示例中另外可調用Send Message
它將把信息傳輸到iPhone上
我們將在後臺啓動天氣app
此時 iOS上的天氣app
可以使用任何WatchConnectivity
API返回信息並填充到時間軸
總的來說
當你運行初始激活時
WatchKit外設將在後臺啓動
你可以使用NSURLSession或者
因爲這是非常特殊的情況
WatchConnectivityAPI啓動iOS app
因爲可達性爲True
我建議你用這個
儘可能多的填充ClockKit時間軸
因爲開始時 裏面沒有數據
接下來是如何保持最新狀態
你的時間軸現在已被填滿
而更新也即將開始
如何保持更新complication
有很多不同的方法
可以用來更新你的complication
你可以將內容傳輸到complication
也就是說 若你有個外部源
比如說web服務器 它知道新內容出現的具體時間
而且是不定期更新的
你將做的是
將內容從雲中拿出 放到iPhone
然後傳輸到Apple Watch
我們比較容易理解這點的一個示例是比如體育app
顯示比賽分數時就是complication
多數時間裏 
分數只在一天當中很短的一段時間內發生改變
所以可以很快進行更新
然後 接下來我們認爲更合理的方法是使用推送方法
另一個方法是我正在調用請求間隔讀取
這個更多的是用在你知道有定期更新的情況
這樣你可以保持更新你的complication
可用像NSURLSession
直接進入雲
有些衝浪app帶有潮汐complication
顯示潮汐模式
這樣你就可以知道什麼時候可以衝浪了
我們先來看一下這個例子
你想用NSURLSession和ClockKit
更新complication
從時鐘畫面的角落可看到
衝浪complication已經啓動
這個流程看起來是這樣的
在後臺啓動的WatchKit外設
你想創建一個NSURLSession請求
並將它發送到服務器以獲取內容
服務器將生成一個響應
並將傳輸回WatchKit外設
現在你想打開並更新ClockKit
你將要求他們擴展你的時間軸
它們將通過問問題開始
你將提供過去 現在的時間軸更新
最後 你將給出一個建議時間
什麼時候應該再次啓動
最後一件事
當你提供下次啓動時間時
系統會獲得你的工作已經做完的提示
你的WatchKit外設也將被隔離
現在 我們假設經過一段時間後
系統根據你的提示和系統條件
認爲現在是重啓complication的
最好時間
再一次 你將在後臺啓動
你將調用NSURLSession生成一個請求
你將把它發送到服務器
服務器將生成一個響應
你將使用ClockKit打開並更新你的complication
概括一下 我們建議你
如果可能的話就使NSURLSession後臺會話
這是因爲 在下次外設運作之後
NSURLSession請求才會完成
使用後臺會話 
可使它在下次運作時傳輸內容
提供的請求時間只是給系統的一個建議
並不能保證確實如此
我們將盡可能逼近準確時間而且使用條件
在這時候也不一定總是滿足
我們建議你讓運作時間儘可能的短
你調用ClockKit更新時鐘畫面
你想讓運行時間儘可能的短
而且讓下次更新請求的時間間隔儘可能的大
因爲這是預設的 你不想在一天結束之前就用完這些安排
另一個獲得內容的方法
比如在使用體育app的示例中
是推送這些內容
我們將在不同數個階段中查看內容
因爲這會用到兩個非常獨特的進程
首先 你用PushKit
將內容從雲推送到iPhone
第二部分是用WatchConnectivity
將內容從iPhone推送到Apple Watch
我們分別來看一下
所以第一部分是
用PushKit將內容傳輸到iPhone
你已更新PushKit框架
從而支持complication推送
使用方法是創建一個PKPushRegistry實例
接下來 你將自己設置成指派
這樣 你就可以接收回調了
最後 你將設置推送類型
並傳輸新PK推送類型complication
這是之前添加到iOS9中的
一旦完成 你將收到帶新Push記號的指派回調
之後上傳到你的服務器
也將讓服務器可以將推送發送到設備上
最後 當服務器發出推送時
將收到攜帶負載Did Receive
Incoming Push回調
這是你可以返回來 
使用WatchConnectivity
API 將內容發送到iPhone時
所以 第二部分 這時候
可以使用WatchConnectivity
將在iOS app上收到的內容
發送到Apple Watch app
首先要用到的是
亞歷克斯先前說到的傳輸用戶信息API
這種方式可讓你項目排隊等候
Watchcomplication可能需要的
爲過去和未來的時間軸
一旦所有的時間軸項目排完隊
在完成工作前需要做的最後一件事是
調用一個專門的API
WatchConnectivity的一部分
它調用了傳輸當前complication用戶信息
這是傳輸用戶信息的專門版本
不管在什麼時候
只允許存在一個當前complication用戶信息
若你調用兩次
只有最後一次被標記爲當前complication用戶信息
當你調用時
對於系統來說 意思是事情已經做完了
在接收方 所有的回調將生成這個指派回調
Did ReceiveUser Info
所以 總體而言
這流程看起來像什麼呢 好的
所以 當用戶第一次啓動一個體育app時
app在其使用週期的知哦啊其
將建立PK推送註冊表並設置期待類型
然後註冊該推送類型
即帶Apple推送服務器的設備
然後類型推送到Apple服務器上
隨後將反過來生成一個Push記號
然後你將在你的iOS app上收到指派回調
你需要收到該記號並上傳到你的服務器
這樣以後 你的服務器
就可以發送推送到這個設備了
這個時候 PushKit初始化設置就已經完成
不需要用到你的app了
假設這一切開始了 服務器決定
更新complication
它將發送一個推送到你的設備上
設備將收到推送
我們將在後臺啓動體育app傳輸推送
那是另一個指派調用
這時候 你需看看推送負載上的數據
確定如果要使用WatchConnectivity
需要發送些什麼
你將調用Transfer User Info
將過去和未來的時間軸項目加入列隊
然後我們可以訪問未解決用戶信息傳輸列隊
然後調用專門傳輸當前
complication用戶信息的重要隊列
這也是將在Watch表面顯示的隊列
它將進入未解決用戶信息傳輸隊列
但會跳過開頭
因爲它是最重要的隊列
而且被指定爲緊急優先
我們將立即把它傳輸到Apple Watch
然後在後臺啓動WatchKit外設
傳輸當前complication用戶信息
如滿足相關條件 部分內容也會同時傳輸
你將獲得其他時間軸項目
但是最重要的隊列一定會被傳輸
最後 可以使用ClockKit
更新你的complication
就是這樣你已使用PushKit更新了complication
我們已經添加新PK推送類型complication
你可以使用服務器上的信息
快速更新complication
使用這些推送類型
還有很多限制條件
complication在時鐘畫面必須是處於活躍狀態
否則將無法進行推送
且每天的推送數量也是有限的
所以 請節約使用
平均大概是每小時1到2個推動
但體育app可能在很短的時間內全部用光
你可使用傳輸用戶信息
對時間軸項目進行列隊
最後 你可以使用傳輸當前complication
用戶信息列隊當前
或現有的時間軸項目
可使用ClockKit更新時鐘畫面
請記住 很多這些事都是有預算限制的
在iOS和WatchKit上執行的
complication更新的任何操作 
都會消耗預算
我推薦 將你需要用來更新complication的
任何信息都包括在推送中
complication推送類型有4K有效負載
大於標準負載 所以你可以將需要的大部分
信息放入其中
若你收到其中一個推送
並打開iOS app提交NSURLSession請求
你將很快就消耗完預算
請確保所有你需要的內容都在推送中
這部分就到此結束
簡要地討論下我們今天所說的
我們說了框架WatchConnectivity
和API
我們很期待看到你們用這些API做出來的東西
簡要地討論了NSURLSession和使用方法
還有其他部分
深入地討論NSURLSession及如何使用NSURLSession
最後 我們討論瞭如何把數據放到complication
這是個更爲高級的話題
還有很多可以查看的重要資源
我們有一些很棒的樣本代碼
我們也有專員他們已經準備好回答你的問題了
關於其他的內容
建議你看Creating Complications
with ClockKit以及Networking with NSURLSession
因爲他們與我們今天討論的內容緊密相關
謝謝