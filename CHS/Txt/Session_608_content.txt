GameplayKit介绍
大家好 欢迎光临
我的名字叫布鲁诺·萨默是Apple公司游戏技术工程师
今天我非常高兴
能为您介绍GameplayKit
Apple公司第一个专用的游戏开发框架
我们有多种解决方案可以处理制作游戏的视觉部分
在像SpriteKit SceneKit和Metal的平台工具上
在游戏开发难题中游戏设置是另一个非常重要的部分
事实证明 游戏设置方面存在难题
像AI 寻路算法和自主运动这些工具
我们坚信不应当故步自封
应当鼓励开发人员设计出更优秀的游戏
我们希望你们能够更加专注为生活带来好点子
我们将挑起重担在后端实现
所以开始制作GameplayKit时我们的使命非常清晰
我们想要设计一个具有游戏设置且简单功能强大的API解决方案
现在这就像普通的设计模式和架构因此我们开始先讲讲游戏语言
另外还有一些标准的游戏算法适用于多种多样的游戏类型
并且对我们很重要的是这隔断图形和引擎的联系
因此虽然GameplayKit与很多我讲到的那些视觉框架分隔
它和其它框架运作得很好
它和SpriteKit SceneKit Metal及更多的软件也运作得很好
所以此时我们有GameplayKit和七个GameplayKit的重要特性
并且这些组件可以说说是非常好可用于构建你的游戏对象和游戏逻辑
状态机描述了我们游戏中的状态化和游戏对象的各种状态变化
主体是自主运动的实体由现实行为和目标控制
路径找寻解决了导航图形生成和我们如何移动实体的问题
在游戏世界的可通行区域中
我们也有一个极好的MinMax AI解决方案
它是非常好的解决方法让反对计算机控制者看到了希望
有许多游戏质量随机源和随机分布可以任意使用
最后我们有一个规则系统也是个很好的途径
对模拟谨慎和模糊逻辑很有用
今天还涉及到很多让我们继续看看接着讲实体和组件
我想要提几个继承的经典问题
从普通游戏对象中得到的
此时我们有一个塔防游戏带有简单的弹塔和弓箭手类
这有一些共享的功能
我们有射击 有移动还有被攻击的目标
让我们以射击为例
我们想让塔和弓箭手都能够射击
那么我们在哪放置射击功能呢
一种选择可能是在塔和弓箭手类之间简单地复制并粘帖它
但现在在我的分享功能代码中有两个点
并且如果我想要更新这个功能
现在我也需要更新那两个点
如果我只是更新一个那么会导致一些很奇怪的行为
所以在我所描述的这种继承模型中
我们的唯一正确的选择就是在树状图中把分享功能往更高的层级放
此时我们有个射击功能
可以将它置于游戏对象类或某些基于普通的类
现在这种方法的问题是
当我们在游戏中获得越来越多的共享功能
我们不得不将它移到越来越高的层次
并且我们的基础游戏对象变得根本不基础了
他们变得很大 难以理解并且很难维护 协作
让我们看下怎么样用实体和组件解决这个问题
你看我们仍然有三个对象弹 塔 弓箭手
但现在取而代之的是有了功能在继承意义上
成为移动者 成为射手成为被击中者
它们反而有这些对象我们称之为组件
里面包含游戏逻辑的个别元素
所以此时我们有移动组件可以解决移动问题
有射击组件可以解决射击问题
还有目标组件这表示可命中目标
所以我们获得这些很好的小黑盒具有特定功能松散结构的盒子
而不是与层次紧密结合的结构
所以我们现在看见的实体和组件是的很好方法
可用于组织我们的游戏逻辑
举个例说他们很容易维护
因为他们是极好的黑盒子具有压缩功能
他们倾向于更简单
我们也可以让实体和组件进行良好的协作
现在我可以让一个开发人员在一个组件上操作
另一个开发人员在另一个组件上操作
并且他们不一定需要知道这些组件间的具体细节
我可以随着复杂性的高低得到很好的缩放比例
我的意思是 在那个类和继承模型中我的层级越来越宽 越高
随着我的游戏变得越复杂
有了实体和组件它只是在宽度中变得更宽
而不再有其他变化
真的是个好工具
无论何时想在游戏中制作个新实体
我只要简单地看下可用的组件
选择合适的或执行新的组件
有了实体和组件我们可以轻易获取动态行为
让我们回想塔防例子
我想要实现施放魔咒使弓箭手固定不动这样他们不再移动
一种典型的方法可能是暂时删除它的移动组件
间接地告诉游戏剩下的部分
停止移动
并且在这里还有其他的优势即不需要知道魔咒的细节
那么让我们继续往下看一下类
此时我们有GKEntity
这是基于实体的类
这是个简单的组件集合
随着实体功能改变
它可以动态增加和删除组件
同时也让我通过独特类的类型访问现有的组件
当我在GKEntity上调用更新时自身拥有的组件将自动更新
所以回想之前的例子 弹 塔 弓箭手都随着GKEntities而更新
现在讲GKComponent类
现在当你要在游戏中添加功能时你可以把这编入子集
并且有多种方法可以实现
你的组件属性成为那些组件的状态信息
所以你可以想象射击组件此时很可能有一个伤害属性
描述了炮弹能造成多大的伤害
你也可以执行自定义选择器进行功能扩展
也可以告诉游戏的剩余部分如何与组件进行通讯
同样举个例子 移动组件此时可能有能移动到某位置的功能
你可以调用输入或调用游戏控制器代码
正如我之前所提到的组件是通过它实体更新实现自动更新
并且你可以随意地在updateWithDeltaTime中执行时间逻辑
因此你需要更好地控制命令或控制组件的更新
为此我们提供GKComponentSystem
这是不同实体的组件集合
但他们都是同类的类型
并且在当更新命令对游戏内部起到重要作用的情况下调用
在更新移动代码后我可能想要更新AI
因为我想让我的AI处理最新的位置信息
需要留意的是放置在组件系统中的组件不会随着实体更新而更新
而取决于在正确的时间调用组件系统更新
以便更新所有的实体
所以再一次回想我们的例子
我们可能有一个移动系统能够移动游戏中的组件
并且我可以用来同步多种实体间的移动
最后我有一个代码例子 看看如何使用GameplayKit的实体和组件
你看下此处的上方我将制作我的弓箭手实体
然后我将制作三个组件构成一个弓箭手移动组件
射击组件和目标组件
并且给我的弓箭手增加这些组件
然后我将制作谈到的移动系统进入移动组件的类
指示这个组件系统只处理移动组件
然后我将增加弓箭手的移动组件到移动系统
然后继续进行弓箭手和移动系统准备就绪可以使用了
所以接下来是实体和组件
因此让我们转移到状态机
此时我将讲解其它例子
让我们想象一些游戏游戏中玩家被鬼魂追捕
有时他获得力量加成然后追赶并击败鬼魂
这有一个状态机的例子说明如何控制鬼魂的
此时你看 我们有四个鬼魂状态
当鬼魂追逐玩家时可以逃跑
当玩家追逐鬼魂时可以被追赶
当鬼魂被抓住且被打败时可以被击败
并且在击败后和复活前有时候可以复位
现在重要的事情是请注意只有一部分状态转换是有效的
你可以看到 我在追赶和逃跑之间转换
根据我刚才描述的这是合理的
有时候是鬼在追赶玩家有时候是玩家在追赶鬼
当然只有在逃跑的时候会打败鬼
这是玩家可以真正打败鬼的唯一时刻当获得力量后就可以追赶鬼
然后复活再被打败这是同样的道理
在我们重生之后我们就开始追赶鬼
这是我们的初始状态
当鬼重生之后它们就变回追赶玩家
因此为什么说状态机对游戏开发是如此重要
对于很多游戏来说这是游戏设置元素的重要部分
许多常见的游戏设置元素都充满了状态
例如动画制作AI UI 等级
想要在游戏中赋予让人物类角色以生命
毫无疑问地开发者必须对状态机非常熟悉
我们通常有个IdleAnimation
和MoveAnimation及AttackAnimation
并在它们之间进行合理切换
因此由于这种模式在我们的代码中是很普遍的
我们会执行多次
与部分样板文件一样采用个开关语句或者树状结构
是否有一些常见的方法
用于删除样板文件添加一些可维护性
让我们可以在整个游戏中从使用状态和状态机得益呢
这就是我们在GameplayKit里做的
让我们来看看类
这里我们有GKStateMachine
这是你的总体目标限定状态机
我的意思是说任何给定的状态均只有一个状态
它拥有所有的状态
你可以调用状态机里的enterState进行状态转换
具体发生了什么呢如果转换是有效的 它会检查改变
它调用许多状态目标的回调函数
退出状态 进入状态等
并更新状态机里的现有状态
在那个鬼的例子中我们可能有个GhostStateMachine
它将依次有四个状态
这里我们有GKState抽象类
然后调用回调函数执行状态基础逻辑
当你键入状态的时候我们给你一个进入回调函数
当你离开状态时我们给你个退出回调函数
当状态机里是现有状态的时候我们给你一个更新回调函数
正如我之前所提它们会在何时的时间自动被状态机调用
你可以选择性地重写isValidNextState功能
从而控制状态图边缘就是那些我说的有效转换
现在通过默认值所有这些边缘都是有效的
但毫无疑问的是你想要调用状态的内部动态决定哪个转换是有效的
我们讨论的四个鬼状态追赶 被打败 逃跑 重生
全部会随着GKState被执行
因此我想要在这里通过一个例子结束这个问题
让我们执行刚刚讨论的GhostStateMachine
一开始我要说说我的四个状态
追赶 逃跑 被打败以及重生
然后我将使我的状态机经历这四种状态
这四种状态是状态机里有的状态
然后我将继续并在例子中进入追赶的初始状态
我们开始这个状态机它已为我们的游戏做好了准备
并且鬼将做我们希望它做的
这就是状态机
让我们转向主体 目标和行为
在我们开始之前先说一些概念
我们说的主体 目标和行为
都是真正的自主移动实体
由现实的行为和目标所控制
它们受制于许多客观约束如掩码 加速度和惯性
控制这些主体的行为反过来组成一定的目标并附上适当的权重
从而在游戏中完成一些有意义的自主运动
因此为什么主体在游戏发展中如此重要
我想许多游戏都是以现实情况为出发点
当我们的游戏实体呈直线运动
然后再转弯后撞上环境障碍物这样看起来就不是很真实
现实世界的运动有诸如惯性
质量和加速度这类的因素
这样它就可以准确地避开附近的障碍物和其它实体
当实体知道如何从点A到点B它们通常跟随一条路径
并且路径通常是笔直的而非曲折的
以上就是对主体系统的简单概述
我们有主体类由一个行为控制
也有一个指派让你可以回应 主体中的变化
这些行为反过来组成一定的权重目标从而实现有意义的功能
你可以设置许多目标如寻找 拦截 避免障碍物及跟随路径
让我们继续看看类
GKAgent是一个简单的自主质点
也是个GKComponent
和实体 组件系统配合得非常出色
当你在GKAgent上调用更新它将应用当前行为
具体的是查看组成行为的目标
然后计算权重及所有必须的加速变化从而达成目标
然后运用加速中的变化
改变主体速度和旋转位置
正如我说的 现在GKAgent受制于许多客观约束
例如质量 反弹半径最大速度和最大加速度
很重要的是请注意这些单元式无标度且只适用于游戏世界
因此你可以想象以公里为单位的游戏相对于英尺为单位的游戏
二者将有非常大的差异
因此要确保游戏世界选择合适的数值
这里我们有GKBehavior类
它是一个像字典一样的简单目标容器
它让你随着游戏动态修改行为
你可以添加新的行为添加新的目标
移动已有目标改变已有目标的重量
正如我之前提过的在主体设置了一个行为
主体将很好地执行
下次你更新主体时它将正确遵循该行为
举几个关于行为例子可能你想执行群集行为
以模仿现实世界中鸟类的群集
我们可以通过合适权重将一个凝聚目标 一个分离目标
和一个匹配目标结合在一起
或者我可能正在做一个赛车游戏我想要做一个竞赛行为控制赛车
这就像结合跟随路径那样简单
我想要我的赛车跟随赛道
避开其他主体目标
我想要我的赛车避免和其他赛车相撞
这代码样本看起来像室行为代码的样子
看上面 我将创建寻找行为
我想在我的环境里找一些敌方的主体
我将创建一个回避目标用来避开附近的障碍
然后我将创建一个targetSpeed目标我想要我的主体加速并达到目标速度
然后用一套合适的权重让我的行为通过这三个目标
你可以看到我把回避目标权重加到5
因为我真的不想让我的主体撞到附近的障碍
然后我将创建我的主体
初始化 设置行为
主体已经准备好了
下次我更新主体时它将完全按照我的要求来做
现在来讲讲主体指派
在你需要使用基础指派模仿
同步你的外观事物如图形 动画 物理时
GKAgentDelegate就很有用了
我们提供两个回调函数对其进行操作
在主体更新前调用agentWillUpdate
在设备更新后调用agentDidUpdate
在你的游戏中这或许就像是SpriteKit节点
或SceneKit节点 或渲染组件
我们来看看SpriteKit游戏中这个指派看起来像什么
你可以看到这里有个自定义图形节点MyAgentSpriteNode
我将继续操作并执行我刚说过的两个回调函数
在agentWillUpdate中我将在循环里设置主体的位置
它们的节点位置一样
我想让基础主体模仿和我的外观相匹配
然后我将做一些更新
然后在agentDidUpdate中做的事情刚好相反
我将在循环中设置节点位置
它的位置和循环中主体的位置一样外观将和基本主体模拟相匹配
我将简要的为你展示一下
主体运动的样子和你可以自行处理的一些目标
有个简单的SpriteKit情景我们用一个圆圈里的三角形来代表主体
他们按照三角形的指向调整方向
这里我有一个座位目标
中间的主体会试图寻找鼠标的位置
可以看到移动看起来很流畅自然
因为它是受真实物理约束比如质量 加速度和惯性
这里有个相反的事例 逃跑目标
主体试图逃离鼠标的位置
这是漫步行为的事例
我的主体正在环境里任意移动任意左转 右转
这是一个障碍回避目标事例
我的主体又在试图寻找鼠标的位置
但我在情景里增加了一些循环障碍物
主体的目标之一是回避障碍
所以在他试图寻找鼠标位置时同时也在避免和障碍物相撞
这是一个分离目标事例
我有三个主体正在试图寻找鼠标位置
但他们同时有一个分离目标
他们之间试图保持最小距离
这对游戏中编队飞行或各组保持在一起真的很有用
这里有个对齐目标事例
右边的主体试图与左边主体的标签相对齐
这对于在游戏中同步单位真的很有用
这里有一个群集目标事例
领导主体是在场景里漫步的红色
但是在一个群集行为里同样还有一组蓝色主体
它们结合了一个凝聚目标一个分离目标 和一个阵营目标
形成了一个集体同时试图追逐领导实体
分离目标 维护他们之间的最小距离
凝聚目标让它们以结合块的形式待在一起
而对齐目标想让它们达到一个均等状态
最后是一个跟随路径的事例
我的主体正试图跟随简单的多线路径
请注意它并不会突然转弯
他正处于我们说过的真实物理约束下比如质量和加速度
所以尽管基本路径是固定的但是主体会被迫以曲线的跟随目标
以上就是主体 目标 和行为
我们现在继续来说说搜索路径
我很确定在游戏开发中我们对此都很熟悉
在我的游戏世界里有一些实体想从A点移到B点
但路径中有一个障碍
我不想这些实体穿过障碍我不想她碰到障碍
我想让她像人类一样准确地找到路径 绕过障碍
我正在寻找的是这些东西
我想让她找到障碍周围最短的路线 越过障碍 继续前往目标
我们调用游戏设置搜索路径
开始之前 说一些概念
导航图上的路径搜索操作
导航图是一个节点集合体现的是游戏世界里可通行的区域
允许实体呆着以及移动的地方
这些节点依次连接在一起体现在可通行区域是如何移动的
这些连接可以是单向的也可以是双向的
在连接图中任何两个节点之间总是存在最佳路径
这是在路径搜索中我们通常会找到的路径
我们继续来看看类
我们有GKGraph这是抽象图基础类
它仅是图节点的容器图节点是游戏世界里可通行区域的描述
在游戏世界有变动时它有个功能可用来增加以及移除节点
它也可以让我将新节点连接到图上与我希望的现有的节点做恰当的连接
当然我们也可以让你在节点和一个图之间寻找路径
我们提供两个专门化
一个是GKGraph和网格配合使用一个是GKGraph和障碍配合使用
我们现在来看下这两个东西
GKGridGraph
这是GK图2D网格专用的
它所做的是自动创建所有节点用来代表格框
既定的初始位置网格 宽度网格以及高度网格
它将在网格节点间自动创建基本连接
同样在在对角线之间随意创建基本连接
它也有很简单的功能在你的游戏中
网格空间变得不可通行时可对其进行增加以及移除
接下来我们讲GKObstacleGraph
这是GK图游戏世界中 障碍周围路径搜索专用
障碍可以是任意的多边形
我们提供一些在游戏世界变化时不断地增加以及移除障碍的功能
它也可以让你不断地将新节点连接到图上
对于为一个单位寻找路径而在图中插入一个开始以及结束节点来说很有用
我们通过一个缓冲区半径实现
这是障碍周围的安全地带
这里我的实体是进不去的
它通常是由游戏来决定大小
与我想要做导航的实体边界框半径有关
我们来说说这些障碍图是如何被创建的
这里是一个简单的情景有两个方形障碍
左下角的一个实体想要到达右下角的桥上
我的实体受一些边界框半径约束
我们将它当做缓冲区半径人为增大障碍
高级选项下障碍图将在网格节点间创建合适的连接
它将不会创建违反障碍空间性的连接
从这里可以看到我们找到了最短的路径了
它将不会和障碍相撞
这是最后示例的代码
但这个示例中只有一个障碍
在顶端我将创建一个只有四个点的简单多边形障碍
我将创建障碍图进入障碍以及一些缓冲区半径
然后我将创建一个开始和结束节点
一个是现在我的英雄所在地另一个是她想去的地方
我不断地将这些节点连接到我的障碍图上
它将做的是将这些节点插到图中并再一次自动创建合理的连接
但它并不创建那些会违反障碍空间性的节点
最后我为开始和结束节点寻找一个路径
我取回一个简单的图节点NSArray
我可以用它来激活角色
GKGraphNode是图节点类的先进节点
毫无疑问你会想对其进行划分子类
在你执行高级或非空间操作或在需要精确控制路径搜索时
将非常好用
你可以设想一个拥有各种版图类型的战略游戏
或许你想要一个森林版图类型
可以向其他版图类型一样做双倍挪动
我需要考虑路径搜索
我不想它返回可见的最短路径
我只想它在森林周围进行导航
因为事实上在我的游戏世界里这是最短的路径
在你想手动创建自己的图时GKGraphNode同样也很有用
你通过手动管理节点间的连接手动创建自己的图
对于一些像抽象或非空间图的东西这真的是好东西
或许你想要你的游戏有个端口想要单位让这些端口为路径搜索负责
尽管这些端口在空间上并不相连
Grid/GraphNode和使用障碍节点的GraphNode2D
正如你所看到的都很合适
对于这个特性我真的很兴奋
我们和SpriteKit组配合做了一些工作
可让你从现有的SpriteKit Scenes中
很容易地创建这些障碍图
你可以为这些类似节点边界节点实体和节点材质的东西创建障碍图
这个意思是说只要极少的代码
你就可以获得一个现有的SpriteKit场景创建一个障碍图
并动地在其周围路径搜索
现在我们为你稍微展示一下
我们用SpriteKit来搜索路径
这里有一个我们讲过的塔防游戏
我们将它作为SpriteKit场景来执行
我在左边创建实体它们想移到右边的桥上
因为这是个塔防游戏
我将在右边放置一些塔而这占用了它们现在的路径
我们继续 放置一个
你将看到它们在它的周围正确地搜索路径
那是因为我们正在用刚讲过的SpriteKit集成
自动地从节点创建一个障碍
更基本的GKObstacleGraph
以及更新我们的路径
我们转向调试程序迅速的将塔移开
你可以看到从开始和结束节点间的简单路径
当我在这里插入一个障碍时
我们重新计算了基本的GKObstacleGraph
这就允许我们的实体在障碍周围找一条新路径
我们继续增加一些东西
因为有那个SpriteKit集成每次我们增加或移除障碍时
基本GKObstacleGraph总能进行更新
以上就是使用SpriteKit的路径搜索
现在有请我的同事萝丝·德克斯特
为我们讲讲MinMax AI
萝丝
谢谢你 布鲁诺
布鲁诺刚讲的很多特性可以用来创建AI
但它们更多的是在你的游戏中给于实体生命
许多游戏也需要同等的AI对手用人类玩家同样的规则来玩整个游戏
这对于有些游戏来说是很关键的如象棋 西洋棋 一字棋等等
所以我们想为你提供解决方案
我们选择实现经典AI解决方案MinMax
将它当做GameplayKit关键部分
MinMax会查看所有适合玩家的移动
然后它根据每个移动及每个移动能产生的所有排列建立一个决策图标
当你请求一个移动它就搜索决策图标最大化潜在收获
同时最小化潜在损失
在这个一字棋事例中
AI为X玩家选择了右边的一步因为是在最好的情况下 结果是胜利
在最差的情况下 结果是平局
其他两个布则会导致失败
MinMax AI给你控制对手的能力
当人类玩家陷入困局时它也可以为人类玩家提供建议
这对于游戏来说非常好甚至都不需要其他的AI请求
它尤其适合以转弯类的游戏
但也同样适合对于需要玩家操作的不连续移动的游戏
但你也可以通过改变对未来的预测程度调整AI的难度
事先预测10步
当然要比事先只预测2 3步要来的更有效
此外你可以随意指挥它任意挑选最不适宜的一步
给它一些类似人类的错误
我们来看看它如何整合到游戏之中
MinMax非常棒的地方是你不需要知道游戏的任何细节
你不需要告诉它你的规则它也不需要知道该如何执行
所有的这些都是抽象的
你所需做的只是提供游戏中的玩家清单
他们可能会走的步
每个玩家的分数用来显示他们目前位置的相对强弱
当你向AI请求一步它会考虑所有这些数据 创建决策图标
返回一个最佳策略供你使用
我们来看看类
有三个所需的关键协议以便与MinMax AI配合使用
第一个是GKGameModel
指的是对目前游戏状态进行抽象
比如你在创建一个象棋游戏执行该类的较佳的是板类
因为它追踪板上所有的位置以及目前在玩的所有块
正如我在前面的幻灯片提到的
所需做的是提供游戏中活跃的玩家清单
目前的玩家每个玩家的分数
然后是每个玩家可能会下的每一步
同样也需要一个应用这些步的方法
AI用这个方法创建出决策图标
在它已经被AI选中后你也可以用它来应用每一步
当采用该步后它将改变目前游戏状态
可能改变玩家目前的行动
每个玩家的分数
以及适合他们的下一步
接下来的协议是GKGameModelUpdate
这是游戏里的动作抽象
它应该有你为游戏模型应用每一步的全部数据
正如我们所说的MinMax用它创建决策图标
在它被选中后你可以用它来做出下一步行动
最后是GKGameModelPlayer
是游戏玩家抽象
AI用它来区分不同玩家的行动
现在来说说AI它属于GKMinMaxStrategist类
在GKGameModel上运作
在你创建MinMaxStrategist示例后
你将把它连接到gameModel属性中
当你从AI请求下一步时maxLookAheadDepth就是能进行预测
正如我们前面提到的较高的数字比较低的数字更有效
开始使用之前这是你所需要做的
当你调用bestMoveForPlayer时AI将创建它的决策图标
按照从优到劣的顺序列出所有适合的步然后返回最优的步
这可能会出现在这些情况中
你有不止一个有利的步需要由AI作出决定
以及这些情况中你可以直接指挥AI随机打破连接
若你想调用randomMoveForPlayer它就会出现
你有10个适合玩家的移动
但你只想从3个最佳移动中随机挑选出一个
它将按照你的要求操作从3个最佳中随机挑选出一个
而选出的这个可能是次优的
如果你想要让AI看起来更人性化 会犯错误
这或许就是最令人满意的结果了
bestMoveForPlayer和randomMoveForPlayer
都返回GKGameModelUpdate
你可以将GKGameModelUpdate应用到GKGameModel以创建一个移动
这是个简单的代码样本
我正在创建象棋游戏模型
不幸的是
审查你将如何执行游戏模型细节不在这个会话范围里
但我们有很棒的样本代码
你可以用来展示将如何做这些事
我们创建象棋模型
然后创建MinMax AI
通过在gameModel属性上设置游戏模型将它联系起来
我们为LookAheadDepth选择6
当你创建决策图标时你将提前看到6个转弯
这就是我们所需做的
我们调用当前活跃玩家的bestMoveForPlayer
它将利用所给信息为玩家找出最优移动
你可以在游戏中应用那个移动用它来创建移动
我们来看一个简单的演示
有一个只有两个玩家的简单游戏黑色和白色
它们在棋盘上尽可能的收集和它们同颜色的块
当它们在棋盘上放置块时
它们将反转两块之间的属于对手的块使之变成属于己方颜色
我们有两个AI控制的玩家
黑色玩家可提前预测5个移动
而白色玩家只能提前预测3个移动
在游戏过程中使得黑色玩家可以很容易的打败白色玩家
这里你可以看到有双方玩家的分数
这个很简单
我们来看一下玩家在棋盘上拥有的块减去对手在棋盘上的块
再通权重码进行调整就得到分数了
这里你可以看到黑色玩家很容易就打败了白色玩家
我们来详细看下分数
看这里
在中间的块他们的权重是1
棋盘边缘位置权重略高
在角落的权重就更高了
因为对于玩家来说这些位置更有利
我们通过改变这些位置如何影响分数来指挥AI选择这些地方
我来互换一下这些人的预测
白色将会预测4步取代先前的预测3步
尽管只是小变动这也会让AI更有效率
事实上游戏中白色AI略占上风
但是黑色AI将牺牲短期利益换取长期胜利
这样最后就可以战胜白色
以上就是MinMax AI
现在让我们来讨论随机源
起初这个话题可能看起来不必要
因为我们已经有了随机函数为什么我们不能仅仅使用它就好呢
好的 随机函数给我们随机序号
但是游戏有独特的随机序号需求
随机函数可能无法给我们想要的一切
首先每个系统中由随机函数生成的序号可能是不相同的
不能保证不同的计算机平台产生的结果是相同的
这对网络游戏来说会是一个大问题
因为我们不能依靠任何一方以相同顺序生成的数据集合
否则为了使两方是数据同步
我们不得不浪费关键带宽
因此我们需要平台独立性和确定性
无论我们什么调用随机函数都取自单一来源
如果我对AI代码中的随机函数有一串请求
然后我在我的物理代码中添加一项请求
物理代码中的这个请求就会影响在我的AI代码中生成的数字
这可能会导致意外行为
我们真正想做的事情是可以把这两个系统分开
这样两个系统分别生成的数字就不会互相影响
我们不仅想要控制生成的数字范围
而且还要控制这些数字在该范围内是如何分布的
这就是随机源的由来
我们为你提供一系列具有确定性的游戏优质随机源
因此当你有同样的种子时你就可以获取相同顺序号
无论你在什么平台上
它们是可序列化的因此它们可以为你保存游戏数据
这对阻止欺骗程序是非常实用的
人们用行业标准算法执行
众所周知这些行业标准算法具有可靠性和卓越的随机性
此外我们为你提供一套随机分布杠杆
这使你可以在给定的范围内控制序号的分布
我们有一个真随机它的每个值都有同等的发生可能
高斯通过平均值分布中它的值以钟形曲线分布
而非边缘值以及反聚类或恰当的随机分布
这样有助于消除运行的数据
最后我们有NSArray排列
对洗牌这类事情是超级实用的
让我们来看看类
GKRandomSource是随机源的基础类
采用NSSecureCoding和NSCopying以便被安全地序列化
同样的种子保证了确定性
无论你在哪个平台上
因此如果你想要同样的顺序号你可以依靠它生成
如果没有种子可以从安全的系统源获取一个
我们继续说说共享随机
它是系统隐含的共享随机源
它不具有确定性但是很多例子说明它值得拥有
例如你在洗牌的时候你希望每个结果都是唯一的
让我们看看我们为你提供的AI随机源运算法
我们有ARC4
它低消耗并具有卓越的随机性并且它即将成为你的Goldielocks随机源
我们有线性意味它比ARC4更低消耗
但它的随机性并不那么好你可能会更频繁地看见重复的顺序号
最后我们有马特赛特旋转演算法高质量但占用大量内存
可以发现没有一个适合密码系统
但Apple提供其它单独的API来满足这些需求
现在我们开始讨论随机分布
在基础类中GKRandomDistribution执行一个纯粹的随机分布
意味着每个在最低值和最高值之间的值都有同等的发生可能性
你可以通过操纵nextInt
nextUniform及rextBool来获取数值
我们也提供一套骰子默认构造函数用于创建6面 20面和自定义骰子
然后我们有GKGaussianDistribution
来执行钟形曲线高斯分布
这些值偏向于均值而距离均值较远的值是不太可能发生
这就是在样板分布里所发生的一切情况
我们已经生成了一个由1到5之间数字组成的15位顺序号
我们可以看到均值3发生的可能性远远大于其他任意数
事实上和其它任何数字一样它发生两次以上
边缘数1和5
每个只发生一次
可以发现在一个标准高斯分布中它是无限的
但它不被随机源需要
因此我们操纵每个均值三个标准差之外的每个值
接下来我们看看
在GKShuffledDistribution类中执行反聚类分布
这是随机分布有助于减少或消除运行的数字
但它随着时间是随机的
你运用uniformDistance来控制这些
在0.0所有数字都有同等的发生概率
这是无法从一个随机分布中真随机源中区分的
在1.0所有值都是不同的
在你开始看到任何重复值之前它会遍及范围内的每个值
这就是在我们的分布中的情况
再重复一下 我们生成了由1-5之间的数字组成的15为数值
在我们开始发现任何重复值之前我们会命中每一个数值
实际上每个数值都生成了三次
让我们来看一个简单的代码例子
我们可以很容易地创建一个6面骰子随机源
你仅需运用默认构建函数GKRandomDistribution然后摇动骰子
如同调用nextInt一样简单
类似的创建一个20面骰子也很容易
创建自定义骰子也同样简单
我们正创建一个256面骰子
如果你试着在现实世界中掷这样的骰子情况将完全不一样
前面的三个例子都运用真随机分布执行
但你可以使用我们提供给你的任何分布
我们正使用高斯分布
创建了一个20面骰子因此它的均值大约是11
因此当你转骰子的时候你最有可能得到一个约值
在这里我们创建一个20面骰子使用洗牌分布
在默认情况下统一的洗牌分布距离是1.0
因此当我们转动的时候
在我们看见任何重复值之前我们将击中范围内的每个值
我们第一次转的时候可能得到了5
然后我们知道下一次我们转动它的时候我们一定不会再转到5
直到我们转出范围内的其他所有值
最后我们有数组洗牌
我们运用早前在GKRandomSource提到过的共享随机源
它让我们获得系统隐含的随机源
它不具有确定性
但在这个情况下是有利的
我们希望每一个卡铲都是唯一的
你可以看到让随机源成为你游戏的一部分是很容易的
仅仅是几行代码就可以实现
这就是随机源
现在我想邀请桥什·伯格斯和我们谈谈规则系统
谢谢 罗斯
你们好 我是桥什
我一直和布鲁诺和诺斯并肩工作进行GameplayKit收尾工作
我在这里讲讲这些系统中的一个规则系统
在我开始降解规则系统之前我想要说说游戏总有的一些常见要素
游戏往往由三个元素组成
这像是名词之类的东西位置 速度 生命值
已经穿上身的装备
第二是类似动词的东西
这些玩家可执行的动作例如跑 跳
使用一件物品或者如果你在一辆车上 加速
最后是规则
规则是极其重要的因为要界定名词和动词是如何相互作用
规则给你的游戏添加了质感绝好的游戏有绝好的规则
让我们来看一个例子规则
在这里我们有一项规则
司机可以用来决定什么时候刹车什么时候加速
运用距离的输入属性
玩家要么将减速 要么将加速
在这个例子中我们可以看到
如果距离小于5 他们将刹车
当大于或等于的时候 他们将加速
这个逻辑很不错但这里有一个不易察觉的问题
在距离为5左右我们的动作非常不稳定
因为汽车将在刹车和加速之间不断徘徊
这将使我们的动作非常不稳定
因此想要更多自然的动作我们需要一些更加真实的东西
运用一个更加模糊的解决方法
我们输出的情况而不是立即执行动作
我们在这里输出了两种情况 近和远
两者都是基于距离的
重要的事情是
现在你既可以是远也可以是近
与其执行一个或另外一个
这让我们把两者融合在一起获得更加自然的动作
这对之前的例子尤为重要现在当距离在5左右
我们可以更加自然地加速
这就是规则系统的动机作用
事实是可以划分等级的
这允许我们用模糊的逻辑执行更加复杂的演算
模糊逻辑处理近似值
它也允许我们把我们做什么和我们如何做分开
而不是马上执行动作
我们只是说明关于世界的情况然后基于这些情况采取推迟操作
让我们来看看这些类的其中之一
这里我们有GKRule
GKRule包含一个布尔预测和一个动作
预测与事实和系统状态相匹配如果预测为真 将触发动作
动作则如断言事实那样简单也可以如复杂块一样复杂
重要的是现在可以运用
NSPredicate序列化方法进行序列化
重要的事情是记住规则系统提供近似值答案
回答类似前面的车有多远这样的问题
在第一个例子中
我们可以相当自信认为我们还很远
在其他两个例子中事情有点模糊
我们在做出答案后真实情况是介于两者之间的
让我们来看看管理这些规则的系统
这里我们有其它类GKRuleSystem
它是规则和事实的有序集合
如要陈述世界事实只需要进行调用即可
这将在序列中运行规则
这些规则将使用一个状态字典作为输入
然后基于此插入事实
事实将输入到事实序列
重要的是要了解陈述事实后
评价将返回到开端然后继续评价
这是因为当你明确一个事实的时候
它可能会影响其它规则的运行
这可以确保当评价结束的时候你可以有最简明和精确的游戏视图
如要重新开始
比如在一个更新循环末尾或计时器上
只需调用重置
这样你就可以重复评价
让我们看一个代码例子
在开始的时候我们初始化规则系统
然后我们获取状态并明确基于此的两个事实
稍后在游戏代码中
我们抓取这两种等级并求出两者之和
来获取关于我们可以加速多少的模糊近似值
然后填入游戏代码中
看看我们正在做的一个小例子
我们在高速公路上开车
汽车在十字路口使用一套规则而在高速公路上使用一套不同的规则
高速公路上使用的规则是基于与前方车辆的距离
决定它们要加速多少或减速多少
它们明确世界的两个事实
分别是距离和相对速度
车辆在十字路口使用另一套规则明确谁有通行权的事实
现在综合在一起的话
我们获得非常复杂的仿真世界
这就是规则系统的力量
所以在我运用规则系统作一些最佳实践之前
很重要的是请记住GKRuleSystem是孤立的
你必须使用状态字典作为游戏世界的快照
你同样必须要运用许多简单规则并明确许多关于游戏世界的事实
作为对抗大型复杂规则以及少数事实
同样重要的是请注意事实是一些近似值
如何使用它们取决于你
事实的等级是系统的置信度
这允许我们使用模糊逻辑来完成更复杂的推理
那样 我想把这交回给我的同事布鲁诺
谢谢 乔什
这就是GameplayKit
今天我们讲了GameplayKit里的七个主要系统
实体和组件是构建游戏逻辑的好方法
状态机处理游戏中的状态性及我们的目标经历的各种各样状态变化
主体即自主移动的实体由真实行为和目标控制
路径搜索 处理导航图的生成以及找到我们游戏世界中的路径
我们也讨论了MinMax AI解决方法
它让计算机控制的对手表现出生命力
同样可以提供给你许多随机源和分布
最后我们讨论了规则系统是用于描述谨慎和模糊逻辑的绝好方法
我们很期待发布GameplayKit
我们迫不及待地想看到你们会如何使用
一些很好的代码例子本周发布了
如果你想了解更多东西你一定要看看
Demobot是一个SpriteKit游戏涵盖了GameplayKit各种API
FourInARow是实操MinMax AI的绝佳示例
AgentsCatalog表现主体行为和目标的好例子
因此如果你想学习一定要看看
同样还有一些环节如果你想要了解更多相关技术
例如SpriteKit ReplayKitGame Center SceneKit
今天午饭之后有一个DemoBots的深入研究
就是我说到的那个例子
如果你想了解更多关于GameplayKit或SpriteKit的资料
就一定要来看看
我们有实验室欢迎来游戏控制器实验室
今天午饭之后同样有个关于GameplayKit实验
大家可以来会面成员 发问讨论任何关于代码的问题
如果你需要更多信息请登录伟大的开发者网站
有任何一般询问联系我们的游戏技术专员艾伦·沙菲尔
谢谢会议中间请休息片刻