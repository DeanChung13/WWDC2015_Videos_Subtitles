00:00:21.288 --> 00:00:28.295 
UIKitDynamics
和視覺效果的最新進展

00:00:31.365 --> 00:00:33.834 
歡迎參加WWDC
和"UIKitDynamics

00:00:34.601 --> 00:00:37.070 
和視覺效果的最新進展"
的最後一天的活動

00:00:37.304 --> 00:00:38.405 
我是麥克·特納

00:00:38.672 --> 00:00:40.440 
我將和我的同事大衛·杜漢
一起爲大家進行介紹

00:00:40.507 --> 00:00:42.643 
我們兩個都是Apple在這裏的
UIKit開發組成員

00:00:43.644 --> 00:00:45.179 
所以 在我們開始今天的介紹之前

00:00:45.646 --> 00:00:47.314 
我要向各位推薦幾場
非常好的講座

00:00:47.381 --> 00:00:48.882 
我只是簡要介紹一下

00:00:48.949 --> 00:00:50.651 
在過去幾年裏我們
進行過幾場非常好的

00:00:50.717 --> 00:00:53.287 
圍繞UIKitDynamics動態
和視覺效果的講座

00:00:53.620 --> 00:00:56.557 
所以我們今天就從
簡要概述

00:00:56.623 --> 00:00:58.358 
動態動畫模擬系統開始

00:00:58.425 --> 00:01:00.160 
我們會進行 基本示範 然後

00:01:00.327 --> 00:01:03.664 
我們直接切入今年
UIKit Dynamics的新進展

00:01:04.197 --> 00:01:08.068 
然後大衛會過來
與我們討論視覺效果

00:01:09.937 --> 00:01:12.206 
以及你怎樣在你的應用程序中
運用那些效果

00:01:12.706 --> 00:01:14.374 
最後 我們會稍稍涉及

00:01:14.441 --> 00:01:17.077 
一些應用UIKit
Dynamics的最佳操作範例

00:01:17.144 --> 00:01:18.779 
和你的應用程序裏的自動佈局

00:01:20.681 --> 00:01:22.683 
所以我們談論UIKit Dynamics時

00:01:22.749 --> 00:01:25.085 
我們說的是一個二維的
基於物理啓發的

00:01:25.152 --> 00:01:26.553 
動畫交互系統

00:01:27.387 --> 00:01:30.023 
它有一個非常易於組合的
說明式的API

00:01:30.357 --> 00:01:32.993 
可以顯示你的應用程序
裏的高水平動畫

00:01:33.727 --> 00:01:37.798 
我們所說的並非核心動畫或用戶界面視
圖UIView動畫的

00:01:38.031 --> 00:01:39.199 
替代程序 而是另一個

00:01:39.266 --> 00:01:41.702 
能夠幫助你在你的應用程序
創建定製的效果的工具

00:01:42.436 --> 00:01:43.537 
讓我們來看一個示例

00:01:44.238 --> 00:01:46.807 
這裏有一個基礎的滑動視圖

00:01:47.774 --> 00:01:50.477 
用戶可以平移視圖
但是如果你放開它

00:01:50.544 --> 00:01:53.413 
它就像受到重力
影響一樣落下來

00:01:53.780 --> 00:01:55.883 
現在 它並不會直接
從電話底部消失

00:01:56.083 --> 00:01:57.851 
相反 它先在底部邊緣停止

00:01:57.985 --> 00:01:59.686 
再稍稍向上反彈 然後停在那裏

00:02:00.287 --> 00:02:02.823 
現在 讓我們看一看如何
創建這個基本示例

00:02:03.457 --> 00:02:06.059 
首先你需要先選定一個很好
的參考視圖

00:02:06.326 --> 00:02:08.228 
在這裏 我們選擇
視圖控制器的視圖

00:02:08.294 --> 00:02:09.596 
其中包含我們的滑動視圖

00:02:11.131 --> 00:02:12.766 
選擇引用視圖後 我們要

00:02:12.833 --> 00:02:15.602 
創建一個動態動畫並
將它與引用視圖關聯

00:02:16.136 --> 00:02:18.639 
這段動態動畫
爲我們的動畫

00:02:18.705 --> 00:02:21.775 
保持整體背景 它的
主要作用是跟蹤

00:02:21.842 --> 00:02:23.544 
行爲和動態項目

00:02:24.711 --> 00:02:27.281 
對於滑動的例子
我們有一個滑動行爲

00:02:27.714 --> 00:02:30.050 
UI動態行爲的
偉大之處之一

00:02:30.450 --> 00:02:32.286 
是更高層次的行爲
可以由相對原始

00:02:32.352 --> 00:02:33.220 
的行爲組成

00:02:34.087 --> 00:02:36.456 
所以我們的滑動
行爲只不過是

00:02:36.523 --> 00:02:38.792 
重力 碰撞 附件
的組合作品

00:02:39.760 --> 00:02:41.195 
稍後 我們將向大家展示

00:02:41.261 --> 00:02:44.531 
我們如何使用UIAttachmen
Behavior和增加的新組件

00:02:44.598 --> 00:02:45.899 
讓滑動
比過去更簡單

00:02:47.534 --> 00:02:48.936 
所以一旦我們
有滑動的行爲

00:02:49.036 --> 00:02:50.504 
我們就需要一個動態的項目

00:02:50.971 --> 00:02:53.574 
這裏我們選擇了
滑動視圖

00:02:53.941 --> 00:02:56.276 
它只是一個自動符合動態項
協議的UIView

00:02:56.410 --> 00:02:57.511 
所以這是一個很好的選擇

00:02:57.845 --> 00:02:59.913 
然後我們選擇
動態項 將它與

00:02:59.980 --> 00:03:01.281 
滑動行爲關聯 將滑動行爲

00:03:01.348 --> 00:03:02.816 
和animator組件關聯

00:03:03.450 --> 00:03:05.886 
現在animator組件
將自動確定

00:03:05.953 --> 00:03:08.555 
系統靜止或運動的時間
這是要創建這個

00:03:08.622 --> 00:03:10.057 
偉大的效果你所需要的全部條件

00:03:12.025 --> 00:03:13.527 
現在我們已經看過了一個基本示範

00:03:14.494 --> 00:03:16.730 
這就是今年UIKit
dynamics的新變化

00:03:17.431 --> 00:03:18.265 
我們支持

00:03:18.332 --> 00:03:21.034 
UIDynamicItem的
非矩形碰撞結合

00:03:21.802 --> 00:03:24.238 
我們有一個全新的
UIDynamicItemGroup

00:03:24.304 --> 00:03:26.907 
允許多個項目
就像引擎中的一個部件

00:03:28.141 --> 00:03:29.543 
一樣運轉 我們
還有一個全新的

00:03:29.776 --> 00:03:31.178 
模擬向量力場的行爲

00:03:32.746 --> 00:03:35.983 
我們對UIDynamicItemBehavior
以及UISnapBehavior進行了

00:03:36.049 --> 00:03:37.484 
一些基礎性的優化處理

00:03:38.018 --> 00:03:40.687 
我們會看到UIAttachmentBehavior
新增了一些很好的功能

00:03:41.355 --> 00:03:43.991 
我們最後還將介紹
一些新的方法 你們可以

00:03:44.057 --> 00:03:46.093 
用這些方法調試動畫

00:03:49.263 --> 00:03:52.499 
所以 在iOS 9裏 我們
增加了UIDynamicItem

00:03:52.566 --> 00:03:55.569 
碰撞邊界類型
可以提供三個新方法

00:03:55.903 --> 00:03:58.405 
爲動態項指定碰撞邊界

00:03:59.506 --> 00:04:02.309 
在默認情況下你的碰撞
邊界是矩形

00:04:02.509 --> 00:04:04.811 
與邊界數據訪問器
返回的動態項目協議

00:04:05.078 --> 00:04:06.246 
匹配

00:04:07.381 --> 00:04:10.417 
現在你可以指定一個
橢圓類型 它來自

00:04:10.484 --> 00:04:12.920 
協議中的邊界
寬度和高度

00:04:13.820 --> 00:04:17.024 
最後 你可以指定
一個UI BezierPath用於

00:04:17.089 --> 00:04:18.524 
動態項的碰撞邊界

00:04:20.761 --> 00:04:23.597 
現在 爲了實現這一點 我們採用了
現有的動態項目協議

00:04:23.664 --> 00:04:27.067 
並已經延長兩個可選屬性

00:04:27.401 --> 00:04:28.435 
如果你不
應用這兩個

00:04:28.502 --> 00:04:30.871 
可選屬性中的任何一個
你將像過去一樣

00:04:30.938 --> 00:04:32.372 
遭遇到矩形碰撞邊界

00:04:33.273 --> 00:04:35.409 
如果你執行第一個
碰撞邊界類型

00:04:35.542 --> 00:04:37.411 
並返回橢圓
就將得到一個

00:04:37.511 --> 00:04:39.279 
基於邊界的寬度
和高度的橢圓

00:04:39.980 --> 00:04:42.082 
如果你執行
第一碰撞邊界類型並返回一個路徑

00:04:42.149 --> 00:04:43.884 
我們會將你調回
執行第二個類型

00:04:44.218 --> 00:04:46.820 
此時您將需要提供
一個UI BezierPath

00:04:46.887 --> 00:04:47.754 
用於碰撞邊界

00:04:48.822 --> 00:04:51.458 
所以如果我們要模擬
項目之間的

00:04:51.525 --> 00:04:53.894 
邊界不同的碰撞
爲保險起見

00:04:53.961 --> 00:04:56.129 
我們要多做幾次
情況可能看起來像這樣

00:04:56.630 --> 00:04:58.932 
這次碰撞看起來
比過去所有項目

00:04:58.999 --> 00:05:00.033 
都有矩形碰撞邊界

00:05:00.100 --> 00:05:02.436 
的情況下更現實

00:05:04.872 --> 00:05:07.875 
現在 爲碰撞邊界
設定路徑時有

00:05:07.941 --> 00:05:09.943 
一些限制
特別是

00:05:10.010 --> 00:05:13.180 
BezierPath要求必須是凸起
的逆時針模繞

00:05:13.580 --> 00:05:14.815 
並且非自相交

00:05:15.415 --> 00:05:17.985 
這些都是非常基本的
如果你仔細想想

00:05:18.785 --> 00:05:19.987 
也沒有什麼太花哨的東西

00:05:20.454 --> 00:05:23.457 
我們還需要記住
當項目在屏幕上時

00點將代表


00:05:27.461 --> 00:05:28.462 
動態項的中心點

00:05:30.230 --> 00:05:33.333 
這就是碰撞邊界的更新內容
讓我們來談談動態項目組

00:05:33.567 --> 00:05:35.936 
這是進行
多個項目

00:05:36.170 --> 00:05:38.405 
並使他們作爲一項
在底層引擎運行的基本方式

00:05:39.106 --> 00:05:41.842 
這個項目組
保留每個項目

00:05:42.042 --> 00:05:45.245 
的位置和各自的
碰撞邊界

00:05:45.479 --> 00:05:49.550 
所以因爲這個原因 你應該
把這些項目與一組

00:05:49.850 --> 00:05:51.218 
而不是單獨的行爲
關聯起來

00:05:51.285 --> 00:05:52.586 
與其將它們與組
進行關聯

00:05:52.986 --> 00:05:54.288 
將組與
任何行爲進行關聯

00:05:54.354 --> 00:05:56.223 
你更傾向於
與animator組件關聯

00:05:56.290 --> 00:05:57.891 
總的來說 這會
把那些行爲

00:05:57.958 --> 00:05:58.992 
強加在項目上

00:05:59.860 --> 00:06:02.462 
而一個組卻不能被
添加到其他組中

00:06:02.529 --> 00:06:03.897 
這是一個一級抽象

00:06:04.598 --> 00:06:07.668 
所以要創建凹形或其他

00:06:07.734 --> 00:06:10.737 
複雜的不能用動
態項目邊界路徑創建的幾何結構

00:06:11.338 --> 00:06:13.941 
而且總體來說行爲能夠有此影響

00:06:14.341 --> 00:06:15.809 
要做
到這些 這是一個很好的方式

00:06:17.077 --> 00:06:19.313 
那麼 讓我們暫時
回到滑動示例

00:06:21.481 --> 00:06:24.418 
我們希望實現更豐富的滑動效果
而不僅僅是簡單的平移和回落

00:06:24.484 --> 00:06:27.154 
比如我們讓屏幕
在用戶觸碰時輕微跳動

00:06:27.221 --> 00:06:28.522 
顯示可以平移

00:06:29.289 --> 00:06:31.124 
要做到這些 我們只需要

00:06:31.191 --> 00:06:33.293 
給滑動視圖添加一個簡短的力

00:06:33.894 --> 00:06:34.995 
這就是那力

00:06:37.130 --> 00:06:40.067 
所以我們可以在項目
的中心把這個力

00:06:40.334 --> 00:06:44.471 
作爲一個向量進行模擬在項目的中心
向量的長度對應的這個力

00:06:44.538 --> 00:06:47.374 
的長度 向量指向上方以說明

00:06:47.441 --> 00:06:49.743 
這個力的方向 在本例中我們要

00:06:49.810 --> 00:06:51.578 
向上移動視圖 所以這個力指向上方

00:06:52.379 --> 00:06:55.382 
爲了應用這個力我們就要使用
UIPushBehavior

00:06:56.083 --> 00:06:58.118 
你還記得的話
UIPushBehavior

00:06:58.185 --> 00:06:59.486 
有兩種截然不同的模式

00:06:59.887 --> 00:07:02.990 
它有一個連續模式
代表了一種跨越時間的力

00:07:03.056 --> 00:07:05.492 
另一個模式是瞬時模式

00:07:05.993 --> 00:07:08.395 
代表一個簡短的瞬間的力

00:07:08.529 --> 00:07:09.730 
或者稱爲一個脈衝

00:07:10.597 --> 00:07:13.667 
對於這種交互 我們
只需要一個簡短的力 它會反彈回來

00:07:13.734 --> 00:07:15.135 
然後靜止
所以我們要

00:07:15.202 --> 00:07:16.136 
使用瞬時模式

00:07:16.537 --> 00:07:18.272 
我們這樣做就
得到一個簡短的力

00:07:18.338 --> 00:07:20.407 
但是什麼使視圖回來？

00:07:20.474 --> 00:07:22.476 
我們給它一個力
使它向上移動

00:07:22.543 --> 00:07:24.011 
但它卻回落下來

00:07:24.778 --> 00:07:28.382 
這是我們的複合行爲
是由重力

00:07:28.448 --> 00:07:29.750 
碰撞和附件構成的

00:07:30.083 --> 00:07:31.818 
所以是重力
使其移動下來

00:07:31.885 --> 00:07:33.487 
然後它再以
碰撞行爲反彈

00:07:34.121 --> 00:07:35.856 
但讓我們來
多瞭解一些重力

00:07:35.923 --> 00:07:37.324 
以及它如何影響
我們的項目

00:07:38.091 --> 00:07:39.993 
我們從開始
施加脈衝力的瞬間

00:07:40.661 --> 00:07:42.963 
來看滑動視圖

00:07:43.030 --> 00:07:44.498 
的垂直運動

00:07:44.932 --> 00:07:47.401 
你會發現
這個力是作用於一個點

00:07:47.601 --> 00:07:50.070 
然後項目向上移動
再以弧形回落

00:07:50.804 --> 00:07:53.073 
這是因爲在我們的
圖表中重力

00:07:53.140 --> 00:07:54.575 
無時無地
不在影響它

00:07:54.875 --> 00:07:57.578 
如果我們把這些力與重力相加
情況看起來

00:07:57.644 --> 00:08:01.815 
可能像這樣
這個力是應用於

00:08:01.882 --> 00:08:03.417 
所有位置和時間的

00:08:03.617 --> 00:08:04.985 
所以不容易模擬

00:08:05.419 --> 00:08:07.354 
也許我們可以試着
使用UI來推動行爲

00:08:07.454 --> 00:08:09.289 
但是這會非常
複雜的 而且很快

00:08:09.990 --> 00:08:12.492 
所以我們需要更多地
把重力當作一個場加以思考

00:08:13.360 --> 00:08:15.495 
場非常簡單
它只是一個函數

00:08:15.729 --> 00:08:18.832 
在指定的定義域內
給每一個點分配一個向量

00:08:18.999 --> 00:08:20.701 
在這個例子中
我們的定義域

00:08:20.767 --> 00:08:21.935 
是整個參考視圖

00:08:22.236 --> 00:08:24.605 
所以我們希望重力
在整個參考視圖裏

00:08:24.938 --> 00:08:26.006 
影響滑動視圖

00:08:26.840 --> 00:08:27.674 
特別簡單

00:08:27.875 --> 00:08:30.677 
所以我們採用了這個場
的想法 並加以擴展

00:08:31.011 --> 00:08:33.780 
在iOS 9中 我們引入了
UIFieldBehavior

00:08:34.780 --> 00:08:36.283 
UIFieldBehavior

00:08:36.350 --> 00:08:38.150 
是一個
可以添加到參考視圖的

00:08:38.217 --> 00:08:42.222 
一個區域中的方法
場在參考視圖之內的

00:08:42.289 --> 00:08:43.222 
每一個點都被賦值

00:08:43.289 --> 00:08:46.393 
任何產生的力量

00:08:46.460 --> 00:08:48.195 
自動被動態animator組件應用

00:08:48.262 --> 00:08:49.530 
到已經與場關聯的
項目中

00:08:51.164 --> 00:08:54.134 
如果你在想
我們現有的UIGravityBehavior

00:08:54.535 --> 00:08:56.203 
被作爲一個場實施

00:08:57.504 --> 00:08:58.805 
重要的是還要記住

00:08:58.872 --> 00:09:00.073 
這是簡化的物理

00:09:00.140 --> 00:09:01.642 
爲適應這個展示進行了調整

00:09:02.009 --> 00:09:03.744 
我不會用它來建造

00:09:03.810 --> 00:09:05.312 
星際空間站
或類似的東西

00:09:06.747 --> 00:09:09.283 
讓我們看一看內置場的類型

00:09:09.483 --> 00:09:10.684 
這裏種類非常豐富

00:09:10.784 --> 00:09:12.686 
有線性和放射重力場、

00:09:12.753 --> 00:09:14.254 
速度和阻力場、

00:09:14.321 --> 00:09:17.191 
渦流場以及依據胡克定律的彈簧場

00:09:17.257 --> 00:09:18.525 
還有電場

00:09:18.592 --> 00:09:20.460 
和磁場

00:09:21.328 --> 00:09:23.096 
如果還不能滿足你的需要

00:09:23.163 --> 00:09:24.998 
我們也提供自定義力鑑別器

00:09:25.065 --> 00:09:26.033 
此話題我們稍後再敘

00:09:26.466 --> 00:09:28.335 
我們先從線性重力開始

00:09:29.369 --> 00:09:31.371 
我們首先會注意到它處於一個區域內

00:09:31.638 --> 00:09:33.440 
就像我們之前講的那樣

00:09:33.907 --> 00:09:36.476 
而且它有場強
我們使用默認值1

00:09:36.810 --> 00:09:38.412 
它也是一個方向作用力

00:09:38.478 --> 00:09:41.548 
我們使用熟悉的重力方向

00:09:42.082 --> 00:09:43.317 
舉例

00:09:43.550 --> 00:09:46.119 
但它實際可以指向任何方向

00:09:46.720 --> 00:09:50.324 
讓我們看一看放射重力和
線性重力的區別

00:09:51.058 --> 00:09:55.729 
除存在於一個區域並且有場強外

00:09:55.796 --> 00:09:59.900 
這兒有一個位置作爲一個質點
用放射重力可以模擬

00:10:00.467 --> 00:10:02.503 
如你所知

00:10:02.569 --> 00:10:04.838 
兩個物體之間重力

00:10:04.905 --> 00:10:09.076 
與距離的平方成反比

00:10:09.343 --> 00:10:11.945 
這兒是物體之間距離的平方

00:10:12.012 --> 00:10:14.781 
這個指數是場的衰減值

00:10:15.148 --> 00:10:17.351 
距離場的位置越遠

00:10:17.851 --> 00:10:21.255 
場產生的作用力就會減小

00:10:21.822 --> 00:10:23.824 
這兒也有最小半徑

00:10:24.324 --> 00:10:29.296 
這一方法可以確定
一個物體距離位置點多遠

00:10:29.363 --> 00:10:31.832 
纔可以感受到場的作用力

00:10:33.333 --> 00:10:35.002 
我們還有一個噪聲場

00:10:35.502 --> 00:10:37.404 
在這方面我們注意到的第一個問題是

00:10:37.471 --> 00:10:40.874 
它隨着時間變化 你可以使用動畫速度

00:10:40.941 --> 00:10:42.476 
來調節 默認值爲1

0表示靜態場


00:10:45.012 --> 00:10:46.914 
你也可以使用平滑參數

00:10:46.980 --> 00:10:48.448 
調節噪聲程度

00:10:50.717 --> 00:10:52.486 
讓我們看一看自定義場鑑別器

00:10:53.287 --> 00:10:54.721 
使用起來非常簡單

00:10:54.788 --> 00:10:59.026 
先使用場鑑別框創建一個
UIFieldBehavior並初始化

00:10:59.693 --> 00:11:02.996 
然後就可以調用該框
使用幾個場取樣包含相關取樣位置

00:11:03.163 --> 00:11:05.999 
速度、質量、負載以及時間

00:11:06.066 --> 00:11:08.368 
下來你就可以使用它來

00:11:08.435 --> 00:11:10.537 
判斷任何作用力

00:11:11.004 --> 00:11:13.574 
這裏我們需要做的是選擇位置 x位置

00:11:13.941 --> 00:11:15.075 
然後繪成正弦波

00:11:15.676 --> 00:11:16.510 
一個很酷的結果

00:11:17.878 --> 00:11:20.380 
這是一些基本的內置場

00:11:20.447 --> 00:11:22.382 
和UIFieldBehavior
的概述

00:11:22.616 --> 00:11:25.018 
我想邀請大衛

00:11:25.252 --> 00:11:26.086 
舉例展示

00:11:33.227 --> 00:11:34.995 
大家好 我們將

00:11:35.062 --> 00:11:36.597 
帶你體驗一個

00:11:36.663 --> 00:11:38.632 
我相信你們以前都見過的一個例子

00:11:40.534 --> 00:11:43.470 
我確信你們某個時候
都使用過FaceTime

00:11:43.537 --> 00:11:45.572 
所以這兒的例子是

00:11:45.672 --> 00:11:47.207 
創建一個相似的UI

00:11:47.274 --> 00:11:49.977 
管理屏幕中的臉孔

00:11:51.044 --> 00:11:52.813 
正如你所看到的 在我滑過這兒時

00:11:53.313 --> 00:11:55.716 
方框移動順暢

00:11:55.782 --> 00:11:58.952 
如果我從角上拉開一點 它會彈回

00:11:59.019 --> 00:12:01.021 
如果我再拉 它會有

00:12:01.088 --> 00:12:02.756 
漂亮的漸入曲線

00:12:02.823 --> 00:12:05.425 
如果向下拋 它就會

00:12:05.492 --> 00:12:07.628 
沿着四周邊沿彈開

00:12:08.061 --> 00:12:10.297 
你會注意到在我向下拋時 它並沒有

00:12:10.364 --> 00:12:12.432 
直接到它應到的地方

00:12:12.666 --> 00:12:14.735 
實際上有一個物理過程 它會彈離

00:12:14.801 --> 00:12:16.503 
屏幕邊沿並回到原位

00:12:17.704 --> 00:12:22.042 
現在 我可以產生一個調試視圖

00:12:22.109 --> 00:12:23.977 
看看這些作用力場的樣子

00:12:24.578 --> 00:12:25.712 
這樣 你可以看到

00:12:31.685 --> 00:12:33.954 
這兒
你可以看到我們有四個彈簧場在運行

00:12:34.021 --> 00:12:38.158 
我們可以很容易地解釋所發生的事情

00:12:38.225 --> 00:12:40.227 
如果我們把這個放在邊沿

00:12:40.294 --> 00:12:41.562 
我們知道它會彈回

00:12:42.462 --> 00:12:44.865 
如果我們跨越兩者 那麼根據

00:12:44.932 --> 00:12:47.000 
我們跨越的位置
它會選擇一邊或另一邊

00:12:47.801 --> 00:12:49.336 
穿過中間

00:12:49.703 --> 00:12:50.971 
它會選擇最近的一邊

00:12:51.538 --> 00:12:52.940 
讓我們看看怎樣設置

00:12:53.006 --> 00:12:55.909 
怎樣在實際中獨立完成

00:12:58.145 --> 00:13:00.848 
第一就是建立Sticky
Corners 行爲

00:13:01.281 --> 00:13:03.750 
根據麥克的說法
它是由其它行爲構成的

00:13:03.817 --> 00:13:06.320 
這種複雜的行爲可以做完成我們的一切
想法

00:13:06.720 --> 00:13:08.288 
在這種情況下 它會產生衝突行爲

00:13:08.355 --> 00:13:09.456 
因爲我們不想讓你的面孔

00:13:09.523 --> 00:13:11.091 
急速離開屏幕邊沿

00:13:11.825 --> 00:13:14.161 
我們有一個動態的項目行爲

00:13:14.228 --> 00:13:16.296 
可以影響面孔的屬性

00:13:16.630 --> 00:13:18.165 
這樣 我們可以減小密度

00:13:18.232 --> 00:13:19.900 
使引擎具光感

00:13:20.334 --> 00:13:22.870 
但需要增加其對運動的耐受性 這樣

00:13:22.936 --> 00:13:25.272 
它位於某一地點時
就不會繞着那個位置

00:13:25.339 --> 00:13:26.373 
不斷旋轉

00:13:27.140 --> 00:13:28.809 
最後我們禁用旋轉

00:13:28.876 --> 00:13:29.910 
因爲這樣做沒有意義

00:13:29.977 --> 00:13:31.011 
你並不想讓自己的面孔

00:13:31.078 --> 00:13:32.145 
在屏幕中旋轉

00:13:33.947 --> 00:13:35.749 
最後我們有個這些場行爲

00:13:35.816 --> 00:13:38.852 
四個彈簧場標出了四個角

00:13:38.952 --> 00:13:40.587 
我們也把它們增添到行爲中

00:13:40.988 --> 00:13:44.525 
現在無論什麼時候人們增添這種
StickyCorners 行爲

00:13:44.625 --> 00:13:46.260 
都會免費得到這種行爲

00:13:48.629 --> 00:13:50.397 
接下來 看看視圖控制器

00:13:50.964 --> 00:13:53.634 
我們去看一看建立視圖層級需要的一切

00:13:54.368 --> 00:13:56.336 
但還需增添一個拖動手勢識別器

00:13:56.403 --> 00:13:58.605 
這樣 用戶可以選擇面孔

00:13:58.672 --> 00:13:59.773 
並在屏幕移動

00:14:00.974 --> 00:14:03.410 
長按手勢識別器則會使我們

00:14:03.477 --> 00:14:05.312 
開關調試界面

00:14:05.913 --> 00:14:07.281 
我們創建動態仿真器

00:14:07.447 --> 00:14:09.783 
並增添StickyCorners行
爲

00:14:10.184 --> 00:14:12.252 
手勢識別器是如何工作的？

00:14:12.753 --> 00:14:15.289 
像往常一樣
手勢識別在狀態之間進行

00:14:15.355 --> 00:14:19.993 
它從begin開始
開始後 我們做一些記賬

00:14:20.060 --> 00:14:23.263 
這樣我們可以跟蹤進展但我們也需要禁
用sticky behavior

00:14:23.330 --> 00:14:24.698 
我馬上會演示我們是怎樣做的

00:14:25.365 --> 00:14:27.835 
同樣 當它變化時 我們向四周移動

00:14:28.502 --> 00:14:30.137 
當它取消或結束時

00:14:30.504 --> 00:14:32.072 
這是比較特殊的地方

00:14:32.573 --> 00:14:35.442 
當用戶停止互動時

00:14:35.509 --> 00:14:37.377 
我們檢查拖動手勢識別器的速度

00:14:37.911 --> 00:14:40.247 
並使用它把速度增添到

00:14:40.314 --> 00:14:41.715 
動態體系中

00:14:41.782 --> 00:14:44.551 
這樣 當用戶離開視圖時

00:14:44.718 --> 00:14:47.521 
它會繼續隨用戶的動作而移動

00:14:47.754 --> 00:14:49.623 
而不是突然停止並

00:14:49.690 --> 00:14:51.058 
由場完全接管

00:14:51.725 --> 00:14:53.026 
禁用和啓用

00:14:53.093 --> 00:14:54.494 
都是由於相同的理由

00:14:54.828 --> 00:14:56.196 
在用戶在活動中時

00:14:56.263 --> 00:14:57.965 
我們不想讓這些場處於活躍狀態

00:14:58.031 --> 00:14:58.899 
否則它會從我們的

00:14:58.966 --> 00:15:00.100 
指尖下溜走

00:15:01.668 --> 00:15:02.970 
所以我們再回過來看一下

00:15:03.036 --> 00:15:05.239 
看看是怎樣啓用的

00:15:05.806 --> 00:15:07.541 
的確非常簡單

00:15:07.941 --> 00:15:10.544 
在啓用時 我們把所有項目增添到

00:15:10.611 --> 00:15:13.080 
這些行爲中 當禁用時
我們再取出來

00:15:13.380 --> 00:15:16.316 
創建這樣一個系統非常簡單

00:15:16.383 --> 00:15:18.519 
你可以在自己的程序中

00:15:18.719 --> 00:15:20.220 
建立類似
FaceTime的行爲

00:15:20.287 --> 00:15:22.990 
所以 爲了告訴你們如何將調試UI

00:15:23.190 --> 00:15:24.258 
置入你自己的應用程序

00:15:24.324 --> 00:15:25.726 
我要讓麥克上來幫我一下

00:15:32.733 --> 00:15:33.567 
謝謝 大衛

00:15:34.101 --> 00:15:37.004 
真的非常好 在大衛的例子中

00:15:37.070 --> 00:15:38.772 
爲了能夠一探究竟

00:15:38.972 --> 00:15:41.508 
將這些場線可視化了

00:15:41.909 --> 00:15:43.810 
在他打開它之前 這顯得很神祕

00:15:44.611 --> 00:15:47.948 
所以 在你的動畫設計參照視圖中

00:15:48.315 --> 00:15:50.150 
這些線基本是用來顯示這個場的疊加圖

00:15:51.151 --> 00:15:53.820 
特別是 這個疊加圖能夠幫助你將

00:15:54.154 --> 00:15:56.924 
各個場、碰撞邊界、附件 以及

00:15:56.990 --> 00:15:59.092 
某特定組件是運動還是靜止可視化

00:16:00.661 --> 00:16:02.930 
現在 你可能奇怪 這不會是API

00:16:03.864 --> 00:16:06.767 
但是它在LLDB中可以存取
而我們也正在把它

00:16:06.834 --> 00:16:09.736 
作爲UIDynamicAnimator上的
一個有效的調試功能加以推廣

00:16:09.903 --> 00:16:11.071 
而且它用起來確實很簡單

00:16:11.271 --> 00:16:12.606 
暫停調試程序

00:16:12.673 --> 00:16:14.208 
爲你的動態動畫設計找一個參照

00:16:14.641 --> 00:16:16.076 
激活調試功能 設定在true

00:16:16.376 --> 00:16:18.979 
然後你將得到這個漂亮的疊加圖
它能夠給出所有的物理屬性

00:16:24.051 --> 00:16:27.287 
現在 除了激活和滅活調試功能之外

00:16:27.354 --> 00:16:28.956 
我們還要給出調試間隔

00:16:29.056 --> 00:16:30.457 
這樣你就可以調整

00:16:30.524 --> 00:16:33.160 
調試疊加圖更新的時間間隔了

00:16:33.460 --> 00:16:35.229 
所以 默認情況下

00:16:35.295 --> 00:16:37.030 
每個動畫幀都會更新
但是如果你有許多

00:16:37.097 --> 00:16:39.867 
複雜的物理屬性 那麼可能

00:16:39.933 --> 00:16:41.034 
例如 最好把間隔改爲5

00:16:41.101 --> 00:16:43.237 
即只是每到第5幀才更新

00:16:44.238 --> 00:16:47.274 
同時 我們還允許你調節

00:16:47.341 --> 00:16:48.442 
動態動畫設計的動畫速度

00:16:48.909 --> 00:16:51.078 
此時放慢速度可能有利於

00:16:51.211 --> 00:16:52.746 
觀察真實的過程

00:16:53.046 --> 00:16:55.582 
之後 重要的是要記住 在使用時

00:16:56.116 --> 00:16:57.951 
如果放慢速度

00:16:58.252 --> 00:16:59.219 
可能會影響模擬效果

00:16:59.286 --> 00:17:00.854 
所以一定要確保以1x修正

00:17:03.490 --> 00:17:06.693 
那麼接下來讓我們談談
UIDynamicItemBehavior

00:17:06.827 --> 00:17:08.127 
現在 如果你再次調用

00:17:08.194 --> 00:17:11.498 
可改變你的視圖或動態道具的物理屬性

00:17:12.031 --> 00:17:14.535 
這適用於一個或多個動態道具

00:17:15.035 --> 00:17:16.403 
在大衛的例子中

00:17:16.470 --> 00:17:18.505 
他爲FaceTime方塊選用了低密
度

00:17:18.571 --> 00:17:20.641 
及高阻力

00:17:20.941 --> 00:17:22.776 
使其牢牢固定於場的角點

00:17:23.510 --> 00:17:26.012 
就現有特性 在此多舉幾個例子

00:17:26.079 --> 00:17:29.883 
我們有彈性、摩擦力
我們看到了密度和阻力

00:17:29.950 --> 00:17:32.052 
我們有角阻力 這些都可調節

00:17:32.386 --> 00:17:34.821 
你的道具在動畫引擎中的狀態

00:17:35.522 --> 00:17:38.792 
在iOS 9中
我們增加了兩個性能

00:17:38.959 --> 00:17:41.995 
這影響你的道具

00:17:42.062 --> 00:17:44.131 
在我們新型電場和磁場中的參與度；

00:17:44.464 --> 00:17:46.466 
我們還增加了anchored屬性

00:17:47.034 --> 00:17:48.001 
這個略有不同

00:17:48.502 --> 00:17:51.038 
但是它能讓你的道具

00:17:51.104 --> 00:17:54.474 
參與動態系統 參與碰撞

00:17:54.541 --> 00:17:56.677 
不過沒有自己的速度

00:17:56.743 --> 00:17:59.112 
所以更像是碰撞邊界

00:18:00.280 --> 00:18:01.181 
那麼接下來

00:18:01.248 --> 00:18:03.650 
我要談談UIAttachmentB
ehavior

00:18:03.917 --> 00:18:06.386 
這讓你能夠約束兩個動態道具

00:18:06.453 --> 00:18:09.156 
從而讓它們彼此
保持特定的距離

00:18:09.690 --> 00:18:13.060 
你可以利用阻尼和頻率進行配置

00:18:13.360 --> 00:18:16.129 
讓它更像一個彈簧 而不是連桿

00:18:16.763 --> 00:18:18.098 
這是一個很好的附件

00:18:18.165 --> 00:18:20.901 
你知道 它很有用 但是你也確實

00:18:20.968 --> 00:18:23.203 
只有一個辦法來約束兩個道具

00:18:24.438 --> 00:18:27.474 
所以 在iOS
9中 我們增加了更多附件類型

00:18:28.308 --> 00:18:29.877 
第一個是限制附件

00:18:30.477 --> 00:18:32.446 
這與剛講到的距離附件很像

00:18:32.513 --> 00:18:35.415 
但不是我們能想到的

00:18:35.482 --> 00:18:37.751 
像一個連桿或彈簧一樣受約束

00:18:38.252 --> 00:18:40.821 
而是更像兩個道具間的一根繩子

00:18:40.921 --> 00:18:43.624 
唯一約束是彼此間的
最大距離

00:18:44.658 --> 00:18:46.827 
你對它的配置類似於距離附件

00:18:47.127 --> 00:18:49.863 
規定從每個道具中心偏移出的兩個點

00:18:50.631 --> 00:18:51.465 
很簡單

00:18:51.965 --> 00:18:53.500 
接下來是一個固定的附件

00:18:54.468 --> 00:18:57.104 
這與限制附件或距離附件
略有不同

00:18:57.704 --> 00:19:01.041 
在你創建這種類型的附件時
首先規定一個錨點

00:19:01.375 --> 00:19:04.178 
就每個道具中心而言 這個錨點

00:19:05.012 --> 00:19:07.181 
位於你的參照視圖座標空間

00:19:08.148 --> 00:19:12.319 
而這類附件無論如何不會
在兩個道具之間運動

00:19:12.653 --> 00:19:18.725 
相對於允許道具端部旋轉的連桿
它更像是兩道具間的焊接杆

00:19:20.360 --> 00:19:22.462 
我們還增加了一種鎖銷附件

00:19:23.363 --> 00:19:25.399 
這個類似於固定附件

00:19:25.465 --> 00:19:29.036 
即你可以
先在兩個道具間規定一個錨點

00:19:30.070 --> 00:19:34.441 
但是這種類型附件允許兩個道具
圍繞這個錨點在彼此之間旋轉

00:19:35.008 --> 00:19:39.379 
這樣你可以規定一個旋轉範圍
默認狀態下無界

00:19:39.680 --> 00:19:42.482 
但是我們可以給出界限
如縮小範圍

00:19:43.417 --> 00:19:46.186 
最後我們增加了一個滑動附件

00:19:46.787 --> 00:19:49.489 
這個滑動附件有點複雜

00:19:49.556 --> 00:19:51.058 
我們等一下看一個例子

00:19:51.558 --> 00:19:53.627 
和固定附件及鎖銷附件一樣

00:19:53.694 --> 00:19:56.063 
我們先在參照視圖座標空間

00:19:56.129 --> 00:19:57.631 
規定附件錨點

00:19:58.866 --> 00:20:00.334 
但是與這兩個類型不同 我們還要

00:20:00.400 --> 00:20:02.436 
規定一個平移軸

00:20:02.903 --> 00:20:04.805 
這裏 兩個道具之間

00:20:04.872 --> 00:20:07.574 
相對運動都將沿着這個平移軸

00:20:08.342 --> 00:20:11.245 
這個類型的附件可阻止兩個道具
所有的相對旋轉

00:20:11.311 --> 00:20:13.614 
所以 兩個道具不能再旋轉

00:20:13.680 --> 00:20:16.550 
只能沿着這個平移軸
運動

00:20:17.818 --> 00:20:18.852 
但像鎖銷附件一樣

00:20:19.186 --> 00:20:21.121 
你可以限制平移範圍

00:20:21.288 --> 00:20:23.090 
這樣 如果你規定了一個平移範圍

00:20:23.423 --> 00:20:25.559 
就要把附件錨點

00:20:26.093 --> 00:20:27.494 
放在確定爲範圍零點的

00:20:27.561 --> 00:20:29.162 
錨點位置

00:20:29.897 --> 00:20:32.132 
所以
如果我們以這種類型附件建立該系統

00:20:32.799 --> 00:20:33.967 
我們就能夠得到

00:20:34.034 --> 00:20:35.569 
兩個道具間直線運動
就是這樣

00:20:36.470 --> 00:20:37.437 
所以 相當複雜

00:20:37.504 --> 00:20:38.906 
讓我們看一個基本示例

00:20:39.940 --> 00:20:41.308 
爲此 我想

00:20:41.375 --> 00:20:43.243 
再次回到滑動的例子

00:20:44.478 --> 00:20:46.647 
是說過在過去 如果我們

00:20:46.713 --> 00:20:49.583 
使其可滑動 將必須

00:20:49.650 --> 00:20:51.985 
在底部
每一側以及頂部離開屏面的某處

00:20:52.052 --> 00:20:53.887 
增加一個碰撞

00:20:54.188 --> 00:20:55.222 
以限制滑動視圖

00:20:55.455 --> 00:20:57.424 
沿着垂直軸的運動

00:20:58.025 --> 00:21:00.294 
那麼
有了UI附件 我們再無需如此

00:21:00.360 --> 00:21:02.763 
我們用滑動附件就能做到

00:21:03.030 --> 00:21:04.798 
所以 我們把系統控制在一次碰撞

00:21:05.165 --> 00:21:06.166 
使其表現更佳

00:21:06.433 --> 00:21:08.135 
而代碼確實更易讀

00:21:08.902 --> 00:21:10.537 
所以 如果我們在此激活調試視圖

00:21:10.971 --> 00:21:13.307 
你就能夠看到

00:21:13.373 --> 00:21:15.375 
通過沿垂直軸的直線描畫的滑動附件

00:21:15.442 --> 00:21:18.412 
它隨我們滑動視圖而縮放

00:21:18.879 --> 00:21:20.480 
但是同時還有一個附件

00:21:20.848 --> 00:21:23.717 
即距離附件 我們用它

00:21:23.784 --> 00:21:25.586 
通過一個平移手勢識別器

00:21:25.652 --> 00:21:26.820 
附於一個操控錨點

00:21:27.321 --> 00:21:29.556 
所以 不同於大衛的演示

00:21:29.623 --> 00:21:30.624 
這個完全在動態系統內

00:21:30.691 --> 00:21:32.659 
我們不做任何禁用或啓動

00:21:32.826 --> 00:21:33.760 
我們只是保持動態

00:21:34.361 --> 00:21:35.195 
好極了

00:21:35.829 --> 00:21:36.897 
所以最後

00:21:36.964 --> 00:21:39.733 
讓我在UISnapBehav
ior上爲你做一個快速更新

00:21:39.800 --> 00:21:42.503 
如果再次你調用UISnapBeha
vior 它能做的更多

00:21:42.803 --> 00:21:46.139 
它可以被用來將一個視圖從一個位置
移動到另一個位置

00:21:46.206 --> 00:21:47.107 
並有一種快動效果

00:21:47.941 --> 00:21:50.244 
通過SnapBehavior
你可以定製快拍阻尼

00:21:50.310 --> 00:21:53.113 
這樣確實可以調節

00:21:53.180 --> 00:21:54.815 
感覺上的快慢

00:21:55.616 --> 00:21:58.018 
在iOS 9中 我們也新增了

00:21:58.085 --> 00:22:00.220 
初始化後定製捕捉點的功能

00:22:00.287 --> 00:22:01.822 
同樣相當不錯

00:22:02.089 --> 00:22:03.357 
這裏讓我看一個簡單的例子

00:22:03.991 --> 00:22:08.262 
所以 如果我們試着平移視圖
那麼打開調試功能

00:22:08.629 --> 00:22:11.598 
就會回到如最初捕捉點的屏面

00:22:12.032 --> 00:22:14.601 
如果我們輕敲另一個位置
就會對齊到新點

00:22:14.701 --> 00:22:16.203 
即在現有動態特性基礎上

00:22:16.503 --> 00:22:18.105 
調節捕捉點

00:22:18.472 --> 00:22:19.306 
相當不錯

00:22:19.640 --> 00:22:22.976 
你還會注意到 有了調試疊加圖

00:22:23.544 --> 00:22:25.646 
這些實際上都是自行合成

00:22:25.712 --> 00:22:29.082 
這裏4個附件 配置如彈簧

00:22:29.516 --> 00:22:31.885 
把視圖對齊到新位置

00:22:31.952 --> 00:22:32.786 
確實非常棒

00:22:33.554 --> 00:22:34.388 
所以 這就是

00:22:34.454 --> 00:22:36.857 
UIKit Dynamics
和iOS 9中新增的內容

00:22:37.391 --> 00:22:38.759 
我要把它交給大衛

00:22:38.825 --> 00:22:39.927 
讓他談談視覺效果

00:22:46.500 --> 00:22:47.334 
各位早上好

00:22:47.734 --> 00:22:49.870 
那麼我們接下來要談談利用視覺效果

00:22:49.937 --> 00:22:51.471 
爲你的應用增加新模式

00:22:52.272 --> 00:22:56.009 
那麼我們用一個簡單的圖像瀏覽器應用
示例來形象地加以說明

00:22:56.343 --> 00:23:00.180 
這裏 我們要
向用戶額外介紹一下

00:23:00.247 --> 00:23:01.748 
他們目前正在看的圖片

00:23:02.316 --> 00:23:05.519 
看右邊 圖像上面

00:23:05.586 --> 00:23:06.553 
有點疊加部分

00:23:06.620 --> 00:23:09.122 
是我們圖像的文件名

00:23:09.690 --> 00:23:11.892 
所以我們要看看如何創建

00:23:13.160 --> 00:23:15.229 
那麼 第一步是你要

00:23:15.295 --> 00:23:16.330 
形成一種模糊效果

00:23:16.864 --> 00:23:19.199 
我們有3種模式 超亮、

00:23:19.299 --> 00:23:20.467 
明亮及陰暗模式

00:23:22.302 --> 00:23:25.172 
你通過這些模式形成一種模糊效果

00:23:25.572 --> 00:23:27.341 
就是那樣

00:23:27.908 --> 00:23:30.444 
最後 你用模糊模式形成

00:23:30.611 --> 00:23:31.712 
你的視覺效果圖

00:23:32.312 --> 00:23:34.248 
之後只要添加你需要的佈局

00:23:34.548 --> 00:23:36.350 
你就能夠得到屏面上你看到的模糊效果

00:23:38.085 --> 00:23:39.820 
下一步 我們要添加振動效果

00:23:39.887 --> 00:23:42.523 
振動的作用是 使某物在模糊模式

00:23:42.589 --> 00:23:44.958 
突然彈出

00:23:46.159 --> 00:23:47.928 
所以接下來 我們要

00:23:47.995 --> 00:23:49.763 
通過模糊效果形成振動效果

00:23:49.930 --> 00:23:51.698 
如上面提到的 確實要要模糊疊加

00:23:51.765 --> 00:23:54.234 
所以我們從模糊效果開始

00:23:54.301 --> 00:23:55.536 
形成振動效果

00:23:56.603 --> 00:23:57.905 
我們形成振動效果

00:23:57.971 --> 00:23:59.173 
正如我們之前形成模糊效果

00:24:00.174 --> 00:24:01.742 
此時 我們要

00:24:01.808 --> 00:24:04.278 
在模糊視圖中添加內容視圖

00:24:04.344 --> 00:24:07.147 
現在 不必直接加到模糊視圖上

00:24:07.214 --> 00:24:10.384 
而應是在視覺效果圖後

00:24:10.450 --> 00:24:11.351 
有一個模糊視圖

00:24:12.419 --> 00:24:14.288 
最後 我們

00:24:14.354 --> 00:24:16.223 
在振動視圖的內容視圖上加標籤

00:24:16.823 --> 00:24:19.326 
視覺效果圖的內容視圖上

00:24:19.393 --> 00:24:21.295 
加這些東西是要確保

00:24:21.361 --> 00:24:23.797 
你給出的所有內容

00:24:23.864 --> 00:24:24.698 
效果無誤

00:24:26.166 --> 00:24:27.434 
所以 當你完成這些之後

00:24:27.901 --> 00:24:30.304 
模糊視圖頂部就有了可愛的標籤

00:24:30.404 --> 00:24:31.638 
正如你在屏面上看到的那樣

00:24:32.406 --> 00:24:33.907 
那麼iOS 9有什麼新東西呢

00:24:34.541 --> 00:24:37.077 
首先我們使得

00:24:37.144 --> 00:24:40.380 
你的視圖邊界有清新的動畫效果

00:24:40.848 --> 00:24:42.783 
在模糊視圖中你可以向用戶顯示更多信
息

00:24:42.850 --> 00:24:45.919 
而無需做任何複雜的工作

00:24:46.887 --> 00:24:48.689 
但是 除此之外 我們讓你能夠

00:24:48.755 --> 00:24:50.057 
讓模糊視圖生動有趣

00:24:52.125 --> 00:24:54.728 
那麼現在 比如
如果你的app有夜間加載模式

00:24:54.795 --> 00:24:56.930 
你在你的應用中可以日夜都採用非常清
新的動畫

00:24:56.997 --> 00:24:58.966 
並推動用戶

00:25:00.267 --> 00:25:02.102 
接下來我們要簡要介紹

00:25:02.169 --> 00:25:04.972 
我們如何切實地把這些效果搬上屏面

00:25:05.072 --> 00:25:08.008 
它做什麼用 以及你爲什麼需要知道

00:25:08.075 --> 00:25:09.843 
這很重要 因爲所有這些都會影響

00:25:09.910 --> 00:25:11.345 
性能和修正

00:25:12.145 --> 00:25:13.881 
這裏 小嬰兒Sophia帶我們看

00:25:13.947 --> 00:25:18.318 
如何向她的小UI加一點疊加內容

00:25:19.253 --> 00:25:20.854 
那麼先想想

00:25:20.921 --> 00:25:21.822 
我們要捕捉哪裏

00:25:22.489 --> 00:25:23.957 
我們只要看到一個視覺效果

00:25:24.024 --> 00:25:26.426 
就知道我們需要捕捉的內容

00:25:26.860 --> 00:25:27.895 
我們將它從屏面移開

00:25:28.729 --> 00:25:30.330 
這樣我們就把這個小東西拷貝了出來

00:25:30.964 --> 00:25:33.233 
現在
它從屏面上下來了 我們可以用它了

00:25:33.300 --> 00:25:34.701 
但是我們爲什麼將它從屏面取下

00:25:35.102 --> 00:25:37.304 
好 有一個原因是我們需要確保

00:25:37.371 --> 00:25:39.139 
我們獲得正確的效果
而且在這種情況下

00:25:39.206 --> 00:25:41.275 
我們捕獲了我們需要用於模糊的所有一
切內容

00:25:41.341 --> 00:25:42.376 
爲了達到那種模糊效果

00:25:42.709 --> 00:25:44.077 
而且我們經常離屏做這些事情

00:25:44.144 --> 00:25:46.580 
這樣
我們就不會弄亂屏幕上已經做好的內容

00:25:46.647 --> 00:25:48.549 
當我們正在離屏做出這樣效果的時候

00:25:49.783 --> 00:25:51.518 
於是我們將這個模糊效果應用在它這裏

00:25:52.419 --> 00:25:54.354 
最後 我們把它複製回原來的位置

00:25:54.421 --> 00:25:55.856 
即效果視圖對它所要求的位置

00:25:56.823 --> 00:25:58.825 
而所有這些給了我們一個定義

00:25:58.892 --> 00:26:01.929 
它定義的是你以前可能已經聽說過的一
個東西 即所謂“離屏通過”

00:26:01.995 --> 00:26:05.465 
就是無論什麼時候我們獲得一個內容
我們將它複製到屏幕以外

00:26:05.866 --> 00:26:07.835 
做好後 再把它返回到屏幕上

00:26:09.336 --> 00:26:11.805 
那麼有什麼其他方法
我們可以得到“離屏通過”？

00:26:12.873 --> 00:26:14.007 
好
正如你所看到的

00:26:14.074 --> 00:26:15.275 
我們已經有了Alpha

00:26:15.542 --> 00:26:17.311 
而且你可以看到你做那種效果的方法

00:26:17.377 --> 00:26:18.946 
因爲如何你有一個複雜的視圖層次

00:26:19.179 --> 00:26:20.581 
其中需要Alpha

00:26:20.647 --> 00:26:23.217 
那麼我們就不能只把Alpha適用於
單個視圖

00:26:23.283 --> 00:26:24.551 
因爲你將得不到正確的效果

00:26:25.152 --> 00:26:28.155 
相反
我們需要獲得整個複雜的視圖層次

00:26:28.222 --> 00:26:31.391 
通過離屏獲得它渲染它
然後將Alpha應用到整個事情

00:26:32.025 --> 00:26:34.294 
遮罩在它的背後有一個非常相似的推理

00:26:34.361 --> 00:26:36.263 
在那個推理中我們需要將所有像素用於
遮罩

00:26:39.166 --> 00:26:42.336 
正如我們剛纔提到的
模糊和虛化也是通過離屏完成的

00:26:43.303 --> 00:26:44.872 
但快照不是 爲什麼是這樣呢？

00:26:44.938 --> 00:26:45.806 
你可能會問自己

00:26:46.573 --> 00:26:48.208 
嗯 首先 什麼是快照？

00:26:48.509 --> 00:26:51.345 
我們已經有了這兩種UIView方法
一種是在屏幕更新後

00:26:51.411 --> 00:26:53.614 
獲得屏幕快照
然後以矩形繪製出視圖層次

00:26:54.181 --> 00:26:57.150 
一種是UIScreen方法
即在屏幕更新後獲得快照視圖

00:26:57.651 --> 00:27:00.621 
而且所有這些都會把快照上的內容返回
給你

00:27:01.321 --> 00:27:03.857 
那麼 快照基本上是做同樣的事情

00:27:03.924 --> 00:27:06.960 
即如“離屏通過”做的一樣
但讓你能夠控制最後一個步驟

00:27:07.027 --> 00:27:08.195 
從而將內容複製回屏幕

00:27:09.263 --> 00:27:11.832 
我們獲得了所有你要求我們進行快照的
內容

00:27:11.965 --> 00:27:14.268 
對它進行離屏渲染
然後返給你一個視圖

00:27:14.334 --> 00:27:17.271 
或者代表那個圖像的像素內容

00:27:18.672 --> 00:27:20.974 
但是 再一次想問的是 這與確保

00:27:21.041 --> 00:27:22.509 
你的效果必須正確無誤有關嗎？

00:27:22.843 --> 00:27:23.677 
好

00:27:23.744 --> 00:27:27.114 
不幸的是如果你得到的視覺效果陷入了

00:27:27.181 --> 00:27:28.448 
這一點
正如你可以看到的

00:27:28.515 --> 00:27:29.983 
索̨菲亞已經
失去了她的模糊度

00:27:30.050 --> 00:27:32.886 
而這就是你在視覺效果完成後將在屏幕
上所看到的內容

00:27:33.120 --> 00:27:34.755 
視學效果是你離屏時所得到的

00:27:34.821 --> 00:27:36.223 
它是你事先沒有想到會遇到的

00:27:38.592 --> 00:27:40.527 
好
重新回到這裏

00:27:40.928 --> 00:27:43.130 
我敢肯定你們今年都已經
參加過多任務會議

00:27:43.197 --> 00:27:45.199 
如果沒有
你可以下課後看看它們的視頻

00:27:45.632 --> 00:27:48.101 
但在所有事情當中
即你需要啓動一個非常好的App

00:27:48.168 --> 00:27:49.503 
以參與多任務處理

00:27:49.570 --> 00:27:51.305 
其中關鍵的一點是屏幕上要有好的表現

00:27:51.371 --> 00:27:54.441 
因爲現在你的App的表現
也會影響到其他正在運行的App

00:27:55.042 --> 00:27:57.811 
所以 既然我們在這個特殊的例子中
沒有出現任何滾動

00:27:57.878 --> 00:28:01.048 
那麼我們就可以決定
讓我們不要一直保持對模糊進行渲染

00:28:01.114 --> 00:28:02.649 
讓我們只是爲它照一個快照好了

00:28:02.816 --> 00:28:06.320 
因此我們決定爲那個特殊的視覺效果圖
照一個快照

00:28:07.521 --> 00:28:11.658 
但隨後發生的事情是捕捉區域
是離屏完成的

00:28:12.092 --> 00:28:14.561 
而且由於你只快照了視覺效果圖

00:28:15.495 --> 00:28:17.331 
因此在捕捉區域上什麼也沒有

00:28:17.898 --> 00:28:21.068 
這樣一來捕捉區域什麼也沒帶給你
而且模糊功能也沒有可以模糊的

00:28:21.134 --> 00:28:23.003 
你得到的是你之前看到的被破壞的效果

00:28:24.037 --> 00:28:25.305 
所以 既然我們已經看到

00:28:25.639 --> 00:28:28.742 
你是如何破壞了你的效果
那我們能做些什麼來解決這個問題呢？

00:28:29.243 --> 00:28:31.111 
好了 第一件事就是

00:28:31.178 --> 00:28:33.747 
我們有了這個簡便的方法
即用於視覺效果圖上的方法

00:28:34.014 --> 00:28:35.449 
所謂的“這個效果怎麼了？”

00:28:43.357 --> 00:28:46.860 
就像使用動態調試標誌

00:28:46.927 --> 00:28:50.063 
在SDK中不是這樣的 但你可以

00:28:50.130 --> 00:28:51.765 
從調試器中調用它 就像這個一樣

00:28:52.432 --> 00:28:55.736 
你會得到一個字符串
看起來和這個有點像

00:28:56.270 --> 00:28:58.872 
在這種情況下
我們發現在層次結構上的某個地方

00:28:58.939 --> 00:29:01.642 
有一個遮罩視圖 它造成的視覺效果

00:29:01.708 --> 00:29:04.511 
需要在屏幕外來完成
因此無法捕獲儘可能多的

00:29:04.578 --> 00:29:06.280 
它所需要的內容
以便進行正確的渲染

00:29:07.848 --> 00:29:09.082 
那麼如何解決這一問題呢？

00:29:10.751 --> 00:29:12.953 
第一種方式
如果你使用的是Alpha

00:29:13.020 --> 00:29:15.489 
或者遮罩這項工作實際上是重新排列你
的視圖層次

00:29:15.622 --> 00:29:18.792 
我們在這裏所擁有的只是一些容器
或許窗口

00:29:19.026 --> 00:29:19.960 
和一個容器視圖

00:29:20.027 --> 00:29:22.162 
包含一個模糊和更多的內容

00:29:22.563 --> 00:29:24.631 
那麼
在這種情況下 模糊實際上並不需要

00:29:24.698 --> 00:29:26.733 
加入我們所擁有的Alpha或者遮罩

00:29:27.501 --> 00:29:30.637 
所以我們只是重新安排
以便將模糊作爲第一個子視圖

00:29:30.771 --> 00:29:33.273 
將容器作爲第二個子視圖
這樣一來容器

00:29:33.340 --> 00:29:35.609 
和它裏面的一切都將渲染於模糊的頂部

00:29:35.909 --> 00:29:38.378 
而且我們可以將Alpha或
遮罩適用於這個容器視圖

00:29:38.445 --> 00:29:39.479 
卻不會搞亂我們的模糊

00:29:40.948 --> 00:29:42.883 
我們能爲遮罩做的第二件事是

00:29:43.383 --> 00:29:45.686 
不是將容器視圖進行遮罩

00:29:46.620 --> 00:29:47.855 
而且我們可以將那個遮罩

00:29:48.021 --> 00:29:51.091 
向下移動到我們實際上需要遮罩的內容
上

00:29:51.959 --> 00:29:53.260 
現在 正如我們前面所提到的

00:29:53.327 --> 00:29:54.995 
遮罩往往會採取“離屏通過”

00:29:55.195 --> 00:29:56.697 
所以你在做這樣的轉換時

00:29:56.763 --> 00:29:58.131 
應該非常地小心謹慎

00:30:00.667 --> 00:30:02.736 
最後
通過快照 正如我們前面提到的

00:30:02.803 --> 00:30:05.072 
快照只會捕獲你告訴它需要做的

00:30:05.672 --> 00:30:06.773 
所以
在這種情況下

00:30:06.840 --> 00:30:09.910 
我們要求快照的內容視
圖中 有一定的透明度

00:30:09.977 --> 00:30:11.678 
這樣
我們就可以看到它背後的東西

00:30:11.745 --> 00:30:14.715 
但是如果我們只快照了那個視圖
那麼我們在模糊中將得不到透明度

00:30:14.781 --> 00:30:16.116 
它會看起來有點滑稽

00:30:16.550 --> 00:30:18.352 
因此 當我們一直向上移動快照時

00:30:18.418 --> 00:30:20.621 
窗口通常是最容易做的事情

00:30:21.221 --> 00:30:23.357 
但有時你可能需要
一直將它向上移動到屏幕上

00:30:23.924 --> 00:30:25.993 
所以
如果你要快照模糊 你應該確保

00:30:26.059 --> 00:30:28.428 
你在快照時儘量遠離模糊內容

00:30:28.495 --> 00:30:30.998 
以確保你得到你所需要的
一切

00:30:32.666 --> 00:30:35.936 
然後有了這些
讓我們轉到有關動態和自動佈局的

00:30:36.003 --> 00:30:37.371 
一些最佳做法

00:30:41.341 --> 00:30:42.776 
所以
你可能要做的第一件事是

00:30:42.843 --> 00:30:44.745 
你可能需要
使相當複雜的

00:30:44.811 --> 00:30:46.847 
視圖層次在動態系統內發生作用

00:30:47.915 --> 00:30:50.150 
而你想要的是使外部視圖加入

00:30:50.217 --> 00:30:52.686 
動態系統而不是內部視圖

00:30:52.753 --> 00:30:53.787 
它們的佈局將正如

00:30:53.854 --> 00:30:55.822 
你用其他內容所做的佈局的一樣

00:30:56.056 --> 00:30:59.760 
所以 你可以將UIKit
Dynamics用於外部視圖

00:30:59.960 --> 00:31:02.462 
這隻需要將
“自動調整遮罩大小轉變爲約束”

00:31:02.529 --> 00:31:03.931 
變爲“真”即可

00:31:04.097 --> 00:31:06.300 
是的在WWDC中唯一的幻燈片裏
講的是“真”

00:31:09.169 --> 00:31:10.737 
然後你就可以使用“自動佈局”

00:31:10.804 --> 00:31:12.506 
將所有其他的東西正好放置於視圖裏面

00:31:12.573 --> 00:31:14.675 
就像你經常做的一樣
或者使用新的句法

00:31:14.741 --> 00:31:15.976 
即如幻燈片上所顯示的一樣

00:31:17.411 --> 00:31:20.247 
你可以做的另一件事是
你在動態系統裏經常會有

00:31:20.314 --> 00:31:23.483 
各種項目
但你可能對它們作了標記

00:31:23.550 --> 00:31:25.819 
它們不應該參與 但需要跟隨

00:31:26.253 --> 00:31:28.522 
所以在這裏Lola有她的小標籤

00:31:28.856 --> 00:31:31.458 
上面寫了文件名是什麼
而我們只有這個錨點

00:31:31.525 --> 00:31:33.427 
它代表了我們的自動佈局約束

00:31:33.794 --> 00:31:36.830 
然後當動態圖起作用並準備四處移動L
ola時

00:31:37.030 --> 00:31:39.533 
標籤也跟着一起動 但標籤最終不會

00:31:39.600 --> 00:31:41.001 
與動態圖有互動

00:31:43.036 --> 00:31:45.472 
最後你可以使用動態圖來操作

00:31:45.539 --> 00:31:47.307 
其方法是創建一個自定義動態項目

00:31:47.441 --> 00:31:48.675 
正如麥克前面所提到的

00:31:49.843 --> 00:31:51.545 
你只需要將
NSObject劃入子類

00:31:51.612 --> 00:31:53.580 
或者其他適當的對象類

00:31:55.048 --> 00:31:57.084 
只要符合UI動態項目協議

00:31:58.151 --> 00:31:59.753 
並提供了所需要的方法

00:32:00.654 --> 00:32:02.222 
對於Bounds 有的尺寸...

00:32:02.289 --> 00:32:04.791 
它不能是“00”
或者動態系統準備

00:32:06.193 --> 00:32:08.262 
拋出一個異常...
然後你執行居中和轉換

00:32:08.362 --> 00:32:10.764 
並按順序使用這些數值

00:32:10.831 --> 00:32:12.999 
以構建自動佈局約束

00:32:13.233 --> 00:32:15.335 
或者改變你係統外部的一些東西

00:32:16.470 --> 00:32:19.373 
然後關閉 我們將給你一個演示
你也可以做到這樣

00:32:25.812 --> 00:32:27.247 
所以我們這裏得到的是什麼？

00:32:28.248 --> 00:32:30.017 
對 同剛纔一樣
是一個簡單的應用程序

00:32:30.250 --> 00:32:31.585 
它剛剛顯示了一張照片

00:32:31.652 --> 00:32:34.054 
但是
我們希望能夠以某種風格向用戶展示

00:32:34.121 --> 00:32:35.789 
照片里人的面部

00:32:36.056 --> 00:32:37.324 
所以
當我們點擊

00:32:37.391 --> 00:32:39.993 
我們的動態項目時系統就
會伸出

00:32:40.060 --> 00:32:41.395 
並且在那個模糊中出現動畫

00:32:42.129 --> 00:32:43.830 
如果你再次點擊 當然 它的移動

00:32:43.897 --> 00:32:45.432 
會出現更好一點的效果

00:32:46.433 --> 00:32:49.036 
但是如果你繼續點擊 你就可以看到

00:32:49.102 --> 00:32:51.638 
它在動態系統上的反應非常流暢

00:32:52.306 --> 00:32:54.741 
並且不具有非常固定的、僵硬的路徑

00:32:55.475 --> 00:32:58.879 
所以它對於用戶正在做的動作做出恰好
的反應

00:32:59.713 --> 00:33:01.148 
那麼 我們是如何做到這個的？

00:33:02.449 --> 00:33:03.884 
所以
我們做的第一件事是

00:33:03.951 --> 00:33:05.485 
我們使這個面部
執行佈局嚮導

00:33:06.019 --> 00:33:07.988 
這正好是UI佈局嚮導的一個子類

00:33:08.288 --> 00:33:11.391 
而在它的內部是一點點的動態

00:33:11.825 --> 00:33:14.561 
我們將這個面部佈局嚮導執行動態項目
也就是再一次

00:33:14.628 --> 00:33:17.431 
將NSObject劃入子類
並符合UI動態項目

00:33:18.265 --> 00:33:19.900 
並且它將管理一個約束

00:33:20.300 --> 00:33:24.037 
然後通過將該約束的常數
設置爲中心點的x值

00:33:24.104 --> 00:33:27.407 
或y值 不管該約束是如何變化的

00:33:30.043 --> 00:33:33.680 
在這裏 當你設置佈局嚮導時

00:33:34.014 --> 00:33:35.582 
它就會得到一箇中心位置

00:33:35.849 --> 00:33:38.385 
並且創建了四個額外的動態項目

00:33:38.652 --> 00:33:40.354 
在系統中表示上、左、下

00:33:40.420 --> 00:33:41.955 
和右

00:33:43.156 --> 00:33:45.259 
我們將它分配到約束
而約束剛好從動態項目的

00:33:45.325 --> 00:33:47.861 
左上角發生作用

00:33:48.495 --> 00:33:50.597 
以及從動態項目參考視圖

00:33:51.565 --> 00:33:54.067 
而我們使用滑塊附件以限制

00:33:54.134 --> 00:33:56.103 
這四個動態項目相對於該位置

00:33:56.170 --> 00:33:57.237 
可以去的範圍大小

00:33:57.638 --> 00:33:59.973 
這可保證它避免飛到系統外

00:34:00.040 --> 00:34:01.909 
或者摺疊到一個過小的位置

00:34:03.911 --> 00:34:05.045 
現在 在視圖控制器裏

00:34:05.112 --> 00:34:08.014 
我們得到這種行爲的方式
是我們有一個

00:34:08.081 --> 00:34:09.416 
沿着面部佈局嚮導的重力行爲

00:34:09.483 --> 00:34:10.817 
然後在彼此的頂部將它們居中

00:34:10.884 --> 00:34:12.351 
因此當重力發生變化時

00:34:12.418 --> 00:34:13.954 
佈局嚮導將會適當地移動

00:34:15.188 --> 00:34:17.090 
我們從故事板中得到模糊效果

00:34:17.157 --> 00:34:18.792 
這樣我們不必不斷地擺弄它

00:34:18.859 --> 00:34:21.195 
如果我們決定要改變我們使用的風格

00:34:22.829 --> 00:34:26.099 
我們使用約束將那個模糊視圖

00:34:26.366 --> 00:34:27.568 
附加到面部佈局嚮導上

00:34:27.900 --> 00:34:29.803 
因此 當此嚮導改變了尺寸

00:34:29.870 --> 00:34:31.538 
模糊視圖也會隨之改變

00:34:33.005 --> 00:34:35.842 
現在
爲了使它看起來像是模糊視圖切割了

00:34:35.909 --> 00:34:38.411 
除面部以外的所有東西
對此我們確實有一個小竅門

00:34:38.679 --> 00:34:40.813 
我們做了一個原始圖像的頂替圖像

00:34:40.981 --> 00:34:44.284 
剛好切出我們需要的圖像
給它們一個遮罩

00:34:44.618 --> 00:34:47.754 
並創造更多的UI圖像視圖放置於

00:34:47.821 --> 00:34:48.956 
已經在那裏的視圖的頂部

00:34:49.456 --> 00:34:52.125 
所以它看起來好像模糊剛好遮擋着面部

00:34:52.192 --> 00:34:54.194 
但實際發生的事情是
你所看到的視圖

00:34:54.261 --> 00:34:56.830 
被放置在頂部
而面部從它們上面切除

00:34:58.465 --> 00:35:01.368 
最後 我們對這個視圖
點擊我們設置的手勢識別器

00:35:01.435 --> 00:35:04.438 
得到的正好是
使我們的動態系統發生改變的東西

00:35:06.206 --> 00:35:08.141 
當我們要暴露面部時

00:35:08.475 --> 00:35:09.743 
我們只需要改變重力就可以

00:35:09.810 --> 00:35:13.046 
所以重力通常是造成一切被拉向
中心的原因

00:35:13.347 --> 00:35:16.650 
但當我們打開它時
它像一個反重力一樣想推開一切東西

00:35:18.385 --> 00:35:19.653 
然後我們利用以下這個事實

00:35:19.720 --> 00:35:21.822 
即我們通常在這個過程中
始終佈局子視圖

00:35:22.189 --> 00:35:24.758 
以實際地觸發模糊動畫進入或退出

00:35:25.792 --> 00:35:29.162 
而所有這些都是爲了建設
這個非常好的效果

00:35:29.363 --> 00:35:33.300 
我們所依靠的是自動佈局
和動態都可以很容易地提供給你

00:35:33.967 --> 00:35:35.736 
至此我們將回到幻燈片來做一個結束

00:35:39.373 --> 00:35:40.674 
總而言之

00:35:41.675 --> 00:35:45.279 
我們希望你能夠使用這些技術
以真正地改善用戶體驗

00:35:45.746 --> 00:35:47.915 
所以 當你添加一個模糊
你添加了它

00:35:47.981 --> 00:35:51.985 
這樣你就可以通過其他的信息
來彌補你的內容

00:35:52.319 --> 00:35:53.453 
當你使用動態

00:35:53.520 --> 00:35:56.990 
你可以有一個反應剛剛好的用戶界面

00:35:57.057 --> 00:35:59.226 
並且正如用戶對他們輸入內容
的期待一樣

00:35:59.993 --> 00:36:02.629 
但是你也需要考慮到表現
當你在做這些事情時

00:36:02.996 --> 00:36:05.432 
因爲如果你有很多在屏幕上的動態項目

00:36:05.499 --> 00:36:07.501 
它們能夠使用戶界面真正陷入困境

00:36:07.835 --> 00:36:10.204 
而且你不會得到你所期待的的物理現象

00:36:10.537 --> 00:36:11.872 
所以請謹慎地使用

00:36:13.040 --> 00:36:15.576 
而且對於視覺效果
如果你有很多這樣的效果

00:36:15.642 --> 00:36:17.544 
你最終將有很多“離屏通過”

00:36:17.711 --> 00:36:19.446 
並且這也會招致相當高的成本

00:36:21.748 --> 00:36:24.284 
這些都是與課程相關的內容
這是我們今天爲你準備的

00:36:24.518 --> 00:36:26.954 
不幸的是其中大部分都在之前發生過

00:36:27.187 --> 00:36:29.523 
僅有一個沒有發生
而且是與我們一起出現的

00:36:29.590 --> 00:36:31.892 
即所謂
“通過GCD建立響應和效率的App”

00:36:33.060 --> 00:36:35.562 
而且我們在此之後將在實驗室裏回答
你的所有問題

00:36:35.629 --> 00:36:38.632 
並幫助你避免出現
你這一年遇到的大部分情況

00:36:40.801 --> 00:36:42.503 
我們已經有了各種文檔

00:36:42.769 --> 00:36:46.139 
以及你以前在演示中看到的
用於StickyCorners樣本的組裝代碼

00:36:46.206 --> 00:36:47.341 
將會提供給你

00:36:47.908 --> 00:36:50.677 
而且 當然 寇特·羅斯特
將通過電子郵件回答大家的提問

00:36:51.979 --> 00:36:53.780 
我很高興你們在週五
堅持與我們一起學習

00:36:53.847 --> 00:36:56.550 
我希望你擁有一個偉大的WWDC
並祝大家一路平安