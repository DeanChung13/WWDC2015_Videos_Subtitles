面向協議 編程序Swift
大家好 我叫戴夫·亞伯拉罕我是Swift標準庫的技術主管
今天站在這裏同你們一起是我的榮幸
很高興看到房間裏的你們
接下來的40分鐘請
丟掉你們通常思考編程的方式
我們接下來要一起做的事情不一定容易
但我向你們保證如果你們跟着我的思路這一定是值得的
我現在來和你們談一談
Swift設計核心的主題並介紹一種編程方式
這種編程方式有可能改變一切
但首先請允許我先向你們介紹我的一位朋友
他是 Crusty
現在可能你們每個人都正在使用這個傢伙的某一個版本
Crusty是個老式的程序員
他不相信調試器不使用集成開發環境
不 他喜歡 80x24的終端窗口
和純文本 非常感謝
他對最近的編程時尚不以爲然
現在我已經學會期待 Crusty 
有點憤世嫉俗脾氣古怪
但是即便如此有時仍會令我驚訝
比如上個月我們正在討論應用開發
他坦率地說“我不做面向對象”
我不敢相信我的耳朵
我的意思是面向對象程序設計
大約起源於20世紀70年代
所以它並不能算是新奇的編程時尚
此外我們一起構建的很多神奇的東西 我 你 還有那些
我們所站在其肩膀上的工程師們都由對象構建而成
“來吧”我邊走向他的老式黑板邊說
“面向對象程序設計棒極了看看你可以使用類做些什麼”
是的
所以首先你可以把相關數據和操作進行分組
然後就可以建造牆壁將我們的代碼內外
分開這樣就可以使我們保持不變量
然後我們使用類來表達相關想法如窗口或通信信道
它們給我們一個命名空間用於幫助避免隨着軟件擴展所帶來的衝突
它們有驚人的表達語法
所以我們可以寫方法調用和屬性並把它們鏈接起來
我們可以做下標
我們甚至可以做屬性用於計算
最後類的擴展性是開放的
所以如果類作者遺漏了一些我需要用到的東西
我可以繼續向前並在後續將其添加上
此外這些事物一起
這些事物使我們能夠管理複雜的事物
而這正是程序設計中最主要的挑戰
這些屬性它們直接解決了我們正在努力解決的軟件開發中的問題
在這一點上我自己頗受啓發
然而 Crusty只是哼了一聲嘆了口氣
他讓我十分泄氣
如果這還不夠糟糕的話片刻之後他完成了這個句子
因爲這是真的在Swift
任何一種你可以說出的類型都是一等公民
它能夠利用所有這些功能
所以我後退了一步並試圖
找出使我們完成的所有事情運行的核心功能在面向對象程序設計中
很顯然它一定是來自於只能用類來處理的某些事物
比如繼承
這讓我特別考慮
這些結構是如何做到代碼共享
及細密定製的
因此，舉個例子一個超類可以定義一個實質的具有複雜邏輯的方法
而子類無償得到超類已完成的所有工作
它們只是繼承了這些內容
但真正不可思議的事發生在當超類的作者
把這個操作的一小部分斷爲
獨立的定製點
這些定製點可被子類覆蓋
且這種定製被覆蓋在繼承的實現上
這使得困難的邏輯
在具備開放的靈活性和特殊變化的同時可被重新使用
現在我確信我可以說服他
“哈”我對 Crusty 說
“很顯然現在你不得不臣服於類的力量了”
“再堅持該死的一分鐘”他回答說
“首先我用你一直說的結構做定製
其次 對 類是很厲害但讓我們來談一談用類所需要的代價
我已經有三個重要的關於類的牢騷”Crusty 說
然後他從列表上開始了抱怨
“首先你有了你的自動共享”
現在你們都知道這是什麼樣子的
A傳遞給B一些看起來完全清晰的數據
然後B想“好 會話結束”
但現在我們有一種情形
A和B都有他們自己非常合理的世界觀而這恰好是錯誤的
因爲現實是這樣的 最終A厭惡了
嚴肅的數據取而代之喜歡小馬
誰不喜歡一匹好的小馬？
一切都很好直到B之後發現了這些數據
很久之後她從A那裏得到
且已有一個令人吃驚的變化
B 想要的是她的數據而不是 A 的小馬
好 Crusty 激昂地講着這是如何結束的
“首先”他說“你開始瘋狂地複製一切
鎮壓你代碼中的錯誤
但現在你現在做了太多的副本
而這拖慢了代碼的運行速度
然後有一天你正在處理某個調度隊列中的事情
突然你進入了一種紊亂狀態下
因爲線程正在共享可變狀態
所以你開始添加鎖以保護不變量
但是這些鎖更加拖延了代碼的運行速度
甚至可能導致死鎖
所有的這些都在增加複雜度
其結果可總結爲一個詞 故障”
不過這些對於Cocoa的程序員來說都不是新聞
這不是新聞這些年我們已經在應用一種語言特徵的組合
像@property(copy)和編碼約定
來解決這個問題
而我們仍然被咬
舉個例子
在Cocoa文件中有這樣一個警告
關於修改一個可變集合在你通過它進行迭代時
對吧 所有這些都是由
從類中繼承的可變狀態的隱式共享導致的
但這並不適用於Swift
爲什麼不適用呢？這是因爲Swift集合都是數值類型
所以你正在迭代的這些
和你正在修改的這些是截然不同的
好 Crusty 列表上的第二條
類繼承太具有侵入性
首先 它太龐大你有且僅有一個超類
那麼假使你需要塑造多個抽象將會怎樣？
可以是一個集合並序列化嗎？
當然 除非集合和序列化是類
因爲類繼承是單繼承
類變得臃腫隨着所有相關的事情被放在一起
你也不得不選擇超類在你定義類時而非在後續某些擴展時
其次如果超類存儲了屬性
你必須接受它們
並且別無選擇
然後因爲它存儲了屬性
你必須將其初始化
然後就像 Crusty 所說“指定便利是必須的 噢天哪”
因此你又必須確信你理解如何
與超類相互作用而不破壞它的常量
對嗎 最後對於類作者來說這很自然
寫代碼就好像他們知道他們的方法
將會做些什麼 不用對方法可能被覆蓋負責任
因此經常有至關緊要卻有不成文的約定
關於哪些實際是允許
覆蓋的以及比如你是否需要鏈接到超類方法
如果你要鏈接到超類方法
那麼位置是在方法的開頭還是在結尾抑或是在中間的某處呢
所以，再一次對於Cocoa的程序設計員來說仍然不是新聞 對嗎
這就是爲什麼我們到處使用委託模式在Cocoa
好 Crusty 列表上的最後一條
類被證明完全不適合於類型關係很重要的問題
所以如果你曾經嘗試過使用類
來表達一個對稱操作比如比較你知道我的意思
舉個例子假設你打算寫通用分類
或二進位檢索類似這樣你需要一種方法來比較兩個元素
使用類你最終得到像這樣的一些結果
當然你不能用這種方法只寫Ordered
因爲Swift會預先要求方法體
那麼我們可以放些什麼呢？
請記得我們對於Ordered的任意示例還一無所知
所以如果這個方法沒有由子類實現
那麼除了陷阱我們什麼都做不了
現在這是表明我們可以對抗類型系統的第一個跡象
如果我們沒有認識到這一點
這也是我們欺騙自己的開始
因爲我們對這個問題置之不理告訴自己
只要每個Ordered子類
預先執行一切都會好的
對嗎？讓它成爲子類的問題
如此我們繼續進行執行Ordered的一個例子
所以這就是子類
它得到一個雙精度類型值
我們覆蓋優先來做比較
當然除去它不起作用的情況
看“其它”只是某些任意的Ordered
不是一個數字因此我們不知道
“其他”有數值屬性
事實上它可能是個標籤
具有文本屬性
所以現在我們需要向下轉型以得到正確的類型
但是等一下假設“其它”結果是一個標籤？
現在我們將要陷阱
對嗎 所以這聽起來很像
我們在預先寫方法體時遇到的問題在超類中
並且我們現在沒有比之前更好的答案
這是靜態類型安全漏洞
它爲什麼會發生？
這是因爲類不讓我們表達這種至關緊要的類型關係
自身的類型和其他的類型之間的關係
事實上你可以把這個用作“代碼異味”
所以任何時候你在代碼中看到強制的向下轉型
這很好地象徵了有些重要的類型關係已經丟失
而這通常是由於抽象類的使用所造成的
好 顯然我們需要的是更好的抽象機制
不強制我們接受隱式共享
不丟失類型關係
不強制我們只選擇一種抽象且
在定義類型時進行選擇
不強制我們接受不想要的實例數據
以及相關的初始化複雜度
最後不會留下模棱兩可關於需要覆蓋什麼
當然我正在講述的便是協議
協議有所有這些優勢這就是爲什麼
我們創造Swift時也就是我們創造第一個面向協議的程序設計語言
是的 Swift是很棒的面向對象程序設計
但從循環和字符串的工作方式
到泛型標準庫的重點
其核心Swift是面向協議的
希望到你離開時
你可以更加面向協議
所以爲使你邁出右腳開始
我們在Swift有一種說法
不要從類開始
而要從協議開始
那麼讓我們來做一下上一個例子
好 首先我們需要一個協議Swift馬上會說
我們不可以在這兒放方法體
而這實際上是很好的因爲這意味着
我們要以動態運行時間檢查換
靜態檢查
對 在完成時預先執行
好 接下來它會說我們沒有覆蓋任何東西
當然我們沒有
我們不再有基類 對嗎
沒有超類 沒有覆蓋
我們可能根本不希望數字首先是類
因爲我們希望它像數字一樣操作
對嗎 那麼讓我們馬上來做兩件事情把這做成一個結構
好 我想在這兒暫停一下
欣賞一下我們現在來到何處因爲這又是完全有效的代碼了
好 協議正完全扮演着相同的角色
就像在我們這個例子的第一個版本中類的角色一樣
這絕對更好
我的意思是我們不再有那致命的錯誤
但是我們沒有定位潛在的靜態類型安全漏洞
因爲我們仍然需要強制的向下轉型
因爲“其他”仍然是某些任意的Ordered
那麼讓我們用數字替代丟掉類型轉換
現在Swift要說簽名不匹配
爲解決這個問題 我們需要在協議簽名中用Self來替代Ordered
我們稱之爲Self要求
因此當你在協議中看到Self
它是類型的佔位符用來符合那個協議模型類型
如此現在我們又有了有效的代碼了
現在讓我們看一下如何使用協議
所以這是二進位檢索
它也能夠完美運行在我們向Ordered加入Self要求之前
這裏的Ordered數組是一個聲明
聲明我們要處理Ordered類型的異構數組
因此這個數組可以混合包含數字
與標籤 對吧
由於我們對Ordered做了這個改變
向其添加了Self需求編譯器將
強制將其變爲同構的 像這樣
這個人說“我在使用任意一個Ordered類型T的同構數組”
現在你可能會想強制使數組
成爲同構數組這太限制了 
或者有些失去了泛函性或靈活性或其他
但是如果你想一下
原始的簽名真的是個謊言
我們從沒真正處理過異構情況除了通過陷阱的方式
對吧 同構數組正是我們要的
那麼一旦你在協議中添加Self要求
這將使協議進入一個非常不同的世界
在這裏功能中大大減少了類的重複
它不再作爲類型使用
集合從異構變爲同構
實例之間的相互作用不再意味着所有模型類型之間的相互作用
我們以動多態換靜多態
但是作爲我們傳遞給編譯器的額外的類型信息的回報
這樣更具可優化性
所以 兩個世界
在後續的演講中我將向你們演示如何
在兩者之間搭橋至少一種方式
好
我理解了協議靜態方面的工作原理
但我還不確定是否要相信Crusty
協議真的可以取代類
所以我給他設了一個挑戰
構建我們通常使用面向對象程序設計的事物但是要用協議
我腦海中浮現一個小的圖表應用
你可以在繪圖界面拖拽落成形狀然後可以與它們交互
所以我讓 Crusty 構建文檔並顯示模型
這是他想出來的
首先他構建了一些基本繪圖
現在你可以想象
Crusty並不是在做圖形用戶界面
相較而言他更傾向文本
他的基本繪圖只是輸出了你提出的繪圖命令 對嗎？
我不情願地承認了這很可能足以
證明他的觀點然後他新建了Drawable協議
爲我們的所有繪圖元素提供通用接口
好 這很簡單了
然後他開始創建形狀比如多邊形
現在這裏需要注意的第一件事關於多邊形這是一個數值類型
由其他數值類型創建而成
這是一個包含多點數組的結構
爲了畫一個多邊形我們來到最後一個拐角
然後我們在所有交角處重複循環 畫線
好 下面是圓
同樣的圓也是一個數值類型由其他數值類型創建而成
它是包含中心和半徑的結構
現在爲了畫一個圓
我們從0到2π弧度拽出一個弧形
那麼現在我們就可以通過圓和多邊形來創建圖表了
“好的” Crusty 說“我們來將她做個旋轉”
他這麼做了
接下來就是圖表
圖表就是一個Drawable類這是另一個數值類型
它爲什麼是數值類型呢？這是因爲所有Drawable類都是數值類型
因此Drawable類的數組也是數值類型
讓我們回到之前的話題
好 這裏
因此由於這是我的圖表中唯一的事物這個圖表也是數值類型
因此要繪製它我們只需要遍歷所有
元素並畫下來每一個元素
好 現在來作一個旋轉
那麼 我們要測試一下
所以Crusty新建了一個圓
以非常特別的中心和半徑
然後以神祕的Spock一般的精度
他添加了一個三角形
最後他在其周圍創建了一個圖表並讓它繪製
“瞧”Crusty 耀武揚威地說
“就像你能明白地看到的這是一個帶圓的等邊三角形內切於圓”
也許我不擅長在腦海中做三角學問題
不像 Crusty 那樣但是“不 Crusty ”我說
“我不能很明白地看到這些
我會覺得這個延時更加有趣
如果我做一些實際有用的
比如給我們的應用 畫到屏幕上”
我從煩惱中恢復過來之後
我決定使用CoreGraphics重寫渲染器
我告訴他我將要做這些
他說“再等一會兒猴小子
如果你這樣做了我還怎樣測試我代碼呢？”
然後他展現了一個很有說服力的案例
在測試中使用純文本
如果我們正在做的事情中發生了某些改變
我們可以立馬在輸出中看到
然而他提出我們做一點
面向協議的程序設計
然後他複製了他的渲染器然後將其寫入協議中
然後你必須刪除主體 好
這就是了 然後他重命名了原始的渲染器並將它改爲一致
現在 所有的代碼重構使得我變得不耐煩
因爲我很想在屏幕上看到這些東西
我想搶過來實現CoreGraphics的渲染器
但我必須等到Crusty 再次測試他的代碼
等到他終於滿意了他說“好了
你打算在渲染器中放些什麼呢？”
我說“一個CGContext
CGContext基本有渲染器需要的一切”
實際上在純C語言接口範圍內
它基本就是一個渲染器
“好” Crusty 說“把鍵盤給我”
他從我這兒奪去某樣東西然後
極快地做了某些事情太快以至於我都沒有看到做了些什麼
“等一下”我說
“你剛剛只是把每個CGContext寫入渲染器嗎？”
他...我是說它什麼也沒做
但是這有些令人吃驚我甚至不需要添加一種新的類型
“你還在等什麼？Crusty說
“在那些大括號中填入內容”
所以我把必要的CoreGraphics粘着都倒了進去
把所有都扔進了遊戲場 這就是了
現在你可以下載這個遊戲場
它演示了我在這兒演講的所有內容
在我們結束之後
不過還是回到我們的例子
爲了幹擾我Crusty之後做了這些
現在我需要花一點時間瞭解爲什麼繪製
在這個點上沒有進入無線循環
如果你想了解更多的話
你可以聽一下週五的講習會
但這也並沒有改變顯示
最終Crusty決定向我演示正在發生的事情
在他的純文本輸出中
然後事實證明它只重複了相同的繪製命令
兩次
所以作爲一個更面向圖形的傢伙
我很想看到結果
所以我創建了一個小比例的適配器並用它包裹住圖表
這就是結果
你可以在遊戲場看到這些所以我不打算在這兒深究小比例適配器
不過這也是一種
使用協議的演示我們可以做到所有
與使用類可以做到的相同的事情
適配器通常設計模式
好 現在我想反思一下
使用TestRenderer都做了些什麼
因爲它事實上是有些傑出的
通過從特定的渲染器中解耦文件模型
他能夠插入檢測組件
以顯示我們正在做的一切我們的代碼正在做的一切詳細地
後來我們就在我們的代碼中應用了這種方法
我們發現我們使用協議解耦的事物越多
所有的事物的可測性就越強
這種測試與
使用mock測試得到的結果很像但這樣做更好
mock測試本質上是脆弱的
你需要結合測試中的代碼
測試代碼的實現細節
正因這種脆弱性它們無法與
Swift 強大的靜態類型系統很好地融合
協議給我們提供了有原則的接口
以供使用這由語言進行實施
但仍會給我們hook以插入所有我們所需要的檢測設備
好 回到我們的例子因爲我們現在需要認真地
討論一下Bubbles
好我們希望這個圖表應用受孩子們的歡迎
當然孩子們喜歡Bubbles(氣泡)
因此在圖表中Bubbles只是一個內部圓圈偏移量
圍繞外圍圓圈中心
以此來表現加亮區
所以你有兩個圓
就像這樣
當我把這段代碼放到上下文
Crusty 開始變得很激動
所有的代碼副本都使他抓狂
如果 Crusty 不高興那麼沒有人可以高興
“瞧 他們都是完整的圓”他喊道“我只想寫這段”
我說“冷靜Crusty冷靜
我們可以這麼做
我們需要做的就是再添加一個協議的要求
然後當然我們更新模型來供應它
我們有測試渲染器
然後還有 CGContext”
現在這個點上Crusty 脫掉了鞋子
拿它敲着桌子因爲這裏我們又一次在重複代碼
他從我這裏把鍵盤奪了回來抱怨着
說所有的事情都需要他自己完成
他開始教我使用Swift的一個新特徵
這就是協議擴展
據說“渲染器的所有模型
都有circleAt的這個實現”
現在我們有一種實現渲染器的所有模型都在共享這種實現
注意到我們仍有這個circleAt 要求在那裏
你可能會問“有要求意味着什麼？
這個要求也可以在擴展中立即實現”
很好的問題
答案是協議要求新建定製點
爲了見證這是如何表現的讓我們先推翻這種方法體
而在擴展中添加另一種方法
添加一種不被要求支持的方法
現在我們可以擴展Crusty的 
來實現這兩個方法
然後我們只需要調用它們
好 現在發生的事情完全不會令人吃驚
我們直接調用TestRender中的實現
而協議並沒有參與其中 對吧？
如果我們刪除這種一致性我們將得到相同的結果
不過現在我們修改下上下文
這樣Swift就只知道它是一個渲染器而不是 TestRenderer
來看一下發生了什麼
所以因爲circleAt是要求
我們的模型獲得了定製它的特權
然後定製被調用
那個
但是rectangleAt不是要求
所以TestRenderer中的實現
只覆蓋到協議和上下文
你只知道有渲染器而非TestRenderer的時候
協議實現被調用
這有點奇怪 不是嗎？
那麼 這是否意味着rectangleAt應該是要求？
也許在這種情況下它應該
是因爲有些渲染器非常有可能
有更有效的方式來畫矩形
與座標系相配合
但是 協議擴展中的所有事物是否也是由要求支持的呢？
不一定
我是說有些應用程序界面並不打算作爲定製點
所以有時正確的解決方法是
只覆蓋到模型中的要求
而不要覆蓋到模型中的方法
那麼這種新特徵偶然地變革了我們在Swift標準庫上的工作
有時我們使用協議擴展所做的事情
感覺很神奇
我真心希望你們可以享受使用最新的庫進行工作
就像我們享受應用這些到庫
以及更新庫一樣我想先撇開我們的故事
這樣我就可以向你們展示我們使用協議擴展在標準庫上做的一些事情
還有一些其他的技巧
首先來講一下新的indexOf方法
這個方法遍歷集合的指針
直到它找到與我們正在查找的相等的元素
然後返回這個指針
如果它沒有找到結果那麼返回空
非常簡單對吧？
但是如果我們這樣寫就會有一個問題
一個任意集合的元素
不能對等地比較
因此爲了解決這個問題我們可以約束擴展
這是這個新特徵的另一方面
所以這麼說擴展應用於集合元素類型是Equatable時
我們已經給Swift傳遞了它所需要的信息以允許等式比較
現在我們已經看到了
約束擴展的一個簡單示例讓我們重溫一下二進位檢索
我們將其應用到整型數組上
好 整型不符合Ordered類
這是一種簡單的解決辦法
我們只要添加一致性
好 那對於字符串又會怎樣呢？
當然 這對字符串並沒有用所以我們再做一次
現在在Crusty開始敲桌子之前我們很想分析出其中原因
小於運算符出現在
Comparable協議中所以我們可以在
Comparable協議中操作
像這樣
現在我們正在預先提供那些一致性
所以一方面這是很好的
如果我想對雙精度數據進行二進位搜索
我所需要做的就是添加這個一致性我可以這麼做
另一方面這有些討厭
因爲即使我去掉一致性
我還是有這個被雙精度獲得的優先函數
它已經有了足夠的接口 對嗎？
我們可能想要更加有選擇性地在雙精度數值上添加東西
所以即使我可以這樣做
我不能用它來進行二進位檢索所以這些優先函數真的沒有給我買入任何東西
幸運的是我可以對哪些東西獲得優先函數應用程序界面更有選擇性
通過使用Ordered的約束擴展
所以這就是說一個是Comparable的類型並被聲明
爲Ordered將能夠自動地滿足優先要求
而這正是我們想要的
抱歉 但我覺得這很酷
我們有了同樣的抽象
同樣的邏輯抽象來自於兩個不同的地方
而我們已經使它們無縫協作
謝謝你們的掌聲 不過我只是我覺得這很酷
好 做好準備來一個味蕾清新劑了嗎？
這顯示它起作用了
好 這是一個完全通用的二進位檢索的簽名
作用於任意一個集合
帶有適當的索引和元素類型
現在我已經能聽到你們在那兒越來越不舒服了
我並不準備在這裏寫主體
因爲這已經看起來很糟糕了 對吧
Swift 1有很多像這樣的通用免費函數
在Swift 2中我們像這樣使用協議擴展將它們
變爲方法 這很棒
現在每個人都專注於在這個調用站點的改善
它現在很明顯地充滿了
方法的精華
但隨着這個傢伙寫二進位檢索
我因其簽名而愛上了它所做的事情
通過分離情況這些情況下該方法應用於
聲明的其餘部分
現在讀起來只是一個常規方法
不再有尖括號盲區
非常感謝
好 在我們回到我們的故事前來講一下最後一個技巧
這是一個包含最小模型的遊戲場
關於Swift的心OptionSetType協議
它就是一個結構具有隻讀整型屬性
叫做rawValue
現在來看一下一旦你昨晚即可免費得到的廣泛設置界面
所有這些都來自於協議擴展
如果你有機會的話我邀請你來看一下
那些擴展是怎樣聲明的
在標準庫中因爲幾個圖層
一起工作來提供這個豐富的應用程序界面
好 這些就是你可以使用協議擴展做到的一些很酷的事情
現在 我想回到我們的圖表示例中
使值類型可相等
爲什麼？因爲我是這麼說的
另外吃蔬菜
不 事實上如果你想知道爲什麼去聽一下
週五的講習會我已經跟你們講過這個
這是一個很酷的演講他們準備詳細探討這個問題
總之Equatable對於大多數類型來說都是很容易的 對吧
你只需要比較相應的部分以求其對等性 就像這樣
但是現在我們來看一下圖表發生了什麼
啊哦 我們不能對比兩個Drawable類型數組的對等性
好吧 也許我們可以這麼做比較個體元素就好比這樣
好 我將給你們過一遍
首先你去頂它們有相同數量的元素
然後把兩個數組壓縮在一起
如果它們有相同數量的元素
那麼你就找一對不相等的
好的你可以相信我的話
這還不是問題有趣的部分
哦 對吧？
這是我們無法比較數組的整個原因就是
因爲Drawable類是不對等的
因此兩個數組之間沒有等於運算符
我們沒有等於運算符給潛在的Drawable屬性
我們能不能把Drawable改爲Equatable？
我們改變了設計像這樣
這裏的問題在於Equatable有Self要求
這意味着Drawable現在有了Self要求
而Self要求正好將Drawable
放進了同構中靜態分派的世界
但是圖表需要的是Drawable異構數組
因此我們可以將多邊形和圓放在同一個圖表中
那麼Drawable必須待在異構的動態分派的世界
而這帶來了矛盾
將Drawable改爲Equatable是行不通的
我們需要這樣做
就是說給Drawable添加isEqualTo要求
但是...不 我們不能用Self
因爲我們需要保持異構
而沒有了Self
這就像用類完成Ordered一樣
現在我們要讓所有 Drawable
來處理異構比較情況
幸運的是這次有一種方法可以做到
與大多對稱運算符不同等式是特殊的
因爲有顯而易見的默認的答案
如果類型不匹配的話
可以這麼說如果有兩個不同的類型它們是不等的
明白這一點我們可以實現isEqualTo
爲所有Equatable的Drawable
就像這樣
讓我來向你們演示
擴展就是我們所說的
它是給所有Equatable的Drawable的
好 首先我們有條件地將其他類型向下轉型到Self類型
如果這成功瞭然後我們可以繼續下去
使用等式比較因爲我們有Equatable一致性
否則實例會被認爲不對等
那麼大圖片這裏剛剛發生了什麼呢？
我們與Drawable的實現器達成協議
我們說“如果你真的想處理異構情況請做我的訪客
去實現isEqualTo
但如果你只是想用我們
表達同構比較的常規方式
我們將爲你處理所有異構比較的負擔”
所以在靜態和動態世界之間建立橋樑
是極好的設計空間
我鼓勵你們多多觀察
我們使用等式的特殊屬性解決了這個特別的問題
但是問題並不都像這樣
你還可以做很多很酷的事情
因此等式的這個屬性不一定適用但是什麼纔是普遍適用的呢？
基於協議的設計
所以我想在我們總結
何時使用類之前說幾句因爲他們有他們的位置
好嗎？有些時候你真的想要隱式共享
例如值類型的基本操作
沒有任何意義時
比如複製副本意味着什麼呢？
如果你不明白這是什麼意思
那麼你可能想使它成爲引用類型
或者比較 一樣的
這是作爲數值的另一個基礎部分
那麼 比如窗口
複製窗口意味着什麼呢？
你真的想看
一個新的圖形窗口嗎？
就在另一個窗口之上？ 不知道
這不會是你視圖層級的一部分
毫無意義
另外一種情況
你的實例的生命週期依賴於某些外部的副作用
比如磁盤上出現的文件
部分原因是編譯器大量地創建值
創建 再銷燬
我們試圖儘可能地優化
引用類型有這種穩定的特性
所以如果你要做一些對應於
外部實體的事情
你可能會想使它爲引用類型
類 另一種情況是
抽象實例是“水槽”
比如渲染器
我們灌注信息給它
給渲染器 我們讓它畫線
舉個例子如果你想做一個TestRenderer
讓它積累文本並將這些命令輸出爲
字符串 而不是直接將它們倒給控制檯
你可以像這樣做
但要注意幾件事情
首先這是最後
其次沒有基類
這仍然是一個協議
我使用協議來表達抽象
好 額外的幾種情況
我們生活在面向對象的世界 對吧？
Cocoa 和Cocoa Touch致力於對象
他們會給你基類並期望你將它們編入子類
他們期望應用程序界面中的對象
不要與系統對抗 好嗎？
這隻會是徒勞的
但是與此同時一定要謹慎
你知道程序中任何事物都不能過大
這對類和其他都適用
所以當你從類中重構或分解時
考慮使用值類型
好了 總結一下
協議 對於抽象來講好過於超類
第二協議擴展這個新特徵
讓你做很神奇的事情
第三我提到讓你們來聽週五的演講嗎？
來參加週五的演講
吃蔬菜
像Crusty一樣
非常感謝