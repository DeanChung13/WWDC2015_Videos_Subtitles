Metal性能优化技术
早上好 
欢迎来到Metal性能优化技术
我是菲利普·班尼特 来自GPU软件性能团队 
我们的特别嘉宾  
来自GPU软件开发者技术团队的塞尔哈特·特钦
将为我们展示一个非常棒的新工具  
对你的Metal app进行配置我相信你会喜欢这个工具的
到目前为止WWDC上的Metal
在Metal Part 1新特性介绍会上
讨论了iOS 9和OS X ElCapitan上Metal的新特性
在Metal Part 2新特性介绍会上
我们会介绍两个新架构 
MetalKit和Metal性能着色器
让我们更容易开发Metal app
在最后部分  
我们将回顾有什么工具适合调试和分析Metalapp
我们也将探讨一些关于从Metal app中
获得最佳性能的最优方法
我们来看看工具
Metal调试和分析工具
若你已经在iOS上做Metal app开发 
你应该对Xcode 
以及配套Metal工具很熟悉了
现在 我们将快速看一下
框架调试程序
这里是Metal app中一个单帧捕获 
左边是一个框架导航器 
显示所有存在于框架内的
状态和Draw调用
渲染编码器命令缓冲器分组 
如果你正在使用调试标签  
那么调试标签也会对它们进行分组
是渲染attachment视图 
显示除任何深度和网板attachment外
与现有渲染pass有关的所有color attachment
它显示当前Draw调用的框架高亮区
这让你可以很便利地操纵你的框架 
接下来是资源检查器  
你可以检查app所用的所有资源  
从缓冲器到纹理到渲染attachment
你可以查看所有不同的格式  
分开位图水平 立方形地图  
TD阵列 这些特征它都有
我们有状态检查器  
它可以检查app上所有Metal对象的属性 
继续 我们有GPU报告  
用于测量现有框架上的每一帧 
并对CPU和GPU进行计时
此外 它也在框架中显示  
消耗最大的渲染和计算编码器
以帮助你缩小消耗最大的着色器 
和Draw调用的范围
最后 我们有着色器分析器和编辑器 
这个工具很棒  
可用来调试和分析着色器  
因为它可让你在联机中  
微调着色器并对他们重新编译  
这样你就无需对app重新编译了
你或许已经知道了  
所有这些很棒的工具 
都可用来在OS X El Capitan试Metal app
工具能够很好协助Xcode的使用
它可以让你在整个系统中分析app性能  
现在 你也可以使用 
类似Metal系统寻踪工具的方法
分析Metal的性能
这是iOS 9的一个最新工具
它可让你在CPU和GPU中
分析Metal app
我们来看一下
我们从分析应用中的Metal API使用开始  
然后是驱动程序 再到GPU 
在GPU你可以看到单独处理阶段 
verse X片段 随机计算  
然后到真实的显示器硬件
现在 塞尔哈特·特钦将为我们演示
这个很棒的新工具  
有请他上台
谢谢你 菲利普 大家好
今天我想为大家展示一个非常酷的东西 
Metal系统寻踪
Metal系统寻踪是最新的Metal开发工具
Metal系统寻踪是Metal iOS app上
一款性能分析和追踪工具  
是整套工具的一部分 
它让你可以随时掌握应用的全系统概述  
在显卡上 它也可让你获得细分到
微秒的细节信息
我必须强调一下 它很重要 
它是首次出现在我们的平台上的 
幸亏有了Xcode 7 和 iOS 9
言归正传 我们继续 来尝试一下
我将启动工具  
我们在模板选择器上
你可以看到这里有个新的模板标志  
Metal系统寻踪Metal标志
我将进行选择
对工具很熟悉的人
知道我刚用它当中的四个工具创建了一个新文件  
在时间轴的左手边可以看到这个文件 
我们来快速浏览一下这些工具  
和在时间轴中显示的数据
我们继续在iPad中选择Metal app 
作为目标app和开始记录 
好了
现在Metal 系统寻踪是一款工具内的记录工具 
这个工具叫Windowed Mode
本质上说 它捕捉轨道 形成环形缓冲区
这可让你随时进行记录 
重要的是 在你发现需要调查的问题时  
可以停止记录
这时候
工具将收集所有已经收集的追踪数据处理一会儿 
以一个时间轴作为结束 时间轴看起来像这样
这里有很多东西正在运作  
放大一下 可以看得更清楚些
控制选择键 选择一个时间轴里  
我想要放大的  
感兴趣的区域
我可以通过追踪器手势操纵时间轴  
两个手指滑动到滚动和收缩 以进行缩放 
你可以看到 在我进一步放大时  
我可以在时间轴里看到更多的细节 
所以 在这里 我们看什么呢？
基本上 我们看到是  
Metal应用图形处理过程中
所有图层集合中
图形深层信息
时间轴里不同的颜色
代表每个框架不同的工作量
磁道本身相当的灵敏 
这里的每个盒子代表每个轨道的相关开始时间  
结束时间和所用时间 
从头开始 然后往下一直处理  
我们使用Metal框架的应用
接下来 我们有显卡驱动 它处理你的命令缓冲器
如果你有任何着色器编辑活动中等框架  
它同样也会在轨道中体现 
这由GPU硬件轨道进行跟踪  
显示的是在GPU中
执行渲染和计算指令
最后 我们有显示面轨道 
基本上 这就是在设备上显示的框架 
好了
在这里你可以看到的其他东西是这些标签 
这边的这两个标签阴影bufferG buffer和lighting
是我用编码器标签的属性
分配到Metal代码中的编辑器里的
这些标签带着与它们相关的工作负荷 
沿着传递路径传送  
这使得Metal系统寻踪中
追踪场景渲染pass
非常简单
我强烈建议你充分地使用它 
有些东西太小 无法安装标签  
你可以将鼠标悬停在尺子上就可以看到
一个工具提示 同时显示标签和持续时间 
基本上 这里的轨道顺序映射 
Metal指令沿着显卡
传递路径运作的顺序
让我们继续跟随命令缓冲器 沿着管道向下
在轨道顶端 我可以看到我的应用使用的是
Metal命令缓冲器和编码器
尤其是这里 我看到的是命令缓冲器
和渲染计算编码器的
创建时间和提交时间
顶端有命令缓冲器  
底部有相关的编码器 这个编码器是 
由命令缓冲器直接嵌入其中而创建
现在 注意这个箭头 箭头在进入下个轨道
命令缓冲器的提交时间上 
在Metal系统寻踪中  
这些箭头代表
不同水平传递路径间的依赖性 
例如 当提交了命令缓冲器  
它的下一站是图形显示器驱动  
如果将其可以放大 就会看到更多信息 
看看我们获取到到了多少信息
它真的真的很快 CPU仍在处理
几乎没有占用多少内存
同样的 一旦编码器处理完毕  
我就可以跟随这些箭头了
这些编码器将被提交到GPU轨道
用同样的方式跟随箭头  
可以看到GPU正在处理我的编码器
这个GPU轨道被分成三个不同线路 
一个是vertex处理  
一个是碎片 一个是计算
比如说 我可以看到阴影缓冲途径的
阴影缓冲渲染代码  
它正在仔细查看它的vertex处理阶段  
然后移到碎片阶段 这个阶段刚好
和G buffer和lighting 阶段重叠
这些东西很好
这里有个简要的信息vertex碎片不只是
计算着色器处理时间 同样也计算处理成本
比如说 我们正在iOS上运行  
它是一个图块类延缓体系结构 
所以vertex处理成本也将 
包含图块成本 这些需要记住
最后 一旦框架完成渲染 
表面也将在显示器中结束 
这点显示在在底部的轨道中
基本上 它显示框架进入显示器的时间
以及在里面呆了多长时间
在它下面 有同步轨道 
显示的是被与个别同步事件
相应的峰值分开的同步间隔
最后 在顶部有细节视图
细节视图和你在
其他工具看到的类似
它在选择的工具使用基础上 
提供环境细节
比如说现在 
我选择了Metal应用工具 
就可以扩大这个 看看所有的框架 
所有的命令缓冲器 
和与有关层级的编码器
如果你想看精确定时 这个轨道就很有用
若我转到编码器清单 
精确创建提交时间
或进程的起始位置
非常有用
酷！这里的时间轴
对应这图形管道
这是一个非常强大的工具
iOS 9和Metal中是首次出现
所以要怎么用 才能解决你的问题呢？
或有问题的app是什么样的？
继续 我将打开一个不同的轨道 
为你进行展示
等下菲利普将为你
详细讲解Metal性能
以及如何使用它解决你的问题 
我将简要讲讲工具的
工作流程和一些小窍门
首要的是你需要关心
你的CPU和GPU并行
你可以看到 我打开的标有 
Problem Run标签的轨道 
比我们上一个轨道要稀疏
因为我们有不少同步点 在这些点里 
事实上 CPU正在等待GPU
你需要确保将它消除掉 
同样的 需要寻找另一个有用的东西 
就是你在时间轴里看到的模式
这些框架都是同一场景的一部分 
所以它们的时间局部性很高
任何你看到的分歧 都可能指向一个问题 
你应该进行调查
另一个重要的东西是显示面轨道
理论上 若帧速率目标是60帧每秒 
这些面将在显示上停留
一个单一的VSync间隔
所以我们可以看到每VSync间隔 
显示面就会被交换
比如这个特别的框架 停留了三个间隔 
所以我们以20 fps进行运行 
另一个非常有用的东西是着色器编辑轨道 
不管着色器编辑器何时在轨道里开始生效 
它都直接为你显示相关信息 
需要特别避免的一件事是 
将工作提交到着色器编辑器中等框架
因为它将浪费你的CPU周期
这个周期你原本可以用在其他的事情上的
菲利普等下会详细说到这点
最后 你应该尽早并经常进行分析
像这样的工作流程将帮你解决问题
而且可让解决问题变得简单
Xcode通过为创建产品提供一个配置文件启动选项 
对你有所帮助
它将自动创建一个已安装
在设备上的app的发布版本 
启动一个按照你选择模板运行的工具
好了 这是Metal系统寻踪
适合所有支持Metal的iOS设备
你可以试一下我们期待你的反馈和建议
现在有请菲利普上台 
他将为我们展示一些主要的Metal性能 
以及如何使用工具对他们进行鉴别谢谢
谢谢你 塞尔哈特 你的信息量很大
我们会讲到前面提到的Metal性能
一些最优方法 我们也将看看 
如何使用这些工具进行诊断
并遵循最优方法
让我来介绍一下我们的app样本 
更确切地说是app样本的一个系统轨道 
我们马上可以看到一些性能问题
首先 CPU和GPU之间没有并行
那是非常强大的设备 
实现最大性能的唯一方式
是立即运行它们 然而 它们似乎正在等待什么
你可以看到 CPU中处理框架之间
有大量的延迟
有一个异常的22毫秒
这里不能有任何拖延 发生什么了？ 
来看一下CPU实际活跃周期 
它超过了框架截止期限
我们希望每秒有60帧
所以所有的东西必须在16毫秒内解决我们已经超出时间 失效了
GPU方面看起来也不乐观 
这是个漫长的拖延与CPU上的相称 
因为CPU花费了大量的时间却没做成任何事 
也无法为下个框架排队等候
此外活跃的GPU周期超过框架截止期限 
我们努力达到每秒60帧 
但是事实每秒只有20帧
我们可以做些什么呢？
让我们看看基础的东西
首先检查一下Metal设计和性能主要原则
在前面的状态中它正在创建耗费资源的对象 
现在 在传统app上 特别是在内容加载过程中将发生的
app编译所有来自源的着色器 
着色器可能有数个 甚至上百个 
这是个相当耗时的操作
现在共享编译才进行到一半 
因为着色器需要全部编译到
与各种使用状态相结合的
GPU管道状态中
所以一些app可能
试图进行预热
通常情况下 当着色器和状态第一次 
在Draw call中使用时 就会出现设备编辑
这是个坏消息 想象一下 你有一个竞赛游戏 突然间 
你转了个弯 添加了很多新对象 
帧速率也下降了
这真是的很糟糕
预热所做的就是
你释放大量
带显示状态和不同着色器组合的W Draw调用 
这样让驱动程序可以进行编辑相关GPU管道状态
所以当使用
组合状态和着色器时 
所有的一切都准备好了 帧速率也不会下降了
在实际的渲染循环中 
它们是典型的状态设置 
当你开始考虑做一些事情时 
或许你将做些Draw调用
所以Metal路径就是事先移除资源消耗多的对象
着色器可以在脱机状态下从源代码进行编辑
它免去了不少的工作量
我们提前移到状态定义
你定义你的状态 
GPU管道状态被编译成
这些状态对象
所以当你开始Draw调用时 
就没有所谓的设备编辑 
所以也就不在需要警告了
它已经成为历史了
它们已经为Draw调用备好渲染循环了 
许多Draw调用
基本上
Metal通过以下方式加速状态定义
分离Draw命令里消耗多的状态确认和编辑 
从而允许你将其推出渲染循环
并为真实的Draw调用
保持渲染循环
现在 这些资源消耗型状态
被打包到不可变状态对象中 
目的是一旦创建 就可以被重复使用
现在 回到app样本 
你可以看到中等框架上有些渲染器编辑正在发生 
这里我们大约浪费了一毫秒
根本没用
倘若看一下Xcode的框架调试器 
看看在单个框架上发生的所有这些
看看所有的这些对象
都不是我们想要的
你应该看的是这些 
创建框架命令缓冲器
获取drawable以及纹理
剩下的东西 就都是多余的了
我们来说说这些消耗大的对象 
以及应该何时创建它们
我们从着色器库开始
这些是你的编译着色器库
现在 你真正要做的是 在离线状态下 对它们进行编译
你可以使用Xcode 
项目上任何Metal源文件
都将被入默认库
你的app或许有它自己的自定义目录管道 
你或许并不是必需使用这个方法
因此 我们提供了命令行工具 
它可以被合并到你的管道中
如果在运行时间里 
你免不了要从源里编辑着色器
最好是进行异步创建
所以当你创建库 同时 
你的app确切的说是调用线程 
可以继续做其他事情 
一旦着色器库创建完成 
你的app也会得到相关信息
需在你的app创建的首个对象
是设备和命令队列
这些代表着你将使用的GPU 
以及安排好的命令缓冲器的顺序
现在 正如我们所说的 你想要
在app初始化过程中 创建这些 
因为创建它们消耗太大 
你想让它们可以在app的使用周期里被重复使用
而且当然你想为每个使用的GPU都创建一个
接下来是很有趣的东西 渲染
和计算管道状态 
它们压缩了所有的可编程GPU管道状态 
因此它准备了所有的描述符vertex格式器脚本 
渲染缓冲器格式 
并把它们编译成真实的原管道状态
现在 因为这是个消耗多的操作 
你应该在你加载内容时 创建这些管道对象 
而且它们应该可以被不断循环使用
现在 因为有了这些库 
你也可以用这些方法 
对它们进行异步创建
一旦创建完毕 
完成处理器将通知你的app
需要提到一点 除非你真的需要它们 
要不然就不要获取反射数据了 
因为这是个消耗很大的操作
接下来是深度网板和取样器状态
这些是GPU管道状态固定功能 
在你加载内容时 
你应该和其他管道状态一起对其进行创建
现在 你或许已经结束了许多深度网板
和样品器状态 但你无需担忧 
因为Metal实现将在内部
散列状态 并创建大量副本 
所以 你无需担忧
接下来我们有了GPU消耗的真实数据了
你获得了纹理和缓冲器
再一次 你应该在加载内容时 
对其进行创建 并尽可能的重复使用 
因为这是一项与配置
和释放资源有关的消耗
乃至动态资源 你或许无法
提前将它们完全初始化但是你至少应该
创建优先存储
我们很快就会讲到这部分的详细信息
现在简要说一下 
所以 对于消耗大的状态显然应该提前创建 
它们是着色器库 
可在离线的时候进行创建
设备和命令序列 在你初始化
app的时候进行创建
渲染和计算管道状态 
在你加载内容的时候进行创建 
固定功能管道状态 
深度网板和取样器状态 
也是在你加载内容时进行创建 
最后是app使用的纹理和缓冲器
我们继续 在app示例中遵循
这些最优方法或许你还记得它是这样的
曾有些着色器编辑每帧都会出现中间帧情况 
现在 我们什么都没有了
已经节约了大概CPU时间的一毫秒
开端不错不过我们要看下
能否很快的做得更好
预先创建消耗多的状态和对象 
并使它们可以被重复使用
特别是 在脱机状态下编辑你的着色器源 
你想将渲染循环保持在它原本的样子 
这是Draw调用 
摆脱了所有的对象创建 
对于那些你无法全部预先创建的资源该怎么办？
我们正在谈论这些动态资源 
所以我们该对它们做什么？我们该如何有效地创建并管理它们呢？
现在 通过动态资源 
我们来谈谈那些一经创建 
就可能被CPU修改很多次的资源
一个好的例子是缓冲器着色器常量 
以及一些东西 比如在CPU中产生的粒子系统 
所拥有的任何动态vertex和指示缓冲器  
除动态纹理外
或许你的app有一些纹理 
它在框架间的CPU上进行修改
理想的状态是 如果可以
你会选择将这些资源放在某处 
以方便CPU和GPU有效地使用
当你创建资源时 
你可以通过使用共享储存模式选项进行操作
这在存储器里创建资源
资源由CPU和GPU共享
事实上 这是iOS上的默认储存模式 
iOS设备已经统一存储器架构 
所以相同的存储器可在CPU和GPU之间进行共享
现在 关于这些共享资源的事情是 
CPU完全无法同步使用
它可以通过指示器自由地修改数据
事实上 对于GPU正在使用的数据
对CPU而言是毁灭性的的数据 
CPU很容易就可以对其进行干涉
我们想要避免这种情况
但我们应该怎么做？
一个简单的做法是为资源配备一个单一缓冲器
在资源里 我们有一个常量缓冲器
这个缓冲器在CPU里进行更新 并随后被GPU所消耗
现在 倘若CPU想要
修改常量缓冲器里的任何数据 
它就必须等到GPU完成后 才能开始
唯一方法是 
它是否在等待命令缓冲器在命令缓冲器里 
资源是调用于完成GPU进程
在这个示例中 我们使用等待至完成
所以我们空等着等于CPU也在空等着 
直到GPU完成处理 
CPU才能继续并修改缓冲器
而缓冲器将在下个框架中被GPU消耗
这真的很不好 
因为不仅CPU储存了GPU也储存了 
因为CPU没有时间为下个框架操作排队等候
这是在app示例中所发生的
CPU在空等等待GPU完成每个框架 
你引入了大量的存储周期 
是的 CPU和GPU之间并没有并行
显然 你需要更好的方法 
你或许会冒险为每个框架创建新缓冲器 
因为你需要他们
但是正如我们前面所提到的 
这并不是一个好办法 
因为创建缓冲器
需要经常消耗
如果你有很多大的缓冲器他们会积累 
你不会真的想这么做的
你应该做的是 使用一个缓冲器组合
这里我们有三重缓冲组合 
里面有三个缓冲器这些缓冲器是在CPU更新 
然后被GPU消耗掉的
为什么是三个？
我尤其要建议你限制
命令缓冲器数量 最多三个 
实际上 每个命令缓冲器有一个缓冲器
通过利用一个信号 
阻止CPU超过GPU太多 
我们可以确保在CPU上更新缓冲器仍是安全的
返回读取第一个缓冲器时 
当GPU在处理过程中
与其拿一堆恼人的样本代码
我将示范的很棒的例子
是Metal UniformStreaming示例 
它将展示如何做到这点
若你感兴趣 我建议你随后检验一下它
回到app示例 你应该还记得 
在CPU上 每个框架之间
有这些被削弱性能的权重
在使用一个缓冲组合更新动态数据后 
我们设法极大地减少
CPU处理和GPU处理之间的差距
我们还有些同步性问题 
但我们将只简要地看一下
我们已经取得很大的进步 
总之 你想要缓冲
动态共享资源 
因为它是在框架之间更新这些的最有效的方式 
你通过使用我提到过的缓冲器和组确保安全
现在 我将讲一些东西 
确切地说 实际上是一件
我不想提前做的事情 
那关系到你何时获得你的appDrawable服务
Drawable外观是领域里app的窗口 
它是你的app渲染它的可视内容进去的东西 
这要么是在显示器上直接显示 
要么是组成管道的一部分
从Core AnimationMetal图层检索Drawable
但这些Drawable数量有限 因为事实上 它们相当的大 
而我们既不想大量保存它们 
也不像在我们需要的时候对它们进行配置
所以这些Drawable非常有限 
而一旦它们在硬件中显示了 
在显示间隔
预先drawable 被放弃了
如果你集成实际的显示硬件 
显示管道的每个阶段可能在任何点 
为一个GPU为Core Animation
在你的app里抓取Drawable
你的app通过调用下个Drawable方法 
抓取了一个Drawable外观
当调用Current RenderPass Descriptor时 
可以执行MetalKit 
一旦Drawable适用方法将只能返回 
若那时恰巧有个适用的可取值 
它将立即返回
很好 你可以使用框架 继续做
然而 若没有适用的app 
确切地说为它调用 它将被封锁直至 
至少下个显示间隔正在等待一个Drawable
可能会很久
60帧每秒
我们在说16毫秒
真是一个坏消息
所以这就是样本app所做的事情？
这就是执行中巨大差距的解释？
我们来看看Xcode是怎么说的
我们转到框架导航器 
看看这里的框架导航器
Xcode与阴影缓冲编码器
之间似乎存在问题
这里有个小警告
详细看一下 
事实上 我们确实比实际需要的早
调用了下个Drawable方法
下个代码提供了一些非常明智的建议 
应该在真正需要这个Drawable的时候 再调用它
所以这个是如何与样本app相适应？
这里 在样本app中 我们有数个pass 
在阴影pass前的每个框架开始时获得Drawable
这实在太早了因为直到最后的pass 
我们才将一切拖离屏幕 
直到我们渲染UI pass时我们才需要一个Drawable
所以获取下个Drawable的最佳位置是
自然地刚好早于UI pass
我们继续 做出改变 随后将调用移到 
下个Drawable 
来看看问题是否被解决了
你已经看到了 是的 它做到了
我们移动第二个同步点 
现在在框架上的处理和在CPU上的处理之间再无任何拖延了
这是个巨大的改进 
建议很简单 仅在你真的需要
Drawable的时候 再获取它
这是在真的使用渲染pass之前
这将确保你隐藏任何长延时 
这些延时在没有适用的Drawable时就会出现
你的app可以继续做有用的工作 
知道真的需要一个Drawable时 
就会出现一个适用的
从这点来说 目前为止 我们做得非常好
但是仍有改进的空间 
所以 为什么我们不看看GPU的效能
而不是降到非常低的水平？
试图最优化着色器或改变纹理格式 
诸如此类的
为什么不看我是否可以提供一般的建议
就是这么巧 这就是了这涉及到我们如何使用
Render Command Encoders
Render Command Encoders是用来 
为单个渲染pass创建Draw命令的 
一个单一渲染pass在颜色获得attachment的一个不动集 
以及深度和网板attachment上其作用 
一旦开始pass 就不能变动attachment了 
你可以改变作用在它们上面的行动 
比如深度网板状态 
颜色蒙版和调配
这个值得记住
现在 在iOS设备GPU上 
尤其重要的渲染编码器使用方式 
取决于它们的结构方式
它们是基于图块的延迟渲染器
每个Render Command Encoder
可产生2个GPU pass
首先 你有vertex阶段 它在编码器中
变换所有的几何体 然后执行剪贴
着色 然后将所有的几何体装到
屏幕空间图块里
紧接着是碎片阶段 它通过决定
哪些对象是可见的
来处理所有的对象图块
然后只有可见像素才能被处理
所有的碎片处理发生在
快速芯片图块缓冲器上
现在 在渲染结束时 
你只需存储颜色缓冲器
你只是放弃了深度缓冲
甚至有时你有多个color attachment 
你也只需存储其中一个
不在每个pass存储图块数据 
你就节省了不少带宽
你避免了写出整个框架缓冲器
这对于性能来说很重要 
因为它不必加载每个贴图的数据
所以Xcode告诉了我们什么？
它能否为我们提供 -确切地说 
我提到每个编码器相当于
一个vertex pass和一个碎片pass
这甚至在MT编码器中也适用 
这个是相当重要的
这里 事实上 我们有两个G buffer编码器 
而第一个似乎没绘制任何东西 
我猜这是误操作造成的 
事实上 它对性能还是有影响的
但是看下app的系统轨道就可以知道
由于空编码器在GPU中消耗了2.8毫秒 
由此推测它刚为我们所有的attachment
三个颜色和两个深度
和网板写出了清晰的颜色
这个特殊框架GPU处理时间 
总计是22毫秒
现在 如果我们移除MT编码器 
这可以很容易就做到 因为MT编码器本就不该
在第一个位置时间就降到了19 非常好 
只需做极少的事情 就达成目标
所以小心这些MT编码器 
若你不打算在pass进行任何绘制 
就别启动编码
我们来详细看一下
来看看样本app上的渲染pass 
并看看我们都有些什么
所以我们有一个阴影pass 
它转化成了一个深度缓冲器
有一个G buffer pass 
它转化成3个color attachment
一个深度和网板attachment
有这三个lighting pass
它用来自G buffer pass的渲染attachment数据
要么通过纹理单位进行取样 
要么加载到框架缓冲器内容
当lighting pass使用这个数据时 
它们完成lighting和输出 
使之成一个单一积聚对象 
这个对象被多次使用
最后你有一个用户界面pass 
在这个pass上 用户界面元素在屏幕上
被画出并被展示出来
所以 这是否是编码器最有效的设置？
再一次 我们调用Xcode框架调试器 
看看它是否还有什么问题
再一次 是的 它做到了 
它和sunlight编码器不协调
我们来详细看一下 
使用命令编码器并没有什么效率
使用Xcode就足够了 它可以告诉我们 
事实上 我们应该联合哪一些 
我们继续 来合并一些pass 
与其合并两个 不如合并三个 
他们都在同一个上起作用color attachment
我们继续 进行合并 
这里 我们有6个pass 
现在他们将把它们合并成4个
所以对于性能GPU方面会有什么影响呢？
我们转到GPU 系统轨道
这里可以看到 我们从21毫秒 
6个pass降低到18 而且不需要
写出所有的加载 存储所有的attachment数据
真是好极了 
但是 是否能在进一步呢？
让我们回到app 
我们有4个pass它是否真的可以
合并G buffer和lighting pass免去存储
5个attachment并将所有的一切都保存在芯片上？
是的 它真的可以 
我们可以通过巧妙的使用可编程调配做到这点 
这里 我不会讲太多细节 
我们所做的是 将两个编码器合并成一个
现在 三个渲染编码器被留下来 
我们必须加载并存储极少的attachment数据 
从带宽方面来说
这是个巨大的胜利
来看看有什么影响
事实上 并不多
这简直是出乎意料 
我们只减掉了大约1毫秒
不是很好
我原本希望可以减掉更多的 
再一次 Xcode能否挽救我们？
我们转向Xcode框架调试器
来详细看下为G buffer编码器
加载和存储带宽
它显示的是 事实上我们仍然加载和存储了大量的数据 
原因很简单
看起来似乎是我们并未为每个attachment
正确设置加载和存储行动
我们只想存储第一个color attachment 
除了深度和网板attachment外 
其他的都要放弃 我们当然也不想加载
这些放弃掉的color attachment
所以 若我做了个简单的变动 让加载
和存储行动变得更合适 
加载带宽就被减到0 
我们也大量减少
存储attachment数据的数量
所以现在有什么影响呢？
先前 GPU上 
三个pass就花了17毫秒
现在 它减到14毫秒
更接近一些了
简而言之 不要浪费你的渲染编码器 
想在它们上面尽可能的多做些有用的工作 
那就不想画任何东西的时候 
就别启动编码
如果你可以在Xcode的帮助下 
合并渲染到同一attachment上的编码器
这将让你获益良多
在GPU方面 我们做得相当好 
事实上 我们是在我们的框架预算之内 
但我们是否能在CPU上做些什么呢？
如果你记得 我想事实上我们仍然 
有点超出我们的框架预算
多线程怎么样？
多线程会如何帮助我们？
在多线程方面Metal允许我做些什么？
很幸运Metal在考虑了多线程的基础上 
设计出来的它有一个非常有效的线程安全 
和一些多线程渲染工具的可扩展方法
它允许你在不同的线程上同时对多重命令缓冲器进行编码 
你的app控制了
正在执行编码的命令
我们来看一下可能的情境 
在这个情境里我们可能尝试一些多线程 
开始之前 我想要强调 
在你开始对你的渲染进
行多线程处理之前 
你应该积极寻找
达到最佳单线程性能的可能
在你开始进行多线程处理之前 
确保资源足够 
好了 这里有个示例 里面有两个渲染pass 
事实上CPU对这两个pass进行编码时间太长 
导致我们错过了框架截止期限
所以 如何改进呢？
我们可以继续 
对两个pass采用并行编辑
不仅是设法减少每帧的CPU时间 
副作用是 第一个渲染pass会 
更快地被提交到GPU中
在Metal对象方面这个看起来是怎么样的？
如何一起使用呢？
照例从命令队列中的Metal设备开始 
现在这个示例 
我们将有三个线程 
每个线程需要一个命令缓冲器 
这两个线程每个都有一个RenderCommand Encoder 
在单独的pass上起作用 
第三个线程上 我们可能有
持续执行的多重编码器
为多线程展示方法
可以是非常灵活的 
一旦编码完成了  
命令缓冲器就会被提交到命令队列中
所以 你会怎么设置呢？
非常简单
你为每个线程创建一个命令缓冲器 然后继续 
像往常一样初始化渲染pass 
现在 重要的一点是命令 
在命令里 命令缓冲器将被提交到GPU中
有可能这对你很重要 
所以你通过调用命令缓冲器里的 
Enqueue方法执行它 
它在命令队列里保存了位置 
所以当缓冲器运作时
它们将按照排列的顺序被执行
这点很重要 需要记住
因为随后为每个线程创建渲染编码器 
然后继续在分开的线程中对绘制进行编码 
然后提交命令缓冲器
真的很简单 
其他可能从多线程中
获益的情境怎么样？
这里 我们有两个pass 
其中一个比另一个明显长很多
可以将它分离吗？
是的 可以 
我们将它分成两个单独的pass 
这里 我们有三个线程 
一个在第一个渲染pass上起作用 
另两个则在第二组块上起作用
再一次 通过使用多线程 
我们没有超过框架截止期限 
我们在CPU上节省了一些时间 
可以用来做我们喜欢的事
无需更多的Metal工作 
我们怎么确切地说这看起来像什么？
再一次 我们有设备和命令队列 
在这个示例中 我们将用到三个线程 
但是我们只想用一个命令缓冲器 
有Render CommandEncoder的特别格式 
Parallel Render Command Encoder
现在 这允许你越过多重线程 
为单个编码器分离工作在iOS上使用这个尤其重要 
因为它确保线程的工作量
随后在GPU中被合并成一个单个pass
所以pass之间并无加载和存储 
如果你将在多重线程里拆分
一个单个pass使用这个就很重要了
从Parallel RenderCommand Encoder里 
我们创建了三个从属命令编码器 
现在每个都将编码成命令缓冲器 
因为我们正在多重线程化 
编码可能在不同的时间里被完成 
无需特别的命令
然后命令缓冲器提交到队列 
现在 它完全可行 
你甚至可以有并行
Parallel Render Command Encoders
多线程可能性并非无止境 
但是非常的灵活
你也可以有我们刚看到的 
你可以有第四个线程 
连续地执行编码器
所以我们如何设置？
每Parallel Render Command Encoder 
创建一个命令缓冲器开始 
不管有多少个使用中的线程 
你只需要一个命令缓冲器
然后 和往常一样 继续初始化渲染pass 
然后创建真实的并行编码器 
现在 这里是重要的显存位宽 
在我们创建附属编码器时 
创建编码器的命令决定 
编码器提交到GPU的顺序 
在你为多线程编码分离工作量时 
就需要考虑到这点
然后我们继续 编码绘图 分离线程 
然后为每个附属编码器完成编码 
现在 第二个重要的点是 
所有的附属编码器必须在我们结束
并行编码器编码之前完成编码
如何执行 取决于你 
最后 命令缓冲器致力于队列 
所以 我们继续 我们决定对我们的app多线程化 
看看都有什么 
先前 我们有连续编码或pass 
这个用了CPU时间的25毫秒 
现在 我们找到一种方法即在一个线程里编码阴影pass
在其他线程上编码G bufferpass和UI pass 
现在时间减到少15毫秒 
这是一个改进 
我们同样也在CPU上节省了一些时间
直到多线程化进行 
如果你发现你仍在CPU范围内 
而且你已经做了所有你能做的调查 
确定app上没有愚蠢的事正在进行 
那你就可以从多线程化里获益了 
你可以在多线程上
同时编码渲染pass
但是你决定在多线程里分离
一个单个pass
想用Parallel RenderCommand Encoder来做
现在 我从这部分学到了什么？
我们介绍了Metal系统寻踪工具
它真的很棒
它为你的app Metal性能提供了新理解 
你想要和Xecode一起配合使用 
进行早期分析 并经常进行分析
正如我们看到的 你也应该试着 
遵循陈述过的最优方法 
所以你想提前创建消耗多的状态 
并尽可能重复使用状态
我们想要缓冲动态资源 
所以我们可以在框架之间进行有效修改
而不会引起任何拖延
我们想要确保我们在适当的时候
在正确的点上获得Drawable
通常在最后的可能时刻 
我们想确保我们有效使用 
Render Command Encoders
我们没有任何空的编码器 
我们把为相同attachment所写的
任何编码器都合并成一个
然后 倘若发现我们还在CPU范围内 
正如在这里案例中看到了我们可以考虑由Metal提供 
用来将渲染多线程化的方法
所以 我是怎么做的？
现在 看我们的app 
我们没有任何执行期着色器编辑 
GPU工作量在框架截止期限内 
很好 
本来就是CPU的工作量 
在CPU上框架之间的处理没有差距 
我们甚至可以决定进行多线程
我们节省了不少时间 可以用来做其他事情 
我们设法达到我们的对象 
在这个示例中 它是60帧每秒
做得好！
现在 演讲结束了 如果你需要 
这部分提到的更多信息 
你可以访问我们的开发者门户网站 
你可以在开发者论坛注册 
任何详细的问题或一般询问 
你可以将它们发送给艾伦 卡夫 
他是我们的图像和游戏技术专员 
感谢你们来参加这个演讲 
希望你不会觉得无聊 
请享受WWDC剩下的部分
谢谢