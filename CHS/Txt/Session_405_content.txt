构建丰富的Playground创建引人入胜的Swift在Xcode 7的内容
早上好！
感谢大家来到今天
关于Rich Playground编写的讲座环节
我叫 山姆是 Xcode 团队的一名工程师
那么 现在Playground已经推出大约一年了
而我们已经被你们用它所做的事情震撼了
我们已经看到了各种东西有人写出了他们的第一个“Hello, world”
更有人在Playgrounds中写出了多本书
反应是非常惊人的
那么今天我将谈几个内容
我们将讨论 自去年以来
我们在Playground上增加的一些新特性
以及我们已经更新的一些现有特性
我们也将涉及一些小建议和窍门
它们能帮助您编写出真真正正的丰富的Playgrounds
您希望与世界上的其他人分享的Playgrounds
而作为一点奖励
我们将解决WWDC的出席者中一个常见的问题
那就是如何玩遍旧金山
那么问题是什么呢？
这个嘛 旧金山是一个大地方
有很多可看的东西
但实际上在讲座环节之间你不会有太多的时间去做这件事
您还有实验室活动还要写您的下一个伟大的app
而你多半恰好在本周末要赶航班
所以这里有个终结点
而作为工程师
我们希望在解决问题的时候尽可能地高效
在这个问题的语境下 这意味着
我们不希望走不必要的路
那么我们将如何解决这个问题？
这个么一旦我们知道我们想要参观的地方
我们会从Moscone Center出发
以可能的最快的方式遍历所有我们想看的地方
而且要赶在我们冲向旧金山国际机场之前看完
那么为了做到这个我们将建立一个Playground
那么 闲话少叙让我们进入正题
好了
那么我这里 已经有了一个已为我们设置好的Playground
而我们将快速地花一点时间查看一下我们已有的东西
首先我们这里有一个地点结构体
地点将是我们希望在旧金山参观的地方
它们将有一个字符串形式的名字
以及位置 以 CLLocationCoordinate2D 表示
接下来我们有一个城市结构体
那么在我们这个问题的语境下它将代表旧金山
而且我们可以把这认为是一个地点的集合
它是我们用来放这些东西的类型
那么在内部我们有一系列的地点
然后我们在这里有一个函数 通过它我们可以向我们的城市添加地点
那么让我们往下进行创建我们的城市
我们将把它叫做“旧金山”
如我刚才所言我们需要从某处开始我们的旅行
因此我们将继续往下进行为Moscone Center创建一个地点
就是我们将出发的地方
那么让我们在那里创建Moscone 
最后我们终于要向我们的城市添加地点了
那么 你们中间熟悉Playgrounds的朋友会记得
对于每行被执行的代码
我们在这里的结果侧边栏都会得到一个结果
因此我们会看到我们的addPlace函数被调用
而且我们似乎是要将Moscone Center传递给它
但是 如果您继续往下看下面我们创建了城市和地点
我们所要获取的就是类型
因此这是非常方便的但是我们也想更具有描述性
尤其是我们将要创建更多的几个地点时
如果我们一个地点接一个地点地逐一参观
我们将不能区分这些东西
那么对于我们的地点来说最具描述性的东西就是名称
那么我们如何让名称返回到我们的结果侧边栏呢？
我们有一个新的协议来解决那个问题
叫作CustomStringConvertible
那么我能做的就是在这里为我的地点扩展结构体
表明我将执行CustomStringConvertible
而你能看到现在我这里有个错误
因为它们实际上还不符合协议
因此 为了实际符合协议
我们需要执行一个现成的属性
叫作 description
而那将返回一个字符串
而对我们来说我们希望返回我们的地名
因为那是最具描述性的东西
您现在可以看到如果你回顾下面我们创建地点的地方
这里我们有Moscone Center而不仅是类型名
那么这对我们的城市意味着什么？
多半最具描述性的东西
是返回当前城市内的地点清单
以便我们能够看到旅行的进展
因此我们将往下进行为城市进行这个操作
执行那里的CustomStringConvertible
并继续往下进行返回描述
对于它 我们将返回places.description
因此它将给出我们一系列地点的描述
那么现在您可以看到当我们最初创建San Francisco时
实际上里面没有任何东西
因此我们这里获得了一个空阵列
但是然后当我们对其添加地点后我们得到了Moscone Center
那么当我们创建越来越多的地点时
我们将在结果侧边栏内看到越来越多的东西
因此 关于Playgrounds很酷的事情之一就是
你总能更进一步地查看获得关于某个结果的更多信息
只须点击结果旁边的这个Quick Look按钮即可
那么 我就点击查看Moscone Center
我们看到了关于我们的地点的更多一些信息
我们有地名和经纬度
这对于调试是非常方便的
但是 经纬度对我没有实际帮助我对制图学不是那么在行
我不知道如何在世界上定位这些东西
因此我想看到更直观一点的东西
某种让人大声喊出的东西“呀 那就是要找的地方”
而对我来说没有什么能比一个蓝色大圆点
下面加个名字更能让我喊出地名来了
我也会在地图上加上这个东西
那么我们要怎么实现呢？
通常当我们希望做有些定制化或直观的事情时
我们会创建一个视图
那么我们将继续往下进行在这里创建一个UI View子类
而我们已经设置了它的一些内容
让我们快速地查看一下我们在这里都有些什么
我们这里有个类叫做 View
它将是一个UI View子类
我们在内部有另一个视图它将成为我们的蓝色大圆点视图
然后我们有一个名称标签以显示我们的地名
然后当我们创建这个东西时我们将让它决定它的大小
最后 在layout子视图中
我们将放置这些东西以便当蓝色圆点位于顶部
而文本位于下部
那么我们先创建其中一个看一下它是什么样子
而且我们将让Quick Look弹出
妙极了 那开始更像是一个我能在地图上看到的地点了
但是我们实际上要怎样把这些东西合在一起
以便当我们快速查看地点时
我们实际上会看到视图返回？
为了实现那个目的我们有另一个新的协议
该协议叫做 CustomPlaygroundQuickLookable
CustomPlaygroundQuickLookable所做的就是
如果您执行了要求的方法
它将让您 返回另一个type
作为您的type或其他type的Quick Look 显示的内容
因此那可能是一个贝塞尔曲线或某种颜色
但是对于我们的情况我们希望返回视图
因此我将要继续往下进行的就是为我们的地点创建一个扩展
并且表明
它将执行CustomPlaygroundQuickLookable
那么我们这里又有一个错误因为那我们实际上还未遵从那个协议
因此我们将通过执行
CustomPlaygroundQuickLook添加对它的遵从
那么我们将向那个这个方法内返回
一个反映该视图的PlaygroundQuickLook
现在 因为我们已经设置了一个扩展我们可以读取我们的地名
因此 我们可以往下进行并将地名 赋给那里的初始值
那么现在 当我们快速查看地点时我们就该看到了
妙极了我们有了Moscone Center
一切都开始看上起更像个地名了
但是 我们这里还有点代码它似乎
与我们的Playground其它部分格格不入
我们想把这些内容移开因为实际上没有其他人关注它
它无助于展示我们所做的工作
那么对这些内容我们将继续往下进行...
首先我们将删除这里的地点视图因为我们并不需要它
并且我们将截取这里的这个
我们所声明的视图
并将它直接放在我们的地点扩展里面
清除这里的一些空白
那么当Playground重新执行时您应该看到...
妙极了真是我们以前看到的样子
但是现在 那个视图代码正好全部嵌入在我们的扩展内
因此它是精致而干净的
这对我们的城市意味着什么呢？
如果我们遵循这样一种模式希望看看当前我们城市里面有些什么
那么我们会希望看看我们的城市里面有些什么地方
那么这将是默认发生的
所以 如果我们点击Moscone Center的快速查看
我们会发现那里有了个“Place”
而且我们可以看到Moscone Center那里的蓝点
但是... 随着我们添加更多地点
它不会对我们有太大帮助它只是会被列入清单而已
我们希望对这些东西的相对位置有一个直观的印象
因此我们开始着手解决如果我们在Moscone Center
我们多半不会直接去Golden Gate Bridge
我们首先多半会去类似Coit Tower的地方
为此我们创建了另一个扩展这次是 City 的扩展
它将仍然是CustomPlaygroundQuickLookable
我们将在这里创建我已经有了一些现成的代码
我们将快速地查看一下它
那么它是一个City的扩展
我以同样的方式执行了CustomPlaygroundQuickLookable
我们已经通过执行这里的CustomPlaygroundQuickLook方法而遵从了协议
然后在内部我将创建一个视图
根据它们的经纬度算出这些东西
应该在视图中的位置
那么现在 当我们快速查看City时我们应该看到...
妙极了！Moscone Center在那里的一个空地图的东边
但是我们将创建一张图片
表明我们我们将在这里实际看到的东西
那么既然我们已经有了这个
我们将添加更多几个地点
但是在那之前
我想让这里的地图视图一直保持打开状态 或至少可见
当我检查代码的时候我将打开并关闭它多次
为此我们有这个很酷的小东西叫做“内嵌结果”
那么 紧靠这个快速查看按钮如果我点击Show Result
那将会把“快速查看”直接放在生成它的这行代码下面
那么我可以继续在Playground的工作并查看它的持续运行
以及了解实际发生的事情
而很酷的事情是目前它还很小
因此我们可以选定并向外拖拽它就像我们拖拽任何其他窗口一样
随意调整到希望的大小
我们可以开始处理我们在Playground上的其他内容
添加地点
我们会看到它们出现在我们的地图上
那么我们希望看到什么呢？
我听说过Golden Gate Bridge是很酷而且很出名的
因此我将往下进行并尝试一下
我们将把它添加到我们想看的地点
而当Playground重新执行的时候
我们将看到它基于Golden Gate Bridge的实际位置
我们将把它放在西北部
如果我对旧金山地理的了解是正确的
我想那就没错
我们还想看些什么？Sutro Tower 怎么样？
它有点像是是来自于电影《世界大战》里面的东西
我将把它加入
并放在地点中
我将加入 Sutro Tower
Playground 重新执行
然后我们就会看到下方也即南边的Sutro Tower
那么我们已经开始真正了解我们的地点是如何创建的
而随着我们添加越来越多这些地点根据它们所在的位置 我们将看出
如何游览这些地点
现在我将继续往下进行并切换到前面的幻灯片
那么您可能已经注意到了
我们的Playground到末尾时变得有点冗长
我们有些视图代码和一些扩展
而且有很多并没有帮助我们描述问题的内容
它还不是那么完美
那么我们应该做的就是
直接把大量代码从Playground主体中取出
但仍然把它留在附近以便使用
那么为了向您展示我们如何操作的我想邀请我的同事 康纳 上台
谢谢你 山姆！
大家好！
我叫 康纳是 Xcode 团队的一名工程师
今天我将和大家谈谈如何让您的Playgrounds更加强大
并更专注于手头的问题
为了达到这个目的让我们直接进入一个演示程序
在里面我将查看山姆 刚才开始的Playground
并为找到穿越旧金山的最佳路径添加一些支持
同时也让目标更加明确
现在让我们来看看演示吧
好了 那么我们已经在Xcode中了
如果您注意到的话 我们的Playground与 山姆 刚才向您展示的基本相同
我们开始先为旧金山创建一个city
我们创建几个地点然后将它们添加到city
用这个内嵌结果结束以表明您到目前创建了哪些内容
不过如果您注意到的话有一个重大区别
那就是整个Playground现在正好占据一个屏幕
然而 在地点构造体内我仍在使用我的自定义 city
而尽管Swift编译器很棒
它也不能凭空创建出构造体
因此 我们将转而采用我们在
Xcode 6.3中添加的一个特性叫做“辅助资源”
“辅助资源”是额外的Swift源文件
它们被嵌入在您的Playground内部
而且被预先编译到一个单独的Swift模块中
因为它们不需要具备互动性
它们可以比Playground本身有更好的表现
此外 由于它们位于一个单独模块内
您可以利用读取控制
来确保只显示那些您希望Playground可见的辅助资源
因此 您可以在辅助资源中隐藏大量的内部执行细节
为了找到它们 我们将继续进行并打开浏览器
在您的PC中我们在顶部有Playground
然后 在Playground内我们有sources文件夹
在sources文件夹内我们有一批Swift 源文件
我可以打开一个这里我们有city.swift
而它大体上是与 山姆刚才处理的构造体是一样的
只是有些小的修改
首先 我将把它标为 public
因为我们想让city能够被主Playground自身使用
我也添加了对城市的旅行时间的支持
以便于我们能够实际追踪游览城市的每个地点所需的时间
如果我们看一下place.swift我们发现这里有同样的基本的东西
因此 与我们以前的同样的构造体
只是被修改而成为public
并有其他一些修改以便与更新后的city构造体协同工作
有几个其他的辅助资源文件我不会去探讨它们
一个与属性列表的序列化有关
另一个是我从我做过的其他项目收集来的各种实用工具
它将在我执行我们的算法的时候帮我的忙
现在让我们回到主Playground
那么这里我们看到我们有了一个城市的起点
我们在开始建立某些东西
但是我想参观更多地点而不只是这两个
而我们也希望有在不同地点之间的旅行时间
我可以用代码形式全部添加它们但是那还不够好
因为我们在Playground上方将会有一堆代码
它们对我们将要展示的东西并无益处
因此 我将利用Playgrounds中的另一个特性
叫做“嵌入式资源”
“嵌入式资源”是被复制到 Playground内的文件
Playground本身在运行的时候可以使用这些文件
作为主 bundle 的资源
而且它们也驻留在浏览器中在这个小Resources文件夹内
我将要做的就是把一个plist
从定义旧金山这个城市的Finder中拖进来
因此我将继续并执行这个操作我有了SanFrancisco.plist
我可以把它拖到这里来
它就会在Playground文件内被复制
这意味着当你决定与其他某人共享你的Playground时
我们无须担心任何外部文件引用的中断
它全部都在那里面因此你可将其作为独立单元发送
让我们看一下这个plist的样子
首先 我们有一系列地点
每个地点将一组经纬度映射到一个地名
然后让我们在这个文件里向下滚动一点
在这里我们会看到有一系列的旅行时间
而旅行时间则将两个地点映射
到两个地点之间旅行所需的时间和分钟数
这些时间是使用iOS 9内的trans directions创建的
不过即使我将这些东西称作目的地和出发地
我将把它进行一些简化
并且假定 从A点到B点所需的时间 与从B点到A点所需的时间相同
因此这实际上是双向旅行时间
现在切换回主Playground 
这里并不需要全部代码
我将选取其中的大部分将其删除
并替换为一个调用加载我的城市San Francisco
从调用这个城市初始值开始
调用contentsOfPropertyListAtURL
它将做的不过就是查看主bundle
以便为特定的资源获取URL这个资源即San Francisco plist
我们知道我们刚把它加入了Playground
因此我将把它强制拆包为可选型
以便把它传递给我的初始值
此外 这个初始值也经过更新以便利用Swift 2的错误处理特性
因此我将向编译器表明
我知道我可以通过Try这个关键字并在末尾加上一个感叹号
抛出一个错误
因为我不想 增加大量的无助于
我将在Playground中所展示内容的错误处理代码
此外 我知道这个plist是正确的
因此我这样加载它是没有问题的
我们可以通过内嵌形式显示它
让我们把它放大一些
那么这里就是我们的城市
我们有Moscone CenterCoit Tower 渔夫码头
Painted Ladies, SutroTower金门公园 金门大桥
以及虽然不在我们的地图上但仍然在那里的
旧金山国际机场
而且你可以看到连通机场的所有路线
很棒 现在我们有了一个我们可以使用的城市
但是现在在我看来我想把这个Quick Look弄得更好一点
通过为我即将参观的所有地点增加一些图标
碰巧的是在我的桌面电脑内
我有这个图片文件夹
而如果我把它打开你会看到这里我有一组用于每个地点的图标
那么我将选取那些图标
并也也把它们拖拽到Resources文件夹内
正像plist一样 它们将被复制到那里并提供给我的Playground使用
我还确实需要更新我的Quick Look以便利用这些图片
因此我将继续并在辅助编辑器中更新 place.swift 文件
通过点击它即可
然后我会发现这个位置视图
我们要利用这些图片更新作为初始值的蓝色圆点
那么我可以选取所有那些代码
并更新我们的地点视图
我们将从获取与之关联的图片开始
创建一个图片视图然后设置几个属性 然后将其返回
现在当我保存这个文件时
Xcode 将注意到辅助资源已发生变化
并将自动重新编译它们的Swift 模块
一旦编译结束我们将重新运行Playground 
Quick Look将会自动更新
我所要做的不过是进行编辑并存储到磁盘
棒极了Quick Look 看起来好多了
让我们切换回标准编辑器
并开始研究我们的算法
我仍将隐藏浏览器
因为我不需要它而且我想要额外的空间
因此我们将执行暴力算法来找到我们通往旧金山之路
而为了开始这一过程
我们需要获取通往旧金山的所有路线
因此我们将从这个开始而我们所做的就是
通过我们在city结构体上的city方法调用所有路线
告诉它我们希望从Moscone Center开始
并且我们希望在机场结束
而如果你看一下右边的侧边栏我们发现我们有720条路线
然后我将执行算法
这里我们将从几个变量开始它们将存放我们的结果
一个用于最佳旅行时间一个用于最佳路线
然后我们将迭代所有穿城路线
为每个路线获取旅行时间
然后我们将把它与我们的最佳旅行时间相比较
如果必要的话更新我们的结果变量
最后 我们会在这里看到穿过城市的最佳旅行时间
那么我们将把它内嵌显示
并且我们将看到如果我们从不停留并设法在所有交通工具之间转车
在这些地点之间需要 235 分钟
我们也可以为线路添加内嵌显示因此我们可以看到
我们将从Moscone Center出发正如我们所期待那样
然后我们将直接前往Painted Ladies和Sutro Tower
然后到金门公园和金门大桥
然后我们将前往渔夫码头以及 Coit Tower
最后抵达旧金山国际机场搭乘我们的班机
那么很棒我们已经有了我需要的
游览景点的全部信息
那么现在让我们切换回幻灯片来解决那个问题
刚才我为大家展示了如何使用Playgrounds中的
辅助资源和嵌入式资源特性
以便在让它高度专注于您希望实现的任务的同时
让您的Playground更加强大
我这里有些非常有趣的东西
我想在会议结束回家时与人分享
但是它还不够精炼还不足以示人
然而 我们已经在Xcode 7中添加了很多不错的特性
这让您能够比以往更好地分享您的 Playground
那么现在我想邀请我的同事 马特 上台
向您展示这些特性谢谢大家！
非常感谢 康纳！嗨 大家好！
我叫 马特 也是Xcode团队的一名工程师
我觉得 康纳 和 山姆已经做得很棒了
他们搭建了一个令人惊叹的 Playground
向人们展示如何以最佳方式游览旧金山
但它还未完成不能与世界分享
因此我将为您提供几个建议和窍门
让您的 Playground更加丰富 也更吸引人
以便让您把它放在互联网上人们也会很喜欢它
那么您在这里可以看到我们有了Playground
康纳 刚刚完成了在它上面的工作
而且 康纳 也写了一个非常简单的算法
它遍历旧金山这座城市中的所有可能路线
并将其互相比较
而这对于你们大家是很不错的因为我们这里已经由 康纳
在执行算法的时候讲解了路线的每一步
然而 当我们将它与全世界分享的时候
遗憾的是并不是每个人都在这里参加 WWDC
因此我们要添加一点信息一点上下文
以便今后查看此Playground的人
会明白我们到底是怎样达到这一步的
因此我们在Xcode 6.3中推出了一个新特性
叫做Playground标记注释
而那让您对您的Playground
添加富文本格式的漂亮的显示
以便人们能够更好地理解
您究竟是如何得到你想要的 Playground 的
那么再给我一点空间我将先把QuickLook放在一边
而且我将把Playground顶部的注释
用一些关于游览旧金山的信息替换
现在您可以看到这看上去非常像个注释
您可以把它放在您的源文件的其他任何地方
但是 富文本标记注释和其他注释的最大区别是冒号
我们在注释中的第一个星号后面有个冒号
而且我们也可以对单行注释这样做
也在这里添加一个冒号
而当我来到上边的编辑器菜单
并选择Show Rendered Markup
您会发现它重新渲染
而且现在我们有了这些好看而丰富的文本块
我们可以用它们来解释我们的Playground中正在发生什么
我们实际上也可以重新安排它们的格式
因此 如果我切换回Raw Markup
我可以使用一个井字符号
表明我们希望有一个标题显示“Exploring San Francisco”
而且我可以使用星号比如在“most efficient”前后
来表明我们希望这些内容是斜体的
因此如果我再次执行它
您会看到我们有了个不错的大号字体的粗体标题
精确地解释我们将要讨论的内容
所以那是一个不错的开端
我也想给它加上更多一点注释
介绍这个Playground里面正在发生的事情
例如 所有的路线
“所有的穿城路线”有点含糊而且有点神秘
因此我将添加一点
关于这些路线如何计算出来的信息
而算法本身很可能也使用了一些解释
因此我们将把算法记录下来
而如果我再次切换回到已被渲染的标记
您会看到现在我们开始获得某种看起来更像是一本书的东西
某种用户可以坐下来查看 通读并理解的东西
我们甚至有一个不错的以粗体字显示的列表
我们通过在每行开头插入一个星号来实现这个效果
因此那是非常棒的
但是它还不够丰富
我们想把它让它更进一步因此为了实现目标
我们将采用我们很久以前在Playgrounds上推出的一个特性
它现在在Xcode 7上的效果更好那就是“实时视图”
因此我已经斗胆写了一个实时视图
我已经把它加入了附属资源
而我们先从把它与这个Playground一道展示开始
以视觉化地呈现这个算法的工作机制
那么使用实时视图的第一步是您需要导入XCPlayground
它是一个有很多确实很棒的功能的模块
它们让您用 Playground做一些非常酷的事情
现在也欢迎您在辅助资源中做这件事
比如创建一个 helper 方法用它显示您的实时视图
您不必在主Playground中做那件事
但是我将在这里做这件事只是为了更清楚地表明它的工作原理
一旦我们获取了我们的旧金山这个城市我们就准备好显示它
因此我将实例化一个视图控制器
有了我们的新的城市视图控制器
我将把旧金山这个城市传递进来
然后我将使用XCPShowView函数
将城市名赋值给它
并传入我们的视图控制器的视图
那么如果我现在切换回去
并在Playground重新执行后显示我们的辅助编辑器
我们将看到一个实时视图看上起正像是旧金山市
您可以看出我们使用了
我们已添加更多内容的更丰富的 Quick Looks
而且我们把它们设置在看起来更真实的背景上面
以便避免人们太分不清方向
那么这就是第一步但是我们也希望展示
算法本身是如何工作的
而为了达到这个目的我们将添加一些代码
当我们预演我们的算法时它会更新实时视图
因此这里我们有一个循环它对所有线路进行迭代
而我将用我的视图控制器上的方法替换它
这个方法叫做VisualizePathIteration
而我写它的时候用了尾随闭包
以便能够实际更新它因此它看起来
几乎与我们最初的循环代码完全类似
而且我还将在这里添加一行
告诉视图代码控制器：
一旦我们发现更好的路线
我们希望显示那条路线尤其是在我们的地图上
因此它会从头到尾再执行一次
而你也会因此看到
当我们在旧金山全城遍历所有路线我们将以视觉化形式展示它们
而这是很不错的因为现在正在阅读这个程序的人们
可以实际看到我们是如何得到答案如何找到最佳穿城路线的
不过您可能注意到了某些东西
那就是它将检查大量的路线
实际上它将检查 720 条路线正如 康纳 早些时候指出
而那是相当多了
实际上 实时视图默认运行30秒
您可以使用Playground右下角的控制条进行更改
而那甚至不足以遍历旧金山市的所有穿城路线
现在我们已经将其人工减慢了一些
因此 当我们在实时视图上迭代它们时您可以看到那些路线
但是我觉得的当人们看到路线时他们会说...
哦 一定有条更好的路线
实际上确实有
而且我们也乐于从一开始就把它展示给我们的用户们
因此我们将使用另一种算法
它是“最近邻近似算法”
而它将做的就是
假定我们从 Moscone 出发
我们查看我们想参观的所有地点
然后我们选择最近的一个并去往那里
然后从那个地点开始
我们将选择下一个最近的地点并将从那里继续
而如果我愿意
我可以在这个Playground文件的正下方执行那一操作
但是那将开始变得有点难以理解而且不是那么专注于目标了
Playgrounds的妙处之一在于
它们是由目标非常非常明确的内容片段组成的
因此我们希望能够维持这一特点
而为了达到这个目的我们在Xcode 7中有一个全新的特性
叫做 Pages
它让您在单一Playground文件中有多页内容
因此为了达到那一目的我们将打开浏览器
在左下角我们将点击加号按钮
并选择 New Page
而那将在同样的Playground中创建一个全新的页面
我将把这个页面叫做Nearest Neighbor
这是根据我们即将使用的算法而命名的
然后我们将把我们最初的 Playground
重命名为Getting Around
此外 Pages 的很酷的一点是
就像是辅助资源
以及您可以在顶层水平加入Playground中资源一样
你也可以在单页的基础上那么做
你可以看到我可以展开这些Playground页面中的任何一个
而且我们可以嵌入它们自己的来源
例如 任何名称相同的资源
都将优先于更大的Playground 中的那些资源
所以如果您希望在每个页面上有不同的印记
或者在您将讲授的每个页面上的概念上
有特定的图片您可以非常容易地做到
那么现在我将切换到最近邻页面
切换回 Raw Markup 页面
我已经写好了算法因此我将径直把它粘贴进来
那么我们这里是一个带有最近邻近似算法的Playground
而且您可以看出当它运行的时候
它会检查少得多的穿城路线
不过 这不是一个最优算法
原因是它不一定会找到我们的最佳穿城路线
但是您可以看出它已经完成了非常酷
因此这是一个不错的方法表明对此问题可能不止一个答案
而如果我们执行它
的话我们也可以表明
我们从哪里获得的这条路线
我们实际上是在维基百科上发现的关于这个算法的信息
遗憾的是 我缩进得有点太远了
我们可以直接在Playground中嵌入一个链接
它将把我们带到解释此算法如何工作的页面
我们也可以在单一Playground中链接不同页面
并回到我们早些时候发现的最优路线
而实际上 当我们查看路线的数量
我们所走的穿过城市的不同路线
以及该算法的执行所花费的时间时
我们检查了这页上的720条路线
并发现了一条仅比另一个页面上快21分钟的路线
那么这给了人们一个参考框架他们会说：
或许有其他方法做这件事
而他们可以用Playground自己试验
这是非常棒的
而那将在Playgrounds中
添加标记 页面以及实时视图等部分
那么我们在Xcode 7的Playgrounds中有了大量的真正令人惊叹的新特性
我们向您展示了定制化的Quick Looks
它将让您选择自定义的数据类型
并让它们与内置类型一样生灵活现
我们也有内嵌结果
它们就在Playground内部
因此您既可以让一些结果直接显示在产生它们的各行代码间
也可以在与他人 分享您的 Playground 时让另一些结果随Playground显示 
我们还有辅助资源这一特性
您可以把附属于您的Playground的但并不像主Playground内的代码
那样有启发性的代码 放在一边
以便您的用户只看到你愿意他们看到的API 和实际功能
我们还有“嵌入式资源”特性借此您可以嵌入图片
并让东西更活灵活现更吸引人
我们还有全新的标记注释特性
当您不能与用户在一起时它们真的是一个不错的
指导您的用户通读Playground的方式
经过改进的比以往任何时候都好的实时视图
以及那些 让您在单一Playground中覆盖多个话题的页面
同时不偏离任何一个主题的重心这是确确实实非常酷的
那么那就是我们在Xcode 7的Playgrounds中的内容
如想了解更多信息您可以访问我们的网站
我们那里有文稿和开发者论坛
您也可以和斯特凡·乐塞我们的开发者工具宣传官交谈
我们还有几个相关的讲座环节将要进行
包括《Swift在实践中》它将是在明天下午举行
以及《在Swift中 如何使用数值类型来打造更好的app》
此外还有本周的《Xcode中的新特性》以及《Swift中的新特性》
等环节都 将是很棒的
非常感谢大家！请欣赏 WWDC 的剩余内容！