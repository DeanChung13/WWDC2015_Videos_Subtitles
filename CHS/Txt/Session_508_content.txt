音频单元扩展
谢谢 早上好
我是道格·怀亚特Core Audio的团队
我想向大家展示我们新近研发的产品
叫做音频单元扩展
这是iOS 9和OS X ElCapitan系统的一项新技术
关于音频单元自OS X和iOS系统诞生伊始
我们就在操作系统中植入了该技术
操作系统包括许多内置单元
从I/O单元到混音器
给软件采样器提供了多种不同的特效
在我们的许多高级API中
我们都使用了这些内置音频单元
比如媒体播放栈
但是音频单元同时也是一款OS X中
广泛使用的第三方插件格式
市面上有着成千上万种
第三方音频单元
现在音频单元扩展
使我们首次在OS X和iOS系统中
拥有了全能插件模型
音频单元扩展是基于应用扩展技术开发的
这就意味着 如果你在编写插件你可以将插件
打包进App而App可以在App Stores中进行销售
作为该技术的一部分我们优化了API
同时维持了兼容性
在这次演讲中我将详细汇报这一新的API
我们将它称为第三代音频单元API
在音频单元框架基础之上
使用AUAudioUnit的Objective-C类型建开发而成
既然从属于Objective-C类别当然能够与Swift完美兼容
我们都将见证这一点
本次演讲我们还会讨论
AVFoundation框架内的其他许多类别
我们有AV音频单元组件管理器
和AV音频单元组件
用来定位系统中的音频组件
这在iOS 9中还是首次
在Yosemite系统也是如此
在今天我们将要展示的代码样本中
我们也将会用到AVAudioEngine
尤其是AVAudioUnit
和AVAudioUnitEffect类别
两者都是在去年的OS发布的
那么现在我们谈一谈兼容性
这是OS X中的情况
我们现在拥有二代音频单元主机
以及二代音频单元执行
主机与音频部件实例之间
通过信息通讯
实现执行功能
则基于音频部件出厂功能基础
我们拥有一组新的API
因此就有了使用这些API的新主机
以及植入的使用这些新的API的音频单元
主机与 AU音频单元类通讯
新的第三代音频单元会将AU音频单元纳入子类
这就成了两种不同的API
我们怎么才能确保兼容呢
我们需要在这两种API之间使用桥站
正因有了桥站我们会发现
第三代主机与现有的二代音频单元
几乎完全兼容
相反现有的二代主机只需要很小的改动
就可适应新的第三代音频单元
我将详细介绍这些API的改动
现在我将给大家展示
在经过细微改良的Logic Pro版本中
使用新的音频单元的演示
这里有一小段音乐里面有鼓点循环
我将把一个音频单元放到这条音轨上
这里所有的都是Apple内置的音频单元
这里还有一个叫做v3失真的演示音频单元
这样我打开这个音频单元
我可以找到心仪的预置方案我们可以听到Logic
通过这个音频单元播放出来
声音很干
完全失真了
现在如果我查看活动监视器
我们可以发现
这个失真音频单元在一个独立进程AU v3 失真中运作
这会消耗一点CPU
会占据一些线程
假设这个音频单元内部有一个bug它就会崩溃
我可以在活动监视器中进行模拟
我可以强制退出
注意Logic界面一片空白
但音乐还在继续播放
这是我们刚刚探讨问题的一个图
这是经过细微改良的Logic Pro
但本质上还是使用现有的二代API进行通讯
与AU音频单元桥接
进而在独立扩展服务进程中
我们看到失真AU音频单元子类
和定制的视图控制器同时运行
Logic进程中也有视图控制器
你可以看到这些是如何
进行跨进程桥接的
现在我们再看托管音频单元
我将向大家展示使用三代API的一个案例
我们有这一段称为音频单元v3 Example的样本代码
几小时前我检查过这段代码还没有写好
我希望今天它能够工作正常
在这个样本代码项目中你可以看到有很多个样靶
其中一个叫做AU主机
这个App相当简洁明了
但它展示了怎样找到并打开系统中音频单元的过程
怎样连接形成特效链
怎样选择音频单元预置方案
以及怎样打开音频单元自定义界面
因此在AU主机app中我们有所谓的简单播放引擎
也就是使用AVAudioEngine的Swift类
它使用一个AV音频播放器结点
并连接到AV音频单元特效
继而AV音频单元特效显示出
内部的AU音频单元
也就是第三代音频单元API的一个主类
播放器连接到特效器 
混音器和输出上
这就是简单播放引擎的工作原理
我们还将看到如何使用
AV音频单元组件管理器类别选择系统中的
AV音频单元组件
以及控制AV音频单元选择的特效
让我们来看一段代码
首先在使用音频单元时
我们有一个非常重要的数据结构
我们有音频组件描述
以及三个相关的主要域组件类别
子类别以及制造商
这一元组标记出系统中特定的音频单元
标记也十分重要
由音频组件部分植入
系统也会植入新的音频组件
在解说过程中我们还会对部分进行细致探讨
很重要的一点是
这是识别插件的关键
因此 为了找到系统中的音频单元组件
首先我们需要创建一个包含通配符的
音频组件描述
这里我们所说的组件类别是特效
那并不是通配符 
这里还有组件子类别和元制造商
那些才是通配符这样我们有了组件描述
可以识别任何特效了
接下来我们可以选择任意特效组件描述
应用到AV音频单元组件管理器
我们会得到与通配符相适应的系统中的
所有特效的渲染
现在我们有了一系列AV音频单元组件对象
其中包含了名称 标签
以及该单元的音频组件描述
我们得到了一系列的组件
我们可以将它放回UI中
继而UI可以在简单播放引擎中使用这种方法
挑选出一种此前已经上市的
特效组件
这样我们得到了一个组件
将它使用到一种内部的方法上
这种内部方法的本质
就是这样
我们将命名一种新的AV音频单元分类方法
这种方法需要基于这里的
组件描述创造一个实例
这是一种异步功能也就是说它会进行实例化
但真正将音频单元实例化
并且我们可以使用之后
就会自行关闭
因此这里我们可以得到回馈信号
这是Swift闭合语法
我们有自己的AV音频单元
随后我们可以将它应用到我们的引擎上
我们将它储存到一个成员变量即特效中
我们也就得到了一个可以察觉特效的AV音频单元
我们对引擎打入补丁
特效和主混音器断开
然后连接播放器和特效
然后特效再连接到主混音器节点
这样我们就在播放引擎中加入了一种特效
我们可以保存真实的AU音频单元
这是插件利用插件我们可以做各种各样有趣的事情
比如操控组件的特效预置方案和参数
例如 从这里我们将看到出厂预置方案的列表
这也将向表格视图而不是UI中
植入一个域
这样 用户可以选择出厂预置
最后我们还想向诸位展示
我们将怎样利用接下来我要展示的App
得到音频单元的自定义视图
以及怎样将其嵌入主程序视图
现在我们进入了主机的视图控制器
我们要求播放引擎给我们音频单元
然后再从音频单元中
获得视图控制器
当完成了这些步骤之后它将反馈给我们
一个视图控制器我们就将它嵌入到主视图中
好的 接下来有请我的同事迈克尔·霍普金斯
为大家演示这个App是如何运作的
非常感谢你 道格
非常荣幸今天有机会
向大家演示这款基于AVAudioEngine第三代主应用
如何在iPad上使用
正如你所见我点击一下主机的图标
就可以打开它
在屏幕的左手边我们有一个包含音频单元
在系统呈现的所有特效的列表
既包含了内部Apple音频组件的特效
也包含了我自己添加的
新扩展的第三代音频单元
在屏幕的顶端有一个播放键 
点击可以触发鼓点循环的播放
现在让我们来看看怎样应用一些特效结点
以及怎样将它们加到图表中
首先我播放一次无特效音乐
然后我再加几个特效
这样方便大家听出它的作用
利用高通率波器滤除大部分铙钹的声音
以及其他高频声音
声音略有延迟在这个屋子里不是很听得清楚
这段音乐就播放到这儿我们继续
现在我在向大家展示
在iPad上运行音频扩展单元
这将会是它的处女秀
这是一首失真的演示
当选择之后大家可以看到
音频单元所提供的所有出厂预置的列表
这里面包含了一些鼓点特别明显的方案
也包含了一些非常狂野的设置比如外星人的叨叨声
刚才道格提到
第三代音频单元在iOS上有自定义界面
我将向大家演示
我继续演示点击视图按钮
我们所完成的是从音频单元中
加载视图控制器的动作
我将它作为子视图控制器安装在App中
我们首次在主机中拥有
带有UI的内置音频单元
我们有一个很大的滑动条对不起 是按钮
可以用来控制失真的量
请允许我继续我将播放这段声音
以便诸位能亲耳判别
这真的很有趣
我们可以在一个主应用中
流畅地使用多点触控的UI
而且省去了很多麻烦
过去我们还得切换到另一个App
捣鼓半天再切回主应用
开始录音后再切换回去
现在你再也不必重复这些步骤了
谢谢
我还想指出
这个音频单元正是刚才道格在Logic里面播放演示中 
使用的那个音频单元
事实上 音频单元的源代码完全一样
无需再做修改
编码也十分相似因为编写过程中
我使用了Core Animation
以使API更为便携
要将这个音频单元植入iOS 
唯一需要做的必要改变就是事件模型
我们需要用UIKit里的触摸事件
代替桌面的APPkit鼠标事件
说真的 诸位有机会利用一点点改变
就可以在桌面和iOS上
同时发布一个音频单元
非常感谢
现场交还给道格
感谢迈克尔
我想和大家探讨一下
不使用AVAudioEngine的情况下
怎样在主操作程序中使用音频单元的问题
在使用AU音频单元类
异步创建一个组件描述实例时
我们会使用类似的方法
请看那里
对于还在使用二代主机的人来说
我们最简单的翻译途径是
使用音频组件进行实例化
我们将细致探讨该问题
现在 我想和大家探讨一下
用扩展服务进程替代插件
加载到主机进程中的问题
任何接触过音频单元的人都清楚
利用我们现有的插件模型
插件总是加载到主机进程中
对于三代主机来说也是这样
如果是一个二代插件
可能是iOS上使用的苹果插件
也可能是OS X上使用的第三方插件
但不论哪种情形都是二代音频单元
不需要考虑其他因素始终是加载到主机进程中的
现在三代音频单元讲起来
略微有点复杂
在初始状态下三代音频单元加载到
一个独立的扩展服务进程
这张图表显示的是在Logic出现之前我们所见情形
对于二代和三代主机来说
这都是正确的
现在OS X上插件只能
直接加载到主机进程中
为了使之成为可能需要同时使用到二者
在实例化音频单元时
主机需要将选项传递给
我们刚才所见到的任意一种异步创建方法
你可以看到新标记的名称
叫做进程加载音频单元
还需要利用
音频组件包列表条目
进行特殊的打包和授权
如果同时使用
那么框架将把插件
加载到主机进程
主机将会直接与插件的
AU音频单元子类进行通讯
作为一个主机编写人员你为什么想这样做呢
原因是要在安全性和性能之间
进行权衡
毋庸置疑 向App中添加第三方代码会有安全风险
如果在App中崩溃
用户埋怨的将会是你
而不是特效不佳的插件
但另一方面 出于性能考虑
如果你在做主机
你想向进程中加载插件
因为与独立的扩展服务程序通讯
会造成一些间接损耗
我们以40微秒
为一个渲染周期进行了计算
你可以自行计算一下
这在你的主机中有多么重大的意义
可能还需要与一些程序外的插件进行通讯
你还需要把这部分算上
此外你预期渲染多少声频
同样也是需要考虑的因素
比如 如果以32帧这样在每个渲染循环之间间隔为1毫秒
因此40微秒的损耗将
占据高达5.5%的比例
如果你是主机编写人员你需要做出这样的权衡
我之前提到过
现有的二代音频单元主机
在与三代音频单元共存时需要几处改变
以下便是需要改变的地方
我提到了音频组件描述标记
这里便是组件标记
这是一种称为异步实例化需求的新标记
它适用于多数哪怕不是全部的三代音频单元
如果你在组件描述中看到了这个标记
你就必须使用新的音频组件实例化方法
而不是音频组件新实例
类似的在二代主机上
如果你想进入一个音频单元的视图控制器
你也必须使用一种新的异步方法
有一种新的属性请求视图控制器
也是异步的
你可以在音频单元属性h部分中
详细阅读
关于这些异步方法
你可以利用二代单元使用新的方法
但如果有标记那就必须使用三代单元
我们的思路是
我们这么做的动机是因为这样能提高响应能力
如果实例化音频单元需要半秒
如果你释放主线程
你的主应用 仪表或者其他动画
将继续流畅运行
尤其是在更新现有代码时
这也正是我在测试内测代码时
做的第一件事
就像坐在那儿
干等主线程完成异步操作
千万别这么干
因为这样不仅会打乱你正在制作的任何图表
而且会扰乱框架的基础程序
而这些可能是音频单元实例化中所必要的
如果你干等主线程那么你将会陷入僵局
千万别这么干
现在我们把话题
从主机音频单元转到
使用三代API创建音频单元上来
首先考虑到新的音频单元模型是基于应用扩展的
我们简单聊一聊应用扩展
应用扩展是appex.文件类型扩展
Xcode将把它们嵌入App插件条目中
我们可以看到系统是如何
将它们加载到独立的扩展服务进程中的
你可以在应用扩展编写指南中
读到应用扩展的全部细节
我们新的样本代码项目音频单元v3示例
包含了一段叫做Filter Demo的
示例音频单元执行
当你研究样本项目时
你会发现Filter Demo有三个目标
它有我们所说的容器App
里面有有应用扩展
和普通代码的框架
App和扩展都链接到框架中
在框架内 我们有两种主要的类别
一种是AU v3 Filter Demo
是AU音频单元的子类别
还有一种是Filter Demo视图控制器
控制着音频单元的自定义界面
这么做最酷的一面就是
我们开发了
属于自己的信号处理和视图代码
我们可以完全在自己App的环境中完成
因此我们不再是在独立的SPC服务进程中清除bug
而是在与我们自己的App交互过程中清除bug
开发属于自己的代码
我们还让用户在打开App时
觉得看起来很不错
这并不仅仅是一种为了别人而设计的插件
我们也不是通过复制代码
才实现这一目标
这在OS X上还有一个额外的好处
如果我们想的话
我们可以指定这一框架成为主进程加载束
让我们看看应用扩展
这里有一个包含很多重要条目的info plist
NSExtensionPointIdentifier告诉系统
这是什么样的扩展
主故事板告诉系统
当打开我的扩展服务进程时打开故事板
最后 还有一个音频组件序列告诉系统
这是我在注册的
音频组件描述
简单提示一下在你的故事板中
你必须明确你的自定义类
如果你要把它嵌入一个独立框架
你需要明确是哪个模块
就像我们这里的一样
扩展本身其实没有代码
有的只是一小部分确保里面有代码
我们要链接Filter Demo框架
这里的都是好东西
我们有一个全局变量来指向它
让我们回到框架
框架中的主类别是
Filter Demo视图控制器
在扩展术语中
这是扩展的首要类别
创建或者加载扩展时
系统都会创建一个
属于这个首要类别的实例
它有两个主要任务
它创建AU音频单元的子类别
比如你所预见的视图控制器
它创建并管理插件定制界面
这是Filter Demo视图控制器类别定义
从AU视图控制器演变而来
本质上是一种NS或者UI视图控制器
还使用了一种叫做
AU音频单元工工厂的协议
那是一个简单的协议仅仅使用了一种方法 
利用组件描述创建音频单元
这一方法的任务是
创建AU音频单元的子类别
也就是这里的AU v3 Filter Demo
现在让我们看看AU音频单元的子类别
由于种种原因我们只简单地探讨一下
这些实际上是内嵌的C++类别或对象
所有算法都是在滤波器DSP kernel中进行的
我们一会儿可以听到
这比单是看它的代码有趣多了
我们有一些处理总线的代码
这是特效它有一个输入一个输出
我们的基本类别需要我们提供一连串的总线
从而有支持的数字
我们有所谓的参数树
稍后我们会弄清它是指什么
这是初始化器
我们要做的第一件事就是初始化我们的输入和输出总线
然后将它们汇总到总线序列
这些总线序列都包含一个单独的总线
现在我们看看参数
每个参数都是一个对象
每个对象你都可以把它想成
连接执行和主机之间的桥梁
中间是参数对象
这是一个简单的低通滤波器
只有两个参数
截止频率和停留
每个参数都有标识符
这里我们说截止
它有一个本地化的名字
我们做的不对这里没有进行本地化
它有地址
我们简要探讨一下它
排列这些单元或者标记
在使用二代音频单元时
你会觉得这些标记是一样的
这样我们创建了我们的第一个参数
我们会以几乎一样的方式创建第二个参数
最后我们可以创建我们自己的参数树
将这两个参数排成序列
这样我们就有了我们自己的参数树我们想要将它接通
以便与我们的DSP代码相连
我们的方法是在参数树中
安装一个叫做执行器值观测器的块
只要是主机或界面参数改变
这个块在任何时候都可以被调动
因此 针对这种改变
我们仅仅需要在我们的DSP kernel中设置新的值
可以立刻获得音响特效
反过来有时这个参数树
需要信号处理过程
更新参数值
它从DSP
获取当前值
将它反馈到参数树上
这是一种重要的替换值方法
如果你熟悉二代音频单元API
这一过程被称为音频单元初始化
这在Objective-C可不是一个很好的名字
所以我们决定要将它具体化
初始化的时间就是用来
准备渲染和分配有关的渲染资源
比如缓冲 DSP状态 等等
我们首要做的事情被称为基础类别方法
然后我们要求总线分配存储空间给插件
以便声频输入
我们可以初始化我们的信号处理
要根据现在输出总线的通道数和采样率
因此我们有一种完全相反的方法
叫做解除渲染资源分配
我们把这还称为基础类
原则上撤销我们在分配过程中所做的一切
利用块进行渲染过程
在每个渲染循环中都会用到
但我们需要在渲染开始前就提供块
我们捕获C++代码
改成作为指针局部变量
原因是我们需要在实时环境中操作块
这对于处理任何Objective-C对象来说都不安全
运行时间会阻塞
造成音频故障
因此我们将再次捕获C++代码变量
然后在放回块
它将反馈AU音频单元状态
如果你熟悉二代API
参数大体一致
有时间标记 许多样本帧
一个输出音频缓冲表
这里是一个新玩意儿叫做实时事件表头
我将详细介绍它
它还与计划参数和MIDI事件相关
最后是推动输入块
主机告诉我们这叫音频单元的执行器
获得输入的来源
因此在输入块的内部
我们要做的第一件事
就是将推动输入块交给输入C++对象
并且要求输入块为渲染循环抓取音频输入
随后我们清理清理缓冲
我们再把它们交给DSP状态
最后 DSP状态为渲染循环处理音频
缓冲器已经收到信号
只需给它一个时间标记和帧计数
以及实时事件的链接表
这便是这个音频单元的内容
但代码的全部并不止这些
实际信号处理的代码
远比这多得多
但正如我们刚才讲的那样
听远比看来得好
因此我想再次请回迈克尔·霍普金斯
向我们展示AU v3 Filter Demo
谢谢道格
我继续讲 从包含扩展的应用容器开始
你将首先看到
屏幕左边是我们的Filter Demo
我们将它分解成代码样本
右边是我之前给你们演示的失真演示应用
我将启动Filter Demo
在屏幕的顶部
你会看到
道格谈到的两个参数
在停留参数中有停止点
在UI中永一个滑动块
和一个文本域来表示
实际上 应用包括了这部分UI 
而主屏幕面积较大的图案
实际上是音频单元
嵌入视图
我可以通过拖动滑动条
来改变参数的值
看有什么变化应用改变
该参数的值也改变
视图也随参数而更新
正如您将看到更新是实时的
相反我可以直接
点击和拖动
我们嵌入的音频单元
你会注意到当我用手指拖动它时
应用接收到参数已经改变的通知
然后会依次更新
但这是一种没有音乐的
无聊演示 对吧
让我们来听一听
我能整天做这个
你有时间吗
现在真的很酷 很流畅谢谢
用你的手指就可以玩多触点UI
非常有趣
很神奇
另一件有趣的事是
因为我们以这种方式设计的用户界面
可以适应任何大小尺寸的设备
我们以这个iPad为例
旋转后看到不同的用户界面
从纵向视图到横向视图 反之亦然
我们能做到这点是因为我们支持自动布局
我们考虑大小等级 
但当我们把它放到
我们的主应用中
而主应用的屏幕专用插件更小会发生什么呢
所以我返回
打开主机
我要清除失真样本
嵌入我们的Filter Demo视图
点击视图加载
现在你可以看到
虽然加载的垂直空间很有限 水平比较大
但是仍能可以运行
没有标签重叠
它仍然完全按我们所期望的运行
这是一个奇妙的新技术
我们很兴奋 终于能够给你们
我都迫不及待地想看看在你们的iOS应用上运行的情况了
谢谢
谢谢你 迈克
现在我大概讲一下关于包含应用
这个是插件载体
通过快速迭代和快速开发提供协助
但你可能考虑在包含应用里放置其他东西
通过Filter Demo我们知道有简单播放引擎
而且你还可以加载
某些复杂的播放引擎
主体应用能满足你的需求 
你可以在其中放置触摸控制器
在插件视图里可能没有空间
储存全部触摸控制器
就算空间足够 但你可能考虑
在包含应用中
储存其他东西
这个应用还能储存文件资料
还有压缩插件视图的功能
下面是关于创建一个应用扩展的总结
如果你要在OS X系统进程上加载构架
先抛开Swift语言不讲
我们也不建议你们在OS X系统上这样做
因为Swift API可能会变化
如果你开发不兼容Swift版本一的插件
并且加载到使用Swift其他版本的主机
会出现问题
情况会很糟糕
我们知道你在这儿看到样本代码
你会试着开发自己的插件
你需要知道有三个相关指标需要开发
这有一点儿复杂
我们计划开发X code模板
但是现在你可以从随意复制Filter Demo
现在我从主机和实现两个方面 
总体讲一下
关于现代化AU音频单元API
针对版本2和版本3的属性
我们来做一下比较
版本2AU音频单元API
属性有作用域和元素
全局范围有大量属性可用
所以可以编写很多代码
K音频单元全局范围和元素0
在Swift语言中非常折磨人
很多的属性值都是无效指针
都出都可以看到无用指标
这着实让我头疼
对这些功能我们争议颇多
相比较之下 在版本3 API里
属性依旧是那些属性
我们在Objective-C和Swift语言里使用了dot语法
这样你就可以以最大帧的AU进行渲染
我们还对关键值编码和关键值观测兼容进行分类
这样你就可以对键使用值
对关键路径添加观测器
我们还对总线阵列添加专门的KVO方法
对所有的总线添加观测器这样你就不必
同时时刻注意总线
还可以在总线上添加KVO观测器
免去了许多麻烦
说到总线 在新的API中
这些都已经进行了完善
我们拥有AU音频单元总线阵列
AU音频单元有一组输入总线
和一组输出总线
并且总线有两个主要属性
他们有一种格式和一个名称
格式由主机处理
我们可以拒绝我们不想要的格式
版本3的音频单元使用的格式
与版本2 相同
让我们看一下参数
在版本2的API和参数中
这里有一些问题
因为我们改变的是属性
这里有些不实用范围元素ID元祖
此外在较为复杂的AU中 
这里的位元不足
再次我们开发了带有长参数列表的功能
我们也开发了更好的AU事件监听器API
版本3的API中之前曾在
介绍参数树和Filter Demo的时候提到
当然 这是个完整的参数树
可以对其进行分组 
这是有模拟合成器的简单模拟例子
它有振荡器组 过滤组和放大器组
这个过滤器和放大器组下还有组
在这个颜色最鲜艳盒子下是参数 波形八度
滤波器截止点和共振
包线区 维持和释放
这些盒子都是节点  
不管是组别还是参数 
在参数树上的节点都有一个唯一的永久的ID
这个像一个C标识符
所以用这些唯一的ID我们可以启动KVC
然后找到想要的参数
例如振荡器 波动或者滤波器 包线等
这让那些具有庞大的数据树
更为复杂的音频组件
变得更为灵活
现在  你会注意到
参数有数字地址
且是64个位的地址但是在任何时候
我们必须认为这只是暂时地址
因为这些地址不是我们设定的
也就是说如果我是一个主应用  
我想记录参数自动化  
我应该记录使用关键路径的自动化参数
而不是其地址
我之前提到过
AU参数对象
参数值在主机和视图之间的通讯中心
另一方面 也是音频单元执行器
现在  从主机的角度来看
参数对象属性 包括值
还有最小值和最大值等等
所以我们可进行设置
并获得使用点记法的参数值
现在我们仍然可以按照防止反馈回路发生的方式
进行数值设置  
这在性能和UI简化方面都有优势
我们不希望看到的情况是在我们滑动到下一个画面后
看到与前一张不同的通知
所以设置值的方法可以实现这种效果
并且在往参数 参数树或者参数组添加观测器后
可以看到标志
当我们这样操作时  
我们能返回参数这就是我们在底部所看到的
这里有个块称为AU参数观测器
通过观测器 我们能看到
参数改变后的地址和新值
至于执行方面 我们在Filter Demo已经了解到
有执行器 值观测器 
以及值供应块
现在 我们在Filter Demo中
将这些块安装到参数树上
也可以安装到参数树的任意位置
甚至可以安装到单个参数上
我也想展示下在调度参数方面
我们已经做到的事情
因为我想在版本2的API 中
这是个大的改进
我们有主机和执行器
可以分别处理不同事件
但这里我们还使用了AU音频单元基础分类
从而帮助我们实现该功能
所以主机能从AU音频单元获得一个模块
称之为计划参数模块
渲染过程中  调用该模块
精准改变参数
所以第一个要做的计划表是一个抽样时间
这个计划表值会累增
如果音频单元使用累增方式
例如苹果婚姻器所做的一样
最后的2个参数  
功能参数和参数地址
将被改变成新的参数值
在执行方面
事情略有不同
我们从主机那得到的 并不仅仅是传递操作
相反基础类将获得
刚我们在Filter Demo看到的
内部渲染块
它将把只属于渲染循环的实时事件
传递到渲染块上
所以基础类会保证
所有待定预订参量变换计划表的完整
只在渲染时
分配相关块到音频单元中
这就是参数计划策略
在MIDI事件中我们也做了完全相同的事情
主机在开始渲染前
从音频单元获取了一个块
在渲染时间里调用那个块
现在你可以看到我们在音频单元API版本2中
增加了一个叫做网线的功能参数
它只有1个MIDI网线 16个通道
现在我们有256虚拟MIDI网线
如果想要有巨大样品库的音频单元
现在可以做到了
所有的这些 都可以在虚拟MIDI网线中进行处理
在MIDI事件的执行方面
这与计划参数的实现完全相同
基础类AU 音频单元保护内部计划表
并仅在应该起作用的时候
在渲染循环期间 通过实时事件清单
将事件传递到内部渲染块
我们认为这是很大的改善
节省了执行器很多工作
关于渲染 总的来说 我们仍然使用拉模式
意思就是一个输出装置拉一个混音器
拉一个特效 拉另一个特效 拉播放器
音频流通过链回流
API版本2的不同点是
音频单元需要保持一些状态
这里需要提到一个概念即它是否是从其他音频单元上游
或一个功能反馈信号获得输入信号
API版本3中 就更简单了
AU并不需要保持该状态
我们在Filter Demo中
看到的反馈信号来自主机
且在每个渲染循环期间进行传递
其他的 API的功能极其相似
这使得我们可以
在它们之间快速连接
现在 若你的主机是直接调用AU 音频单元进行渲染
而不是使用AU图标或AVAudioEngine
这是会调用配置渲染源
然后将它们放在渲染块中
你可调用渲染块进行渲染
看起来和内部渲染块非常相似
这些有必要回顾一下
在渲染时间出现的音频缓冲器的一些规则
现在 主机提供了一个输出音频缓冲器清单
在输出音频缓冲器清单中 M数据指针可以是0
音频单元必须用一个内部自备的缓冲器进行取代
同时AU必须保证
缓冲器持续有效直至下个渲染循环出现
以上是全部内容  顺便说一下
和音频单元版本2完全相同我一直在重复强调
因为它真的很重要
现在 在渲染块中有一些规则
和输入缓冲器的规则相似但并不一样
主机提供输入块AU调用它输入
当AU调用那个块进行输入时
它必须为那个块提供
非0的M数据指针的有效音频缓冲器清单
现在 主机允许取代储存器的这些指针
即它拥有并可以确保保持有效
直至下个渲染循环出现或释放渲染资源
所有这些是为了达成一项重要目标
即减少重复操作
好 这里有些幻灯片
让程序员和大家开开眼
音频渲染几乎总是
在实时路径环境里发生的
这是个有限制的环境
因为我们无法分配存储器
意思是说我们甚至不需要
调用调度异步通信
事实上我们不能访问因为可能被限制了
比如获取一个互斥量或等一个信号量
原因是 若我们进行限制那么我们就限制了所有时间
然后系统中的音频渲染路径
将错过它的截止期限
这时故障就会发生
所以在使用和调用
不好意思 是使用和执行这些渲染块时需要非常小心
在Filter Demo中你可以看到我们如何准备一些块长
以致不捕捉到我们自己的目标
或任何其他Objective-C目标
在块中 我们避免了Objective-C运行时间
因为Objective-C不安全
它可以获得块
不过Swift运行时间也完全相同
这也是为什么在Filter Demo中你将看到C++目标
我们为这些C++目标捕获指针
现在如果你讨厌C++
你也可以用单纯功能的C做一样的事情
尽管我不太确定为什么你想要那么做
讨厌的东西已经说太多了
现在有请亚力克·利特尔
为我们展示Apple Music创建app中的音频单元扩展
谢谢你 道格我在Apple的音乐创建应用处工作
做的事情有GarageBand和Logic
我们很激动有新的音频单元扩展
我们认为它将为开发者和用户
提供真正的权利和创造的可能性
我会讲到
我们的一些计划
首先我们计划支持音频单元扩展
当然是在所有主要应用中支持
也就是GarageBand iOSGarageBand Mac
Logic Pro XLogic Pro 10和Mainstage
我们今天要做的是看一些例子
一些GarageBand iOS的非常漂亮的图片
这只是很初级的东西
我们会给你们一些概念
关于作为支持音频单元扩展的主机
我们将计划做什么
首先我们将支持AU工具
接下来我要说的例子是
关于我们将如何执行这些AU工具的
首先用一些图像
来解释我们将要做什么  很简单的
但GarageBand将向视图控制器进行请求
视图控制器是一个自定义UI
等下我们会讲到这个
将MIDI事件传递到音频单元
当然随后你会收到通过音频总线的音频
回到约定的图片
GarageBand我们主启动屏幕
进入接触工具传送带
这里有我们所有的接触工具
键盘 鼓 小吉他 等等这类东西
看左边  那里有这个容器
若GarageBand看到设备上
已装有音频单元
容器会展示出来
我可以滑动到那个容器
那是我的音频单元存在的地方
假若我轻敲它
可以看到设备上已经安装了所有的音频单元工具
现在如果我轻敲其中一个工具
我们可以看到一个大的灰色盒子和一个键盘 
我们将为你展示
GarageBand里面漂亮的内嵌视图里的自定义UI
我认为整件事情最酷的部分是
我们会在主机里
显示音频单元的真实情况
我们将为你提供标准GarageBand键盘
以便你可以进行操作
我们将记录MIDI并接收音频
这只是之前说到的亮点而已
当你提供这些自定义UI时
请确保不会在这里
防止任何自定义MIDI控制器类型的设备
因为我们不会在GarageBand捕捉你的MIDI
来快速看一下我们在设备上的新改动
再一次 限制屏幕空间括大了
所以在右上角有个按钮
这里可以接入控制视图
这是自定义UI
那里所有的控制另外还有一点点空间
用户可以在按钮底下的键盘上操作
这或许是我今天讲的最重要的幻灯片
这是我们在视图控制器
要注意的要点
想让GarageBand看起来更美观
那就请多注意这些要点
我们将一起做一些很酷的事情
我们真的很高兴可以看到
现在用户可以通过GarageBand
真正地操作
音频单元接口
我们也很高兴可以和你们一起工作
想出很酷的东西
谢谢你 亚力克
我想你们应该会有些疑问
我来猜猜都有哪些
iOS上的跨应用音频怎么样
这是个老问题了
有很多支持它的app
根据我们的观点
这个使用了API版本2的部分子集
且不支持某些功能
比如参数支持 预置 等等
我收到这些请求
我想我们应该有一个完整的插件模型
这就是我们现在所有的
我们并不是不赞成跨应用音频
我们只是看得更远一些
通过音频单元扩展增加这些以前没有的功能
现在在OS X上
若你有主机和音频单元
你或许会考虑兼容性的问题
连接桥将解决很多麻烦
它们是兼容的我们做了大量的工作
尽可能的让这些东西可以起作用
但如果你可以或者需要一些功能时
我建议你升级到版本3
比如说 你可能想要重做
处理MIDI事件的方法或计划参数
关于端口 我们有一个捷径
它叫做AU音频单元v2连接桥
这是一个AU音频单元子类
在AU版本2上执行所以你可以从那开始
并开发出更加全面执行器
正如迈克尔刚提到的
音频单元版本3
是iOS和OS X之间主要的交叉平台
AU音频单元上的信号处理代码绝对是最方便的途径
因为无需进行UI实现
或任何依赖设备
AU视图控制器来自UI或NSViewController
所以会感觉有些异类
但某些时候可以进入到特定平台UI
我们快没时间了
要讲的话估计需要一个小时
此刻我建议你参考
音频单元框架上的页眉文件
由于一些历史原因你需要连接AudioToolbox
主要的信头文件是AU音频单元h
但Core Audio工具箱框架上有其他的AU视图控制器
这是带AU音频单元组件的AVFoundation框架
所有的这些里面
都有很棒的信头文件所以我强烈建议你查看一下
最后如果你想要用音频单元标志
我们还有一个白色版本
你可以查看这个链接获取许可
以上部分到此结束
我们已经看到在iOS上的音频里
第一次有一个完整的插件模式
在OS X的音频里也第一次有一个完整的插件模式
通过打包音频单元成app扩展
你就可以在iOS和OS X App Stores上
销售音频单元了
我们看了带有AVAudioEngine的简单主机应用
并添加到新品
音频单元v3样本之中
如果编写样品代码时出现漏洞的话
我们鼓励大家读一下文件
然后在AU主机和实现上试试
我知道你一定会这么做的
更多信息 这是我们昨天的部分
谢谢