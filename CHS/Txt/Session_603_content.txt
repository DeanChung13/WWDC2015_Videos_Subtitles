Metal技术最新内容 第一部分
下午好
欢迎来到WWDC 2015
欢迎参加
《Metal技术最新内容》讲座的上半场
本周的三次讲座中
有许多Metal的内容
实际上 我们已经在API中加入很多新内容
所以决定要把《Metal技术的最新内容》
讲座分为两部分
那么今天
我主要对过去12个月的Metal
生态系统进行扼要回顾
像诸位这样的开发人员已经运用Metal
创造了很多应用
我会介绍我们今年推出的
部分新功能
最后 我们会通过具体实例
介绍app瘦身技术
将Metal如何与
系统的其他部分相整合
在下半场《Metal技术最新内容》讲座中
丹·大汀和安娜·蒂科诺娃
将详细介绍今年
我们用Metal新推出的
一款非常棒的支持库
或是两个这样的支持库
MetalKit可为API提供便捷
让你可以生成出色的Metal应用
和MetalPerformanceShaders
我们高度优化的着色器库
可以直接从应用调用
最后 在后一场讲座中
菲尔·贝内特
会深入介绍利用...Metal应用
实现可能的最好
表现的出色技巧
在本次讲座中
我们将介绍最新GPU
System Trace工具所以一定要看看
去年的WWDC上
我们介绍了iOS 8的Metal技术
目标是图形的重新实现
并计算API在我们的平台上
给你提供最好的GPU表现
我们通过让你和GPU之间的软件
发挥最大效用实现这些
为更形象地说明
我们现在来看
在去年的WWDC举的例子
其中描述
GPU和CPU每帧完成的工作
在本例中
头部工具条代表CPU所用时间
底部工具条代表GPU时间
正如大家所见目前CPU密集
GPU在帧的部分位置比较空闲
有了Metal 我们可以
大幅减少GPUAPI开销
有效地
将GPU作为高帧数的瓶颈
这其中最棒的是你可以利用CPU
额外的空闲时间
让游戏效果更好
例如 可以增加更多物理应用或AI
如果你可以签署更多
绘制调用来增加场景的复杂性
但是我们不会止步于此
Metal还可以实现成本较高的操作
例如 着色器编译
和状态确认
从每帧数千次的绘制时间
到发生频率不高的
加载时间均有涉及更好的是在部分情况下
是构建时间
这样用户根本不会发现任何影响
此外
在iOS 8中
我们不仅为iOS设备
引入了计算或首次面对此类计算
而且还提供了图形和计算
API之间的凝聚整合性内容
以便在支持Metal的设备上有效交叉进行渲染
和计算操作
最后
通过Metal
你的应用可以
更高效地运用多线程
而不会受到API的影响可以实现
多线程编码
结果会非常出色
去年
我们展示了
Epic开发的《禅境花园》演示
其中用到Metal实现场景中十倍
数量的绘画调用
我们还展示了EA的《植物大战僵尸》技术演示
其中使用Metal把控制台渲染引擎
才能得到支持
这就为开发界设定了高标准
在去年 我们见证了充分利用Metal API
而推出的部分
水平极高的作品
诸如SuperEvil Mega Corp公司
推出的MOBAVainglory游戏
其中运用了Metal实现每秒60帧的效果
迪斯尼的《Infinity:ToyBox 2》
Metal使其
可将控制器图形和游戏
体验带到了iOS
Gameloft的《Asphalt 8》
可以运用Metal
提高游戏可玩性将游戏中的渲染速度
比对手高出3倍
但还不仅是游戏方面
随着用于iPhone的
新版本Pixelmator推出
Metal被用于强大的
变形工具中的
加速图形处理功能
实际上
相关反响非常强烈
有相当数量的
主要内容和游戏开发人员
在OS X上使用Metal
因为我们对在iOS平台上
推出领先的游戏
控制台引擎所做承诺大部分这样的内容
才能得到支持
这包括
UnityEpic的《虚幻引擎4》
EA的《寒霜》
移动引擎
去年 我们还展示了
Metal怎样在
应用访问GPU的全局图景中发挥作用
一方面 我们有着高水准的2D和
3D场景图像API
以提供难以置信的
功能和便捷
另一方面
通过Metal
我们提供了GPU的直接访问路径
这样你可以为
应用所做的事情
就会多了很多如果选择使用
更高级的API
最棒的是
我们可以在幕后实现很多改进
你可以从中受益
而我们不需改动一行代码
今年
我们很高兴宣布了
我们做到了这些并让Metal
在整个系统技术中表现得更强大更高效
我相信这将会提升
用户在我们的平台上的体验
这也是支持Metal设备的很棒的一年
iPhone 5S和iPadAir在去年的WWDC上
都是主打产品随着iPhone 6
6+和 iPad Air 2的推出
我们现在有了支持Metal设备的
难以置信的安装基础
但是当然还不止于此
我们很高兴地宣布
将Metal纳入了OS X平台
我们在所有的
传送配置中都广泛支持Metal
实际上 自2012年起所有的Mac就已支持Metal
当然 这意味着我们会支持所有
三家GPU厂商：Intel AMD和Nvidia
其他好消息还包括
我们将大家熟悉的
iOS上的所有工具也都加在了Mac平台
这其中包括Frame
DebuggerShader Profiler
和所有API分析工具
这相当了不起
我们了解调试复杂图形
和计算应用的难度
并认为这对大家在OS X上的
开发工作意义重大
当然 所有这些在
OS X ElCapitan版本
搭建的种子中可以获得如今这一版本可以下载
OS X上的Metal
是你所熟悉的同样API
用的是iOS
增加了几项主要功能
新款API支持设备选择
离散内存
和新的纹理格式
Metal可以让你将iOS应用带入
OS X变得异常容易
这里有几个实例
开发人员正是这样做的
大家从主题演讲中听到我们在与Epic合作
将其iOS Metal开发代码带到
Mac中的《虚幻引擎》
Epic运用Metal
和延迟渲染器
在《堡垒之夜》游戏中创建这种神奇的风格效果
此外 Unity在几周内
就推出了他们的引擎
并展示了他们的《海盗村》
演示
很高兴能在OS X的Metal中看到这样的内容
我们在与若干Mac开发者合作
帮助他们通过Metal使用Metal的强大功能
同样 大家从主题演讲中听到
数字内容生成应用的相关介绍
Adobe这样的开发者
在使用Metal访问GPU
加速图像处理能力
The Foundry公司
也在运用Metal
加速其3D建模应用MODO
今天
来自The Foundry公司的杰克•格里斯雷
来谈谈他们在OS X使用Metal的经验
欢迎杰克
谢谢 拉夫
大家好我是杰克•格里斯雷
在The Foundry公司负责新技术部门
在The Foundry 我们为数码艺术家创建工具
我们的软件在全世界
用于游戏 影视等领域
包括拍摄真实的秘鲁熊
变形怪物猎人
但并非仅限于虚拟世界
我们的部分设计客户如阿迪达斯是
是在切实生产产品
如果你询问设计师
他们会告知你 任何产品都是经过成千上万次试验才会成型
我们理解这一过程
我们创造的工具
就是针对此类支持
MODO是我们的著名3D
建模动画和渲染系统
它可用来制作游戏电影和产品设计
等等很多不同的应用
我们的用户创造出
非常精彩的画面和动画在真实世界和虚幻世界中都有
在我们的MODO 9.01最新版本中
对GPU渲染器做了修改
旨在为设计者提供尽可能
高质量的流畅互动体验
这样做的好处在于如果视口是实时
你就可以完成数十倍单个软件
渲染器的决定
在iOS中 我们已经完成了部分早期工作
但是在几个月前我们有个绝好的机会
可以在OS X上开始使用Metal
我们组织了一个小团队让他们来接受挑战
只给4周时间来看他们可以将
生成多少新的MODO视口并在Metal上运行
我们机会立刻会得到一些很令人震惊的结果
虽然
这不过是小三角
但是这代表了我们的一个巨大里程碑
一旦我们可以做到这点就可以很快的取得进步
我们的进攻计划其实是从下往上
并开始将新视口的功能带到了Metal
第一天
我们是从环境开始入手
我们添加了更多的三角
加一点着色处理会
让它看似更像是真正的汽车
加上柔和的阴影
还有特殊的高光处理
加上了闪闪发亮的效果
人人都喜欢亮闪闪的东西
就这样四周后
大家还记得那个单一的三角形吗？
结果难以置信
把这些都放入Metal
仅仅用四周时间
我们就实现了
所有视口都在Metal的MODO运行
很棒的一点是
这提供了跨iOS和OS X的标准化渲染器
我们在两个平台间生成了WYSIWYG工作流
那么我们学到了什么？
首先我们了解到使用Metal充满乐趣
我使用OpenGL工作已经20年时间
我可以告知大家API轻松易用
就像是呼吸新鲜空气一般
其次
Metal中的调试和
优化工具也非常神奇
我刚说过
如果你在GPU上做过调试
就会知道为什么这点很重要
Metal的速度非常快
在部分测试中我们实现了3倍加速
这是在同样的GPU使用完全相同的数据的结果
继续来看 我们对新的视口有些很大的计划
我们想将它整合到TheFoundry公司的所有工具中
希望 能很快看到Metal
出现在有趣的地方
请拉夫回到台上非常感谢
谢谢 杰克
非常好
接下来我会聊聊iOS 9和OS XEl Capitan
引入的新功能
这样的功能有很多
只能对我们
今年新增的功能选择性介绍一番
实在没时间各个都讲一遍
我先来说说子集问题
包括GPU系列集
我们的新内存模型
纹理壁垒
<br/>和扩展的纹理支持
当然 我之前提过
在本周晚些时候的讲座中
大家可以了解到
MetalKitMetalPerformance
Shaders新的Metal System
Trace工具等更多内容
我们现在就来详细介绍
我想先从GPU开始
这是我们的Metal功能集
Metal定义了专门针对生成GPU
硬件的功能集合
Metal调用这些GPU系列
因此GPU功能集
是由iOS或OS X平台所定义
Family Name主要针对
硬件生成
版本则可以
让我们随着时间推移增加功能
询问功能集意义不大
只需在Metal设备上
调用supportFeatureSet 来决定是否GPU系列即可
这里是iOS功能集矩阵
大家会注意到我们会支持
两个主要GPU系列
和版本来区分
iOS 8
和iOS 9功能
在OS X中
GPUFamily1 v1功能集代表
我们将在OS X ElCapitan推出的新功能
这在桌面平台定义了支持Metal
设备的基础
现在 我想谈谈
两个新的着色器常数更新我们所添加的API
首先来看看背景
对于在命令缓冲区的每个
绘画编码都需要发送给
着色器部分常数数据
若要每个绘画都有单独的
常数缓冲区那么效率就会变得极低
所以一般来说 大多数Metal应用
会每帧分配一个单独的常数缓冲区
接着在为绘画编码时
将常数数据增加到缓冲区
代码会是什么样呢？
首先 我们为
常数缓冲区和数据设置
正如示意图在绘图环中
你发送新的常数数据
或将新的常数数据圈入常数缓冲器
现在 值得注意的是
setVertexBuffer调用
实际上在做两件事
它在设置常数缓冲区
也在更新其中的偏移
现在 在这两个操作中 设置常数
缓冲区的调用造价最高
Metald的API可以实现
分离这两个操作
并将造价高的调用
用来设置常数缓冲区
或顶点缓冲在绘画环之外
如果每帧有数千绘图调用
这就会有大量的节约
但是如果你只有少量的常数数据
让Metal来管理常数缓冲区效率
也许会更高
Metal有setVertexBytes API
你可以用它来为
每个绘画调用增加新常数
实际上 关于这一点我还要补充一些
我说过
如果只有少量常数
API很好可以有数十字节常数
如果有更大的常数集
你想在
其他API中使用
很可能 这样会效果更好
好 我现在来谈谈新的内存模型
新内存模型的目标是支持统一
和离散的内存系统 而无需
做出太多改变
Metal现在支持离散内存
这是高速内存部分桌面的
GPU可以访问
我们实现这些的方式
是通过新的存储模式
你可以明确
资源在内存中的位置
模式可以是共享
专用和
托管状态
在接下来的幻灯片中
我会依次来介绍
先来看看共享内存模式
这就是在iOS 8
现有执行的模式
在统一的内存系统用于存储
缓冲区或纹理的
内存共享于CPU和GPU之间
内存只有一份拷贝
内存在命令缓存区边界方面保持一致
也就是说在通过CPU访问之前
需要用GPU做此番处理
这会令它易于使用
但在iOS 9
和OS XEl Capitan中
我们引入了专用存储模式
专用内存
只能通过渲染 计算
或传送操作由GPU进行访问
专用内存的优势在于性能
Metal可以用最便于GPU
访问的方式存储数据
例如 使用帧缓冲压缩
专用存储模式与离散内存系统
配合很好可以将资源
放入GPU可以最快访问的内存中
现在 只有在OS X中
我们引入了托管存储模式
有了托管内存资源就可以在
离散内存
和系统内存中进行存储
Metal管理着两个拷贝的一致性
这样可以提供分享存储模式的
便捷性和灵活性
在多数情况下
是专用存储模式的性能
如果你有统一内存系统的
桌面系统
就你不必担心
托管额外的开销
只有Metal维护的资源的一份拷贝
如果要调整CPU或GPU的数据
还有另外两方面需要
考虑
首先
如果要用CPU调整数据
则要通过调用缓冲didModifyRange
或纹理replaceRegionAPI 让Metal了解
同样 如果要读回数据
则需要调用synchronizeResource API
还要注意的是
在真正用CPU读取
数据前 要等到操作完成之后才行
我们现在来看之前展示的
着色器常数升级实例
这个实例正在使用共享内存
在离散内存系统中
你很想让常数
在离散内存中
这就可能要用到专用缓冲区
还是必须要将转移托管到缓冲区
使用托管缓冲区则要简单很多
有它就会相当容易
只需要做两点
首先
在生成常数缓冲区时
必须明确托管存储模式
然后
要调用didModifyRange
告知Metal 你已经用CPU升级了常数
就这样
代码的其余部分仍然保持不变
值得注意的是在默认情况下
缓冲区可以在所有平台共享
在iOS
在默认状况下纹理也是同样如此
但是在OS X上
我们选择为纹理托管
制作默认模式因为它可以允许
编写携带版代码而不影响性能
但是在有些情况下你不会想要
使用托管纹理
这就是其中之一
当你有帧缓冲区
或可渲染纹理时
你想用专用存储模式
还获取最佳性能
如果只有GPU可以
访问数据这就非常重要
这就是我们在Metal中的新内存模式
我想来介绍Metal中的两个部分功能
都是OS X特有的我觉得你会喜欢
首先是分层渲染
API的意图是要
让你可以将绘制的
每个三角形的纹理
的具体层次都能进行渲染
因此这可以是数组纹理的切片
3D纹理的平面或立体纹理的表面
在每个三角形的基础上你可以明确
要渲染哪一层
只要在顶点着色器中
明确数组索引即可
游戏《堡垒之夜》就是用的这种技术
为部分环境照明渲染立方体
贴图的表面
我们认为 你也会觉得这个功能同样有用
第二个功能也是OS X所特有
就是纹理壁垒
在默认状态GPU会倾向于覆盖
绘画调用的执行
不能在随后的调用中
可靠使用绘画调用的输出
而无需某种形式的显性同步
Metal现有一个API
可以在这些
绘画调用之间插入壁垒
对于在OS X
执行有效的可编程混合非常关键
API很易于使用
只是在你想要同步的绘画操作中间
插入壁垒
最后 当然不是最不重要的内容
我谈谈
今年Metal的扩展纹理支持
在默认条件下
iOS中所有纹理的
最大限制已经增至8k
我们还增加了OS X的立方体数组支持
在所有平台上的各板中
都能提高防叠效果
我们还大量增加了像素格式
便于在计算着色器编写
或读取数据
还有是纹理使用属性
这可以实现对纹理标签
告知Metal 你准备怎样使用它们
Metal会对使用进行优化
例如
如果你有可渲染纹理时
想要设置renderTarget
和shaderRead旗标
这会告知Metal
你计划在纹理上
所渲染 然后还要从中取样
默认状态下
使用是未知的
Metal不会做任何假设纹理会如何使用
允许Metal在系统的任何地方进行使用
与iOS不同
桌面GPU 更喜欢
单独境深模板纹理
我们添加了两个新的组合境深模板格式
32-8格式
在所有硬件
iOS和OS X都会支持
不过只有部分会支持24-8格式
如果这意味着是精度要求
就需要检查是否可用
我们来谈谈纹理压缩
所以所用压缩格式类型取决于所
针对的设备
以及编码的数据类型
在iOS
我们支持若干格式
包括PVRTC
ETC2
和EAC
对于GPUFamily2的新增内容是
我们也支持ASTC
因此ASTC是高质量压缩
要比相同大小的
PVRTC和ETC要好很多
它可以实现对若干不同格式的
图像内容
高度图
法线图等等进行编码
它还提供了尺寸和质量之间的
细粒度控制
每个像素为1到8 bits
在低端
这是PVRTC所需的一般存储
最后
如我之前提到
这只在支持GPUFamily2的
设备上可用
所以 大家要留意这点
最后 在OS X中
我们介绍了桌面GPU
支持的所有原生纹理压缩格式
这些BCn格式
大家应该都很熟悉
如果是在桌面平台
或游戏控制台工作过
你可能已经有了这种格式的资产
这是我们的扩展纹理支持
我今天就介绍这些功能
我想换个话题
谈谈一种
名为app瘦身的新技术
在上次讲座中大家可能听到过一些
这不是Metal特有的功能
但是它是基于
以前我在讲座中之前介绍的GPU系列
首先 设定上下文
开发人员典型的游戏开发
和开发流程在我们的平台上
基本是这个样子
你一般会有艺术管道
来生成部分资产
资产是通过Xcode搭建
或自定义工具管道
是二进制格式
然后二进制格式再
发送到App Store的某处这个具体的
或是相同的二进制要部署到
你的所有用户的设备中
这样很好
但是一旦开始有了具备具体设备
功能的资产
就会开始遇到一些问题
例如
如果有些资产是专门针对
Metal设备
有些资产是特别用于旧式设备
现在必须要下载两种版本
以便用于所有的用户设备
显然 这并不理想
App瘦身可以通过允许按照功能
为资产贴标签 来解决这个问题
这样只有设备需要的资产
才会真正下载到设备中
具体怎么做呢？
app瘦身
可以实现
跨越两级来定义功能
即GPUFamily版本
和设备内存大小
这就会生成一个矩阵可以用来针对
具体设备
我们现在来看典型的法线图实例
理想状态下 你希望将法线图压缩存储
EAC是不错的格式
但是因为部分
就是设备不支持压缩纹理
特别是EAC你可能需要
该资产的未压缩格式
app瘦身可以为资产加标签
并仅下载
压缩格式到支持Metal的设备上
未压缩版本到旧式设备中
但是app瘦身的功能还不仅如此
我们来继续扩展实例
它可以支持更多设备
具体在本例中我们将生成5个资产
我们先从高分辨率的ASTC版本
用于最强大的2GB设备
然后 我们会包括稍低的分辨率
用于1GB版本的设备
因为部分Metal设备并不支持ASTC
我们也会包括EAC版本
然后 对于旧式设备
我们有未压缩版本的资产
我们可以把这个实例进一步扩展
通过最低未压缩资产的较低
分辨率的版本用于较低端的设备
512MB的配置
你可能不希望生成5个资产
但是我想要说明的一点是
你有着极大的灵活度来
锁定具体设备
为用户生成最佳体验
Xcode整合了很好的UI 可以
这样来为资产加标签
首先需要做的是定义你要
锁定的设备功能
这会生成小矩阵
然后只需要
留下资产
以便与GPUFamily系列的
相互交叉和准备锁定的设备内存大小相匹配即可
这非常简单
但是 当然我们
意识到并非所有的开发人员都有
存在于Xcode的工具管道
所以我们也包括了这些
我们支持app瘦身的JSON文件格式
以便明确资产分类
正如在Xcode一样
你需要明确GPUFamily版本
以及希望包含在分类中的各资产的
设备类型
一旦将资产分类定义完毕
怎样在运行时间获取数据呢？
答案就是NSDataAsset类
它可以提供与运行设备的
功能相匹配的资产
通过NSDataAsset很容易做到
只要
用赋予资产分类的名称
分配NSDataAsset对象即可
然后在数据中使用
通过我开始展示的示意图和法线图
实例来把它接合在一起
在这种情况下你的艺术家可以
生成一系列法线图部分压缩 部分未压缩
锁定你想要的具体设备
可以通过Xcode或自定义工具管道
做成二进制格式包括很多资产的
庞大二进制格式上传到App Store
最棒的是
只有用户所需的法线图
才会下载到他们的设备中
这就是app瘦身
我们认为 这将会改变大家
在支持Metal的设备上
生成和部署内容的方法
这就是在过去12个月间
Metal生态系统
的旋风之旅
我们看到像诸位这样的开发人员 使用Metal
生成非常出色的内容
我们将Metal带入了OS X
我们也将所有出色的Metal GPU工具带入OS X
我们引入了部分强大的新款API
相信大家一定会喜欢
最后 我们谈到了Metal怎样与
系统相整合通过app瘦身技术来实现
总之 这是相当不错的一年
我们非常渴望看到大家
在来年能对Metal有怎样的出色应用
请来访问我们的在线文档资料
还可以到支持论坛看看
如果问题没有得到解答 当然还可以
联系我们的游戏技术开发顾问
阿兰·斯卡夫
本周还有两场讲座
《Metal技术最新内容》下半场
安排在周四上午
《Metal性能优化技术》讲座则是
在周五
请务必要记得参加
非常感谢