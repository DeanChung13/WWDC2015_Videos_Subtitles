在Metal中有什麼新內容第二部分
謝謝
早上好 歡迎來到第二部分的講座Metal展示中有什麼新內容
我叫丹·大町市
我是蘋果GPU軟件架構團隊的工程師
今天我的同事 安娜·吉洪諾夫和我將會談一談
基於Metal的技術
有助於在iOS 和OS X上向你提供令人
驚歎的渲染體驗
因此這是三個講座中的第二部分
在本年度討論Metal的WWDC上
第一個講座中
羅布·多啦夫 談論了去年對Metal的開發
他還描述了我們剛剛發佈的Metal的新功能
他還描述了它的瘦身功能如何與Metal應用完美匹配
在本次講座中 我首先要談到
Metalkit方便的APIs使你更快捷地使用Metal應用
然後 安娜 將會談論Metal性能着色器架構
在具有A8處理器的iOS設備上
它可爲可用的公用數據並行操作
提供很好的着色器
明天你將有機會
來聽取Metal性能優化技術講座
在那裏將介紹Metal系統追蹤工具
且向你提供一些有效的Metal應用的最好的範例
現在就開始介紹用於Metal應用的
Metalkit實用功能
因爲Metal是一個低級的API你要做許多事情來建立和運行
MetalKit希望使用這個
來爲經常使用的場景
提供有效的實現
這樣你就可以很容易創建和渲染
並且我們對標準的庫存代碼
增強了性能和穩定性
你自己就可以實現
你需要很少的維護
因爲維護的負擔從你轉到了我們
這樣MetalKit由三部分組成
第一部分是MetalKit視圖
一個介於iOS和OSX之間的統一的視圖類
用於渲染你的Metal場景
第二部分是紋理載入器
用於創建磁盤上的圖像文件的紋理對象
最後Metal Kit的模塊I/O集成
上載和管理來自Metal渲染的網格數據
MetalKit視圖是獲Metal視頻渲染的最簡單的方法
它是iOS和OS X的統一類
它在這個兩個操作系統上提供了幾乎相同的接口
但是它本身是iOS的UI視圖的子類以及OSX上的NS視圖的子類
它的主要工作是爲你管理可顯示渲染目標
並且爲這些渲染目標
自動產生渲染路徑描述符
它的超級靈活之處在於
它可以執行你的繪製代碼
你可以使用一個基於定時器的模式
該模式可以在有規律的間隔內
與顯示同步執行你的繪製代碼
或者你可以使用基於事件的模式
每當發生觸摸或UI事件時該模式在就將觸發你的繪製代碼
這樣你就可以對那個事件做出響應
最後也許你可以在
你的幀頻率下第二線程上的開放環路下
驅動你的繪製代碼
因此有兩種方法使用MetalKit視圖
最簡單的方法是執行一個代表
來處理你的繪製及重新調整運行的大小
在這個實例中你可以執行在視圖中繪製方法
來處理你的包括對任何渲染命令編碼
的每幀的更新
你還可以執行按尺寸佈局視圖的方法
來處理你的視圖的尺寸的改變
在這裏你可以更新投影矩陣
或者改變紋理的大小
以更好地匹配你的顯示區域
如果你有其它的需要改寫的視圖
可將MetalKit視圖設爲子類
在iOS的這個實例中
你將要改寫繪製矩形方法
來處理你的每幀更新
以及佈局視圖方法來處理大小調整
同樣的在OSX上你要處理
你要改寫這兩種方法繪製矩形
和設置楨大小方法
在這裏有個設置視圖控制器的例子
也可以作爲我們視圖的代表
在視圖無法加載方法中我們在接收到針對視圖的一個引用後
我們將我們自己指定爲代表
在OS上特別重要的是我們需要選擇
和設置一個Metal設備
一旦我們完成了 我們就可以配置
一些視圖的功能包括
針對色彩、深度和模板緩衝
的自定義像素格式
我們還可以通過將
採樣計數功能增加到數值1以上來使用多重採樣
或者我們還可以設置我們的自定義清除色彩
這裏有個實現每幀更新的
MetalKit視圖的最基本的使用方法
在我們的繪製視圖方法中我們叫做視圖渲染
是renderpast descriptor
你首次訪問每個畫面的這個功能
該視圖就會調用核心動畫
並且獲得一個可繪製返回
在這裏你可以對渲染命令編碼來進行渲染
這樣我們就渲染了我們最終的render pass
就會在這個可繪製中展現出來
然後我們就將展現這個可繪製
它保存在視圖的當前的可繪製功能中
並且我們將提交我們的指令緩衝器
因爲構建你的每幀更新很重要
讓我花一分鐘
來說說管理這些可繪製
這樣這個系統中有有限的可繪製
都由核心動畫來管理
由於它們通常只有幾個 因爲
它們的大小佔用了一些空間
這些可繪製通過許多級別的
顯示管道層被同時使用
這裏大致說下它是如何工作的
首先你的應用程序對要在可繪製上渲染的
指令進行編碼
當你的應用程序對下個幀進行編碼時
它將那個可繪製向下發送到GPU
GPU對那個畫面進行渲染 核心動畫
在這個階段可以和其他層一起
對那個可繪製進行合成
最後顯示器獲取了可繪製
把它放在屏幕上
顯示器不能用任何東西來替代它
直到可獲得另一個可繪製
如果前面的任何階段花費了很長時間
它只能等一會兒
顯示器不能將那個可繪製反向循環
直到你的幀上有它有可用的東西
讓我們來看看你的帶有這些可繪製的應用框架
首先你調用保留有一個 可繪製的
MetalKit視圖當前渲染描述符
然後用你想要的渲染指令對那個可繪製進行編碼
最後你呈現和提交那個會將它發回到核心動畫中的可繪製
一切都好如果我們只是渲染一個單獨的render pass
但是很有可能我們將做其他的操作
如一些應用邏輯對
無須可繪製 用offscreenrender pass進行編碼
或運行一些物理計算核心程序或其他程序
在這種情況下我們本質上是在佔用我們未來可繪製
因爲在後續幀中
我們會調用這個當前的渲染描述符
它會呆在那兒
等待成爲可用的 可能等不到
因爲我們正在做其它的操作並且將它
保留了比我們所需的更長的時間
因此要解決這個問題
讓我們在訪問當前渲染描述符之前進行這些操作
我們注意到這不是
MetalKit特有的問題
如果你在直接訪問核心動畫的時候滾動視圖 你會注意到這個問題
因此在任何情況下這種信息都很有用
這裏有個每幀渲染更新的更完整的例子
首先 如所述我們想要更新我們的應用程序的渲染狀態
對任何的offscreenpasses進行編碼
做任何我們不需要 可繪製的東西
然後我們就能夠繼續像以前那樣
獲取當前渲染通道描述符
爲最終的pass的指令進行編碼然後呈現和提交我們的指令緩衝器
關鍵點是這兩個階段
越靠近越好
它是我們保持資源的臨界區段
我們不想將它保留時間過長
關於視圖的就說這麼多
讓我們開始討論紋理載入器
紋理載入很簡單
你給一個引用然後你就得到一個成形
的Metal紋理
它不只是簡單而且功能齊全
它異步解碼文件
並且在分別的線程上創建紋理
它支持許多通用圖像文件格式包括
JPG、TIF和PNG還支持PVR
和KTX紋理文件格式
這些格式的有趣之處
是它們以原始形式保存數據
並且可以上傳到你的Metal紋理中
不需要任何的改變
另你可以將MIT maps數據編碼
成其他類型的紋理
包括3D紋理、立體地圖和紋理數組
它的用法很簡單
首先我們通過提供一個設備
來創建了一個紋理上載器對象
然後一旦我們有了那個紋理上載器對象我們就能用它創建許多的紋理
首先提供一個圖像文件的URL地址
然後就可提供許多的選項 
包括 如何處理文件中的sRGB信息
或者是我們是否想在創建這個紋理的時候
爲MIT maps分配內存
最後我們要提供一個完成處理塊
只要紋理載入器已經完成了
上載紋理並且創建了它就會執行塊
它會將紋理處理器發回給你你可以將它保存在以後
需要時用來渲染
紋理載入器非常簡單
讓我們繼續進行Model I/O
模型I/0是一個新的結構是與
iOS 9和OS XEl Capitan一塊引入的
它的一個關鍵特點是
它可以爲你上載許多的模型文件格式
如果你需要可以爲你專門格式創建
你自己的導入器和導出器
這裏非常酷的特點是
做offline baking操作
可創建靜態環境光遮蔽地圖生成光照圖
它還包括你的網格的立體像素化
它提供了一種集中於你的渲染代碼
和寫入你的着色器的方法
你不需要創建一些parchers
來將一些東西從磁盤中取出
你必須少和串行打交道
你只需要上載一個帶有Model I/O的模型文件
把它放入你可用它做渲染的一些構成中
開始寫入你的着色器
MetalKit在這種情況下提供了什麼
它的程序有效使用Metal的Model I/O
它提供了將Model I/O網格優化上載到Metal緩衝器中
MetalKit對象內部的網格數據封裝
有許多函數用於爲網格數據
的Metal管道做準備
讓我來指導
如何用Model I/O來上載一個模型文件的步驟
並且用Metal來將它渲染到屏幕上
這裏就是我們要採取的步驟
首先創建一個Metal渲染狀態管道
我們將用來創建我們的網格來渲染我們的網格
然後通過初始化Model I/O asset
用asset來上載模型文件
我們就可以創建MetalKit網格
以及子網格對象
最後用Metal來渲染那些對象
因此集中於創建一個Metal渲染狀態管道
我們要特別注意
創建一個頂點描述器
該描述器將會對需要的網格提供給管道的頂點的佈局進行描述
這裏是頂點着色器的基本內容
它使用限制符級基本上
說明瞭我們每個頂點的輸入它們的佈局
用我們的objective-C代碼使用頂點描述符
對着色器以外進行描述
它使用了這裏所定義的
頂點輸入架構
這個頂點輸入架構的主要部分是
這些功能我們要使用這些指數來連接
Objective-C編碼的外部和內部
注意這些浮點矢量類型定義了數據在着色器中的樣子
不是實際上數據從我們的
Objective-C編碼送入
着色器的樣子
對此需要創建一個頂點描述符
我將把這個頂點輸入結構
放在這作爲參考但是我要提醒你
它定義的不是被送入到着色器時
的數據的佈局
我們實際上創建的是下面的Metal頂點描述符
我們要做的是針對屬性0
用三個浮點 三個浮點值
來定義這個位置
對於屬性1 色彩將由
四個無符號的字符組成
不是上面的四個浮點 四個無符號字符
它緊接在位置數據之後
有12個比特的相位差
對於屬性2的紋理座標
我們將定義它用了兩個半浮點
它緊跟在位置和顏色數據之後
有16比特的相位差
通過將緩存器的stride設置設爲20
將每個頂點的大小
規定爲20比特
這樣就定義了我們的頂點陣列
內的每個頂點的佈局
這樣我們就得到了我們的Metal頂點描述符
我們能夠將它分配到我們的渲染狀態管道
並且用渲染對不起 用渲染管道描述符
我們就能夠創建一個Metal渲染狀態管道
現在我們開始上載我們的asset
用Model I/O來完成那個任務
我們實際上使用我們在
前一步創建的頂點描述符
一個MetalKit網格緩衝器對象
一個網格緩衝器分配器對象
在我們繼續向下講時
我多說幾句強調一下它的重要性
Model I/O頂點描述器
以及Metal頂點描述器非常類似
但是儘管Model I/O頂點描述器描述了
網格內的頂點屬性的佈局
但是Metal頂點描述器描述了
作爲渲染狀態管道的輸入
的頂點屬性的佈局
它們專門設計成看起來相似
因爲它們包含屬性和緩衝器佈局對象
原因是這樣就簡化了將一個對象翻譯成另一個的過程
在Model I/O頂點描述器中的每個屬性
都有一個可識別的字符串庫名稱
Model I/O分配了一個缺省的名稱 如果模型內不存在
或者是那個模型文件不支持這些名稱
這些名稱包括位置、法向量、紋理、座標顏色等
Model I/O用基於MDLVertex
屬性常數的字符串來定義這些
有許多文件包括你可以自定義那些名稱的
Alembic文件格式
注意 如果你要改變名稱
你需要用那些自定義名稱來訪問這些屬性
所以我們建議你創建一個自定義Model I/O頂點描述器
因爲在缺省下Model I/O上載的頂點
爲高精度
而且佔用大量內存的浮點類型
這是使用Model I/O的優勢之一
你實際上可以上載一個模型格式
具有你所喜愛的任何形式的頂點數據
將那個數據變成你能夠實際使用的格式
在這種情況下我們想用最小的類型
提供給管道
以滿足你們的精確性要求
這將提高你們的頂點帶寬效率
當你們在將每個頂點提供給管道的時候
你實際上不想要一個膨脹的頂點
這裏就是我們前面定義的
當創建我們的Metal頂點描述符時的佈局
現在我們通過從Metal中調用MTKModel I/O頂點格式
來創建我們的Model I/O頂點描述符
我們所提供我們的Metal頂點描述符
就構建了這個Model I/O頂點描述符的大部分
然而我們還需要爲每個屬性標個名字
這樣Model I/O就知道我們談論的是什麼
因此對於屬性0我們用頂點
屬性位置名稱來標記
類似地如屬性1和2 我們用
顏色和紋理座標屬性來做標記
這裏我們要做的另外的事是我們要創建
一個MetalKit並且我們會提供一個Metal設備
這個對象所做的就是允許Model I/O來
直接將頂點數據上載到GPU備份內存中
你不一定要使用一個MetalKit網格緩衝器分配器
但是它所做的是爲網格內的
這些頂點和指標緩衝器分配系統內存
當你想真的要渲染它我們需要從系統內存拷貝到
GPU備份內存中
因此爲了更有效最好使用這些網格
緩存分配器中的一個這裏我們要說下如何使用它
我們要上載我們的asset文件
我們將提供URL地址
將會告訴Model I/O如何對
每個頂點進行佈局的Model I/O頂點描述符
我們還將提供該網格緩存分配器
這樣Model I/O就能直接上載數據到
GPU備份內存中
現在我們獲得的我們的asset
讓我們真正地來創建一些MetalKit網格
以及一些網格對象
這裏是通過Model I/O
來創建asset的一個例子
在asset的內部我們可能會有相機對象
光照對象...
以及對我們目前非常重要的網格對象
MetalKit首先與這些網格對象相關
它並不直接與光線和相機對象打交道
因爲那種數據取決於你的自定義的着色器和你的引擎
你可以真的探究這個對象或者向內查看這個對象
取出相機和光亮信息插入到你的着色器中
但是MetalKit並不直接參與到那個過程中
因此我們所能做的就是直接將這個asset
傳到這個網格中網格來自asset類函數
將會創建MetalKit網格的陣列
讓我們看看這個網格對象內部都有什麼
首先是這些頂點緩存器
包括位置屬性
法向量屬性 紋理屬性等等
在我們的例子中 我們只需要一個陣列
因爲我們對所有我們的數據進行交錯
然而我們用多重陣列來定義佈局
因此你就會有多重頂點緩存器
你可以定義那個屬性0可以在
一個單獨陣列的內部這樣你就會在一個陣列
中有一陣列的位置在下一個中有一陣列的紋理座標
下一個是色彩陣列等等
該網格還包括一個定義了這個
佈局的頂點描述符
與我們初始化我們的asset時
剛剛創建的和送入的是相同的對象
網格包含有許多的子網格對象
每個子網格對象的主要部分是這個變址緩存器
它引用頂點緩存器內部的頂點
另外你能夠使用許多屬性
來用Metal調用一個繪製
獲得了Metal kit網格和子網格對象
讓我們繼續來渲染它們
首先我們要循環訪問每個頂點緩衝器
可能有稀疏陣列 因此需要確定
每個緩存器裏真的有東西
但是一旦我們確定了我們就可以繼續
並且在我們的渲染編碼器中設置頂點緩存器
頂點緩存器實際上有兩個屬性
緩存器本身以及緩存器內部的相位差
它是你的頂點數據駐留的地方
我們還需要提供一個緩衝索引告訴管道
數據的精確位置
就可以真正地渲染我們的網格了
我們將循環訪問每個子網格
並且調用我們的繪製指數基元
注意這個子網格具有
這個繪製指數參數的所有參數
今天將這個MetalKit基本樣本
發佈到WWDC 2015網站上
我希望你們將它下載下來
它描述了許多我介紹的技術
它使用Model I/O來上載這個塞入一個OBJ文件中的
小型飛機對象並且創建一了個MetalKit網格
並且將它在屏幕上進行渲染
這樣你就能明白究竟如何去做
我鼓勵你們多看看
我的就這麼多我叫丹·大町市
如果對我今天討論的題目有什麼問題
我明天就在Metal實驗室
我想要歡迎我的同事安娜·吉洪諾夫
上臺來談Metal性能着色器架構謝謝
早晨好
謝謝你 丹謝謝你的介紹 我叫 安娜
我將和你們談談Metal性能着色器
讓我們開始
首先Metal性能着色器是什麼
它是Metal內 的用於GPU的
優化性能數據並行算法
你什麼時候和爲什麼要使用它？
如果你在寫C代碼並且你要
填加一個C代碼排序算法
到你的CPU應用中
你肯定不會抓來一個就用除非出於你自身的利益
你更有可能使用函數庫提供給你的實現
因爲它已經經過了調試和優化
同樣如果你想要在我們的平臺上
添加一個圖像處理操作到你的CPU應用程序中
你將會使用加速架構
因爲它使用了vlmage
它是一個強大的
高性能的調整圖像處理架構
因爲它使用了CPU的向量處理
這只是幾個例子
重要的是可以爲你的CPU應用程序
提供豐富的環境
對於GPU情況有些不同
你的選擇變少
但是我們將會改變這種情況
我們的目標是豐富我們的Metal編程環境
我們選擇了一系列的通用過濾器
我們知道這些通用過濾器通常使用
在你的圖像處理應用和遊戲中
這些算法爲iOS進行了優化並且
可以使用於A8處理器的IOS 9中
Metal性能着色器架構有兩個目標
性能和容易使用
將它設計成容易融合到
你的Metal應用中
讓它直接在Metal資源上進行操作
它們是輸入和輸出
我們不只是給你提供一批的這些高性能
優化的極好的核心程序
我們還十分關注
啓動這些核心程序的必要的宿主代碼
我們對如何將並行計算分離
的決策流程也很重視
你所要做的工作就是將這個架構的優勢
應用到你的應用程序中
通常只需要幾行的代碼
它簡單地就像是調用一個庫函數
現在我就像你們介紹這個架構
讓我們看看可用的操作
這裏是個完整的列表 我們從頭開始
實際上我只是挑幾個說
並且我還要舉例說明
首先該架構支持直方圖過濾器
直方圖均衡和規格過濾器
均衡和規格過濾器
允許你改變你的圖像
中的色彩強度的分佈
均衡過濾器是個很特殊的例子
它將當前的分佈
改變爲統一的分佈
而規格過濾器使你能夠設置
你所選擇的任何分佈
你指定將要在過濾器中使用的直方圖
這是均衡過濾器的一個例子
它增加了圖像的整體對比度
這裏它描繪的天空中的彩虹非常美麗
我想提醒的一件事是
這些過濾器並不是其本身的結束
它們可以在一個更加複雜的算法中
用作中間步驟
直方圖過濾器可以用來實現
tune mapping的中間步驟
這種技術常用於圖形開發者來
接近高動態範圍的外觀繼續
我們還支持Lancos重採樣
它是高質量的重採樣算法
可以用來縮減 放大壓縮和拉伸圖像
在這個例子中 我垂直地拉伸圖片
並且水平地擠壓圖片同時還保存
圖像的內容
你還可以支持閥值過濾器
如果與Sobel過濾器鏈接在一起
它還可以被用來查找圖像的邊緣
讓我們來看個例子
這是閥值過濾器的輸出
現在它進入Sobel過濾器來給你提供圖像的邊緣
最後支持整個範圍的卷積核
包括通用卷積在這裏你可以指定你自己的
卷積矩陣
我們還支持高斯模糊
box tent和Sobel過濾器
我最後的例子將是高斯模糊
你們都應該很熟悉
我們想在我們的UL中使用
你想要在你自己的應用程序中
使用高斯模糊會怎麼樣呢
性能着色器架構會使它非常簡單
你要問有多簡單？
我預先告訴你
只有兩行代碼
首先你必須創建一個模糊過濾器對象
然後你必須將這個過濾器編碼到指令緩存器中
謝謝大家
有一件事我想再次指出和提醒的是
API將你的通用Metal資源看作是輸入
你的設備、你的指令緩存器、你的紋理
這些都是你已經在你的應用程序中
創建的Metal資源
現在我已經向你展示了這兩行代碼
讓我們看看它們插入到你
當前的Metal工作流程的哪個位置
這是你的指令緩存器的圖解表示法
它包括你將要提交到
設備中的所有命令
你就像平時那樣操作就行了
你通過發送繪製調用來渲染你的屏幕
你通過發送核心程序來進行效果處理
現在你已經決定你的處理效果之一是模糊過濾器
正好是這個地方
不要忘記你還要像平時那樣提交你的命令到設備中
這裏什麼都沒有改變
現在如果你想要看我剛纔完成的例子中的示例代碼
你可以上網developer.Apple.com
下載叫做Metal性能着色器的例子世界你好
我前面已經提到過
Metal性能着色器架構有兩個目的性能和易於使用
我剛纔展示了它是多麼容易使用
讓我們快速地看看幕後
將要告訴你的性能的祕密
對於這些過濾器的每一個
包括高斯模糊過濾器我們要選擇恰當的算法
恰當的這裏的意思是正確的並且是最快的
對於輸入數據、輸入參數
設備GPU的特別組合是最快的
我這樣說是什麼意思
有許多方法可以實現高斯模糊
有constant costlog 2 linear
以及強力運算
所有這些方法的啓動費用和
日常開支都不相同
一種方法可能對於小的核半徑
非常好但在大的核半徑上表現不佳
重要的是我們要實現每一種方法
並且通過實驗來發現哪個
對於一個特別的輸入問題、輸入參數
和設備GPU的組合是最快的
在這個過程之後
所有的核都被調整成爲你的核半徑
你的像素格式
你的基礎硬件結構的存儲層次的參數
以及每個線程的像素數目
以及線程組規模的參數
這決定了如何將你的工作並行分離
最後我將會提到
該架構還爲你做CPU優化工作
它優化了程序上載速度
它還重複使用中間紋理
它還爲你做計算編碼優化
特別的是它還能察覺
你是否是在連續使用多重計算編碼器
如果是這樣它就會將它們合併
我們爲你完成了所有的這些步驟
非常酷但以代碼的角度來看是什麼樣子
如對於我剛剛向你們展示的
優化高斯模糊着色器
好了 你準備好了麼？
這就是代碼
現在你們都知道了
如何實現你們自己的優化高斯模糊
對麼我敢打賭 你沒想到
在這個講座中能學到這個
言歸正傳這是49 Metalkernels
2,000行的kernel代碼
以及821個不同的Metal高斯模糊實現
每個實現都是這些49個Metalkernels一些組合
因此看起來我們做了很多的工作
現在不必由你來做
讓我們看看
運行中的Metal性能着色器架構
首先我將演示一個簡單的
可分離高斯模糊實現的教科書
只需要1分鐘就可寫入到Metal
這可能是你剛開始時應該使用的東西
如果你要實現你的模糊
並且你手頭沒有Metal性能着色器
現在我們非常愉快地在每秒60幀在運行着
但是我們實際上還沒有做任何工作
sigma數值是0
讓我們改變sigma數值到6
我們就降到了每秒8幀
我們還敢繼續麼
讓我們試着sigma 20
好了 現在我們降到了每秒3幀
那樣就無法工作了
讓我們轉換到Metal性能
着色器實現
現在我們返回到了每秒60幀
沒有做任何工作sigma爲6
每秒仍然是60幀
Sigma爲20
仍然是每秒60幀
我們還得繼續 真的模糊它
仍然是每秒60幀
看起來我們贏了
這樣你的屏幕刷新速率是60赫茲
這就意味着我們以每秒60幀在運行
這樣你在演示中所看到的優化高斯模糊着色器
的性能最高是每秒60幀
這就意味着你有16.6毫秒來畫你的幀
這還包括你的系統可能要做的
合成工作
這個圖表顯示你在不同的sigma值
的優化高斯模糊過濾器的執行時間
你可以看到執行時間
要比16.6毫秒少得多
這就意味着你仍然有額外的時間
來做多餘的GPU工作
而且仍然能達到希望的每秒60幀
現在還有一些細節需要說明
有時候你需要在很大的圖片上工作
你需要並列式顯示
有時候你需要只在你的
圖像的一部分上工作
針對那個有個機制
它叫做源偏移和destination剪裁矩形
剪裁矩形有起始點和大小
它決定了目的紋理的區域
將由過濾器來進行更新
源偏移只有起始點
大小是隱含的由剪裁矩形來決定的
它只是你的目的紋理的左上角的一個相位差
它們共同工作給你提供了最後的圖像
在Metal性能着色器架構中
你的來源和目的是相同紋理中的一個
在這種情況下剪裁矩形
以同樣的方式工作
當來源和目的是相同的
我們管它叫in-place操作
用它來節約內存
你怎樣做才能對這些in-place過濾器進行編碼呢
你必須要使用編碼命令緩衝區方法
和一個分配器fall by back copy
有一件事要記住的是着色器並不總是可能
運行in place
它取決於你的過濾器
過濾器參數和性能
如果你希望這個操作永遠成功
使用一個複製分配器
它就會被自動調用
除非在in place操作不可能的情況下
我們將爲你創建一個新的目的紋理
這樣在必要情況下操作
可在out of place 進行
有簡單fall back copy分配器的例子
這個例子只是創建了一個新的具有相同的像素格式和大小
的目的紋理
因爲源紋理非常簡單
之前我向你們展示了一個in place 操作
在這個操作中 你只對目的紋理的
一部分進行了更改
在剪裁矩形之外的任何東西都沒有改變
在複製分配器中你還可以這樣做
只需要用你的源紋理的環境
來初始化你的目的紋理
我還想提到的是所有常見
的Metal資源如你的設備和
你的指令緩衝器
你都可在複製分配器中獲得
現在我對細節進行了說明
讓我們來總結一下
我想說的是請使用Metal支持架構
MetalKit和Metal性能着色器
它們非常強健它們經過優化
正如我向你們展示的
它們很容易融入你們的Metal的應用程序中
它們會給你的應用程序帶來更多的時間
你可以把時間用在製作獨特的應用程序上
而不是浪費在一般的工作上
另外的好處是
你可以花更少的代碼來編寫和維護
到我們的實驗室來向我們提出反饋意見讓我們知道如何開始或者向我們提問
讓我們知道是否想讓新的工具或着色器添加到支持架構中
你隨時可以在網上發現更多的信息
我們可以提供文檔視頻
充分利用蘋果開發論壇和技術支持
對於一般的疑問
請聯繫我們的遊戲技術大師阿倫·謝弗
你可以在網上觀看以前的講座
但如果你想學習新Metal性能優化技術
明天上午11:00來聽我們的講座
謝謝