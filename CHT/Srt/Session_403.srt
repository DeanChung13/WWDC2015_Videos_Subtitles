00:00:32.466 --> 00:00:33.567 
伍迪·李德斯東：
大家好

00:00:34.301 --> 00:00:38.305 
今天早些時候我對斯特凡說
我希望有人能來

00:00:38.906 --> 00:00:40.841 
太不可思議你把這裏都包了

00:00:40.908 --> 00:00:41.975 
感謝你能出來

00:00:42.042 --> 00:00:44.011 
我是伍迪
很高興給大家講講

00:00:44.077 --> 00:00:46.413 
用Swift改進現有的App

00:00:47.748 --> 00:00:48.715 
大家能不能舉一下手

00:00:48.782 --> 00:00:51.585 
多少人實際上
在用Swift 進行編碼？

00:00:53.520 --> 00:00:54.354 
好的<c.blue> 很好

00:00:54.488 --> 00:00:55.756 
那你們大家就 都來對了

00:00:56.423 --> 00:00:57.724 
無論你是否用了都是如此

00:00:57.791 --> 00:00:59.860 
希望在講座後你可以用Swift

00:01:00.327 --> 00:01:02.229 
打理現有的
Objective-C項目

00:01:03.630 --> 00:01:08.368 
要知道 去年我也
我也在這屋裏 坐在後面的角落 

00:01:08.635 --> 00:01:11.305 
是個聽衆的身份還帶着筆記本

00:01:11.371 --> 00:01:14.007 
想試着實踐一下

00:01:14.074 --> 00:01:16.677 
我在之前講座學到的新技術

00:01:17.044 --> 00:01:19.546 
同時還在回覆着工作郵件 
雖然我之前說過不會回覆的

00:01:20.080 --> 00:01:23.183 
同時把一半的心思放在發言人身上

00:01:23.250 --> 00:01:25.319 
我相信在座的大部分現在也是這樣

00:01:25.919 --> 00:01:30.757 
然後 角色換位 我從臺下聽衆

00:01:30.824 --> 00:01:31.859 
走到了臺前

00:01:31.925 --> 00:01:33.894 
我從加拿大新斯科舍省哈利法克斯 

00:01:33.961 --> 00:01:37.397 
來到了加利福尼亞

00:01:37.831 --> 00:01:41.235 
如今來這裏幫助大家學習使用

00:01:41.301 --> 00:01:43.570 
Swift和Objective-C
的部分技術

00:01:46.773 --> 00:01:47.774 
我就不必上前去翻動了

00:01:47.908 --> 00:01:49.209 
這裏有遙控

00:01:53.380 --> 00:01:56.617 
我想來做的是

00:01:56.850 --> 00:02:01.088 
介紹部分技術內容讓大家可以
把Swift加到現有項目

00:02:01.154 --> 00:02:02.289 
讓項目變得更好

00:02:02.523 --> 00:02:04.825 
本次講座我就會用來

00:02:04.892 --> 00:02:06.426 
介紹這樣的內容

00:02:06.894 --> 00:02:10.264 
我去過Infinite
Loop園區到了停車場

00:02:10.330 --> 00:02:12.999 
來到下面一層的地下迷宮

00:02:13.333 --> 00:02:16.136 
經過守衛工業設計入口的三頭犬

00:02:16.203 --> 00:02:18.005 
在盡頭 是我們

00:02:18.071 --> 00:02:19.473 
保存軟件的保險庫

00:02:19.540 --> 00:02:21.308 
我打開軟件保險庫

00:02:21.375 --> 00:02:25.078 
取出app<c.blue> The 
Elements 這可能在兩三年內

00:02:25.145 --> 00:02:26.547 
都沒在WWDC見到了

00:02:26.713 --> 00:02:28.849 
現在我就將向
大家介紹它是怎麼回事

00:02:30.784 --> 00:02:32.486 
好的 這就是 
The Elements

00:02:32.686 --> 00:02:34.488 
有誰還記得以前見過?

00:02:34.588 --> 00:02:36.423 
啊? 有人見過 有人沒有

00:02:36.623 --> 00:02:37.658 
有人當真喜歡它

00:02:37.758 --> 00:02:38.592 
我就是

00:02:40.127 --> 00:02:43.230 
這是個標準的
基於UIKit的表視圖app

00:02:43.830 --> 00:02:45.465 
我們有一束單元格 針對

00:02:45.699 --> 00:02:47.768 
針對原子表中的每個元素

00:02:47.935 --> 00:02:49.303 
我們還有這個小的詳細視圖

00:02:49.369 --> 00:02:50.704 
其中會有更多的信息

00:02:50.771 --> 00:02:52.439 
如果點擊一個單元格

00:02:53.106 --> 00:02:58.278 
我們有這個導航控制器
推動演示顯示部分相關細節

00:02:59.680 --> 00:03:00.747 
非常棒

00:03:08.755 --> 00:03:09.590 
<c.blue> 我相信可能

00:03:09.656 --> 00:03:11.992 
很多人都會這麼做

00:03:12.059 --> 00:03:13.827 
在不同的應用中移動

00:03:13.927 --> 00:03:15.462 
並且回來再來看有一陣子

00:03:15.529 --> 00:03:17.431 
沒用的app 或是有一陣子
沒編程的app 

00:03:17.497 --> 00:03:19.466 
然後有人讓你增添新的功能

00:03:19.533 --> 00:03:21.568 
或是支持
新的操作系統 新的SDK

00:03:22.069 --> 00:03:23.737 
這就是我們馬上要做的事情

00:03:23.804 --> 00:03:27.007 
我們會對Objective-C
app準備用Swift來實現現代化

00:03:28.876 --> 00:03:31.979 
意思是說：如果有現有應用

00:03:32.546 --> 00:03:34.014 
你必須要爲它編寫新代碼

00:03:34.147 --> 00:03:36.517 
而現有的應用是
Objective-C app

00:03:36.850 --> 00:03:40.988 
考慮利用Swift功能
使用Swift來編寫新代碼

00:03:41.388 --> 00:03:42.556 
與此同時

00:03:43.423 --> 00:03:46.560 
把原始的Objective-C代碼
留在Objective-C

00:03:46.793 --> 00:03:47.661 
這也很好的

00:03:48.495 --> 00:03:52.633 
在本講座中 我們先從

00:03:52.866 --> 00:03:55.502 
對應用的翻新講起爲用戶界面

00:03:55.569 --> 00:03:57.304 
帶來更爲現代的外觀

00:03:57.538 --> 00:03:59.373 
我們馬上要做的是使用Swift

00:03:59.606 --> 00:04:02.643 
之後 我們還要來看看代碼

00:04:02.709 --> 00:04:06.146 
Swift的結構及其函數
比如映射

00:04:06.213 --> 00:04:08.582 
找到爲應用增添新功能的辦法

00:04:12.186 --> 00:04:15.789 
這個應用有大小tile框架

00:04:15.923 --> 00:04:17.558 
小tile框架是表視圖

00:04:17.658 --> 00:04:18.992 
大tile框架是詳細視圖

00:04:19.625 --> 00:04:22.095 
這些tile框架包括背景

00:04:22.229 --> 00:04:24.798 
外加在背景上渲染的文本

00:04:25.566 --> 00:04:27.301 
因爲這個app是個老版本app

00:04:27.768 --> 00:04:30.504 
背景最初是用
Photoshop做的渲染

00:04:30.637 --> 00:04:32.573 
然後嵌入到應用之中

00:04:33.207 --> 00:04:35.342 
因爲背景中的不同顏色取決於

00:04:35.475 --> 00:04:40.080 
原子狀態固體 液體 合成氣體

00:04:40.614 --> 00:04:43.650 
是僅爲最初的iPhone做的渲染

00:04:43.717 --> 00:04:45.552 
其中並不包括Retina藝術設計

00:04:45.652 --> 00:04:47.754 
也就是說當我們拿到這個老版本app

00:04:47.821 --> 00:04:49.523 
在新版本硬件上運行時
我們必須做擴展

00:04:50.224 --> 00:04:54.828 
當我們擴展這個老版本藝術設計時

00:04:55.162 --> 00:04:57.364 
我們最後是得到的是圓角失真效果 
就是鋸齒

00:04:57.497 --> 00:05:00.033 
因爲沒有足夠的像素數據

00:05:00.133 --> 00:05:01.568 
來光滑地表現這些角

00:05:01.835 --> 00:05:04.605 
所以我們在
本次講座中就會解決這個問題

00:05:06.440 --> 00:05:09.343 
還有一個問題就是 當你看自己的

00:05:10.077 --> 00:05:11.645 
中學紀念冊時

00:05:12.045 --> 00:05:14.314 
也許是80年代或90年代

00:05:14.381 --> 00:05:16.016 
對嗎？

00:05:16.083 --> 00:05:17.351 
你看到了自己的照片

00:05:17.584 --> 00:05:19.820 
你在這裏穿着馬甲

00:05:19.887 --> 00:05:22.656 
還繡着小貓手裏拿着鍵盤

00:05:22.723 --> 00:05:24.057 
因爲當時這樣很酷

00:05:24.191 --> 00:05:25.826 
背景還是激光效果

00:05:25.893 --> 00:05:26.894 
因爲這當初也很酷

00:05:26.960 --> 00:05:27.828 
現在你再來看着它

00:05:27.895 --> 00:05:30.230 
心裏會想着
當時我腦子裏在想什麼呢？

00:05:34.968 --> 00:05:36.670 
有時 我們看着以前的app心裏會想

00:05:37.004 --> 00:05:38.438 
當時我們腦子裏是想什麼呢？

00:05:38.505 --> 00:05:40.541 
還有閃亮 光澤 反射效果

00:05:41.275 --> 00:05:43.277 
我們這就來調整

00:05:43.510 --> 00:05:45.345 
時尚潮流改變了
風格不一樣了

00:05:45.412 --> 00:05:46.613 
有一種辦法是從

00:05:46.747 --> 00:05:50.918 
背景上把光澤效果刪除下去

00:05:52.653 --> 00:05:55.088 
我們得到了非常時尚的
渲染矩形輪廓

00:05:55.622 --> 00:05:57.991 
看似在小tile框架上效果不錯

00:05:58.058 --> 00:05:59.893 
就像是在app的大tile框架一樣

00:05:59.960 --> 00:06:02.162 
現在我們可以在
Photoshop渲染新 背景

00:06:02.262 --> 00:06:03.530 
並把它們嵌入應用中

00:06:03.830 --> 00:06:05.365 
不過要清楚這個應用我們

00:06:06.233 --> 00:06:07.467 
不會經常使用

00:06:07.534 --> 00:06:10.938 
要知道  我們再講到

00:06:11.305 --> 00:06:14.775 
可能到了WWDC2020
Elements 我希望確保

00:06:14.875 --> 00:06:17.177 
當時它看上去還不錯
不是簡單的過去的硬件

00:06:17.244 --> 00:06:19.646 
和現在的硬件 而是
潛在的未來硬件

00:06:19.947 --> 00:06:24.051 
那我繼續選擇
放入一些自定義繪圖代碼

00:06:24.117 --> 00:06:26.787 
繪製圓角矩形背景因爲它是個圓角矩形

00:06:26.954 --> 00:06:29.523 
我準備在Swift中實現 但是

00:06:29.590 --> 00:06:31.325 
我會從 Objective-C調用

00:06:33.760 --> 00:06:36.296 
爲實現這一點 我用到的是
Mix和Match技術

00:06:36.964 --> 00:06:39.032 
我們在去年和今年有許多講座

00:06:39.132 --> 00:06:42.236 
都是介紹Swift
和Objective-C的互操作性

00:06:42.536 --> 00:06:44.938 
對其中的機制都有很好的介紹

00:06:45.239 --> 00:06:47.341 
現在我想來爲大家進行綜述

00:06:47.407 --> 00:06:49.076 
來看技術怎樣發揮作用

00:06:49.209 --> 00:06:51.712 
然後深入介紹一個
演示 大家可以直觀地瞭解

00:06:54.147 --> 00:06:56.750 
一般而言 當我們考慮到
Objective-C中的類時

00:06:56.817 --> 00:06:59.019 
會有個頭文件和一個執行文件

00:06:59.086 --> 00:07:01.522 
兩部分共同構成類定義

00:07:02.122 --> 00:07:03.824 
但是可能我們會有部分

00:07:04.157 --> 00:07:06.193 
分類中執行的方法

00:07:06.393 --> 00:07:07.694 
這相當好

00:07:07.961 --> 00:07:10.597 
然後我們的類定義是基類

00:07:10.998 --> 00:07:12.499 
加上分類

00:07:12.599 --> 00:07:13.534 
並不是說

00:07:13.600 --> 00:07:14.902 
不可以有多個分類

00:07:15.169 --> 00:07:17.137 
實際上 我們可以
用UI表視圖做些什麼

00:07:17.204 --> 00:07:19.206 
如果來看
Objective-C中的頭文件

00:07:19.273 --> 00:07:22.009 
會看到在UI表視圖有很多分類

00:07:23.010 --> 00:07:27.047 
同樣 也不是說這些分類之一

00:07:27.114 --> 00:07:28.549 
不可以在Swift中執行

00:07:29.049 --> 00:07:31.785 
其中 術語會改變可是概念還是一樣

00:07:31.885 --> 00:07:35.322 
我們只是稱其爲Objective-
C的Swift擴展

00:07:35.455 --> 00:07:36.456 
在本例中是基類

00:07:36.723 --> 00:07:37.691 
並不是說

00:07:37.758 --> 00:07:41.595 
不可以用多個
Objective-C分類

00:07:41.662 --> 00:07:46.900 
與多個Swift擴展
相混合 其中所有的內容構成類

00:07:48.302 --> 00:07:50.904 
我們在Objective-C中
編寫部分函數

00:07:51.305 --> 00:07:53.540 
這會讓你在Swift中
編寫更新的函數

00:07:54.541 --> 00:07:58.045 
爲了讓互操作性技術可以實現我們用到

00:07:58.212 --> 00:08:00.347 
一組橋接頭文件不是一組橋接頭文件

00:08:00.414 --> 00:08:02.149 
我們是用橋接頭文件和一個生成頭文件

00:08:03.650 --> 00:08:06.787 
現在橋接頭文件在Xcode中編成

00:08:06.854 --> 00:08:10.390 
首次向現有Objective-C
項目中引入Swift

00:08:10.924 --> 00:08:12.326 
然後進行維護

00:08:12.392 --> 00:08:14.294 
基本上要進入其中
加上部分輸入語句

00:08:14.361 --> 00:08:18.298 
這樣就可以針對性
從Objective-C 

00:08:18.532 --> 00:08:20.133 
面向Swift
使用選擇數據類型

00:08:21.201 --> 00:08:24.137 
然後在倒數上
Swift編譯器編成生成的頭文件

00:08:24.204 --> 00:08:27.541 
可以將之輸入到
Objective-C執行文件

00:08:27.741 --> 00:08:30.177 
來面對Swift 
在本例中是針對

00:08:30.344 --> 00:08:33.046 
Objective-C的擴展
和其他數據類型

00:08:33.447 --> 00:08:34.881 
現在我們有了兩個頭文件

00:08:34.948 --> 00:08:36.350 
你會在演示中看到它們

00:08:38.085 --> 00:08:39.453 
馬上就好

00:08:50.197 --> 00:08:51.431 
好的<c.blue> 在項目中

00:08:51.598 --> 00:08:53.834 
這個類名爲原子元素tile視圖

00:08:54.868 --> 00:08:56.837 
這就是實際在繪製背景的

00:08:57.504 --> 00:08:58.639 
其中有個方法

00:08:58.972 --> 00:09:00.541 
這其實不僅是繪製背景

00:09:00.607 --> 00:09:02.576 
它爲大小tile框架繪製了背景

00:09:02.643 --> 00:09:03.911 
和背景上的所有的文本

00:09:04.545 --> 00:09:07.047 
我準備介紹新的繪圖代碼

00:09:07.114 --> 00:09:09.283 
但我將用Swift來實現因此
我會繼續製作新的Swift文件

00:09:09.349 --> 00:09:11.151 
這是Xcode
中的command-N

00:09:11.418 --> 00:09:15.956 
我們會選擇Swift文件來創建

00:09:16.223 --> 00:09:18.292 
因爲是這是首次將Swift加入

00:09:18.392 --> 00:09:19.826 
這個項目我可以選擇

00:09:19.927 --> 00:09:21.061 
現在就生成接橋頭文件

00:09:21.361 --> 00:09:24.064 
我想創建一個按下Return

00:09:27.334 --> 00:09:30.804 
現在我有兩個文件
其中包括Objective-C的

00:09:31.405 --> 00:09:32.706 
基類 外加Swift文件

00:09:33.006 --> 00:09:34.808 
我還有接橋頭文件

00:09:35.209 --> 00:09:37.144 
還可以把這個再加寬一些 就這樣

00:09:39.046 --> 00:09:41.548 
你可能注意到
Swift文件的文件名

00:09:41.815 --> 00:09:44.284 
和Objective-C中
的完全一樣

00:09:44.384 --> 00:09:46.320 
並不是有這樣的要求
而是爲了方便起見

00:09:46.587 --> 00:09:48.555 
因爲這表示在Xcode 

00:09:48.622 --> 00:09:51.458 
可以用快捷方式 control
command-up arrow

00:09:51.525 --> 00:09:55.162 
並循環Swift和
Objective-C頭文件並執行

00:09:55.562 --> 00:09:57.631 
在這三個之間快速往復即可

00:09:59.733 --> 00:10:02.102 
現在我選定在橋接頭文件

00:10:02.402 --> 00:10:04.505 
把在Objective-C中
聲明的數據類型

00:10:04.571 --> 00:10:07.007 
暴露Swift通過輸入頭文件來實現

00:10:07.641 --> 00:10:11.745 
因爲我想將原子元素tile視圖
擴展到Swift

00:10:11.812 --> 00:10:15.115 
或使用Swift 
將之輸入給接橋頭文件

00:10:16.683 --> 00:10:20.654 
此刻我只需要的是我已經強調過的
原子元素tile視圖

00:10:20.721 --> 00:10:22.856 
但是在演講的稍後部分
我還需要其他幾個

00:10:22.923 --> 00:10:24.658 
我先來繼續現在把它們全都輸入

00:10:26.527 --> 00:10:28.228 
我們在來看Swift文件

00:10:29.029 --> 00:10:33.200 
我會編寫原子元素tile視圖的擴展

00:10:40.941 --> 00:10:44.178 
現在類原子元素
tile視圖 調用這個新函數

00:10:44.478 --> 00:10:45.646 
叫繪製原始背景

00:10:45.879 --> 00:10:49.183 
大家可以看到 我還用到了
新的Xcode 7標記

00:10:49.316 --> 00:10:51.351 
給出文檔註釋文檔註釋

00:10:51.485 --> 00:10:53.687 
在本例中 是繪製原子
元素背景tile框架

00:10:54.488 --> 00:10:55.956 
我來繼續 把實際

00:10:56.089 --> 00:10:57.257 
進行繪製的代碼加進去

00:11:02.763 --> 00:11:04.064 
這就是Swift的部分

00:11:04.131 --> 00:11:06.967 
但現在我想從Objective-C
中調用Swift函數

00:11:07.401 --> 00:11:09.903 
這樣反而是裝載預渲染圖像

00:11:09.970 --> 00:11:12.973 
我會用這種方法來繪製

00:11:14.107 --> 00:11:16.376 
然後切換到原子元素tile視圖m

00:11:16.877 --> 00:11:19.847 
需要確保
它可以看到我加入Swift中的

00:11:20.180 --> 00:11:22.583 
代碼 因此我繼續並輸入生成的頭文件

00:11:24.251 --> 00:11:26.286 
生成的頭文件和
產品使用完全相同的名稱

00:11:26.486 --> 00:11:31.959 
因此元素
再加上連字符 Swift.h

00:11:34.528 --> 00:11:37.364 
現在 在這種方法中我通常會裝載

00:11:37.464 --> 00:11:39.633 
預渲染背景
我會加註釋

00:11:41.568 --> 00:11:45.506 
並反而調用“self draw”
大家可以看到

00:11:45.572 --> 00:11:47.241 
Swift的方法作爲原生方法

00:11:47.307 --> 00:11:49.743 
和這裏的所有內容一起顯示

00:11:49.810 --> 00:11:51.778 
你甚至可以看到註釋顯示爲
draw  

00:11:51.845 --> 00:11:55.082 
an atomicelements
background tile

00:11:55.148 --> 00:11:57.818 
我來傳遞交出這個元素

00:12:03.490 --> 00:12:05.025 
把它傳遞交給外包矩形

00:12:05.092 --> 00:12:06.693 
它會繪製圓角矩形

00:12:09.563 --> 00:12:10.631 
運行app

00:12:15.002 --> 00:12:18.639 
就這樣運用Swift代碼
和Objective-C

00:12:18.705 --> 00:12:20.541 
獲得部分圓角矩形 謝謝

00:12:26.613 --> 00:12:28.515 
這就是在觀衆裏
安排自己的朋友的好處

00:12:38.192 --> 00:12:40.561 
大部分內容 都是和我的預期相符

00:12:40.627 --> 00:12:41.495 
是圓角矩形

00:12:41.662 --> 00:12:43.564 
但是圓角矩形本身 它們並不

00:12:43.630 --> 00:12:44.831 
和我想要的方式相符

00:12:45.098 --> 00:12:48.535 
實際上 如果放大 大家可以看到

00:12:48.602 --> 00:12:50.904 
裏邊是圓角但外邊不是圓角

00:12:51.138 --> 00:12:52.306 
這不是我的本意

00:12:52.472 --> 00:12:54.775 
我是希望是純圓角純粹的圓角

00:12:54.842 --> 00:12:55.976 
在裏邊和外邊都是

00:12:56.777 --> 00:12:59.980 
我們來仔細看看爲什麼會是這樣

00:13:00.047 --> 00:13:03.083 
我們來看Swift結構

00:13:03.951 --> 00:13:05.619 
Swift會怎麼讓它

00:13:05.752 --> 00:13:07.154 
更簡單並與結構配合更自然

00:13:07.354 --> 00:13:11.091 
例如在Core Graphics
框架中我們有許多 

00:13:11.625 --> 00:13:12.726 
基本結構

00:13:12.793 --> 00:13:16.163 
我們有CGrects
CGpoints CGsize等等

00:13:17.764 --> 00:13:22.302 
繪製的時候我有外包矩形是個
CGrect我繪製了貝茲曲線路徑

00:13:22.669 --> 00:13:24.171 
現在貝茲曲線路徑是屏幕上的

00:13:24.238 --> 00:13:27.474 
灰色邊框繪製貝茲曲線路徑

00:13:29.710 --> 00:13:31.879 
接下來 把它被放在外包矩形內部

00:13:31.945 --> 00:13:33.313 
你就會看到這裏是外包矩形

00:13:34.181 --> 00:13:36.583 
貝茲曲線路徑
你看到的不是這樣本身並非是你所見

00:13:36.650 --> 00:13:38.986 
直到對之應用線條纔會進行渲染

00:13:39.052 --> 00:13:41.321 
比如畫線大家會看到

00:13:41.388 --> 00:13:42.990 
對貝茲曲線路徑的渲染效果

00:13:43.790 --> 00:13:46.026 
我們來繪製貝茲曲線路徑

00:13:47.027 --> 00:13:48.195 
在加上畫線

00:13:48.595 --> 00:13:51.765 
例如 畫線爲
10個單位寬 10點寬

00:13:52.399 --> 00:13:53.901 
但是會超過外包矩形的

00:13:53.967 --> 00:13:54.835 
邊界

00:13:56.970 --> 00:13:58.272 
這會導致剪切

00:13:58.772 --> 00:14:00.908 
圓角矩形實際上是在外邊

00:14:00.974 --> 00:14:03.877 
但是在外包矩形上
發生的剪切防止它到達那裏

00:14:05.078 --> 00:14:08.048 
我知道 在座的朋友
有人會覺得

00:14:08.115 --> 00:14:09.716 
如果剪切存在問題 那就關閉剪切

00:14:10.184 --> 00:14:11.451 
問題就解決了

00:14:11.518 --> 00:14:12.452 
就可以繼續了

00:14:14.188 --> 00:14:16.490 
當然可以 我覺得

00:14:16.557 --> 00:14:20.260 
在Xcode中
Swift問題可以這麼解決

00:14:20.727 --> 00:14:23.463 
只要重新安排
Swift的感嘆號位置

00:14:23.530 --> 00:14:25.232 
直至開始編譯爲止

00:14:27.134 --> 00:14:30.070 
可以這麼做 只是我不會
稱之爲最佳實踐

00:14:30.871 --> 00:14:33.507 
當出現剪切問題時

00:14:35.275 --> 00:14:36.710 
這是性能表現的問題

00:14:36.777 --> 00:14:38.912 
通過所調用的每個API

00:14:39.046 --> 00:14:42.916 
通過發起的每個任務
通過進行的每個動作

00:14:42.983 --> 00:14:44.585 
通過你的每一次呼吸

00:14:44.885 --> 00:14:47.921 
你需要考慮對
功能和性能的影響

00:14:48.288 --> 00:14:52.359 
不斷計算兩個矩形的
交叉部分並對之進行剪切

00:14:52.426 --> 00:14:53.393 
這不是很有效的方法

00:14:53.861 --> 00:14:57.564 
在一開始就把矩形設置爲
正確大小則更爲有效

00:14:59.266 --> 00:15:00.200 
我們就要這麼做

00:15:00.400 --> 00:15:02.202 
準備嵌入貝茲曲線路徑

00:15:02.402 --> 00:15:03.670 
這樣就不會自行剪切

00:15:04.238 --> 00:15:07.307 
爲此 我們會用到一些方法

00:15:07.741 --> 00:15:11.345 
我是說CGrect上的方法

00:15:11.411 --> 00:15:13.313 
當它在Swift中使用的時候

00:15:14.214 --> 00:15:16.183 
考慮一下這些原始類型怎樣正常使用

00:15:16.316 --> 00:15:18.685 
我們有CGrects
CGpoint等等

00:15:19.119 --> 00:15:21.388 
我說過它們可能會在這裏

00:15:21.855 --> 00:15:25.859 
那麼單獨來看
你獲得了可適用的整套全局通用函數

00:15:25.926 --> 00:15:29.263 
例如CGrectZero
CGrectMake

00:15:29.329 --> 00:15:32.132 
或GetWidth
或是部分實際函數

00:15:32.199 --> 00:15:33.634 
例如獲得聯合或交點

00:15:34.001 --> 00:15:35.869 
這是二者之間的認知區分

00:15:35.936 --> 00:15:37.771 
我們瞭解是這個類型 然後我們需要

00:15:37.871 --> 00:15:40.374 
瞭解是這些方法 不好意思

00:15:40.440 --> 00:15:41.875 
是作用的函數

00:15:43.076 --> 00:15:45.612 
我們用Swift
工作時我們實際上改變的是

00:15:45.679 --> 00:15:49.650 
CGrect和CGpoint
及CGsize進入Swift的方法

00:15:50.517 --> 00:15:52.920 
我們基本會用封裝用所有這些

00:15:53.453 --> 00:15:56.356 
這些全局 正式來講是
作用於框架的全局函數

00:15:56.423 --> 00:15:59.193 
並在結構中搭建它以便使之完成代碼

00:16:00.561 --> 00:16:05.299 
更爲簡單
還可以更出色預測到API是什麼

00:16:06.166 --> 00:16:09.770 
因爲你可以處理點結構

00:16:09.837 --> 00:16:13.140 
然後爲所有方法和屬性
獲得它所具備的代碼完成

00:16:14.074 --> 00:16:16.109 
然是如果我們把名稱就保留成這樣

00:16:16.476 --> 00:16:17.878 
這還不是原生的感覺

00:16:18.445 --> 00:16:21.415 
名稱實際上都做了重新映射 

00:16:22.115 --> 00:16:25.953 
讓人覺得
這是數據類型的 第一類型方法

00:16:26.420 --> 00:16:30.858 
這樣做的好處在於
處理Swift中的結構的方法

00:16:31.325 --> 00:16:35.195 
調用函數或調用方法

00:16:35.262 --> 00:16:38.732 
或訪問其屬性這與類的處理方法

00:16:39.199 --> 00:16:42.336 
與枚舉的處理方法完全相同

00:16:43.103 --> 00:16:45.339 
都是相同的一致風格

00:16:45.672 --> 00:16:48.275 
我們還要在所有不同數據類型中

00:16:48.408 --> 00:16:49.776 
使用同樣的初始化器

00:16:49.943 --> 00:16:51.912 
我們有着更好的代碼完成

00:16:51.979 --> 00:16:56.850 
總之
在Swift中運用這些類型更爲自然

00:16:56.917 --> 00:17:02.055 
因爲
它們作爲第一類型數據類型和方法配合

00:17:03.557 --> 00:17:06.126 
好的我們還要做一件事情

00:17:06.193 --> 00:17:08.929 
在下面的演示中我不瞭解大家會怎樣但
是當我用圖形代碼時

00:17:08.996 --> 00:17:10.998 
特別是部分Core
Graphics代碼時 

00:17:11.164 --> 00:17:16.637 
我使用的一個方法是渲染代碼

00:17:16.703 --> 00:17:19.106 
然後會運行接着來構建並複製到

00:17:19.173 --> 00:17:21.407 
模擬器然後我導航到

00:17:21.474 --> 00:17:23.644 
模擬器中代碼真正被激活被使用的位置

00:17:23.844 --> 00:17:25.746 
我還會進行檢測 如果不喜歡

00:17:25.811 --> 00:17:27.748 
就會返回調整代碼並運行全部內容

00:17:27.814 --> 00:17:29.917 
這是個循環

00:17:29.983 --> 00:17:32.152 
來回走一遍會非常耗時

00:17:32.252 --> 00:17:34.488 
來看如果把直線寬度

00:17:34.555 --> 00:17:37.357 
從3改到4 或是關閉光柵化 或是

00:17:37.424 --> 00:17:39.626 
進行某種設置更改試着讓它運轉會怎樣

00:17:41.995 --> 00:17:43.330 
還有更好的方法

00:17:43.897 --> 00:17:45.432 
不需要這麼來回反覆

00:17:45.832 --> 00:17:48.302 
也不必經常註釋出

00:17:48.368 --> 00:17:50.337 
部分代碼只爲嘗試效果如何

00:17:50.404 --> 00:17:51.505 
如果真想試驗 可以

00:17:51.572 --> 00:17:54.842 
拿一些代碼試試看看效果怎樣

00:17:55.042 --> 00:17:56.543 
體育場就是爲這個準備的

00:17:56.877 --> 00:17:58.745 
通過體育場循環修改成

00:17:58.812 --> 00:17:59.713 
這個樣子

00:18:00.214 --> 00:18:03.283 
只要調整代碼你就會立刻看到改變
如果不喜歡可以立 刻修改

00:18:03.684 --> 00:18:06.186 
這些都不會複製到模擬器中 導航並

00:18:06.553 --> 00:18:09.323 
現在通過體育場 
解決圓角來看看是什麼樣子

00:18:09.590 --> 00:18:11.258 
矩形的問題並使用CGrect

00:18:11.525 --> 00:18:15.295 
的部分方法
從中得到更好的CGrect

00:18:15.395 --> 00:18:16.697 
我來給大家看看

00:18:23.670 --> 00:18:26.406 
繪圖代碼在原子元素tile視圖

00:18:26.473 --> 00:18:27.574 
<c.blue>.點Swift就在這裏 

00:18:27.708 --> 00:18:29.209 
這是我在之前演示中

00:18:29.276 --> 00:18:30.577 
複製的函數

00:18:30.911 --> 00:18:32.346 
我就是想要處理這個

00:18:32.412 --> 00:18:33.514 
所以把它複製到體育場

00:18:33.847 --> 00:18:37.518 
複製好了點擊command-N
生成新的iOS體育場

00:18:46.860 --> 00:18:47.928 
粘貼進去

00:18:48.395 --> 00:18:49.730 
現在就有了繪圖函數

00:18:51.698 --> 00:18:53.500 
開發人員並非身處孤島

00:18:53.700 --> 00:18:56.036 
沒有任何繪圖函數是完全隔絕

00:18:56.336 --> 00:18:58.639 
繪圖函數需要在有上下文來繪製

00:18:58.872 --> 00:19:00.674 
也就是繪圖上下文或是圖形上下文

00:19:00.941 --> 00:19:03.210 
獲得圖形上下文的最便捷方式

00:19:03.277 --> 00:19:04.578 
是在UIView生成子類

00:19:04.645 --> 00:19:06.046 
這就是我準備做的

00:19:06.113 --> 00:19:09.516 
我先來聲明UIView的子類 這裏

00:19:11.919 --> 00:19:16.023 
它所做的就是調用繪圖函數

00:19:17.224 --> 00:19:19.393 
然後我會實例化這個類

00:19:23.096 --> 00:19:26.533 
然後我會採用繪圖函數

00:19:26.700 --> 00:19:28.869 
繪製的圖像
並直接加入這裏的故事板

00:19:30.971 --> 00:19:32.472 
放大些 這樣都能看清

00:19:34.341 --> 00:19:35.742 
接着可以進行嘗試

00:19:35.809 --> 00:19:37.044 
你可以指出自己該做什麼

00:19:37.110 --> 00:19:38.812 
讓它按照自己的意圖來進行繪製

00:19:39.012 --> 00:19:41.114 
例如 我想看看是否看似

00:19:41.181 --> 00:19:42.683 
它只有120點

00:19:43.884 --> 00:19:44.785 
這就是結果

00:19:46.286 --> 00:19:49.690 
也許我想看看如果直線寬度
不是6而是60圓角半徑

00:19:50.457 --> 00:19:55.596 
爲356會怎樣

00:19:55.662 --> 00:19:56.663 
就是這樣

00:19:57.531 --> 00:19:59.032 
大家可以一直做嘗試

00:19:59.099 --> 00:20:00.734 
一旦代碼運行方式符合要求

00:20:00.968 --> 00:20:01.969 
就可以複製並

00:20:02.035 --> 00:20:03.470 
粘貼到它來自的實際文件中

00:20:04.571 --> 00:20:08.509 
在本例中我希望獲得直線寬度比例

00:20:08.609 --> 00:20:10.611 
那麼如果是表視圖中的小tile視圖

00:20:11.011 --> 00:20:13.113 
就會是細邊如果是大些的視圖

00:20:13.180 --> 00:20:14.548 
相應的就是寬一些的邊

00:20:14.715 --> 00:20:18.819 
因此我會
讓它關聯到背景矩形的寬度上

00:20:19.520 --> 00:20:24.091 
那麼背景矩形寬度在本例中會除以36

00:20:25.292 --> 00:20:27.094 
對圓角半徑 我也會做同樣處理

00:20:27.861 --> 00:20:30.864 
Background
rectangle.width除以

00:20:31.198 --> 00:20:32.766 
小一點的值 比如16

00:20:34.668 --> 00:20:37.037 
現在來看我希望它看的內容

00:20:37.104 --> 00:20:38.272 
但我仍然還有剪切的問題

00:20:38.338 --> 00:20:40.874 
我還是不能看到畫線或者是

00:20:40.941 --> 00:20:42.876 
圓角矩形的全部內容

00:20:43.610 --> 00:20:45.913 
爲此 在背景矩形

00:20:46.780 --> 00:20:50.684 
我會通過嵌入使用矩形方法

00:20:50.884 --> 00:20:52.953 
並且嵌入到直線寬度的一半

00:20:54.321 --> 00:20:57.057 
這裏的直線寬度除以2 

00:20:57.491 --> 00:21:00.594 
然後 同樣直線寬度除以2

00:21:03.597 --> 00:21:05.866 
我有個完美的圓角矩形

00:21:05.933 --> 00:21:07.734 
和我最初設想完全相同

00:21:08.101 --> 00:21:13.640 
我把這個代碼從這裏複製到擴展

00:21:13.907 --> 00:21:15.409 
代替這個文檔 不對

00:21:15.475 --> 00:21:16.376 
代替這裏的方法

00:21:17.477 --> 00:21:19.346 
用command-R再次運行app

00:21:22.516 --> 00:21:25.352 
正如我所願圓角矩形

00:21:25.886 --> 00:21:26.854 
好的 很好

00:21:34.461 --> 00:21:37.998 
這很有WWDC的感覺如果你想鼓掌
那就隨時可以鼓掌

00:21:38.532 --> 00:21:40.434 
沒有人會阻止這一點

00:21:41.602 --> 00:21:42.603 
沒問題
好的 謝謝大家

00:21:45.072 --> 00:21:46.373 
app看似沒問題

00:21:46.440 --> 00:21:47.541 
我也實現了圓角矩形

00:21:47.608 --> 00:21:48.742 
非常好 就是我想要的

00:21:48.976 --> 00:21:49.943 
接下來 我想做的是

00:21:50.010 --> 00:21:52.679 
讓這個app看上去像是當前的app

00:21:54.047 --> 00:21:58.619 
我不瞭解大家會怎樣但是在參加WWD
C大會之後你是否曾跑到客戶那裏

00:21:58.685 --> 00:22:01.054 
說 現在iOS的新版本出來了 

00:22:01.121 --> 00:22:02.723 
比如說iOS 9出來了

00:22:02.789 --> 00:22:05.259 
我覺得 應該不再支持iOS 8

00:22:05.626 --> 00:22:09.496 
我們應該只支持新的操作系統

00:22:11.899 --> 00:22:13.100 
很好<c.blue> 你們這麼幹過嗎？

00:22:15.636 --> 00:22:16.937 
好 那你再去找下一個客戶好了

00:22:17.971 --> 00:22:22.376 
因爲大家都希望你支持這些舊版本

00:22:22.676 --> 00:22:27.181 
iOS 7 8現在可能9
對大部分人而言會在秋天能用上

00:22:27.614 --> 00:22:32.319 
爲實現這一點 我們在Swift
2.0推出了新的可用性功能

00:22:32.386 --> 00:22:34.321 
只要是用Swift 2.0編寫代碼

00:22:34.388 --> 00:22:38.292 
我們有很好的辦法來看所用的SDK

00:22:38.358 --> 00:22:40.994 
無論你是否真會用這種功能與否

00:22:42.529 --> 00:22:44.097 
去年在WWDC

00:22:44.264 --> 00:22:48.035 
我們推出了一些新的
視圖控制器顯示API

00:22:48.735 --> 00:22:50.671 
可以在iPhone上彈出顯示

00:22:51.138 --> 00:22:54.341 
我想用元素app
做的是當我在支持它的任何設備上

00:22:54.408 --> 00:22:58.111 
例如在iOS 8或者更新

00:22:58.412 --> 00:22:59.980 
版本的設備上我想用彈出顯示

00:23:00.280 --> 00:23:01.748 
但是當我在iOS 7上

00:23:01.815 --> 00:23:05.452 
我想繼續使用導航推送顯示樣式

00:23:06.353 --> 00:23:08.222 
好 怎麼做呢？

00:23:09.556 --> 00:23:14.561 
這是檢測是否支持API的經典辦法

00:23:14.895 --> 00:23:17.798 
無論是什麼類型我們都要
檢測它是否對選擇器有反應

00:23:17.865 --> 00:23:19.800 
如果有反應我們就用這款選擇器

00:23:19.900 --> 00:23:21.568 
如果沒有我們就做其他的事情

00:23:23.837 --> 00:23:27.174 
在Swift 到Swift 2.0
我們都是這麼做的

00:23:27.741 --> 00:23:32.980 
我們有這個井號標籤指定想要的SDK

00:23:33.046 --> 00:23:35.482 
在本例中是iOS 8.3如果是這樣

00:23:35.782 --> 00:23:38.819 
我們會用到彈出框
如果不是我們用其他方法

00:23:39.419 --> 00:23:42.155 
這種樣式的好處在於你並沒有等待

00:23:42.222 --> 00:23:44.358 
運行時間來看是否實際工作正常

00:23:44.424 --> 00:23:46.593 
在編譯時間編譯器會告知你 

00:23:47.060 --> 00:23:49.229 
沒問題 這可行或不可行 

00:23:49.296 --> 00:23:50.497 
根據你的部署目標而定

00:23:50.597 --> 00:23:52.432 
如果我在iOS 7部署

00:23:52.999 --> 00:23:54.735 
它會告知無法進行彈出

00:23:55.135 --> 00:23:57.171 
但是因爲我進行了妥善保護 

00:23:57.538 --> 00:23:59.573 
提供了另外的路徑就可以編譯

00:24:02.576 --> 00:24:06.180 
在本例中 如果我沒有進行保護
如果我沒有說這裏是檢測

00:24:07.047 --> 00:24:10.951 
我想要做編譯 準備部署到iOS 7

00:24:12.252 --> 00:24:15.022 
它就會說 彈出顯示
控制器不可用

00:24:15.189 --> 00:24:16.423 
只能在8或者更新版本才行

00:24:17.157 --> 00:24:18.425 
然後會給我一些修復

00:24:18.492 --> 00:24:19.927 
但是我不會用更多的幻燈片

00:24:19.993 --> 00:24:21.094 
而是直接給大家看代碼

00:24:22.095 --> 00:24:22.930 
好<c.blue> 首先

00:24:22.996 --> 00:24:24.731 
在第二個視圖控制器顯示的代碼

00:24:24.798 --> 00:24:27.668 
保存在elements
viewcontroller.m.

00:24:28.435 --> 00:24:33.674 
表視圖附件的執行
但是點擊了索引路徑的行

00:24:34.875 --> 00:24:36.443 
因爲我想使用可用性檢測

00:24:36.510 --> 00:24:39.012 
我只能在Swift上執行

00:24:39.079 --> 00:24:40.747 
執行而不是Objective-C
我現在就來添加註釋

00:24:41.915 --> 00:24:43.884 
然後我會生成一個類擴展

00:24:43.951 --> 00:24:46.854 
更像20分鐘左右前的
那個最初演示的樣子

00:24:47.221 --> 00:24:52.759 
這樣我可以擴展元素視圖控制器 
並在Swift中執行部分功能

00:24:53.660 --> 00:24:56.163 
我點擊command-N 
生成新文件 是Swift文件

00:24:57.965 --> 00:25:00.267 
是元素視圖控制器.Swift

00:25:01.134 --> 00:25:03.637 
然後我會在上面編寫擴展

00:25:05.606 --> 00:25:08.575 
擴展 元素視圖控制器

00:25:09.977 --> 00:25:15.215 
其中 我會用 等效的Swift函數

00:25:15.382 --> 00:25:16.984 
因此這基本上是我在Swift中

00:25:17.084 --> 00:25:18.085 
已有的相同代碼

00:25:18.185 --> 00:25:19.620 
這裏並沒有新鮮內容

00:25:19.686 --> 00:25:21.522 
就是在Swift上執行的相同內容

00:25:21.588 --> 00:25:23.423 
但是這可以讓我進行可用性檢測

00:25:25.325 --> 00:25:29.830 
這個特殊應用是針對 iOS 7.1

00:25:30.731 --> 00:25:35.369 
我想在其中用這個新的彈出顯示
控制器技術 

00:25:37.271 --> 00:25:38.805 
那麼就在這一行做註釋

00:25:40.140 --> 00:25:43.110 
並加入代碼試着直接調用彈出顯示

00:25:47.714 --> 00:25:48.815 
我有些錯誤

00:25:49.082 --> 00:25:51.018 
一個錯誤是抱怨我沒有

00:25:51.084 --> 00:25:54.488 
真正滿足彈出框所需的委託協議

00:25:55.189 --> 00:25:59.226 
在旁邊可以用Swift擴展

00:25:59.293 --> 00:26:02.696 
並用它來爲額外的協議添加一致性

00:26:02.763 --> 00:26:06.867 
所以我將添加UI彈出顯示控制器委託

00:26:08.368 --> 00:26:11.271 
這就會消除這個錯誤但我仍然還有問題

00:26:11.939 --> 00:26:15.809 
就是要用iOS
7.1中不存在的API

00:26:16.276 --> 00:26:17.644 
而我卻偏偏需要這樣

00:26:17.945 --> 00:26:19.179 
嗯 是在演示中需要如此

00:26:19.847 --> 00:26:21.982 
我有兩種解決辦法

00:26:23.917 --> 00:26:25.886 
現在就給大家簡單介紹一下

00:26:28.155 --> 00:26:30.624 
如果我是在運 
在本例中是iOS 8.3

00:26:31.058 --> 00:26:32.426 
繼續 並作爲彈出顯示

00:26:32.593 --> 00:26:34.261 
否則 就用導航控制器

00:26:35.963 --> 00:26:40.000 
現在 如果我運行它 並點擊 

00:26:42.102 --> 00:26:43.170 
我們來看這裏

00:26:45.038 --> 00:26:46.039 
我們得到一個彈出框

00:26:46.907 --> 00:26:49.910 
已經15年了 
我們仍在WWDC上見到Carbon

00:26:52.813 --> 00:26:53.647 
好

00:27:04.758 --> 00:27:06.460 
若要了解可用性檢測的更多詳情

00:27:06.827 --> 00:27:09.096 
可去看週四的講座《Swift實踐》

00:27:09.363 --> 00:27:10.731 
其中會有大篇幅的相關介紹

00:27:14.067 --> 00:27:15.903 
接下來 之前的演示是關於

00:27:15.969 --> 00:27:18.939 
應用外觀的改進和現代化處理

00:27:19.006 --> 00:27:21.575 
要知道 我們改變繪圖來取消光澤

00:27:21.642 --> 00:27:23.210 
我們現在還有彈出框等等 不勝枚舉

00:27:23.644 --> 00:27:25.412 
但是讓我們實際增添部分功能

00:27:25.546 --> 00:27:28.515 
我們要執行智能搜索

00:27:28.882 --> 00:27:30.184 
爲此 我們會來看看

00:27:30.250 --> 00:27:31.652 
Swift的過濾方法

00:27:31.718 --> 00:27:34.821 
在所有的集合中都有包括集合和數組

00:27:35.756 --> 00:27:39.393 
過濾可以用於驅動智能搜索函數
其中只有滿足搜索

00:27:39.459 --> 00:27:42.930 
字符串的原子元素會在表視圖中顯示

00:27:44.665 --> 00:27:48.335 
標準設置是這個樣子
我們有TableView

00:27:48.402 --> 00:27:51.605 
TableView
加上視圖控制器作爲數據源

00:27:52.072 --> 00:27:53.941 
視圖控制器有內容數組

00:27:56.243 --> 00:27:59.413 
我在搜索域輸入一些東西時

00:27:59.847 --> 00:28:01.682 
就會有個委託方式在視圖控制器上叫做

00:28:01.748 --> 00:28:04.218 
searchbar:
textDidChange.

00:28:06.153 --> 00:28:07.888 
我找出傳遞的字符串

00:28:07.955 --> 00:28:09.022 
那只是一個參數

00:28:09.089 --> 00:28:10.657 
我過濾內容數組

00:28:10.924 --> 00:28:13.927 
並告知TableView用過濾後的

00:28:15.562 --> 00:28:17.231 
內容數組進行更新

00:28:17.297 --> 00:28:19.766 
Searchbar:
textDidChange

00:28:19.833 --> 00:28:21.401 
基本是這樣

00:28:22.269 --> 00:28:24.037 
實際上 就是這個樣子

00:28:24.104 --> 00:28:25.472 
因爲這就是我用的代碼

00:28:25.906 --> 00:28:27.040 
現在我要大家注意

00:28:27.574 --> 00:28:29.910 
標亮的部分是個閉包

00:28:30.477 --> 00:28:32.713 
我正在運行過濾器 在過濾器中

00:28:33.013 --> 00:28:35.382 
會應用數組中的每一項

00:28:35.816 --> 00:28:38.585 
數組中的項我有佔位控件

00:28:38.986 --> 00:28:41.622 
是$0我得到了它的名稱
接着詢問它是否有前綴

00:28:41.688 --> 00:28:42.789 
無論搜索字符串是什麼

00:28:45.792 --> 00:28:48.729 
都會這樣運行 頂部是最初的數組

00:28:49.129 --> 00:28:51.198 
我有一個封閉的過濾器

00:28:51.832 --> 00:28:52.933 
會循環

00:28:52.999 --> 00:28:54.601 
每次都會傳遞元素

00:28:54.668 --> 00:28:57.538 
如果名稱前有字母在本例中是N

00:28:57.871 --> 00:28:59.773 
它被傳遞給返回過濾數組

00:29:01.008 --> 00:29:02.376 
如果沒有字母 那就不是

00:29:02.943 --> 00:29:04.011 
我給大家看看代碼

00:29:04.411 --> 00:29:06.280 
但是爲加快速度我已經運行過

00:29:06.947 --> 00:29:08.248 
把搜索條放在上面

00:29:08.982 --> 00:29:09.950 
但我還沒搭建好

00:29:10.017 --> 00:29:11.418 
那麼如果我試着在裏面做點什麼

00:29:12.386 --> 00:29:14.621 
都不會奏效 因爲我沒有加入委託方式

00:29:16.623 --> 00:29:18.625 
委託方式是這個

00:29:23.030 --> 00:29:24.665 
也就是說 如果搜索文本爲空 
就在這裏

00:29:24.731 --> 00:29:27.234 
顯示所有原子元素

00:29:28.235 --> 00:29:30.537 
如果不是空我想做個過濾器

00:29:30.604 --> 00:29:32.005 
這部分需要完成

00:29:32.072 --> 00:29:32.940 
我們現在就動手

00:29:38.278 --> 00:29:39.746 
我準備一個過濾器

00:29:40.013 --> 00:29:41.648 
如果這是大家第一次見到閉包

00:29:42.015 --> 00:29:43.684 
不錯 歡迎閉包

00:29:43.884 --> 00:29:44.952 
我來給大家多講幾句

00:29:45.018 --> 00:29:46.787 
如果不是的話就當是複習了

00:29:47.354 --> 00:29:50.023 
當Xcode顯示這種藍色符號化背景

00:29:50.090 --> 00:29:52.226 
還都是單項可以雙擊

00:29:52.292 --> 00:29:54.528 
會展開需要填入空白部分

00:29:54.795 --> 00:29:57.531 
我會用這個閉包雙擊 會展開

00:29:59.499 --> 00:30:03.637 
我知道
有原子元素數組數據類型叫原子元素

00:30:04.137 --> 00:30:07.341 
如果傳遞的參數是一個原子元素

00:30:07.975 --> 00:30:10.077 
我會明確在閉包中

00:30:10.611 --> 00:30:13.213 
所傳遞的參數是原子元素

00:30:13.280 --> 00:30:17.551 
我會給它一個本地名稱
這樣原子元素有了自己的本地名稱

00:30:17.618 --> 00:30:20.053 
而數據類型是原子元素

00:30:21.255 --> 00:30:23.824 
在閉包中 我需要檢查是否要將它

00:30:23.891 --> 00:30:26.760 
包括在過濾結果中

00:30:27.127 --> 00:30:29.763 
因爲我承諾給出Boolean返回值

00:30:30.964 --> 00:30:35.736 
我來看返回值是否是原子元素

00:30:38.438 --> 00:30:43.110 
名稱
有前綴 再看搜索條傳遞的搜索文本

00:30:48.148 --> 00:30:50.150 
像這樣 現在 當我運行的時候

00:30:55.489 --> 00:30:59.092 
我們會搜索所有以字母N開始的內容

00:30:59.493 --> 00:31:02.029 
就這樣 
我們用Swift過濾器過濾了

00:31:03.330 --> 00:31:04.831 
但是有兩方面內容需要給大家展示

00:31:04.898 --> 00:31:07.701 
其一 有兩種方法可以來看閉包 

00:31:07.768 --> 00:31:09.436 
這裏是個擴展句法

00:31:11.872 --> 00:31:13.373 
這裏還有精簡句法

00:31:13.607 --> 00:31:15.108 
我來給大家看看精簡句法

00:31:16.476 --> 00:31:19.146 
Swift有非常強大的類型推斷系統

00:31:19.213 --> 00:31:21.648 
我們可根據上下文和所使用的數據類型

00:31:21.715 --> 00:31:23.050 
推斷出很多內容

00:31:23.617 --> 00:31:26.653 
例如 如果在閉包有個單獨行

00:31:26.720 --> 00:31:29.289 
假設它將返回一個值 

00:31:29.356 --> 00:31:30.557 
那我不必放入返回值

00:31:30.858 --> 00:31:35.262 
實際上 如果前綴
返回了Boolean類型

00:31:35.329 --> 00:31:37.564 
Swift可推斷這個閉包的返回類型

00:31:37.631 --> 00:31:40.167 
就是Boolean 所以我不需要

00:31:40.534 --> 00:31:42.970 
把它放在這裏也就是說我也不必

00:31:43.036 --> 00:31:45.305 
把它放在那裏因爲原子元素

00:31:45.806 --> 00:31:49.643 
我就不必明確 原子元素需要傳遞
就可以不要這部分

00:31:50.177 --> 00:31:53.247 
因爲我沒有任何參數 我不必區分代碼

00:31:53.313 --> 00:31:54.681 
和參數 那麼我不需要關鍵詞 

00:31:55.549 --> 00:31:58.085 
也就是說 可以不要這部分

00:31:59.219 --> 00:32:02.456 
節省空間 
最後我得到的是這樣的東西

00:32:05.225 --> 00:32:07.528 
因爲最後的

00:32:07.594 --> 00:32:11.231 
過濾方法參數是閉包本身

00:32:12.199 --> 00:32:14.902 
我們可以把它變成結尾閉包
並且可以刪掉括號

00:32:15.669 --> 00:32:17.871 
我們得到的是這個樣子

00:32:18.472 --> 00:32:19.706 
現在唯一的問題是

00:32:19.773 --> 00:32:22.109 
沒有符號聲明調用了原子元素

00:32:22.609 --> 00:32:23.577 
因爲我刪掉了

00:32:24.278 --> 00:32:28.315 
但是我可以每次傳遞給過濾閉包一個項

00:32:28.382 --> 00:32:32.152 
而且可以這樣參考那個參數

00:32:32.853 --> 00:32:35.255 
這是完全一樣的代碼
如果大家懷念Perl代碼

00:32:35.722 --> 00:32:37.191 
這裏就是

00:32:44.498 --> 00:32:46.066 
現在可以檢測一下

00:32:46.133 --> 00:32:48.302 
我們放入字母N 不錯

00:32:48.902 --> 00:32:51.538 
現在有了這些元素不過
它們不是在正確的方向分類

00:32:51.805 --> 00:32:52.840 
實際上 它們就沒有分類

00:32:53.140 --> 00:32:55.375 
我們快速繼續加入分類

00:32:55.809 --> 00:32:58.345 
我會把它加在現有閉包的結尾

00:32:58.412 --> 00:33:01.682 
.sort在本例中

00:33:01.748 --> 00:33:05.118 
我雙擊這個藍色的符號 讓它展開

00:33:05.185 --> 00:33:07.154 
還有很多方式可以比較字符串 

00:33:07.287 --> 00:33:10.490 
比如大小寫和區分比較本地化比較等等

00:33:10.824 --> 00:33:13.794 
但是因爲我知道某種程度上 我得到

00:33:14.261 --> 00:33:17.497 
一個原子元素 
接着又得到一個原子元素

00:33:17.564 --> 00:33:21.902 
我只需要明確哪個在前 哪個在後

00:33:22.202 --> 00:33:24.404 
或是否一個在另一個之前 我可以自己

00:33:24.538 --> 00:33:28.041 
編寫閉包首先識別
我會有兩個原子元素傳遞過來 

00:33:28.709 --> 00:33:31.812 
拿到第一個來查看名稱

00:33:31.879 --> 00:33:32.913 
然後是第二個

00:33:32.980 --> 00:33:33.947 
也要查看名稱

00:33:36.416 --> 00:33:38.452 
其本身不會做比較

00:33:39.019 --> 00:33:41.288 
但是在Swift中我們過載了

00:33:41.355 --> 00:33:44.057 
許多標準運算符例如大於和小於

00:33:44.124 --> 00:33:47.261 
那麼它們會在你可能不希望它們處理的
類型上發揮作用 比如字符串

00:33:50.097 --> 00:33:51.498 
這是字符串比較

00:33:52.999 --> 00:33:54.201 
我再次運行

00:33:57.437 --> 00:34:01.408 
搜索字母N 現在分類妥當了

00:34:01.475 --> 00:34:03.644 
過濾和分類都在一行

00:34:04.011 --> 00:34:04.978 
我再檢查一遍

00:34:05.045 --> 00:34:06.380 
我們搜索S 

00:34:06.713 --> 00:34:08.047 
我有一些非常重要的元素

00:34:08.681 --> 00:34:10.016 
比如Swiftonium 

00:34:11.318 --> 00:34:12.386 
非常重要

00:34:13.587 --> 00:34:16.489 
好的<c.blue> 我們回來

00:34:17.623 --> 00:34:20.561 
在這部分我們通過

00:34:20.627 --> 00:34:23.362 
Swift的過濾方法執行過濾表視圖

00:34:25.599 --> 00:34:30.036 
然後用分類進行分類
看到過載操作符是小於或是大於

00:34:31.271 --> 00:34:33.907 
下面的功能
也是我想加入app中的最後一個功能

00:34:34.107 --> 00:34:37.476 
是可以選擇多個行 再做累計以便得到

00:34:37.811 --> 00:34:40.112 
所選元素的原子量

00:34:40.347 --> 00:34:41.348 
是這樣的

00:34:41.715 --> 00:34:44.117 
我們先從表視圖開始

00:34:44.818 --> 00:34:47.286 
頂部的導航條說選擇二或更多項

00:34:48.222 --> 00:34:52.626 
你選擇二或更多項
接着頂部的導航條確定其原子量總數

00:34:54.795 --> 00:34:57.097 
爲實現這一點我從內容數組開始

00:34:57.164 --> 00:34:58.899 
這就是我有的全部原子元素

00:34:58.966 --> 00:35:00.767 
那些是在表視圖中顯示的全部

00:35:01.001 --> 00:35:05.405 
但是我只想要 選中的原子元素

00:35:06.273 --> 00:35:08.942 
爲此 我不能前往表視圖

00:35:09.009 --> 00:35:12.646 
讓詢問視圖所選項的數組

00:35:12.946 --> 00:35:16.750 
我只能通過所選項的索引路徑來找

00:35:19.052 --> 00:35:22.189 
表視圖會給我所選項的索引路徑數組

00:35:22.389 --> 00:35:24.458 
我可以詢問索引路徑 還獲得這一行

00:35:24.525 --> 00:35:27.261 
我可以將這與支持數組內容相關聯

00:35:27.661 --> 00:35:30.597 
從這裏 生成所選元素

00:35:31.265 --> 00:35:32.366 
基本上 就是這個

00:35:32.999 --> 00:35:34.067 
我們生成新數組

00:35:34.334 --> 00:35:36.003 
循環索引路徑

00:35:36.236 --> 00:35:37.571 
返回內容

00:35:37.771 --> 00:35:42.910 
爲當前的索引路徑的行
找出對應的原子元素

00:35:43.443 --> 00:35:45.746 
如果你們習慣於這樣編碼

00:35:46.713 --> 00:35:48.549 
在Swift中也可以同樣

00:35:49.316 --> 00:35:50.150 
這是映射函數

00:35:51.051 --> 00:35:53.287 
重要的內容 還是用橙色表示

00:35:53.587 --> 00:35:55.155 
周圍所有的額外基礎架構

00:35:55.222 --> 00:35:56.490 
都已經刪除

00:35:58.859 --> 00:36:02.729 
接下來 一旦我有所有所選項的數組

00:36:03.697 --> 00:36:05.666 
我就想加上原子量

00:36:06.166 --> 00:36:09.770 
爲此 我會傳統地使用一個外循環

00:36:09.837 --> 00:36:12.039 
那裏 我把其變量設置爲零

00:36:12.105 --> 00:36:16.043 
接着重複所選對象並加上 

00:36:16.109 --> 00:36:18.645 
在本例中是D原子量

00:36:18.812 --> 00:36:21.148 
如果習慣用for-in循環做這類事

00:36:21.381 --> 00:36:22.916 
可以在Swift中也同樣如此

00:36:23.150 --> 00:36:26.153 
通過化簡函數 我們將初始值設爲零

00:36:26.220 --> 00:36:29.356 
接下來
我們加上採用初始值的閉包也就是零值

00:36:29.756 --> 00:36:32.960 
再把它附在傳遞來的下一項後面做累加

00:36:33.994 --> 00:36:36.563 
我給大家看看代碼 不過我會把所做的

00:36:37.030 --> 00:36:37.965 
全部內容用一行代碼

00:36:38.165 --> 00:36:39.800 
進行綜述像這樣

00:36:40.834 --> 00:36:42.503 
有個圖形設計師看過演示後

00:36:42.569 --> 00:36:44.538 
曾經問過我
能不能把這些放在一行中？

00:36:45.539 --> 00:36:46.907 
不 不可以

00:36:46.974 --> 00:36:47.975 
我覺得 你們看不到

00:36:48.442 --> 00:36:53.013 
我們轉到演示電腦上

00:37:02.823 --> 00:37:05.425 
現在就是所有內容的函數

00:37:05.626 --> 00:37:08.862 
首先要確保選中的是兩個以上的項

00:37:09.196 --> 00:37:11.532 
這樣大家可以看到

00:37:11.632 --> 00:37:15.836 
只要選中的項大於或
等於2就要繼續執行這個代碼

00:37:17.171 --> 00:37:20.507 
然後我會用映射
這樣可以獲得通過表視圖

00:37:20.574 --> 00:37:21.875 
而不是索引路徑所選定的對象

00:37:22.743 --> 00:37:25.078 
接着用化簡函數進行累加

00:37:25.846 --> 00:37:28.682 
最後
通過數字格式器傳遞固定在標題部分

00:37:29.149 --> 00:37:31.618 
如果想在一行內看到同樣內容
就是這樣

00:37:34.288 --> 00:37:35.622 
在我運行程序時

00:37:39.726 --> 00:37:41.261 
就會做累加並把結果放在頂部

00:37:42.062 --> 00:37:47.034 
這樣顯示映射和化簡會使與支持表視圖
的項一起配合會更容易些

00:37:56.176 --> 00:37:59.446 
好 總之 

00:38:00.314 --> 00:38:03.450 
我希望大家發現使用Swift
會有很多好處

00:38:03.517 --> 00:38:06.053 
甚至可以和現有的
Objective-C項目配合使用

00:38:06.119 --> 00:38:08.922 
這並不難 而且還有諸多好處

00:38:09.489 --> 00:38:11.225 
大家不必把任何現有代碼都扔掉

00:38:11.291 --> 00:38:15.996 
而且會習慣使用這些現代的強大技術
例如化簡和映射

00:38:16.063 --> 00:38:17.631 
和這些功能強大的結構等等 

00:38:18.532 --> 00:38:20.267 
若想了解更多詳情可以來實驗室找我們

00:38:20.334 --> 00:38:22.669 
查看文檔資料訪問開發人員論壇

00:38:23.003 --> 00:38:24.238 
給斯特凡發郵件

00:38:24.304 --> 00:38:25.205 
他喜歡收郵件

00:38:25.272 --> 00:38:27.274 
你可以告訴他大會開的非常好
就行了

00:38:27.741 --> 00:38:29.810 
這麼說 我會非常感謝你
希望大家喜歡這次大會