音頻單元擴展
謝謝 早上好
我是道格·懷亞特Core Audio的團隊
我想向大家展示我們新近研發的產品
叫做音頻單元擴展
這是iOS 9和OS X ElCapitan系統的一項新技術
關於音頻單元自OS X和iOS系統誕生伊始
我們就在操作系統中植入了該技術
操作系統包括許多內置單元
從I/O單元到混音器
給軟件採樣器提供了多種不同的特效
在我們的許多高級API中
我們都使用了這些內置音頻單元
比如媒體播放棧
但是音頻單元同時也是一款OS X中
廣泛使用的第三方插件格式
市面上有着成千上萬種
第三方音頻單元
現在音頻單元擴展
使我們首次在OS X和iOS系統中
擁有了全能插件模型
音頻單元擴展是基於應用擴展技術開發的
這就意味着 如果你在編寫插件你可以將插件
打包進App而App可以在App Stores中進行銷售
作爲該技術的一部分我們優化了API
同時維持了兼容性
在這次演講中我將詳細彙報這一新的API
我們將它稱爲第三代音頻單元API
在音頻單元框架基礎之上
使用AUAudioUnit的Objective-C類型建開發而成
既然從屬於Objective-C類別當然能夠與Swift完美兼容
我們都將見證這一點
本次演講我們還會討論
AVFoundation框架內的其他許多類別
我們有AV音頻單元組件管理器
和AV音頻單元組件
用來定位系統中的音頻組件
這在iOS 9中還是首次
在Yosemite系統也是如此
在今天我們將要展示的代碼樣本中
我們也將會用到AVAudioEngine
尤其是AVAudioUnit
和AVAudioUnitEffect類別
兩者都是在去年的OS發佈的
那麼現在我們談一談兼容性
這是OS X中的情況
我們現在擁有二代音頻單元主機
以及二代音頻單元執行
主機與音頻部件實例之間
通過信息通訊
實現執行功能
則基於音頻部件出廠功能基礎
我們擁有一組新的API
因此就有了使用這些API的新主機
以及植入的使用這些新的API的音頻單元
主機與 AU音頻單元類通訊
新的第三代音頻單元會將AU音頻單元納入子類
這就成了兩種不同的API
我們怎麼才能確保兼容呢
我們需要在這兩種API之間使用橋站
正因有了橋站我們會發現
第三代主機與現有的二代音頻單元
幾乎完全兼容
相反現有的二代主機只需要很小的改動
就可適應新的第三代音頻單元
我將詳細介紹這些API的改動
現在我將給大家展示
在經過細微改良的Logic Pro版本中
使用新的音頻單元的演示
這裏有一小段音樂裏面有鼓點循環
我將把一個音頻單元放到這條音軌上
這裏所有的都是Apple內置的音頻單元
這裏還有一個叫做v3失真的演示音頻單元
這樣我打開這個音頻單元
我可以找到心儀的預置方案我們可以聽到Logic
通過這個音頻單元播放出來
聲音很乾
完全失真了
現在如果我查看活動監視器
我們可以發現
這個失真音頻單元在一個獨立進程AU v3 失真中運作
這會消耗一點CPU
會佔據一些線程
假設這個音頻單元內部有一個bug它就會崩潰
我可以在活動監視器中進行模擬
我可以強制退出
注意Logic界面一片空白
但音樂還在繼續播放
這是我們剛剛探討問題的一個圖
這是經過細微改良的Logic Pro
但本質上還是使用現有的二代API進行通訊
與AU音頻單元橋接
進而在獨立擴展服務進程中
我們看到失真AU音頻單元子類
和定製的視圖控制器同時運行
Logic進程中也有視圖控制器
你可以看到這些是如何
進行跨進程橋接的
現在我們再看託管音頻單元
我將向大家展示使用三代API的一個案例
我們有這一段稱爲音頻單元v3 Example的樣本代碼
幾小時前我檢查過這段代碼還沒有寫好
我希望今天它能夠工作正常
在這個樣本代碼項目中你可以看到有很多個樣靶
其中一個叫做AU主機
這個App相當簡潔明瞭
但它展示了怎樣找到並打開系統中音頻單元的過程
怎樣連接形成特效鏈
怎樣選擇音頻單元預置方案
以及怎樣打開音頻單元自定義界面
因此在AU主機app中我們有所謂的簡單播放引擎
也就是使用AVAudioEngine的Swift類
它使用一個AV音頻播放器結點
並連接到AV音頻單元特效
繼而AV音頻單元特效顯示出
內部的AU音頻單元
也就是第三代音頻單元API的一個主類
播放器連接到特效器 
混音器和輸出上
這就是簡單播放引擎的工作原理
我們還將看到如何使用
AV音頻單元組件管理器類別選擇系統中的
AV音頻單元組件
以及控制AV音頻單元選擇的特效
讓我們來看一段代碼
首先在使用音頻單元時
我們有一個非常重要的數據結構
我們有音頻組件描述
以及三個相關的主要域組件類別
子類別以及製造商
這一元組標記出系統中特定的音頻單元
標記也十分重要
由音頻組件部分植入
系統也會植入新的音頻組件
在解說過程中我們還會對部分進行細緻探討
很重要的一點是
這是識別插件的關鍵
因此 爲了找到系統中的音頻單元組件
首先我們需要創建一個包含通配符的
音頻組件描述
這裏我們所說的組件類別是特效
那並不是通配符 
這裏還有組件子類別和元製造商
那些纔是通配符這樣我們有了組件描述
可以識別任何特效了
接下來我們可以選擇任意特效組件描述
應用到AV音頻單元組件管理器
我們會得到與通配符相適應的系統中的
所有特效的渲染
現在我們有了一系列AV音頻單元組件對象
其中包含了名稱 標籤
以及該單元的音頻組件描述
我們得到了一系列的組件
我們可以將它放回UI中
繼而UI可以在簡單播放引擎中使用這種方法
挑選出一種此前已經上市的
特效組件
這樣我們得到了一個組件
將它使用到一種內部的方法上
這種內部方法的本質
就是這樣
我們將命名一種新的AV音頻單元分類方法
這種方法需要基於這裏的
組件描述創造一個實例
這是一種異步功能也就是說它會進行實例化
但真正將音頻單元實例化
並且我們可以使用之後
就會自行關閉
因此這裏我們可以得到回饋信號
這是Swift閉合語法
我們有自己的AV音頻單元
隨後我們可以將它應用到我們的引擎上
我們將它儲存到一個成員變量即特效中
我們也就得到了一個可以察覺特效的AV音頻單元
我們對引擎打入補丁
特效和主混音器斷開
然後連接播放器和特效
然後特效再連接到主混音器節點
這樣我們就在播放引擎中加入了一種特效
我們可以保存真實的AU音頻單元
這是插件利用插件我們可以做各種各樣有趣的事情
比如操控組件的特效預置方案和參數
例如 從這裏我們將看到出廠預置方案的列表
這也將向表格視圖而不是UI中
植入一個域
這樣 用戶可以選擇出廠預置
最後我們還想向諸位展示
我們將怎樣利用接下來我要展示的App
得到音頻單元的自定義視圖
以及怎樣將其嵌入主程序視圖
現在我們進入了主機的視圖控制器
我們要求播放引擎給我們音頻單元
然後再從音頻單元中
獲得視圖控制器
當完成了這些步驟之後它將反饋給我們
一個視圖控制器我們就將它嵌入到主視圖中
好的 接下來有請我的同事邁克爾·霍普金斯
爲大家演示這個App是如何運作的
非常感謝你 道格
非常榮幸今天有機會
向大家演示這款基於AVAudioEngine第三代主應用
如何在iPad上使用
正如你所見我點擊一下主機的圖標
就可以打開它
在屏幕的左手邊我們有一個包含音頻單元
在系統呈現的所有特效的列表
既包含了內部Apple音頻組件的特效
也包含了我自己添加的
新擴展的第三代音頻單元
在屏幕的頂端有一個播放鍵 
點擊可以觸發鼓點循環的播放
現在讓我們來看看怎樣應用一些特效結點
以及怎樣將它們加到圖表中
首先我播放一次無特效音樂
然後我再加幾個特效
這樣方便大家聽出它的作用
利用高通率波器濾除大部分鐃鈸的聲音
以及其他高頻聲音
聲音略有延遲在這個屋子裏不是很聽得清楚
這段音樂就播放到這兒我們繼續
現在我在向大家展示
在iPad上運行音頻擴展單元
這將會是它的處女秀
這是一首失真的演示
當選擇之後大家可以看到
音頻單元所提供的所有出廠預置的列表
這裏麪包含了一些鼓點特別明顯的方案
也包含了一些非常狂野的設置比如外星人的叨叨聲
剛纔道格提到
第三代音頻單元在iOS上有自定義界面
我將向大家演示
我繼續演示點擊視圖按鈕
我們所完成的是從音頻單元中
加載視圖控制器的動作
我將它作爲子視圖控制器安裝在App中
我們首次在主機中擁有
帶有UI的內置音頻單元
我們有一個很大的滑動條對不起 是按鈕
可以用來控制失真的量
請允許我繼續我將播放這段聲音
以便諸位能親耳判別
這真的很有趣
我們可以在一個主應用中
流暢地使用多點觸控的UI
而且省去了很多麻煩
過去我們還得切換到另一個App
搗鼓半天再切回主應用
開始錄音後再切換回去
現在你再也不必重複這些步驟了
謝謝
我還想指出
這個音頻單元正是剛纔道格在Logic裏面播放演示中 
使用的那個音頻單元
事實上 音頻單元的源代碼完全一樣
無需再做修改
編碼也十分相似因爲編寫過程中
我使用了Core Animation
以使API更爲便攜
要將這個音頻單元植入iOS 
唯一需要做的必要改變就是事件模型
我們需要用UIKit裏的觸摸事件
代替桌面的APPkit鼠標事件
說真的 諸位有機會利用一點點改變
就可以在桌面和iOS上
同時發佈一個音頻單元
非常感謝
現場交還給道格
感謝邁克爾
我想和大家探討一下
不使用AVAudioEngine的情況下
怎樣在主操作程序中使用音頻單元的問題
在使用AU音頻單元類
異步創建一個組件描述實例時
我們會使用類似的方法
請看那裏
對於還在使用二代主機的人來說
我們最簡單的翻譯途徑是
使用音頻組件進行實例化
我們將細緻探討該問題
現在 我想和大家探討一下
用擴展服務進程替代插件
加載到主機進程中的問題
任何接觸過音頻單元的人都清楚
利用我們現有的插件模型
插件總是加載到主機進程中
對於三代主機來說也是這樣
如果是一個二代插件
可能是iOS上使用的蘋果插件
也可能是OS X上使用的第三方插件
但不論哪種情形都是二代音頻單元
不需要考慮其他因素始終是加載到主機進程中的
現在三代音頻單元講起來
略微有點複雜
在初始狀態下三代音頻單元加載到
一個獨立的擴展服務進程
這張圖表顯示的是在Logic出現之前我們所見情形
對於二代和三代主機來說
這都是正確的
現在OS X上插件只能
直接加載到主機進程中
爲了使之成爲可能需要同時使用到二者
在實例化音頻單元時
主機需要將選項傳遞給
我們剛纔所見到的任意一種異步創建方法
你可以看到新標記的名稱
叫做進程加載音頻單元
還需要利用
音頻組件包列表條目
進行特殊的打包和授權
如果同時使用
那麼框架將把插件
加載到主機進程
主機將會直接與插件的
AU音頻單元子類進行通訊
作爲一個主機編寫人員你爲什麼想這樣做呢
原因是要在安全性和性能之間
進行權衡
毋庸置疑 向App中添加第三方代碼會有安全風險
如果在App中崩潰
用戶埋怨的將會是你
而不是特效不佳的插件
但另一方面 出於性能考慮
如果你在做主機
你想向進程中加載插件
因爲與獨立的擴展服務程序通訊
會造成一些間接損耗
我們以40微秒
爲一個渲染週期進行了計算
你可以自行計算一下
這在你的主機中有多麼重大的意義
可能還需要與一些程序外的插件進行通訊
你還需要把這部分算上
此外你預期渲染多少聲頻
同樣也是需要考慮的因素
比如 如果以32幀這樣在每個渲染循環之間間隔爲1毫秒
因此40微秒的損耗將
佔據高達5.5%的比例
如果你是主機編寫人員你需要做出這樣的權衡
我之前提到過
現有的二代音頻單元主機
在與三代音頻單元共存時需要幾處改變
以下便是需要改變的地方
我提到了音頻組件描述標記
這裏便是組件標記
這是一種稱爲異步實例化需求的新標記
它適用於多數哪怕不是全部的三代音頻單元
如果你在組件描述中看到了這個標記
你就必須使用新的音頻組件實例化方法
而不是音頻組件新實例
類似的在二代主機上
如果你想進入一個音頻單元的視圖控制器
你也必須使用一種新的異步方法
有一種新的屬性請求視圖控制器
也是異步的
你可以在音頻單元屬性h部分中
詳細閱讀
關於這些異步方法
你可以利用二代單元使用新的方法
但如果有標記那就必須使用三代單元
我們的思路是
我們這麼做的動機是因爲這樣能提高響應能力
如果實例化音頻單元需要半秒
如果你釋放主線程
你的主應用 儀表或者其他動畫
將繼續流暢運行
尤其是在更新現有代碼時
這也正是我在測試內測代碼時
做的第一件事
就像坐在那兒
乾等主線程完成異步操作
千萬別這麼幹
因爲這樣不僅會打亂你正在製作的任何圖表
而且會擾亂框架的基礎程序
而這些可能是音頻單元實例化中所必要的
如果你乾等主線程那麼你將會陷入僵局
千萬別這麼幹
現在我們把話題
從主機音頻單元轉到
使用三代API創建音頻單元上來
首先考慮到新的音頻單元模型是基於應用擴展的
我們簡單聊一聊應用擴展
應用擴展是appex.文件類型擴展
Xcode將把它們嵌入App插件條目中
我們可以看到系統是如何
將它們加載到獨立的擴展服務進程中的
你可以在應用擴展編寫指南中
讀到應用擴展的全部細節
我們新的樣本代碼項目音頻單元v3示例
包含了一段叫做Filter Demo的
示例音頻單元執行
當你研究樣本項目時
你會發現Filter Demo有三個目標
它有我們所說的容器App
裏面有有應用擴展
和普通代碼的框架
App和擴展都鏈接到框架中
在框架內 我們有兩種主要的類別
一種是AU v3 Filter Demo
是AU音頻單元的子類別
還有一種是Filter Demo視圖控制器
控制着音頻單元的自定義界面
這麼做最酷的一面就是
我們開發了
屬於自己的信號處理和視圖代碼
我們可以完全在自己App的環境中完成
因此我們不再是在獨立的SPC服務進程中清除bug
而是在與我們自己的App交互過程中清除bug
開發屬於自己的代碼
我們還讓用戶在打開App時
覺得看起來很不錯
這並不僅僅是一種爲了別人而設計的插件
我們也不是通過複製代碼
才實現這一目標
這在OS X上還有一個額外的好處
如果我們想的話
我們可以指定這一框架成爲主進程加載束
讓我們看看應用擴展
這裏有一個包含很多重要條目的info plist
NSExtensionPointIdentifier告訴系統
這是什麼樣的擴展
主故事板告訴系統
當打開我的擴展服務進程時打開故事板
最後 還有一個音頻組件序列告訴系統
這是我在註冊的
音頻組件描述
簡單提示一下在你的故事板中
你必須明確你的自定義類
如果你要把它嵌入一個獨立框架
你需要明確是哪個模塊
就像我們這裏的一樣
擴展本身其實沒有代碼
有的只是一小部分確保裏面有代碼
我們要鏈接Filter Demo框架
這裏的都是好東西
我們有一個全局變量來指向它
讓我們回到框架
框架中的主類別是
Filter Demo視圖控制器
在擴展術語中
這是擴展的首要類別
創建或者加載擴展時
系統都會創建一個
屬於這個首要類別的實例
它有兩個主要任務
它創建AU音頻單元的子類別
比如你所預見的視圖控制器
它創建並管理插件定製界面
這是Filter Demo視圖控制器類別定義
從AU視圖控制器演變而來
本質上是一種NS或者UI視圖控制器
還使用了一種叫做
AU音頻單元工工廠的協議
那是一個簡單的協議僅僅使用了一種方法 
利用組件描述創建音頻單元
這一方法的任務是
創建AU音頻單元的子類別
也就是這裏的AU v3 Filter Demo
現在讓我們看看AU音頻單元的子類別
由於種種原因我們只簡單地探討一下
這些實際上是內嵌的C++類別或對象
所有算法都是在濾波器DSP kernel中進行的
我們一會兒可以聽到
這比單是看它的代碼有趣多了
我們有一些處理總線的代碼
這是特效它有一個輸入一個輸出
我們的基本類別需要我們提供一連串的總線
從而有支持的數字
我們有所謂的參數樹
稍後我們會弄清它是指什麼
這是初始化器
我們要做的第一件事就是初始化我們的輸入和輸出總線
然後將它們彙總到總線序列
這些總線序列都包含一個單獨的總線
現在我們看看參數
每個參數都是一個對象
每個對象你都可以把它想成
連接執行和主機之間的橋樑
中間是參數對象
這是一個簡單的低通濾波器
只有兩個參數
截止頻率和停留
每個參數都有標識符
這裏我們說截止
它有一個本地化的名字
我們做的不對這裏沒有進行本地化
它有地址
我們簡要探討一下它
排列這些單元或者標記
在使用二代音頻單元時
你會覺得這些標記是一樣的
這樣我們創建了我們的第一個參數
我們會以幾乎一樣的方式創建第二個參數
最後我們可以創建我們自己的參數樹
將這兩個參數排成序列
這樣我們就有了我們自己的參數樹我們想要將它接通
以便與我們的DSP代碼相連
我們的方法是在參數樹中
安裝一個叫做執行器值觀測器的塊
只要是主機或界面參數改變
這個塊在任何時候都可以被調動
因此 針對這種改變
我們僅僅需要在我們的DSP kernel中設置新的值
可以立刻獲得音響特效
反過來有時這個參數樹
需要信號處理過程
更新參數值
它從DSP
獲取當前值
將它反饋到參數樹上
這是一種重要的替換值方法
如果你熟悉二代音頻單元API
這一過程被稱爲音頻單元初始化
這在Objective-C可不是一個很好的名字
所以我們決定要將它具體化
初始化的時間就是用來
準備渲染和分配有關的渲染資源
比如緩衝 DSP狀態 等等
我們首要做的事情被稱爲基礎類別方法
然後我們要求總線分配存儲空間給插件
以便聲頻輸入
我們可以初始化我們的信號處理
要根據現在輸出總線的通道數和採樣率
因此我們有一種完全相反的方法
叫做解除渲染資源分配
我們把這還稱爲基礎類
原則上撤銷我們在分配過程中所做的一切
利用塊進行渲染過程
在每個渲染循環中都會用到
但我們需要在渲染開始前就提供塊
我們捕獲C++代碼
改成作爲指針局部變量
原因是我們需要在實時環境中操作塊
這對於處理任何Objective-C對象來說都不安全
運行時間會阻塞
造成音頻故障
因此我們將再次捕獲C++代碼變量
然後在放回塊
它將反饋AU音頻單元狀態
如果你熟悉二代API
參數大體一致
有時間標記 許多樣本幀
一個輸出音頻緩衝表
這裏是一個新玩意兒叫做實時事件表頭
我將詳細介紹它
它還與計劃參數和MIDI事件相關
最後是推動輸入塊
主機告訴我們這叫音頻單元的執行器
獲得輸入的來源
因此在輸入塊的內部
我們要做的第一件事
就是將推動輸入塊交給輸入C++對象
並且要求輸入塊爲渲染循環抓取音頻輸入
隨後我們清理清理緩衝
我們再把它們交給DSP狀態
最後 DSP狀態爲渲染循環處理音頻
緩衝器已經收到信號
只需給它一個時間標記和幀計數
以及實時事件的鏈接表
這便是這個音頻單元的內容
但代碼的全部並不止這些
實際信號處理的代碼
遠比這多得多
但正如我們剛纔講的那樣
聽遠比看來得好
因此我想再次請回邁克爾·霍普金斯
向我們展示AU v3 Filter Demo
謝謝道格
我繼續講 從包含擴展的應用容器開始
你將首先看到
屏幕左邊是我們的Filter Demo
我們將它分解成代碼樣本
右邊是我之前給你們演示的失真演示應用
我將啓動Filter Demo
在屏幕的頂部
你會看到
道格談到的兩個參數
在停留參數中有停止點
在UI中永一個滑動塊
和一個文本域來表示
實際上 應用包括了這部分UI 
而主屏幕面積較大的圖案
實際上是音頻單元
嵌入視圖
我可以通過拖動滑動條
來改變參數的值
看有什麼變化應用改變
該參數的值也改變
視圖也隨參數而更新
正如您將看到更新是實時的
相反我可以直接
點擊和拖動
我們嵌入的音頻單元
你會注意到當我用手指拖動它時
應用接收到參數已經改變的通知
然後會依次更新
但這是一種沒有音樂的
無聊演示 對吧
讓我們來聽一聽
我能整天做這個
你有時間嗎
現在真的很酷 很流暢謝謝
用你的手指就可以玩多觸點UI
非常有趣
很神奇
另一件有趣的事是
因爲我們以這種方式設計的用戶界面
可以適應任何大小尺寸的設備
我們以這個iPad爲例
旋轉後看到不同的用戶界面
從縱向視圖到橫向視圖 反之亦然
我們能做到這點是因爲我們支持自動佈局
我們考慮大小等級 
但當我們把它放到
我們的主應用中
而主應用的屏幕專用插件更小會發生什麼呢
所以我返回
打開主機
我要清除失真樣本
嵌入我們的Filter Demo視圖
點擊視圖加載
現在你可以看到
雖然加載的垂直空間很有限 水平比較大
但是仍能可以運行
沒有標籤重疊
它仍然完全按我們所期望的運行
這是一個奇妙的新技術
我們很興奮 終於能夠給你們
我都迫不及待地想看看在你們的iOS應用上運行的情況了
謝謝
謝謝你 邁克
現在我大概講一下關於包含應用
這個是插件載體
通過快速迭代和快速開發提供協助
但你可能考慮在包含應用裏放置其他東西
通過Filter Demo我們知道有簡單播放引擎
而且你還可以加載
某些複雜的播放引擎
主體應用能滿足你的需求 
你可以在其中放置觸摸控制器
在插件視圖裏可能沒有空間
儲存全部觸摸控制器
就算空間足夠 但你可能考慮
在包含應用中
儲存其他東西
這個應用還能儲存文件資料
還有壓縮插件視圖的功能
下面是關於創建一個應用擴展的總結
如果你要在OS X系統進程上加載構架
先拋開Swift語言不講
我們也不建議你們在OS X系統上這樣做
因爲Swift API可能會變化
如果你開發不兼容Swift版本一的插件
並且加載到使用Swift其他版本的主機
會出現問題
情況會很糟糕
我們知道你在這兒看到樣本代碼
你會試着開發自己的插件
你需要知道有三個相關指標需要開發
這有一點兒複雜
我們計劃開發X code模板
但是現在你可以從隨意複製Filter Demo
現在我從主機和實現兩個方面 
總體講一下
關於現代化AU音頻單元API
針對版本2和版本3的屬性
我們來做一下比較
版本2AU音頻單元API
屬性有作用域和元素
全局範圍有大量屬性可用
所以可以編寫很多代碼
K音頻單元全局範圍和元素0
在Swift語言中非常折磨人
很多的屬性值都是無效指針
都出都可以看到無用指標
這着實讓我頭疼
對這些功能我們爭議頗多
相比較之下 在版本3 API裏
屬性依舊是那些屬性
我們在Objective-C和Swift語言裏使用了dot語法
這樣你就可以以最大幀的AU進行渲染
我們還對關鍵值編碼和關鍵值觀測兼容進行分類
這樣你就可以對鍵使用值
對關鍵路徑添加觀測器
我們還對總線陣列添加專門的KVO方法
對所有的總線添加觀測器這樣你就不必
同時時刻注意總線
還可以在總線上添加KVO觀測器
免去了許多麻煩
說到總線 在新的API中
這些都已經進行了完善
我們擁有AU音頻單元總線陣列
AU音頻單元有一組輸入總線
和一組輸出總線
並且總線有兩個主要屬性
他們有一種格式和一個名稱
格式由主機處理
我們可以拒絕我們不想要的格式
版本3的音頻單元使用的格式
與版本2 相同
讓我們看一下參數
在版本2的API和參數中
這裏有一些問題
因爲我們改變的是屬性
這裏有些不實用範圍元素ID元祖
此外在較爲複雜的AU中 
這裏的位元不足
再次我們開發了帶有長參數列表的功能
我們也開發了更好的AU事件監聽器API
版本3的API中之前曾在
介紹參數樹和Filter Demo的時候提到
當然 這是個完整的參數樹
可以對其進行分組 
這是有模擬合成器的簡單模擬例子
它有振盪器組 過濾組和放大器組
這個過濾器和放大器組下還有組
在這個顏色最鮮豔盒子下是參數 波形八度
濾波器截止點和共振
包線區 維持和釋放
這些盒子都是節點  
不管是組別還是參數 
在參數樹上的節點都有一個唯一的永久的ID
這個像一個C標識符
所以用這些唯一的ID我們可以啓動KVC
然後找到想要的參數
例如振盪器 波動或者濾波器 包線等
這讓那些具有龐大的數據樹
更爲複雜的音頻組件
變得更爲靈活
現在  你會注意到
參數有數字地址
且是64個位的地址但是在任何時候
我們必須認爲這只是暫時地址
因爲這些地址不是我們設定的
也就是說如果我是一個主應用  
我想記錄參數自動化  
我應該記錄使用關鍵路徑的自動化參數
而不是其地址
我之前提到過
AU參數對象
參數值在主機和視圖之間的通訊中心
另一方面 也是音頻單元執行器
現在  從主機的角度來看
參數對象屬性 包括值
還有最小值和最大值等等
所以我們可進行設置
並獲得使用點記法的參數值
現在我們仍然可以按照防止反饋迴路發生的方式
進行數值設置  
這在性能和UI簡化方面都有優勢
我們不希望看到的情況是在我們滑動到下一個畫面後
看到與前一張不同的通知
所以設置值的方法可以實現這種效果
並且在往參數 參數樹或者參數組添加觀測器後
可以看到標誌
當我們這樣操作時  
我們能返回參數這就是我們在底部所看到的
這裏有個塊稱爲AU參數觀測器
通過觀測器 我們能看到
參數改變後的地址和新值
至於執行方面 我們在Filter Demo已經瞭解到
有執行器 值觀測器 
以及值供應塊
現在 我們在Filter Demo中
將這些塊安裝到參數樹上
也可以安裝到參數樹的任意位置
甚至可以安裝到單個參數上
我也想展示下在調度參數方面
我們已經做到的事情
因爲我想在版本2的API 中
這是個大的改進
我們有主機和執行器
可以分別處理不同事件
但這裏我們還使用了AU音頻單元基礎分類
從而幫助我們實現該功能
所以主機能從AU音頻單元獲得一個模塊
稱之爲計劃參數模塊
渲染過程中  調用該模塊
精準改變參數
所以第一個要做的計劃表是一個抽樣時間
這個計劃表值會累增
如果音頻單元使用累增方式
例如蘋果婚姻器所做的一樣
最後的2個參數  
功能參數和參數地址
將被改變成新的參數值
在執行方面
事情略有不同
我們從主機那得到的 並不僅僅是傳遞操作
相反基礎類將獲得
剛我們在Filter Demo看到的
內部渲染塊
它將把只屬於渲染循環的實時事件
傳遞到渲染塊上
所以基礎類會保證
所有待定預訂參量變換計劃表的完整
只在渲染時
分配相關塊到音頻單元中
這就是參數計劃策略
在MIDI事件中我們也做了完全相同的事情
主機在開始渲染前
從音頻單元獲取了一個塊
在渲染時間裏調用那個塊
現在你可以看到我們在音頻單元API版本2中
增加了一個叫做網線的功能參數
它只有1個MIDI網線 16個通道
現在我們有256虛擬MIDI網線
如果想要有巨大樣品庫的音頻單元
現在可以做到了
所有的這些 都可以在虛擬MIDI網線中進行處理
在MIDI事件的執行方面
這與計劃參數的實現完全相同
基礎類AU 音頻單元保護內部計劃表
並僅在應該起作用的時候
在渲染循環期間 通過實時事件清單
將事件傳遞到內部渲染塊
我們認爲這是很大的改善
節省了執行器很多工作
關於渲染 總的來說 我們仍然使用拉模式
意思就是一個輸出裝置拉一個混音器
拉一個特效 拉另一個特效 拉播放器
音頻流通過鏈迴流
API版本2的不同點是
音頻單元需要保持一些狀態
這裏需要提到一個概念即它是否是從其他音頻單元上游
或一個功能反饋信號獲得輸入信號
API版本3中 就更簡單了
AU並不需要保持該狀態
我們在Filter Demo中
看到的反饋信號來自主機
且在每個渲染循環期間進行傳遞
其他的 API的功能極其相似
這使得我們可以
在它們之間快速連接
現在 若你的主機是直接調用AU 音頻單元進行渲染
而不是使用AU圖標或AVAudioEngine
這是會調用配置渲染源
然後將它們放在渲染塊中
你可調用渲染塊進行渲染
看起來和內部渲染塊非常相似
這些有必要回顧一下
在渲染時間出現的音頻緩衝器的一些規則
現在 主機提供了一個輸出音頻緩衝器清單
在輸出音頻緩衝器清單中 M數據指針可以是0
音頻單元必須用一個內部自備的緩衝器進行取代
同時AU必須保證
緩衝器持續有效直至下個渲染循環出現
以上是全部內容  順便說一下
和音頻單元版本2完全相同我一直在重複強調
因爲它真的很重要
現在 在渲染塊中有一些規則
和輸入緩衝器的規則相似但並不一樣
主機提供輸入塊AU調用它輸入
當AU調用那個塊進行輸入時
它必須爲那個塊提供
非0的M數據指針的有效音頻緩衝器清單
現在 主機允許取代儲存器的這些指針
即它擁有並可以確保保持有效
直至下個渲染循環出現或釋放渲染資源
所有這些是爲了達成一項重要目標
即減少重複操作
好 這裏有些幻燈片
讓程序員和大家開開眼
音頻渲染幾乎總是
在實時路徑環境裏發生的
這是個有限制的環境
因爲我們無法分配存儲器
意思是說我們甚至不需要
調用調度異步通信
事實上我們不能訪問因爲可能被限制了
比如獲取一個互斥量或等一個信號量
原因是 若我們進行限制那麼我們就限制了所有時間
然後系統中的音頻渲染路徑
將錯過它的截止期限
這時故障就會發生
所以在使用和調用
不好意思 是使用和執行這些渲染塊時需要非常小心
在Filter Demo中你可以看到我們如何準備一些塊長
以致不捕捉到我們自己的目標
或任何其他Objective-C目標
在塊中 我們避免了Objective-C運行時間
因爲Objective-C不安全
它可以獲得塊
不過Swift運行時間也完全相同
這也是爲什麼在Filter Demo中你將看到C++目標
我們爲這些C++目標捕獲指針
現在如果你討厭C++
你也可以用單純功能的C做一樣的事情
儘管我不太確定爲什麼你想要那麼做
討厭的東西已經說太多了
現在有請亞力克·利特爾
爲我們展示Apple Music創建app中的音頻單元擴展
謝謝你 道格我在Apple的音樂創建應用處工作
做的事情有GarageBand和Logic
我們很激動有新的音頻單元擴展
我們認爲它將爲開發者和用戶
提供真正的權利和創造的可能性
我會講到
我們的一些計劃
首先我們計劃支持音頻單元擴展
當然是在所有主要應用中支持
也就是GarageBand iOSGarageBand Mac
Logic Pro XLogic Pro 10和Mainstage
我們今天要做的是看一些例子
一些GarageBand iOS的非常漂亮的圖片
這只是很初級的東西
我們會給你們一些概念
關於作爲支持音頻單元擴展的主機
我們將計劃做什麼
首先我們將支持AU工具
接下來我要說的例子是
關於我們將如何執行這些AU工具的
首先用一些圖像
來解釋我們將要做什麼  很簡單的
但GarageBand將向視圖控制器進行請求
視圖控制器是一個自定義UI
等下我們會講到這個
將MIDI事件傳遞到音頻單元
當然隨後你會收到通過音頻總線的音頻
回到約定的圖片
GarageBand我們主啓動屏幕
進入接觸工具傳送帶
這裏有我們所有的接觸工具
鍵盤 鼓 小吉他 等等這類東西
看左邊  那裏有這個容器
若GarageBand看到設備上
已裝有音頻單元
容器會展示出來
我可以滑動到那個容器
那是我的音頻單元存在的地方
假若我輕敲它
可以看到設備上已經安裝了所有的音頻單元工具
現在如果我輕敲其中一個工具
我們可以看到一個大的灰色盒子和一個鍵盤 
我們將爲你展示
GarageBand裏面漂亮的內嵌視圖裏的自定義UI
我認爲整件事情最酷的部分是
我們會在主機裏
顯示音頻單元的真實情況
我們將爲你提供標準GarageBand鍵盤
以便你可以進行操作
我們將記錄MIDI並接收音頻
這只是之前說到的亮點而已
當你提供這些自定義UI時
請確保不會在這裏
防止任何自定義MIDI控制器類型的設備
因爲我們不會在GarageBand捕捉你的MIDI
來快速看一下我們在設備上的新改動
再一次 限制屏幕空間括大了
所以在右上角有個按鈕
這裏可以接入控制視圖
這是自定義UI
那裏所有的控制另外還有一點點空間
用戶可以在按鈕底下的鍵盤上操作
這或許是我今天講的最重要的幻燈片
這是我們在視圖控制器
要注意的要點
想讓GarageBand看起來更美觀
那就請多注意這些要點
我們將一起做一些很酷的事情
我們真的很高興可以看到
現在用戶可以通過GarageBand
真正地操作
音頻單元接口
我們也很高興可以和你們一起工作
想出很酷的東西
謝謝你 亞力克
我想你們應該會有些疑問
我來猜猜都有哪些
iOS上的跨應用音頻怎麼樣
這是個老問題了
有很多支持它的app
根據我們的觀點
這個使用了API版本2的部分子集
且不支持某些功能
比如參數支持 預置 等等
我收到這些請求
我想我們應該有一個完整的插件模型
這就是我們現在所有的
我們並不是不贊成跨應用音頻
我們只是看得更遠一些
通過音頻單元擴展增加這些以前沒有的功能
現在在OS X上
若你有主機和音頻單元
你或許會考慮兼容性的問題
連接橋將解決很多麻煩
它們是兼容的我們做了大量的工作
儘可能的讓這些東西可以起作用
但如果你可以或者需要一些功能時
我建議你升級到版本3
比如說 你可能想要重做
處理MIDI事件的方法或計劃參數
關於端口 我們有一個捷徑
它叫做AU音頻單元v2連接橋
這是一個AU音頻單元子類
在AU版本2上執行所以你可以從那開始
並開發出更加全面執行器
正如邁克爾剛提到的
音頻單元版本3
是iOS和OS X之間主要的交叉平臺
AU音頻單元上的信號處理代碼絕對是最方便的途徑
因爲無需進行UI實現
或任何依賴設備
AU視圖控制器來自UI或NSViewController
所以會感覺有些異類
但某些時候可以進入到特定平臺UI
我們快沒時間了
要講的話估計需要一個小時
此刻我建議你參考
音頻單元框架上的頁眉文件
由於一些歷史原因你需要連接AudioToolbox
主要的信頭文件是AU音頻單元h
但Core Audio工具箱框架上有其他的AU視圖控制器
這是帶AU音頻單元組件的AVFoundation框架
所有的這些裏面
都有很棒的信頭文件所以我強烈建議你查看一下
最後如果你想要用音頻單元標誌
我們還有一個白色版本
你可以查看這個鏈接獲取許可
以上部分到此結束
我們已經看到在iOS上的音頻裏
第一次有一個完整的插件模式
在OS X的音頻裏也第一次有一個完整的插件模式
通過打包音頻單元成app擴展
你就可以在iOS和OS X App Stores上
銷售音頻單元了
我們看了帶有AVAudioEngine的簡單主機應用
並添加到新品
音頻單元v3樣本之中
如果編寫樣品代碼時出現漏洞的話
我們鼓勵大家讀一下文件
然後在AU主機和實現上試試
我知道你一定會這麼做的
更多信息 這是我們昨天的部分
謝謝