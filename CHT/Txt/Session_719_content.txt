App與新一代網絡
謝謝 上午好
歡迎參加“App與新一代網絡”講座
我是普拉巴卡爾·拉卡拉另外還有我的同事斯圖爾特·柴歇爾
今天的講座分爲兩個部分
第一個主題關於IPv6
在第二個主題中斯圖爾特將會介紹
如何讓你的APP更快地運行
我們首先討論IPv6
IPv6有哪些新特性呢？
在大約17年以前IPv6 RFC就已經發表
你可能會想今天我們爲什麼要討論IPv6？
我們看到IPv6越來越多地
被部署到企業和蜂窩網絡之中
你需要確保你的APP
能夠在這些網絡中運行
因此你的APP應該強制兼容IPv6
現在我們將討論這個主題 以及它對於開發者的意義
但是在此之前
請讓我們先回顧一下歷史
在前些年客戶端設備具有真實
唯一的IPv4 那是以前的事情了
你需要進行端對端網絡連接
但是我們很快發現
IPv4地址就快要用完了
因此我們在中間加入NAT
這個方法是可行的但是大規模的NAT設備
不僅昂貴而且脆弱
因此現在運營商在他們的網絡中部署IPv6
利用IPv6以繼續提供端對端網絡連接，
不需要在數據路徑中進行轉換
現在 讓我們來看美國三個主要蜂窩運營商的IPv6部署情況
我們可以看到兩個特點
首先所有趨勢線都是上升的
其次一半以上的用戶
現在通過IPv6連接到
蜂窩數據網絡
看起來不錯是吧
但是對於網絡運營商來說
實際情況比以前更加糟糕
原因是他們的網絡現在必須同時
支持IPv4和IPv6
他們真正需要的是消除通過IPv4
訪問他們的網絡
如果這樣做將會導致
完全依靠IPv4連接網絡的設備和用戶流失
但 他們仍然是主流
現在運營商在他們的網絡中部署NS64和NAT64
其實現方式是當客戶端設備上的APP
進行主機名稱查詢
以獲得IPv4-only服務器的IPv6地址時
DNS64和網絡將合成一個IPv6地址
並提供給客戶端設備
現在客戶端設備可以使用這個IPv6地址
發送流量至網絡
網絡的配置方式
使搜索數據包被髮送給NAT64引擎
NAT64引擎將IPv6流量轉換成爲IPv4流量
在客戶端設備返回流量時NAT64引擎將進行相反的轉換
在這裏 必須注意的是
對於客戶端設備上運行的APP來說
你的IPv4-only服務器看去就你是IPv6-only服務器
這個特性很重要
因爲你們一些人可能會認爲
我的服務器僅配置用於IPv4
因此我不需要針對通過IPv6進行訪問的客戶端來測試我的APP
你的假設並不成立
我們很快就會轉換到
到這種類型的網絡 到那時
我們希望爲用戶提供無縫的用戶體驗
因此你的APP必須支持IPv6
APP必須符合這項要求
這是一項新的APP要求
你可能會想我應該如何針對此網絡來測試我的APP呢?
我可以在哪裏找到這種NAT64類型的網絡?
我有一個好消息告訴你們
你可以使用基於IPv4連接的Mac設備
創建你自己的NAT64網絡
並可以開始測試你的APP
這項新功能供開發人員使用
它隱藏起來了讓我們來看清楚一點你只需要
點擊“Sharing”選項然後點擊
“Internet Sharing”選項其他保持不變
這裏有一個新複選框顯示
“createNAT64 network” 
選中之後 可以選擇
Internet共享接口然後使用這個NAT64網絡
開始測試你的APP
在這裏舉例來說我有一個IPv4 Internet連接
我想要使用NAT64/DNS64
將這個連接作爲IPv6-only訪問網絡
在我的Wi-Fi接口上進行共享
當我開始這樣做時我看到Wi-Fi圖標變灰
並且變成箭頭
這表明Wi-Fi接口
轉爲接入點模式
其意義在於它成爲一個Wi-Fi熱點
你可以連接其他客戶端設備
並開始測試你的APP
典型的測試平臺是這樣的
在WAN側 IPv4Internet連接已經完成
我的iMac已經在運行DNS64/NAT64引擎
成爲使用Wi-Fi接口的IPv6網絡熱點
你想要測試的APP已經安裝在一臺客戶端機器上
你也可以在其他Mac設備上
運行的模擬器上測試你的APP
這個Mac必須是 此Internet共享環境的客戶端
現在 你已經可以
在這種類型的網絡進行測試 你真正想做的事情是
確保這種網絡成爲開發流程的組成部分
也就是說在任何時候當你編寫新的APP
或者編寫APP更新版本時
你需要在提交APP之前
確保在NAT64網絡環境下測試你的APP
現在對你們70%的人來說這是一個好消息
你的APP運行正常
這很不錯吧
你可以放心地測試
各個版本的APP確保不會有功能受到影響
但是有將近三分之一的人
將會看到在NAT64MQXT網絡環境下
你的APP要麼受到嚴重的限制或者根本無法運行
幸運的是大多數問題都容易修復
這裏是一個例子
現在如果你只使用IPv4-only數據結構
或IPv4-only API或者你使用同時支持
IPv4和IPv6的API
但是你傳遞一個參數
聲明你只想獲得IPv4結果
這會導致你的APP僅支持IPv4
這意味着 你的APP將無法在IPv6-only網絡環境下運行
對於這些無法運行的APP
我們看到另外一件有意思的事情
有時候在嘗試連接之前
APP會預先選擇IPv4連接
因此有時候你會看到這樣的錯誤信息
在這種情況下我的iPhone確實連接到我的Mac設備上
創建的NAT64網絡
我可以使用Safari 瀏覽互聯網內容
我可以觀看視頻 聽音樂...
我的Internet連接正常
但是出於一些原因APP認爲我沒有Internet連接
你會看到提示信息
說你的設備處於飛行模式
但是頂部信息欄卻不是這樣顯示的
那麼這是爲什麼呢？ 
這是因爲APP預先
設置成爲IPv4連接
但是在IPv6-only訪問網絡中例如NAT64網絡
並沒有IPv4連接
整個網絡對你來說完全是一個IPv6-only網絡
即使IPv4-only服務器看上去像是IPv6-only服務器
因此如果選擇這樣的設置將會發生失敗
在這種情況下APP將會提示你重試
我進行重試但是仍然會顯示相同的錯誤信息
然後我再重試仍然顯示相同的錯誤信息
這個信息不會消失因此無法使用APP進行其他操作
對此有什麼好方法嗎？
應該嘗試連接
如果能夠連接成功當然是好了
如果不能應該巧妙地進行處理
第二個建議是
使用更高級別的網絡框架例如NSURLSession
或CFNetwork API
原因是像iPhone和Mac等多址設備的
網絡連接有一點複雜
比如iPhone不僅有Wi-Fi接口
還有蜂窩網絡接口
多於Mac設備可能有多個以太網接口
而且也有Wi-Fi接口
在特定的時間
所有這些接口可能有不同類型的連接
你需要考慮使用哪個接口如何進行這種類型的連接
以連接到特定的目標
自已編寫代碼可能會費時費力
因此應該使用更高層次的網絡框架
這會讓你的APP代碼更加簡潔明瞭
如果出於某些原因你不能使用更高層次的網絡框架 
而且你必須使用socket
我們建議你閱讀RFC 4038
此RFC詳細地介紹瞭如何在地址族
不可知的情況下編寫APP
我們的最後建議是儘可能使用主機名
而不是直接使用IP地址
無論IPv4或IPv6
當你編寫自己的專用協議
或者編寫APP時
應確保不要直接使用IP地址
而應該優先使用主機名
其原因是
在NAT64/DNS64網絡環境中
客戶端設備首先會發出DNS查詢請求
以獲得IPv4服務器的IPv6地址
因此你必須使用主機名
如果你需要使用IPv4地址
客戶端設備將不會進行DNS查詢
DNS64網絡將不會爲你合成IPv6地址
我們知道有時候可能
無法避免使用IPv4例如使用Safari進行瀏覽時
你打開一個網頁顯示正常
但是在網頁內可能有其他一些鏈接
這些鏈接可能具有嵌入的IPv4地址
在此之前在Safari瀏覽器中
如果你點擊這樣的鏈接將不會打開網頁
從iOS 9和OS X 10.11開始
不僅Safari而且任何
NSURLSession或CFNetwork API用戶
將能夠在NAT64/DNS64網絡中使用IPv4地址
其工作原理是當你使用主機名時
網絡中的DNS64將會爲你合成IPv6 地址
但是當你直接使用IPv4地址
並且使用一個更高層次網絡API時
操作系統將會發現網絡行爲
並確定它將如何爲你
合成IPv6 地址並在本地完成此工作
這也是你爲什麼應該使用更高層次
網絡框架的另一個原因
因此應該這樣做
希望你能夠利用這些數據點
和新工具找到並解決APP中的問題
我們希望你做的事情是在本講座結束之後
在你們的Mac設備上安裝seed build
開始創建自己的NAT64網絡
然後使用它們測試你的APP
請記住這是APP應該遵守的一項要求
請將這個信息傳達給
未參加本講座的其他開發人員
並且把這個消息帶回你的公司確保使用NAT64網絡測試你的APP
現在請斯圖爾特·柴歇爾上臺
爲大家介紹其他的網絡功能
你們可以使用這些功能更快速地開發APP
並且提高APP的響應速度
有請斯圖爾特
謝謝普拉巴卡爾
我們想要討論如何讓APP加快運行速度
在過去的幾十年裏
我們看到網絡吞吐量飛速增長
我還記得在以前56k調制解調器就已經
屬於尖端科技而現在
50Mb/s網速已經很常見
但是我們並沒有感覺到網速成千倍提升
我們仍然需要花大量的時間來等待網頁打開
這是爲什麼呢？
這是因爲我們的行業專注於
提升吞吐量
但是卻忽略其他資源延遲
光速不會變得更快
對此我們無能爲力但是我們可以
消除其它方面的延遲現在我們應該致力於這些工作
這就是我今天要討論的主題
我想要討論四種類型的資源延遲
當用戶使用APP可能會遇到這些延遲
首先是當你遇到信號較弱的WiFi連接
而且連接不成功時
會遇到的延遲
第二個是使用“顯式擁塞通知”
即“Explicit CongestionNotification”技術
和智能隊列功能來減少網絡延遲
TCP NOTSENTLow-WaterMark選項
減少發送機器中的延遲
最後我們將瞭解
一種名爲TCP Fast Open的 令人激動新的技術
我們先開始討論如何進行可靠的網絡回退操作
我相信你們每個人都有這樣的經歷
下班之後離開辦公室
走向你的汽車拿出手機
然後想要查看地圖天氣預報和郵件等
你盯着手機但是沒有載入任何內容你走向汽車
但是仍然沒載入內容你感到煩躁不安
於是你進入“設置“關閉Wi-Fi
使用LTE數據連接網頁瞬間打開了
然後你忘記打開Wi-FI
一週之後你收到鉅額的數據流量賬單這可不是你想要的
對於用戶體驗來說這是糟糕的事情
現在我們要做的事情是
設置並行連接數字邏輯
這樣如果你的iPhone檢測到它在使用Wi-Fi
但是卻無法建立TCP連接
這時它會很快地通過蜂窩數據網絡
發起第二個並行連接
但是它不會完全中止Wi-Fi連接
並不會放棄Wi-Fi連接
它會並行嘗試Wi-Fi連接
如果連接成功
將會轉到Wi-Fi連接
如果連接不成功蜂窩網絡連接將率先完成
這樣APP的網絡連接延將
將會很短用戶甚至不會發現
當然此功能僅用於
允許使用蜂窩網絡的APP
如果用戶進入設置
禁止APP連接數據網絡我們將不會進行這種回退
如果我們進行回退將會隱藏Wi-Fi圖標
讓用戶知道他們沒有使用Wi-Fi
如果你使用更高層次的API
這並不會佔用額外的資源
而且這並不會影響
用戶獲得良好的使用體驗
你還需要做另外一件事情
也就是當你在蜂窩網絡上運行時
無論你首先連接到蜂窩網絡
還是回退到蜂窩網絡
用戶最後還可能會回到Wi-Fi範圍之內
那時，你將會看到“Better Route”通知
然後你可以決定應該怎麼做
你可能想要斷開數據連接重新連接到Wi-Fi
或者如果你的郵件發送進度已經達到99%
你可能想要完成發送
但是“Better Route”通知
讓你能夠進行
智能化的決定
從而儘量減少數據流量費用
下一個主題是網絡中的延遲
這是我在Apple TV開發中遇到的問題
我們努力提高Apple TV的響應速度
和理解延遲來源
我期望你們在座的每個人都聽說過“bufferbloat”即“緩存膨脹”
我做過一些實驗並且想和你們分享
這些實驗的結果
讓你們理解對於我們的所有APP和產品來說
消除網絡中的緩存膨脹問題是多麼重要
我測試過一個10Mb下行速度
模擬網絡環境，
這種網速對於觀看視頻來說已經足夠了
我將顯示使用代表性網絡設置所獲得的結果
這是一種簡單的先進先出隊列
數據包被緩存直到隊列變滿
不能再容納更多數據包新到達的數據包將被丟棄
這是現今的家用網關的典型配置
我將介紹另外一種更智能的隊列處理方法和ECN機制並進行比較
我將介紹一些使用tcptrace的方案
我期望你們很多人都使用過tcptrace
如果你們沒有使用過我強烈建議你們訪問
TCPtrace.org並下載它
如果你要編寫網絡代碼
而且不使用tcptrace來查看你的數據包
你將沒有辦法弄清楚
運行機制或理解APP 
和協議的性能特徵
在我們編寫APP時應該注意內存使用情況
應該分析代碼弄清楚哪些代碼佔用CPU
然後優化代碼
以提高CPU效率並且延長電池使用時間
爲此應該多關注CPU和內存使用情況
但是也不能忽略網絡部分
Tcptrace是一個工具讓你能夠方便地
進行網絡分析分析網絡流量
這是一個流媒體視頻的
前10秒的TCPtrace
如果你們一些人以前沒有見過tcptrace
讓我來簡要介紹一下
這些白色的短線條表示數據包
白色線條所處的位置表示數據包被捕獲的時間
白色線條的高度告訴我們
數據包有多少字節線條的垂直位置
告訴我們在整個邏輯TCP序列，數字空間內的哪些位置
收到這些數據包
在這裏我們可以看到正在按順序向外發送數據包流
其間隔爲數毫秒
在返回數據時我們看到接收端的應答消息
聲稱它已經收到數據
綠色線條表示累積應答線條
所有數據包括綠色線條都得到接收端的確認
因此沒有任何白色數據包位於綠色線條之下
那將表示存在bug
我們看到沒有白色數據包位於綠色線條之下這說明一切正常
黃色線條表示接收窗口
當你打開TCP連接時接收端將指示它分配多少內存
來接收你的數據不應該超過這個分配給你的內存量限值
如果你看到白色數據包位於黃色線之上
表示存在bug我們沒有看到這種情況
這說明一切正常
數據傳輸看起來
顯示爲一條直線
這條曲線的斜率是10Mb/s
這正是我們所期望的但是每隔幾秒
我們看到這種情況
讓我們來放大仔細觀察
發生了什麼
這些TCPtrace圖形提供豐富的信息
我可以花上一個小時的時間來講解這些幻燈片
但是我們並沒有時間這樣做
我會講解這個圖形中的一些重要信息
首先白色數據包線看起來正在
偏離綠色應答線條
這意味着我們將數據發送到
網絡的速度快於數據從另一側被輸出
和被應答的數據
如果數據被輸入的速度
快於被輸出的速度
情況就會變得不一樣
數據將會進入緩存網絡緩存中的
舊數據將會增大
由於緩存數據量增大
意味着數據包發送與
接收端應答之間的往返延遲增大
當緩存數據量達到一定程度時
網關將無法緩存更多數據
將開始出現丟包現象
將會發生混亂而且是非常嚴重的混亂
因此數據包進入隊列末尾的速度
將會快於數據包出列的速度我們收到數據包但是會丟失它們
其他數據包也會被丟失
隊列被清空一點我們獲得一個數據包接受它
在隊列的末尾是一片混亂
它獲得一個數據包就會丟失一個數據包
但是在隊列前部
有200個數據包依次排列等待它們需要有序地
經過10Mb瓶頸鍊路
不能有間隔不能發生問題
只有在整個隊列的數據
發送完之後我們纔會看到
反映在發送端選擇性應答消息中的
接收端的數據包丟失情況
然後開始進行補包
因此這是嚴重的混亂現象
由於網絡傳輸API的工作方式
數據必須依次傳輸
如果一個數據包丟擋住
其後抵達的所有數據包在內核中將被延遲
直到間隙被填滿
這是有道理的
很多人曾經建議使用無序傳輸方法
但是結果發現幾乎所有APP都很難
使用無序數據
如果你要解碼H.264視頻
只獲得數據幀而無法獲得它們所依賴的I-Frame將不會有意義
因此順序數據傳輸確實是APP所需的傳輸模式
順序數據傳輸導致
我們看到這些長時間的空白期在此期間沒有數據傳輸
對於Apple TV視頻回放流程來說
這相當於一個無信號時間段
在此期間將接收不到數據
我們不想要視頻卡住
因此所有流媒體視頻都需要一個回放緩衝區
較大的回放緩衝區意味着
當你觀看流媒體視頻時
你會看到不斷旋轉的圖標提示正在緩衝
因爲緩衝區還有填滿
因此當長時間沒有數據到達時可能會始終顯示這個圖標
當丟失的數據包到達時我們開始填滿間隙
並且立即播放視頻
這將會給網絡接收線程帶來額外的負擔
它需要將CPU時間分配給視頻播放線程之外的其他線程
從而造成視頻播放卡頓
這不是我們想要的
這種不均衡的網絡數據傳輸給Apple TV等設備
造成不佳的用戶體驗在我們努力降低
設備的成本時
這種長時間的數據空白期
相當於我們需要增大設備內存來緩存更多數據
並且推遲視頻開始時間和降低用戶體驗
這種傳輸不均衡現象
還會導致設備需要更快的CPU
從而擡升設備價格
因此對於流媒體視頻來說這種不均衡的傳輸是十分有害的
一個有意思的事情是
如果你跟蹤觀察黃色應答線條的斜率...
黃色窗口線和和綠色應答線條
你會發現如果不發生丟包在軌跡末端
線條會回到它們原本應該所在的位置
因爲TCP協議能夠高效率地
一次性填充需要重新傳輸的數據包
而不會傳輸其他不需要重新傳輸的數據
因此它將會返回原本應該所處的位置
如果使用Iperf測量網絡速度
並且查看測量值
你將會看到它顯示爲10Mb/s
你會說很好我的網絡一切正常
但是如果你探究這些信息
分析具體的數據
你就會發現實際的網絡情況
現在我們知道是什麼原因
造成網絡性能下降
我決定使用智能網絡進行實驗
對於這個實驗我使用一種名爲CoDel的智能隊列算法
它是ControlledDelay的簡稱
其工作原理不是填充隊列
直到隊列溢出並丟失數據相反它監測隊列的狀態
當隊列快要變滿時
將會把它視爲一個擁塞信號
對於擁塞很多人認爲
我說的是高峯時間出現的情況
實際上不是這樣的
必須理解的是在網絡數據傳輸中
擁塞始終存在
它是一種穩定的網絡狀態
TCP等傳輸協議的任務是
最大限度地利用網絡
以確定網絡的最大承載能力
並且最高效地利用網絡
傳輸協議的工作原理是
它越來越快地傳輸數據
同時始終進行偵測它嘗試不斷髮送更多的數據
直到發生丟包這時它將知道負載過大並開始削減流量
它始終進行這種嘗試以找到合適的傳輸速率
這意味着它始終在嘗試
使網絡進入擁塞狀態
然後降低傳輸負載從而減少擁塞
CoDel的工作原理並不是等待網絡進入擁塞狀態
然後發出擁塞信息
在發現第一個擁塞信號之後它就會通知發送端
在這個實驗中我做的另一事情
不是通過丟包來指示擁塞
這需要重新傳輸
相反我使用一種名爲“顯式擁塞通知”即Explicit Congestion 
Notification的新技術智能隊列算法不會丟棄數據包
它設置IP標頭中的一個位聲明遇到擁塞
這個消息被傳回給發送端發送端作出響應
降低傳輸速度而不會造成破壞性的丟包後果
這是使用CoDel和ECN的
數據傳輸示意圖如果我放大
前面看過的相同部分你可以看到非常明顯的差別
在我進行這些實驗時
我計劃用一週的時間來完成這些工作和收集數據
結果只用了兩個小時就全部完成了
一個方案使用標準配置來執行一個方案使用CoDel來執行
這是我的第一個實驗
我預計需要調整參數重試並返回實驗
但是沒有發生這種情況 差別很明顯
只需進行一次試驗就夠了
好像有人在鼓掌 謝謝
我們沒有看到傳輸中斷現象
也沒有出現高峯擁塞
每次出現輕微的隊列擁塞時
CoDel算法就會發出信號
要求降低傳輸速度
這個方案的CWR標記的含義是“減少擁塞窗口期”
這是TCP的應答消息意思是消息已經被接收和理解
我已經降低傳輸速率
這確實很不錯
總的來說CoDel
和其他隊列算法非常有效
ECN十分有效
將它們組合在一起將會功效倍增
那麼如果這麼有效應該在哪裏使用它們？
從歷史來看對於傳統的網絡應用來說
例如文件傳輸和發送電子郵件等
丟包和重新傳輸並不會造成嚴重的問題
當你傳輸文件時原則上傳輸層將會
最後發送第一個數據包
而且最先發送最後一個數據包其間的所有數據包
將會隨機發送 在數據包全部到達之後
將會按照文件的正確順序重新進行組裝這就是你需要關注的所有事情
但是當你觀看流媒體視頻時
你並不想先看到結尾最後看到開頭
你希望按順序觀看
這時按順序發送數據就成爲一個更緊迫的問題
現在我們通過Internet傳輸流媒體視頻
這裏的一個特點是在以前的應用中
例如點擊發送電子郵件等
需要發送的數據量是預先確定的
而發送所需要的時間是可變的
基本上網絡發送電子郵件
所需要的時間是越少越好
我們並沒有郵件發送過快這樣的說法
發送時間是可變的你希望它越快越好
現在的應用則有不同
比如你通過Internet
觀看兩個小時的電影
我們不應該半個小時或八個小時內看完成
而必須是兩個小時
現在我們的應用必須具有適應能力
時間是固定的但是必須調整
這段時間內發送的數據量
以適應網絡狀況
現在的情況是怎樣的？
讓人驚奇的是Linux已經支持此功能
而且在世界性能最強的一百萬臺Web服務器中
一半以上默認支持ECN
對於一項無人使用的技術來說
這種應用廣泛性是驚人的
客戶端並不請求ECN連接
它們不請求ECN在很大程度上
是因爲Internet不支持ECN標記
如果你啓用這個選項
可能會帶來暴露bug的風險而且沒有直接好處
那麼路由器在做什麼？ 
沒有路由器進行標記
因爲沒有客戶端請求它們那麼爲什麼要設計
這樣具有風險而且無人使用的功能呢？
今天我高興地宣佈Apple將首開先河
打破這個僵局
在所有的基本應用中默認情況下
所有應用的所有TCP連接將支持ECN
我們將不會看到任何問題
在我們的測試中一切運行正常
我已經在我自己的筆記本電腦上運行很長時間
當然我們希望傾聽你們的體會
請接受這些基本應用在你的家庭網絡
工作單位酒店和機場使用它們
和以前一樣如果發現任何bug請報告給Apple
如果我們取得成功幾個月之後
將會有數百萬設備運行ECN
這樣ISP將有足夠的動力來提供這項服務
現在我們將主題從網絡延遲
轉移到終端系統延遲
許多技術進步的出發點是爲了
克服我們自己遇到的不便之處這裏也同樣如此
我使用屏幕共享功能連接到我家裏的Mac計算機
這種功能真不錯
我能夠遠程控制計算機能夠訪問計算機上的數據
能夠開始費時的視頻轉碼
在我到家時就已經完成轉碼
這些確實不錯
在我進行這些實驗時
我使用的是很慢的DSL線路
當然DSL是非對稱的
一般來說下行速度比上行速度快十倍
當你進行屏幕共享時
數據傳輸方向是上行方向
因此速度會比較慢
這有一點像那個衆人皆知的關於熊跳舞的笑話
當你看到熊跳舞時
你不應該驚訝於熊跳舞跳得很好
而應該驚訝於熊會跳舞
多年人與很多人一樣我被這個讓人難受的
勉強可用的功能所困擾我發現當我點擊一個菜單時
要花費三到四秒的時間
菜單纔會顯示出來這樣使用計算機幾分鐘之後
讓人感到非常不舒服
有時候恨不得快點開車回家
親自在計算機上操作
我曾經研究過“bufferbloat”
和網絡中的過度隊列
很自然地我首先感到不滿
並且開始研究
我最初認爲罪魁禍首
應該是這個愚蠢的DSL調制解調器
產生過度的緩存膨脹
於是我ping計算機
ping時間爲35ms
當我點擊鼠標時卻需要3秒才能顯示鼠標
我意識到情況可能與我當初設想的不一樣
那麼延遲來自於哪裏呢？
對此我進行了一些研究
當時默認socket發送的緩存數據是120KB
我的網速率大約是50KB/s
用時約爲2.5秒
這與我看到的延遲時間差不多
發送緩衝數據的socket 具有十分重要的意義
當我們使用TCP等協議時
它會發送一個數據包等待應答
然後再發送一個數據包再等待應答
這樣的性能十分低下
我們需要一次發送多個數據包我們需要足夠多的數據包
以充分利目的地往返傳輸路徑的帶寬
而且必須緩存這些數據包
這樣當它們丟失時可以重新進行傳輸。
最大限度利用連接吐吞率
是一個很好有用而且必要的方法
但於超過需求的緩存
僅僅會增加延遲而不會帶來好處
它不會幫助提高吞吐率
而只會增大延遲
最終我們只會得到這樣的結果
我們一次僅傳輸少量的數據而且這些數據進入緩存
以備在需要時重新傳輸
而另一方面有大量的數據在內核中等待被髮送出去
這讓我明白
不僅網絡上存在延遲而且主機之中存大量延遲
屏幕共享程序會抓取一個畫面幀將它送入緩存
再抓取一個畫面幀將它送入緩存內核將會讓這些幀
像葡萄酒那樣長時間陳釀然後纔會在特定時間將它們通過網絡發送出去
爲此我們引入了TCP_NOTSENT-LOWAT
套接字選項
發送這個選項時
Socket_Send_Buffer保持不變
區別在於kevent
或你的run loop不會報告Socket正在被寫入
直到未發送的數據量
達到很低的閥值
通常爲8或16KB
當socket轉爲可寫入狀態時
你可以將單個有用的基本數據塊寫入緩存
不需要循環操作中內核中也不會積累過多的數據
因爲現在內存已經很便宜它可以容納大量的數據
你只需寫入一個感應單元
在屏幕共享程序中它是一個幀
現在的情況是這樣的
有數據在等待發送它們位於緩存中
需要等待較短的時間讓它們發送出去
在發送完畢之後中達到閥值
Socket轉爲可寫入狀態
我們寫入一個數據塊
在它發送完畢之後再寫入更多數據塊
現在我爲你們演示這個過程
在這裏我將要在這臺計算機上
使用屏幕共享程序連接到這臺計算機
我將使用一個運行sarawert[猜測寫法]的網關
來模擬DSL連接
讓我們調出終端窗口
看到了
我將移動這個窗口
你可以看到鼠標指針在移動
因爲它是本地生成的
實際的圖形更新是由遠程計算機生成的
讓我們窗口移動這裏
不 不是這裏
讓我們移動它 不我想讓它回到原來的地方
雙手離開鍵盤
讓我們調出菜單：Shell
它出現了讓我們打開“Edit”
或者“View”
這個演示讓人感覺很着急
看起來遠程使用我的計算機是非常費勁的事情
這需要很好的耐心
現在我一個新的方法
我啓用TCP_NOTSENT-LOWAT選項
然後重新進行連接我可以隨意拖動這個窗口
謝謝
多年來 在BSD網絡應用中
我們一直忍受着這種極其糟糕的屏幕共享連接
好消息是我們已經解決這個問題
現在此技術已經在
10.10.3最新版本中得到應用
如果發現屏幕共享得到越來越多的運用
背後的原因就在這裏
此技術已經被AirPlay使用而且也可以在Linux中使用
因爲此選項應用於發送端數據源
因此如果你運行Linux服務器
此選項也可以用於你的服務器
對於實時應用來說這種降低延遲的好處很明顯的
在製作本講座的幻燈片時
我將APP分爲兩類
一類APP應該使用tcp_notsent-lowat選項
另一類APP不應該使用
但是我想不出任何APP應歸入不應該使用此選項的類別
每次我們想到哪些傳統應用可能不需要使用此選項例如文件傳輸
我們發現你們曾經有這樣的經歷
你想要取消文件傳輸
你按下Control-C但是需要大約30秒的時間才能取消
這是因爲程序將所有數據
過量載入內核而必須等待數據被清空
因爲並沒有方法來改變此操作
事實上文件傳輸
並不會受益於過量載入數據
我們想不出會任何APP
會受益內核中的過量數據堆積
在認識到這種情況之後
我們決定在下一個版本中
使用更高層次的SURLSession和CFNetwork API
自動爲所有連接啓用此選項
爲了最有效地利它需要做的事情是
當socket變爲可寫入狀態時在看到EWOULDBLOCK錯誤碼之前
不要循環寫入大量的數據
只需要寫入合適大小的數據塊
然後等待被告知可以寫入更多數據塊
這樣如果用戶改變主意
或者網絡環境發生變化
下次socket變爲可寫入狀態時
你可以做出明智的決定
你可以即進生成數據
根據當前的信息而不是5或10秒前的信息
生成最新的數據
現在進入本講座的最後一部分
讓我們來窺探
一項名爲TCP Fast Open的全新技術
傳統TCP工作原理是這樣的我們通過發送消息和獲得應答
設置TCP連接
然後我們第二次發送消息和獲得應答
以發送請求和獲得響應
TCP Fast Open將連接設置
與數據交換合併成爲一個數據包交換
所有APP並不會默認啓用此選項
而這是有原因的
你需要注意這個警告信息
提示說此功能僅對冪等數據來說是安全的
我將解釋這其中的含義
當你使用TFO操作時握手與數據組合在一起
服務器將收到消息服務器作出反應發送響應信息
然後你關閉連接
Internet的工作模式並不保證
不會重複發送數據包
Internet的成功得益於
其非常簡單的工作模式
即快速低成本地發送數據包
你不需要考慮數據包的發送順序
不需要擔心數據包是否損壞或丟失
或者重複發送數據包只需實現快速和低成本就可以了
終端系統非常智能化能夠適應這種網絡模型
重複發送數據包的原因是多少方面的
可能是因爲路由器有bug
也可能是因爲Wi-Fi鏈路層
意外地發送數據包兩次
終端系統可能重複發送：
如果你發送數據包
但是應答消息丟失
你將需要重新發送數據包
這樣網絡中就會出現兩個相同的數據包
如果其中一個數據包發生延遲並且在很久以後出現
對於服務器來說
這是一個完全有效的TFO請求
無論操作是什麼都會再次執行此操作
如果操作是向你發送一幅JPEG圖片
進行兩次這樣的操作並不會帶來嚴重的後果
但是如果操作是發送一雙Zappos鞋子
兩次進行這樣的操作可不是你想的
對於這種情況你必須做出明智的決定
哪些操作是合適和安全的
哪些對你的APP來說不合適
你可以通過connectx系統調用來這樣做
這是早期適配器的簡要技術預覽
讓我們來看如何通過更高層API來展示這個技術
但是目前還不能使用connectx來實現
與你進行對話的服務器必須支持TFO
APP必須選擇加入對話
如果你運行Linux服務器你必須具有幾個星期以前
發佈的最新Linux內核
此內核支持標準ITF、TFO、
TCP選項代碼OS X操作系統也同樣如此
最後作爲總結我希望你們記住今天講座的要點
即 你應該儘可能地
使用最高層次的網絡API
這樣你將能夠獲得這些API所能提供的全部功能
你絕對必須在NAT64網絡上測試你的APP
幸運的是我們進行了大量的簡化工作
你只需要點擊“選項”就可以了
可靠的網絡回退機制能夠讓你的APP提供更好的用戶體驗
你需要做的是注意“Better Route”通知
這樣當Wi-Fi重新可用時你可以返回到Wi-Fi連接
“顯式擁塞通知”是一項新的基本功能
它通過降低隊列等待和減少丟包
大幅提高網絡數據傳輸的響應速度
我希望你們測試這些功能並且報告任何問題
利用CPNOTSENT-LOWAT選項
你可以爲自己設置一個socket選項
在下一個版本中你將可以免費使用它
從而大幅減少發送機中緩存的遲滯數據量
最後對於喜歡TCP Fast Open的開發者
我們已經提供此功能
有很多不錯的文檔資源可供你查看
你們並不需要記下這些URL
可以點擊PDF文檔中的鏈接
還有一些不錯的論壇你可以提問並且討論
與網絡應用相關的問題
我鼓勵你們觀看
NSURLSession講座
和Network Extensions講座
在網絡實驗室午餐休息之後也可以與我們討論
我們將會回答你的所有問題
謝謝