00:00:22.956 --> 00:00:24.658 
iOS和watchOS的性能

00:00:31.632 --> 00:00:32.466 
早上好

00:00:33.967 --> 00:00:37.004 
我是 本
我是一名iOS性能工程师

00:00:37.538 --> 00:00:41.208 
今天我们要谈一谈
iOS和watchOS的性能

00:00:42.876 --> 00:00:44.311 
那么我们首先 要告诉你

00:00:44.645 --> 00:00:46.413 
你为什么要思考
与性能相关的问题

00:00:46.647 --> 00:00:49.216 
如果你之前从未思考过
你的app的性能如何

00:00:49.283 --> 00:00:50.417 
那么为什么现在要开始

00:00:51.919 --> 00:00:54.388 
希望我能说服你
留在你的座位上继续往下听

00:00:55.255 --> 00:00:58.125 
然后我们可以继续聊一聊
你应该如何思考性能问题

00:00:58.525 --> 00:01:01.862 
这个话题貌似非常宽泛
有时甚至令人生畏

00:01:02.362 --> 00:01:04.665 
但是我们要把它细分成
几个类别

00:01:05.065 --> 00:01:07.167 
并给你提供一些具体的策略

00:01:07.234 --> 00:01:10.037 
来提高你的app
在这些方面的性能

00:01:11.038 --> 00:01:13.440 
最终 很有可能
你会兴奋地发现自己

00:01:13.507 --> 00:01:15.676 
可以给watchOS编写本地代码

00:01:15.909 --> 00:01:17.644 
我们则要深入研究
在这个平台上

00:01:17.711 --> 00:01:20.948 
你还可以为给用户最佳体验
做出什么贡献

00:01:22.015 --> 00:01:24.618 
那么你为什么要
考虑性能问题呢

00:01:25.252 --> 00:01:29.156 
最简单的回答是
性能是一个特性

00:01:29.957 --> 00:01:34.828 
要想让你的app用户有良好的体验
性能是核心是中心要素

00:01:35.195 --> 00:01:38.131 
它不是额外的津贴或奖金
或如果你有时间可以

00:01:38.198 --> 00:01:39.733 
在任务结束时你可以得到的东西

00:01:40.467 --> 00:01:44.805 
事实上 你在编写app时
应该时刻关注它的性能

00:01:45.339 --> 00:01:46.473 
这样要求 有几个原因

00:01:48.041 --> 00:01:49.843 
如果你的app反应迅速

00:01:49.910 --> 00:01:52.746 
如果它总是立即
反应用户的输入

00:01:53.547 --> 00:01:55.983 
就会构建起用户的信任

00:01:56.850 --> 00:02:01.355 
那样就让用户知道
如果他们需要通过你的app

00:02:01.522 --> 00:02:03.223 
访问信息或进行交互操作

00:02:03.624 --> 00:02:05.058 
他们无需久等

00:02:05.526 --> 00:02:08.061 
这会让他们很高兴
成为回头客

00:02:10.030 --> 00:02:11.932 
如果你要在使用iOS 9
的iPad里

00:02:11.999 --> 00:02:14.101 
采用多任务应用程序
Multitasking

00:02:14.201 --> 00:02:17.304 
它不仅不能
满屏幕运行

00:02:18.138 --> 00:02:19.473 
实际上它也不能
充分利用

00:02:19.540 --> 00:02:21.241 
系统的资源

00:02:22.109 --> 00:02:25.646 
所以app的性能问题
再也不只是给你的app用户

00:02:25.712 --> 00:02:27.314 
带来糟糕的使用体验

00:02:27.648 --> 00:02:29.316 
它还可会损害
另一个app的

00:02:29.416 --> 00:02:30.651 
用户体验

00:02:31.585 --> 00:02:34.354 
你肯定想成为
Multitasking里的好邻居

00:02:36.924 --> 00:02:39.860 
所有App的体系结构都着眼于
高效利用系统资源

00:02:40.160 --> 00:02:42.863 
比如CPU和内存
你利用它们时

00:02:42.930 --> 00:02:45.732 
不只是感觉很好
其实也是在节省电池

00:02:45.799 --> 00:02:47.234 
让用户可以
坚持一天

00:02:47.568 --> 00:02:48.735 
对此他们真的很感激

00:02:50.170 --> 00:02:53.841 
最后 iOS 9支持
范围庞大的硬件

00:02:54.341 --> 00:02:56.944 
而要持续地
为所有的客户

00:02:57.010 --> 00:03:00.314 
提供优秀的app和特色功能
性能是一个先决条件

00:03:03.984 --> 00:03:05.886 
那么 我就有希望说服
各位 你们不必走出去了

00:03:07.554 --> 00:03:09.156 
你们应该如何思考
有关性能的问题呢

00:03:09.489 --> 00:03:11.225 
开发app的第一步

00:03:11.558 --> 00:03:14.161 
是选择技术

00:03:15.062 --> 00:03:17.865 
这一步至关重要 因为
你需要选择

00:03:17.998 --> 00:03:18.999 
哪种技术会

00:03:19.066 --> 00:03:21.034 
让你的用户有
最好的体验

00:03:22.569 --> 00:03:25.372 
一旦你开始
构建应用程序

00:03:26.106 --> 00:03:27.708 
你就可以开始
采取测量手段

00:03:27.774 --> 00:03:30.611 
并真正理解
在你的app里用户

00:03:30.844 --> 00:03:32.412 
在重要的交互中的
体验情况

00:03:34.081 --> 00:03:37.284 
你的测量手段会告诉
你今天你的app的下载情况

00:03:37.918 --> 00:03:40.454 
一旦你得到了那些数据
你就可以设定一些目标

00:03:40.687 --> 00:03:42.389 
比如在把它提交给
应用商店之前 你想让

00:03:42.456 --> 00:03:43.957 
你的app处于何种状态

00:03:45.058 --> 00:03:47.694 
最后 一旦你
得到那些数据 你就已经准备好

00:03:47.761 --> 00:03:50.430 
开始修改代码
来提高app的性能

00:03:50.497 --> 00:03:53.066 
你可以遵循
一个很好的工作流程

00:03:53.300 --> 00:03:54.468 
来全力实现你的目标

00:03:55.702 --> 00:03:57.971 
那么让我们从
选择技术开始

00:03:59.006 --> 00:04:02.009 
选择正确的工具
来完成这项工作是

00:04:02.075 --> 00:04:03.177 
构建app的一项重要

00:04:03.443 --> 00:04:06.446 
的早期工作 是保证app
性能卓越的一个前瞻性的步骤

00:04:07.214 --> 00:04:09.917 
而选择技术
的第一步是

00:04:09.983 --> 00:04:11.118 
了解的这些技术

00:04:11.652 --> 00:04:13.287 
所以在这个演讲中

00:04:13.787 --> 00:04:17.057 
我将引用今年
和前几年的几场其他演讲

00:04:17.824 --> 00:04:19.059 
这几场
演讲都涉及了

00:04:19.293 --> 00:04:20.761 
我们认为
有助于提高

00:04:20.861 --> 00:04:22.429 
app性能的技术

00:04:24.198 --> 00:04:27.134 
一旦你知道有多少
技术可以为你所用

00:04:28.202 --> 00:04:30.037 
那么你就可以
根据你的app的

00:04:30.103 --> 00:04:32.239 
设计构想和
工作内容

00:04:33.440 --> 00:04:35.042 
来挑选最合适的技术

00:04:36.043 --> 00:04:38.712 
举一个很好的例子
如果你的app需要

00:04:38.779 --> 00:04:40.080 
存储三个字符串

00:04:40.948 --> 00:04:43.417 
你可能可以把这些字符串
写进一个plist文件或

00:04:43.483 --> 00:04:44.852 
放在用户默认中

00:04:45.485 --> 00:04:48.822 
但是 如果您的app
需要使用3000个字符串

00:04:49.556 --> 00:04:50.757 
你可能就要
考虑核心数据了

00:04:52.459 --> 00:04:53.627 
说到核心数据

00:04:54.494 --> 00:04:55.762 
当你
选择技术时

00:04:56.296 --> 00:04:57.264 
我强烈建议你

00:04:57.331 --> 00:04:59.433 
考虑Apple
APIs和框架

00:05:00.334 --> 00:05:02.569 
我们在Apple
APIs和框架上花了大量时间

00:05:02.636 --> 00:05:04.104 
力图
让它们满足你和你的用户的

00:05:04.404 --> 00:05:06.306 
需求 我们也在其基础上
创建我们自己的产品

00:05:07.641 --> 00:05:11.278 
采用Apple APIs和框架
的一个好处是

00:05:11.345 --> 00:05:13.747 
用户在安装了
你的app之后

00:05:14.681 --> 00:05:16.383 
他们可能会安装
一个iOS更新

00:05:16.884 --> 00:05:19.887 
这些更新经常包含
对核心APIs和技术的

00:05:19.953 --> 00:05:21.522 
性能改进

00:05:21.989 --> 00:05:23.757 
所以下次
他们在安装了

00:05:23.824 --> 00:05:27.027 
一个iOS更新之后 打开你的app
就会发现app神奇地变快了

00:05:28.195 --> 00:05:29.963 
那么你选择了
某些技术

00:05:30.564 --> 00:05:31.698 
并且开始
构建应用程序了

00:05:32.799 --> 00:05:33.967 
现在我们要谈论测量问题

00:05:34.668 --> 00:05:36.403 
有几个类别
的性能

00:05:36.470 --> 00:05:37.638 
我们可以
考虑测量

00:05:38.939 --> 00:05:40.240 
让我们从动画开始

00:05:40.841 --> 00:05:43.677 
动画让你的app
活泼 流畅

00:05:43.744 --> 00:05:46.713 
还能够让用户知道他们
在哪里 发生了什么

00:05:47.581 --> 00:05:49.349 
测量动画性能的
最简单的方法

00:05:49.416 --> 00:05:52.186 
是Core Animation工具

00:05:55.689 --> 00:05:59.326 
反应速度测量的是
你对用户的输入做出反应的迅速程度

00:05:59.860 --> 00:06:01.628 
实际上 测量反应速度

00:06:01.695 --> 00:06:05.165 
最简单的方法
看起来技术含量有点低

00:06:05.599 --> 00:06:06.533 
但是它真的很强大

00:06:07.000 --> 00:06:09.269 
并且只是插装
你的实际代码

00:06:09.937 --> 00:06:11.171 
我将给它
举一个例子

00:06:12.673 --> 00:06:15.742 
更复杂的场景
可能涉及多个线程

00:06:15.809 --> 00:06:17.411 
或大量的系统交互

00:06:17.744 --> 00:06:19.780 
对于这样的场景有一个
伟大的工具叫做系统跟踪

00:06:21.181 --> 00:06:22.583 
最后要说的是内存

00:06:23.417 --> 00:06:26.320 
内存是移动设备上
最宝贵的资源

00:06:26.987 --> 00:06:28.121 
确保你的app的内存

00:06:28.188 --> 00:06:30.757 
正好能够满足需要
不多不少

00:06:30.824 --> 00:06:32.292 
这一点很重要

00:06:33.460 --> 00:06:35.796 
和前面相似的是
有一个简单但强大的方法

00:06:35.863 --> 00:06:37.664 
来了解app
内存的使用情况

00:06:37.731 --> 00:06:40.200 
我马上就要谈到了
那就是Xcode调试器

00:06:41.368 --> 00:06:42.636 
如果你要
了解更多情况

00:06:43.103 --> 00:06:44.872 
还有一个很好的工具
叫做存储器分配

00:06:45.639 --> 00:06:48.075 
如果你认为
有漏洞 也有一个工具

00:06:48.141 --> 00:06:49.376 
来帮助你追踪
这些漏洞

00:06:51.345 --> 00:06:52.179 
那么

00:06:53.413 --> 00:06:55.549 
让我们举一个
代码插装的例子

00:06:55.616 --> 00:06:58.785 
我这里有一个IBAction
连接到一个按钮

00:06:58.852 --> 00:07:00.287 
所以当用户按下按钮时

00:07:00.687 --> 00:07:02.756 
我就要加载一个图像
并把它放在我的视图

00:07:03.524 --> 00:07:04.992 
而且我想知道
这需要多长时间

00:07:05.926 --> 00:07:07.160 
所以我要用一个AP

00:07:07.895 --> 00:07:09.796 
叫做"CF绝对时间当前值"

00:07:10.731 --> 00:07:12.833 
现在 我并不关心
当前时间的

00:07:12.900 --> 00:07:14.635 
绝对值
但我在意的是

00:07:14.701 --> 00:07:16.403 
它们之间
的差别

00:07:18.038 --> 00:07:21.141 
这个API 尽管它是
SWIFT 是类型推断

00:07:21.208 --> 00:07:24.011 
非常好 但是我将
告诉你它会返回一个双精度浮点

00:07:24.444 --> 00:07:27.848 
具体地说 这个双精度浮点数
以秒为单位代表当前时间

00:07:28.682 --> 00:07:30.918 
一秒钟实际上
是一段很长的时间

00:07:31.185 --> 00:07:33.120 
如果你的app用了
一秒钟 你的用户

00:07:33.187 --> 00:07:34.388 
真的会感觉到

00:07:35.289 --> 00:07:37.191 
其实我们发现毫秒

00:07:37.391 --> 00:07:39.326 
是一个更可行的
度量单位

00:07:40.027 --> 00:07:42.262 
所以我们要从结束时间
减去开始时间

00:07:42.329 --> 00:07:44.164 
并把结果
乘以一千

00:07:44.464 --> 00:07:46.333 
以得到以毫秒为单位的
测量结

00:07:49.236 --> 00:07:52.439 
概要描述
app的发行组态

00:07:52.506 --> 00:07:55.943 
很重要 这样你将得到
你的用户所得到的

00:07:56.543 --> 00:07:57.644 
所有的编译器优化

00:07:57.711 --> 00:08:00.247 
你也将了解你的app
在它的领域内的

00:08:00.881 --> 00:08:03.417 
实际表现；然
同样重要的是不要

00:08:03.483 --> 00:08:06.320 
把你的性能插装提交
给应用商店

00:08:06.987 --> 00:08:09.356 
所以我的建议是
你在Xcode中

00:08:09.423 --> 00:08:11.291 
复制一份你的研发流程

00:08:11.491 --> 00:08:13.961 
同时定义一个额外的定义

00:08:14.228 --> 00:08:17.497 
这样您就可以
用性能插装

00:08:17.831 --> 00:08:20.701 
轻松 快捷地
构建一个app的发布版本

00:08:21.902 --> 00:08:25.305 
那么什么类型的反应
我们有兴趣测量呢

00:08:25.772 --> 00:08:28.075 
当然是按键和
按钮

00:08:29.409 --> 00:08:32.645 
大多数情况下 你可以
在IBActions中做这些

00:08:33.347 --> 00:08:37.150 
你也可以用UIView
触摸处理代码做这些事

00:08:37.951 --> 00:08:39.986 
或者你可能以
手势识别器为目标

00:08:41.755 --> 00:08:44.191 
App性能的
另一个有趣的方面

00:08:44.258 --> 00:08:46.927 
就是用户在
使用这个应用程序

00:08:46.994 --> 00:08:49.062 
并切换到不同的
视图时感受如何

00:08:49.530 --> 00:08:51.465 
无论他们是使用
标签栏还是模态视图

00:08:53.133 --> 00:08:55.202 
在这种情况下
我们觉得思考

00:08:55.269 --> 00:08:57.204 
"视图将显示"和"视图出现"
之间的时间

00:08:57.271 --> 00:08:59.773 
是件有趣的事
因为那让你可以比较

00:09:00.107 --> 00:09:03.110 
你的哪一个观点要花更长的时间
来准备 以出现在屏幕上

00:09:06.013 --> 00:09:07.548 
那么你已经取得了
一些测量结果

00:09:07.648 --> 00:09:09.383 
了解了
你的app的表现

00:09:10.384 --> 00:09:12.986 
在你将app提交到应用商店之前
你希望它取得怎样的成绩

00:09:13.053 --> 00:09:14.388 
要如何
设定这个目标呢

00:09:15.589 --> 00:09:18.892 
在以60帧每秒的速度
运行时 动画

00:09:19.193 --> 00:09:20.961 
感觉很棒 逼真
流畅又有生气

00:09:22.162 --> 00:09:23.997 
今年我不打算
过多谈论动画

00:09:24.431 --> 00:09:26.667 
因为去年有一个很好的关于动画的
演讲 你可以查看

00:09:27.067 --> 00:09:29.369 
名字是"iOS Apps中的
高级图形和动画"

00:09:30.337 --> 00:09:32.973 
那场演讲谈到了
核心动画工具

00:09:33.040 --> 00:09:34.842 
以及如何
使用它

00:09:34.908 --> 00:09:36.743 
来衡量并利用
所有硬件

00:09:36.810 --> 00:09:38.212 
改善动画性能

00:09:39.513 --> 00:09:42.482 
今天我们要把大量的
时间花在反应速度上

00:09:43.350 --> 00:09:45.319 
反应速度 再说一次

00:09:45.552 --> 00:09:47.521 
反应的是你如何对用户输入进行反应

00:09:47.988 --> 00:09:49.223 
我们发现

00:09:49.556 --> 00:09:51.859 
如果它需要超过一百毫秒

00:09:51.925 --> 00:09:53.227 
用户就能够感觉到

00:09:53.560 --> 00:09:57.831 
所以 你对任何响应性的目标
应是一百毫秒

00:09:58.732 --> 00:10:00.601 
顺便提一下 你想考虑

00:10:01.034 --> 00:10:05.038 
在你要支持的最老的硬件上
实现这些性能目标

00:10:06.373 --> 00:10:08.175 
如果你针对iOS 9

00:10:08.375 --> 00:10:10.744 
那么可能是最早的iPad mini

00:10:11.078 --> 00:10:13.547 
iPhone 4s 甚至 iPad 2

00:10:14.548 --> 00:10:15.749 
如果你已经有了这其中之一

00:10:15.816 --> 00:10:18.118 
或者更确切地说
你仍然还在用这着其中之一

00:10:18.185 --> 00:10:21.655 
那么继续用它
接下来对它进行检测

00:10:22.523 --> 00:10:23.423 
如果不是这样

00:10:23.490 --> 00:10:27.127 
那么在Apple Online Store上
有很棒的翻新部件

00:10:31.698 --> 00:10:33.200 
所以你已经设定了目标

00:10:33.400 --> 00:10:34.468 
你已经做了检测

00:10:34.968 --> 00:10:37.871 
现在你想继续通过
在你的app上更改代码

00:10:38.172 --> 00:10:39.439 
来提高性能

00:10:40.574 --> 00:10:41.441 
我们如何开始呢？

00:10:42.576 --> 00:10:44.311 
首先 不用猜

00:10:45.078 --> 00:10:47.347 
你一定想用工具做简要分析

00:10:47.581 --> 00:10:50.951 
解决造成你的app性能问题的根源

00:10:51.752 --> 00:10:55.222 
你的直觉总是对的
这想法很诱人

00:10:55.489 --> 00:10:57.457 
但是这可能如同抛硬币一样不准确

00:10:58.859 --> 00:11:02.029 
据此 不要过早优化

00:11:02.563 --> 00:11:05.699 
除非你有证据表明
尽可能简单的做法

00:11:05.766 --> 00:11:09.937 
不足以达到卓越的性能
否则不用把你的代码复杂化

00:11:10.437 --> 00:11:16.009 
经常是人们引入一些机构
试图避开性能问题

00:11:16.476 --> 00:11:18.345 
结果却是造成他们自身的性能问题

00:11:20.881 --> 00:11:22.382 
一次只做一处更改

00:11:22.749 --> 00:11:26.854 
你肯定想开始培养你的直觉

00:11:27.054 --> 00:11:29.923 
以便知道
如何能够改进你的app的性能

00:11:30.457 --> 00:11:36.296 
但是很难知道你做的哪件事
确实改进了你的app性能

00:11:36.864 --> 00:11:38.599 
所以一次只改一处

00:11:39.366 --> 00:11:42.703 
我这里实际想说的是没有奇迹

00:11:42.970 --> 00:11:44.671 
这只是普通的调试而已

00:11:45.038 --> 00:11:49.176 
所以同样要本着严谨而科学的态度
去排除

00:11:49.243 --> 00:11:51.311 
app中存在的死机或功能问题

00:11:54.815 --> 00:11:57.084 
这是我希望你打印出来的图片

00:11:57.150 --> 00:12:00.020 
挂在你墙上的的图片
设成你Mac的壁纸

00:12:01.121 --> 00:12:03.557 
这就是我们如何通过更改代码

00:12:03.757 --> 00:12:05.058 
来改进app性能的

00:12:05.826 --> 00:12:08.428 
首先你要做的是在脑海中重现这个问题

00:12:09.630 --> 00:12:14.434 
之后用工具进行分析 了解

00:12:14.501 --> 00:12:15.903 
你的代码是哪里

00:12:15.969 --> 00:12:16.870 
造成了性能问题

00:12:17.604 --> 00:12:19.273 
在一个足够大的代码库在

00:12:19.806 --> 00:12:22.276 
你的直觉可能的确不对

00:12:22.376 --> 00:12:23.877 
所以还是收集证据为好

00:12:24.912 --> 00:12:28.182 
之后 一旦你找到

00:12:28.482 --> 00:12:31.585 
造成你app中性能不理想的代码

00:12:32.286 --> 00:12:34.154 
你就能确切算出你需要为此

00:12:34.221 --> 00:12:35.055 
花费多长时间

00:12:35.489 --> 00:12:38.692 
最后
你只要有针对性对对代码做一次更改

00:12:38.926 --> 00:12:40.527 
以尝试达到你的目的

00:12:42.796 --> 00:12:46.233 
常常是一处更改

00:12:46.300 --> 00:12:48.702 
无法让你一次达到目的 事实上

00:12:49.069 --> 00:12:51.038 
多次更改

00:12:51.371 --> 00:12:53.006 
才能最终达到你的目的

00:12:53.707 --> 00:12:55.909 
这就是为什么说这是一个周期
因为你可能会发现

00:12:56.143 --> 00:12:59.146 
你更改代码并再次重现后 有所改善

00:12:59.213 --> 00:13:00.447 
但没有达到你最终的目的

00:13:01.248 --> 00:13:04.384 
所以你要继续这个周期
直到你满意

00:13:09.623 --> 00:13:13.460 
幻灯片上是分析和检测情况
似乎都类似

00:13:13.527 --> 00:13:15.362 
但是实际上

00:13:15.429 --> 00:13:16.797 
这是改进你的app性能的

00:13:17.030 --> 00:13:18.465 
两个分立的步骤

00:13:19.032 --> 00:13:22.636 
再次分析时
采用工具如Xcode调试器

00:13:22.836 --> 00:13:25.539 
以及Instruments:
Time Profiler

00:13:25.639 --> 00:13:28.275 
就与你性能方面具体问题相关的代码

00:13:28.342 --> 00:13:29.443 
得到一个全面的概览

00:13:30.344 --> 00:13:34.014 
检测针对你代码某具体区域

00:13:34.314 --> 00:13:36.850 
以准确了解用户的

00:13:36.917 --> 00:13:37.751 
等待时间

00:13:38.118 --> 00:13:38.952 
我给出的

00:13:39.019 --> 00:13:41.922 
"CF absolute time
get current"的例子

00:13:42.256 --> 00:13:44.124 
再次证明确实很好用

00:13:45.092 --> 00:13:47.394 
对于更复杂的情形 有System
Trace

00:13:50.597 --> 00:13:52.099 
所以让我们来谈谈响应响应性

00:13:57.404 --> 00:14:00.207 
响应即是对用户输入的反应

00:14:00.841 --> 00:14:03.210 
谈到响应性 我们不得不提到

00:14:03.277 --> 00:14:04.912 
你app的主线程

00:14:05.412 --> 00:14:06.680 
因为你app的主线程

00:14:06.747 --> 00:14:08.515 
是你消耗所有用户输入的所在

00:14:09.016 --> 00:14:10.851 
--来自触摸屏的一切

00:14:10.918 --> 00:14:14.154 
一次敲击或一次滚动--即有来自设备
其他传感器的一切

00:14:14.221 --> 00:14:16.023 
比如定位更改

00:14:16.723 --> 00:14:20.294 
及多重任务缩略图及其他系统状态
事件等均在这里

00:14:21.695 --> 00:14:24.331 
如果你的主线程主要针对

00:14:24.464 --> 00:14:25.766 
用户输入响应任务

00:14:26.233 --> 00:14:28.402 
你的app将始终感觉很棒

00:14:29.770 --> 00:14:31.672 
如果你对你的主线程操作有些不够细心
或者

00:14:31.738 --> 00:14:33.607 
也许你在你的主线程上

00:14:33.674 --> 00:14:34.508 
什么都做

00:14:35.008 --> 00:14:37.744 
那么你的app可能出现
停滞或冻结现象

00:14:40.547 --> 00:14:43.217 
所以
我们应该避免对我们的主线程做什么？

00:14:44.384 --> 00:14:47.821 
特别注意CPU密集型业务

00:14:48.488 --> 00:14:51.191 
这可能是解析你从网络上下载的很长一
段字符串

00:14:51.258 --> 00:14:54.127 
可能是对某图像进行过滤

00:14:54.695 --> 00:14:57.064 
以及与外部资源有关的任务

00:14:57.531 --> 00:14:58.565 
我回头还会讲这个问题

00:14:59.366 --> 00:15:02.035 
我今天不打算花太多时间讲CPU密集
型业务

00:15:02.102 --> 00:15:04.104 
因为本周开始的时候有一个非常好的演
讲

00:15:04.304 --> 00:15:05.572 
演讲者做了

00:15:06.173 --> 00:15:07.841 
叫做"Profiling in Depth"的仪器

00:15:08.041 --> 00:15:10.444 
他们事实上讲到用仪器

00:15:10.511 --> 00:15:14.248 
对其中CPU密集型业务做性能改进

00:15:14.715 --> 00:15:15.549 
很棒

00:15:16.750 --> 00:15:19.753 
所以我们回到与外部资源有关的任务

00:15:20.120 --> 00:15:22.556 
其另一名称叫阻塞调用

00:15:23.357 --> 00:15:26.693 
之所以叫这个名字是因为你的线程进展
被阻止所以你被阻断

00:15:27.661 --> 00:15:28.695 
那么 什么是阻塞调用？

00:15:29.429 --> 00:15:31.899 
你们中可能有人熟悉
系统调用（syscall）

00:15:33.233 --> 00:15:34.535 
任何进行了系统调用的代码

00:15:34.601 --> 00:15:37.004 
路径均被认为是阻塞调用

00:15:38.505 --> 00:15:39.573 
正如我所说

00:15:39.740 --> 00:15:41.909 
这一般涉及到

00:15:41.975 --> 00:15:43.510 
目前不在内存中的资源

00:15:44.244 --> 00:15:46.747 
一般是
从磁盘载入内容

00:15:46.980 --> 00:15:48.615 
或网络上取用材料

00:15:49.950 --> 00:15:52.252 
有时候 你的主线程也会被阻塞

00:15:52.886 --> 00:15:55.155 
原因是在等待可用资源

00:15:55.756 --> 00:15:57.591 
但是它是在等待他人完成资源使用

00:15:57.658 --> 00:16:00.827 
因为该资源一次只允许
一个客户使用

00:16:04.198 --> 00:16:06.333 
那么 你如何认出你线程的阻塞调用？

00:16:06.867 --> 00:16:08.402 
有时它们刚好出现在你目前

00:16:09.336 --> 00:16:11.772 
"同步"一词即表示阻塞

00:16:12.506 --> 00:16:14.741 
所以这是一个线索
当你读代码时

00:16:14.808 --> 00:16:16.276 
你要注意到它

00:16:17.411 --> 00:16:18.245 
所以很好

00:16:18.312 --> 00:16:20.047 
我们在我的代码中发现了这个阻
塞调用

00:16:20.113 --> 00:16:22.416 
‘NSURLConnection
发送同步请求’

00:16:23.183 --> 00:16:24.117 
那么 现在我做什么？

00:16:25.018 --> 00:16:27.921 
有时会有一个同步的API --

00:16:28.088 --> 00:16:30.224 
尤其是对于声称

00:16:30.290 --> 00:16:31.758 
其名字同步的API--

00:16:32.426 --> 00:16:33.861 
你可以轻松转换到这种API

00:16:34.528 --> 00:16:37.364 
这种情况下 我们很幸运 而事实上

00:16:37.431 --> 00:16:39.933 
这个名字中出现的是有用的"异步"字
样

00:16:40.400 --> 00:16:42.369 
那么我们就确切知道了
自己要进入的是哪里

00:16:43.537 --> 00:16:46.173 
很遗憾 这不似搜索和替换那么简单

00:16:46.707 --> 00:16:49.576 
你正在改变你的代码的执行顺序

00:16:49.810 --> 00:16:51.512 
你可能有与此次操作结果

00:16:51.578 --> 00:16:53.013 
有关的其他代码

00:16:53.547 --> 00:16:56.383 
所以很遗憾 需要一些调整

00:16:58.485 --> 00:16:59.753 
但是让我说

00:17:00.587 --> 00:17:03.023 
你没有能够轻松切换到的相当的asy
nc

00:17:03.090 --> 00:17:05.459 
或者你想将全部代码

00:17:05.526 --> 00:17:07.728 
一次操作即移出主线程

00:17:08.529 --> 00:17:11.330 
这种情况下用Grand
CentralDispatch即可

00:17:12.398 --> 00:17:14.867 
Grand Central Dispatch
是Apple的一项技术

00:17:15.002 --> 00:17:17.436 
可管理你app中的全局线程池

00:17:17.738 --> 00:17:19.239 
已经好了
即使你没有注意到

00:17:20.941 --> 00:17:25.479 
如果你熟悉其他平台上的线程编程
Grand Central Dispatch

00:17:25.811 --> 00:17:28.949 
在某种程度上
可完全避免混淆 消除你

00:17:29.016 --> 00:17:31.451 
对于启动线程及其状态等的担忧

00:17:32.152 --> 00:17:34.188 
让你明确出向运行的任务

00:17:34.254 --> 00:17:35.355 
如封闭或阻塞

00:17:37.524 --> 00:17:40.527 
这些封闭任务一旦你提交给
Grand Central Dispatch

00:17:40.594 --> 00:17:42.696 
即在你的流程中任一线程上运行

00:17:48.936 --> 00:17:51.305 
所有线程都很棒 因为你不必

00:17:51.371 --> 00:17:52.506 
启动它们 也不必考虑

00:17:52.573 --> 00:17:55.142 
它们的数量 但是它们会有警告

00:17:55.542 --> 00:17:58.912 
由于你不控制你的代码在哪个线程上影
响

00:17:59.613 --> 00:18:01.715 
你在封闭或阻塞任务中明确的任何操作

00:18:01.782 --> 00:18:04.685 
必须在任一线程上均安全

00:18:07.154 --> 00:18:08.388 
有些什么例子吗？

00:18:09.823 --> 00:18:12.226 
一些对象事实上只是被限制

00:18:12.292 --> 00:18:13.360 
进入主线程

00:18:13.861 --> 00:18:16.196 
例如UIKit视图和控制器

00:18:17.030 --> 00:18:21.168 
必须在主
线程上创建修改或销毁

00:18:22.503 --> 00:18:25.372 
一些对象如Foundation和C
ore Graphics

00:18:25.839 --> 00:18:27.541 
可采用任何线程

00:18:28.475 --> 00:18:31.245 
但是 其中许多另有规定

00:18:31.578 --> 00:18:33.080 
这些规定是调用者提出

00:18:33.146 --> 00:18:37.417 
目的是确保当时只有一个线程被采用

00:18:38.118 --> 00:18:39.920 
它们内部无自我保护

00:18:40.420 --> 00:18:42.656 
所以 如果你要用于多线程

00:18:43.023 --> 00:18:45.659 
你常常必须自行采取保护

00:18:46.026 --> 00:18:49.096 
为此 最好的方法是GCD串行队列

00:18:50.531 --> 00:18:52.566 
要想知道你的对象预计会被如何处理

00:18:52.633 --> 00:18:54.601 
最好的方法是读标题

00:18:54.902 --> 00:18:56.870 
每个对象 通常在靠近初始化程序处

00:18:57.104 --> 00:18:59.606 
应有一个描述 确切说明该对象

00:18:59.673 --> 00:19:01.341 
在你的app中如何通过线程被存取

00:19:01.975 --> 00:19:03.410 
如此 让我们回到我的例子

00:19:04.378 --> 00:19:05.512 
我在这个代码中做什么？

00:19:05.579 --> 00:19:07.114 
我从一个文件中加载一些数据

00:19:08.415 --> 00:19:09.783 
我对一个图像进行处理和过滤

00:19:10.817 --> 00:19:13.620 
最后
我把它放在我视图层次的图像视图中

00:19:14.655 --> 00:19:17.424 
那么现在
当用户敲击我app中的一个按钮时

00:19:18.425 --> 00:19:19.860 
我的主线程就有点像这样

00:19:20.360 --> 00:19:23.463 
它会按顺序做3件事

00:19:24.464 --> 00:19:27.501 
简单 直接 很好理解 很棒

00:19:28.836 --> 00:19:29.770 
遗憾地是

00:19:30.137 --> 00:19:32.306 
如果在我做这件事的时候

00:19:32.372 --> 00:19:34.942 
用户偶尔做尝试
向右滚动或旋转

00:19:35.876 --> 00:19:41.081 
我们将无法操作输入项
只能拖后

00:19:42.316 --> 00:19:44.351 
关于阻塞请求

00:19:44.418 --> 00:19:47.020 
你永远不知道它们要花的时间
这就像天气的变化一样

00:19:47.521 --> 00:19:51.325 
用户需要等待不知道有多久

00:19:51.792 --> 00:19:52.793 
这会使他们很沮丧

00:19:54.027 --> 00:19:55.329 
那么如何解决这一问题呢？

00:19:55.863 --> 00:19:58.365 
我们可以使用
Grand Central Dispatch

00:19:58.432 --> 00:20:00.634 
我们可以使用
Grand Central Dispatch API的

00:20:00.701 --> 00:20:02.503 
"dispatch async"异步执行

00:20:02.669 --> 00:20:05.205 
现在 "dispatch async"
采取了两个命令参数

00:20:05.839 --> 00:20:07.307 
第一个需要输入的是

00:20:07.875 --> 00:20:10.244 
你想使用哪一个队列

00:20:10.844 --> 00:20:13.280 
如我所提到的那样
你的app内已经有几个队列

00:20:13.747 --> 00:20:15.282 
由GCD为你创建

00:20:15.816 --> 00:20:19.686 
我将使用 "dispatch get global queue"
API得到其中之一

00:20:20.387 --> 00:20:23.223 
因为有几个可供选择
我需要告知GCD

00:20:23.290 --> 00:20:24.124 
我想要哪一个

00:20:24.858 --> 00:20:27.494 
这儿我要用
"Quality of Service"等级

00:20:28.095 --> 00:20:30.430 
"Quality of Service"
是关于怎样告知系统

00:20:30.497 --> 00:20:34.668 
你请求它完成的工作
相对于app上的其它工作

00:20:34.935 --> 00:20:36.470 
以及系统内的其它工作有多重要

00:20:37.237 --> 00:20:38.238 
在这种情况下

00:20:38.305 --> 00:20:40.741 
因为这是用户行为
的直接结果

00:20:41.208 --> 00:20:43.343 
并且用户
也许正在等待这一结果

00:20:43.677 --> 00:20:45.679 
我将使用"user-initiated"

00:20:45.746 --> 00:20:46.580 
QOS等级

00:20:48.615 --> 00:20:50.684 
"dispatch async"

00:20:51.318 --> 00:20:53.787 
最后的参数是闭包
包含你想让它运行的代码

00:20:55.656 --> 00:20:57.191 
好了
完成了

00:20:57.424 --> 00:20:58.292 
已经离开了主线程

00:20:58.492 --> 00:20:59.326 
好了吗？

00:21:00.527 --> 00:21:01.361 
还没完全好

00:21:01.895 --> 00:21:03.697 
如我提到的 UIKit
views

00:21:03.764 --> 00:21:06.466 
和controllers
只是在主线程上使用才安全

00:21:07.134 --> 00:21:08.535 
所以我不能把它们置于该闭包内

00:21:10.070 --> 00:21:12.406 
因此这并不是代码最慢的部分

00:21:12.472 --> 00:21:13.507 
对吗？

00:21:13.574 --> 00:21:15.242 
前两行是阻塞请求

00:21:16.143 --> 00:21:18.378 
为什么我不把它移到主线程上？

00:21:20.047 --> 00:21:22.115 
不幸地是 那样也是不行的

00:21:22.449 --> 00:21:24.051 
因为我实际已经改变了代码

00:21:24.117 --> 00:21:25.452 
执行的命令

00:21:26.453 --> 00:21:28.755 
该关闭并不一定在

00:21:29.056 --> 00:21:31.391 
"dispatch async"
返回的的时候运行

00:21:31.558 --> 00:21:33.760 
当然希望它将很快运行

00:21:34.494 --> 00:21:35.662 
最有可能的是

00:21:36.263 --> 00:21:37.931 
一旦GCD将工作送至

00:21:37.998 --> 00:21:40.100 
dispatch queue
它会立即进入到

00:21:40.167 --> 00:21:42.302 
下一行 在此点上

00:21:42.936 --> 00:21:44.505 
我的图像仍然可能没有

00:21:45.072 --> 00:21:46.440 
用户将永远看不到他们的图像

00:21:47.074 --> 00:21:48.275 
这会使他们抓狂的

00:21:49.943 --> 00:21:51.144 
那么如何处理这种情况呢？

00:21:51.678 --> 00:21:53.981 
我们实际上可以向"dispatch async"

00:21:54.982 --> 00:21:56.250 
发出另外一个请求
这次

00:21:56.316 --> 00:21:58.585 
我们将使用一个特别的队列叫做
主队列

00:21:59.086 --> 00:22:02.322 
主队列则保证会由主线程服务

00:22:02.756 --> 00:22:04.458 
你可以使用API
dispatch的

00:22:04.525 --> 00:22:06.493 
"get main queue"获得主队列

00:22:07.227 --> 00:22:08.128 
这意味着

00:22:08.962 --> 00:22:11.832 
如果你有对象需要进入

00:22:11.899 --> 00:22:14.668 
主线程 你可以把它们放进闭包中
并发给dispatch

00:22:14.735 --> 00:22:16.270 
你只需要确保它们这个队列中运行

00:22:16.870 --> 00:22:18.038 
现在
我们已经做到了

00:22:18.105 --> 00:22:20.307 
我的imageView完好

00:22:21.675 --> 00:22:22.776 
这样

00:22:23.110 --> 00:22:24.778 
我们将该工作退出主线程

00:22:25.379 --> 00:22:27.147 
但是当我们需要使用主线程上的

00:22:27.214 --> 00:22:29.416 
对象时 一旦数据准备好

00:22:29.483 --> 00:22:31.351 
我们就可以这样做

00:22:32.419 --> 00:22:35.122 
顺便说一下 我们最初要解决的问题

00:22:35.856 --> 00:22:37.558 
如果用户尝试 滚动或旋转

00:22:38.392 --> 00:22:40.561 
将会立刻得以处理

00:22:41.428 --> 00:22:42.629 
谢谢！

00:22:47.367 --> 00:22:49.670 
那么你可能在代码中发现

00:22:49.736 --> 00:22:50.904 
哪一种类型的阻塞请求？

00:22:50.971 --> 00:22:52.873 
它们在暗处 可能藏在各种地方

00:22:54.508 --> 00:22:55.909 
如我所提到的那样 联网、

00:22:56.176 --> 00:22:57.978 
NSURL
Connection和朋友

00:22:58.212 --> 00:23:00.414 
很容易无意间

00:23:00.781 --> 00:23:02.449 
向网络发出同步请求

00:23:03.517 --> 00:23:05.752 
通常 你可以切换到异步API

00:23:06.854 --> 00:23:09.423 
或者如果你想要对app何时进入网络

00:23:09.656 --> 00:23:11.625 
有更多的控制

00:23:12.426 --> 00:23:15.095 
在某些情况下 让它在不运行时
进行下载

00:23:15.596 --> 00:23:18.799 
我建议你查看NSURL
Session后台演讲

00:23:20.467 --> 00:23:23.871 
Foundation initializers
当你在代码中遇到这些问题时

00:23:23.971 --> 00:23:25.072 
它们并非看起来那么可怕

00:23:25.205 --> 00:23:26.073 
它只是一行

00:23:26.139 --> 00:23:27.007 
有什么可怕的？

00:23:27.608 --> 00:23:29.009 
但是 其中一些

00:23:29.243 --> 00:23:31.645 
像名为"contents of file"或者

00:23:32.279 --> 00:23:33.780 
"contents of URL"

00:23:34.114 --> 00:23:36.617 
可能不得不使用硬盘或其它资源

00:23:36.683 --> 00:23:37.684 
来满足要求

00:23:39.086 --> 00:23:40.821 
最后 Core Data

00:23:41.522 --> 00:23:44.691 
它们看起来像一些对象 对吗？

00:23:45.425 --> 00:23:48.195 
Core Data代表
你不断地进行很多I/O

00:23:49.363 --> 00:23:51.365 
幸运地是 很容易将一些

00:23:51.431 --> 00:23:53.133 
记录的操作移到

00:23:53.333 --> 00:23:54.801 
不同的并发模式

00:23:55.335 --> 00:23:58.005 
实际上 今年在Core
Data内有一个新的API

00:23:58.238 --> 00:24:01.408 
简化各种一般的批量操作

00:24:02.075 --> 00:24:04.077 
你可以另选时间从演讲中了解

00:24:04.444 --> 00:24:06.146 
"Core Data的
新变化是什么"

00:24:06.380 --> 00:24:08.482 
所以如果你发现了一个阻塞请求

00:24:08.982 --> 00:24:10.350 
切换到异步API

00:24:10.951 --> 00:24:11.818 
或者使用GCD

00:24:12.619 --> 00:24:15.088 
如果你想更多了解GCD 包括

00:24:15.155 --> 00:24:18.258 
今年可以简化一般操作的新API

00:24:18.725 --> 00:24:21.528 
以及前面提到的quality
of service等级

00:24:22.262 --> 00:24:24.331 
这儿一小时前就有一个不错的会话

00:24:24.398 --> 00:24:27.234 
称作 "GCD Building
Responsive and Efficient Apps"

00:24:27.401 --> 00:24:28.535 
我建议你看看它

00:24:32.272 --> 00:24:34.308 
让我们继续看一看存储

00:24:35.442 --> 00:24:38.312 
我说过存储是移动设备上

00:24:38.579 --> 00:24:39.446 
最宝贵的资源

00:24:41.715 --> 00:24:45.018 
如果你计划在app中采用多任务处理

00:24:45.953 --> 00:24:47.721 
你不能再自由使用屏幕

00:24:48.255 --> 00:24:51.225 
当然你也
不能自由使用

00:24:51.291 --> 00:24:52.526 
其它系统资源

00:24:54.895 --> 00:24:56.430 
如果你把一些代码从app带入

00:24:56.496 --> 00:24:58.565 
watchOS 那么 重要的是

00:24:58.632 --> 00:25:00.334 
内存占用应当紧凑

00:25:02.336 --> 00:25:05.239 
另外 iOS 9支持很大范围的硬件

00:25:05.873 --> 00:25:08.742 
如果你想把大型apps
和功能带入一些

00:25:08.809 --> 00:25:10.811 
OS支持的低端设备

00:25:11.512 --> 00:25:13.680 
存储在这些系统中非常重要

00:25:14.481 --> 00:25:17.084 
最后 如果你是扩展的开发者

00:25:17.651 --> 00:25:19.987 
想一想你的扩展也许现在被要求运行

00:25:20.053 --> 00:25:23.223 
而这时
屏幕上还有两个其它的apps

00:25:24.191 --> 00:25:26.760 
因此 存储会是十分需要的 你需要

00:25:26.827 --> 00:25:28.896 
尽可能少地使用

00:25:30.964 --> 00:25:33.300 
现在
让我们看看存储在iOS上如何工作

00:25:35.302 --> 00:25:36.136 
基本原则

00:25:36.470 --> 00:25:39.439 
任何iOS 装置里
都没有足够的物理内存

00:25:39.740 --> 00:25:42.743 
把所有暂停的App
同时保存在RAM里

00:25:44.645 --> 00:25:47.314 
当我们有内存压力时
我们实际上必须

00:25:47.381 --> 00:25:50.484 
清理一些事情出去
把空间留给前景无限的app

00:25:51.485 --> 00:25:55.189 
在OS X 或PC 操作系统上
我们可能要首先

00:25:55.255 --> 00:25:57.758 
要把这些app的状态
写到磁盘上 但是

00:25:57.824 --> 00:26:00.093 
这在移动装置上
根本行不通

00:26:00.594 --> 00:26:02.796 
所以 一旦你要清理空间
你就必须消失

00:26:04.765 --> 00:26:06.900 
还有更多细节
可以慢慢详述

00:26:07.434 --> 00:26:10.637 
实际上前几年
有一个所谓的伟大谈话

00:26:10.737 --> 00:26:12.172 
叫做"iOS App 性能内存"

00:26:13.040 --> 00:26:15.042 
滑动模板和颜色
稍微有点不同

00:26:15.108 --> 00:26:17.778 
但是信息真的是
货真价实

00:26:17.845 --> 00:26:20.013 
所以如果你感兴趣的话
请去看看那个产品

00:26:20.080 --> 00:26:21.215 
学习学习
这是如何运作的

00:26:22.482 --> 00:26:24.785 
但是如果你以前
从未想过app里有内存

00:26:25.185 --> 00:26:26.220 
总是归结为

00:26:26.954 --> 00:26:28.689 
回收内存需要花时间

00:26:29.189 --> 00:26:31.425 
如果你已经用完
系统中所有

00:26:31.491 --> 00:26:33.460 
可用的内存
然后需要更多

00:26:33.861 --> 00:26:36.230 
你可能要等待
而系统清理一些东西

00:26:36.296 --> 00:26:37.164 
以你的名义清理

00:26:37.931 --> 00:26:40.200 
如果你突然请求
大量内存

00:26:40.968 --> 00:26:42.970 
系统就需要
清理若干不同内容

00:26:43.036 --> 00:26:43.937 
来满足你的请求

00:26:44.371 --> 00:26:46.607 
这影响到
App的反应效率

00:26:48.976 --> 00:26:50.878 
相反 当你
在背景里时

00:26:51.545 --> 00:26:53.180 
如果你的足迹
非常简缩

00:26:53.680 --> 00:26:55.482 
实际上
你不太可能成为

00:26:55.549 --> 00:26:56.917 
被清理之列

00:26:57.417 --> 00:26:59.319 
所以当用户
返回到你的app时

00:26:59.720 --> 00:27:02.022 
你能够恢复原貌
而不是重启

00:27:02.589 --> 00:27:03.624 
这感觉就快多了

00:27:05.492 --> 00:27:07.528 
所以 如果你以前
从未想过内存的话

00:27:08.328 --> 00:27:09.930 
这真是很重要的
第一步

00:27:10.063 --> 00:27:11.932 
要合理化你的
App内存足迹

00:27:12.599 --> 00:27:14.668 
也就是说
要想一想各种类型

00:27:14.735 --> 00:27:16.170 
所用资源的类型

00:27:17.070 --> 00:27:20.807 
这些可能是字符串；
可能是JSON 或 XML的小泡泡

00:27:20.874 --> 00:27:22.075 
你从网络上下载的这些

00:27:22.943 --> 00:27:23.977 
还有图片 也是

00:27:24.044 --> 00:27:26.380 
来自网络 或者
用户用照相机照的

00:27:27.080 --> 00:27:29.917 
还有 Core Data管理
的东西 用了很多

00:27:29.983 --> 00:27:32.452 
潜在的资源
似乎是奇迹发生

00:27:34.388 --> 00:27:36.757 
一旦你思考
这些资源 你就会开始

00:27:36.823 --> 00:27:40.127 
按照用户互动
把他们分组

00:27:40.194 --> 00:27:43.397 
归类 这有助于
你建立一个思想模式

00:27:43.463 --> 00:27:45.132 
对于自己App
所用的资源

00:27:46.366 --> 00:27:47.267 
一旦你已经那样做了

00:27:47.534 --> 00:27:50.070 
我们可以用Xcode 调试器
快速检查你的作业

00:27:51.538 --> 00:27:53.106 
要了解更多细节

00:27:53.173 --> 00:27:54.341 
我们可以去配置栏

00:27:54.408 --> 00:27:55.242 
和遗漏工具

00:27:55.876 --> 00:27:57.511 
我不想说这么多
今天

00:27:57.578 --> 00:27:58.412 
但请找找

00:27:58.478 --> 00:28:00.414 
去年的类似谈话
名叫"用工具

00:28:00.480 --> 00:28:02.149 
提高你的App"
从那里开始看吧

00:28:03.750 --> 00:28:05.485 
所以我们返回到
Xcode调试器

00:28:06.453 --> 00:28:09.056 
我已经下载了
Photos框架案例app

00:28:09.223 --> 00:28:10.524 
这是从苹果开发者
网站下载的

00:28:11.258 --> 00:28:13.427 
我已经安装到手机中
打开了Xcode 项目

00:28:13.660 --> 00:28:14.595 
草创并运行

00:28:15.295 --> 00:28:18.999 
现在我刚刚开始看看左上方
在我调试器的Xcode窗口的左上方

00:28:19.399 --> 00:28:20.334 
放大进去

00:28:21.435 --> 00:28:23.403 
这里 正好我看到

00:28:23.470 --> 00:28:26.406 
不用眼睛贴着手机屏幕
也能看到第一个数据 太有趣了

00:28:27.307 --> 00:28:29.543 
现在我知道
在我的app发起之后

00:28:29.610 --> 00:28:31.044 
在用户可以做任何事情之前

00:28:31.378 --> 00:28:33.380 
我正在使用大约10MB的内存

00:28:35.916 --> 00:28:37.918 
我想要搜集的下一个数据点

00:28:38.452 --> 00:28:39.686 
就是我想要离开

00:28:39.753 --> 00:28:42.556 
所有在我的App中
最常见的用户交互都执行了

00:28:42.823 --> 00:28:45.526 
因为这是一个照片App
所以我会打开一张照片

00:28:46.460 --> 00:28:48.795 
现在我明白了
每打开一张照片

00:28:49.062 --> 00:28:51.665 
我的App另外需要
大约2.5兆的内存

00:28:53.066 --> 00:28:55.836 
在这一点上 另一个有趣的实验是

00:28:56.303 --> 00:28:58.539 
一遍又一遍地重复执行同样的动作

00:28:58.605 --> 00:29:03.343 
所以 我可能会多次打开
一张相同的照片或两张不同的照片

00:29:04.144 --> 00:29:06.079 
如果我的内存占用持续增长

00:29:06.480 --> 00:29:08.482 
我可能需要解决一下内存方面的问题

00:29:10.517 --> 00:29:11.885 
最后有趣的是

00:29:12.586 --> 00:29:15.756 
我需要使用我设备上的
Home按钮来暂停App

00:29:16.223 --> 00:29:18.792 
而且我想看看当它进入后台时
会发生什么

00:29:19.459 --> 00:29:22.529 
它看起来好像比它刚刚启动之后

00:29:22.596 --> 00:29:24.264 
要稍微小了一点点

00:29:25.299 --> 00:29:26.834 
这真是对打击很好的一种平衡

00:29:27.734 --> 00:29:30.537 
你不想再重复你在恢复期间所做的工作

00:29:31.338 --> 00:29:33.640 
但你也想保持后台的紧凑

00:29:33.841 --> 00:29:36.143 
以确保你的用户实际体验到那个恢复

00:29:41.281 --> 00:29:42.182 
需要注意的是

00:29:42.649 --> 00:29:43.917 
照片框架示例App

00:29:43.984 --> 00:29:46.453 
实际上并不需要做什么
特别的事情或施展魔法

00:29:46.653 --> 00:29:47.688 
以实现这一行为

00:29:48.121 --> 00:29:50.190 
它实际上只是一个非常简单的

00:29:50.257 --> 00:29:52.826 
对苹果技术最小的一种应用

00:29:53.427 --> 00:29:56.964 
而且苹果技术实际上
通常会将这个行为

00:29:57.030 --> 00:29:59.800 
进行内置
而它们只是管理一下基本资源

00:30:00.033 --> 00:30:02.970 
以自动响应于应用程序生命周期事件

00:30:03.270 --> 00:30:04.438 
所以你并不需要担心这个

00:30:05.606 --> 00:30:06.473 
但是

00:30:06.540 --> 00:30:08.442 
如果你有大的对象或者你自己的其他资
源

00:30:08.509 --> 00:30:11.345 
那么你将有一些动态上的损失

00:30:11.411 --> 00:30:14.081 
并会返回来响应应用程序生命周期事件

00:30:14.548 --> 00:30:15.749 
做到这一点最简单的方法是

00:30:15.816 --> 00:30:17.117 
使用NSCache

00:30:18.185 --> 00:30:20.654 
不过在某些情况下
你虽然可能会遇到

00:30:20.721 --> 00:30:24.358 
需要将不能灵巧地被表示为可回收的对
象用于NSCache

00:30:25.025 --> 00:30:27.327 
这时候你不得不
实际上执行自定义代码

00:30:27.394 --> 00:30:30.397 
以响应你App中的生命周期通知

00:30:31.698 --> 00:30:33.133 
有一些通知你可能会感兴趣

00:30:33.800 --> 00:30:35.569 
比如"确实进入了后台"的通知

00:30:36.336 --> 00:30:38.338 
你的App在挂起会得到这个通知

00:30:38.539 --> 00:30:40.707 
而这正是NSCache
使用这个通知

00:30:40.874 --> 00:30:42.976 
在你进入后台时使
App实际上执行了释放

00:30:43.710 --> 00:30:46.780 
另一个有趣的通知是内存警告通知

00:30:47.314 --> 00:30:50.350 
系统实际上是在发出这个通知之后
才开始逐出

00:30:50.417 --> 00:30:52.786 
挂起的App
从而给它们一个释放的机会

00:30:53.720 --> 00:30:55.355 
或许它们能够避免被逐出

00:30:55.589 --> 00:30:56.823 
只要它们占用的内存下降了

00:30:57.958 --> 00:30:59.993 
所以我在这里对那个问题举了一个简单
的例 子

00:31:01.028 --> 00:31:03.630 
我将使用默认的
NSNotificationCenter

00:31:03.830 --> 00:31:05.832 
在这种情况下 我要添加一个观察员

00:31:06.033 --> 00:31:07.935 
以观察"确实收到了
内存警告"的通知

00:31:09.670 --> 00:31:12.840 
而所有我要做的就是调用一些
"自定义缓存清除"的代码

00:31:14.041 --> 00:31:16.743 
也许这会搭板C结构一起使用

00:31:16.810 --> 00:31:18.111 
并释放一些其他的内存

00:31:19.913 --> 00:31:22.282 
需要注意的是 如果你真地注册了

00:31:22.349 --> 00:31:26.053 
NSNotificationCenter观察员
特别是在初始化时

00:31:26.620 --> 00:31:28.789 
请一定要在反初始化中删除你自己

00:31:29.623 --> 00:31:31.091 
你知道 内存实在是太重要了

00:31:31.325 --> 00:31:32.626 
因为我还准备讲另外一个课程

00:31:32.693 --> 00:31:33.827 
我希望你们去听一听

00:31:35.262 --> 00:31:36.163 
这个课的名字叫做

00:31:36.230 --> 00:31:37.998 
"在安装有iOS 9
系统的iPad上

00:31:38.065 --> 00:31:39.499 
优化你的App多任务处理"

00:31:40.133 --> 00:31:42.636 
但实际上
即使你的App无法在iPad上运行

00:31:42.703 --> 00:31:44.872 
或者你有没有计划支持多任务处理

00:31:45.105 --> 00:31:46.406 
也请你去听一听这个课程

00:31:47.140 --> 00:31:49.977 
这个课程对应用程序
所使用的资源类型

00:31:50.043 --> 00:31:51.078 
介绍了大量的详细信息

00:31:51.545 --> 00:31:53.480 
包括它们通常以何种模式进入访问

00:31:53.947 --> 00:31:56.717 
以及更多有关如何使你的App响应

00:31:56.783 --> 00:31:57.851 
系统内存状态的信息

00:31:58.452 --> 00:31:59.286 
这真是太棒了

00:32:01.855 --> 00:32:04.324 
最后同样重要的是
我希望你们都会非常兴奋地看到

00:32:04.391 --> 00:32:06.360 
我们把原代码带到
watchOS 2中

00:32:07.995 --> 00:32:10.731 
当你正在思考如何建立你的watch
OS 2 App时

00:32:11.498 --> 00:32:13.400 
你必须开始于一个伟大的设计

00:32:14.034 --> 00:32:16.837 
这个设计真正地关注于你App的基本
功能

00:32:16.904 --> 00:32:19.306 
使它们轻松、愉快

00:32:19.373 --> 00:32:20.507 
并且方便于用户访问

00:32:21.475 --> 00:32:22.776 
如果你在这方面需要获得帮助

00:32:22.843 --> 00:32:24.778 
这里有一个非常不错的课程
你可以去听一听

00:32:24.845 --> 00:32:26.547 
这个课程叫做"苹果手表App设计"

00:32:27.781 --> 00:32:30.350 
一旦你为你的苹果手表App找到了一
个伟大的设计

00:32:31.351 --> 00:32:33.654 
那么你就可以开始考虑

00:32:33.720 --> 00:32:36.256 
你的iOS App在哪些方面
可能值得再次使用

00:32:37.224 --> 00:32:39.426 
这可包括实际代码

00:32:40.360 --> 00:32:42.429 
或熟悉的API访问
模式

00:32:42.763 --> 00:32:44.898 
以及平台之间共享的框架

00:32:46.934 --> 00:32:48.702 
有时候 你在iOS上做的一些事情

00:32:48.769 --> 00:32:51.338 
实际上可能在watchOS上没有任
何意义

00:32:51.705 --> 00:32:53.106 
比如出于性能上的考虑就会这样

00:32:53.240 --> 00:32:54.908 
你最终会执行新的机制

00:32:55.609 --> 00:32:57.644 
以便在其它平台上获得相同的结果

00:33:05.419 --> 00:33:08.422 
watchOS用户希望交互行为快速
而简单

00:33:09.022 --> 00:33:12.059 
而且他们总是希望能在App
看到最新的相关数据、

00:33:12.392 --> 00:33:14.561 
通知以及快捷视图

00:33:15.729 --> 00:33:18.065 
作为一名App开发者
这对你意味着什么呢？

00:33:19.132 --> 00:33:21.001 
用户最有可能做的事情是

00:33:21.068 --> 00:33:24.071 
在watchOS上刚一启动App

00:33:24.137 --> 00:33:26.940 
随后就能看到他们想看到的内容

00:33:28.642 --> 00:33:29.810 
那么我们能够做的工作

00:33:29.877 --> 00:33:32.045 
是不是让watchOS有
非常久的启动时间

00:33:32.112 --> 00:33:33.247 
以及非常缓慢的响应呢？

00:33:34.882 --> 00:33:37.017 
我们必须关注于最大限度地减少两个工
作量

00:33:37.084 --> 00:33:39.987 
一是你生成的网络流量
以及你必须在设备上

00:33:40.053 --> 00:33:42.589 
完成的以便它能顺利
执行任务的工作量

00:33:43.891 --> 00:33:46.293 
如果你正在访问的服务器
你可以对它进行控制

00:33:46.360 --> 00:33:47.628 
并且能够添加新的API

00:33:49.096 --> 00:33:50.731 
那么请确保你给苹果手表发送了

00:33:50.797 --> 00:33:52.966 
适当大小和格式的响应

00:33:54.101 --> 00:33:57.571 
有的可能很简单
比如从JSON或XML数据块中

00:33:57.671 --> 00:33:59.339 
删除未使用的密钥

00:34:00.140 --> 00:34:01.508 
调整图像大小等等

00:34:01.775 --> 00:34:03.844 
这样
苹果手表就会精确地显示它们

00:34:03.911 --> 00:34:05.712 
就如同它们是通过连线传输过来的一样

00:34:05.779 --> 00:34:09.550 
而且不必做任何额外的工作
如果你的API适用于

00:34:09.616 --> 00:34:11.552 
大屏幕设备

00:34:11.618 --> 00:34:13.120 
可以同时显示10条

00:34:13.187 --> 00:34:14.621 
或20条记录

00:34:15.355 --> 00:34:16.422 
它可能会发回

00:34:16.489 --> 00:34:17.958 
一次调用中发生的所有这些信息

00:34:18.492 --> 00:34:19.726 
但实际上 对于苹果手表来说

00:34:19.960 --> 00:34:21.695 
你应该只发送需要在
单个屏幕上显示的

00:34:21.762 --> 00:34:24.464 
有关记录的正确数字

00:34:25.732 --> 00:34:28.235 
为了随时显示更新的相关信息

00:34:28.802 --> 00:34:30.838 
很重要的一点是使用
你的iPhone App

00:34:30.904 --> 00:34:32.572 
来保持App内容的更新

00:34:33.206 --> 00:34:35.509 
App内容是平台之间的

00:34:35.576 --> 00:34:37.444 
一种双向共享状态

00:34:37.878 --> 00:34:40.147 
因此
当用户在任一用户端上采取行动

00:34:40.214 --> 00:34:42.683 
这将导致他们希望在另一用户端上

00:34:42.748 --> 00:34:45.052 
看到可以更新的不同的东西

00:34:45.686 --> 00:34:46.920 
API对此的反应是

00:34:47.420 --> 00:34:50.324 
"手表连接性更新应用程序内容"

00:34:51.324 --> 00:34:52.592 
做这个工作的最好时刻

00:34:53.025 --> 00:34:56.697 
是你的iPhone App
被后台程序刷新唤醒的时候

00:34:57.598 --> 00:35:00.801 
当它完成下载新信息
并更新了它自己的快照时

00:35:01.268 --> 00:35:03.804 
它也可以
将这些信息推送到苹果手表上

00:35:03.871 --> 00:35:06.340 
这样它将在下一次
用户启动时做好准备

00:35:09.543 --> 00:35:10.377 
最后

00:35:11.278 --> 00:35:14.515 
如果你所依赖的服务器
由于某种原因你不能作出更改

00:35:15.215 --> 00:35:17.451 
比方说
你正在与第三方API竞争

00:35:18.285 --> 00:35:22.189 
你可以利用你的iPhone网络和C
PU来连接

00:35:22.389 --> 00:35:24.458 
从而实际上执行一个中介

00:35:24.591 --> 00:35:27.094 
使格式和大小响应于手机

00:35:27.895 --> 00:35:31.832 
你希望API的反应是
"手表连接发送信息"

00:35:33.433 --> 00:35:35.402 
所以你会发送
一条消息到iPhone上

00:35:36.170 --> 00:35:39.439 
提出你的要求
然后iPhone将会下载它

00:35:40.240 --> 00:35:43.277 
并完成我提到的所有操作
如删除未使用的密钥、

00:35:43.343 --> 00:35:45.546 
减少记录数、
调整图像大小等等

00:35:46.246 --> 00:35:49.550 
然后它会向手表发送
一个紧凑的可操作的答复

00:35:49.816 --> 00:35:51.418 
好了 WC课程又到结束的时间了

00:35:51.852 --> 00:35:52.686 
让我作一下总结

00:35:54.188 --> 00:35:55.455 
性能是一个特征

00:35:55.989 --> 00:35:57.457 
这是一个重要的方面

00:35:57.624 --> 00:36:00.093 
你的App必须给予
你的用户丰富的经验

00:36:00.761 --> 00:36:02.663 
从建立你的App的第一天开始

00:36:02.729 --> 00:36:04.031 
你就应该把这一点记在心里

00:36:05.666 --> 00:36:07.701 
当你使用高效的App时
你会感觉非常棒

00:36:08.101 --> 00:36:11.705 
因为它们建立了用户的信任
它们节省电池消耗

00:36:13.707 --> 00:36:16.810 
请了解我提到的所有的苹果技术

00:36:17.244 --> 00:36:19.880 
当你正在思考如何建立你的App时
请选择最好的技术

00:36:20.881 --> 00:36:22.983 
请保持你的主线程随时
为用户输入作好准备

00:36:24.351 --> 00:36:26.587 
你需要了解你的App
何时以及为什么使用内存

00:36:27.387 --> 00:36:29.323 
你需要获得watchOS

00:36:29.690 --> 00:36:32.159 
下载以及处理
极小集信息的大量经验

00:36:34.228 --> 00:36:35.696 
这里有一些非常不错的书面资料

00:36:35.762 --> 00:36:38.532 
如果你开始对这个东西产生兴趣
你可以学习一下这些资料

00:36:39.333 --> 00:36:41.468 
好了 这些就是我今天上课的主要内容

00:36:42.436 --> 00:36:45.639 
最开始 讲到的一些技术
是我们今年新推出的技术

00:36:45.873 --> 00:36:47.574 
还有一些技术是前几年推出的

00:36:48.509 --> 00:36:49.877 
谢谢大家 祝你们周五愉快！