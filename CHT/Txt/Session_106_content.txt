歡迎參加《Swift最新內容》講座
我是克里斯·拉特納我來主講前半部分
我的同事約翰·邁克考爾則會在下半部分介紹最新內容
在開始之前我覺得先來看看
我們想做什麼這很有趣也許會有幫助
Swift 2的目標是什麼以及它背後的思想是什麼？
我們主要追求三個目標
首先 基礎架構 
我們希望Swift語言的核心功能和核心行爲以及工具都非常出色
許多內容都需要很多在座的朋友
在使用Swift過程中產生的反饋
其中很多都是...
我非常感謝大家所提供的所有反饋
大家通過實際使用產生的出色反饋
才使得Swift得以不斷完善
第二 是安全
安全性是Swift的核心價值
我們的確希望能很容易地編寫安全代碼
我們覺得錯誤處理結構的新可用性
將成爲實現這一目的的傑出方式
第三是 美觀
我們希望代碼可以非常美觀
作爲編程人員 我們整天都在和代碼打交道
這一點對我們非常重要
我們在Swift中的新增內容使其更容易寫出自然美觀的代碼
今天我們介紹Swift的五項新內容
在我們詳細介紹Swift 2最新內容之前
我認爲有必要說明
Swift 1.2已經實現了長足進步
它不過是在三個月前發佈
由於時間所限我們沒辦法詳細介紹這個版本
但是如果你感興趣而且還沒有看到過
可以看看Swift編程語言書籍和Xcode 6版本發佈說明
我們來詳細介紹基礎架構部分
基礎架構是關於改進Swift語言的核心行爲以及它該如何通力配合
這裏有許多小細節
這感覺像是在漫無目的地漫步但是要跟上思路
我們先從枚舉講起
枚舉是Swift最好的功能之一
這裏我用枚舉來列舉一些常見的家養寵物
枚舉的出色在於它們很容易定義和使用
另一方面如果你已將它們用於遊樂場或打印出來
你可能就會想要更多
在Swift 2枚舉可以攜帶足夠的可以打印的反射信息且效果非常好
接下來相關值
枚舉的出色還在於它們是差別聯合類型的理想模型
當有兩種不同類型的值
需要在同一內容中進行保存時這就會非常有用
對嗎？
相關值非常強大
也許你會用任何一個類型編寫明顯的內容
這是用來做模型的理想方法
但是當你使用時會有些不快之處
這就太糟糕了大家都不希望是這樣
有了Swift 2這就不成問題
我們再看看遞歸
Swift中的枚舉就是代數數據類型
在其他語言中遞歸代數數據類型非常強大
可以做出相當棒的事情
問題在Swift中這些值在枚舉中都是內聯保存
這意味着如果是遞歸枚舉
它將會無限令當前的設備很難承受
也許在明年會有這方面的變通方案
大家可能都見過箱型可以以此作爲參考
但是要打破模式匹配就會很難看 很可怕
在Swift 2中有更好的方法
在beta 1中還不太好
不過很快你就可以間接標識自己的情況
可以自然地進行表達模式匹配效果也很棒
我們來繼續介紹範圍
有些時候你想重複使用某個名稱
也許是想確定某個之前發佈的資源
我們引入了可以介紹顯性範圍的新Do語句
在本例中 我們只想時不時和網絡挑釁打交道
但是我們需要緊緊地約束它們
在講座稍後 我們介紹錯誤處理部分時Do語句就會非常重要
但是把Do作爲關鍵字會導致一些潛在歧義
這種歧義不是針對編譯器而是在我們讀碼時會有歧義
你不會常常看太長的語句底部
我們還有Do While循環
通過語句的字符集了解它在做什麼
我們需要讓它變得非常簡單
通過看語句的字符集關鍵字就一目瞭然
所以我們把Do While循環更名爲Repeat
一看到頂部你就可以知道這是個循環
這樣就非常簡單
我們再看看選項集合
選項集合是輕量級超級高效的方法來表現一組布林值
如果你們以前見過並用過不同的Cocoa API
並且用過See Like句法和Or句法
這類基本句法實際上非常不錯
問題在於當你使用其他句法時就不會是這樣
你用零值生成選項集合...
這不太合理
因爲選項集合和可選類型是完全不同的概念結果卻混爲一談
你從按位操作將之提取出來
這樣非常麻煩而且非常容易出錯你也會很容易犯錯
有了Swift 2我們會採用選項集合
這樣會更糟糕
因爲Swift1.2 是 一類集合類型
上述組合使得選項集合似乎退回到C語言
而事實就是如此
但是Swift 2解決了這個問題它將選項集合變得像集合
這就是說選項集合和集合現在都是帶方括號
也就是說你會獲得帶方括號空集的空集
你也會得到整套標準集合API來與選項集合相配合
這樣做非常容易而且效果極佳
還有一個好處是
你可以用更簡單的方式定義自己的選項集合
你現在只需要定義自己的集合類型
或結構類型集合的結構類型
以符合新的選項集合類型協議
找到存放位數的存儲
定義需要放入選項集合中的元素
只需要簡單進行定義你就可以獲得我們談到的所有句法
這就是相當棒的一點它不需要進行任何編譯器匹配
這可以通過一個新功能
名爲Default Implementations
和選項集合類型提供的Protocols自動實現
我們實在沒時間在這裏詳細介紹
Default Implementations和Protocols
但是我們有一場相當棒的講座詳細介紹協議方面的內容
我們來談談函數和方法
Swift將函數和方法統到單一的函數聲明中
將兩個完全不同的概念放在類型系統中構成一個漂亮的函數核
這樣做非常棒
這個漂亮的函數核就是Swift的關鍵部分
在你想要調用這些內容時就會立刻分解
因爲它們用的是不同的參數標籤
這對很多人來講都相當麻煩
如果我們來看這是從何而來
可以看出Swift是效仿Objective-C的先例
C語言並無參數標籤
參數標籤對Objective-C的方法而言非常重要
Swift也是如此
在Swift 2中我們不僅解決了個問題
現在函數和方法是同樣的聲明句法
它們按照同樣的方式發生作用
當你調用全局函數時你在默認狀態下提供參數標籤
所有內容都是統一的
因此需要了解的關鍵內容是這會影響到純粹的Swift代碼
如果聲明Swift中的全局函數你就會在默認狀態獲得這個行爲
從C語言引入的函數會繼續按照它們一貫的方法行爲
因爲在C語言函數中的參數名稱不是API的組成部分
也不會被當做是API
但是我們希望Swift代碼可以繼續將函數標籤包括在參數中
如果要想要深入瞭解這裏還有更多內容
Swift函數使用參數
參數爲每個值有不同名稱
當你用句法聲明某項內容時
你會獲得默認行爲
參數獲得的兩個名稱一個是調用者看到的外部名稱
一個是執行方看到的內部名稱
在默認狀態下第一個的參數並未向其外部客戶端顯示標籤名稱
你可能會在執行方法時用到
同樣 第二個和之後的參數都是默認爲內外相同
這就是爲何你會看到有該參數的參數標籤
這種模型最棒的一點是當你理解這點就可以對之進行自定義
例如 在本例中可以將標籤
放在第一個參數上這樣你會知道它是什麼
只要重複參數名稱即可實現
這非常簡單
同樣 如果想要刪除某些內容
你可以用下劃線顯性設置該名稱表明要刪除參數標籤
這麼做我們就犯下了最嚴重的命名錯誤
讓布林值沒有標籤
好的!
更好的一點是
發生的整個改變會令標籤在系統中更爲顯著
讓API如此便於使用
而且這會讓我們將複雜簡化很多
現在函數和方法都在同樣發揮作用
我們還可以取消默認函數的特殊規定
這裏還有非常奇怪的句法
誰也不記得它是什麼現在也不見了
這樣就會好得多
我們接着會談到編譯器
談到警告和錯誤消息是編譯器而成的
這裏的代碼是合理代碼
也許你之前寫過類似內容
我要更新一點內容
如果你使用Swift 1編譯器它會生成這個樣子
我不瞭解大家會怎樣這並沒有什麼用
Swift 1.2則要好很多
Swift 1.2會生成錯誤消息並告知我出現了問題
現在我發現無法對之賦值
當然這還不夠好
我們繼續研究編譯器生成的錯誤消息和警告
在Swift 2中 它表示“你不能給x賦值因Self不可變”
Xcode會告知你可以把方法標爲可變 這樣就解決了問題
這是個很棒的方法我覺得很多人...
它會幫助很多人更好地瞭解Swift中的可變性模型
並讓代碼更爲出色
當然這才只是一個實例這樣的例子還有很多
我們還添加了警告的實例
如果你的變量聲明爲常數
我們就會生成警告要使用Let來替代Are
Swift移植工具會在許多情況下用Let替代Are自動移動許多代碼
我們都會警告如果你聲明一個值無論是Let還是Are都不要使用
如果你使用函數方法
然後忽略結果
因爲你可能是想使用變異方法
我們會對所有這些生成警告
還有簡單的實例
我們來談談SDK
這是Swift的核心內容它與Cocoa配合很好
有了Objective-C API
Swift編譯器不清楚指針是否應爲零以及集合的元素類型是什麼
我們引入了若干Objective-C的新功能
包括表達可空性的能力
Objective-C的集合元素類型
有整系列的其他功能
爲Swift的Objective-C代碼提供優質體驗
最棒的一點是
Apple的框架工程師完成一項傑出的工作
他們採用了所有這些現代Objective-C功能
在Swift的各種平臺上Cocoa SDK整體表現都很出色
而你無需做任何工作
不過如果你有Objective-C代碼
也許在你項目中混合並匹配了Objective-C代碼
也許你想在Swift中擁有更美觀的Objective-C框架
今天晚些時候可以看看部分講座內容瞭解更多功能
這樣你就可以提供出色的Swift體驗
你可能需要看看視頻
我們來談談單元測試
在整個工具組測試都是非常重要的
Swift中的測試功能非常不錯
不過訪問控制則不然
問題是Swift要求你將符號Public標爲對單元測試束可見
如果可以測試就不應該公開大量內容
Swift 2和Xcode 7解決了這一問題
現在你的代碼會自動搭建成特殊模式
表示這是測試中
它們默認可以訪問你的公開和內部符號
你必須要用到新的app...
更棒的一點是這不但非常容易 而且...
你仍可以爲發佈構建獲得正確的行爲
這樣可以獲得很好的性能以及訪問控制的保護收益
我們有一系列關於測試的講座
我強力推薦《Xcode的UI測試》
我們來談談富批註
遊樂場非常棒
Xcode可能幫你在編輯器中使用批註句法 富批註句法
搭建漂亮的Swift遊樂場
句法是Markdown中的一個變量
非常不錯 很出名 很流行是很好的句法
我們也可以使用文檔評論
這是說你可以構建漂亮的富文檔評論
並在API上爲客戶顯示
如果你在生成庫你可以做很棒的事情
最後 Xcode的移植工具
在Xcode 7中一打開Swift 1項目
它就會彈出信息
“我可以爲你升級到Swift 2”
這大概需要兩步驟
你可以選擇自己的目標然後它會提供一個dif
Swift 2移植工具實際上非常不錯
這其中包括從Swift 1
轉移到Swift 2的大部分問題和情況
包括錯誤處理模型 從內容到方法的轉移和SDK的改變
及諸多的選項集合改變都搭建在移植工具之中
效果相當不錯
Swift 2中還有相當多的內容 現在我們沒時間一一介紹
如果你們對更多詳情感興趣
建議看看Swift編程語言書籍
已經有新版本推出
Xcode 7版本發佈說明中也詳細介紹了這方面的改變
我們來繼續講模式匹配
大家最初遇到模式匹配也許是在if-let語句中
最好使用可選類型
有條件地打開然後將結果捆綁到安全的名稱上
這非常棒
當然 好東西遠不止這些
我們都曾經見過“金字塔厄運”
是指太多if-let語句堆在一起
突然代碼已經有15層高
你完全搞不懂它
Swift 1.2通過在if語句中引入複合條件解決了這個問題
這會就自然多了
你可以在內聯
查看多個可選類型和布林條件 效果好多了
這並沒有解決提早退出的問題
我給大家看幾個也許是最可怕的JSON處理代碼
隨着時間的推移 情況會改善
我們來看這個
我從無類型JSON字典中取出各種域
我取出名稱轉化爲字符串生成可選類型
如果不匹配 我就要想辦法
同樣 取出年信息轉化爲In
如果不匹配 需要救助
如果取出很多值更常見是最好能採取救助方式
而不是深埋在代碼中這種模式更常見
這種方式的問題在於完成時需要強迫打開可選值
這裏我只使用一次
但是如果你有一組代碼都使用它們你就需要到處都要強迫打開
你需要做些事情來解決
打開可選類型是不錯方法
它將強迫打開放入不安全的Mecca
可能這樣做也不大對也非常難看
我們引入了新的Guard語句
看待Guard的方法就是它要做檢查
若是檢查不匹配就會做救助
你可以用過很多Guard語句
現在我們來做可選檢查
我們將一個值綁在名稱上
它可以發揮作用的方式是
是確保Else退出當前的範圍
可以用兩種方式的一種來完成
返回 拋出 跳出有很多方式可以退出範圍
很好
你還可以調用No Return函數
例如Precondition Fail或Abort
這些都是停止的不錯方法
這還可以確保編譯器瞭解安全性和
和貫穿代碼之後可以看到的確定性
如果把這個用在我們的例子中肯定會邊的更好
因爲我們可以用Guard校對
如我們所願進行安全 簡潔的檢查
還有一點很棒的是
這些都構建在If語句的富複合條件中
現在可以將它們合併在一起
根據Guard語句 檢查多個布林值和可選類型
和我們稍後介紹的其他情況
這相當棒
我們再看看模式匹配更強大更有趣的形式 開關語句
我覺得開關語句也許是許多人喜愛的Swift功能
因爲在開關語句中可以實現許多模式匹配功能
你可以檢查可選類型 
可以做類分層結構檢查可以檢查範圍
在開關語句中可以實現許多功能
當你要寫許多條件語句時這會很棒
但是當你只想檢查一個條件時 
在語句構成方面些笨重
它們只能是表達詳盡你必須承認這很麻煩
我們所做的是將模式匹配和開關 條件結合
將其帶到其他控制語句中
這個實例可以寫成新的If條件 
檢查之後 可以做模式匹配將可變名稱綁到語句中
我們又向前進了一步Swift還有一個出色的語句 循環
在...循環中需要完成一些過濾的情況是很常見的
有些語言甚至需要引入全新的語言結構
例如列出對此類模式的模型理解
通過Swift 2我們完成兩項任務
我們在...語句中添加了簡單的布林值內聯過濾器
但是大家也可以在循環中完成
全面的模式匹配爲你提供強大的條件
關於模式匹配的內容我只能匆匆介紹這些
我們介紹了新的Guard語句非常適合提前退出
講了將模式匹配放到語言各處
我們並未談及其他的改進內容
在你開始使用Swift時就會發現它們
謝謝接下來有請約翰上臺
他會告知大家可用性檢測方面的內容
謝謝 克里斯
我們經常推出新功能
大家可能聽說過Force Touch
Force Touch是硬件功能當然它還有一系列API
正如NSButton中的這個
可以讓我來改變按鈕對拖拽的反應方式
如果我想在自己的app中採用這個功能
將非常簡單 對吧？
我得編寫一些新的事件處理代碼
然後我需要用到按鈕
設置熱加載屬性
問題是這在我的開發設備上效果可能會不錯
但是當我把它移交到測試硬件時
幾乎肯定就會出現崩潰
這是因爲這是個新的API
是在X v10.3中引入
在這種情況下 和大多數人一樣
你仍然會需要支持較早版本的OS
我怎麼解決這個問題呢?
我以前常用的解決辦法是我會讓方法的錯誤信息不存在
我來看看這種方法是否存在
一方面人們開發了許多不同的慣用語法來實現這一點
這是個常見慣用語使用Responds到Selector
問題是這是個容易出錯的模式
例如 我必須指出選擇器是什麼
從部分Swift語言功能做映射
到部分Objective-C選擇器
這些細節沒有必要全部瞭解
要知道編譯器也沒有幫我檢查
因爲我本來也不願檢查編譯器所提供的內容
例如 在本例中我實際上忘記加冒號
意思是說檢查永遠不會爲真
有了Swift 2我們有更好的解決方案
在默認狀態下要確保
不要使用部署目標上最小且不可用的API
如果我做這樣的事情...
如果我做這樣的事情我會經常進行診斷
這樣我可以有某種安全核心假設
只要我的代碼...只要我的項目完全編譯
它至少不會包含這種小的部署問題
當然這還不全是兼容性的問題
但這可以幫你使用新的API
我確實想要用這個怎麼辦呢?
我們添加了新的#available條件
在#available中你可以列出想要測試的OS版本
最後你會用這個星號確定
是否在代碼裏沒有的新OS
你至少要在這裏診斷可用性
我已經用了If語句 
但是我可以使用克里斯剛展示給大家的Guard語句
這是在所有的地方都完全相同的條件邏輯
就是這樣
這是可用性檢測
我們認爲這是
讓你在項目中 自動安全使用新版OS 新功能的不錯方法
稍後 我們會介紹更多詳情我非常建議大家能來聽
接下來 我想談談協議擴展
擴展是Swift一大特色功能
我可以使用任意類型 如Array
並在其中加上我自己的方法
這一點很重要但並不明顯
方法是核心內容
這就是類型原生API表達的方式
當我添加擴展時
我實際添加了感覺像第一類型新功能
正如該類型的設計人員已經加上的API核心類型
這會有很多優勢
這裏我加上了Count If方法
這就會針對間隔的數組
和返回True的次數調用閉包
在這種方法中並沒有具體針對數組
這應該適用於任意集合
不過 在Swift 1我無法用這方法來表達
爲將這個泛型加到任意集合中
我必須要編寫像這個樣子的編碼
正如很多人所指出的那樣這並不絕對優化
首先 這裏有很多額外的句法
在其中所有這些尖角括號中有些盲區 
所有這些額外的外殼構成了這個泛型
其二 這不再是一種方法
因爲首先它不再是方法
它不再像使用該類型的自然部分
第二 它很難被發現
它不會出現在數組的任何功能列表中
特別是它不會出現在功能列表被完成提供的代碼中
這意味着你寫出這麼漂亮的Count If語句 
可是使用它的人都不知道它的存在除非你指出來
好那我們先回來
我們有這個擴展的數組只要把方法加到數組中即可
爲什麼我們不能擴展...我不知道...
執行集合類型的每項內容?
在Swift 2中 我很高興地說你可以
你可以擴展集合類型而不是擴展數組
當你這麼做的時候
你會自動把各處的方法加到執行集合類型的每個類型中
不僅是從標準庫中或是任何內容中
而是就在恰好符合要求的你自己的類型中
這不僅有利於編寫自己的泛型代碼
而且我們發現這可以讓我們修改在Swift 1中不滿意的許多內容
在Swift 1中有很多內容都必須是全局函數
因爲它們必須是泛型或者因爲我們寫成了泛型
更糟糕的是 爲了製作方法我們選擇了特殊條件的部分類型
例如數組有許多這樣的映射和過濾方法
其他類似Set的類型也許不會有
在Swift 2會有這些功能
這類過濾和映射功能會通過擴展表達
這意味着在每個內容上都可用
還會更容易找到
這意味着使用標準庫會更爲統一
我們的確認爲大家會喜歡它
我還沒有介紹到新功能的
複雜度的三分之一
明天我們有場專門介紹這方面內容的精彩講座
我強烈建議大家能來聽
它是關於Swift支持的協議中傑出的新設計模式
講座的其餘部分是關於錯誤處理
我覺得很少有人會喜歡琢磨錯誤處理
如果大家和我一樣的話
思想深處都埋藏着這樣的想法
但它真的很重要
當我們在看可以用Swift做點什麼
使其真正成爲更穩健更具表現力的語言
我們覺得這裏最重要的問題就是要進行錯誤處理
當我們看其他語言Cocoa中的解決方案
我們對這些並不滿意
其中有太多問題我們真的不很喜歡
要知道其中有些是基於自動傳播錯誤
比如Objective-C語言中的NSError
它生成了許多重複性的容易出錯的代碼
最後你不得不到處複製
這意味着很容易出錯
更重要的是當你在自己周圍傳播錯誤時
隱形的默認行爲就是你在忽略錯誤
而這永遠都不是正確的默認狀態
你應該至少考慮一下錯誤
從另外一個角度而言還有些語言可以顯示傳播錯誤
例如異常處理
但是我們也不喜歡這些的效果
很顯然在這方面人們很容易不去考慮這些錯誤 
最後你會掉到坑裏
自己也不知道到底程序裏出現哪些問題
你不明白控制怎樣會從一處流到另一處
而且這樣也不是安全可靠的編程模型
其實函數有三種以不同的方式出現問題
一種是許多函數以非常簡單
而明顯的方式出問題
例如 除非你在運行編譯器
你可能並不在乎爲什麼要分析字符串失敗的整數
這種事情報告給用戶沒什麼意思也不會有趣
也許你想直接處理
以前我們就是這樣看待這個問題的
現在在Swift中它得到了很好的解決
有了可選的結果
我們覺得不需要做任何事情
我們對現在的辦法很是滿意
從另外一個角度而言在你的程序中有許多邏輯問題
比如程序 人員的錯誤索引越界
人們使用NSException的主要方式等等
對於這些問題它們實際上不應該是可恢復的
當你可以恢復這類問題時
就會導致程序整體不太穩定
如果你隨機從越界索引中恢復你不清楚程序的狀態究竟如何
你可能甚至會在應用中產生安全問題
在中間的
是API可能出現錯誤的各種具體情況
這些是我們真正想關注的內容
如今在Cocoa的內容可以使用NSError 
我想給大家舉個例子
這是個預飛方式我有某個操作需要預飛
以確定它是否可以發揮作用
我相信 很多人之前都寫過這樣的內容
我想看看是否部分文檔可以訪問
然後我會重設與操作相關的狀態
現在來看資源是否可訪問
這個操作會發生錯誤
可以出現各種各樣的錯誤
它應該報告一些內容
因爲調用者希望知道爲什麼有些內容不可訪問
也許會根據原因進行不同的處理
如果我想使用NSError
最後代碼就會變成這樣
我會採用這個錯誤在調用者之外進行傳播
就是這種情況
有許多問題我們當真不喜歡
它在我的邏輯中增添了許多模板
我原本是隻有兩行的緊湊函數
結果變成這樣...
要知道其中有If語句額外的嵌套 額外的參數
這裏有很多內容
其目的就是爲了表達有錯誤我們正將它向調用者傳播
更糟糕的是
這裏還有個約定
你需要了解這個約定
根據這個約定你必須手動執行才行
編譯器無法幫到你
事實上我這裏又犯了錯
在這個約定中當你返回False時就會有錯誤發生
我檢查的時候方法也不對
我不知道他們怎麼會信得過我來用編譯器
我需要加上Not才能得到我想要的行爲
好的啊 不好意思
這就是不利因素這也是我們喜歡它的原因
首先 可以通過讀取這個代碼
檢查資源找到出現問題的部分
在名稱上就說得很清楚這就是在說錯誤
這是顯性的錯誤處理內容這是顯性錯誤參數
同樣很明顯地預飛也是很容易出有問題的操作
同樣是顯性錯誤參數 返回值 等等
其三是沒有顯性控制流
我可以看着它並瞭解其中所有的內容
我可以像人類那樣分析而不是像編譯器那樣靜態分析代碼
作爲人類我可以看到這個代碼
分析它在做什麼
而不需要了解每個我在調用的函數細節
好
我們返回這個例子中
它之前是這樣
如果我用Swift編譯會發生什麼情況？
我會受到錯誤消息因爲我沒有處理錯誤
在Swift中有兩個組件可用來處理錯誤
第一個是在你調用API出現問題時必須要用Try關鍵字
Try可以交流
它主要就是便於他人讀取代碼
它與你交流道，“這裏就是會出現問題的部分”
這是說 當你返回時當你以後做維護的時候
我會直接...
Reset State但並不是每次調用都需要這個函數
這裏也許還有很重要的內容需要我知道
當我首先編寫代碼時
這是我需要考慮的問題
Reset State在我每次退出函數時 都需要調用嗎？
對於預飛操作呢？也許這還不夠 
我沒有以任何方式處理造成錯誤
這是因爲在Swift中在默認狀態下 函數不可拋出
這是我們的設計的核心內容 
因爲它意味着錯誤不可避免
你不必考慮所有內容都會像Java或C#語言那樣拋出異常
或是基本上每種語言都在使用異常
相反 它是相當具體的內容
你知道自己需要是否要考慮將之拋出
當你在代碼中調用它們時它會標明Try
這一組合可以交流很多
好的 假設我先要向調用者傳播一個錯誤
爲此 我只需告知編譯器
“可以讓它把錯誤拋出”
我就會拋出
這可能不是我想要處理的方式
這是個預飛方式
我可能想容忍錯誤
告知調用方預飛是否成功
爲此 我只能處理它
我就編寫了Do Catch
在Do中的任何代碼
其中轉發的任何錯誤都會像過濾所一樣被捕獲
在捕獲之後會是什麼
你在開關語句中可以編寫的任何內容
Swift的模式匹配句法最強大之處在於它可以捕獲
作爲非常簡單的常見句法改進
這類捕獲是捕獲的短板
並會帶入這種特殊的錯誤變量
我還可以寫出更精緻的內容
例如 我可以處理某種錯誤
作爲特殊情況也許在我的預飛中可以接受
我不知道爲什麼不存在的文檔可以接受
也許我真想看看它是否存在
出於某些許可原因它會不會真的使用
如果我想
我可以對錯誤代碼和域名直接做像這樣的模式匹配
另外 還有第三種“處理錯誤”的方法
經常會有這種情況
你前提設置了
不應該拋出的具體調用
例如 也許這個文件在我的app束
我知道如果我無法在自己的app束中讀取文件
那就真的有問題了
也許沒有辦法可以恢復
在這個常見模式中
你可能會需要一個致命錯誤因爲錯誤拋出
它有個非常精簡的關聯句法 Try!
這會生成一個斷言
其中Try中的代碼不會真正拋出
如果拋出你的程序就會崩潰
就像是其他斷言錯誤一樣
這類問題可以很容易地調試解決
你不會總是想要用這類內容
但是當你需要它時這非常方便
回來看一下
我捕獲一個錯誤
錯誤是什麼類型？
我們有個協議
搭建成標準庫ErrorType
你可以拋出任何滿足ErrorType類型的值
當你捕獲到問題時
也就是模式匹配的ErrorType任意值
我們覺得重要的是
我們不會只跟蹤是否要拋出的錯誤
這和Java不同 你最後會有一個詳盡的清單
列出可能會拋出的所有異常
然後每次改變錯誤時你可能都會面對這個複雜的傳播問題
跟蹤錯誤是否拋出已經足夠
幾乎一直是如此
我們認爲這是個很好的模型
你可以讓自己的類型符合ErrorType
這個過程要比Cocoa容易得多
枚舉是表達的不錯方法
它們可以很棒地表達一組相關問題
正如它們...
要知道的確如此
因爲在枚舉中可以關聯每個條件的數據
如果我想報告更豐富的錯誤消息
其中包括也許關於...
也許我在查看一些無效狀態
我希望記住無效狀態是什麼
我可以將特例中的相關值直接嵌入枚舉中
爲了讓枚舉作爲錯誤可用 你只需要讓它
符合ErrorType即可
編譯器會自動處理合成的細節
這要勝過處理生成新NSError域名和相關內容
我們認爲當你需要的時候
這將會對大家很有幫助在自己的代碼中表達拋出錯誤API
我們回到克里斯之前介紹的例子中來
這個JSON處理器
我用字符串中的Either返回錯誤
我們讓它看起來更像是Swift中的效果
首先 不是用字符串
我會用剛談過的數據錯誤枚舉
我必須拋出
爲了拋出這些值 我使用新的拋出語句
效果不錯
另一方面是我需要修改返回類型
我不再返回Either類型
對於這類問題每個調用者爲檢查錯誤
不會對返回值認真進行微管理
我做了修改這樣就會返回Person即拋出方式
這樣我就不必在這些小細節上操心
我們再來一個新的例子去除我們剛生成的方法
我們來解析JSON語句我們解析一個人
我們用它來解析涉及此人和一些內容的整個銷售記錄
有時候碰巧你需要知道
這是個人爲的例子
不好意思有時候我需要觀察這類進程
我需要進行某種委託
我需要讓它知道我開始讀取銷售數據
我現在告知它我開始讀取
顯然 我在完成讀取時也應該告知它
我可以把代碼加在下面
問題是我在錯誤處理方面做得不對
很容易會...
如果我的委託在銷售結束時
每次都調用Careful和Variants設置
如果我的委託有變化它希望在兩端調用時都保持
如果我要搞糟進程我把這事兒弄混了
這類問題常常會出現會使得錯誤處理看似很脆弱
好的 當然我可以這樣解決問題
只要在這些拋出站點 Did End Reading Sale加入調用
隨後我仍沒有處理調用Process Person
爲了做點什麼我必須把它加入Do Catch
這相當...相當繁瑣
但是它的確容易出錯
因爲很容易讓我增添新的代碼 新的處理方式
如果我當真做什麼的話它就會立刻過期
如果我忘記添加
Did End Reading Sale到這個特殊路徑
Swift 2有着更好的選項
叫做Defer
Defer語句生成一個動作
當你執行時
無論當前的範圍是什麼動作都會 得以執行
如果我返回如果我出現問題
如果我拋出錯誤無論怎樣
我都知道它會得到執行
這意味着當有人讀取代碼
維護代碼時 
我會絕對有信心
無論我怎樣結束讀取銷售數據
Did End Reading Sale都會執行
這是需要掌握的重要內容
我簡要介紹一下執行情況
如果有誰習慣進行異常處理也許會知道
在許多語言中 異常處理的執行方式
會非常受到被拋出的錯誤的影響
拋出錯誤的函數返回
也許會比按照正常方式
返回慢3個 甚至4個數量級
出於語言設計的某些方面的需要
我們並非是想在Swift中模仿什麼
大家在這裏只需要知道
Swift執行得更爲平衡
基本上更像是調用者的If語句
這是說並非完全自由地調用可拋出錯誤的內容 
但是這意味着你不必擔心
我們的錯誤處理功能造價太高
如果出於實際情況中
對錯誤路徑 效率的考慮有些具體原因會令你無法使用它
最後 我要說一下Swift
Swift的錯誤處理設計在Cocoa API中可以發揮作用
我們自動識別你在Cocoa中見到的最常用約定
例如具備NSError Out參數的方法
並將返回Bool值
自動變爲拋出方法
Bool的返回值也會返回
同樣地
如果它返回可選結果
我們會將模式識別爲零值表明是無效內容
因爲是零值
它就不會再返回包括在錯誤處理之內可選結果
有着這兩條非常簡單的規則
我們發現系統的大部分API都會輸入
並自動無縫完美配合這些新的Swift錯誤處理模型
我認爲這是在Swift中處理錯誤的偉大新方式
我強烈推薦大家去看看
你可能沒有太多選擇
它們到處都是
要知道我們對這個設計非常自豪
我們認爲這將極大改善編碼的穩健性和表達性
讓你可以設計出非常不錯的API
我來總結一下
我們一直在Swift 2方面投入大量精力
爲大家提供新的語言
通過Swift中的工具
推出Swift的編程的核心方面
爲大家提供更安全更穩健的環境
整體提高產品水平
整個過程中對我們而言 最珍貴的工具
就是大家的反饋
我們非常非常重視這些
我承諾一定會聽取意見
如果你要告訴我們什麼
當然 大家可以僅使用錯誤報告工具即可實現這一點
但是大家也可以聯繫斯蒂凡·萊瑟來開發人員論壇
我們大部分人始終都會在那裏待着
我們非常樂於對任何問題進行答覆
想聽到大家的反饋
我們非常非常重視你們
非常感謝
希望大家喜歡WWDC 2015