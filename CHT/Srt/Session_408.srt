00:00:20.120 --> 00:00:25.392 
面向協議 編程序Swift

00:00:34.234 --> 00:00:39.473 
大家好 我叫戴夫·亞伯拉罕
我是Swift標準庫的技術主管

00:00:39.540 --> 00:00:44.144 
今天站在這裏同你們一起是我的榮幸

00:00:44.678 --> 00:00:46.113 
很高興看到房間裏的你們

00:00:47.548 --> 00:00:49.283 
接下來的40分鐘請

00:00:49.983 --> 00:00:53.320 
丟掉你們通常思考編程的方式

00:00:55.122 --> 00:00:58.659 
我們接下來要一起做的事情不一定容易

00:00:58.725 --> 00:01:02.162 
但我向你們保證如果你們跟着
我的思路這一定是值得的

00:01:04.331 --> 00:01:06.400 
我現在來和你們談一談

00:01:06.733 --> 00:01:11.705 
Swift設計核心的主題
並介紹一種編程方式

00:01:11.905 --> 00:01:13.607 
這種編程方式有可能改變一切

00:01:15.075 --> 00:01:17.845 
但首先請允許我先向你們
介紹我的一位朋友

00:01:20.581 --> 00:01:21.748 
他是 Crusty

00:01:23.483 --> 00:01:26.286 
現在可能你們每個人
都正在使用這個傢伙的某一個版本

00:01:26.453 --> 00:01:29.256 
Crusty是個老式的程序員

00:01:29.723 --> 00:01:34.761 
他不相信調試器不使用集成開發環境

00:01:35.028 --> 00:01:37.564 
不 他喜歡 80x24的終端窗口

00:01:37.631 --> 00:01:39.366 
和純文本 非常感謝

00:01:42.736 --> 00:01:45.506 
他對最近的編程時尚不以爲然

00:01:46.773 --> 00:01:49.309 
現在我已經學會期待 Crusty 

00:01:49.376 --> 00:01:51.979 
有點憤世嫉俗脾氣古怪

00:01:52.446 --> 00:01:55.382 
但是即便如此有時仍會令我驚訝

00:01:55.883 --> 00:01:59.253 
比如上個月我們正在討論應用開發

00:01:59.753 --> 00:02:03.090 
他坦率地說“我不做面向對象”

00:02:05.158 --> 00:02:06.627 
我不敢相信我的耳朵

00:02:07.060 --> 00:02:09.830 
我的意思是面向對象程序設計

00:02:09.896 --> 00:02:11.298 
大約起源於20世紀70年代

00:02:11.865 --> 00:02:15.269 
所以它並不能算是新奇的編程時尚

00:02:15.769 --> 00:02:22.242 
此外我們一起構建的
很多神奇的東西 我 你 還有那些

00:02:22.876 --> 00:02:26.947 
我們所站在其肩膀上的工程師們
都由對象構建而成

00:02:28.949 --> 00:02:31.952 
“來吧”我邊走向他的老式黑板邊說

00:02:32.286 --> 00:02:35.489 
“面向對象程序設計棒極了
看看你可以使用類做些什麼”

00:02:41.161 --> 00:02:41.995 
是的

00:02:43.697 --> 00:02:47.234 
所以首先你可以把
相關數據和操作進行分組

00:02:48.202 --> 00:02:53.207 
然後就可以建造牆壁將我們的代碼內外

00:02:53.607 --> 00:02:56.076 
分開這樣就可以使我們保持不變量

00:02:58.879 --> 00:03:05.118 
然後我們使用類來
表達相關想法如窗口或通信信道

00:03:07.988 --> 00:03:12.326 
它們給我們一個命名空間用於幫助
避免隨着軟件擴展所帶來的衝突

00:03:15.796 --> 00:03:18.031 
它們有驚人的表達語法

00:03:18.332 --> 00:03:22.769 
所以我們可以寫方法調用和屬性
並把它們鏈接起來

00:03:23.003 --> 00:03:24.304 
我們可以做下標

00:03:25.339 --> 00:03:27.741 
我們甚至可以做屬性用於計算

00:03:30.244 --> 00:03:32.946 
最後類的擴展性是開放的

00:03:33.280 --> 00:03:36.149 
所以如果類作者遺漏了
一些我需要用到的東西

00:03:36.483 --> 00:03:38.085 
我可以繼續向前並在後續將其添加上

00:03:39.019 --> 00:03:41.588 
此外這些事物一起

00:03:42.990 --> 00:03:44.725 
這些事物使我們能夠管理複雜的事物

00:03:45.392 --> 00:03:47.561 
而這正是程序設計中最主要的挑戰

00:03:49.496 --> 00:03:54.301 
這些屬性它們直接解決了
我們正在努力解決的軟件開發中的問題

00:03:55.702 --> 00:03:57.838 
在這一點上我自己頗受啓發

00:03:58.172 --> 00:04:02.409 
然而 Crusty
只是哼了一聲嘆了口氣

00:04:05.812 --> 00:04:07.214 
他讓我十分泄氣

00:04:09.516 --> 00:04:12.753 
如果這還不夠糟糕的話
片刻之後他完成了這個句子

00:04:15.389 --> 00:04:17.357 
因爲這是真的在Swift

00:04:17.891 --> 00:04:21.195 
任何一種你可以說出的
類型都是一等公民

00:04:21.562 --> 00:04:24.898 
它能夠利用所有這些功能

00:04:26.800 --> 00:04:28.335 
所以我後退了一步並試圖

00:04:29.002 --> 00:04:34.875 
找出使我們完成的所有事情運行的
核心功能在面向對象程序設計中

00:04:36.777 --> 00:04:42.382 
很顯然它一定是來自於只能用
類來處理的某些事物

00:04:42.716 --> 00:04:44.084 
比如繼承

00:04:46.253 --> 00:04:48.021 
這讓我特別考慮

00:04:48.088 --> 00:04:51.491 
這些結構是如何做到代碼共享

00:04:51.825 --> 00:04:53.393 
及細密定製的

00:04:54.761 --> 00:04:58.565 
因此，舉個例子一個超類可以定義
一個實質的具有複雜邏輯的方法

00:04:58.632 --> 00:05:03.470 
而子類無償得到超類已完成的所有工作

00:05:04.938 --> 00:05:06.039 
它們只是繼承了這些內容

00:05:07.207 --> 00:05:10.911 
但真正不可思議的事
發生在當超類的作者

00:05:10.978 --> 00:05:12.980 
把這個操作的一小部分斷爲

00:05:13.413 --> 00:05:15.282 
獨立的定製點

00:05:17.651 --> 00:05:18.952 
這些定製點可被子類覆蓋

00:05:20.087 --> 00:05:23.690 
且這種定製被覆蓋在繼承的實現上

00:05:25.559 --> 00:05:27.060 
這使得困難的邏輯

00:05:27.127 --> 00:05:31.798 
在具備開放的靈活性
和特殊變化的同時可被重新使用

00:05:32.099 --> 00:05:33.800 
現在我確信我可以說服他

00:05:34.401 --> 00:05:35.936 
“哈”我對 Crusty 說

00:05:36.170 --> 00:05:39.673 
“很顯然現在你不得不
臣服於類的力量了”

00:05:42.976 --> 00:05:45.412 
“再堅持該死的一分鐘”他回答說

00:05:46.180 --> 00:05:50.350 
“首先我用你一直說的結構做定製

00:05:51.084 --> 00:05:55.055 
其次 對 類是很厲害
但讓我們來談一談用類所需要的代價

00:06:00.427 --> 00:06:04.565 
我已經有三個重要的
關於類的牢騷”Crusty 說

00:06:05.632 --> 00:06:07.367 
然後他從列表上開始了抱怨

00:06:08.769 --> 00:06:10.537 
“首先你有了你的自動共享”

00:06:11.638 --> 00:06:13.106 
現在你們都知道這是什麼樣子的

00:06:14.174 --> 00:06:18.178 
A傳遞給B一些看起來完全清晰的數據

00:06:20.013 --> 00:06:21.882 
然後B想“好 會話結束”

00:06:22.983 --> 00:06:25.886 
但現在我們有一種情形

00:06:26.286 --> 00:06:32.359 
A和B都有他們自己非常合理的世界觀
而這恰好是錯誤的

00:06:33.994 --> 00:06:39.466 
因爲現實是這樣的 最終A厭惡了

00:06:39.533 --> 00:06:42.069 
嚴肅的數據取而代之喜歡小馬

00:06:42.936 --> 00:06:44.137 
誰不喜歡一匹好的小馬？

00:06:46.440 --> 00:06:50.911 
一切都很好直到B之後發現了這些數據

00:06:51.044 --> 00:06:53.113 
很久之後她從A那裏得到

00:06:54.014 --> 00:06:55.415 
且已有一個令人吃驚的變化

00:06:57.284 --> 00:06:59.353 
B 想要的是她的數據
而不是 A 的小馬

00:07:01.054 --> 00:07:03.824 
好 Crusty 激昂地講着
這是如何結束的

00:07:06.460 --> 00:07:09.296 
“首先”他說“你開始瘋狂地複製一切

00:07:09.363 --> 00:07:10.864 
鎮壓你代碼中的錯誤

00:07:11.131 --> 00:07:12.833 
但現在你現在做了太多的副本

00:07:13.300 --> 00:07:14.701 
而這拖慢了代碼的運行速度

00:07:15.068 --> 00:07:17.571 
然後有一天你正在處理
某個調度隊列中的事情

00:07:17.838 --> 00:07:19.873 
突然你進入了一種紊亂狀態下

00:07:20.107 --> 00:07:21.975 
因爲線程正在共享可變狀態

00:07:22.442 --> 00:07:25.312 
所以你開始添加鎖以保護不變量

00:07:26.180 --> 00:07:28.382 
但是這些鎖更加拖延了代碼的運行速度

00:07:28.682 --> 00:07:30.083 
甚至可能導致死鎖

00:07:30.350 --> 00:07:32.286 
所有的這些都在增加複雜度

00:07:32.586 --> 00:07:36.290 
其結果可總結爲一個詞 故障”

00:07:39.259 --> 00:07:41.595 
不過這些對於Cocoa的
程序員來說都不是新聞

00:07:50.304 --> 00:07:54.041 
這不是新聞這些年我們已經
在應用一種語言特徵的組合

00:07:54.107 --> 00:07:56.910 
像@property(copy)和編碼約定

00:07:56.977 --> 00:07:58.879 
來解決這個問題

00:08:01.114 --> 00:08:02.216 
而我們仍然被咬

00:08:03.183 --> 00:08:04.418 
舉個例子

00:08:05.118 --> 00:08:07.321 
在Cocoa文件中有這樣一個警告

00:08:07.521 --> 00:08:10.791 
關於修改一個可變集合
在你通過它進行迭代時

00:08:12.092 --> 00:08:16.330 
對吧 所有這些都是由

00:08:16.430 --> 00:08:19.600 
從類中繼承的可變狀態的
隱式共享導致的

00:08:21.468 --> 00:08:23.470 
但這並不適用於Swift

00:08:25.272 --> 00:08:30.878 
爲什麼不適用呢？
這是因爲Swift集合都是數值類型

00:08:31.512 --> 00:08:32.679 
所以你正在迭代的這些

00:08:32.746 --> 00:08:34.481 
和你正在修改的這些是截然不同的

00:08:36.616 --> 00:08:39.385 
好 Crusty 列表上的第二條

00:08:40.554 --> 00:08:42.222 
類繼承太具有侵入性

00:08:44.157 --> 00:08:48.795 
首先 它太龐大你有且僅有一個超類

00:08:49.897 --> 00:08:52.232 
那麼假使你需要塑造
多個抽象將會怎樣？

00:08:52.699 --> 00:08:56.103 
可以是一個集合並序列化嗎？

00:08:57.137 --> 00:08:59.973 
當然 除非集合和序列化是類

00:09:01.508 --> 00:09:04.211 
因爲類繼承是單繼承

00:09:04.745 --> 00:09:08.715 
類變得臃腫隨着所有
相關的事情被放在一起

00:09:09.349 --> 00:09:14.922 
你也不得不選擇超類在你定義類時
而非在後續某些擴展時

00:09:16.790 --> 00:09:20.027 
其次如果超類存儲了屬性

00:09:22.596 --> 00:09:23.463 
你必須接受它們

00:09:24.531 --> 00:09:25.399 
並且別無選擇

00:09:26.733 --> 00:09:29.736 
然後因爲它存儲了屬性

00:09:30.337 --> 00:09:31.271 
你必須將其初始化

00:09:32.506 --> 00:09:36.009 
然後就像 Crusty 所說
“指定便利是必須的 噢天哪”

00:09:37.578 --> 00:09:39.713 
因此你又必須確信你理解如何

00:09:39.780 --> 00:09:43.383 
與超類相互作用而不破壞它的常量

00:09:44.218 --> 00:09:48.856 
對嗎 最後對於類作者來說這很自然

00:09:49.523 --> 00:09:53.627 
寫代碼就好像他們知道他們的方法

00:09:54.862 --> 00:10:00.501 
將會做些什麼 不用對
方法可能被覆蓋負責任

00:10:02.402 --> 00:10:06.573 
因此經常有至關緊要卻有不成文的約定

00:10:06.874 --> 00:10:08.709 
關於哪些實際是允許

00:10:08.775 --> 00:10:13.480 
覆蓋的以及比如你是否需要
鏈接到超類方法

00:10:13.747 --> 00:10:16.016 
如果你要鏈接到超類方法

00:10:16.316 --> 00:10:19.019 
那麼位置是在方法的開頭還是在結尾
抑或是在中間的某處呢

00:10:23.624 --> 00:10:26.693 
所以，再一次對於Cocoa的
程序設計員來說仍然不是新聞 對嗎

00:10:26.994 --> 00:10:30.464 
這就是爲什麼我們到處使用
委託模式在Cocoa

00:10:33.033 --> 00:10:35.335 
好 Crusty 列表上的最後一條

00:10:36.803 --> 00:10:42.776 
類被證明完全不適合於
類型關係很重要的問題

00:10:44.611 --> 00:10:46.880 
所以如果你曾經嘗試過使用類

00:10:47.214 --> 00:10:51.752 
來表達一個對稱操作
比如比較你知道我的意思

00:10:53.020 --> 00:10:56.857 
舉個例子假設你打算寫通用分類

00:10:56.924 --> 00:11:00.327 
或二進位檢索類似這樣
你需要一種方法來比較兩個元素

00:11:00.928 --> 00:11:03.664 
使用類你最終得到像這樣的一些結果

00:11:05.566 --> 00:11:08.602 
當然你不能用這種
方法只寫Ordered

00:11:08.969 --> 00:11:11.371 
因爲Swift會預先要求方法體

00:11:13.707 --> 00:11:14.908 
那麼我們可以放些什麼呢？

00:11:16.143 --> 00:11:20.347 
請記得我們對於Ordered
的任意示例還一無所知

00:11:21.715 --> 00:11:24.318 
所以如果這個方法沒有由子類實現

00:11:25.352 --> 00:11:27.688 
那麼除了陷阱我們什麼都做不了

00:11:29.857 --> 00:11:33.493 
現在這是表明我們可以
對抗類型系統的第一個跡象

00:11:35.095 --> 00:11:36.463 
如果我們沒有認識到這一點

00:11:36.930 --> 00:11:38.932 
這也是我們欺騙自己的開始

00:11:40.734 --> 00:11:43.136 
因爲我們對這個問題置之不理告訴自己

00:11:43.203 --> 00:11:45.038 
只要每個Ordered子類

00:11:45.105 --> 00:11:47.307 
預先執行一切都會好的

00:11:48.809 --> 00:11:51.445 
對嗎？讓它成爲子類的問題

00:11:52.779 --> 00:11:55.883 
如此我們繼續進行
執行Ordered的一個例子

00:11:57.951 --> 00:11:59.019 
所以這就是子類

00:11:59.386 --> 00:12:01.121 
它得到一個雙精度類型值

00:12:01.455 --> 00:12:04.925 
我們覆蓋優先來做比較

00:12:06.927 --> 00:12:08.529 
當然除去它不起作用的情況

00:12:11.231 --> 00:12:14.067 
看“其它”只是某些任意的
Ordered

00:12:14.434 --> 00:12:16.970 
不是一個數字因此我們不知道

00:12:17.037 --> 00:12:19.806 
“其他”有數值屬性

00:12:20.440 --> 00:12:22.543 
事實上它可能是個標籤

00:12:23.143 --> 00:12:24.311 
具有文本屬性

00:12:26.013 --> 00:12:28.215 
所以現在我們需要向
下轉型以得到正確的類型

00:12:30.984 --> 00:12:34.121 
但是等一下假設“其它”
結果是一個標籤？

00:12:35.989 --> 00:12:36.990 
現在我們將要陷阱

00:12:39.059 --> 00:12:42.930 
對嗎 所以這聽起來很像

00:12:43.030 --> 00:12:47.267 
我們在預先寫方法體時
遇到的問題在超類中

00:12:49.937 --> 00:12:52.272 
並且我們現在沒有比之前更好的答案

00:12:53.674 --> 00:12:55.242 
這是靜態類型安全漏洞

00:12:56.643 --> 00:12:57.878 
它爲什麼會發生？

00:12:58.745 --> 00:13:02.282 
這是因爲類不讓我們表達
這種至關緊要的類型關係

00:13:02.349 --> 00:13:05.853 
自身的類型和其他的類型之間的關係

00:13:07.688 --> 00:13:09.590 
事實上你可以把這個用作
“代碼異味”

00:13:10.591 --> 00:13:13.794 
所以任何時候你在
代碼中看到強制的向下轉型

00:13:14.561 --> 00:13:17.998 
這很好地象徵了有些重要的
類型關係已經丟失

00:13:18.632 --> 00:13:21.535 
而這通常是由於抽象類的使用所造成的

00:13:23.904 --> 00:13:28.675 
好 顯然我們需要的是更好的抽象機制

00:13:30.711 --> 00:13:33.614 
不強制我們接受隱式共享

00:13:34.147 --> 00:13:35.983 
不丟失類型關係

00:13:36.750 --> 00:13:39.586 
不強制我們只選擇一種抽象且

00:13:39.653 --> 00:13:41.321 
在定義類型時進行選擇

00:13:42.456 --> 00:13:45.626 
不強制我們接受不想要的實例數據

00:13:46.193 --> 00:13:48.862 
以及相關的初始化複雜度

00:13:51.398 --> 00:13:55.335 
最後不會留下模棱兩可
關於需要覆蓋什麼

00:13:57.304 --> 00:13:58.705 
當然我正在講述的便是協議

00:13:59.940 --> 00:14:03.544 
協議有所有這些優勢這就是爲什麼

00:14:03.777 --> 00:14:07.981 
我們創造Swift時也就是我們創造
第一個面向協議的程序設計語言

00:14:17.791 --> 00:14:21.195 
是的 Swift是很棒的
面向對象程序設計

00:14:21.762 --> 00:14:25.399 
但從循環和字符串的工作方式

00:14:25.799 --> 00:14:28.502 
到泛型標準庫的重點

00:14:28.936 --> 00:14:31.238 
其核心Swift是面向協議的

00:14:33.040 --> 00:14:34.608 
希望到你離開時

00:14:35.042 --> 00:14:36.977 
你可以更加面向協議

00:14:40.447 --> 00:14:42.182 
所以爲使你邁出右腳開始

00:14:42.616 --> 00:14:43.917 
我們在Swift有一種說法

00:14:44.451 --> 00:14:45.552 
不要從類開始

00:14:46.086 --> 00:14:47.254 
而要從協議開始

00:14:48.856 --> 00:14:50.424 
那麼讓我們來做一下上一個例子

00:14:53.393 --> 00:14:58.165 
好 首先我們需要一個協議
Swift馬上會說

00:14:58.332 --> 00:15:00.200 
我們不可以在這兒放方法體

00:15:01.468 --> 00:15:03.437 
而這實際上是很好的因爲這意味着

00:15:03.504 --> 00:15:07.541 
我們要以動態運行時間檢查換

00:15:08.041 --> 00:15:09.076 
靜態檢查

00:15:10.577 --> 00:15:12.412 
對 在完成時預先執行

00:15:15.282 --> 00:15:20.487 
好 接下來它會說我們
沒有覆蓋任何東西

00:15:21.388 --> 00:15:22.222 
當然我們沒有

00:15:22.689 --> 00:15:24.558 
我們不再有基類 對嗎

00:15:24.658 --> 00:15:26.059 
沒有超類 沒有覆蓋

00:15:27.461 --> 00:15:29.696 
我們可能根本不希望數字首先是類

00:15:29.763 --> 00:15:31.832 
因爲我們希望它像數字一樣操作

00:15:32.699 --> 00:15:37.571 
對嗎 那麼讓我們馬上來做
兩件事情把這做成一個結構

00:15:39.940 --> 00:15:43.043 
好 我想在這兒暫停一下

00:15:43.110 --> 00:15:46.046 
欣賞一下我們現在來到何處
因爲這又是完全有效的代碼了

00:15:48.081 --> 00:15:51.051 
好 協議正完全扮演着相同的角色

00:15:51.585 --> 00:15:55.556 
就像在我們這個例子的
第一個版本中類的角色一樣

00:15:56.223 --> 00:15:57.491 
這絕對更好

00:15:57.658 --> 00:16:00.294 
我的意思是我們不再有那致命的錯誤

00:16:01.328 --> 00:16:04.164 
但是我們沒有定位潛在的
靜態類型安全漏洞

00:16:04.798 --> 00:16:07.100 
因爲我們仍然需要強制的向下轉型

00:16:07.601 --> 00:16:10.838 
因爲“其他”仍然是
某些任意的Ordered

00:16:12.606 --> 00:16:16.643 
那麼讓我們用數字替代丟掉類型轉換

00:16:19.346 --> 00:16:22.416 
現在Swift要說簽名不匹配

00:16:25.452 --> 00:16:30.324 
爲解決這個問題 我們需要在協議簽名
中用Self來替代Ordered

00:16:33.126 --> 00:16:34.661 
我們稱之爲Self要求

00:16:35.729 --> 00:16:39.132 
因此當你在協議中看到Self

00:16:39.433 --> 00:16:42.736 
它是類型的佔位符用來符合
那個協議模型類型

00:16:45.005 --> 00:16:46.573 
如此現在我們又有了有效的代碼了

00:16:47.641 --> 00:16:49.843 
現在讓我們看一下如何使用協議

00:16:53.580 --> 00:16:57.584 
所以這是二進位檢索

00:16:58.919 --> 00:17:03.223 
它也能夠完美運行在我們向
Ordered加入Self要求之前

00:17:04.724 --> 00:17:08.795 
這裏的Ordered數組是一個聲明

00:17:10.163 --> 00:17:14.268 
聲明我們要處理
Ordered類型的異構數組

00:17:14.734 --> 00:17:18.638 
因此這個數組可以混合包含數字

00:17:19.138 --> 00:17:21.141 
與標籤 對吧

00:17:23.010 --> 00:17:26.146 
由於我們對
Ordered做了這個改變

00:17:26.213 --> 00:17:28.482 
向其添加了Self需求編譯器將

00:17:28.549 --> 00:17:33.754 
強制將其變爲同構的 像這樣

00:17:35.923 --> 00:17:41.662 
這個人說“我在使用任意一個
Ordered類型T的同構數組”

00:17:43.864 --> 00:17:45.666 
現在你可能會想強制使數組

00:17:45.732 --> 00:17:48.702 
成爲同構數組這太限制了 

00:17:48.769 --> 00:17:51.939 
或者有些失去了泛函性或靈活性或其他

00:17:52.339 --> 00:17:53.407 
但是如果你想一下

00:17:54.041 --> 00:17:56.310 
原始的簽名真的是個謊言

00:17:56.910 --> 00:18:00.981 
我們從沒真正處理過異構情況
除了通過陷阱的方式

00:18:01.515 --> 00:18:05.485 
對吧 同構數組正是我們要的

00:18:08.589 --> 00:18:11.725 
那麼一旦你在協議中添加Self要求

00:18:12.192 --> 00:18:15.462 
這將使協議進入一個非常不同的世界

00:18:16.230 --> 00:18:21.134 
在這裏功能中大大減少了類的重複

00:18:22.703 --> 00:18:24.638 
它不再作爲類型使用

00:18:26.073 --> 00:18:30.444 
集合從異構變爲同構

00:18:32.012 --> 00:18:37.951 
實例之間的相互作用不再意味着
所有模型類型之間的相互作用

00:18:40.020 --> 00:18:43.323 
我們以動多態換靜多態

00:18:43.891 --> 00:18:47.060 
但是作爲我們傳遞給
編譯器的額外的類型信息的回報

00:18:47.127 --> 00:18:49.029 
這樣更具可優化性

00:18:50.697 --> 00:18:52.165 
所以 兩個世界

00:18:54.101 --> 00:18:56.236 
在後續的演講中我將向你們演示如何

00:18:56.303 --> 00:18:58.272 
在兩者之間搭橋至少一種方式

00:18:59.606 --> 00:19:01.074 
好

00:19:02.442 --> 00:19:07.247 
我理解了協議靜態方面的工作原理

00:19:07.314 --> 00:19:11.585 
但我還不確定是否
要相信Crusty

00:19:11.652 --> 00:19:14.421 
協議真的可以取代類

00:19:14.855 --> 00:19:18.492 
所以我給他設了一個挑戰

00:19:19.092 --> 00:19:22.496 
構建我們通常使用面向
對象程序設計的事物但是要用協議

00:19:24.965 --> 00:19:26.567 
我腦海中浮現一個小的圖表應用

00:19:26.834 --> 00:19:31.772 
你可以在繪圖界面拖拽落成形狀
然後可以與它們交互

00:19:32.806 --> 00:19:36.310 
所以我讓 Crusty 
構建文檔並顯示模型

00:19:37.344 --> 00:19:38.345 
這是他想出來的

00:19:41.281 --> 00:19:43.016 
首先他構建了一些基本繪圖

00:19:43.650 --> 00:19:44.852 
現在你可以想象

00:19:44.918 --> 00:19:46.620 
Crusty並不是在做圖形用戶界面

00:19:46.920 --> 00:19:47.988 
相較而言他更傾向文本

00:19:48.989 --> 00:19:52.626 
他的基本繪圖只是
輸出了你提出的繪圖命令 對嗎？

00:19:53.126 --> 00:19:56.330 
我不情願地承認了這很可能足以

00:19:56.396 --> 00:20:01.435 
證明他的觀點
然後他新建了Drawable協議

00:20:01.835 --> 00:20:05.873 
爲我們的所有繪圖元素提供通用接口

00:20:06.840 --> 00:20:08.242 
好 這很簡單了

00:20:09.610 --> 00:20:12.279 
然後他開始創建形狀比如多邊形

00:20:14.114 --> 00:20:17.484 
現在這裏需要注意的第一件事
關於多邊形這是一個數值類型

00:20:18.218 --> 00:20:19.786 
由其他數值類型創建而成

00:20:20.487 --> 00:20:23.056 
這是一個包含多點數組的結構

00:20:24.191 --> 00:20:27.761 
爲了畫一個多邊形
我們來到最後一個拐角

00:20:28.195 --> 00:20:30.931 
然後我們在所有交角處重複循環 畫線

00:20:32.966 --> 00:20:33.834 
好 下面是圓

00:20:35.335 --> 00:20:38.639 
同樣的圓也是一個數值類型
由其他數值類型創建而成

00:20:38.705 --> 00:20:42.042 
它是包含中心和半徑的結構

00:20:43.310 --> 00:20:46.513 
現在爲了畫一個圓

00:20:46.613 --> 00:20:48.215 
我們從0到2π弧度拽出一個弧形

00:20:51.818 --> 00:20:55.822 
那麼現在我們就可以
通過圓和多邊形來創建圖表了

00:20:59.092 --> 00:21:01.361 
“好的” Crusty 說
“我們來將她做個旋轉”

00:21:05.365 --> 00:21:06.200 
他這麼做了

00:21:07.568 --> 00:21:08.402 
接下來就是圖表

00:21:10.003 --> 00:21:13.207 
圖表就是一個Drawable類
這是另一個數值類型

00:21:14.241 --> 00:21:17.044 
它爲什麼是數值類型呢？這是因爲所有
Drawable類都是數值類型

00:21:17.110 --> 00:21:19.479 
因此Drawable類的
數組也是數值類型

00:21:19.680 --> 00:21:20.848 
讓我們回到之前的話題

00:21:26.486 --> 00:21:27.354 
好 這裏

00:21:28.422 --> 00:21:34.995 
因此由於這是我的圖表中唯一的事物
這個圖表也是數值類型

00:21:36.663 --> 00:21:38.899 
因此要繪製它我們只需要遍歷所有

00:21:38.966 --> 00:21:41.969 
元素並畫下來每一個元素

00:21:43.737 --> 00:21:45.639 
好 現在來作一個旋轉

00:21:47.040 --> 00:21:48.175 
那麼 我們要測試一下

00:21:52.646 --> 00:21:54.948 
所以Crusty新建了一個圓

00:21:55.015 --> 00:21:58.652 
以非常特別的中心和半徑

00:21:59.086 --> 00:22:02.389 
然後以神祕的Spock一般的精度

00:22:02.923 --> 00:22:03.891 
他添加了一個三角形

00:22:05.092 --> 00:22:09.263 
最後他在其周圍創建了
一個圖表並讓它繪製

00:22:13.133 --> 00:22:14.801 
“瞧”Crusty 耀武揚威地說

00:22:15.135 --> 00:22:20.674 
“就像你能明白地看到的
這是一個帶圓的等邊三角形內切於圓”

00:22:21.808 --> 00:22:25.612 
也許我不擅長在腦海中做三角學問題

00:22:25.679 --> 00:22:29.449 
不像 Crusty 那樣
但是“不 Crusty ”我說

00:22:29.516 --> 00:22:30.984 
“我不能很明白地看到這些

00:22:31.385 --> 00:22:33.487 
我會覺得這個延時更加有趣

00:22:33.554 --> 00:22:35.689 
如果我做一些實際有用的

00:22:35.889 --> 00:22:38.592 
比如給我們的應用 畫到屏幕上”

00:22:40.460 --> 00:22:41.995 
我從煩惱中恢復過來之後

00:22:42.429 --> 00:22:46.266 
我決定使用
CoreGraphics重寫渲染器

00:22:49.970 --> 00:22:51.371 
我告訴他我將要做這些

00:22:51.705 --> 00:22:54.208 
他說“再等一會兒猴小子

00:22:55.676 --> 00:22:58.078 
如果你這樣做了
我還怎樣測試我代碼呢？”

00:23:01.348 --> 00:23:04.051 
然後他展現了一個很有說服力的案例

00:23:04.117 --> 00:23:06.286 
在測試中使用純文本

00:23:06.720 --> 00:23:09.723 
如果我們正在做的
事情中發生了某些改變

00:23:10.190 --> 00:23:12.726 
我們可以立馬在輸出中看到

00:23:14.127 --> 00:23:16.129 
然而他提出我們做一點

00:23:16.330 --> 00:23:17.631 
面向協議的程序設計

00:23:19.533 --> 00:23:23.136 
然後他複製了他的
渲染器然後將其寫入協議中

00:23:28.942 --> 00:23:32.613 
然後你必須刪除主體 好

00:23:33.080 --> 00:23:37.918 
這就是了 然後他重命名了
原始的渲染器並將它改爲一致

00:23:41.455 --> 00:23:43.924 
現在 所有的代碼重構使得
我變得不耐煩

00:23:43.991 --> 00:23:46.560 
因爲我很想在屏幕上看到這些東西

00:23:47.861 --> 00:23:50.998 
我想搶過來實現
CoreGraphics的渲染器

00:23:51.765 --> 00:23:54.601 
但我必須等到
Crusty 再次測試他的代碼

00:23:56.069 --> 00:23:58.172 
等到他終於滿意了他說“好了

00:23:59.640 --> 00:24:01.141 
你打算在渲染器中放些什麼呢？”

00:24:02.809 --> 00:24:04.778 
我說“一個CGContext

00:24:05.212 --> 00:24:08.649 
CGContext
基本有渲染器需要的一切”

00:24:09.816 --> 00:24:13.020 
實際上在純C語言接口範圍內

00:24:13.587 --> 00:24:14.755 
它基本就是一個渲染器

00:24:16.690 --> 00:24:18.659 
“好” Crusty 說
“把鍵盤給我”

00:24:18.859 --> 00:24:20.794 
他從我這兒奪去某樣東西然後

00:24:20.861 --> 00:24:23.730 
極快地做了某些事情
太快以至於我都沒有看到做了些什麼

00:24:32.673 --> 00:24:33.774 
“等一下”我說

00:24:35.742 --> 00:24:39.446 
“你剛剛只是把每個
CGContext寫入渲染器嗎？”

00:24:41.615 --> 00:24:44.251 
他...我是說它什麼也沒做

00:24:45.118 --> 00:24:48.222 
但是這有些令人吃驚
我甚至不需要添加一種新的類型

00:24:51.058 --> 00:24:52.559 
“你還在等什麼？Crusty說

00:24:52.626 --> 00:24:53.927 
“在那些大括號中填入內容”

00:24:55.028 --> 00:24:57.631 
所以我把必要的
CoreGraphics粘着都倒了進去

00:24:57.931 --> 00:25:01.368 
把所有都扔進了遊戲場 這就是了

00:25:02.736 --> 00:25:04.638 
現在你可以下載這個遊戲場

00:25:05.072 --> 00:25:07.708 
它演示了我在這兒演講的所有內容

00:25:07.774 --> 00:25:09.710 
在我們結束之後

00:25:12.713 --> 00:25:13.814 
不過還是回到我們的例子

00:25:14.915 --> 00:25:17.618 
爲了幹擾我Crusty之後做了這些

00:25:20.754 --> 00:25:23.257 
現在我需要花一點時間瞭解爲什麼繪製

00:25:23.323 --> 00:25:25.025 
在這個點上沒有進入無線循環

00:25:26.226 --> 00:25:27.694 
如果你想了解更多的話

00:25:28.095 --> 00:25:31.031 
你可以聽一下週五的講習會

00:25:34.234 --> 00:25:36.270 
但這也並沒有改變顯示

00:25:37.471 --> 00:25:39.873 
最終Crusty決定向我
演示正在發生的事情

00:25:39.940 --> 00:25:41.341 
在他的純文本輸出中

00:25:42.242 --> 00:25:45.946 
然後事實證明它只
重複了相同的繪製命令

00:25:48.382 --> 00:25:49.216 
兩次

00:25:49.750 --> 00:25:52.686 
所以作爲一個更面向圖形的傢伙

00:25:52.753 --> 00:25:54.788 
我很想看到結果

00:25:55.355 --> 00:25:59.793 
所以我創建了一個小
比例的適配器並用它包裹住圖表

00:26:00.761 --> 00:26:03.564 
這就是結果

00:26:04.031 --> 00:26:08.268 
你可以在遊戲場看到這些所以我不打算
在這兒深究小比例適配器

00:26:11.471 --> 00:26:13.173 
不過這也是一種

00:26:14.241 --> 00:26:16.543 
使用協議的演示我們可以做到所有

00:26:16.610 --> 00:26:18.378 
與使用類可以做到的相同的事情

00:26:18.712 --> 00:26:21.114 
適配器通常設計模式

00:26:22.816 --> 00:26:25.819 
好 現在我想反思一下

00:26:25.886 --> 00:26:27.921 
使用TestRenderer
都做了些什麼

00:26:28.522 --> 00:26:29.957 
因爲它事實上是有些傑出的

00:26:32.526 --> 00:26:36.363 
通過從特定的渲染器中解耦文件模型

00:26:36.964 --> 00:26:40.100 
他能夠插入檢測組件

00:26:40.534 --> 00:26:44.905 
以顯示我們正在做的一切
我們的代碼正在做的一切詳細地

00:26:46.773 --> 00:26:49.209 
後來我們就在我們的
代碼中應用了這種方法

00:26:50.244 --> 00:26:53.146 
我們發現我們使用協議解耦的事物越多

00:26:53.514 --> 00:26:54.982 
所有的事物的可測性就越強

00:26:56.517 --> 00:26:57.551 
這種測試與

00:26:57.951 --> 00:27:01.822 
使用mock測試得到的結果很像
但這樣做更好

00:27:03.090 --> 00:27:04.958 
mock測試本質上是脆弱的

00:27:07.327 --> 00:27:08.996 
你需要結合測試中的代碼

00:27:09.062 --> 00:27:11.465 
測試代碼的實現細節

00:27:13.100 --> 00:27:16.003 
正因這種脆弱性它們無法與

00:27:16.069 --> 00:27:18.105 
Swift 強大的靜態類型
系統很好地融合

00:27:20.641 --> 00:27:23.510 
協議給我們提供了有原則的接口

00:27:23.810 --> 00:27:26.146 
以供使用這由語言進行實施

00:27:26.680 --> 00:27:30.450 
但仍會給我們hook以插入所有
我們所需要的檢測設備

00:27:32.853 --> 00:27:36.790 
好 回到我們的例子
因爲我們現在需要認真地

00:27:36.857 --> 00:27:37.958 
討論一下Bubbles

00:27:40.027 --> 00:27:42.396 
好我們希望這個圖表
應用受孩子們的歡迎

00:27:42.462 --> 00:27:44.631 
當然孩子們喜歡
Bubbles(氣泡)

00:27:45.132 --> 00:27:51.138 
因此在圖表中Bubbles
只是一個內部圓圈偏移量

00:27:51.972 --> 00:27:54.308 
圍繞外圍圓圈中心

00:27:55.475 --> 00:27:57.010 
以此來表現加亮區

00:27:57.845 --> 00:27:58.745 
所以你有兩個圓

00:27:59.479 --> 00:28:00.314 
就像這樣

00:28:02.015 --> 00:28:03.917 
當我把這段代碼放到上下文

00:28:03.984 --> 00:28:06.086 
Crusty 開始變得很激動

00:28:07.120 --> 00:28:09.056 
所有的代碼副本都使他抓狂

00:28:09.723 --> 00:28:11.859 
如果 Crusty 不高興
那麼沒有人可以高興

00:28:15.095 --> 00:28:18.165 
“瞧 他們都是完整的圓”他喊道
“我只想寫這段”

00:28:19.166 --> 00:28:21.335 
我說“冷靜Crusty冷靜

00:28:22.069 --> 00:28:22.903 
我們可以這麼做

00:28:24.171 --> 00:28:28.208 
我們需要做的就是
再添加一個協議的要求

00:28:29.810 --> 00:28:32.880 
然後當然我們更新模型來供應它

00:28:33.780 --> 00:28:34.882 
我們有測試渲染器

00:28:36.250 --> 00:28:37.684 
然後還有 CGContext”

00:28:39.720 --> 00:28:42.556 
現在這個點上
Crusty 脫掉了鞋子

00:28:42.623 --> 00:28:45.926 
拿它敲着桌子因爲這裏
我們又一次在重複代碼

00:28:47.194 --> 00:28:49.630 
他從我這裏把鍵盤奪了回來抱怨着

00:28:49.696 --> 00:28:51.498 
說所有的事情都需要他自己完成

00:28:53.066 --> 00:28:55.936 
他開始教我使用
Swift的一個新特徵

00:29:00.440 --> 00:29:01.909 
這就是協議擴展

00:29:03.277 --> 00:29:05.712 
據說“渲染器的所有模型

00:29:05.779 --> 00:29:08.248 
都有circleAt的這個實現”

00:29:09.516 --> 00:29:14.354 
現在我們有一種實現
渲染器的所有模型都在共享這種實現

00:29:15.022 --> 00:29:18.859 
注意到我們仍有這個
circleAt 要求在那裏

00:29:19.493 --> 00:29:20.994 
你可能會問“有要求意味着什麼？

00:29:21.061 --> 00:29:25.165 
這個要求也可以在擴展中立即實現”

00:29:26.366 --> 00:29:27.201 
很好的問題

00:29:28.101 --> 00:29:32.472 
答案是協議要求新建定製點

00:29:35.876 --> 00:29:38.178 
爲了見證這是如何表現的
讓我們先推翻這種方法體

00:29:38.712 --> 00:29:40.547 
而在擴展中添加另一種方法

00:29:40.848 --> 00:29:43.450 
添加一種不被要求支持的方法

00:29:45.819 --> 00:29:48.755 
現在我們可以擴展Crusty的 

00:29:49.022 --> 00:29:51.458 
來實現這兩個方法

00:29:54.862 --> 00:29:55.963 
然後我們只需要調用它們

00:29:57.965 --> 00:30:01.702 
好 現在發生的事情完全不會令人吃驚

00:30:02.202 --> 00:30:04.872 
我們直接調用
TestRender中的實現

00:30:05.806 --> 00:30:08.408 
而協議並沒有參與其中 對吧？

00:30:08.909 --> 00:30:12.312 
如果我們刪除這種一致性
我們將得到相同的結果

00:30:17.251 --> 00:30:18.919 
不過現在我們修改下上下文

00:30:18.986 --> 00:30:22.289 
這樣Swift就只知道它是一個渲染器
而不是 TestRenderer

00:30:26.226 --> 00:30:27.160 
來看一下發生了什麼

00:30:28.228 --> 00:30:30.497 
所以因爲circleAt是要求

00:30:31.331 --> 00:30:34.001 
我們的模型獲得了定製它的特權

00:30:34.401 --> 00:30:35.769 
然後定製被調用

00:30:39.239 --> 00:30:40.073 
那個

00:30:44.378 --> 00:30:46.480 
但是rectangleAt不是要求

00:30:46.547 --> 00:30:48.448 
所以TestRenderer中的實現

00:30:48.849 --> 00:30:52.753 
只覆蓋到協議和上下文

00:30:53.453 --> 00:30:56.089 
你只知道有渲染器而非
TestRenderer的時候

00:30:56.590 --> 00:30:58.125 
協議實現被調用

00:30:59.660 --> 00:31:00.627 
這有點奇怪 不是嗎？

00:31:03.163 --> 00:31:05.999 
那麼 這是否意味着
rectangleAt應該是要求？

00:31:07.067 --> 00:31:08.402 
也許在這種情況下它應該

00:31:08.635 --> 00:31:11.205 
是因爲有些渲染器非常有可能

00:31:11.271 --> 00:31:13.674 
有更有效的方式來畫矩形

00:31:13.907 --> 00:31:15.909 
與座標系相配合

00:31:17.578 --> 00:31:22.449 
但是 協議擴展中的所有事物是否也
是由要求支持的呢？

00:31:22.883 --> 00:31:23.750 
不一定

00:31:26.553 --> 00:31:29.990 
我是說有些應用程序
界面並不打算作爲定製點

00:31:30.724 --> 00:31:32.860 
所以有時正確的解決方法是

00:31:32.926 --> 00:31:37.264 
只覆蓋到模型中的要求

00:31:38.031 --> 00:31:39.900 
而不要覆蓋到模型中的方法

00:31:44.872 --> 00:31:50.511 
那麼這種新特徵偶然地變革了
我們在Swift標準庫上的工作

00:31:51.845 --> 00:31:54.348 
有時我們使用協議擴展所做的事情

00:31:55.349 --> 00:31:56.683 
感覺很神奇

00:31:57.918 --> 00:32:01.188 
我真心希望你們可以
享受使用最新的庫進行工作

00:32:01.522 --> 00:32:03.123 
就像我們享受應用這些到庫

00:32:03.190 --> 00:32:08.228 
以及更新庫一樣
我想先撇開我們的故事

00:32:08.295 --> 00:32:11.665 
這樣我就可以向你們展示我們使用
協議擴展在標準庫上做的一些事情

00:32:11.999 --> 00:32:14.902 
還有一些其他的技巧

00:32:16.570 --> 00:32:19.239 
首先來講一下新的indexOf方法

00:32:20.707 --> 00:32:23.043 
這個方法遍歷集合的指針

00:32:23.410 --> 00:32:26.613 
直到它找到與我們
正在查找的相等的元素

00:32:26.947 --> 00:32:28.448 
然後返回這個指針

00:32:28.982 --> 00:32:30.751 
如果它沒有找到結果那麼返回空

00:32:31.552 --> 00:32:32.386 
非常簡單對吧？

00:32:34.488 --> 00:32:36.356 
但是如果我們這樣寫
就會有一個問題

00:32:37.891 --> 00:32:40.527 
一個任意集合的元素

00:32:41.161 --> 00:32:42.462 
不能對等地比較

00:32:44.998 --> 00:32:48.602 
因此爲了解決這個問題
我們可以約束擴展

00:32:49.369 --> 00:32:51.638 
這是這個新特徵的另一方面

00:32:55.242 --> 00:33:00.180 
所以這麼說擴展應用於
集合元素類型是Equatable時

00:33:01.381 --> 00:33:05.986 
我們已經給Swift傳遞了它所
需要的信息以允許等式比較

00:33:08.422 --> 00:33:10.324 
現在我們已經看到了

00:33:10.390 --> 00:33:13.894 
約束擴展的一個簡單示例
讓我們重溫一下二進位檢索

00:33:16.997 --> 00:33:18.732 
我們將其應用到整型數組上

00:33:22.269 --> 00:33:24.671 
好 整型不符合Ordered類

00:33:25.706 --> 00:33:26.874 
這是一種簡單的解決辦法

00:33:27.374 --> 00:33:28.575 
我們只要添加一致性

00:33:29.977 --> 00:33:31.278 
好 那對於字符串又會怎樣呢？

00:33:33.247 --> 00:33:35.983 
當然 這對字符串並沒有用
所以我們再做一次

00:33:36.683 --> 00:33:40.387 
現在在Crusty開始敲桌子之前
我們很想分析出其中原因

00:33:41.889 --> 00:33:44.124 
小於運算符出現在

00:33:44.191 --> 00:33:47.160 
Comparable協議中
所以我們可以在

00:33:47.227 --> 00:33:48.829 
Comparable協議中操作

00:33:53.300 --> 00:33:54.134 
像這樣

00:33:55.536 --> 00:33:58.438 
現在我們正在預先提供那些一致性

00:33:58.739 --> 00:34:00.974 
所以一方面這是很好的

00:34:01.842 --> 00:34:03.744 
如果我想對雙精度數據
進行二進位搜索

00:34:04.111 --> 00:34:07.481 
我所需要做的就是添加
這個一致性我可以這麼做

00:34:08.982 --> 00:34:12.152 
另一方面這有些討厭

00:34:12.485 --> 00:34:15.155 
因爲即使我去掉一致性

00:34:15.522 --> 00:34:18.559 
我還是有這個被雙精度獲得的優先函數

00:34:19.025 --> 00:34:22.062 
它已經有了足夠的接口 對嗎？

00:34:23.163 --> 00:34:28.534 
我們可能想要更加有選擇性地
在雙精度數值上添加東西

00:34:30.871 --> 00:34:34.675 
所以即使我可以這樣做

00:34:34.741 --> 00:34:38.277 
我不能用它來進行二進位檢索所以這些
優先函數真的沒有給我買入任何東西

00:34:39.813 --> 00:34:43.449 
幸運的是我可以對哪些東西獲得
優先函數應用程序界面更有選擇性

00:34:44.251 --> 00:34:46.286 
通過使用Ordered的約束擴展

00:34:48.222 --> 00:34:52.726 
所以這就是說一個是
Comparable的類型並被聲明

00:34:52.793 --> 00:34:57.164 
爲Ordered將能夠
自動地滿足優先要求

00:34:57.798 --> 00:34:59.066 
而這正是我們想要的

00:35:00.567 --> 00:35:02.836 
抱歉 但我覺得這很酷

00:35:03.237 --> 00:35:05.939 
我們有了同樣的抽象

00:35:07.007 --> 00:35:09.676 
同樣的邏輯抽象
來自於兩個不同的地方

00:35:09.977 --> 00:35:12.312 
而我們已經使它們無縫協作

00:35:13.013 --> 00:35:15.249 
謝謝你們的掌聲 
不過我只是我覺得這很酷

00:35:17.651 --> 00:35:19.586 
好 做好準備來一個味蕾清新劑了嗎？

00:35:24.391 --> 00:35:25.225 
這顯示它起作用了

00:35:25.792 --> 00:35:31.398 
好 這是一個完全通用的
二進位檢索的簽名

00:35:32.032 --> 00:35:33.734 
作用於任意一個集合

00:35:34.101 --> 00:35:36.236 
帶有適當的索引和元素類型

00:35:37.971 --> 00:35:40.374 
現在我已經能聽到
你們在那兒越來越不舒服了

00:35:40.641 --> 00:35:42.409 
我並不準備在這裏寫主體

00:35:42.476 --> 00:35:44.811 
因爲這已經看起來很糟糕了 對吧

00:35:45.779 --> 00:35:48.782 
Swift 1有很多像
這樣的通用免費函數

00:35:49.983 --> 00:35:52.553 
在Swift 2中我們像這樣
使用協議擴展將它們

00:35:52.619 --> 00:35:55.822 
變爲方法 這很棒

00:35:57.724 --> 00:36:00.961 
現在每個人都專注於在
這個調用站點的改善

00:36:01.762 --> 00:36:04.598 
它現在很明顯地充滿了

00:36:04.898 --> 00:36:06.533 
方法的精華

00:36:06.967 --> 00:36:08.902 
但隨着這個傢伙寫二進位檢索

00:36:09.469 --> 00:36:11.038 
我因其簽名而愛上了它所做的事情

00:36:11.872 --> 00:36:15.309 
通過分離情況
這些情況下該方法應用於

00:36:15.609 --> 00:36:17.110 
聲明的其餘部分

00:36:17.811 --> 00:36:19.780 
現在讀起來只是一個常規方法

00:36:21.415 --> 00:36:22.816 
不再有尖括號盲區

00:36:26.587 --> 00:36:27.421 
非常感謝

00:36:31.191 --> 00:36:34.228 
好 在我們回到我們的故事前
來講一下最後一個技巧

00:36:35.829 --> 00:36:39.299 
這是一個包含最小模型的遊戲場

00:36:39.366 --> 00:36:41.768 
關於Swift的心
OptionSetType協議

00:36:42.769 --> 00:36:45.038 
它就是一個結構具有隻讀整型屬性

00:36:46.006 --> 00:36:47.007 
叫做rawValue

00:36:47.474 --> 00:36:53.580 
現在來看一下一旦你昨晚
即可免費得到的廣泛設置界面

00:36:55.249 --> 00:36:57.584 
所有這些都來自於協議擴展

00:36:58.952 --> 00:37:00.988 
如果你有機會的話
我邀請你來看一下

00:37:01.054 --> 00:37:02.856 
那些擴展是怎樣聲明的

00:37:03.190 --> 00:37:05.959 
在標準庫中因爲幾個圖層

00:37:06.026 --> 00:37:08.629 
一起工作來提供這個豐富的
應用程序界面

00:37:11.331 --> 00:37:16.303 
好 這些就是你可以
使用協議擴展做到的一些很酷的事情

00:37:17.371 --> 00:37:21.408 
現在 我想回到我們的圖表示例中

00:37:24.144 --> 00:37:25.846 
使值類型可相等

00:37:27.681 --> 00:37:30.083 
爲什麼？因爲我是這麼說的

00:37:30.817 --> 00:37:32.219 
另外吃蔬菜

00:37:33.954 --> 00:37:35.989 
不 事實上如果你想
知道爲什麼去聽一下

00:37:36.056 --> 00:37:37.858 
週五的講習會我已經跟你們講過這個

00:37:39.826 --> 00:37:43.397 
這是一個很酷的演講
他們準備詳細探討這個問題

00:37:44.965 --> 00:37:47.968 
總之Equatable對於大多數
類型來說都是很容易的 對吧

00:37:48.035 --> 00:37:51.538 
你只需要比較相應的部分
以求其對等性 就像這樣

00:37:52.940 --> 00:37:55.242 
但是現在我們來看一下圖表發生了什麼

00:37:58.612 --> 00:38:03.350 
啊哦 我們不能對比兩個
Drawable類型數組的對等性

00:38:06.286 --> 00:38:11.058 
好吧 也許我們可以這麼做
比較個體元素就好比這樣

00:38:15.762 --> 00:38:19.032 
好 我將給你們過一遍

00:38:19.166 --> 00:38:21.502 
首先你去頂它們有相同數量的元素

00:38:21.635 --> 00:38:23.937 
然後把兩個數組壓縮在一起

00:38:24.004 --> 00:38:25.772 
如果它們有相同數量的元素

00:38:25.839 --> 00:38:28.575 
那麼你就找一對不相等的

00:38:29.009 --> 00:38:30.410 
好的你可以相信我的話

00:38:30.477 --> 00:38:33.480 
這還不是問題有趣的部分

00:38:36.250 --> 00:38:37.084 
哦 對吧？

00:38:37.217 --> 00:38:40.153 
這是我們無法比較數組的整個原因就是

00:38:40.220 --> 00:38:43.590 
因爲Drawable類是不對等的

00:38:43.891 --> 00:38:46.593 
因此兩個數組之間沒有等於運算符

00:38:47.060 --> 00:38:49.963 
我們沒有等於運算符
給潛在的Drawable屬性

00:38:50.030 --> 00:38:52.666 
我們能不能把Drawable
改爲Equatable？

00:38:53.200 --> 00:38:54.601 
我們改變了設計像這樣

00:39:00.274 --> 00:39:03.277 
這裏的問題在於
Equatable有Self要求

00:39:04.344 --> 00:39:07.214 
這意味着Drawable
現在有了Self要求

00:39:08.382 --> 00:39:11.218 
而Self要求正好將
Drawable

00:39:11.285 --> 00:39:14.721 
放進了同構中靜態分派的世界

00:39:16.256 --> 00:39:20.894 
但是圖表需要的是
Drawable異構數組

00:39:22.029 --> 00:39:25.232 
因此我們可以將多邊形
和圓放在同一個圖表中

00:39:26.099 --> 00:39:29.303 
那麼Drawable必須待在異構的
動態分派的世界

00:39:30.370 --> 00:39:31.305 
而這帶來了矛盾

00:39:31.972 --> 00:39:34.474 
將Drawable改爲
Equatable是行不通的

00:39:37.811 --> 00:39:39.713 
我們需要這樣做

00:39:39.780 --> 00:39:43.350 
就是說給Drawable添加
isEqualTo要求

00:39:45.919 --> 00:39:48.488 
但是...不 我們不能用Self

00:39:49.857 --> 00:39:51.825 
因爲我們需要保持異構

00:39:52.192 --> 00:39:53.694 
而沒有了Self

00:39:54.328 --> 00:39:57.831 
這就像用類完成Ordered一樣

00:39:58.765 --> 00:40:00.834 
現在我們要讓所有 Drawable

00:40:01.134 --> 00:40:03.403 
來處理異構比較情況

00:40:06.473 --> 00:40:08.041 
幸運的是這次有一種方法可以做到

00:40:09.142 --> 00:40:13.280 
與大多對稱運算符不同
等式是特殊的

00:40:14.381 --> 00:40:16.617 
因爲有顯而易見的默認的答案

00:40:16.683 --> 00:40:17.784 
如果類型不匹配的話

00:40:18.385 --> 00:40:22.155 
可以這麼說如果有兩個不同的類型
它們是不等的

00:40:24.424 --> 00:40:27.528 
明白這一點我們可以實現
isEqualTo

00:40:27.594 --> 00:40:29.730 
爲所有Equatable的
Drawable

00:40:31.765 --> 00:40:32.599 
就像這樣

00:40:35.402 --> 00:40:36.370 
讓我來向你們演示

00:40:37.538 --> 00:40:38.906 
擴展就是我們所說的

00:40:39.106 --> 00:40:41.508 
它是給所有Equatable的
Drawable的

00:40:49.049 --> 00:40:53.887 
好 首先我們有條件地將其他
類型向下轉型到Self類型

00:40:54.488 --> 00:40:57.090 
如果這成功瞭然後我們可以繼續下去

00:40:57.157 --> 00:41:00.494 
使用等式比較
因爲我們有Equatable一致性

00:41:01.461 --> 00:41:04.064 
否則實例會被認爲不對等

00:41:09.169 --> 00:41:11.705 
那麼大圖片這裏剛剛發生了什麼呢？

00:41:13.207 --> 00:41:16.009 
我們與Drawable的
實現器達成協議

00:41:16.476 --> 00:41:22.516 
我們說“如果你真的想
處理異構情況請做我的訪客

00:41:22.916 --> 00:41:24.751 
去實現isEqualTo

00:41:25.652 --> 00:41:30.057 
但如果你只是想用我們

00:41:30.123 --> 00:41:32.826 
表達同構比較的常規方式

00:41:33.093 --> 00:41:35.829 
我們將爲你處理所有異構比較的負擔”

00:41:38.131 --> 00:41:41.201 
所以在靜態和動態世界之間建立橋樑

00:41:41.268 --> 00:41:44.338 
是極好的設計空間

00:41:44.838 --> 00:41:47.307 
我鼓勵你們多多觀察

00:41:47.875 --> 00:41:51.879 
我們使用等式的特殊屬性
解決了這個特別的問題

00:41:51.945 --> 00:41:54.915 
但是問題並不都像這樣

00:41:56.583 --> 00:41:58.018 
你還可以做很多很酷的事情

00:42:01.889 --> 00:42:06.193 
因此等式的這個屬性不一定適用
但是什麼纔是普遍適用的呢？

00:42:07.694 --> 00:42:08.695 
基於協議的設計

00:42:16.670 --> 00:42:19.473 
所以我想在我們總結

00:42:19.973 --> 00:42:23.043 
何時使用類之前說幾句
因爲他們有他們的位置

00:42:23.977 --> 00:42:26.713 
好嗎？有些時候你真的想要隱式共享

00:42:28.415 --> 00:42:31.318 
例如值類型的基本操作

00:42:31.385 --> 00:42:33.053 
沒有任何意義時

00:42:33.520 --> 00:42:35.889 
比如複製副本意味着什麼呢？

00:42:35.956 --> 00:42:37.391 
如果你不明白這是什麼意思

00:42:38.025 --> 00:42:40.427 
那麼你可能想使它成爲引用類型

00:42:42.095 --> 00:42:43.964 
或者比較 一樣的

00:42:44.031 --> 00:42:46.233 
這是作爲數值的另一個基礎部分

00:42:46.800 --> 00:42:48.001 
那麼 比如窗口

00:42:48.969 --> 00:42:50.270 
複製窗口意味着什麼呢？

00:42:50.470 --> 00:42:51.738 
你真的想看

00:42:52.506 --> 00:42:53.707 
一個新的圖形窗口嗎？

00:42:54.041 --> 00:42:55.709 
就在另一個窗口之上？ 不知道

00:42:57.110 --> 00:42:58.879 
這不會是你視圖層級的一部分

00:42:59.947 --> 00:43:00.781 
毫無意義

00:43:01.815 --> 00:43:04.117 
另外一種情況

00:43:04.184 --> 00:43:09.122 
你的實例的生命週期依賴於
某些外部的副作用

00:43:09.489 --> 00:43:11.158 
比如磁盤上出現的文件

00:43:13.093 --> 00:43:17.998 
部分原因是編譯器大量地創建值

00:43:18.599 --> 00:43:20.367 
創建 再銷燬

00:43:20.634 --> 00:43:22.769 
我們試圖儘可能地優化

00:43:23.604 --> 00:43:26.707 
引用類型有這種穩定的特性

00:43:26.773 --> 00:43:28.942 
所以如果你要做一些對應於

00:43:29.009 --> 00:43:30.110 
外部實體的事情

00:43:30.844 --> 00:43:33.013 
你可能會想使它爲引用類型

00:43:33.580 --> 00:43:37.217 
類 另一種情況是

00:43:37.518 --> 00:43:40.354 
抽象實例是“水槽”

00:43:40.821 --> 00:43:42.523 
比如渲染器

00:43:43.724 --> 00:43:47.794 
我們灌注信息給它

00:43:47.861 --> 00:43:50.964 
給渲染器 我們讓它畫線

00:43:52.132 --> 00:43:55.435 
舉個例子如果你想做一個
TestRenderer

00:43:55.502 --> 00:44:00.641 
讓它積累文本並將這些命令輸出爲

00:44:00.841 --> 00:44:03.610 
字符串 而不是直接將它們倒給控制檯

00:44:04.011 --> 00:44:05.012 
你可以像這樣做

00:44:06.914 --> 00:44:08.882 
但要注意幾件事情

00:44:09.416 --> 00:44:11.518 
首先這是最後

00:44:13.153 --> 00:44:15.088 
其次沒有基類

00:44:15.422 --> 00:44:16.456 
這仍然是一個協議

00:44:17.057 --> 00:44:18.992 
我使用協議來表達抽象

00:44:23.530 --> 00:44:25.299 
好 額外的幾種情況

00:44:27.768 --> 00:44:30.704 
我們生活在面向對象的世界 對吧？

00:44:30.871 --> 00:44:33.640 
Cocoa 和
Cocoa Touch致力於對象

00:44:34.741 --> 00:44:37.411 
他們會給你基類
並期望你將它們編入子類

00:44:37.845 --> 00:44:40.881 
他們期望應用程序界面中的對象

00:44:41.715 --> 00:44:43.584 
不要與系統對抗 好嗎？

00:44:43.984 --> 00:44:45.085 
這隻會是徒勞的

00:44:46.420 --> 00:44:51.225 
但是與此同時一定要謹慎

00:44:51.992 --> 00:44:55.062 
你知道程序中任何事物都不能過大

00:44:55.529 --> 00:44:57.898 
這對類和其他都適用

00:44:58.832 --> 00:45:02.469 
所以當你從類中重構或分解時

00:45:03.303 --> 00:45:04.738 
考慮使用值類型

00:45:07.574 --> 00:45:09.610 
好了 總結一下

00:45:11.378 --> 00:45:14.214 
協議 對於抽象來講好過於超類

00:45:16.183 --> 00:45:21.121 
第二協議擴展這個新特徵

00:45:21.588 --> 00:45:23.290 
讓你做很神奇的事情

00:45:25.492 --> 00:45:27.728 
第三我提到讓你們來聽週五的演講嗎？

00:45:29.796 --> 00:45:30.731 
來參加週五的演講

00:45:32.833 --> 00:45:33.667 
吃蔬菜

00:45:34.801 --> 00:45:35.702 
像Crusty一樣

00:45:36.737 --> 00:45:37.571 
非常感謝