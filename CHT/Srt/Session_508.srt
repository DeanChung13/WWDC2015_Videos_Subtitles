00:00:19.720 --> 00:00:24.291 
音頻單元擴展

00:00:25.292 --> 00:00:27.794 
謝謝 早上好

00:00:29.696 --> 00:00:31.698 
我是道格·懷亞特
Core Audio的團隊

00:00:31.865 --> 00:00:34.768 
我想向大家展示我們新近研發的產品

00:00:35.169 --> 00:00:36.970 
叫做音頻單元擴展

00:00:37.371 --> 00:00:42.409 
這是iOS 9和OS X El
Capitan系統的一項新技術

00:00:43.944 --> 00:00:46.747 
關於音頻單元
自OS X和iOS系統誕生伊始

00:00:46.813 --> 00:00:51.318 
我們就在操作系統中植入了該技術

00:00:52.085 --> 00:00:54.521 
操作系統包括許多內置單元

00:00:54.588 --> 00:00:57.758 
從I/O單元到混音器

00:00:58.258 --> 00:01:02.396 
給軟件採樣器提供了多種不同的特效

00:01:04.096 --> 00:01:06.333 
在我們的許多高級API中

00:01:06.400 --> 00:01:09.169 
我們都使用了這些內置音頻單元

00:01:09.369 --> 00:01:10.737 
比如媒體播放棧

00:01:12.072 --> 00:01:15.742 
但是音頻單元同時也是一款OS X中

00:01:15.876 --> 00:01:17.811 
廣泛使用的第三方插件格式

00:01:18.178 --> 00:01:20.948 
市面上有着成千上萬種

00:01:21.014 --> 00:01:21.949 
第三方音頻單元

00:01:24.251 --> 00:01:25.886 
現在音頻單元擴展

00:01:25.953 --> 00:01:28.922 
使我們首次在OS X和iOS系統中

00:01:29.423 --> 00:01:31.725 
擁有了全能插件模型

00:01:32.259 --> 00:01:35.262 
音頻單元擴展是基於
應用擴展技術開發的

00:01:35.762 --> 00:01:39.066 
這就意味着 如果你在
編寫插件你可以將插件

00:01:39.132 --> 00:01:42.636 
打包進App而App可以在
App Stores中進行銷售

00:01:49.676 --> 00:01:53.247 
作爲該技術的一部分我們優化了API

00:01:53.747 --> 00:01:56.617 
同時維持了兼容性

00:01:57.117 --> 00:02:00.454 
在這次演講中
我將詳細彙報這一新的API

00:02:01.221 --> 00:02:03.924 
我們將它稱爲第三代音頻單元API

00:02:05.926 --> 00:02:07.895 
在音頻單元框架基礎之上

00:02:07.961 --> 00:02:11.965 
使用AUAudioUnit的
Objective-C類型建開發而成

00:02:12.032 --> 00:02:15.736 
既然從屬於Objective-C
類別當然能夠與Swift完美兼容

00:02:15.802 --> 00:02:17.004 
我們都將見證這一點

00:02:19.940 --> 00:02:21.975 
本次演講我們還會討論

00:02:22.042 --> 00:02:24.511 
AVFoundation框架內的
其他許多類別

00:02:25.145 --> 00:02:28.982 
我們有AV音頻單元組件管理器

00:02:29.616 --> 00:02:31.451 
和AV音頻單元組件

00:02:32.152 --> 00:02:35.656 
用來定位系統中的音頻組件

00:02:36.390 --> 00:02:38.659 
這在iOS 9中還是首次

00:02:39.293 --> 00:02:40.928 
在Yosemite系統也是如此

00:02:41.728 --> 00:02:44.364 
在今天我們將要展示的代碼樣本中

00:02:44.932 --> 00:02:47.367 
我們也將會用到
AVAudioEngine

00:02:48.202 --> 00:02:50.704 
尤其是AVAudioUnit

00:02:50.771 --> 00:02:52.806 
和AVAudioUnitEffect類別

00:02:53.207 --> 00:02:56.276 
兩者都是在去年的OS發佈的

00:02:58.545 --> 00:03:00.814 
那麼現在我們談一談兼容性

00:03:00.881 --> 00:03:02.683 
這是OS X中的情況

00:03:03.050 --> 00:03:05.652 
我們現在擁有二代音頻單元主機

00:03:06.053 --> 00:03:09.256 
以及二代音頻單元執行

00:03:09.623 --> 00:03:12.659 
主機與音頻部件實例之間

00:03:12.726 --> 00:03:13.861 
通過信息通訊

00:03:14.528 --> 00:03:16.630 
實現執行功能

00:03:16.697 --> 00:03:18.999 
則基於音頻部件出廠功能基礎

00:03:21.435 --> 00:03:23.670 
我們擁有一組新的API

00:03:24.037 --> 00:03:27.140 
因此就有了使用這些API的新主機

00:03:27.741 --> 00:03:31.945 
以及植入的使用這些
新的API的音頻單元

00:03:32.312 --> 00:03:35.582 
主機與 AU音頻單元類通訊

00:03:35.983 --> 00:03:40.053 
新的第三代音頻單元會
將AU音頻單元納入子類

00:03:40.854 --> 00:03:42.823 
這就成了兩種不同的API

00:03:42.890 --> 00:03:45.225 
我們怎麼才能確保兼容呢

00:03:45.826 --> 00:03:48.629 
我們需要在這兩種API之間使用橋站

00:03:49.930 --> 00:03:51.665 
正因有了橋站我們會發現

00:03:52.065 --> 00:03:57.004 
第三代主機與現有的二代音頻單元

00:03:57.237 --> 00:03:59.540 
幾乎完全兼容

00:04:00.274 --> 00:04:04.578 
相反現有的二代主機只需要很小的改動

00:04:04.645 --> 00:04:08.482 
就可適應新的第三代音頻單元

00:04:08.815 --> 00:04:11.552 
我將詳細介紹這些API的改動

00:04:15.455 --> 00:04:17.558 
現在我將給大家展示

00:04:17.624 --> 00:04:19.760 
在經過細微改良的
Logic Pro版本中

00:04:19.826 --> 00:04:22.896 
使用新的音頻單元的演示

00:04:25.332 --> 00:04:29.536 
這裏有一小段音樂裏面有鼓點循環

00:04:31.238 --> 00:04:34.541 
我將把一個音頻單元放到這條音軌上

00:04:35.943 --> 00:04:38.612 
這裏所有的都是
Apple內置的音頻單元

00:04:40.147 --> 00:04:45.419 
這裏還有一個叫做
v3失真的演示音頻單元

00:04:46.687 --> 00:04:48.555 
這樣我打開這個音頻單元

00:04:49.389 --> 00:04:54.695 
我可以找到心儀的預置方案
我們可以聽到Logic

00:04:54.828 --> 00:04:56.363 
通過這個音頻單元播放出來

00:05:01.668 --> 00:05:02.603 
聲音很乾

00:05:04.771 --> 00:05:05.806 
完全失真了

00:05:06.807 --> 00:05:09.309 
現在如果我查看活動監視器

00:05:10.110 --> 00:05:13.413 
我們可以發現

00:05:13.480 --> 00:05:17.317 
這個失真音頻單元在一個
獨立進程AU v3 失真中運作

00:05:17.484 --> 00:05:19.820 
這會消耗一點CPU

00:05:20.721 --> 00:05:21.889 
會佔據一些線程

00:05:23.090 --> 00:05:27.794 
假設這個音頻單元內部
有一個bug它就會崩潰

00:05:27.861 --> 00:05:30.430 
我可以在活動監視器中進行模擬

00:05:30.964 --> 00:05:31.965 
我可以強制退出

00:05:34.168 --> 00:05:36.470 
注意Logic界面一片空白

00:05:36.870 --> 00:05:38.205 
但音樂還在繼續播放

00:05:49.183 --> 00:05:51.485 
這是我們剛剛探討問題的一個圖

00:05:52.052 --> 00:05:54.955 
這是經過細微改良的
Logic Pro

00:05:55.756 --> 00:05:59.893 
但本質上還是使用
現有的二代API進行通訊

00:06:00.260 --> 00:06:03.830 
與AU音頻單元橋接

00:06:04.131 --> 00:06:06.533 
進而在獨立擴展服務進程中

00:06:06.900 --> 00:06:10.604 
我們看到失真AU音頻單元子類

00:06:11.305 --> 00:06:13.040 
和定製的視圖控制器同時運行

00:06:13.607 --> 00:06:16.210 
Logic進程中也有視圖控制器

00:06:16.810 --> 00:06:18.612 
你可以看到這些是如何

00:06:19.213 --> 00:06:21.281 
進行跨進程橋接的

00:06:24.918 --> 00:06:27.588 
現在我們再看託管音頻單元

00:06:28.255 --> 00:06:31.859 
我將向大家展示使用
三代API的一個案例

00:06:32.159 --> 00:06:35.295 
我們有這一段稱爲音頻單元
v3 Example的樣本代碼

00:06:35.729 --> 00:06:38.232 
幾小時前我檢查過這段代碼還沒有寫好

00:06:38.565 --> 00:06:42.603 
我希望今天它能夠工作正常

00:06:42.903 --> 00:06:45.339 
在這個樣本代碼項目中
你可以看到有很多個樣靶

00:06:45.472 --> 00:06:48.175 
其中一個叫做AU主機

00:06:49.009 --> 00:06:51.879 
這個App相當簡潔明瞭

00:06:52.279 --> 00:06:56.250 
但它展示了怎樣找到
並打開系統中音頻單元的過程

00:06:56.950 --> 00:06:58.485 
怎樣連接形成特效鏈

00:06:58.819 --> 00:07:02.322 
怎樣選擇音頻單元預置方案

00:07:02.756 --> 00:07:05.792 
以及怎樣打開音頻單元自定義界面

00:07:07.794 --> 00:07:11.498 
因此在AU主機app中
我們有所謂的簡單播放引擎

00:07:11.899 --> 00:07:15.369 
也就是使用
AVAudioEngine的Swift類

00:07:16.036 --> 00:07:19.106 
它使用一個AV音頻播放器結點

00:07:19.173 --> 00:07:20.841 
並連接到AV音頻單元特效

00:07:21.241 --> 00:07:23.810 
繼而AV音頻單元特效顯示出

00:07:23.977 --> 00:07:26.547 
內部的AU音頻單元

00:07:27.147 --> 00:07:31.018 
也就是第三代音頻
單元API的一個主類

00:07:31.752 --> 00:07:33.487 
播放器連接到特效器 

00:07:33.554 --> 00:07:34.988 
混音器和輸出上

00:07:35.255 --> 00:07:37.424 
這就是簡單播放引擎的工作原理

00:07:38.892 --> 00:07:42.963 
我們還將看到如何使用

00:07:43.030 --> 00:07:46.400 
AV音頻單元組件管理
器類別選擇系統中的

00:07:46.466 --> 00:07:50.103 
AV音頻單元組件

00:07:50.170 --> 00:07:52.606 
以及控制AV音頻單元選擇的特效

00:07:54.641 --> 00:07:56.443 
讓我們來看一段代碼

00:07:56.510 --> 00:07:59.580 
首先在使用音頻單元時

00:07:59.646 --> 00:08:01.281 
我們有一個非常重要的數據結構

00:08:01.882 --> 00:08:03.784 
我們有音頻組件描述

00:08:04.284 --> 00:08:06.787 
以及三個相關的主要域組件類別

00:08:07.254 --> 00:08:10.390 
子類別以及製造商

00:08:10.824 --> 00:08:14.628 
這一元組標記出系統中特定的音頻單元

00:08:15.229 --> 00:08:16.730 
標記也十分重要

00:08:16.797 --> 00:08:19.566 
由音頻組件部分植入

00:08:19.933 --> 00:08:23.370 
系統也會植入新的音頻組件

00:08:23.804 --> 00:08:25.772 
在解說過程中
我們還會對部分進行細緻探討

00:08:26.406 --> 00:08:28.008 
很重要的一點是

00:08:28.075 --> 00:08:29.943 
這是識別插件的關鍵

00:08:32.145 --> 00:08:34.948 
因此 爲了找到系統中的音頻單元組件

00:08:35.849 --> 00:08:38.919 
首先我們需要創建一個包含通配符的

00:08:39.653 --> 00:08:41.321 
音頻組件描述

00:08:41.655 --> 00:08:43.724 
這裏我們所說的組件類別是特效

00:08:43.823 --> 00:08:44.958 
那並不是通配符 

00:08:45.392 --> 00:08:48.462 
這裏還有組件子類別和元製造商

00:08:48.795 --> 00:08:52.065 
那些纔是通配符
這樣我們有了組件描述

00:08:52.266 --> 00:08:54.067 
可以識別任何特效了

00:08:55.969 --> 00:09:00.574 
接下來我們可以選擇任意特效組件描述

00:09:00.641 --> 00:09:03.510 
應用到AV音頻單元組件管理器

00:09:04.111 --> 00:09:06.914 
我們會得到與通配符相適應的系統中的

00:09:07.247 --> 00:09:08.749 
所有特效的渲染

00:09:09.616 --> 00:09:13.353 
現在我們有了一系列
AV音頻單元組件對象

00:09:13.987 --> 00:09:18.392 
其中包含了名稱 標籤

00:09:18.859 --> 00:09:23.363 
以及該單元的音頻組件描述

00:09:25.332 --> 00:09:27.401 
我們得到了一系列的組件

00:09:27.467 --> 00:09:29.102 
我們可以將它放回UI中

00:09:29.503 --> 00:09:34.141 
繼而UI可以在簡單
播放引擎中使用這種方法

00:09:34.541 --> 00:09:37.945 
挑選出一種此前已經上市的

00:09:38.645 --> 00:09:39.780 
特效組件

00:09:40.147 --> 00:09:41.715 
這樣我們得到了一個組件

00:09:42.182 --> 00:09:44.985 
將它使用到一種內部的方法上

00:09:45.586 --> 00:09:50.791 
這種內部方法的本質

00:09:50.858 --> 00:09:51.792 
就是這樣

00:09:52.292 --> 00:09:56.430 
我們將命名一種
新的AV音頻單元分類方法

00:09:57.297 --> 00:10:00.901 
這種方法需要基於這裏的

00:10:00.968 --> 00:10:03.103 
組件描述創造一個實例

00:10:04.137 --> 00:10:07.274 
這是一種異步功能
也就是說它會進行實例化

00:10:07.341 --> 00:10:09.309 
但真正將音頻單元實例化

00:10:09.743 --> 00:10:11.845 
並且我們可以使用之後

00:10:13.647 --> 00:10:20.554 
就會自行關閉

00:10:21.488 --> 00:10:23.023 
因此這裏我們可以得到回饋信號

00:10:23.090 --> 00:10:24.791 
這是Swift閉合語法

00:10:25.392 --> 00:10:27.027 
我們有自己的AV音頻單元

00:10:29.296 --> 00:10:32.999 
隨後我們可以將它應用到我們的引擎上

00:10:33.700 --> 00:10:36.270 
我們將它儲存到一個成員變量即特效中

00:10:39.339 --> 00:10:43.677 
我們也就得到了一個可以
察覺特效的AV音頻單元

00:10:43.744 --> 00:10:45.579 
我們對引擎打入補丁

00:10:46.146 --> 00:10:48.515 
特效和主混音器斷開

00:10:49.216 --> 00:10:51.585 
然後連接播放器和特效

00:10:52.886 --> 00:10:55.889 
然後特效再連接到主混音器節點

00:10:57.658 --> 00:10:59.560 
這樣我們就在播放
引擎中加入了一種特效

00:11:01.428 --> 00:11:05.632 
我們可以保存真實的AU音頻單元

00:11:06.066 --> 00:11:09.203 
這是插件利用插件我們可以
做各種各樣有趣的事情

00:11:09.269 --> 00:11:13.640 
比如操控組件的特效預置方案和參數

00:11:14.942 --> 00:11:18.946 
例如 從這裏我們將看到
出廠預置方案的列表

00:11:20.581 --> 00:11:23.383 
這也將向表格視圖而不是UI中

00:11:23.450 --> 00:11:25.719 
植入一個域

00:11:27.221 --> 00:11:29.356 
這樣 用戶可以選擇出廠預置

00:11:31.225 --> 00:11:33.227 
最後我們還想向諸位展示

00:11:34.328 --> 00:11:36.129 
我們將怎樣利用
接下來我要展示的App

00:11:36.430 --> 00:11:39.132 
得到音頻單元的自定義視圖

00:11:39.199 --> 00:11:40.968 
以及怎樣將其嵌入主程序視圖

00:11:41.535 --> 00:11:43.904 
現在我們進入了主機的視圖控制器

00:11:44.404 --> 00:11:47.574 
我們要求播放引擎給我們音頻單元

00:11:47.875 --> 00:11:49.810 
然後再從音頻單元中

00:11:49.910 --> 00:11:50.911 
獲得視圖控制器

00:11:51.211 --> 00:11:53.046 
當完成了這些步驟之後它將反饋給我們

00:11:53.113 --> 00:11:56.483 
一個視圖控制器
我們就將它嵌入到主視圖中

00:11:58.252 --> 00:12:00.821 
好的 接下來有請我的同事
邁克爾·霍普金斯

00:12:01.255 --> 00:12:03.390 
爲大家演示這個App是如何運作的

00:12:12.699 --> 00:12:13.867 
非常感謝你 道格

00:12:14.168 --> 00:12:16.003 
非常榮幸今天有機會

00:12:16.069 --> 00:12:20.474 
向大家演示這款基於
AVAudioEngine第三代主應用

00:12:21.008 --> 00:12:23.343 
如何在iPad上使用

00:12:24.144 --> 00:12:26.780 
正如你所見我點擊一下主機的圖標

00:12:26.847 --> 00:12:28.148 
就可以打開它

00:12:29.116 --> 00:12:32.653 
在屏幕的左手邊
我們有一個包含音頻單元

00:12:33.153 --> 00:12:35.122 
在系統呈現的所有特效的列表

00:12:35.489 --> 00:12:39.593 
既包含了內部
Apple音頻組件的特效

00:12:40.027 --> 00:12:42.396 
也包含了我自己添加的

00:12:42.462 --> 00:12:44.565 
新擴展的第三代音頻單元

00:12:45.766 --> 00:12:48.969 
在屏幕的頂端有一個播放鍵 

00:12:49.069 --> 00:12:51.672 
點擊可以觸發鼓點循環的播放

00:12:52.739 --> 00:12:56.009 
現在讓我們來看看
怎樣應用一些特效結點

00:12:56.210 --> 00:12:57.411 
以及怎樣將它們加到圖表中

00:12:57.945 --> 00:12:59.746 
首先我播放一次無特效音樂

00:12:59.813 --> 00:13:01.114 
然後我再加幾個特效

00:13:01.181 --> 00:13:02.683 
這樣方便大家聽出它的作用

00:13:09.790 --> 00:13:13.660 
利用高通率波器濾除大部分鐃鈸的聲音

00:13:13.994 --> 00:13:15.729 
以及其他高頻聲音

00:13:17.431 --> 00:13:19.600 
聲音略有延遲
在這個屋子裏不是很聽得清楚

00:13:22.936 --> 00:13:24.371 
這段音樂就播放到這兒我們繼續

00:13:24.872 --> 00:13:26.106 
現在我在向大家展示

00:13:26.173 --> 00:13:29.443 
在iPad上運行音頻擴展單元

00:13:29.510 --> 00:13:31.078 
這將會是它的處女秀

00:13:32.112 --> 00:13:33.881 
這是一首失真的演示

00:13:34.681 --> 00:13:37.584 
當選擇之後大家可以看到

00:13:37.651 --> 00:13:40.420 
音頻單元所提供的所有出廠預置的列表

00:13:41.255 --> 00:13:44.091 
這裏麪包含了一些鼓點特別明顯的方案

00:13:44.358 --> 00:13:47.160 
也包含了一些非常狂野的設置
比如外星人的叨叨聲

00:13:48.462 --> 00:13:49.663 
剛纔道格提到

00:13:49.830 --> 00:13:54.067 
第三代音頻單元
在iOS上有自定義界面

00:13:54.568 --> 00:13:56.036 
我將向大家演示

00:13:56.103 --> 00:13:57.905 
我繼續演示點擊視圖按鈕

00:13:58.405 --> 00:14:02.476 
我們所完成的是從音頻單元中

00:14:02.543 --> 00:14:04.478 
加載視圖控制器的動作

00:14:04.545 --> 00:14:08.382 
我將它作爲子視圖控制器
安裝在App中

00:14:08.448 --> 00:14:11.852 
我們首次在主機中擁有

00:14:11.919 --> 00:14:13.921 
帶有UI的內置音頻單元

00:14:15.088 --> 00:14:19.459 
我們有一個很大的滑動條
對不起 是按鈕

00:14:19.526 --> 00:14:21.795 
可以用來控制失真的量

00:14:22.863 --> 00:14:24.464 
請允許我繼續我將播放這段聲音

00:14:24.531 --> 00:14:25.933 
以便諸位能親耳判別

00:14:43.984 --> 00:14:45.452 
這真的很有趣

00:14:45.519 --> 00:14:47.788 
我們可以在一個主應用中

00:14:47.855 --> 00:14:52.326 
流暢地使用多點觸控的UI

00:14:52.392 --> 00:14:54.528 
而且省去了很多麻煩

00:14:54.795 --> 00:14:57.064 
過去我們還得切換到另一個App

00:14:57.130 --> 00:14:59.032 
搗鼓半天再切回主應用

00:14:59.366 --> 00:15:01.268 
開始錄音後再切換回去

00:15:01.335 --> 00:15:03.070 
現在你再也不必重複這些步驟了

00:15:09.042 --> 00:15:09.877 
謝謝

00:15:10.744 --> 00:15:12.379 
我還想指出

00:15:12.446 --> 00:15:15.849 
這個音頻單元正是剛纔道格在
Logic裏面播放演示中 

00:15:15.916 --> 00:15:17.551 
使用的那個音頻單元

00:15:17.951 --> 00:15:20.954 
事實上 音頻單元的源代碼完全一樣

00:15:21.021 --> 00:15:22.322 
無需再做修改

00:15:22.890 --> 00:15:26.560 
編碼也十分相似因爲編寫過程中

00:15:26.627 --> 00:15:28.495 
我使用了
Core Animation

00:15:28.562 --> 00:15:30.831 
以使API更爲便攜

00:15:31.498 --> 00:15:33.300 
要將這個音頻單元植入iOS 

00:15:33.367 --> 00:15:36.937 
唯一需要做的必要改變就是事件模型

00:15:37.004 --> 00:15:39.473 
我們需要用UIKit裏的觸摸事件

00:15:39.540 --> 00:15:44.978 
代替桌面的APPkit鼠標事件

00:15:45.512 --> 00:15:47.581 
說真的 諸位有機會利用一點點改變

00:15:47.648 --> 00:15:50.384 
就可以在桌面和iOS上

00:15:51.151 --> 00:15:54.221 
同時發佈一個音頻單元

00:15:55.189 --> 00:15:56.023 
非常感謝

00:15:57.224 --> 00:15:58.158 
現場交還給道格

00:16:01.328 --> 00:16:02.162 
感謝邁克爾

00:16:05.666 --> 00:16:08.802 
我想和大家探討一下

00:16:09.169 --> 00:16:11.605 
不使用
AVAudioEngine的情況下

00:16:11.672 --> 00:16:13.640 
怎樣在主操作程序中
使用音頻單元的問題

00:16:14.441 --> 00:16:18.145 
在使用AU音頻單元類

00:16:18.545 --> 00:16:20.614 
異步創建一個組件描述實例時

00:16:20.681 --> 00:16:21.882 
我們會使用類似的方法

00:16:21.949 --> 00:16:22.783 
請看那裏

00:16:23.550 --> 00:16:26.720 
對於還在使用二代主機的人來說

00:16:27.054 --> 00:16:29.890 
我們最簡單的翻譯途徑是

00:16:29.957 --> 00:16:32.392 
使用音頻組件進行實例化

00:16:32.793 --> 00:16:34.928 
我們將細緻探討該問題

00:16:37.631 --> 00:16:39.433 
現在 我想和大家探討一下

00:16:40.300 --> 00:16:42.069 
用擴展服務進程替代插件

00:16:42.135 --> 00:16:45.305 
加載到主機進程中的問題

00:16:47.074 --> 00:16:50.310 
任何接觸過音頻單元的人都清楚

00:16:50.377 --> 00:16:52.312 
利用我們現有的插件模型

00:16:52.646 --> 00:16:55.449 
插件總是加載到主機進程中

00:16:55.883 --> 00:16:59.553 
對於三代主機來說也是這樣

00:16:59.786 --> 00:17:02.055 
如果是一個二代插件

00:17:02.389 --> 00:17:05.526 
可能是iOS上使用的蘋果插件

00:17:05.592 --> 00:17:09.128 
也可能是OS X上使用的第三方插件

00:17:09.796 --> 00:17:12.799 
但不論哪種情形都是二代音頻單元

00:17:12.866 --> 00:17:15.368 
不需要考慮其他因素
始終是加載到主機進程中的

00:17:17.003 --> 00:17:19.873 
現在三代音頻單元講起來

00:17:19.940 --> 00:17:21.008 
略微有點複雜

00:17:21.675 --> 00:17:25.345 
在初始狀態下三代音頻單元加載到

00:17:25.412 --> 00:17:28.080 
一個獨立的擴展服務進程

00:17:28.448 --> 00:17:31.185 
這張圖表顯示的是在Logic
出現之前我們所見情形

00:17:32.686 --> 00:17:35.656 
對於二代和三代主機來說

00:17:35.722 --> 00:17:36.990 
這都是正確的

00:17:38.091 --> 00:17:43.197 
現在OS X上插件只能

00:17:43.263 --> 00:17:46.099 
直接加載到主機進程中

00:17:46.600 --> 00:17:50.103 
爲了使之成爲可能需要同時使用到二者

00:17:50.637 --> 00:17:54.007 
在實例化音頻單元時

00:17:54.074 --> 00:17:55.876 
主機需要將選項傳遞給

00:17:55.943 --> 00:17:58.812 
我們剛纔所見到的
任意一種異步創建方法

00:17:59.980 --> 00:18:02.182 
你可以看到新標記的名稱

00:18:02.249 --> 00:18:03.517 
叫做進程加載音頻單元

00:18:04.051 --> 00:18:07.554 
還需要利用

00:18:07.888 --> 00:18:11.625 
音頻組件包列表條目

00:18:11.859 --> 00:18:13.160 
進行特殊的打包和授權

00:18:13.861 --> 00:18:15.863 
如果同時使用

00:18:16.230 --> 00:18:19.766 
那麼框架將把插件

00:18:19.833 --> 00:18:21.268 
加載到主機進程

00:18:21.401 --> 00:18:23.837 
主機將會直接與插件的

00:18:24.271 --> 00:18:26.773 
AU音頻單元子類進行通訊

00:18:30.010 --> 00:18:33.046 
作爲一個主機編寫人員
你爲什麼想這樣做呢

00:18:33.547 --> 00:18:36.216 
原因是要在安全性和性能之間

00:18:36.316 --> 00:18:37.384 
進行權衡

00:18:37.885 --> 00:18:41.255 
毋庸置疑 向App中添加
第三方代碼會有安全風險

00:18:41.321 --> 00:18:46.059 
如果在App中崩潰

00:18:46.393 --> 00:18:48.529 
用戶埋怨的將會是你

00:18:48.595 --> 00:18:50.063 
而不是特效不佳的插件

00:18:51.532 --> 00:18:54.201 
但另一方面 出於性能考慮

00:18:54.268 --> 00:18:57.838 
如果你在做主機

00:18:57.905 --> 00:19:00.641 
你想向進程中加載插件

00:19:00.774 --> 00:19:03.043 
因爲與獨立的擴展服務程序通訊

00:19:03.110 --> 00:19:04.244 
會造成一些間接損耗

00:19:04.845 --> 00:19:07.181 
我們以40微秒

00:19:07.281 --> 00:19:09.383 
爲一個渲染週期進行了計算

00:19:09.950 --> 00:19:12.452 
你可以自行計算一下

00:19:12.519 --> 00:19:14.788 
這在你的主機中有多麼重大的意義

00:19:15.355 --> 00:19:19.526 
可能還需要與一些
程序外的插件進行通訊

00:19:20.060 --> 00:19:21.662 
你還需要把這部分算上

00:19:22.229 --> 00:19:23.664 
此外你預期渲染多少聲頻

00:19:23.730 --> 00:19:26.867 
同樣也是需要考慮的因素

00:19:27.668 --> 00:19:33.674 
比如 如果以32幀這樣
在每個渲染循環之間間隔爲1毫秒

00:19:34.007 --> 00:19:36.543 
因此40微秒的損耗將

00:19:36.610 --> 00:19:38.512 
佔據高達5.5%的比例

00:19:40.414 --> 00:19:43.217 
如果你是主機編寫人員
你需要做出這樣的權衡

00:19:44.985 --> 00:19:46.353 
我之前提到過

00:19:46.420 --> 00:19:49.489 
現有的二代音頻單元主機

00:19:49.857 --> 00:19:52.125 
在與三代音頻單元共存時需要幾處改變

00:19:52.192 --> 00:19:53.994 
以下便是需要改變的地方

00:19:55.229 --> 00:19:58.565 
我提到了音頻組件描述標記

00:19:59.166 --> 00:20:01.635 
這裏便是組件標記

00:20:01.702 --> 00:20:04.638 
這是一種稱爲異步實例化需求的新標記

00:20:05.239 --> 00:20:09.576 
它適用於多數
哪怕不是全部的三代音頻單元

00:20:10.010 --> 00:20:13.146 
如果你在組件描述中看到了這個標記

00:20:13.213 --> 00:20:16.550 
你就必須使用新的音頻組件實例化方法

00:20:16.950 --> 00:20:19.019 
而不是音頻組件新實例

00:20:21.021 --> 00:20:23.757 
類似的在二代主機上

00:20:24.391 --> 00:20:27.361 
如果你想進入一個
音頻單元的視圖控制器

00:20:28.161 --> 00:20:31.698 
你也必須使用一種新的異步方法

00:20:32.099 --> 00:20:34.801 
有一種新的屬性請求視圖控制器

00:20:35.269 --> 00:20:36.503 
也是異步的

00:20:36.570 --> 00:20:38.906 
你可以在音頻單元屬性h部分中

00:20:39.106 --> 00:20:41.241 
詳細閱讀

00:20:43.610 --> 00:20:46.180 
關於這些異步方法

00:20:46.580 --> 00:20:49.883 
你可以利用二代單元使用新的方法

00:20:49.983 --> 00:20:54.688 
但如果有標記那就必須使用三代單元

00:20:56.190 --> 00:20:57.658 
我們的思路是

00:20:57.991 --> 00:21:01.929 
我們這麼做的動機是
因爲這樣能提高響應能力

00:21:02.229 --> 00:21:04.932 
如果實例化音頻單元需要半秒

00:21:04.998 --> 00:21:08.569 
如果你釋放主線程

00:21:09.203 --> 00:21:11.638 
你的主應用 儀表或者其他動畫

00:21:11.705 --> 00:21:13.307 
將繼續流暢運行

00:21:14.441 --> 00:21:16.944 
尤其是在更新現有代碼時

00:21:17.010 --> 00:21:21.381 
這也正是我在測試內測代碼時

00:21:21.448 --> 00:21:23.417 
做的第一件事

00:21:23.483 --> 00:21:24.718 
就像坐在那兒

00:21:24.785 --> 00:21:27.054 
乾等主線程完成異步操作

00:21:27.721 --> 00:21:28.822 
千萬別這麼幹

00:21:28.922 --> 00:21:33.727 
因爲這樣不僅會打亂
你正在製作的任何圖表

00:21:34.194 --> 00:21:36.563 
而且會擾亂框架的基礎程序

00:21:37.130 --> 00:21:40.968 
而這些可能是音頻單元
實例化中所必要的

00:21:41.368 --> 00:21:43.770 
如果你乾等主線程那麼你將會陷入僵局

00:21:43.971 --> 00:21:44.805 
千萬別這麼幹

00:21:47.241 --> 00:21:49.376 
現在我們把話題

00:21:49.443 --> 00:21:52.980 
從主機音頻單元轉到

00:21:53.046 --> 00:21:55.215 
使用三代API創建音頻單元上來

00:21:57.317 --> 00:22:02.055 
首先考慮到新的音頻單元模型
是基於應用擴展的

00:22:02.222 --> 00:22:04.258 
我們簡單聊一聊應用擴展

00:22:05.459 --> 00:22:09.997 
應用擴展是appex.文件類型擴展

00:22:10.364 --> 00:22:13.600 
Xcode將把它們嵌入
App插件條目中

00:22:14.034 --> 00:22:18.505 
我們可以看到系統是如何

00:22:18.906 --> 00:22:21.542 
將它們加載到獨立的擴展服務進程中的

00:22:22.075 --> 00:22:26.313 
你可以在應用擴展編寫指南中

00:22:26.580 --> 00:22:28.482 
讀到應用擴展的全部細節

00:22:31.218 --> 00:22:35.489 
我們新的樣本代碼
項目音頻單元v3示例

00:22:35.956 --> 00:22:38.825 
包含了一段叫做
Filter Demo的

00:22:38.892 --> 00:22:39.927 
示例音頻單元執行

00:22:42.663 --> 00:22:43.964 
當你研究樣本項目時

00:22:44.031 --> 00:22:46.800 
你會發現
Filter Demo有三個目標

00:22:47.301 --> 00:22:49.303 
它有我們所說的容器App

00:22:50.070 --> 00:22:54.708 
裏面有有應用擴展

00:22:55.142 --> 00:22:58.245 
和普通代碼的框架

00:22:58.612 --> 00:23:01.815 
App和擴展都鏈接到框架中

00:23:03.483 --> 00:23:06.753 
在框架內 我們有兩種主要的類別

00:23:07.120 --> 00:23:08.856 
一種是
AU v3 Filter Demo

00:23:09.289 --> 00:23:11.425 
是AU音頻單元的子類別

00:23:11.692 --> 00:23:13.927 
還有一種是
Filter Demo視圖控制器

00:23:14.761 --> 00:23:18.498 
控制着音頻單元的自定義界面

00:23:20.501 --> 00:23:22.636 
這麼做最酷的一面就是

00:23:23.070 --> 00:23:26.907 
我們開發了

00:23:27.341 --> 00:23:30.010 
屬於自己的信號處理和視圖代碼

00:23:30.811 --> 00:23:33.914 
我們可以完全在
自己App的環境中完成

00:23:33.981 --> 00:23:36.683 
因此我們不再是
在獨立的SPC服務進程中清除bug

00:23:36.750 --> 00:23:38.652 
而是在與我們自己的
App交互過程中清除bug

00:23:38.719 --> 00:23:39.620 
開發屬於自己的代碼

00:23:40.521 --> 00:23:43.190 
我們還讓用戶在打開App時

00:23:43.257 --> 00:23:44.525 
覺得看起來很不錯

00:23:44.591 --> 00:23:46.627 
這並不僅僅是一種爲了
別人而設計的插件

00:23:47.127 --> 00:23:49.930 
我們也不是通過複製代碼

00:23:49.997 --> 00:23:51.298 
才實現這一目標

00:23:52.432 --> 00:23:57.237 
這在OS X上還有一個額外的好處

00:23:57.771 --> 00:24:00.507 
如果我們想的話

00:24:00.707 --> 00:24:03.310 
我們可以指定這一框架
成爲主進程加載束

00:24:07.447 --> 00:24:09.049 
讓我們看看應用擴展

00:24:09.116 --> 00:24:11.952 
這裏有一個包含很多
重要條目的info plist

00:24:12.352 --> 00:24:15.489 
NSExtensionPointIdentifier
告訴系統

00:24:15.556 --> 00:24:18.992 
這是什麼樣的擴展

00:24:19.393 --> 00:24:21.161 
主故事板告訴系統

00:24:21.228 --> 00:24:24.064 
當打開我的擴展服務進程時打開故事板

00:24:25.199 --> 00:24:28.101 
最後 還有一個音頻組件序列告訴系統

00:24:28.402 --> 00:24:32.139 
這是我在註冊的

00:24:32.673 --> 00:24:33.707 
音頻組件描述

00:24:37.311 --> 00:24:40.614 
簡單提示一下在你的故事板中

00:24:40.681 --> 00:24:44.518 
你必須明確你的自定義類

00:24:44.651 --> 00:24:47.454 
如果你要把它嵌入一個獨立框架

00:24:47.521 --> 00:24:49.323 
你需要明確是哪個模塊

00:24:50.490 --> 00:24:53.227 
就像我們這裏的一樣

00:24:53.293 --> 00:24:54.494 
擴展本身其實沒有代碼

00:24:54.561 --> 00:24:56.196 
有的只是一小部分確保裏面有代碼

00:24:56.864 --> 00:24:59.066 
我們要鏈接
Filter Demo框架

00:24:59.166 --> 00:25:00.367 
這裏的都是好東西

00:25:00.901 --> 00:25:03.704 
我們有一個全局變量來指向它

00:25:06.373 --> 00:25:07.941 
讓我們回到框架

00:25:09.376 --> 00:25:10.744 
框架中的主類別是

00:25:10.811 --> 00:25:13.313 
Filter Demo視圖控制器

00:25:13.814 --> 00:25:15.382 
在擴展術語中

00:25:15.449 --> 00:25:17.317 
這是擴展的首要類別

00:25:17.751 --> 00:25:20.521 
創建或者加載擴展時

00:25:20.921 --> 00:25:22.756 
系統都會創建一個

00:25:22.823 --> 00:25:24.591 
屬於這個首要類別的實例

00:25:25.192 --> 00:25:26.593 
它有兩個主要任務

00:25:26.894 --> 00:25:30.063 
它創建AU音頻單元的子類別

00:25:30.497 --> 00:25:33.500 
比如你所預見的視圖控制器

00:25:33.567 --> 00:25:36.303 
它創建並管理插件定製界面

00:25:38.438 --> 00:25:41.542 
這是Filter Demo
視圖控制器類別定義

00:25:42.643 --> 00:25:44.878 
從AU視圖控制器演變而來

00:25:45.579 --> 00:25:48.649 
本質上是一種NS或者UI視圖控制器

00:25:49.483 --> 00:25:51.718 
還使用了一種叫做

00:25:51.919 --> 00:25:53.420 
AU音頻單元工工廠的協議

00:25:53.921 --> 00:25:57.524 
那是一個簡單的協議
僅僅使用了一種方法 

00:25:59.059 --> 00:26:01.228 
利用組件描述創建音頻單元

00:26:02.563 --> 00:26:04.698 
這一方法的任務是

00:26:04.765 --> 00:26:07.267 
創建AU音頻單元的子類別

00:26:08.702 --> 00:26:10.771 
也就是這裏的
AU v3 Filter Demo

00:26:14.608 --> 00:26:17.578 
現在讓我們看看AU音頻單元的子類別

00:26:19.913 --> 00:26:22.482 
由於種種原因我們只簡單地探討一下

00:26:22.950 --> 00:26:27.554 
這些實際上是內嵌的C++類別或對象

00:26:28.021 --> 00:26:31.391 
所有算法都是在濾波器
DSP kernel中進行的

00:26:33.260 --> 00:26:34.328 
我們一會兒可以聽到

00:26:34.394 --> 00:26:36.129 
這比單是看它的代碼有趣多了

00:26:37.965 --> 00:26:42.803 
我們有一些處理總線的代碼

00:26:43.136 --> 00:26:47.541 
這是特效它有一個輸入一個輸出

00:26:47.608 --> 00:26:51.011 
我們的基本類別需要
我們提供一連串的總線

00:26:51.111 --> 00:26:52.746 
從而有支持的數字

00:26:53.514 --> 00:26:55.449 
我們有所謂的參數樹

00:26:56.450 --> 00:26:57.918 
稍後我們會弄清它是指什麼

00:26:58.485 --> 00:26:59.486 
這是初始化器

00:27:00.587 --> 00:27:04.324 
我們要做的第一件事就是
初始化我們的輸入和輸出總線

00:27:05.058 --> 00:27:07.594 
然後將它們彙總到總線序列

00:27:09.096 --> 00:27:12.132 
這些總線序列都包含一個單獨的總線

00:27:16.103 --> 00:27:18.338 
現在我們看看參數

00:27:18.939 --> 00:27:21.575 
每個參數都是一個對象

00:27:21.975 --> 00:27:26.346 
每個對象你都可以把它想成

00:27:26.647 --> 00:27:27.848 
連接執行和主機之間的橋樑

00:27:27.915 --> 00:27:30.517 
中間是參數對象

00:27:30.884 --> 00:27:32.419 
這是一個簡單的低通濾波器

00:27:32.486 --> 00:27:34.087 
只有兩個參數

00:27:34.354 --> 00:27:36.089 
截止頻率和停留

00:27:36.924 --> 00:27:39.159 
每個參數都有標識符

00:27:39.426 --> 00:27:41.161 
這裏我們說截止

00:27:41.428 --> 00:27:42.996 
它有一個本地化的名字

00:27:43.063 --> 00:27:44.798 
我們做的不對這裏沒有進行本地化

00:27:46.099 --> 00:27:46.934 
它有地址

00:27:47.000 --> 00:27:48.335 
我們簡要探討一下它

00:27:48.936 --> 00:27:50.704 
排列這些單元或者標記

00:27:51.071 --> 00:27:53.874 
在使用二代音頻單元時

00:27:54.007 --> 00:27:56.610 
你會覺得這些標記是一樣的

00:27:57.377 --> 00:27:59.379 
這樣我們創建了
我們的第一個參數

00:27:59.913 --> 00:28:02.716 
我們會以幾乎一樣的方式
創建第二個參數

00:28:03.851 --> 00:28:06.653 
最後我們可以創建我們自己的參數樹

00:28:07.221 --> 00:28:09.723 
將這兩個參數排成序列

00:28:11.124 --> 00:28:14.428 
這樣我們就有了我們自己的參數樹
我們想要將它接通

00:28:14.761 --> 00:28:17.264 
以便與我們的DSP代碼相連

00:28:19.132 --> 00:28:21.535 
我們的方法是在參數樹中

00:28:21.802 --> 00:28:25.572 
安裝一個叫做執行器值觀測器的塊

00:28:26.874 --> 00:28:30.277 
只要是主機或界面參數改變

00:28:30.344 --> 00:28:33.881 
這個塊在任何時候都可以被調動

00:28:34.548 --> 00:28:37.150 
因此 針對這種改變

00:28:37.451 --> 00:28:40.454 
我們僅僅需要在我們的
DSP kernel中設置新的值

00:28:40.988 --> 00:28:43.390 
可以立刻獲得音響特效

00:28:45.592 --> 00:28:47.661 
反過來有時這個參數樹

00:28:47.728 --> 00:28:51.398 
需要信號處理過程

00:28:51.465 --> 00:28:52.766 
更新參數值

00:28:53.333 --> 00:28:55.068 
它從DSP

00:28:56.937 --> 00:28:59.039 
獲取當前值

00:28:59.106 --> 00:29:00.774 
將它反饋到參數樹上

00:29:04.077 --> 00:29:07.080 
這是一種重要的替換值方法

00:29:07.581 --> 00:29:10.117 
如果你熟悉二代音頻單元API

00:29:10.184 --> 00:29:12.753 
這一過程被稱爲音頻單元初始化

00:29:13.854 --> 00:29:17.191 
這在Objective-C
可不是一個很好的名字

00:29:17.691 --> 00:29:19.993 
所以我們決定要將它具體化

00:29:20.961 --> 00:29:25.132 
初始化的時間就是用來

00:29:25.465 --> 00:29:28.669 
準備渲染和分配有關的渲染資源

00:29:29.937 --> 00:29:33.640 
比如緩衝 DSP狀態 等等

00:29:34.541 --> 00:29:37.644 
我們首要做的事情被稱爲基礎類別方法

00:29:39.112 --> 00:29:42.583 
然後我們要求總線分配存儲空間給插件

00:29:42.783 --> 00:29:44.651 
以便聲頻輸入

00:29:45.786 --> 00:29:49.456 
我們可以初始化我們的信號處理

00:29:50.457 --> 00:29:55.629 
要根據現在輸出總線的通道數和採樣率

00:29:58.465 --> 00:30:01.268 
因此我們有一種完全相反的方法

00:30:01.568 --> 00:30:03.504 
叫做解除渲染資源分配

00:30:03.871 --> 00:30:05.739 
我們把這還稱爲基礎類

00:30:06.106 --> 00:30:09.510 
原則上撤銷我們
在分配過程中所做的一切

00:30:12.546 --> 00:30:16.116 
利用塊進行渲染過程

00:30:16.884 --> 00:30:21.421 
在每個渲染循環中都會用到

00:30:21.522 --> 00:30:24.424 
但我們需要在渲染開始前就提供塊

00:30:25.792 --> 00:30:29.129 
我們捕獲C++代碼

00:30:29.663 --> 00:30:32.599 
改成作爲指針局部變量

00:30:33.233 --> 00:30:37.871 
原因是我們需要在實時環境中操作塊

00:30:38.205 --> 00:30:41.808 
這對於處理任何Objective-C
對象來說都不安全

00:30:42.309 --> 00:30:46.146 
運行時間會阻塞

00:30:46.480 --> 00:30:49.283 
造成音頻故障

00:30:50.083 --> 00:30:54.688 
因此我們將再次捕獲C++代碼變量

00:30:57.391 --> 00:30:59.026 
然後在放回塊

00:30:59.927 --> 00:31:02.029 
它將反饋AU音頻單元狀態

00:31:03.096 --> 00:31:05.566 
如果你熟悉二代API

00:31:05.632 --> 00:31:07.467 
參數大體一致

00:31:07.835 --> 00:31:10.470 
有時間標記 許多樣本幀

00:31:11.004 --> 00:31:12.472 
一個輸出音頻緩衝表

00:31:13.040 --> 00:31:15.909 
這裏是一個新玩意兒叫做實時事件表頭

00:31:16.877 --> 00:31:19.713 
我將詳細介紹它

00:31:19.780 --> 00:31:22.583 
它還與計劃參數和MIDI事件相關

00:31:25.552 --> 00:31:27.354 
最後是推動輸入塊

00:31:27.888 --> 00:31:31.058 
主機告訴我們這叫音頻單元的執行器

00:31:31.124 --> 00:31:33.927 
獲得輸入的來源

00:31:35.596 --> 00:31:37.097 
因此在輸入塊的內部

00:31:37.431 --> 00:31:40.868 
我們要做的第一件事

00:31:41.134 --> 00:31:46.106 
就是將推動輸入塊交給輸入C++對象

00:31:46.340 --> 00:31:49.476 
並且要求輸入塊爲
渲染循環抓取音頻輸入

00:31:51.044 --> 00:31:53.280 
隨後我們清理清理緩衝

00:31:53.347 --> 00:31:56.583 
我們再把它們交給DSP狀態

00:31:57.851 --> 00:32:03.323 
最後 DSP狀態爲渲染循環處理音頻

00:32:04.391 --> 00:32:06.793 
緩衝器已經收到信號

00:32:06.894 --> 00:32:09.963 
只需給它一個時間標記和幀計數

00:32:10.163 --> 00:32:12.432 
以及實時事件的鏈接表

00:32:13.333 --> 00:32:15.502 
這便是這個音頻單元的內容

00:32:15.569 --> 00:32:17.104 
但代碼的全部並不止這些

00:32:17.171 --> 00:32:18.572 
實際信號處理的代碼

00:32:18.639 --> 00:32:19.773 
遠比這多得多

00:32:20.374 --> 00:32:22.342 
但正如我們剛纔講的那樣

00:32:22.743 --> 00:32:24.044 
聽遠比看來得好

00:32:24.111 --> 00:32:25.879 
因此我想再次請回
邁克爾·霍普金斯

00:32:26.513 --> 00:32:29.316 
向我們展示
AU v3 Filter Demo

00:32:32.286 --> 00:32:33.120 
謝謝道格

00:32:40.327 --> 00:32:46.066 
我繼續講 從包含擴展的應用容器開始

00:32:47.234 --> 00:32:49.570 
你將首先看到

00:32:49.636 --> 00:32:51.905 
屏幕左邊是我們的
Filter Demo

00:32:52.272 --> 00:32:54.141 
我們將它分解成代碼樣本

00:32:54.675 --> 00:32:59.313 
右邊是我之前給你們
演示的失真演示應用

00:33:00.347 --> 00:33:02.015 
我將啓動Filter Demo

00:33:03.150 --> 00:33:04.918 
在屏幕的頂部

00:33:04.985 --> 00:33:06.320 
你會看到

00:33:06.386 --> 00:33:07.654 
道格談到的兩個參數

00:33:08.121 --> 00:33:10.390 
在停留參數中有停止點

00:33:10.858 --> 00:33:12.726 
在UI中永一個滑動塊

00:33:12.793 --> 00:33:14.828 
和一個文本域來表示

00:33:15.329 --> 00:33:18.365 
實際上 應用包括了這部分UI 

00:33:18.432 --> 00:33:23.437 
而主屏幕面積較大的圖案

00:33:23.737 --> 00:33:26.139 
實際上是音頻單元

00:33:26.540 --> 00:33:27.875 
嵌入視圖

00:33:29.076 --> 00:33:32.679 
我可以通過拖動滑動條

00:33:32.746 --> 00:33:34.181 
來改變參數的值

00:33:35.249 --> 00:33:39.920 
看有什麼變化應用改變

00:33:40.454 --> 00:33:43.323 
該參數的值也改變

00:33:43.390 --> 00:33:44.858 
視圖也隨參數而更新

00:33:45.592 --> 00:33:47.861 
正如您將看到更新是實時的

00:33:48.529 --> 00:33:51.899 
相反我可以直接

00:33:52.099 --> 00:33:53.267 
點擊和拖動

00:33:53.700 --> 00:33:55.736 
我們嵌入的音頻單元

00:33:56.370 --> 00:33:58.705 
你會注意到當我用手指拖動它時

00:33:58.772 --> 00:34:01.475 
應用接收到參數已經改變的通知

00:34:01.909 --> 00:34:04.511 
然後會依次更新

00:34:05.379 --> 00:34:07.247 
但這是一種沒有音樂的

00:34:07.314 --> 00:34:09.283 
無聊演示 對吧

00:34:09.983 --> 00:34:11.618 
讓我們來聽一聽

00:34:30.637 --> 00:34:32.005 
我能整天做這個

00:34:32.072 --> 00:34:32.906 
你有時間嗎

00:34:35.309 --> 00:34:40.080 
現在真的很酷 很流暢
謝謝

00:34:40.581 --> 00:34:44.685 
用你的手指就可以玩多觸點UI

00:34:44.751 --> 00:34:46.119 
非常有趣

00:34:46.453 --> 00:34:47.621 
很神奇

00:34:47.688 --> 00:34:51.958 
另一件有趣的事是

00:34:52.926 --> 00:34:55.728 
因爲我們以這種方式設計的用戶界面

00:34:55.795 --> 00:35:00.000 
可以適應任何大小尺寸的設備

00:35:00.467 --> 00:35:04.538 
我們以這個iPad爲例

00:35:04.605 --> 00:35:07.608 
旋轉後看到不同的用戶界面

00:35:07.941 --> 00:35:12.379 
從縱向視圖到橫向視圖 反之亦然

00:35:14.581 --> 00:35:17.784 
我們能做到這點是因爲
我們支持自動佈局

00:35:17.851 --> 00:35:20.854 
我們考慮大小等級 

00:35:21.188 --> 00:35:23.757 
但當我們把它放到

00:35:23.824 --> 00:35:26.226 
我們的主應用中

00:35:26.293 --> 00:35:29.229 
而主應用的屏幕專用插件更小
會發生什麼呢

00:35:30.063 --> 00:35:32.199 
所以我返回

00:35:32.699 --> 00:35:34.401 
打開主機

00:35:35.035 --> 00:35:37.404 
我要清除失真樣本

00:35:37.504 --> 00:35:40.440 
嵌入我們的
Filter Demo視圖

00:35:40.507 --> 00:35:41.775 
點擊視圖加載

00:35:42.276 --> 00:35:43.877 
現在你可以看到

00:35:43.944 --> 00:35:50.083 
雖然加載的垂直空間
很有限 水平比較大

00:35:50.651 --> 00:35:52.553 
但是仍能可以運行

00:35:52.619 --> 00:35:55.656 
沒有標籤重疊

00:35:57.691 --> 00:35:59.626 
它仍然完全按我們所期望的運行

00:36:02.162 --> 00:36:04.398 
這是一個奇妙的新技術

00:36:04.464 --> 00:36:06.934 
我們很興奮 終於能夠給你們

00:36:07.201 --> 00:36:10.804 
我都迫不及待地想看看
在你們的iOS應用上運行的情況了

00:36:11.972 --> 00:36:12.806 
謝謝

00:36:16.743 --> 00:36:17.578 
謝謝你 邁克

00:36:20.814 --> 00:36:24.117 
現在我大概講一下關於包含應用

00:36:24.751 --> 00:36:27.154 
這個是插件載體

00:36:27.221 --> 00:36:29.022 
通過快速迭代和快速開發提供協助

00:36:29.656 --> 00:36:33.560 
但你可能考慮在包含
應用裏放置其他東西

00:36:34.061 --> 00:36:36.897 
通過Filter Demo
我們知道有簡單播放引擎

00:36:37.364 --> 00:36:39.900 
而且你還可以加載

00:36:39.967 --> 00:36:41.134 
某些複雜的播放引擎

00:36:42.236 --> 00:36:44.404 
主體應用能滿足你的需求 

00:36:44.471 --> 00:36:47.541 
你可以在其中放置觸摸控制器

00:36:47.841 --> 00:36:49.743 
在插件視圖裏可能沒有空間

00:36:50.043 --> 00:36:51.278 
儲存全部觸摸控制器

00:36:51.345 --> 00:36:54.948 
就算空間足夠 但你可能考慮

00:36:55.349 --> 00:36:56.750 
在包含應用中

00:36:56.817 --> 00:36:57.918 
儲存其他東西

00:36:58.785 --> 00:37:02.189 
這個應用還能儲存文件資料

00:37:02.723 --> 00:37:06.126 
還有壓縮插件視圖的功能

00:37:08.262 --> 00:37:11.231 
下面是關於創建一個應用擴展的總結

00:37:11.865 --> 00:37:15.435 
如果你要在OS X系統
進程上加載構架

00:37:15.502 --> 00:37:18.939 
先拋開Swift語言不講

00:37:19.806 --> 00:37:22.609 
我們也不建議你們在
OS X系統上這樣做

00:37:22.676 --> 00:37:26.146 
因爲Swift API可能會變化

00:37:27.047 --> 00:37:29.917 
如果你開發不兼容
Swift版本一的插件

00:37:29.983 --> 00:37:32.886 
並且加載到使用
Swift其他版本的主機

00:37:32.953 --> 00:37:35.689 
會出現問題

00:37:37.024 --> 00:37:37.858 
情況會很糟糕

00:37:38.725 --> 00:37:43.096 
我們知道你在這兒看到樣本代碼

00:37:43.163 --> 00:37:45.899 
你會試着開發自己的插件

00:37:45.966 --> 00:37:48.902 
你需要知道有三個相關指標需要開發

00:37:49.269 --> 00:37:50.404 
這有一點兒複雜

00:37:50.737 --> 00:37:52.739 
我們計劃開發X code模板

00:37:53.173 --> 00:37:56.043 
但是現在你可以從隨意複製
Filter Demo

00:38:00.214 --> 00:38:03.283 
現在我從主機和實現兩個方面 

00:38:03.817 --> 00:38:07.120 
總體講一下

00:38:07.321 --> 00:38:09.556 
關於現代化AU音頻單元API

00:38:12.793 --> 00:38:15.529 
針對版本2和版本3的屬性

00:38:15.596 --> 00:38:17.998 
我們來做一下比較

00:38:18.632 --> 00:38:21.368 
版本2AU音頻單元API

00:38:21.702 --> 00:38:23.704 
屬性有作用域和元素

00:38:24.204 --> 00:38:26.907 
全局範圍有大量屬性可用

00:38:26.974 --> 00:38:29.009 
所以可以編寫很多代碼

00:38:29.309 --> 00:38:32.279 
K音頻單元全局範圍和元素0

00:38:34.248 --> 00:38:37.150 
在Swift語言中非常折磨人

00:38:37.784 --> 00:38:41.388 
很多的屬性值都是無效指針

00:38:41.922 --> 00:38:44.858 
都出都可以看到無用指標

00:38:44.925 --> 00:38:46.560 
這着實讓我頭疼

00:38:47.327 --> 00:38:50.731 
對這些功能我們爭議頗多

00:38:52.499 --> 00:38:55.002 
相比較之下 在版本3 API裏

00:38:55.469 --> 00:38:57.104 
屬性依舊是那些屬性

00:38:57.938 --> 00:39:01.041 
我們在Objective-C和
Swift語言裏使用了dot語法

00:39:01.408 --> 00:39:04.178 
這樣你就可以以最大幀的AU進行渲染

00:39:05.112 --> 00:39:09.550 
我們還對關鍵值編碼
和關鍵值觀測兼容進行分類

00:39:09.616 --> 00:39:12.953 
這樣你就可以對鍵使用值

00:39:13.053 --> 00:39:15.789 
對關鍵路徑添加觀測器

00:39:16.790 --> 00:39:20.294 
我們還對總線陣列添加
專門的KVO方法

00:39:20.661 --> 00:39:24.264 
對所有的總線添加觀測器這樣你就不必

00:39:24.331 --> 00:39:26.233 
同時時刻注意總線

00:39:26.667 --> 00:39:30.070 
還可以在總線上添加KVO觀測器

00:39:30.571 --> 00:39:34.174 
免去了許多麻煩

00:39:35.742 --> 00:39:38.579 
說到總線 在新的API中

00:39:38.645 --> 00:39:40.380 
這些都已經進行了完善

00:39:40.781 --> 00:39:42.716 
我們擁有AU音頻單元總線陣列

00:39:43.350 --> 00:39:46.119 
AU音頻單元有一組輸入總線

00:39:46.186 --> 00:39:47.521 
和一組輸出總線

00:39:48.689 --> 00:39:51.291 
並且總線有兩個主要屬性

00:39:51.692 --> 00:39:54.027 
他們有一種格式和一個名稱

00:39:54.528 --> 00:39:56.964 
格式由主機處理

00:39:58.665 --> 00:40:01.335 
我們可以拒絕我們不想要的格式

00:40:01.401 --> 00:40:03.704 
版本3的音頻單元使用的格式

00:40:03.770 --> 00:40:04.905 
與版本2 相同

00:40:08.308 --> 00:40:09.376 
讓我們看一下參數

00:40:09.443 --> 00:40:11.278 
在版本2的API和參數中

00:40:11.411 --> 00:40:13.981 
這裏有一些問題

00:40:14.047 --> 00:40:15.349 
因爲我們改變的是屬性

00:40:15.849 --> 00:40:18.952 
這裏有些不實用範圍元素ID元祖

00:40:19.019 --> 00:40:21.321 
此外在較爲複雜的AU中 

00:40:21.855 --> 00:40:23.624 
這裏的位元不足

00:40:24.525 --> 00:40:27.461 
再次我們開發了帶有長參數列表的功能

00:40:27.861 --> 00:40:30.931 
我們也開發了更好的
AU事件監聽器API

00:40:33.567 --> 00:40:36.503 
版本3的API中之前曾在

00:40:38.071 --> 00:40:40.340 
介紹參數樹和
Filter Demo的時候提到

00:40:40.707 --> 00:40:42.142 
當然 這是個完整的參數樹

00:40:42.242 --> 00:40:45.779 
可以對其進行分組 

00:40:45.846 --> 00:40:48.582 
這是有模擬合成器的簡單模擬例子

00:40:48.916 --> 00:40:51.451 
它有振盪器組 過濾組和放大器組

00:40:51.919 --> 00:40:55.556 
這個過濾器和放大器組下還有組

00:40:55.856 --> 00:40:59.726 
在這個顏色最鮮豔盒子下是
參數 波形八度

00:41:00.260 --> 00:41:03.197 
濾波器截止點和共振

00:41:03.263 --> 00:41:06.266 
包線區 維持和釋放

00:41:07.734 --> 00:41:10.637 
這些盒子都是節點  

00:41:10.704 --> 00:41:12.940 
不管是組別還是參數 

00:41:13.006 --> 00:41:17.511 
在參數樹上的節點都有
一個唯一的永久的ID

00:41:17.778 --> 00:41:19.813 
這個像一個C標識符

00:41:21.448 --> 00:41:25.419 
所以用這些唯一的ID
我們可以啓動KVC

00:41:25.485 --> 00:41:27.454 
然後找到想要的參數

00:41:27.788 --> 00:41:32.192 
例如振盪器 波動或者濾波器 包線等

00:41:32.593 --> 00:41:34.828 
這讓那些具有龐大的數據樹

00:41:34.895 --> 00:41:37.030 
更爲複雜的音頻組件

00:41:37.097 --> 00:41:39.499 
變得更爲靈活

00:41:40.534 --> 00:41:41.835 
現在  你會注意到

00:41:41.902 --> 00:41:44.137 
參數有數字地址

00:41:44.271 --> 00:41:48.408 
且是64個位的地址但是在任何時候

00:41:48.475 --> 00:41:52.346 
我們必須認爲這只是暫時地址

00:41:52.813 --> 00:41:54.581 
因爲這些地址不是我們設定的

00:41:56.950 --> 00:41:59.753 
也就是說如果我是一個主應用  

00:41:59.820 --> 00:42:02.122 
我想記錄參數自動化  

00:42:02.456 --> 00:42:06.560 
我應該記錄使用關鍵路徑的自動化參數

00:42:07.094 --> 00:42:10.664 
而不是其地址

00:42:13.700 --> 00:42:15.102 
我之前提到過

00:42:15.802 --> 00:42:20.240 
AU參數對象

00:42:20.340 --> 00:42:24.111 
參數值在主機和視圖之間的通訊中心

00:42:24.411 --> 00:42:27.181 
另一方面 也是音頻單元執行器

00:42:29.750 --> 00:42:31.852 
現在  從主機的角度來看

00:42:32.186 --> 00:42:36.256 
參數對象屬性 包括值

00:42:36.323 --> 00:42:38.692 
還有最小值和最大值等等

00:42:39.459 --> 00:42:42.062 
所以我們可進行設置

00:42:42.462 --> 00:42:44.932 
並獲得使用點記法的參數值

00:42:45.832 --> 00:42:48.368 
現在我們仍然可以按照
防止反饋迴路發生的方式

00:42:48.435 --> 00:42:50.304 
進行數值設置  

00:42:51.104 --> 00:42:56.243 
這在性能和UI簡化方面都有優勢

00:42:56.410 --> 00:42:59.546 
我們不希望看到的情況是
在我們滑動到下一個畫面後

00:42:59.613 --> 00:43:02.182 
看到與前一張不同的通知

00:43:02.983 --> 00:43:06.486 
所以設置值的方法可以實現這種效果

00:43:07.855 --> 00:43:12.659 
並且在往參數 參數樹
或者參數組添加觀測器後

00:43:12.726 --> 00:43:15.863 
可以看到標誌

00:43:16.864 --> 00:43:19.032 
當我們這樣操作時  

00:43:19.099 --> 00:43:21.335 
我們能返回參數
這就是我們在底部所看到的

00:43:21.835 --> 00:43:24.371 
這裏有個塊稱爲AU參數觀測器

00:43:24.872 --> 00:43:26.173 
通過觀測器 我們能看到

00:43:26.507 --> 00:43:29.309 
參數改變後的地址和新值

00:43:32.079 --> 00:43:35.582 
至於執行方面 我們在
Filter Demo已經瞭解到

00:43:36.049 --> 00:43:38.185 
有執行器 值觀測器 

00:43:38.418 --> 00:43:40.120 
以及值供應塊

00:43:40.721 --> 00:43:42.523 
現在 我們在
Filter Demo中

00:43:42.589 --> 00:43:44.358 
將這些塊安裝到參數樹上

00:43:44.525 --> 00:43:48.061 
也可以安裝到參數樹的任意位置

00:43:48.462 --> 00:43:50.297 
甚至可以安裝到單個參數上

00:43:54.168 --> 00:43:56.103 
我也想展示下在調度參數方面

00:43:56.236 --> 00:43:57.938 
我們已經做到的事情

00:43:58.005 --> 00:43:59.806 
因爲我想在版本2的API 中

00:44:00.174 --> 00:44:02.476 
這是個大的改進

00:44:03.710 --> 00:44:06.280 
我們有主機和執行器

00:44:06.346 --> 00:44:08.215 
可以分別處理不同事件

00:44:08.782 --> 00:44:13.420 
但這裏我們還使用了
AU音頻單元基礎分類

00:44:13.487 --> 00:44:15.255 
從而幫助我們實現該功能

00:44:15.956 --> 00:44:19.993 
所以主機能從
AU音頻單元獲得一個模塊

00:44:20.060 --> 00:44:21.762 
稱之爲計劃參數模塊

00:44:22.496 --> 00:44:26.700 
渲染過程中  調用該模塊

00:44:27.167 --> 00:44:28.802 
精準改變參數

00:44:29.870 --> 00:44:32.739 
所以第一個要做的計劃表
是一個抽樣時間

00:44:33.440 --> 00:44:35.609 
這個計劃表值會累增

00:44:35.676 --> 00:44:38.745 
如果音頻單元使用累增方式

00:44:39.346 --> 00:44:41.882 
例如蘋果婚姻器所做的一樣

00:44:44.251 --> 00:44:46.653 
最後的2個參數  

00:44:46.854 --> 00:44:49.923 
功能參數和參數地址

00:44:49.990 --> 00:44:52.659 
將被改變成新的參數值

00:44:54.228 --> 00:44:55.662 
在執行方面

00:44:55.729 --> 00:44:57.030 
事情略有不同

00:44:57.097 --> 00:45:00.100 
我們從主機那得到的 
並不僅僅是傳遞操作

00:45:00.934 --> 00:45:03.103 
相反基礎類將獲得

00:45:03.170 --> 00:45:06.340 
剛我們在
Filter Demo看到的

00:45:07.341 --> 00:45:08.509 
內部渲染塊

00:45:08.575 --> 00:45:11.512 
它將把只屬於渲染循環的實時事件

00:45:12.179 --> 00:45:14.781 
傳遞到渲染塊上

00:45:15.516 --> 00:45:19.086 
所以基礎類會保證

00:45:19.520 --> 00:45:21.855 
所有待定預訂參量變換計劃表的完整

00:45:22.222 --> 00:45:25.158 
只在渲染時

00:45:25.392 --> 00:45:27.494 
分配相關塊到音頻單元中

00:45:29.897 --> 00:45:31.365 
這就是參數計劃策略

00:45:31.431 --> 00:45:34.201 
在MIDI事件中
我們也做了完全相同的事情

00:45:35.102 --> 00:45:36.403 
主機在開始渲染前

00:45:36.937 --> 00:45:39.173 
從音頻單元獲取了一個塊

00:45:40.007 --> 00:45:42.509 
在渲染時間裏調用那個塊

00:45:43.377 --> 00:45:46.246 
現在你可以看到
我們在音頻單元API版本2中

00:45:46.480 --> 00:45:48.215 
增加了一個叫做網線的功能參數

00:45:49.983 --> 00:45:55.255 
它只有1個MIDI網線 16個通道

00:45:55.689 --> 00:45:59.092 
現在我們有256虛擬MIDI網線

00:45:59.393 --> 00:46:00.894 
如果想要有巨大樣品庫的音頻單元

00:46:01.395 --> 00:46:03.597 
現在可以做到了

00:46:03.830 --> 00:46:07.334 
所有的這些 都可以
在虛擬MIDI網線中進行處理

00:46:09.203 --> 00:46:11.238 
在MIDI事件的執行方面

00:46:11.305 --> 00:46:14.341 
這與計劃參數的實現完全相同

00:46:15.142 --> 00:46:19.012 
基礎類AU 音頻單元保護內部計劃表

00:46:19.813 --> 00:46:23.083 
並僅在應該起作用的時候

00:46:23.617 --> 00:46:28.222 
在渲染循環期間 通過實時事件清單

00:46:28.288 --> 00:46:30.257 
將事件傳遞到內部渲染塊

00:46:32.125 --> 00:46:34.761 
我們認爲這是很大的改善

00:46:34.828 --> 00:46:36.597 
節省了執行器很多工作

00:46:39.099 --> 00:46:43.370 
關於渲染 總的來說 
我們仍然使用拉模式

00:46:43.437 --> 00:46:46.673 
意思就是一個輸出裝置拉一個混音器

00:46:47.074 --> 00:46:49.710 
拉一個特效 拉另一個特效 拉播放器

00:46:49.776 --> 00:46:51.778 
音頻流通過鏈迴流

00:46:52.746 --> 00:46:55.182 
API版本2的不同點是

00:46:55.249 --> 00:46:58.218 
音頻單元需要保持一些狀態

00:46:58.619 --> 00:47:02.356 
這裏需要提到一個概念
即它是否是從其他音頻單元上游

00:47:02.422 --> 00:47:05.993 
或一個功能反饋信號獲得輸入信號

00:47:06.593 --> 00:47:08.195 
API版本3中 就更簡單了

00:47:08.996 --> 00:47:12.432 
AU並不需要保持該狀態

00:47:12.900 --> 00:47:15.302 
我們在Filter Demo中

00:47:15.736 --> 00:47:18.372 
看到的反饋信號來自主機

00:47:18.705 --> 00:47:20.174 
且在每個渲染循環期間進行傳遞

00:47:21.542 --> 00:47:24.845 
其他的 API的功能極其相似

00:47:24.912 --> 00:47:27.481 
這使得我們可以

00:47:27.548 --> 00:47:28.782 
在它們之間快速連接

00:47:32.586 --> 00:47:37.391 
現在 若你的主機是
直接調用AU 音頻單元進行渲染

00:47:37.691 --> 00:47:40.661 
而不是使用AU圖標
或AVAudioEngine

00:47:41.628 --> 00:47:45.832 
這是會調用配置渲染源

00:47:45.899 --> 00:47:49.069 
然後將它們放在渲染塊中

00:47:50.070 --> 00:47:51.672 
你可調用渲染塊進行渲染

00:47:52.706 --> 00:47:54.875 
看起來和內部渲染塊非常相似

00:47:57.477 --> 00:47:59.646 
這些有必要回顧一下

00:47:59.713 --> 00:48:03.283 
在渲染時間出現的
音頻緩衝器的一些規則

00:48:03.951 --> 00:48:06.820 
現在 主機提供了一個
輸出音頻緩衝器清單

00:48:07.354 --> 00:48:11.291 
在輸出音頻緩衝器清單中 
M數據指針可以是0

00:48:12.292 --> 00:48:15.696 
音頻單元必須用一個內部
自備的緩衝器進行取代

00:48:16.496 --> 00:48:19.499 
同時AU必須保證

00:48:19.566 --> 00:48:22.703 
緩衝器持續有效直至下個渲染循環出現

00:48:23.270 --> 00:48:25.038 
以上是全部內容  順便說一下

00:48:25.105 --> 00:48:27.841 
和音頻單元版本2完全相同
我一直在重複強調

00:48:28.509 --> 00:48:29.409 
因爲它真的很重要

00:48:31.445 --> 00:48:34.882 
現在 在渲染塊中有一些規則

00:48:34.948 --> 00:48:37.718 
和輸入緩衝器的規則相似但並不一樣

00:48:38.151 --> 00:48:41.221 
主機提供輸入塊AU調用它輸入

00:48:41.288 --> 00:48:45.125 
當AU調用那個塊進行輸入時

00:48:45.526 --> 00:48:48.462 
它必須爲那個塊提供

00:48:48.662 --> 00:48:52.032 
非0的M數據指針的
有效音頻緩衝器清單

00:48:52.833 --> 00:48:55.602 
現在 主機允許取代儲存器的這些指針

00:48:56.503 --> 00:49:00.774 
即它擁有並可以確保保持有效

00:49:00.841 --> 00:49:04.478 
直至下個渲染循環出現或釋放渲染資源

00:49:05.179 --> 00:49:08.415 
所有這些是爲了達成一項重要目標

00:49:08.482 --> 00:49:11.251 
即減少重複操作

00:49:15.055 --> 00:49:17.524 
好 這裏有些幻燈片

00:49:18.592 --> 00:49:23.263 
讓程序員和大家開開眼

00:49:23.697 --> 00:49:26.667 
音頻渲染幾乎總是

00:49:26.733 --> 00:49:28.669 
在實時路徑環境裏發生的

00:49:28.969 --> 00:49:30.971 
這是個有限制的環境

00:49:31.104 --> 00:49:32.973 
因爲我們無法分配存儲器

00:49:33.540 --> 00:49:36.243 
意思是說我們甚至不需要

00:49:36.310 --> 00:49:38.078 
調用調度異步通信

00:49:38.846 --> 00:49:42.049 
事實上我們不能訪問因爲可能被限制了

00:49:42.649 --> 00:49:47.054 
比如獲取一個互斥量或等一個信號量

00:49:47.421 --> 00:49:51.859 
原因是 若我們進行限制
那麼我們就限制了所有時間

00:49:52.292 --> 00:49:53.861 
然後系統中的音頻渲染路徑

00:49:53.927 --> 00:49:55.696 
將錯過它的截止期限

00:49:56.196 --> 00:49:59.333 
這時故障就會發生

00:50:00.534 --> 00:50:05.038 
所以在使用和調用

00:50:05.372 --> 00:50:08.542 
不好意思 是使用和執行
這些渲染塊時需要非常小心

00:50:10.277 --> 00:50:14.081 
在Filter Demo中你可以
看到我們如何準備一些塊長

00:50:14.281 --> 00:50:17.251 
以致不捕捉到我們自己的目標

00:50:17.317 --> 00:50:20.254 
或任何其他
Objective-C目標

00:50:21.288 --> 00:50:24.324 
在塊中 我們避免了
Objective-C運行時間

00:50:24.391 --> 00:50:27.327 
因爲Objective-C不安全

00:50:27.394 --> 00:50:28.762 
它可以獲得塊

00:50:29.429 --> 00:50:31.932 
不過Swift運行時間也完全相同

00:50:32.399 --> 00:50:37.504 
這也是爲什麼在Filter Demo中
你將看到C++目標

00:50:37.571 --> 00:50:41.775 
我們爲這些C++目標捕獲指針

00:50:42.242 --> 00:50:44.311 
現在如果你討厭C++

00:50:44.578 --> 00:50:46.914 
你也可以用單純功能的C做一樣的事情

00:50:46.980 --> 00:50:48.615 
儘管我不太確定爲什麼你想要那麼做

00:50:51.118 --> 00:50:52.286 
討厭的東西已經說太多了

00:50:52.352 --> 00:50:54.054 
現在有請亞力克·利特爾

00:50:54.154 --> 00:50:57.925 
爲我們展示Apple Music
創建app中的音頻單元擴展

00:51:04.431 --> 00:51:09.269 
謝謝你 道格
我在Apple的音樂創建應用處工作

00:51:09.336 --> 00:51:11.205 
做的事情有
GarageBand和Logic

00:51:11.271 --> 00:51:14.842 
我們很激動有新的音頻單元擴展

00:51:14.908 --> 00:51:17.978 
我們認爲它將爲開發者和用戶

00:51:18.045 --> 00:51:19.847 
提供真正的權利和創造的可能性

00:51:19.913 --> 00:51:21.415 
我會講到

00:51:21.481 --> 00:51:23.550 
我們的一些計劃

00:51:23.984 --> 00:51:27.454 
首先我們計劃支持音頻單元擴展

00:51:27.521 --> 00:51:29.489 
當然是在所有主要應用中支持

00:51:29.556 --> 00:51:32.759 
也就是GarageBand iOS
GarageBand Mac

00:51:32.960 --> 00:51:36.129 
Logic Pro X
Logic Pro 10和Mainstage

00:51:37.631 --> 00:51:42.703 
我們今天要做的是看一些例子

00:51:42.769 --> 00:51:46.240 
一些GarageBand iOS的
非常漂亮的圖片

00:51:46.306 --> 00:51:48.008 
這只是很初級的東西

00:51:48.075 --> 00:51:49.877 
我們會給你們一些概念

00:51:49.943 --> 00:51:51.578 
關於作爲支持音頻單元擴展的主機

00:51:52.279 --> 00:51:53.780 
我們將計劃做什麼

00:51:55.148 --> 00:51:58.919 
首先我們將支持AU工具

00:51:59.219 --> 00:52:01.154 
接下來我要說的例子是

00:52:01.221 --> 00:52:03.624 
關於我們將如何執行這些AU工具的

00:52:05.292 --> 00:52:07.094 
首先用一些圖像

00:52:07.160 --> 00:52:08.896 
來解釋我們將要做什麼  很簡單的

00:52:08.962 --> 00:52:11.832 
但GarageBand
將向視圖控制器進行請求

00:52:11.899 --> 00:52:13.400 
視圖控制器是一個自定義UI

00:52:14.301 --> 00:52:15.969 
等下我們會講到這個

00:52:16.570 --> 00:52:18.539 
將MIDI事件傳遞到音頻單元

00:52:18.605 --> 00:52:22.309 
當然隨後你會收到通過音頻總線的音頻

00:52:24.411 --> 00:52:26.280 
回到約定的圖片

00:52:27.247 --> 00:52:31.151 
GarageBand我們主啓動屏幕

00:52:31.218 --> 00:52:34.588 
進入接觸工具傳送帶

00:52:34.821 --> 00:52:38.525 
這裏有我們所有的接觸工具

00:52:38.592 --> 00:52:40.928 
鍵盤 鼓 小吉他 等等這類東西

00:52:41.828 --> 00:52:45.132 
看左邊  那裏有這個容器

00:52:45.199 --> 00:52:47.501 
若GarageBand看到設備上

00:52:47.568 --> 00:52:49.570 
已裝有音頻單元

00:52:49.636 --> 00:52:51.605 
容器會展示出來

00:52:51.672 --> 00:52:53.674 
我可以滑動到那個容器

00:52:54.274 --> 00:52:55.843 
那是我的音頻單元存在的地方

00:52:56.076 --> 00:52:56.910 
假若我輕敲它

00:52:59.847 --> 00:53:04.051 
可以看到設備上
已經安裝了所有的音頻單元工具

00:53:04.651 --> 00:53:07.054 
現在如果我輕敲其中一個工具

00:53:08.155 --> 00:53:10.224 
我們可以看到一個
大的灰色盒子和一個鍵盤 

00:53:10.691 --> 00:53:13.861 
我們將爲你展示

00:53:14.328 --> 00:53:17.431 
GarageBand裏面漂亮的
內嵌視圖裏的自定義UI

00:53:17.497 --> 00:53:19.666 
我認爲整件事情最酷的部分是

00:53:20.334 --> 00:53:22.503 
我們會在主機裏

00:53:22.569 --> 00:53:25.606 
顯示音頻單元的真實情況

00:53:25.672 --> 00:53:28.742 
我們將爲你提供標準
GarageBand鍵盤

00:53:28.809 --> 00:53:30.978 
以便你可以進行操作

00:53:31.411 --> 00:53:35.315 
我們將記錄MIDI並接收音頻

00:53:36.617 --> 00:53:38.919 
這只是之前說到的亮點而已

00:53:39.553 --> 00:53:41.488 
當你提供這些自定義UI時

00:53:41.555 --> 00:53:44.925 
請確保不會在這裏

00:53:45.092 --> 00:53:47.261 
防止任何自定義
MIDI控制器類型的設備

00:53:47.327 --> 00:53:49.830 
因爲我們不會在
GarageBand捕捉你的MIDI

00:53:51.231 --> 00:53:54.468 
來快速看一下我們在設備上的新改動

00:53:55.402 --> 00:53:59.173 
再一次 限制屏幕空間括大了

00:53:59.239 --> 00:54:01.642 
所以在右上角有個按鈕

00:54:01.742 --> 00:54:03.310 
這裏可以接入控制視圖

00:54:04.044 --> 00:54:06.213 
這是自定義UI

00:54:06.413 --> 00:54:08.582 
那裏所有的控制另外還有一點點空間

00:54:08.649 --> 00:54:10.851 
用戶可以在按鈕底下的鍵盤上操作

00:54:11.518 --> 00:54:14.788 
這或許是我今天講的最重要的幻燈片

00:54:14.855 --> 00:54:17.658 
這是我們在視圖控制器

00:54:17.891 --> 00:54:19.993 
要注意的要點

00:54:20.794 --> 00:54:23.797 
想讓GarageBand
看起來更美觀

00:54:24.298 --> 00:54:25.732 
那就請多注意這些要點

00:54:25.799 --> 00:54:29.736 
我們將一起做一些很酷的事情

00:54:30.370 --> 00:54:32.973 
我們真的很高興可以看到

00:54:33.040 --> 00:54:35.609 
現在用戶可以通過
GarageBand

00:54:35.676 --> 00:54:37.511 
真正地操作

00:54:37.578 --> 00:54:40.180 
音頻單元接口

00:54:40.514 --> 00:54:42.149 
我們也很高興可以和你們一起工作

00:54:42.216 --> 00:54:43.250 
想出很酷的東西

00:54:52.326 --> 00:54:53.160 
謝謝你 亞力克

00:54:54.394 --> 00:54:57.531 
我想你們應該會有些疑問

00:54:57.965 --> 00:54:59.867 
我來猜猜都有哪些

00:55:01.969 --> 00:55:04.838 
iOS上的跨應用音頻怎麼樣

00:55:05.672 --> 00:55:07.241 
這是個老問題了

00:55:08.242 --> 00:55:10.611 
有很多支持它的app

00:55:11.111 --> 00:55:13.881 
根據我們的觀點

00:55:13.947 --> 00:55:17.284 
這個使用了API版本2的部分子集

00:55:17.351 --> 00:55:18.719 
且不支持某些功能

00:55:18.785 --> 00:55:21.455 
比如參數支持 預置 等等

00:55:22.089 --> 00:55:25.058 
我收到這些請求

00:55:25.125 --> 00:55:26.960 
我想我們應該有一個完整的插件模型

00:55:27.394 --> 00:55:28.662 
這就是我們現在所有的

00:55:29.830 --> 00:55:32.266 
我們並不是不贊成跨應用音頻

00:55:32.332 --> 00:55:35.936 
我們只是看得更遠一些

00:55:36.303 --> 00:55:38.739 
通過音頻單元擴展
增加這些以前沒有的功能

00:55:41.441 --> 00:55:43.210 
現在在OS X上

00:55:43.277 --> 00:55:45.012 
若你有主機和音頻單元

00:55:45.345 --> 00:55:47.548 
你或許會考慮兼容性的問題

00:55:48.248 --> 00:55:51.051 
連接橋將解決很多麻煩

00:55:51.118 --> 00:55:54.054 
它們是兼容的我們做了大量的工作

00:55:54.254 --> 00:55:57.391 
儘可能的讓這些東西可以起作用

00:55:58.091 --> 00:56:01.728 
但如果你可以或者需要一些功能時

00:56:01.895 --> 00:56:03.830 
我建議你升級到版本3

00:56:03.897 --> 00:56:06.700 
比如說 你可能想要重做

00:56:06.767 --> 00:56:08.502 
處理MIDI事件的方法或計劃參數

00:56:09.736 --> 00:56:12.439 
關於端口 我們有一個捷徑

00:56:12.506 --> 00:56:15.008 
它叫做AU音頻單元v2連接橋

00:56:15.075 --> 00:56:18.645 
這是一個AU音頻單元子類

00:56:18.712 --> 00:56:21.815 
在AU版本2上執行
所以你可以從那開始

00:56:21.882 --> 00:56:25.752 
並開發出更加全面執行器

00:56:28.522 --> 00:56:30.357 
正如邁克爾剛提到的

00:56:31.225 --> 00:56:34.094 
音頻單元版本3

00:56:34.161 --> 00:56:36.296 
是iOS和OS X之間
主要的交叉平臺

00:56:36.730 --> 00:56:41.468 
AU音頻單元上的信號處理代碼
絕對是最方便的途徑

00:56:41.535 --> 00:56:43.770 
因爲無需進行UI實現

00:56:44.204 --> 00:56:45.539 
或任何依賴設備

00:56:47.474 --> 00:56:51.111 
AU視圖控制器來自UI
或NSViewController

00:56:51.178 --> 00:56:53.180 
所以會感覺有些異類

00:56:53.680 --> 00:56:56.517 
但某些時候可以進入到特定平臺UI

00:56:57.851 --> 00:56:59.686 
我們快沒時間了

00:56:59.853 --> 00:57:03.390 
要講的話估計需要一個小時

00:57:03.457 --> 00:57:06.860 
此刻我建議你參考

00:57:07.561 --> 00:57:08.862 
音頻單元框架上的頁眉文件

00:57:08.996 --> 00:57:13.200 
由於一些歷史原因
你需要連接AudioToolbox

00:57:13.567 --> 00:57:16.803 
主要的信頭文件是AU音頻單元h

00:57:17.738 --> 00:57:20.440 
但Core Audio工具箱框架上
有其他的AU視圖控制器

00:57:20.908 --> 00:57:24.378 
這是帶AU音頻單元組件的
AVFoundation框架

00:57:24.444 --> 00:57:26.947 
所有的這些裏面

00:57:27.347 --> 00:57:32.286 
都有很棒的信頭文件
所以我強烈建議你查看一下

00:57:34.388 --> 00:57:38.225 
最後如果你想要用音頻單元標誌

00:57:38.292 --> 00:57:39.560 
我們還有一個白色版本

00:57:40.027 --> 00:57:43.263 
你可以查看這個鏈接獲取許可

00:57:44.631 --> 00:57:46.099 
以上部分到此結束

00:57:46.466 --> 00:57:48.435 
我們已經看到在iOS上的音頻裏

00:57:48.502 --> 00:57:50.838 
第一次有一個完整的插件模式

00:57:51.205 --> 00:57:54.341 
在OS X的音頻裏
也第一次有一個完整的插件模式

00:57:55.042 --> 00:57:58.445 
通過打包音頻單元成app擴展

00:57:58.679 --> 00:58:01.582 
你就可以在iOS
和OS X App Stores上

00:58:01.849 --> 00:58:03.717 
銷售音頻單元了

00:58:04.618 --> 00:58:09.756 
我們看了帶有
AVAudioEngine的簡單主機應用

00:58:10.257 --> 00:58:12.326 
並添加到新品

00:58:12.693 --> 00:58:14.127 
音頻單元v3樣本之中

00:58:14.862 --> 00:58:17.297 
如果編寫樣品代碼時出現漏洞的話

00:58:17.364 --> 00:58:19.533 
我們鼓勵大家讀一下文件

00:58:20.033 --> 00:58:23.036 
然後在AU主機和實現上試試

00:58:23.103 --> 00:58:25.606 
我知道你一定會這麼做的

00:58:28.942 --> 00:58:34.014 
更多信息 這是我們昨天的部分

00:58:34.882 --> 00:58:35.716 
謝謝