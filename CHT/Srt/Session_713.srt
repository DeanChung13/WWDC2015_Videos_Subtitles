00:00:20.354 --> 00:00:23.857 
Watch Connectivity介紹

00:00:31.665 --> 00:00:32.698 
早上好

00:00:32.966 --> 00:00:35.269 
歡迎來到
Watch Connectivity介紹

00:00:35.435 --> 00:00:36.336 
我叫克里斯

00:00:36.403 --> 00:00:38.038 
今天 我的同事亞歷克斯將和我一起 

00:00:38.105 --> 00:00:40.040 
他隨後會上臺

00:00:40.107 --> 00:00:42.276 
我們很興奮爲你們展示 

00:00:42.342 --> 00:00:47.047 
我們一直在watchOS 2
和iOS 9上做的東西

00:00:47.481 --> 00:00:49.483 
今天 我們要說的是 

00:00:49.550 --> 00:00:51.718 
幫助你們爲Watch app做出

00:00:51.852 --> 00:00:53.887 
更好更有反響的用戶體驗

00:00:55.289 --> 00:00:57.558 
爲了簡單說明我們的出發點

00:00:57.624 --> 00:01:00.561 
watchOS 1
上的世界看起來像什麼

00:01:00.627 --> 00:01:04.331 
之前iOS app
和WatchKit擴展都是依賴

00:01:04.498 --> 00:01:08.302 
iPhone的 且當時主要處理的是
WatchKit app通信 

00:01:08.602 --> 00:01:11.672 
而且這二者都可以共享數據存儲

00:01:12.973 --> 00:01:15.409 
在watchOS 2 
我們已經把WatchKit擴展

00:01:15.475 --> 00:01:19.313 
擴展到Watch之上 
app在Watch可以運行更流暢了

00:01:19.513 --> 00:01:20.848 
這有不少的好處 

00:01:20.914 --> 00:01:23.350 
但是也意味着它們都
各自使用自己的數據存儲

00:01:24.718 --> 00:01:28.155 
顯然 下個問題是 我們如何把數據 

00:01:28.322 --> 00:01:29.723 
搬到Apple Watch上 

00:01:29.923 --> 00:01:31.225 
這是我們今天要討論的內容

00:01:33.327 --> 00:01:37.464 
我們將爲你展示解決
這個問題的兩個主要方法

00:01:37.531 --> 00:01:39.499 
如何將數據移到Watch上 

00:01:39.566 --> 00:01:42.169 
這是新框架
WatchConnectivity

00:01:42.236 --> 00:01:46.473 
我們將它引入了
watchOS 2 和iOS 9

00:01:47.708 --> 00:01:53.313 
然後這是可在Foundation上
獲NSURLSession API

00:01:53.580 --> 00:01:55.682 
也適用於WatchKit擴展 

00:01:56.383 --> 00:01:59.419 
也已經集成到watchOS 2 

00:02:00.821 --> 00:02:03.924 
我想今天要討論的話題適用於

00:02:03.991 --> 00:02:09.729 
大多數Watch app 
對於多數人來說也是適用的

00:02:10.464 --> 00:02:12.799 
今天展示中即將用到的大量示例

00:02:12.866 --> 00:02:14.968 
將會證明這一點

00:02:15.536 --> 00:02:18.405 
你可以看到 這個範圍很廣 
我們希望每個人

00:02:18.472 --> 00:02:21.208 
都可以至少辨認出一種

00:02:22.276 --> 00:02:24.912 
我們先討論
WatchConnectivity

00:02:24.978 --> 00:02:29.449 
這是我們引入watchOS 2 
和iOS 9的新架構

00:02:29.516 --> 00:02:31.618 
它在兩個平臺中都適用 

00:02:31.685 --> 00:02:33.921 
幾乎所有的API在兩邊都適用

00:02:33.987 --> 00:02:39.026 
我們將會看到不少
iPhone專用的 API

00:02:39.092 --> 00:02:42.329 
當你開始採用
WatchConnectivity

00:02:42.396 --> 00:02:44.498 
你想做的第一件事是

00:02:44.565 --> 00:02:46.066 
仔細設置

00:02:46.633 --> 00:02:49.269 
我們建議儘早進行設置

00:02:49.336 --> 00:02:52.005 
在使用app的整個過程中 
在兩方面都要

00:02:52.072 --> 00:02:57.511 
在Watch運行的WatchKit
擴展和在iOS 9 app內部

00:02:57.945 --> 00:03:01.081 
你要確保使用代碼路徑進行設置

00:03:01.148 --> 00:03:02.616 
這樣一來 儘管是在後臺啓動

00:03:02.683 --> 00:03:03.851 
也還是可以被執行

00:03:03.917 --> 00:03:07.321 
所以不要把它放在裏面如視圖
控制器View Did Load內

00:03:07.387 --> 00:03:09.790 
因爲當你在後臺啓動時 
這些是不會被調用的 

00:03:10.757 --> 00:03:12.659 
所以在iOS app中

00:03:12.726 --> 00:03:15.162 
你做的第一件事是查看

00:03:15.229 --> 00:03:16.930 
是否支持WCSession  

00:03:17.164 --> 00:03:19.533 
你或許有一個通用的iOS app

00:03:19.600 --> 00:03:22.269 
意思是代碼可以在iPad上執行 

00:03:22.336 --> 00:03:24.838 
iPad無法使用
WatchConnectivity

00:03:25.305 --> 00:03:29.009 
你在Watch上執行任何工作之前 
請事先檢查一下 

00:03:29.076 --> 00:03:34.815 
因爲我們不想你浪費CPU做無用功

00:03:34.882 --> 00:03:36.350 
下一件事情是創建一個對象實例 

00:03:36.416 --> 00:03:39.086 
你可以通過調用Default
 Session進行創建

00:03:39.920 --> 00:03:43.590 
然後在會話對象上設置指派 

00:03:43.957 --> 00:03:45.859 
最後調用Activate

00:03:45.926 --> 00:03:48.896 
滴啊用後就可以繼續
設置WCSession對象 

00:03:48.962 --> 00:03:52.499 
初始化所有屬性 
而且一旦調用返回 

00:03:52.566 --> 00:03:54.535 
所有屬性將被更新

00:03:54.601 --> 00:03:56.970 
更新爲正確的初始化數值

00:03:58.705 --> 00:04:01.275 
同樣此刻 任何指派回調

00:04:01.341 --> 00:04:03.610 
任何向上尾接
的內容會可以開始進入

00:04:03.944 --> 00:04:04.845 
這是爲什麼你需要

00:04:04.912 --> 00:04:06.947 
儘快執行上述步驟的原因

00:04:07.014 --> 00:04:09.983 
或許有內容正等着上傳到你的app上

00:04:10.551 --> 00:04:12.886 
所以 請確保提前處理這些步驟

00:04:13.687 --> 00:04:15.088 
一旦這些步驟完成

00:04:15.155 --> 00:04:17.891 
下一件你將想做的事情是 
查看會話狀態

00:04:17.958 --> 00:04:22.396 
然後通知你的app  

00:04:22.462 --> 00:04:25.032 
iOS app和the Watch
之間目前的關係如何

00:04:26.099 --> 00:04:30.070 
所以這些
屬性只適用於iPhone app

00:04:30.137 --> 00:04:33.674 
它正在通知iOS與Watch的關係

00:04:34.208 --> 00:04:36.510 
所以沒有必要
在你的Watch app上使用

00:04:36.577 --> 00:04:38.011 
因爲基本上不適用

00:04:39.112 --> 00:04:41.281 
在這個示例中 
 我們將使用一款新聞app

00:04:41.548 --> 00:04:43.383 
一款推送最近

00:04:43.450 --> 00:04:44.685 
有趣文章的應用

00:04:46.053 --> 00:04:49.857 
首先要做的是
執行我們剛纔討論的設置過程

00:04:49.923 --> 00:04:51.558 
這應當在使用應用的時候儘快完成

00:04:51.625 --> 00:04:55.629 
下一步進行設備檢查 
檢查該設備是否與Watch配對？

00:04:55.896 --> 00:04:58.732 
如果未配對 
那麼相當於這是在iPad上運行

00:04:58.799 --> 00:05:00.234 
沒什麼需要做的了

00:05:00.300 --> 00:05:01.335 
你無法進行通訊

00:05:01.802 --> 00:05:04.671 
所以這個時候 你可能
要停止所有在Watch上進行的工作

00:05:05.472 --> 00:05:08.408 
用戶會出去並買個新的Watch 

00:05:08.475 --> 00:05:09.977 
然後執行配對步驟

00:05:10.110 --> 00:05:12.546 
啓動Apple Watch app

00:05:13.680 --> 00:05:14.815 
操作配對 

00:05:14.882 --> 00:05:16.550 
設置這些設備

00:05:17.985 --> 00:05:20.087 
現在當你的app啓動後 

00:05:20.153 --> 00:05:21.955 
你會得到一個指派回調

00:05:22.422 --> 00:05:24.258 
說明Watch狀態會話改變了

00:05:25.058 --> 00:05:27.294 
當你檢查配對屬性的數值時 

00:05:27.361 --> 00:05:28.962 
你會看到返回爲真 

00:05:29.029 --> 00:05:30.430 
因爲設備已經配對了

00:05:31.298 --> 00:05:32.633 
所以 這時候你可以繼續

00:05:32.699 --> 00:05:34.968 
檢查下個屬性 也就是

00:05:35.035 --> 00:05:36.470 
Watch app是否安裝了？

00:05:37.204 --> 00:05:38.739 
如果還未安裝 那麼就沒法通訊 

00:05:38.805 --> 00:05:40.374 
工作到此爲止

00:05:40.674 --> 00:05:44.444 
但是 通過默認設置
Watch app是默認安裝的 

00:05:44.511 --> 00:05:46.580 
但是用戶可能會由於某些原因 
選擇不進行安裝

00:05:46.647 --> 00:05:50.150 
在這種情況下 
用戶將接續執行並進行重新安裝

00:05:50.217 --> 00:05:52.219 
返回Apple Watch app

00:05:53.287 --> 00:05:56.957 
打開設備 
如果你的Apple正在運行 

00:05:57.057 --> 00:05:58.725 
你將再一次獲得指派回調 

00:05:58.792 --> 00:06:00.794 
你就可以檢查該屬性數值了 

00:06:00.861 --> 00:06:03.497 
可見Watch App 
Installed返回爲真

00:06:04.665 --> 00:06:06.800 
現在 你可以進行通訊了

00:06:06.867 --> 00:06:07.935 
這時候說明你可以

00:06:08.001 --> 00:06:10.270 
使用Watch app
開始進行通訊了

00:06:10.337 --> 00:06:13.006 
你需要輸入通訊的內容

00:06:14.641 --> 00:06:17.878 
無論何時一旦Watch App 
Installed值爲True 

00:06:18.946 --> 00:06:22.249 
另個屬性Watch 
Directory URL也可用 

00:06:22.416 --> 00:06:25.686 
你會發現一旦Watch App 
Installed值爲True

00:06:25.752 --> 00:06:28.889 
Watch Directory 
URL將會有一個非0值

00:06:28.956 --> 00:06:32.926 
這將指向在
container創建的一個目錄

00:06:33.760 --> 00:06:35.662 
我們稍微深入地討論一下這個

00:06:36.396 --> 00:06:39.132 
目錄和它的內容 它的使用週期與

00:06:39.199 --> 00:06:41.535 
Watch App
Installed屬性息息相關

00:06:41.602 --> 00:06:45.105 
WatchAppInstalled
值從True變成False 

00:06:45.172 --> 00:06:48.375 
這個目錄和它的所有內容都會消失

00:06:48.742 --> 00:06:50.444 
無論何時 當值爲True時 

00:06:50.511 --> 00:06:53.213 
目錄會再次出現 但是是空目錄

00:06:54.848 --> 00:06:56.783 
我們建議你 僅在數據與

00:06:56.850 --> 00:06:58.886 
你的Watch app
特別實例有關時才使用

00:06:59.152 --> 00:07:00.554 
實例是要說明什麼呢 

00:07:00.754 --> 00:07:03.023 
一些事物 比如最後隊列項目標記

00:07:03.557 --> 00:07:04.791 
就可以存儲在這

00:07:04.858 --> 00:07:07.227 
若用戶未安裝並重新安裝app 

00:07:07.294 --> 00:07:09.763 
那麼Watch app
是從一個空的容器開始的

00:07:09.863 --> 00:07:12.733 
因此
這個目錄以開始是沒有內容的 

00:07:12.799 --> 00:07:16.737 
你需要同步到app通訊的位置

00:07:16.803 --> 00:07:20.274 
其他你可以保存的事物有偏好設置

00:07:20.340 --> 00:07:25.345 
當用戶首次運行iOS app時 

00:07:25.412 --> 00:07:27.881 
你可能想讓他設置一下

00:07:27.948 --> 00:07:29.917 
想要的Watch app體驗

00:07:29.983 --> 00:07:32.519 
或許他不想顯示全部內容 

00:07:32.586 --> 00:07:35.122 
但想要顯示特別主題的前十條新聞 

00:07:35.189 --> 00:07:37.724 
比如國際新聞或體育新聞

00:07:37.791 --> 00:07:39.293 
這個位置就很適合來存儲這些設置

00:07:40.460 --> 00:07:43.964 
同樣 如果你正處理全尺寸的資料 

00:07:44.031 --> 00:07:46.166 
想生成適合Watch尺寸的資料 

00:07:46.333 --> 00:07:49.670 
你要壓縮圖片 音頻 視頻 

00:07:50.470 --> 00:07:53.407 
在提示傳輸時可使用
WatchConnectivity

00:07:53.473 --> 00:07:55.909 
API 將這些資料儲存到這裏 
隨後我們會說到這點

00:07:57.311 --> 00:07:58.979 
所以 這就是Watch 目錄

00:07:59.279 --> 00:08:01.114 
我們建議你將內容存儲在這 

00:08:01.181 --> 00:08:03.650 
因爲隨後我們會將內容清理掉 
如果Watch消失了 

00:08:03.717 --> 00:08:07.354 
如果他未配對他的手錶 
我們將自動清除這些內容

00:08:07.421 --> 00:08:10.657 
這樣就省去了管理的麻煩

00:08:11.225 --> 00:08:15.262 
最後會話狀態屬性是
Complication Enabled

00:08:15.929 --> 00:08:18.832 
用戶並不能
啓動Complication 

00:08:18.899 --> 00:08:22.536 
但可編輯Watch表面然後啓動 

00:08:22.803 --> 00:08:24.805 
之後你會收到同樣的的回調 

00:08:24.872 --> 00:08:26.240 
會話或狀態變換信號

00:08:26.840 --> 00:08:29.343 
當你查看屬性時 現在值將是True

00:08:31.879 --> 00:08:35.515 
你已經設置 會話
WatchConnectivity

00:08:35.982 --> 00:08:38.150 
已知道watch的狀態是什麼的 

00:08:38.217 --> 00:08:42.054 
iOS app
和Watch app 

00:08:42.121 --> 00:08:43.423 
之間是什麼關係

00:08:43.490 --> 00:08:47.327 
下一件事情是
開始將信息傳輸到Watch上 

00:08:47.394 --> 00:08:49.496 
或從Watch
傳輸到iOS app上

00:08:50.030 --> 00:08:53.033 
爲了這麼做 我將邀請亞歷山大 

00:08:53.100 --> 00:08:54.768 
他將爲我們講解通訊API

00:09:05.012 --> 00:09:09.082 
謝謝 好的
所以就像克里斯說 你設置好了會話

00:09:09.583 --> 00:09:12.719 
也已經檢查過 設備已經配對了

00:09:12.786 --> 00:09:15.055 
Apple Watch app
也已經安裝了

00:09:15.422 --> 00:09:17.891 
現在 我們從如何才能

00:09:18.058 --> 00:09:19.293 
在兩臺設備之間進行通訊

00:09:20.894 --> 00:09:23.764 
關於通訊 我們有不少分類

00:09:24.231 --> 00:09:26.700 
第一類是後臺傳輸

00:09:27.467 --> 00:09:29.536 
後臺傳輸意思是說 

00:09:29.603 --> 00:09:33.173 
在收到方看來
內容並不是立即需要的

00:09:34.541 --> 00:09:36.810 
因爲內容不是立即需要的 

00:09:37.077 --> 00:09:40.013 
這意味着在傳輸這些內容時 

00:09:40.080 --> 00:09:42.182 
系統可以處理其他的事情

00:09:43.917 --> 00:09:46.453 
除了後臺傳輸外 我們還將講到

00:09:46.520 --> 00:09:48.055 
交互式信息傳輸

00:09:49.256 --> 00:09:52.326 
交互式信息傳輸是指

00:09:52.392 --> 00:09:55.429 
兩個實時溝通的app之間的通訊

00:09:55.529 --> 00:09:58.832 
所以 這時候兩個app都在使用中
它們來回發送信息 

00:09:59.566 --> 00:10:01.902 
要求響應 之類的事情 

00:10:02.703 --> 00:10:04.104 
這裏有你可能需要使用

00:10:04.171 --> 00:10:05.539 
交互式信息傳輸的一些情況

00:10:05.606 --> 00:10:09.510 
假設你有一個遊戲 用戶正在
同時使用兩個app進行遊戲時候 

00:10:09.977 --> 00:10:11.812 
或者
你正在Apple Watch上 

00:10:12.079 --> 00:10:16.049 
你需要啓動iOS上的一些東西

00:10:16.316 --> 00:10:19.253 
比如你想要觸發iOS設備 

00:10:19.319 --> 00:10:21.321 
以便了解用戶位置

00:10:23.190 --> 00:10:26.159 
我們先來說說第一個 後臺傳輸

00:10:27.294 --> 00:10:31.164 
關於後臺傳輸 首先要講的是

00:10:31.231 --> 00:10:34.268 
app內容的類型 以及用戶如何

00:10:34.334 --> 00:10:36.136 
與這兩臺設備進行互動

00:10:36.803 --> 00:10:39.106 
還是用新聞app的示例 

00:10:39.173 --> 00:10:40.807 
這個新聞app有很多內容

00:10:41.308 --> 00:10:44.545 
它從服務器讀取了不少內容 

00:10:44.912 --> 00:10:47.181 
而且它斷定這些內容

00:10:47.581 --> 00:10:48.782 
對於Watch是有用的 

00:10:49.583 --> 00:10:53.020 
現在
用戶並未在目前情況下使用Watch

00:10:53.353 --> 00:10:56.690 
所以在Watch方面來說 
這些內容並不是立即需要的

00:10:57.257 --> 00:11:00.694 
當然啦iOS app 
這個新聞app 

00:11:00.761 --> 00:11:03.463 
想要挑一些新聞 在系統裏列隊備好

00:11:04.598 --> 00:11:07.134 
以便系統可以挑選對的內容

00:11:07.201 --> 00:11:08.802 
進行傳輸

00:11:09.403 --> 00:11:11.972 
在用戶真的進行接收時

00:11:12.072 --> 00:11:14.641 
在這個
示例中是Apple Watch 

00:11:14.708 --> 00:11:16.510 
系統將考慮電源和性能的情況

00:11:17.411 --> 00:11:20.647 
當條件都正確的時候內容將傳輸

00:11:21.148 --> 00:11:25.152 
它將在接收方這個示例中的
Apple Watch中等待

00:11:25.419 --> 00:11:28.222 
直到用戶啓動接收app  

00:11:28.722 --> 00:11:30.057 
當接收app啓動 

00:11:30.123 --> 00:11:31.692 
內容將被傳輸過去 

00:11:32.192 --> 00:11:33.961 
app也可以更新它的狀態

00:11:36.296 --> 00:11:39.166 
這是後臺傳輸所提供的

00:11:39.433 --> 00:11:41.401 
它允許內容列隊等候

00:11:43.504 --> 00:11:45.939 
系統將爲你傳輸內容

00:11:46.473 --> 00:11:50.277 
這允許了發送方 發送方app退出

00:11:50.777 --> 00:11:52.212 
系統將處理接下來的一切

00:11:52.846 --> 00:11:55.983 
它允許系統挑選合適時間傳輸內容 

00:11:57.317 --> 00:11:59.653 
允許系統將信息存儲到

00:11:59.720 --> 00:12:03.190 
接收方 並等待接收app啓動

00:12:04.525 --> 00:12:07.227 
對於app上有的大部分內容 

00:12:07.528 --> 00:12:10.764 
我們建議你使用後臺傳輸

00:12:12.199 --> 00:12:15.335 
原因是 對於接收方來說 

00:12:15.402 --> 00:12:17.070 
大部分內容並不是立即所需的

00:12:17.137 --> 00:12:20.741 
當然啦 一旦接收app打開 
就需要這些內容了

00:12:22.643 --> 00:12:24.411 
所以 我們來講講具體細節

00:12:25.512 --> 00:12:28.148 
我們有三種不同的後臺傳輸類型

00:12:29.283 --> 00:12:31.919 
第一種是應用上下文

00:12:32.619 --> 00:12:35.289 
應用上下文代表的是app提供給

00:12:35.389 --> 00:12:37.491 
另一方的最有趣的

00:12:37.558 --> 00:12:38.692 
信息單一集合

00:12:39.860 --> 00:12:43.096 
比如說在iOS方面 有個app 

00:12:43.463 --> 00:12:46.633 
它跟蹤用戶位置 根據用戶位置 

00:12:47.100 --> 00:12:50.437 
app挑選該位置附近的一個飯店 

00:12:50.504 --> 00:12:52.072 
並想推薦給用戶

00:12:52.840 --> 00:12:54.942 
除了在iOS方面分享飯店外 

00:12:55.008 --> 00:12:56.977 
也想在
Apple Watch app上

00:12:57.044 --> 00:12:58.378 
顯示這個飯店

00:12:59.112 --> 00:13:00.647 
所以你可以將建議打包到

00:13:00.714 --> 00:13:02.616 
應用上下文中 

00:13:03.183 --> 00:13:04.751 
它將傳輸信息 

00:13:04.818 --> 00:13:07.487 
然後下次
用戶在Apple Watch啓用

00:13:07.688 --> 00:13:10.224 
這個app時 內容就會出現 

00:13:10.290 --> 00:13:11.892 
推薦也會出現

00:13:13.026 --> 00:13:15.796 
可能想使用應用上下文的其他示例 

00:13:16.763 --> 00:13:19.499 
假設在iOS方面 
你有一個社交app 

00:13:19.566 --> 00:13:22.836 
它讀取了一堆的帖子 並確定了

00:13:22.903 --> 00:13:27.641 
10個最有趣的帖子 

00:13:27.708 --> 00:13:30.477 
在Apple Watch設備上展示

00:13:30.711 --> 00:13:32.913 
用戶可看Apple Watch 

00:13:32.980 --> 00:13:34.681 
並立即可以看到有趣的信息了

00:13:35.482 --> 00:13:37.618 
你也可以將這排名前10的帖子

00:13:37.684 --> 00:13:40.721 
打包到應用上下文中
他們將傳輸過去 

00:13:41.922 --> 00:13:44.625 
現在 應用上下文是

00:13:44.691 --> 00:13:46.894 
後臺傳輸最簡單的方法 

00:13:46.960 --> 00:13:48.996 
但如果你需要一些稍微複雜的東西 

00:13:49.363 --> 00:13:51.899 
或你需要進行排隊等候 
而不是信息的一個單一集合

00:13:51.965 --> 00:13:54.635 
我們爲你提供兩種方法

00:13:55.569 --> 00:13:58.138 
第一種是用戶信息傳輸

00:13:58.972 --> 00:14:01.842 
這允許你傳輸你想打包的 

00:14:01.909 --> 00:14:04.244 
用戶信息字典的內存內容

00:14:04.344 --> 00:14:07.080 
舉個例子 
假設你在Apple Watch上

00:14:07.514 --> 00:14:08.849 
有一個遊戲

00:14:08.916 --> 00:14:10.450 
用戶不斷升級繼續遊戲 

00:14:11.318 --> 00:14:14.087 
當用戶升級後繼續遊戲時 

00:14:14.154 --> 00:14:18.091 
你想將進度後臺同步到iOS app

00:14:18.292 --> 00:14:20.494 
iOS app
將展示一些細微圖形 

00:14:20.861 --> 00:14:22.629 
說明用戶在每個等級是如何操作的

00:14:23.931 --> 00:14:26.333 
除了用戶信息傳輸 

00:14:26.400 --> 00:14:28.535 
我們還提供文件傳輸

00:14:29.069 --> 00:14:29.903 
非常類似

00:14:29.970 --> 00:14:32.606 
它允許你讓內容進行排隊等候 

00:14:32.673 --> 00:14:34.708 
在這個案例中 內容是一個文件

00:14:35.676 --> 00:14:38.178 
在這個展示中 接下來我們要講到的

00:14:38.245 --> 00:14:40.447 
關於文件傳輸的示例是 
假設你有一個iOS app 

00:14:40.514 --> 00:14:43.050 
它可讓你對圖片進行編輯 

00:14:43.584 --> 00:14:45.652 
在編輯完圖片後 

00:14:45.719 --> 00:14:47.154 
用戶可挑選他們喜歡的

00:14:47.221 --> 00:14:48.789 
這些喜歡的圖片就是

00:14:48.856 --> 00:14:50.357 
想在Apple Watch顯示的

00:14:50.457 --> 00:14:52.526 
你可以在喜歡的圖片之間

00:14:52.593 --> 00:14:54.361 
使用文件傳輸進行傳輸

00:14:54.428 --> 00:14:56.263 
圖片
可通過Apple Watch查看

00:14:56.330 --> 00:14:59.099 
用戶可以向他們的朋友進行展示之類的

00:15:00.300 --> 00:15:02.636 
讓我們一個一個來說

00:15:04.238 --> 00:15:06.240 
我們從應用上下文開始

00:15:07.007 --> 00:15:07.875 
爲了示範說明

00:15:07.941 --> 00:15:11.178 
我們使用社交網絡app

00:15:11.245 --> 00:15:15.048 
剛纔我提到 這個在iOS上的app

00:15:15.115 --> 00:15:16.583 
從社交網絡網站讀取所有的帖子

00:15:16.650 --> 00:15:19.520 
然後選出最有趣的 

00:15:19.586 --> 00:15:21.355 
發送到Watch app

00:15:22.089 --> 00:15:26.560 
關於應用上下文 
首先要說的是這兩個屬性

00:15:28.028 --> 00:15:30.497 
第一個屬性Application 
Context

00:15:30.697 --> 00:15:34.201 
它是這樣一種屬性 先在發送方 

00:15:34.268 --> 00:15:36.803 
然後在接收方存儲最新內容 

00:15:36.870 --> 00:15:38.839 
Received 
Application

00:15:38.906 --> 00:15:41.675 
Context將在接收方存儲

00:15:41.742 --> 00:15:43.210 
最新收到的內容

00:15:44.444 --> 00:15:49.449 
假設這個iOS app
已經讀取了一堆的帖子 

00:15:49.750 --> 00:15:53.253 
它也已經爲
Watch打包好最有趣的那些

00:15:53.654 --> 00:15:56.423 
將調用Update
Application Context

00:15:57.024 --> 00:16:00.427 
這個方法讀取一個詞典 

00:16:00.494 --> 00:16:02.663 
代表你想要發送的最新最有趣的狀態

00:16:04.031 --> 00:16:06.867 
我們獲得這個內容 Update

00:16:06.934 --> 00:16:09.203 
Application 
Context被調用後 

00:16:09.336 --> 00:16:11.972 
將它疊加到Application 
Context屬性

00:16:12.706 --> 00:16:13.974 
這樣內容就在那裏了 

00:16:14.041 --> 00:16:17.411 
系統將決定傳輸內容的最佳時間 

00:16:17.744 --> 00:16:20.314 
或許是當用戶
啓動他們的Watch的時候

00:16:21.648 --> 00:16:23.317 
現在 與此同時  

00:16:24.351 --> 00:16:29.089 
這個iOS app可以讀取更多內容

00:16:29.456 --> 00:16:31.792 
並決定它想發送到Watch 

00:16:31.859 --> 00:16:33.794 
最新的有趣信息

00:16:34.194 --> 00:16:36.196 
在這個示例中 
它將再一次調用Update

00:16:36.263 --> 00:16:38.098 
Application 
Context

00:16:38.832 --> 00:16:40.267 
然後 我們將把那些內容

00:16:40.334 --> 00:16:42.736 
疊加到Application 
Context屬性

00:16:42.970 --> 00:16:45.072 
它將把舊的相關狀態清出 

00:16:45.138 --> 00:16:47.574 
並放入新的相關狀態 
因爲我們真正在意的是

00:16:47.641 --> 00:16:51.578 
那些最有趣 最新的數據集合

00:16:53.180 --> 00:16:55.249 
這個新內容就在那裏了 再一次

00:16:55.315 --> 00:16:56.650 
等待系統挑選一個合適的時間 

00:16:56.717 --> 00:16:58.418 
將內容傳輸過去

00:16:59.319 --> 00:17:01.021 
一旦系統挑出合適的時間 

00:17:01.154 --> 00:17:02.422 
內容就會被傳輸過去

00:17:02.489 --> 00:17:04.657 
它將
傳輸到到Apple Watch方

00:17:05.759 --> 00:17:07.493 
它將等待用戶啓動app 

00:17:07.961 --> 00:17:09.663 
即Apple Watch app

00:17:10.664 --> 00:17:13.133 
當app啓動後
我們將把內容轉傳輸到

00:17:13.200 --> 00:17:14.968 
你的WatchKit擴展 

00:17:15.035 --> 00:17:18.238 
這裏是在Apple Watch
上所有代碼執行的地方

00:17:20.073 --> 00:17:22.576 
所以以上是應用上下文的流程

00:17:23.210 --> 00:17:25.746 
我們來看一些代碼

00:17:26.413 --> 00:17:29.383 
你想做的第一件事是打包

00:17:29.716 --> 00:17:32.886 
你的上下文詞典 代表你想要發送的

00:17:33.120 --> 00:17:34.521 
最新狀態的詞典

00:17:34.855 --> 00:17:37.291 
調用Update 
Application

00:17:37.357 --> 00:17:38.358 
Context 你將使用詞典

00:17:39.493 --> 00:17:42.696 
關於代碼示例
需要提的最後一件事情是Update

00:17:42.763 --> 00:17:45.599 
Application 
Context調用被打包到

00:17:45.666 --> 00:17:50.037 
Do Catch塊中
這個調用通過調試是事先引導的

00:17:50.404 --> 00:17:52.506 
這是Swift的新錯誤處理方式 
Update

00:17:52.573 --> 00:17:55.309 
Application
Context會返回一個錯誤

00:17:55.576 --> 00:17:59.079 
若錯誤被返回
Catch塊將被激發 

00:17:59.546 --> 00:18:01.849 
我們強烈建議你

00:18:01.915 --> 00:18:02.850 
恰當的處理錯誤

00:18:04.885 --> 00:18:08.355 
所以這是應用上下文的發送方

00:18:08.856 --> 00:18:10.591 
我們來看看接收方

00:18:11.792 --> 00:18:13.026 
在接收方看來 

00:18:13.093 --> 00:18:15.028 
接收方將得到指派回調

00:18:15.095 --> 00:18:17.364 
Did Receive 
Application Context

00:18:17.865 --> 00:18:19.266 
它將向發送者

00:18:19.366 --> 00:18:20.634 
發送打包的字典

00:18:21.268 --> 00:18:26.640 
然後此時 接收者可以獲得內容 

00:18:26.707 --> 00:18:27.941 
並更新它的app狀態

00:18:28.775 --> 00:18:30.577 
關於API中這個指派回調

00:18:30.644 --> 00:18:34.081 
和所有指派回調
我們需要知道的一件事是 

00:18:34.147 --> 00:18:36.250 
它們按照非主要串行隊列被返回

00:18:37.317 --> 00:18:38.852 
假若由於你因爲要更新某些UI 

00:18:38.919 --> 00:18:41.755 
而需要在主要隊列中做些事情 

00:18:41.822 --> 00:18:44.558 
需要在此內容或其他事情的基礎上 

00:18:44.625 --> 00:18:47.361 
發送到主要隊列 從而更新你的UI

00:18:49.997 --> 00:18:51.598 
以上是應用上下文

00:18:52.299 --> 00:18:54.301 
它是app爲另一方所提供的的 

00:18:54.368 --> 00:18:56.303 
最有趣的相關內容

00:18:56.670 --> 00:18:58.305 
它的行爲優先權確實更高 

00:18:58.372 --> 00:19:04.178 
這是因爲你重視接收方在意的內容

00:19:04.244 --> 00:19:06.980 
並處理最新內容而任何非最新的內容

00:19:07.047 --> 00:19:10.417 
都是無關緊要的

00:19:12.019 --> 00:19:13.921 
應用上下文有一個詞典

00:19:14.688 --> 00:19:16.924 
這個詞典有屬性清單類型

00:19:17.691 --> 00:19:20.561 
屬性清單類型是基本對象類型 
比如數字 

00:19:20.627 --> 00:19:24.431 
字符串 基本集合型 字典 陣列

00:19:25.132 --> 00:19:28.135 
如果你想要更新屬性清單類型 

00:19:28.302 --> 00:19:31.371 
Apple有很棒的在線文件

00:19:33.574 --> 00:19:35.876 
所以 對於應用上下文 

00:19:35.943 --> 00:19:37.377 
我們有一些特別推薦的使用示例

00:19:38.278 --> 00:19:41.715 
對於Apple Watch app
來說應用上下文真的很不錯 

00:19:41.849 --> 00:19:44.384 
因爲不少
Apple Watch app展示

00:19:44.451 --> 00:19:46.553 
iOS所有信息的一個子集

00:19:47.221 --> 00:19:49.923 
如果app是這樣工作的 我們建議你

00:19:49.990 --> 00:19:53.293 
將那信息的子集放到應用上下文中 

00:19:53.660 --> 00:19:56.496 
讓它可發送到Apple Watch

00:19:57.197 --> 00:19:58.732 
除了這些app 

00:19:59.032 --> 00:20:01.902 
應用上下文在Glance上也很好用

00:20:03.103 --> 00:20:05.672 
Glance獲得app提供的

00:20:05.739 --> 00:20:07.641 
單個最有趣的數據段

00:20:08.108 --> 00:20:09.843 
我們建議你將該數據段

00:20:09.910 --> 00:20:12.913 
放到iOS方的應用上下文中 

00:20:12.980 --> 00:20:14.648 
這樣它就可以被傳輸到Watch方

00:20:14.815 --> 00:20:17.184 
當用戶掃過
手錶表面顯示Glance時 

00:20:17.818 --> 00:20:20.320 
就可以看到數據了

00:20:22.356 --> 00:20:25.659 
結束應用上下文部分 現在將繼續談談

00:20:25.726 --> 00:20:27.361 
用戶信息傳輸

00:20:28.729 --> 00:20:31.698 
我們將用到的一個示例是 

00:20:32.232 --> 00:20:33.734 
Apple Watch上有個遊戲

00:20:33.800 --> 00:20:36.170 
用戶不斷升級從而進行遊戲 

00:20:36.436 --> 00:20:39.106 
當用戶升級後 你將把進度

00:20:39.173 --> 00:20:41.608 
後臺同步到iOS方 

00:20:41.742 --> 00:20:44.344 
iOS app展示一些細微圖形 

00:20:45.112 --> 00:20:47.314 
是關於用戶在該等級
的信息用戶信息傳輸要講到的

00:20:48.015 --> 00:20:53.053 
第一件事是未解決的用戶信息傳輸隊列

00:20:53.420 --> 00:20:55.956 
這控制了所有

00:20:56.023 --> 00:20:57.291 
等待傳輸的內容

00:20:58.492 --> 00:20:59.593 
當用戶升兩級後 

00:20:59.660 --> 00:21:01.795 
這時候的當前狀態

00:21:02.596 --> 00:21:04.198 
進度位於

00:21:04.731 --> 00:21:07.601 
未解決的用戶傳輸隊列中

00:21:08.735 --> 00:21:10.771 
目前 用戶的等級是3級

00:21:11.572 --> 00:21:13.774 
一旦他們再次升級
你將打包那些內容 

00:21:13.841 --> 00:21:18.145 
調用Transfer
User Info 

00:21:18.212 --> 00:21:20.480 
然後傳遞一個描述進度的詞典

00:21:21.648 --> 00:21:24.117 
獲取到該詞典後
系統將對其進行打包 

00:21:24.384 --> 00:21:27.721 
並將它放到未解決用戶輸入
傳輸隊列中

00:21:29.056 --> 00:21:33.093 
現在這個內容將在這裏等待
然後系統會根據電源情況

00:21:33.493 --> 00:21:35.229 
或在用戶
開始使用iPhone的時候 

00:21:35.395 --> 00:21:37.731 
決定傳輸內容的最佳時機

00:21:39.166 --> 00:21:42.202 
內容將被傳輸和先前的API一樣

00:21:42.269 --> 00:21:46.406 
我們需要等待直到iOS上app啓動

00:21:46.940 --> 00:21:49.176 
當它啓動後 我們將傳輸內容 

00:21:49.910 --> 00:21:52.212 
現在iOS app可以更新這些圖形

00:21:52.279 --> 00:21:55.082 
以顯示用戶在
Apple Watch遊戲中的進度

00:21:56.717 --> 00:21:58.886 
所以這是用戶信息傳輸流程

00:21:59.319 --> 00:22:01.054 
我們來看一些代碼

00:22:03.590 --> 00:22:07.861 
首先要做打包所有用戶信息詞典 

00:22:08.395 --> 00:22:10.330 
這代表的是你想要發送的

00:22:10.397 --> 00:22:11.565 
目前狀態的內容全部

00:22:11.932 --> 00:22:14.301 
然後你調用帶有那個詞典的

00:22:14.401 --> 00:22:15.369 
傳輸用戶信息

00:22:16.436 --> 00:22:19.806 
傳輸用戶信息
返回一個用戶信息傳輸對象

00:22:20.174 --> 00:22:22.409 
對象包含你正在發送的字典 

00:22:22.476 --> 00:22:26.880 
倘若傳輸仍然在未解決隊列 

00:22:26.947 --> 00:22:28.849 
你可以選擇取消這個傳輸

00:22:29.917 --> 00:22:32.452 
除了返回這個傳輸對象 

00:22:32.986 --> 00:22:34.755 
我們也提供了一個方法用來獲取所有

00:22:34.821 --> 00:22:37.157 
仍在隊列中的未解決用戶信息傳輸

00:22:37.958 --> 00:22:40.761 
這方法返回一個數組 
你可以迭代這個數組 

00:22:40.827 --> 00:22:42.596 
查看所有內容 

00:22:43.263 --> 00:22:45.165 
若你需要也可取消

00:22:46.400 --> 00:22:48.535 
所以這是用戶信息傳輸的發送方

00:22:49.570 --> 00:22:51.271 
我們來看下接收方

00:22:51.605 --> 00:22:54.408 
在接收方看來你將調用 

00:22:54.575 --> 00:22:56.743 
Did Receive User
Info Transfer

00:22:57.411 --> 00:23:00.247 
和應用上下文和
其他所有指派回調一樣 

00:23:00.314 --> 00:23:02.382 
這是在一個非主要串聯隊列中被返回的

00:23:03.784 --> 00:23:06.019 
一旦你獲得回調 就可以獲得

00:23:06.119 --> 00:23:08.589 
內容和詞典內容 
然後可以更新app狀態

00:23:10.591 --> 00:23:12.392 
那是用戶信息傳輸

00:23:12.626 --> 00:23:14.261 
它有用戶輸入詞典

00:23:14.561 --> 00:23:17.164 
這些詞典和應用上下文詞典一樣 

00:23:17.231 --> 00:23:18.699 
裏面有屬性清單類型

00:23:19.399 --> 00:23:22.603 
這對於內存內容 比如遊戲進度而言
 這種方法很好

00:23:23.704 --> 00:23:25.038 
我們允許你訪問

00:23:25.239 --> 00:23:29.710 
隊列中未解決的用戶信息傳輸

00:23:30.844 --> 00:23:33.180 
接下來 我們談談文件傳輸

00:23:34.481 --> 00:23:36.550 
文件傳輸中要用到的示例是

00:23:36.617 --> 00:23:37.784 
這個圖像編輯app

00:23:38.585 --> 00:23:41.054 
用戶可在iOS編輯圖片 

00:23:41.788 --> 00:23:43.423 
然後挑選他們喜歡的圖片 

00:23:43.490 --> 00:23:45.425 
這些喜歡的圖片就是我們想要

00:23:45.492 --> 00:23:47.661 
傳輸到Apple Watch上的

00:23:48.996 --> 00:23:49.863 
所以首先要說的是

00:23:49.930 --> 00:23:52.533 
未解決的文件傳輸隊列

00:23:53.133 --> 00:23:54.468 
這裏是所有文件傳輸

00:23:54.535 --> 00:23:56.170 
等待發送的地方

00:23:57.204 --> 00:23:59.540 
然後在接收方 文件在等待被轉交到

00:23:59.606 --> 00:24:02.476 
接收方app時 將被放入

00:24:02.543 --> 00:24:04.478 
Documents/Inbox
文件夾

00:24:06.313 --> 00:24:08.515 
這時候的狀態是
用戶有兩張喜歡的圖片 

00:24:08.582 --> 00:24:11.652 
兩個圖像正在隊列裏等待 

00:24:12.719 --> 00:24:14.054 
進程進行到第三個

00:24:15.122 --> 00:24:17.357 
一旦完成進程並且將它挑選爲

00:24:17.424 --> 00:24:20.727 
喜歡的圖片後 
你將調用Transfer File

00:24:21.461 --> 00:24:24.131 
你將傳輸一個文件URL 它指向

00:24:24.198 --> 00:24:27.267 
你想要傳輸的文件 
我們提供一個方法 

00:24:27.334 --> 00:24:31.405 
以詞典的方式傳輸附加的元數據

00:24:32.306 --> 00:24:35.676 
你可能想要增加
一些元數據的一個情況是 

00:24:35.742 --> 00:24:39.713 
通過在
每個元數據詞典中放一個標識符 

00:24:40.180 --> 00:24:43.417 
將一些文件集合在一起

00:24:43.750 --> 00:24:46.587 
接收方可以識別那個標識符 

00:24:46.687 --> 00:24:48.055 
把正在接受的文件聚集在一起

00:24:49.556 --> 00:24:51.692 
所以這是用戶喜歡的圖片

00:24:51.859 --> 00:24:53.493 
我們稱之爲文件傳輸

00:24:53.560 --> 00:24:56.029 
現在我們將獲得打包好的內容 

00:24:56.430 --> 00:24:58.599 
我們將把它放入未解決的文件傳輸隊列

00:24:59.299 --> 00:25:01.468 
它將在這裏等待 直到系統確定

00:25:01.535 --> 00:25:02.836 
傳輸內容的最佳時間

00:25:03.670 --> 00:25:06.640 
當系統確定傳輸內容的最佳時間後 

00:25:06.974 --> 00:25:08.675 
它將開始傳輸內容 

00:25:09.042 --> 00:25:14.114 
等待接收方啓動並接收內容

00:25:15.115 --> 00:25:16.617 
需要注意文件的一件事是 

00:25:16.683 --> 00:25:18.619 
文件可能會稍微大一些

00:25:19.286 --> 00:25:20.888 
文件越大 

00:25:20.954 --> 00:25:22.589 
傳輸的時間就越長

00:25:22.990 --> 00:25:25.225 
當傳輸的時候 你可能需要注意

00:25:25.292 --> 00:25:27.227 
電源和性能的情況

00:25:27.661 --> 00:25:29.796 
請注意
如果準備傳輸的是大文件 

00:25:29.863 --> 00:25:32.266 
相比使用其他API 這種方法

00:25:32.633 --> 00:25:34.535 
可能花費更長的時間

00:25:36.069 --> 00:25:37.971 
現在接收者將啓動設備 

00:25:38.071 --> 00:25:39.873 
然後我們將傳輸這些圖像

00:25:40.407 --> 00:25:43.310 
現在Apple Watch
 app可以顯示這些圖像了

00:25:45.479 --> 00:25:48.615 
所以這是文件傳輸流程

00:25:48.682 --> 00:25:49.917 
我們來看一下代碼

00:25:51.552 --> 00:25:53.787 
首先你想做的是爲你想要傳輸的文件

00:25:53.854 --> 00:25:55.489 
獲取一個URL

00:25:56.190 --> 00:25:58.992 
然後打包你的元數據 最後

00:25:59.159 --> 00:26:01.762 
調用Transfer File 
傳輸URL 

00:26:01.828 --> 00:26:03.297 
以及元數據詞典

00:26:04.298 --> 00:26:06.200 
之後返回一個文件傳輸對象 

00:26:06.333 --> 00:26:09.503 
文件傳輸對象包含URL 

00:26:09.570 --> 00:26:12.973 
元數據詞典 同樣你也可以

00:26:13.040 --> 00:26:16.176 
取消任何未解決的文件傳輸

00:26:18.245 --> 00:26:21.114 
和用戶信息傳輸一樣 我們允許你

00:26:21.181 --> 00:26:25.185 
撤銷所有未解決文件傳輸的數組

00:26:25.485 --> 00:26:27.988 
你可以迭代這個數組 檢查內容 

00:26:28.121 --> 00:26:29.323 
如若需要 也可以取消

00:26:30.724 --> 00:26:32.793 
所以這就是文件傳輸的發送方

00:26:33.260 --> 00:26:36.530 
現在我們來看看接收方

00:26:36.730 --> 00:26:37.931 
在接收方看來 接收方會收到

00:26:38.065 --> 00:26:41.168 
這個指派回調
Did Receive File

00:26:42.069 --> 00:26:44.371 
關於這個指派回調 需要注意的是

00:26:44.438 --> 00:26:46.406 
它與前面兩個略有不同

00:26:47.474 --> 00:26:50.110 
首先獲得WCSession文件對象

00:26:50.944 --> 00:26:54.581 
這個對象只包含文件URL和元數據

00:26:56.149 --> 00:26:59.219 
關於這個回調的第二件事是

00:26:59.820 --> 00:27:02.289 
文件現在位於
app container的

00:27:02.356 --> 00:27:04.258 
Documents/Inbox
文件夾下

00:27:04.892 --> 00:27:08.962 
說到控制這個文件 你需要將文件移出

00:27:09.029 --> 00:27:11.131 
Documents/Inbox
並放到另一個

00:27:11.198 --> 00:27:12.566 
永久位置

00:27:14.735 --> 00:27:18.972 
移出文件的主要原因是

00:27:19.039 --> 00:27:20.974 
在指派返回後

00:27:21.041 --> 00:27:23.877 
Documents/Inbox
將被清空

00:27:24.211 --> 00:27:28.515 
意思是文件將和其他內容一起被刪除

00:27:29.283 --> 00:27:31.852 
所以重要的是在文件傳輸之前

00:27:31.919 --> 00:27:35.522 
將文件放到其他的位置 

00:27:36.590 --> 00:27:38.625 
需要記住一件事 如果你正在指派到

00:27:38.692 --> 00:27:40.794 
另一個隊列 因爲這是在從

00:27:40.861 --> 00:27:44.031 
非重要串行隊列返回的 

00:27:44.131 --> 00:27:48.368 
如果該指派不同步的話 

00:27:48.969 --> 00:27:50.804 
你需要在指派之前移動文件

00:27:53.373 --> 00:27:54.875 
所以這是文件傳輸

00:27:55.442 --> 00:27:58.445 
它和用戶信息傳輸非常相似
但是它允許你

00:27:58.512 --> 00:28:01.782 
傳輸文件或文件列隊

00:28:02.583 --> 00:28:03.717 
我們允許你

00:28:03.817 --> 00:28:06.353 
訪問隊列中未解決的文件

00:28:07.521 --> 00:28:12.860 
我們也允許你傳輸附加元數據

00:28:13.627 --> 00:28:15.796 
我們建議你使用較小的元數據體積 

00:28:16.263 --> 00:28:17.564 
另外 這個元數據詞典

00:28:17.631 --> 00:28:19.533 
和其他我們說過的詞典一樣 

00:28:19.600 --> 00:28:20.767 
有屬性清單類型

00:28:22.603 --> 00:28:25.005 
所以以上是三種後臺傳輸模式

00:28:25.205 --> 00:28:27.474 
若接收放不是立即需要這些內容 

00:28:27.541 --> 00:28:28.942 
請用這些模式

00:28:30.410 --> 00:28:35.983 
但如果你需要實時來回傳輸信息 

00:28:36.350 --> 00:28:41.255 
你可以使用交互信息傳輸

00:28:42.823 --> 00:28:44.758 
交互信息傳輸指的是實時通訊 

00:28:44.825 --> 00:28:47.728 
兩個app當前都處於開啓狀態

00:28:48.061 --> 00:28:49.630 
而且正在來回發送信息

00:28:51.098 --> 00:28:54.134 
就像我先前提到的 
這裏有你可能需要這麼做的一些示例

00:28:54.801 --> 00:28:58.305 
假設我們有一個遊戲
遊戲中兩個UI都處於啓動狀態 

00:28:58.438 --> 00:29:01.508 
而你想要用戶與兩個UI同時進行交互

00:29:02.042 --> 00:29:04.244 
或者你正在
使用Apple Watch 你需要

00:29:04.311 --> 00:29:06.780 
觸發iOS app 

00:29:06.847 --> 00:29:08.615 
比如查詢用戶的位置

00:29:10.284 --> 00:29:12.619 
如果要使用交互信息傳輸 

00:29:12.986 --> 00:29:15.956 
需要滿足特定條件

00:29:16.190 --> 00:29:17.791 
所以我們來說說這些條件

00:29:18.625 --> 00:29:20.194 
這些條件與我們引進的概念有關 

00:29:20.527 --> 00:29:22.362 
這個概念叫做可達性

00:29:23.430 --> 00:29:24.965 
可達性意思是

00:29:25.132 --> 00:29:29.069 
其他app也可以訪問內容

00:29:29.870 --> 00:29:33.507 
這要求其他app是可以訪問和啓動的

00:29:33.707 --> 00:29:36.610 
從而可以使用交互信息傳輸

00:29:37.077 --> 00:29:39.346 
你查看另一方是否可達的方法是 

00:29:40.514 --> 00:29:44.518 
在默認會話中我們有可達性這個屬性 
這樣你可以進行查看 

00:29:45.786 --> 00:29:49.189 
現在 
可達性的條件與之前的有些不同 

00:29:49.256 --> 00:29:51.825 
取決於你所處的平臺 不論你的代碼

00:29:51.892 --> 00:29:53.093 
是否在iOS app上執行

00:29:53.160 --> 00:29:55.028 
或是在WatchKit擴展上執行

00:29:55.729 --> 00:29:57.264 
我們一個一個來看

00:29:58.031 --> 00:29:59.733 
我們從iPhone開始

00:30:00.667 --> 00:30:04.271 
滿足可達性爲True的第一個條件是

00:30:05.405 --> 00:30:07.274 
設備需被連接

00:30:07.641 --> 00:30:11.044 
我們可以通過Bluetooth
或Wi-Fi連接 

00:30:11.912 --> 00:30:13.714 
但是如果用戶將Watch放在家裏 

00:30:14.381 --> 00:30:17.084 
拿了iPhone去上班
這種情況下設備就無法被連接 

00:30:17.417 --> 00:30:19.620 
交互信息傳輸就無法進行

00:30:20.621 --> 00:30:23.123 
iOS上可達性爲True 

00:30:23.190 --> 00:30:25.359 
需要滿足的第二個條件是

00:30:25.492 --> 00:30:27.995 
Watch app
必須處於前臺操作狀態

00:30:28.395 --> 00:30:31.532 
意思是爲了在
iOS上進行交換信息傳輸 

00:30:31.732 --> 00:30:34.735 
用戶必須與Watch app交互

00:30:35.536 --> 00:30:37.137 
一旦滿足以上兩個條件 

00:30:38.672 --> 00:30:41.475 
你的iOS app上
可達性屬性也將爲True

00:30:44.011 --> 00:30:45.412 
所以這是iPhone方面

00:30:47.181 --> 00:30:49.016 
來說說Apple Watch方面

00:30:49.683 --> 00:30:51.752 
在你的WatchKit擴展設備上

00:30:51.952 --> 00:30:53.720 
可達性爲True的第一個條件是

00:30:53.787 --> 00:30:56.256 
必須連接設備

00:30:57.391 --> 00:30:59.927 
意思是說倘若用戶去跑步 
沒帶iPhone

00:30:59.993 --> 00:31:01.461 
只帶了Watch

00:31:02.829 --> 00:31:05.299 
可達性就不會爲True
設備將無法被連接

00:31:06.200 --> 00:31:07.167 
第二個條件是

00:31:07.901 --> 00:31:10.404 
WatchKit
外設必須處於前臺運行狀態

00:31:11.305 --> 00:31:13.674 
提到WatchKit
外設處於前臺運行狀態

00:31:13.740 --> 00:31:15.275 
是因爲在不少示例中

00:31:15.342 --> 00:31:17.611 
WatchKit外設可以在後臺運行

00:31:18.245 --> 00:31:20.013 
主要
與complication有關

00:31:20.080 --> 00:31:22.683 
我們等下會談到這個

00:31:23.584 --> 00:31:27.788 
所以現在 當用戶使用你的app時

00:31:27.855 --> 00:31:29.389 
你的WatchKit外設

00:31:29.523 --> 00:31:31.692 
也將被啓動並被置於前臺運行狀態

00:31:31.792 --> 00:31:33.794 
這也就是說
你可以使用交互信息傳輸

00:31:34.328 --> 00:31:36.163 
並且可達性屬性爲True

00:31:37.731 --> 00:31:39.867 
關於這個圖表 還需要注意的是

00:31:40.267 --> 00:31:43.003 
我們並沒有
說iOS app當前正在運行

00:31:44.104 --> 00:31:49.276 
iOS app必須處於運行狀態 
 以對進來的信息作出反應

00:31:49.476 --> 00:31:50.711 
併發出自己的信息

00:31:51.044 --> 00:31:53.780 
所以當iOS app
在WatchKit外設之外運行時

00:31:53.847 --> 00:31:55.449 
我們如何進入一個狀態呢

00:31:56.083 --> 00:31:59.887 
僅針對這個詞典將信息
從Watch發送到iPhone

00:32:00.153 --> 00:32:03.857 
或者允許iOS app

00:32:04.057 --> 00:32:06.460 
在接收信息的基礎上
在後臺啓動

00:32:07.261 --> 00:32:08.695 
我們拿這個做例子

00:32:08.795 --> 00:32:10.297 
你有一個運行追蹤器app

00:32:10.764 --> 00:32:13.767 
它需要發送信息到iPhone

00:32:13.834 --> 00:32:19.506 
告訴CoreLocation
開始追蹤用戶的信息

00:32:20.641 --> 00:32:23.911 
所以這個app將打包一個信息

00:32:23.977 --> 00:32:26.547 
告訴iOS app開始運行
CoreLocation

00:32:27.281 --> 00:32:29.016 
它將發出啓動信息

00:32:29.082 --> 00:32:31.151 
當系統受到這個信息時

00:32:31.218 --> 00:32:33.086 
我們將在後臺啓動iOS app

00:32:33.554 --> 00:32:34.688 
並傳輸那個信息

00:32:35.122 --> 00:32:38.258 
現在 兩個app都在運行 
 它們可以進行互動了

00:32:38.659 --> 00:32:41.461 
這個示例中的app

00:32:41.528 --> 00:32:42.596 
可以開始追蹤用戶位置

00:32:43.997 --> 00:32:46.466 
所以那是交互信息傳輸流

00:32:47.801 --> 00:32:48.802 
當你可以使用它時

00:32:48.869 --> 00:32:50.604 
它如何和可達性有關係

00:32:50.771 --> 00:32:52.506 
現在我們來具體講講

00:32:52.573 --> 00:32:53.941 
如何在你的代碼中使用它

00:32:55.509 --> 00:32:57.377 
我提供兩種不同類型的信息

00:32:57.978 --> 00:32:59.746 
第一種發出一個詞典

00:33:00.214 --> 00:33:02.516 
你使用
詞典調用Send Message

00:33:02.749 --> 00:33:03.984 
這個調用攜帶詞典

00:33:04.051 --> 00:33:06.420 
加上一個回覆處理器
和一個錯誤處理器

00:33:07.387 --> 00:33:10.057 
這個詞典
和我們先前說過的詞典一樣 

00:33:10.123 --> 00:33:12.359 
裏面有屬性清單類型

00:33:14.561 --> 00:33:16.129 
除了詞典外

00:33:16.196 --> 00:33:18.999 
我們還引入了發送數據的方法

00:33:19.533 --> 00:33:21.935 
可調用Send
 Message Data發送數據

00:33:22.002 --> 00:33:24.605 
這個攜帶數據 相同的回覆處理器

00:33:24.805 --> 00:33:25.939 
和錯誤處理器

00:33:26.807 --> 00:33:30.410 
關於發送數據 

00:33:30.477 --> 00:33:32.079 
如果你有存儲自己信息的
自定義數據

00:33:32.412 --> 00:33:34.548 
或你自己的序列化格式
我們建議你使用這個

00:33:35.983 --> 00:33:38.418 
若你使用自己的序列化格式

00:33:38.485 --> 00:33:41.755 
我們強烈建議你使用小而快的格式

00:33:42.155 --> 00:33:45.025 
這樣用戶體驗更快

00:33:45.092 --> 00:33:46.927 
因爲內容可以更快進行傳輸

00:33:48.729 --> 00:33:52.533 
關於這些調用
 我想要指出一點 就是回覆

00:33:53.100 --> 00:33:56.103 
你或許注意
到了先前兩個調用中有回覆處理器

00:33:57.571 --> 00:33:59.173 
這個處理器是可選的

00:33:59.673 --> 00:34:02.543 
然而 在多數情況下
 我們建議你使用它

00:34:03.377 --> 00:34:05.746 
原因是

00:34:05.812 --> 00:34:07.714 
這可讓接收者確認進來的信息

00:34:08.447 --> 00:34:10.551 
接收者可以確認它接收到信息

00:34:10.650 --> 00:34:13.020 
信息包含正確的內容

00:34:13.085 --> 00:34:14.321 
它也可以處理那些內容

00:34:14.955 --> 00:34:18.525 
這樣一來 發送方就知道
它不需要再發送任何東西了

00:34:18.792 --> 00:34:20.293 
它不需要在發送新信息了

00:34:20.360 --> 00:34:21.527 
因爲它發的是錯誤的信息

00:34:23.996 --> 00:34:27.601 
回覆需要談到的另一部分是

00:34:28.302 --> 00:34:30.003 
接收方這邊的情況

00:34:31.938 --> 00:34:36.043 
如果發送者說 我想要回復 
所以我將提供一個回覆處理器

00:34:36.109 --> 00:34:38.712 
與之相反的 如果發送者說

00:34:38.779 --> 00:34:41.614 
我不想回復 不提供一個回覆處理器 
這時會發生什麼呢

00:34:42.616 --> 00:34:43.617 
這種情況下

00:34:43.684 --> 00:34:46.920 
接收方會收到單獨指派回調

00:34:46.987 --> 00:34:49.022 
這取決於
我們是否應該提供回覆

00:34:51.058 --> 00:34:53.226 
我們來說說這些指派回調

00:34:53.760 --> 00:34:56.797 
第一種情況 發送者說

00:34:57.164 --> 00:34:59.032 
我需要回復 
我爲系統提供一個回覆處理器

00:34:59.466 --> 00:35:01.969 
意思是接收方將收到
這個指派回調

00:35:02.035 --> 00:35:06.039 
Did Receive 
Message它有一個回覆塊

00:35:06.440 --> 00:35:10.277 
你可以在接收者接收
並處理信息之後調用回覆塊

00:35:10.644 --> 00:35:12.346 
接收者就可以決定

00:35:12.412 --> 00:35:14.281 
是否發回一些內容

00:35:14.348 --> 00:35:17.184 
或者如果信息是錯誤的 
 就發回一個錯誤

00:35:18.785 --> 00:35:19.953 
現在 從另一方面來說

00:35:20.020 --> 00:35:24.124 
倘若發送者
並未提供一個回覆處理器

00:35:25.359 --> 00:35:26.493 
接收者將獲得

00:35:26.560 --> 00:35:29.930 
指派回調
Did Receive Message

00:35:30.330 --> 00:35:31.932 
它沒有回覆塊

00:35:31.999 --> 00:35:34.134 
接收方可以處理進來的內容

00:35:34.368 --> 00:35:35.269 
然後就結束了

00:35:36.470 --> 00:35:37.638 
關於這兩個指派回調

00:35:37.704 --> 00:35:40.741 
需要注意的
最後一件事是他們通過一個詞典

00:35:41.842 --> 00:35:45.612 
意思是說發送者使用發送信息

00:35:45.712 --> 00:35:49.249 
從發送方這邊發送出一個詞典

00:35:49.783 --> 00:35:54.888 
倘若 發送者使用發送信息數據
發送數據

00:35:55.522 --> 00:35:59.593 
在接收方會收到
一個類似的回調通過數據

00:36:01.895 --> 00:36:05.499 
現在 我們簡單瞭解了交互信息傳輸

00:36:05.566 --> 00:36:08.402 
將所有的這些放在一起
 並進行編碼

00:36:09.203 --> 00:36:10.470 
你首先要做的是

00:36:11.004 --> 00:36:12.105 
檢查可達性

00:36:12.573 --> 00:36:15.075 
確保另一邊是確實可達的

00:36:15.742 --> 00:36:20.147 
然後 倘若可達性爲True
那你就可以打包你的信息了

00:36:21.515 --> 00:36:23.050 
一旦你有了信息

00:36:23.183 --> 00:36:25.419 
你就可以使用詞典
調用Send Message

00:36:26.486 --> 00:36:27.654 
然後期待收到一個回覆

00:36:27.721 --> 00:36:29.723 
所以我們將提供回覆處理器

00:36:31.124 --> 00:36:32.759 
我們想要處理我們的錯誤

00:36:32.960 --> 00:36:34.528 
所以我們將啓動錯誤處理器

00:36:36.296 --> 00:36:38.232 
使用
WatchConnectivity

00:36:38.298 --> 00:36:40.167 
傳輸內容的不同方法

00:36:41.268 --> 00:36:42.369 
來總結一下所講的

00:36:42.436 --> 00:36:44.404 
關於
WatchConnectivity

00:36:46.039 --> 00:36:47.374 
首先要做的是

00:36:47.441 --> 00:36:48.775 
設置會話

00:36:50.844 --> 00:36:53.347 
爲做到這個 你設置指派 
 調用Activate

00:36:53.747 --> 00:36:56.416 
你需在app的使用週期裏今早執行

00:36:56.683 --> 00:36:59.219 
這樣app就可以開始接收內容

00:36:59.553 --> 00:37:01.121 
然後檢查屬性

00:37:02.923 --> 00:37:05.425 
在檢查這些屬性時候 
你可以查看會話狀態

00:37:06.226 --> 00:37:07.561 
一旦一切都好了

00:37:07.628 --> 00:37:09.263 
而且你知道Watch已經配對

00:37:09.630 --> 00:37:11.765 
同時Apple Watch app
也安裝了

00:37:12.199 --> 00:37:13.333 
你就可以開始通訊了

00:37:15.235 --> 00:37:17.671 
第一種溝通是後臺傳輸

00:37:19.640 --> 00:37:21.241 
我們提供三種類型

00:37:21.742 --> 00:37:23.477 
第一種是應用上下文

00:37:23.810 --> 00:37:27.281 
這是信息的單一子集

00:37:27.347 --> 00:37:28.882 
這個子集是
爲另一方app準備的

00:37:29.349 --> 00:37:30.951 
或者 倘若你需要列隊內容

00:37:31.151 --> 00:37:34.321 
你可以使用用戶信息傳輸
或文件傳輸

00:37:36.156 --> 00:37:37.724 
除了後臺傳輸

00:37:37.791 --> 00:37:39.560 
在實時溝通方面

00:37:39.960 --> 00:37:41.395 
我們還可以使用交互信息傳輸

00:37:42.996 --> 00:37:44.498 
就是
WatchConnectivity

00:37:44.565 --> 00:37:47.034 
它允許你的
app進行設備對設備的通訊

00:37:47.501 --> 00:37:49.703 
我們非常期待

00:37:50.370 --> 00:37:52.806 
你們會如何使用這個API進行通訊

00:37:52.873 --> 00:37:54.775 
如何提供更棒的用戶體驗

00:37:55.843 --> 00:38:00.280 
接下來...
將簡要說說NSURLSession

00:38:01.381 --> 00:38:03.050 
什麼是NSURLSession

00:38:03.517 --> 00:38:05.485 
它是一個現有的基礎類

00:38:06.053 --> 00:38:08.755 
它允許你爲服務器提出HTTP請求

00:38:09.089 --> 00:38:10.824 
從而讀取內容

00:38:11.758 --> 00:38:14.895 
它在watchOS 2上適用
倘若在你的服務器上

00:38:14.962 --> 00:38:17.331 
有內容需要讀取 
我強烈建議你使用它

00:38:17.865 --> 00:38:20.801 
它利用了
Tetherless Wi-Fi特徵

00:38:21.401 --> 00:38:24.137 
在沒帶iPhone的時候
Tetherless Wi-Fi

00:38:24.204 --> 00:38:26.807 
允許Apple Watch
連接到已知的Wi-Fi網絡

00:38:27.774 --> 00:38:30.444 
若Apple Watch
已經連接到已知Wi-Fi網絡

00:38:30.511 --> 00:38:34.948 
你可使用NSURLSession
通過Wi-Fi網絡

00:38:35.015 --> 00:38:36.917 
連接到你的服務器並獲取信息

00:38:39.152 --> 00:38:41.488 
所以你會如何
使用NSURLSession呢？

00:38:41.655 --> 00:38:44.925 
當你的服務器有新內容時
你都可以使用它

00:38:45.592 --> 00:38:47.861 
這個和你通過
iOS app進行的操作

00:38:47.928 --> 00:38:49.029 
非常的相似

00:38:49.796 --> 00:38:54.735 
我們建議
根據Apple Watch的需求

00:38:54.801 --> 00:39:00.674 
定製發送到
Apple Watch的內容

00:39:01.108 --> 00:39:03.043 
若你的服務器上有圖片

00:39:03.844 --> 00:39:08.549 
建議按照Apple Watch
屏幕尺寸按比例決定圖片尺寸

00:39:08.815 --> 00:39:10.384 
若是一個新app

00:39:10.450 --> 00:39:13.554 
你只想在Apple Watch
上顯示部分內容或許只是文本

00:39:13.754 --> 00:39:15.756 
我們建議你
只截取你所需的部分

00:39:17.357 --> 00:39:20.827 
以上是關於
NSURLSession的簡要介紹

00:39:21.361 --> 00:39:26.466 
在WWDC會議上 
有關於這個API的部分

00:39:26.533 --> 00:39:27.734 
同樣也有在線資源部分

00:39:28.335 --> 00:39:30.604 
我們建議你看看這些

00:39:31.205 --> 00:39:32.706 
關於NSURLSession

00:39:32.773 --> 00:39:35.676 
最後要講的是使用
WatchConnectivity

00:39:36.343 --> 00:39:37.778 
NSURLSession

00:39:38.645 --> 00:39:41.081 
再一次 我們有新app的示例

00:39:42.149 --> 00:39:45.719 
這個新app從它的
服務器上讀取一些內容

00:39:46.186 --> 00:39:47.254 
而且它知道

00:39:47.321 --> 00:39:51.024 
Apple Watch app
可能將讀取這些相同內容

00:39:51.391 --> 00:39:54.228 
下次用戶啓動
Apple Watch app時

00:39:54.595 --> 00:39:58.131 
爲了不讓Apple Watch
app重新獲取內容

00:39:58.732 --> 00:40:01.969 
我將利用應用上下文

00:40:02.169 --> 00:40:04.671 
將內容從iOS傳輸到Watch

00:40:06.874 --> 00:40:09.076 
內容會不斷被傳輸進來

00:40:09.142 --> 00:40:11.612 
再啓動Apple Watch
 app會被傳輸到它上

00:40:11.678 --> 00:40:13.547 
Apple Watch app可以

00:40:13.614 --> 00:40:16.550 
顯示在iOS上看到的相同內容

00:40:16.917 --> 00:40:19.253 
而且它提供更多的細微體驗

00:40:20.754 --> 00:40:23.624 
用戶下次啓動
Apple Watch app時

00:40:23.690 --> 00:40:25.993 
可能是數小時後

00:40:26.193 --> 00:40:29.129 
這也就說

00:40:29.196 --> 00:40:30.397 
服務器有更新的內容要讀取

00:40:30.797 --> 00:40:31.965 
所以 我們建議

00:40:32.032 --> 00:40:35.602 
除了在應用上下文
獲取已經發送的內容外

00:40:36.403 --> 00:40:39.306 
使用帶NSURLSession
的HTTP請求

00:40:39.373 --> 00:40:43.076 
從你的服務器上
讀取絕對最新的內容

00:40:44.411 --> 00:40:47.447 
這樣
在用戶等待新內容時

00:40:47.514 --> 00:40:50.450 
他們將看到
在iOS上看到的相同內容

00:40:50.517 --> 00:40:53.954 
這樣將有更好的體驗

00:40:55.756 --> 00:40:57.624 
所以這是NSURLSession和

00:40:57.691 --> 00:40:59.526 
WatchConnectivity

00:40:59.860 --> 00:41:03.530 
現在 我們想要採用這兩種API
我們想要爲你展示

00:41:03.597 --> 00:41:06.633 
如何使用它們獲取數據 
放到complication中

00:41:07.067 --> 00:41:09.469 
關於這部分

00:41:09.536 --> 00:41:11.605 
有請克里斯上臺爲我們講解

00:41:18.512 --> 00:41:20.781 
謝謝你 亞歷克斯
這些東西很酷 是吧

00:41:21.248 --> 00:41:24.618 
我想你們使用
Watch Connectivity API

00:41:24.718 --> 00:41:26.720 
和NSURLSession API

00:41:26.787 --> 00:41:28.856 
做的東西 一定很棒

00:41:29.590 --> 00:41:31.592 
現在我們來討論
complications

00:41:31.658 --> 00:41:34.161 
在深入講解之前

00:41:34.228 --> 00:41:35.896 
先確定大家看的是一個內容

00:41:36.763 --> 00:41:38.866 
這些是在Apple Watch上的

00:41:38.932 --> 00:41:41.535 
三個Watch表面 三個時鐘畫面

00:41:41.802 --> 00:41:43.470 
若你移除時鐘 

00:41:43.971 --> 00:41:45.806 
剩下的就是
complications

00:41:46.707 --> 00:41:48.475 
每次用戶看時鐘畫面時

00:41:48.542 --> 00:41:53.647 
他們會看到少量信息

00:41:54.281 --> 00:41:57.317 
這將讓用戶可以快速獲得

00:41:57.384 --> 00:41:59.853 
最重要的信息

00:42:02.222 --> 00:42:04.157 
當你使用complication時

00:42:04.224 --> 00:42:06.460 
你將需要解決兩個主要任務

00:42:07.494 --> 00:42:09.997 
你需要知道如何更新時鐘畫面

00:42:10.430 --> 00:42:14.134 
第二件事是 你需要拿到
用來更新時鐘畫面的內容

00:42:16.603 --> 00:42:18.872 
我們來討論一下 你如何
簡單地更新時鐘畫面

00:42:18.939 --> 00:42:21.241 
其他會議上 有深入討論

00:42:22.176 --> 00:42:24.545 
在這個示例中

00:42:24.611 --> 00:42:27.181 
用一個天氣app
有個月相complication

00:42:27.447 --> 00:42:29.750 
這個月相complication
不需外部數據

00:42:29.816 --> 00:42:31.585 
它已經有它所需的全部信息

00:42:31.652 --> 00:42:33.053 
因爲它只需要數據和時間

00:42:34.054 --> 00:42:37.758 
所以它所關心的是如何更新時鐘畫面

00:42:38.892 --> 00:42:41.628 
爲做到這點
它將使用新ClockKit API

00:42:41.962 --> 00:42:44.064 
watchOS 2
引進的ClockKit框架

00:42:46.500 --> 00:42:50.204 
流程運作的方式是

00:42:50.270 --> 00:42:52.706 
我們將在
後臺啓動WatchKit外設

00:42:55.008 --> 00:42:57.711 
當這發生時 我們將獲取到

00:42:57.811 --> 00:43:00.013 
一個CLK 
complications服務器例

00:43:00.380 --> 00:43:02.449 
你調用
Shared Instance來實現

00:43:02.616 --> 00:43:05.786 
用Extend Timeline 
For Complication

00:43:06.186 --> 00:43:08.388 
進入正在更新的
complication

00:43:10.624 --> 00:43:12.125 
接下來會發生的是

00:43:12.192 --> 00:43:14.228 
它們將調用ClockKit激發程序

00:43:14.428 --> 00:43:16.830 
然後開始問一堆的問題

00:43:17.097 --> 00:43:19.099 
它們詢問現有時間軸項目

00:43:19.499 --> 00:43:21.201 
這是即將顯示的內容之一

00:43:23.003 --> 00:43:25.706 
它們詢問先前的時間軸項目

00:43:26.106 --> 00:43:29.877 
未來的時間軸項目

00:43:30.043 --> 00:43:32.513 
最後它們詢問你的建議
什麼時候這些數據纔算過時

00:43:32.679 --> 00:43:35.349 
這是給系統的建議

00:43:35.616 --> 00:43:37.851 
這樣我們才知道
你什麼時候需要再次啓動

00:43:38.752 --> 00:43:40.888 
你可以進一步更新時間軸

00:43:42.256 --> 00:43:45.859 
以上是更新時鐘畫面的 簡要介紹

00:43:45.926 --> 00:43:48.996 
你可用ClockKit來做上述事情

00:43:49.329 --> 00:43:50.964 
你可以提供過去的

00:43:51.031 --> 00:43:52.566 
現在的 以及未來的內容

00:43:54.501 --> 00:43:57.738 
你的WatchKit外設將在後臺
進行這些更新

00:43:58.238 --> 00:43:59.339 
而且你可以規定

00:43:59.406 --> 00:44:01.775 
所提供的的內容什麼時候過時

00:44:02.876 --> 00:44:04.144 
需要注意的一點是

00:44:04.278 --> 00:44:07.748 
WatchKit外設更新

00:44:07.814 --> 00:44:09.583 
complication動作是預設

00:44:09.950 --> 00:44:12.653 
所以你儘可能使之儘快完成

00:44:12.719 --> 00:44:15.489 
這樣就可以
一整天保持啓動狀態

00:44:15.722 --> 00:44:17.457 
以更新你的complication

00:44:19.026 --> 00:44:21.495 
正如我提到的關於這個話題 
有個很棒的演講

00:44:21.562 --> 00:44:23.664 
Creating Complications 

00:44:23.730 --> 00:44:26.600 
with ClockKit 
如果你還沒看過 我們希望你去看一下

00:44:27.734 --> 00:44:29.436 
下一個你必須做的事是

00:44:29.503 --> 00:44:32.005 
如何將內容
放到你的complication

00:44:32.272 --> 00:44:35.843 
有個特別的示例即初始激活

00:44:35.909 --> 00:44:39.746 
用戶首次進入時鐘畫面時

00:44:39.880 --> 00:44:41.181 
他可以進入對其進行編輯

00:44:41.849 --> 00:44:43.550 
會啓動你的complication

00:44:43.617 --> 00:44:45.752 
這裏指的是
新app complication

00:44:45.986 --> 00:44:46.987 
此刻

00:44:47.054 --> 00:44:50.023 
那個
complication的時間軸上

00:44:50.090 --> 00:44:51.725 
數據可能很少或甚至沒有數據

00:44:52.392 --> 00:44:54.328 
所以它對內容有大量的需求

00:44:56.230 --> 00:44:57.965 
馬上要做的是

00:44:58.031 --> 00:45:00.000 
立即在後臺啓動WatchKit外設

00:45:00.667 --> 00:45:03.203 
現在 你有很多方式可以獲得內容

00:45:03.470 --> 00:45:06.473 
所以 你可以初始化時間軸

00:45:09.009 --> 00:45:11.979 
你可以調用NSURLSession
與服務器通訊

00:45:12.446 --> 00:45:14.248 
從而獲得內容

00:45:15.249 --> 00:45:17.618 
或可選擇使用
WatchConnectivity

00:45:18.352 --> 00:45:20.087 
若你在這個特別情況下

00:45:20.153 --> 00:45:22.356 
使用
WatchConnectivity

00:45:22.422 --> 00:45:26.226 
設備是連接的
你會發現可達性爲True

00:45:26.293 --> 00:45:28.328 
這是亞歷克斯先前提到的

00:45:28.629 --> 00:45:30.030 
在特定情況下

00:45:30.097 --> 00:45:32.332 
這時候的這個屬性是True

00:45:32.399 --> 00:45:33.300 
這是其中之一

00:45:33.934 --> 00:45:37.204 
在這個示例中
另外可調用Send Message

00:45:37.471 --> 00:45:40.507 
它將把信息傳輸到iPhone上

00:45:40.941 --> 00:45:44.845 
我們將在後臺啓動天氣app

00:45:45.646 --> 00:45:48.382 
此時 iOS上的天氣app

00:45:48.448 --> 00:45:52.119 
可以使用任何
WatchConnectivity

00:45:52.186 --> 00:45:54.721 
API返回信息並填充到時間軸

00:45:58.358 --> 00:45:59.226 
總的來說

00:45:59.293 --> 00:46:01.295 
當你運行初始激活時

00:46:01.528 --> 00:46:03.830 
WatchKit外設將在後臺啓動

00:46:03.964 --> 00:46:06.733 
你可以使用
NSURLSession或者

00:46:06.800 --> 00:46:09.736 
因爲這是非常特殊的情況

00:46:10.070 --> 00:46:13.207 
WatchConnectivity
API啓動iOS app

00:46:13.340 --> 00:46:14.775 
因爲可達性爲True

00:46:15.442 --> 00:46:16.710 
我建議你用這個

00:46:16.777 --> 00:46:19.780 
儘可能多
的填充ClockKit時間軸

00:46:19.980 --> 00:46:22.316 
因爲開始時 裏面沒有數據

00:46:23.717 --> 00:46:26.854 
接下來是如何保持最新狀態

00:46:28.088 --> 00:46:29.656 
你的時間軸現在已被填滿

00:46:29.723 --> 00:46:31.758 
而更新也即將開始

00:46:31.825 --> 00:46:33.794 
如何
保持更新complication

00:46:35.295 --> 00:46:36.496 
有很多不同的方法

00:46:36.563 --> 00:46:39.566 
可以用來
更新你的complication

00:46:40.033 --> 00:46:42.436 
你可以將
內容傳輸到complication

00:46:43.036 --> 00:46:45.372 
也就是說 若你有個外部源

00:46:45.439 --> 00:46:48.175 
比如說web服務器 
它知道新內容出現的具體時間

00:46:48.242 --> 00:46:51.144 
而且是不定期更新的

00:46:51.812 --> 00:46:53.714 
你將做的是

00:46:53.780 --> 00:46:55.849 
將內容從雲中拿出 放到iPhone

00:46:56.183 --> 00:46:57.985 
然後傳輸到Apple Watch

00:46:58.952 --> 00:47:02.155 
我們比較容易理解這點的
一個示例是比如體育app

00:47:02.356 --> 00:47:05.792 
顯示比賽
分數時就是complication

00:47:06.693 --> 00:47:07.561 
多數時間裏 

00:47:07.628 --> 00:47:10.697 
分數只在一天當中
很短的一段時間內發生改變

00:47:10.764 --> 00:47:12.766 
所以可以很快進行更新

00:47:13.066 --> 00:47:15.435 
然後 接下來我們認爲
更合理的方法是使用推送方法

00:47:15.569 --> 00:47:18.205 
另一個方法是我正在調用請求間隔讀取

00:47:18.672 --> 00:47:20.674 
這個更多的是用在
你知道有定期更新的情況

00:47:20.774 --> 00:47:23.076 
這樣你可以保持
更新你的complication

00:47:23.143 --> 00:47:24.912 
可用
像NSURLSession

00:47:24.978 --> 00:47:27.147 
直接進入雲

00:47:27.781 --> 00:47:32.152 
有些衝浪app帶有
潮汐complication

00:47:32.319 --> 00:47:34.454 
顯示潮汐模式

00:47:34.521 --> 00:47:37.724 
這樣你就可以知道
什麼時候可以衝浪了

00:47:38.959 --> 00:47:40.961 
我們先來看一下這個例子

00:47:44.665 --> 00:47:47.701 
你想用NSURLSession
和ClockKit

00:47:47.768 --> 00:47:49.236 
更新complication

00:47:49.303 --> 00:47:51.505 
從時鐘畫面的角落可看到

00:47:51.572 --> 00:47:53.941 
衝浪complication
已經啓動

00:47:55.776 --> 00:47:58.045 
這個流程看起來是這樣的

00:47:58.111 --> 00:48:00.647 
在後臺啓動的WatchKit外設

00:48:01.181 --> 00:48:04.084 
你想創建一個
NSURLSession請求

00:48:04.151 --> 00:48:06.453 
並將它發送到服務器
以獲取內容

00:48:07.287 --> 00:48:09.056 
服務器將生成一個響應

00:48:09.122 --> 00:48:11.625 
並將傳輸回WatchKit外設

00:48:12.359 --> 00:48:15.229 
現在你想打開並更新ClockKit

00:48:15.295 --> 00:48:18.732 
你將要求他們
擴展你的時間軸

00:48:19.466 --> 00:48:22.002 
它們將通過問問題開始

00:48:22.069 --> 00:48:24.538 
你將提供過去 現在的
時間軸更新

00:48:24.638 --> 00:48:28.141 
最後 你將給出一個建議時間

00:48:28.208 --> 00:48:29.610 
什麼時候應該再次啓動

00:48:31.979 --> 00:48:35.282 
最後一件事

00:48:35.349 --> 00:48:37.484 
當你提供下次啓動時間時

00:48:37.551 --> 00:48:39.419 
系統會獲得
你的工作已經做完的提示

00:48:40.020 --> 00:48:43.390 
你的WatchKit外設也將被隔離

00:48:44.892 --> 00:48:47.060 
現在 我們假設經過一段時間後

00:48:47.494 --> 00:48:50.898 
系統根據你的提示和系統條件

00:48:51.031 --> 00:48:53.534 
認爲現在是
重啓complication的

00:48:53.600 --> 00:48:55.502 
最好時間

00:48:56.303 --> 00:48:58.405 
再一次 你將在後臺啓動

00:48:59.106 --> 00:49:01.341 
你將調用NSURLSession
生成一個請求

00:49:01.408 --> 00:49:03.043 
你將把它發送到服務器

00:49:03.710 --> 00:49:05.479 
服務器將生成一個響應

00:49:05.679 --> 00:49:09.650 
你將使用ClockKit打開並
更新你的complication

00:49:14.154 --> 00:49:17.491 
概括一下 我們建議你

00:49:17.558 --> 00:49:20.561 
如果可能的話就使
NSURLSession後臺會話

00:49:21.328 --> 00:49:23.931 
這是因爲 在下次外設運作之後

00:49:23.997 --> 00:49:25.866 
NSURLSession
請求才會完成

00:49:26.099 --> 00:49:27.534 
使用後臺會話 

00:49:27.601 --> 00:49:29.603 
可使它在下次運作時傳輸內容

00:49:32.172 --> 00:49:35.342 
提供的請求時間只是給系統的一個建議

00:49:35.409 --> 00:49:36.577 
並不能保證確實如此

00:49:37.010 --> 00:49:40.380 
我們將盡可能逼近準確時間
而且使用條件

00:49:40.747 --> 00:49:43.116 
在這時候也不一定總是滿足

00:49:44.251 --> 00:49:46.553 
我們建議你讓運作時間
儘可能的短

00:49:46.887 --> 00:49:49.723 
你調用ClockKit更新時鐘畫面

00:49:50.123 --> 00:49:52.059 
你想讓運行時間儘可能的短

00:49:52.459 --> 00:49:58.232 
而且讓下次更新請求的
時間間隔儘可能的大

00:49:58.298 --> 00:50:01.935 
因爲這是預設的 
你不想在一天結束之前就用完這些安排

00:50:03.437 --> 00:50:06.206 
另一個獲得內容的方法

00:50:06.273 --> 00:50:08.775 
比如在使用體育app的示例中

00:50:09.176 --> 00:50:10.577 
是推送這些內容

00:50:14.581 --> 00:50:16.383 
我們將在不同數個階段中查看內容

00:50:16.450 --> 00:50:19.820 
因爲這會用到兩個非常獨特的進程

00:50:19.887 --> 00:50:23.590 
首先 你用PushKit

00:50:23.690 --> 00:50:26.660 
將內容從雲推送到iPhone

00:50:29.897 --> 00:50:32.199 
第二部分是用
WatchConnectivity

00:50:32.266 --> 00:50:35.936 
將內容從iPhone
推送到Apple Watch

00:50:36.737 --> 00:50:37.871 
我們分別來看一下

00:50:39.173 --> 00:50:41.441 
所以第一部分是

00:50:41.575 --> 00:50:43.577 
用PushKit
將內容傳輸到iPhone

00:50:44.311 --> 00:50:46.780 
你已更新PushKit框架

00:50:47.648 --> 00:50:50.350 
從而支持
complication推送

00:50:50.417 --> 00:50:53.453 
使用方法是創建一個
PKPushRegistry實例

00:50:55.289 --> 00:50:57.791 
接下來 你將自己設置成指派

00:50:57.858 --> 00:51:00.427 
這樣 你就可以接收回調了

00:51:01.695 --> 00:51:04.097 
最後 你將設置推送類型

00:51:04.164 --> 00:51:06.400 
並傳輸新PK推送類型
complication

00:51:06.466 --> 00:51:08.402 
這是之前添加到iOS9中的

00:51:09.102 --> 00:51:12.606 
一旦完成 你將收到
帶新Push記號的指派回調

00:51:12.673 --> 00:51:16.310 
之後上傳到你的服務器

00:51:16.376 --> 00:51:19.213 
也將讓服務器可以將推送發送到設備上

00:51:20.013 --> 00:51:21.682 
最後 當服務器發出推送時

00:51:21.748 --> 00:51:23.283 
將收到攜帶負載
Did Receive

00:51:23.350 --> 00:51:24.751 
Incoming Push回調

00:51:24.818 --> 00:51:26.086 
這是你可以返回來 

00:51:26.687 --> 00:51:28.822 
使用
WatchConnectivity

00:51:28.889 --> 00:51:30.924 
API 將內容發送到iPhone時

00:51:36.697 --> 00:51:37.965 
所以 第二部分 這時候

00:51:38.031 --> 00:51:40.868 
可以使用
WatchConnectivity

00:51:40.934 --> 00:51:42.836 
將在iOS app上收到的內容

00:51:42.903 --> 00:51:44.638 
發送到
Apple Watch app

00:51:47.741 --> 00:51:49.376 
首先要用到的是

00:51:49.443 --> 00:51:52.880 
亞歷克斯先前說到的
傳輸用戶信息API

00:51:54.181 --> 00:51:56.517 
這種方式可讓你項目排隊等候

00:51:56.884 --> 00:51:59.853 
Watchcomplication
可能需要的

00:51:59.920 --> 00:52:02.789 
爲過去和未來的時間軸

00:52:04.091 --> 00:52:06.660 
一旦所有的時間軸項目排完隊

00:52:07.127 --> 00:52:09.496 
在完成工作前需要做的
最後一件事是

00:52:09.563 --> 00:52:11.732 
調用一個專門的API

00:52:12.099 --> 00:52:13.901 
WatchConnectivity
的一部分

00:52:13.967 --> 00:52:16.670 
它調用了傳輸當前
complication用戶信息

00:52:16.770 --> 00:52:19.039 
這是傳輸用戶信息的專門版本

00:52:19.106 --> 00:52:20.174 
不管在什麼時候

00:52:20.240 --> 00:52:22.809 
只允許存在一個當前
complication用戶信息

00:52:22.876 --> 00:52:24.611 
若你調用兩次

00:52:24.678 --> 00:52:27.814 
只有最後一次被標記爲當前
complication用戶信息

00:52:29.349 --> 00:52:30.450 
當你調用時

00:52:30.517 --> 00:52:32.419 
對於系統來說 意思是事情已經做完了

00:52:32.886 --> 00:52:36.356 
在接收方 所有的回調
將生成這個指派回調

00:52:36.423 --> 00:52:38.358 
Did Receive
User Info

00:52:41.929 --> 00:52:44.998 
所以 總體而言

00:52:45.065 --> 00:52:47.434 
這流程看起來像什麼呢 好的

00:52:48.268 --> 00:52:52.606 
所以 當用戶第一次啓動
一個體育app時

00:52:53.607 --> 00:52:55.843 
app在其使用週期的知哦啊其

00:52:55.909 --> 00:52:59.146 
將建立PK推送註冊表
並設置期待類型

00:52:59.546 --> 00:53:02.482 
然後註冊該推送類型

00:53:02.583 --> 00:53:04.785 
即帶Apple推送服務器的設備

00:53:05.252 --> 00:53:07.287 
然後類型推送到Apple服務器上

00:53:08.088 --> 00:53:10.257 
隨後將反過來生成一個Push記號

00:53:10.324 --> 00:53:12.693 
然後你將在你的iOS app上
收到指派回調

00:53:14.895 --> 00:53:17.998 
你需要收到該記號
並上傳到你的服務器

00:53:18.765 --> 00:53:20.100 
這樣以後 你的服務器

00:53:20.167 --> 00:53:21.902 
就可以發送推送到這個設備了

00:53:22.536 --> 00:53:25.839 
這個時候 
PushKit初始化設置就已經完成

00:53:26.707 --> 00:53:27.808 
不需要用到你的app了

00:53:28.675 --> 00:53:31.745 
假設這一切開始了 服務器決定

00:53:31.812 --> 00:53:33.514 
更新complication

00:53:33.580 --> 00:53:36.683 
它將發送一個推送到你的設備上

00:53:38.452 --> 00:53:40.721 
設備將收到推送

00:53:40.787 --> 00:53:43.624 
我們將在後臺啓動體育app
傳輸推送

00:53:43.790 --> 00:53:45.092 
那是另一個指派調用

00:53:46.426 --> 00:53:49.329 
這時候 你需看看
推送負載上的數據

00:53:49.463 --> 00:53:52.266 
確定如果要使用
WatchConnectivity

00:53:52.332 --> 00:53:53.700 
需要發送些什麼

00:53:55.369 --> 00:53:57.070 
你將調用
Transfer User Info

00:53:57.137 --> 00:54:00.474 
將過去和未來的時間軸項目加入列隊

00:54:00.874 --> 00:54:03.377 
然後我們可以訪問
未解決用戶信息傳輸列隊

00:54:03.911 --> 00:54:07.581 
然後調用專門傳輸當前

00:54:08.048 --> 00:54:09.516 
complication
用戶信息的重要隊列

00:54:09.583 --> 00:54:11.852 
這也是將在Watch表面顯示的隊列

00:54:13.387 --> 00:54:15.455 
它將進入
未解決用戶信息傳輸隊列

00:54:15.522 --> 00:54:16.790 
但會跳過開頭

00:54:16.890 --> 00:54:18.425 
因爲它是最重要的隊列

00:54:19.426 --> 00:54:22.963 
而且被指定爲緊急優先

00:54:23.297 --> 00:54:25.899 
我們將立即把它傳輸到
Apple Watch

00:54:26.533 --> 00:54:29.036 
然後在後臺啓動WatchKit外設

00:54:29.303 --> 00:54:32.005 
傳輸當前complication
用戶信息

00:54:33.473 --> 00:54:36.810 
如滿足相關條件 
部分內容也會同時傳輸

00:54:36.877 --> 00:54:38.712 
你將獲得其他時間軸項目

00:54:38.779 --> 00:54:41.248 
但是最重要的隊列一定會被傳輸

00:54:42.916 --> 00:54:45.886 
最後 可以使用ClockKit

00:54:46.153 --> 00:54:48.388 
更新你的complication

00:54:55.562 --> 00:54:58.966 
就是這樣你已使用PushKit
更新了complication

00:54:59.466 --> 00:55:02.302 
我們已經添加新PK
推送類型complication

00:55:02.369 --> 00:55:05.105 
你可以使用服務器上的信息

00:55:05.572 --> 00:55:07.808 
快速更新complication

00:55:08.609 --> 00:55:09.710 
使用這些推送類型

00:55:09.776 --> 00:55:11.245 
還有很多限制條件

00:55:11.311 --> 00:55:14.047 
complication在時鐘畫面
必須是處於活躍狀態

00:55:14.448 --> 00:55:16.149 
否則將無法進行推送

00:55:17.284 --> 00:55:19.386 
且每天的推送數量也是有限的

00:55:19.453 --> 00:55:20.621 
所以 請節約使用

00:55:20.687 --> 00:55:23.156 
平均大概是每小時1到2個推動

00:55:23.223 --> 00:55:26.260 
但體育app可能在很短的時間內
全部用光

00:55:27.794 --> 00:55:29.229 
你可使用傳輸用戶信息

00:55:29.296 --> 00:55:30.564 
對時間軸項目進行列隊

00:55:30.631 --> 00:55:32.933 
最後 你可以使用
傳輸當前complication

00:55:32.999 --> 00:55:34.668 
用戶信息列隊當前

00:55:34.735 --> 00:55:36.136 
或現有的時間軸項目

00:55:37.137 --> 00:55:40.240 
可使用ClockKit更新時鐘畫面

00:55:40.874 --> 00:55:43.577 
請記住 很多這些事都是有預算限制的

00:55:43.644 --> 00:55:46.680 
在iOS和WatchKit上執行的

00:55:46.747 --> 00:55:49.583 
complication
更新的任何操作 

00:55:49.650 --> 00:55:50.951 
都會消耗預算

00:55:51.485 --> 00:55:54.354 
我推薦 將你需要用來
更新complication的

00:55:54.421 --> 00:55:56.657 
任何信息都包括在推送中

00:55:57.324 --> 00:56:01.662 
complication
推送類型有4K有效負載

00:56:01.728 --> 00:56:04.798 
大於標準負載 
所以你可以將需要的大部分

00:56:04.865 --> 00:56:05.732 
信息放入其中

00:56:05.799 --> 00:56:07.734 
若你收到其中一個推送

00:56:07.801 --> 00:56:11.004 
並打開iOS app
提交NSURLSession請求

00:56:11.238 --> 00:56:12.873 
你將很快就消耗完預算

00:56:12.940 --> 00:56:16.143 
請確保所有你需要的內容都在推送中

00:56:19.413 --> 00:56:20.981 
這部分就到此結束

00:56:22.049 --> 00:56:23.984 
簡要地討論下我們今天所說的

00:56:24.051 --> 00:56:26.353 
我們說了框架
WatchConnectivity

00:56:26.420 --> 00:56:27.321 
和API

00:56:27.754 --> 00:56:30.424 
我們很期待看到
你們用這些API做出來的東西

00:56:31.124 --> 00:56:33.560 
簡要地討論了
NSURLSession和使用方法

00:56:33.627 --> 00:56:35.796 
還有其他部分

00:56:35.929 --> 00:56:39.600 
深入地討論NSURLSession
及如何使用NSURLSession

00:56:40.100 --> 00:56:43.103 
最後 我們討論瞭如何
把數據放到complication

00:56:43.270 --> 00:56:44.605 
這是個更爲高級的話題

00:56:46.540 --> 00:56:49.076 
還有很多可以查看的重要資源

00:56:49.142 --> 00:56:50.644 
我們有一些很棒的樣本代碼

00:56:50.711 --> 00:56:54.948 
我們也有專員
他們已經準備好回答你的問題了

00:56:56.950 --> 00:56:58.585 
關於其他的內容

00:56:58.886 --> 00:57:01.388 
建議你看Creating 
Complications

00:57:01.455 --> 00:57:04.124 
with ClockKit以及
Networking with NSURLSession

00:57:04.191 --> 00:57:06.326 
因爲他們
與我們今天討論的內容緊密相關

00:57:07.394 --> 00:57:08.495 
謝謝