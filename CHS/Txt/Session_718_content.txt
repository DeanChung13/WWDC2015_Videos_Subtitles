用GCD构建具有响应性的高效app
早上好
欢迎来到本次讲座 题目为用GCD构建具有响应性的高效app
我们非常高兴看到这么多的人有兴趣
学习如何利用多线程优化技术来帮助你们的
应用程序适应我们所有的平台
我是Anthony我将和我的队友Daniel一起呈现这段演讲
多线程优化技术或者叫GCD是与OS X Snow
Leopard操作系统一起引入的一种技术
当时我们的最新版的Mac
还是使用Core IIDuo的MacBook Pro
当时GCD的卖点之一是
它让你可以使用双核
同时运行应用程序的不同部分
并使线程变得非常非常容易
我们认为GCD的使用真的经受住了时间的考验
今天我们最先进的Mac Pro有多得多的内核
而GCD仍然是利用这些所有计算资源
的好方法
但正如GCD有助于利用所有高端
资源一样 它还可以帮助你的应用程序
适应较小的环境
比如最近发布的新MacBook是
第一个无窗格的设计
虽然就机型体积而言
这是一个优势 但如何管理热性能而言
它也带来一些独特的挑战
稍后我会谈到你们的app如何利用GCD
从而在这种环境下更有效地运行
我们iOS 9也有了 新多任务功能
这是第一次你们的应用程序必须肩并肩地
这种说法毫不夸张与其他应用程序一起在系统中运行
GCD可以告诉系统你正在做什么
并能够更好地在你的应用程序和其他
出现在屏幕上应用程序之间分配资源
有了Watch OS系统即便我们最小的平台都能识别你的代码
GCD可以帮助系统知道你应该运行哪些部分
的代码才能让你在这么大的设备上
构建起具有响应性能的应用程序
所以我要先简要概述我们今天将要讨论的内容
我首先会介绍所谓的服务质量类别
我们与iOS 8和OS X Yosemite发布的一款API
Daniel来讲解它针对GCD使用
一些设计模式以及
如何整合QLS与这些模式
然后我会详细讲解线程 队列
并运行可以使GCD更便于使用的循环
最后我们会就如何理解使用GCD时
的崩溃报告得出一个简短的结论
但首先需要一点背景
你们构建起非常棒的app
然后开始执行这款app用户触碰它的图标
从finder中进行下载
我们将开始执行主函数中的代码
那么你们将得到每个app用以开始的
最初的主线程
你们调用应用程序UI函数 或者NS应用程序函数
接着会弹出一个线程上的运行循环
和框架代码
然后线程会停在那里等待事件
在某一时刻会有事件发生
也许你会得到一个调出的委派模式
到你的应用程序委托UI
这时你的代码开始运行
需要完成某项任务比方说从数据库读取信息
你发出指令访问磁盘上的该文件
就会返回相应数据
你会更新用户界面
最后返回控制到框架
并继续等待线程上的事件
这些进展都很顺利 只是
从数据库读取信息需要一点儿时间
在OS X系统此时你可能会看到一个旋转的等待光标
iOS系统里app会暂停甚至被终止运行
这种用户体验不仅糟糕而且未得到响应
出现这种情况GCD就可以参与进来
帮助提高运行效率
你会得到调出的委派模式
但是不要立即开始进行操作而要创建一个GCD队列
使用异步分派把任务移动到尾接
你的代码与主线程异步执行
等你们得到了数据
就可以异步分派回主线程更新用户界面
这样做的优势在于当你的任务在GCD队列运行时
主线程可以继续等待事件
它始终保持响应状态
用户可以获得持续的良好体验
大家都感到满意
我希望这是一个
大家都熟悉的模式
我们不会详细谈论
如何做到这一点
如果你们不熟悉 我强烈建议各位在今天的
演讲之后去一趟去普西迪听一听那里的讲话
里面将详细讲述这种模式
有一点你们之前可能没有想过
我们现在有两个线程两个都要执行代码
主线程要处理新事件
GCD队列要
执行你派遣的任务
也许这两个任务都在一个核心设备上
在这种情况下我们要执行哪个线程呢
这里服务质量类别就要发挥作用了
这是一个在iOS 8和10Yosemite系统中的新的API
于去年发布
我们有四个服务质量类别：用户交互模式
用户发起模式效用和背景
通过这些方法你可以告诉系统你们正在进行哪种任务
它也使系统能够提供各种资源控制
以最有效地执行你的代码
说到资源控制什么是资源控制
我们的系统支持CPU调度优先级
我们要运行哪些线程以什么顺序运行
说到I / O优先级当系统中有多个I / O时
应该以什么顺序执行呢
计时器聚合技术是一个省电的功能
无论我们按照吞吐量还是以效率
导向模式运行CPU
我们想要获得最佳的性能还是想要
以最节能的方式执行的代码
在理想情况下为每个平台或设备优化
这些配置值或设备运行的代码
但显然这种做法很快会难以为继
许多配置值很难调整 而代码
运行的平台数量众多
服务质量类别被设计成
一个抽象参数你们可以使用
这个参数描述任务的目的和类别
不要试图调整所有
具体的配置值你们要明白自己所做的都
“由将要执行工作的用户启动”
而系统将自动为平台和设备
选择正确的配置值
我前面提到过我们有四个服务质量类别
接下来我要对它们进行简要介绍它们分别有什么用途
第一个是用户交互模式
这是主线程
假设有一个iOS应用程序用户的手指
正在屏幕上拖动
主线程需要响应以便在
用户手指拖动时交付
下一帧动画
主要用户交互代码是保持动画
以每秒60帧的速度平稳运行的专门代码
所以你们需要问自己这项工作是否积极参与
到更新UI之中
在决定是否需要进行用户交互式设计时这一点一定要加以考虑
这不是在加载可能成为滚动视图的内容
这就是在画新的动画
我们所说的用户发起模式是指加载由用户
完成的动作结果
比如当我翻动滚动视图
为下一个单元加载数据时
或我在使用照片或邮件应用程序并点击电子邮件或照片
加载全尺寸照片或电子邮件时
这些行为就是我们所说的用户发起的动作
问题是要继续进行用户交互
是否需要这项工作
对其中任何一个都没有帮助
作为用户发起而不是用户拦截
如果用户不能通过你们的应用程序继续
取得有意义的进展就应该选择用户发起模式
效用是指用户本来可能已经开始进行
或已经自动启动任务
这些任务长时间运行但是并不阻碍用户
继续使用你们的应用程序
你们要问问自己用户是否了解
这项工作的进展
如果一个杂志app正在下载新刊物
那么用户可以继续使这个app下载任务可以同时进行彼此互不干扰
他们可以阅读往期刊物或随意浏览
你们可以设计一个进度条
帮助用户了解进展情况
效用是一个很好的类别
最后其余的一切都可以归为背景
用户不会主动关注的一切
任何类型的维护任务 清理工作
数据库清空都属于背景
根本问题是
用户有没有意识到这项工作
背景工作很有趣 因为你要
考虑何时处理背景
我强烈建议你们去看一看
去年关于编写节能代码的那部分演讲
该演讲讨论了如何有效地做好背景工作
如何判断你们的应用程序背景是否表现出色
所以我提到了我们的新MacBook
就像我说的这是第一款无风扇的Mac
在之前有风扇的Macbook里
机器处理的工作越来越多 产生的热量
也越来越多 那么我们可以加快
风扇转速来帮助热量更快消散
新版MacBook非常节能令人惊讶
我们不需要风扇散热在大多数情况下
但全速运转该机器仍然会
产生一些热量我们需要驱散
但是我们驱散热量的能力是有限的
我们有其他技术确保我们能让
机器保持适当的温度适合使用者使用
假设你有一款正在使用的app然后你已经完成工作
按服务类的四项质量指标而言
你正很努力的开动机器用了很多的能量
而我们需要帮忙控制控制热量的多少
这样能让机器在合理的温度中工作
好了我们能做的是我们能开始挤出我们的工作量
我们将要做的是
比较不重要的服务质量标准
这就允许我们管理这个系统能量的使用
保持机器响应及时确保了
没有无反应情况 让使用者看到
这个方式很重要
因为你让你的工作正确分类了
在运行一个像这样的机器时
我还提到iOS以及新的多元任务的特点
你可以想象在古老的世界里我们可能会有你的app
的主要思路而且可能它还有另外的分派线程
在使用但是现在我提出了另外一款app
那款app也将会有一个主要思路
然后我也有Picture inPicture
那款也有一个思路解码视频
好了但是我也只是拥有两个CPUs
所以如果我不得不使用其中之一来解码视频
对于下一个我该做些什么呢
这是另外一个领域对于质量
服务标准来说能真正帮你解决问题
表明了操作系统的服务质量标准的
每一个线程我们都可以准确决定
在哪里安排那些可用的资源
通过那些我会转交东西给Daniel
他会检查特定的设计模式以及对那些类型如何应用服务质量标准
早上好 谢谢 Anthony
本章我们会看几个
关于GCD设计和QOS是如何应用的具体的例子
首先我们从最基本的开始 先看GCD
和QoS 在每个独立模块的层次上
是怎样被细分的例如QoS 从提交线程到
异步运行模块
有一个整体功能模块
和一个异步分派模块
以及相关的自动传播QoS模块
那么这个系统是怎样为你
自动切换一些优先级别的呢？
没有时间深入地讨论具体的API命令
如果你想了解更多的细节 我建议你
看看去年的演讲内容"功率 性能
和诊断: GCD和XPC的新内容"
那么你就能在开发者的网站看到
我们在如何使用API的问题上已经讲了很多具体内容
这是去年的新课程
第一个例子是 Anthony很早就有了的
在主线程的提示下执行了一些异步工作
在GCD上做了些I/O
这个例子怎样适应于QoS？
什么是可以被应用在这里的
适当质量的服务等级呢？
当然在左手边我们有主线程
Anthony说过是UI呈现的地方
这里是事件处理的地方
合适的调用服务命令是用户互动命令
这些都是无条件获得的
应用程序的主线程就在这种质量的服务等级下服务等级下出现
在屏幕右手边
是没有出现在主线程的异步工作
很明显我们不应该启动用户互动
这里我们不是在做UI呈现
而是在说正盯住文件图标
正在等待他的文件打开的用户
用户已经在使用此app前就被绊住了
他仍然能和用户界面互相影响但是并不能做所有他想做的事情
比如编辑文件或者查看文件
用户初始化是服务的最佳质量
如何通过GCDAPI达到这个目标
其实你不需要做任何事情
它就会自动实现
但重要的是理解为什么会这样
让我们详细来看一下
所有程序都起源于初步调动async
它能从主线程消除异步工作
正如我在前一个幻灯片里讲的那样
async异步分派会从你提交块执行
服务线程队列
自动传播服务质量
在这个例子中有一个特殊的规则适用于
我们自动转译的用户交互用户发起的服务质量
这样做我们就避免了过度传播
应该受到限制的服务质量
到主要的线程和呈现的用户界面
我们可以好好利用此法
因为这正是我们想要的
通常情况下
在用户发起的服务质量队列上
都是通过自动传播来运行
当你用自动传播也试着进行的结果
回到主线程去更新
用户界面
因为用户主线程是服务用户交互的质量
所优先考虑的
如果你去一个线程 它不会降低
那些主线程上指定的
服务质量
这里我们将忽略传播的价值
来在用户交互服务质量底部运行用户界面修改块
运行用户界面修改块
我们调用QoS传播属性推断QoS
这是块被提交至一个队列时被捕获的QoS
和特殊规则
我们转译用户交互至用户初始化
正如上文提到的
如果目的地提交之处
没有自己的指定的服务质量
在分配自己的高质量的服务主线程的情况下
也不降低QoS就将用到这种传播的服务质量
下一个例子是不能自动开启任务的情况
长期运行的任务比如说在一个异步调用的长期
的运算中 关闭主线程
用户界面就不能更新它正在处理主线程的当前队列
可能会更新UI 通过一个异步
返回块的进程
这个块包含了更新一些用户界面元素
那么什么才是合适的服务质量类呢？
在你左手边是用户互动
右手边是之前描述过的Anthony
这就是适合质量服务
程序运行的情景
它是长期运行的
用户可以继续使用用户界面
不用等待就会得到想要的画面
他也可以看一些进程 以某种方式发起
的进程 但是这并不会影响到之前的界面
我们怎么用GCD API实现它呢？
最简单的解决方法是关注
任务的产生和发起
这是异步调用的开始
我们以标记我们提交
的带有合适的质量服务类的块
通过调用块生成质量服务类的接口
我们传入想执行的块或者
我们想要的质量服务类
应用程序就有了
这就是生成的异步调用的
块对象 当它被执行的时候
会在质量服务类的应用程序里运行
通过查找最初
质量服务类变化的点
就会自动传递给下一步执行
如果那个块发生变化 就会利用
自动执行这个特性
因此产生的
任何异步线程将会自动运行
相对应的质量服务类
并继续作为应用程序这期间你不需要做任何事
在前面的幻灯片上我们可以看到这个
质量服务块被创建通过显示的给块对象添加质量
服务属性的方式来实现你只需要提供合适的调用时间
当任务产生不同的类的时候
另一个质量服务应用在块对象中的案例
当你需要捕获你提供块的
质量服务类时
就是说在一个回调块的方案中你正在写一个接口
别人提供给你一个回调块 你想
在另一个队列或者线程中保存并提交它
但是你很想让它
像异步调用
质量服务程序那样被执行
你可以去分派现有指定模块
由创立分配模块标识并通过
它会捕捉到现有的QOS和执行状态
在提交模块后把它保存到快速模块中
它会按分配值在一个队列上运行
看看另外一个我们的应用程序案例
它执行了一个UI操作
在操作测试性能时
它通告显示处于维护状态中
并即将执行清除状态
还说里面有一个数据库有太多的松散区
不得不进行一些压缩程序和清除任务
还有一个GCD应用的典型例子
在执行异步分配运行的地方
后台列队上的维护任务
当然是在左手边的
作为用户会重新启动用户界面
在这里相应的服务质量等级
将用于服务背景质量上
目前鉴于幻灯片的标题
这只是一个维护操作
与用户做了些什么不相关系
你通告出此时你正在进行的状态
用户此时并未察觉发生了什么
你要做的工作是关于APP的工作
基于此处自已利益上的工作
我们怎样才能取得服务后台的运行质量
我们能做的一件事就是早点看到API模块的应用
让初始异步此队列成为
后台服务的质量
也许这件事在APP中是比较多样性的
以此而成清除工作的类型
同时你也有多样的方法
可以在这个模式下的数据库上进行操作
这要用一个适当并特别的队列
精确地完成此任务 你才可能创立起
有指定服务质量的队列
你可以用QOS等级分派队列属性
通过如范例中后台
所生成属性通过并分配到创立队列上
创立一个如范例中清除队列
通过服务等级质量被指定到队列上
得到了异步分派的自动传播
用户再次从主流程启动
我们实际上忽略了传播的价值
因为你正在提交一个自身拥用指定服务等级质量的队列
并说可以用此队列来替代
所以你提交的模块将在后台运行
代替已经如果有的
自动系统
对于这样的情况
某处有一个与执行流程无关的维护任务
考虑调度程序块分离的标记是否有用是合适的
这是一种告诉操纵系统
你正对这个程序块所做的事情
与执行流程无关的方式
而且它尤其不参与QoS的传播
也不捕捉事物 如活动ID
如果你正在去年我们会上介绍过的活动追踪特性中使用它
和其它一些执行上下文的性质
当然即使你有工作
它总是应该在QoS背景里
那是些清理性的工作 是可例外的
如一些退出特性 用户退出他的账户
你应该删除数据库
及用户的私人数据
那是一些用户希望能看到它完成的事情
这不该是后台任务
你有必要在后台属性中重写
或退出你这里已经设置过的
这个队列或这个运行
如果这里你仅用自动传播特性
像以前一样除了这里 我们应该忽略
用户初始的QoS
当然这是可用的合适的QoS
这是我们真正期望的
用户正在等待这个退出结束
如何达成呢？
利用调度程序块执行QoS分类标志
程序块创建和你想执行的程序块
那是在告诉系统
你真的希望程序块中的数值
与队列中的相反
这样你可以重写队列的数值显示
如果你这样做程序块将在本例中
用户初始的QoS分类中执行
但是 当然 在图中
你可以看到现在的情况：
你有个别潜在含两个程序块的队列
两程序块是同时的且有不同的优先级别
这就是异步优先级反转翻转
一个高级QoS程序块可能被提交给一个串行队列
但是队列中已有工作
或在更低级的QoS中运行
你有优先权翻转
GCD会帮助你如果你通过提升
串行队列中的工作来使用串行队列
运行或是入队直到你达到高级别的QoS程序块
这是后台QoS覆盖出现问题
并非重写块调用自身的问题或者如果将任务非同步传输下去
程序块将以原始QoS状态传输
但程序块将以更高优先级执行从而消除块的反转执行
概括说QoS队列排序大多适合那些
在应用程序中排序是唯一用途的场景
或者输入的指令不需要考虑登录优先级的重要性
而需要考虑的是指令用途的优先级
QoS队列排序还可用于
为这种类型的工作负载所开发的独立的程序块API
当这种负载处于维护或后台模式时
在队列中使用QoS会使我们忽略
异步block(块)中的QoS除非
我们在程序中使用强制执行标记
最后是利用串行队列实现lock(锁)的功能
这在GCD当中是很常见的用法
在程序当中你有一些共享的数据结构
而你想要锁定对这些数据结构的访问
你可以通过在数据结构中创建一个带有调用队列
标记的串行队列的方法来使用GCD
然后用同步调用来执行关键的区段块
在队列中只有这个block（块）有访问数据结构的权限
QoS在这个过程中是如何运行的呢注明”同步调用”函数很重要
当调用”同步调用”函数的线程
被锁定时执行块
返回block（块）的同时释放线程
这种情况下我们不需要任何额外的线程
我们只需要执行调用同步调用的线程
然后在所调用线程的QoS中执行块
此处指用户交互进程
当你可以使用同步
因为有其他的线程或队列
也在访问此数据结构
或许当执行一个QoS线程时在队列内调用”同步调用”函数
从而可以独占访问
数据结构
如果随后返回线程 同样的事情将出现
他将停止等待线程以获取独占访问权限
然后在调用QoS的线程中
执行自身
QoS线程中的块
我们就又会碰到如果这个独占访问以别的顺序获得
优先权翻转的问题
如果实用程序效用先进入锁死
主线程就必须等待效用线程
这当然是我们不期望的
所以QoS继承
异步优先级翻转会帮助你去解决
一个高级的优先级服务线程正在等待较低级别的进程工作
我们可以通过为等待期间
提高等待工作的QoS来解决 
如果你用串行队列和同步调用
或调用程序块等待API
如果你用多线程互斥锁
或任何建立在其上的API如NSLock也可实现
值得注意的是有些API在这里是不可用的
调度信号量不承认认同所有权概念
所以系统无法决定
谁最终将向信号量发信号
那种情况下没有任何优先权翻转的解决方案
如果你有优先级翻转
你在某调度信号等待中发现高级优先级等待者
低级别优先级工作者正在执行某些工作
你可能必须转变成调度程序块等待 
在我们能够进行提升的外显实体处等待
下面请Anthony讲一下队列线程和运行循环
谢谢 Daniel
希望这激起了你们对服务质量的兴趣
并愿回头看看这些应用
及思考一下如何应用服务质量
现在我们讲一下队列、线程及运行循环
希望能使GCD的更广泛被应用变得更简单
并为你调试应用程序提供一些背景
提醒我们自己我们的应用程序与
我们的主线程相关
GCD线程池
服务于GCD队列中的所有程序块
在应用程序中也有某些队列
想象一下你在主线程上执行代码
你异步调度到某队列
一程序块且我们会为此程序块启动一个线程
开始执行你的代码
在Delay之后我们将同时执行Object和Selector
且这将在当前线程的运行循环上
加入定时源
现在让我们想一下一秒后会发生什么？
结果是：当程序块完成时
线程可能会消失
这些是我们临时线程池里的线程
他们没有任何可确保的有效期
我们可能会破坏这个线程
当然即使线程保留了下来 
也没人在实际地运行那个运行循环
那个计时器将永远不会被触发
这是一个有趣的互动
当你混合基于运行循环与调度队列的API时发生的
简单的总结一下运行循环与
串行队列的区别：运行循环束缚于
某一特定线程
一般看到API通过委托方式被回调
他们拥有在整个运行循环源中的
每次迭代后出现的自动释放池
且运行循环可以被重新进入使用
通过调出运行循环以使运行循环自旋也是可能的
另一方面串行队列
或调度队列可利用
来自Grand CentralDispatch线程池的临时线程
它们一般将程序块作为它们的回调
或应用它们的API一般将程序块作为它们的回调
仅在一线程完全空闲时
串行队列的自动释放池才会出现
如果你的应用在持续忙碌中自动释放池将绝不会出现
所以当你用调度时 不依赖于
免费的自动释放池是很重要的
如果你要自动释放大量的项目
你需确保你的自动释放池是合适的
最后串行队列不是一个重入锁
或递归锁结构
你需要确保当你设计你应用的队列时
不要使自己陷入需重入地
使用它们的情况
这些规则被捆绑在一起 其意义在于
主线程的运行循环也作为主队列被公开
相对于主线程在这些领域间来回跳转
是非常容易的
所以如果你回到计时器那个例子
我们是有点在比较不同的API
说到运行循环 我们有
NSObjects—在Delay后运行Selector和Object
或NSTimer—安排TimerWithTimeInterval
可在当前运行循环上安装计时器
在调度领域我们有dispatchafter和
dispatch sources用其设置计时器
这样就创建一个通过队列上加入程序块
就可激活的计时器
我提到过GDC利用临时线程
现在让我说明一下它是如何运作的
想象一下我正在做大量的异步调度
我将那些放入全局队列
系统正从线程池中取出一个线程
并将它分配给第一个程序块
使其按自己的方式运行
取出另一个线程给第二个程序块
并使其按自己的方式运行
这样我们就有一个两核设备
这些线程在同时运行
我们先停在这里
理想情况下每核有一个线程
当第一个程序块结束执行时
我们将取出线程分配给下一个以此类推
这样运作非常好
直到我们程序中的某个需要访问
现在还不可获得的资源
我们把这叫做等待
线程将等待并暂缓执行
当它需要像是I/O或锁定资源时
你或许听说过这个被称作阻塞
但今天我们叫它等待
所以在接下来的五分钟如果谈论程序块阻塞你会觉得非常困惑
但在许多其它的情况下 你会听到它被称作阻塞
从GCD的角度看这里非常有趣的是
我们想要设备上每核的程序块或是线程都在主动地执行
所以当一线程等待时我们将提出线程池中的另一个线程
直到受到限制
这样就有每核都有一个线程在运行
来想象一下我们有四个这样的程序块
正在两个不同的线程上执行前两个
前一个说：嘿 我需要执行I/O
我们说：好我们将发布I/O到磁盘上
但之后我们必须等待I/O回归返回 
然后才可提出另一个线程
执行下一个程序块等等 当线程等待时
当仍有工作需要被做时找另一线程来执行队列上的下一程序块
这里的问题是：如果仅有四个程序块时运行没有问题
如果我有许多程序块且它们都想等待
我们就会遇到线程激增
当然这就会有点低效
有大量的线程都在占用资源
如果它们同时停止等待
就会有大量的资源冲突
所以这对性能来说是非常不好的
同时它也有一点危险性
因为这对可提出的程序数量有所限制
当我们耗尽极限时对于新的工作
我们该怎么办？
这就导致了死锁
我想举一个死锁的例子 是在我们的一个内部应用程序里碰到的
这个例子有点复杂但我希望我能一步步给你解释 因为
此例很好的说明 应用程序不同部分间
是如何以一种意料外的方式互动的
我们有主线程并且主线程有大量的工作需要去做
它会异步调度大批程序块
到某一并发队列
我们为这些程序块提出线程
这些程序块立即转向
同步调度回主线程
这时我们已经提出了
我们需要的所有线程
在这里的这个简单例子中 是四个
我们达到了线程限制
我们将不能再为线程池提出任何更多的线程
那么 好的我们需要主线程再次变成可使用的
以使那些程序块可以获取它
继续运行 至完成
现在它使我们重新回到限制下
仅在某些情况下这可能发生但是让我们试想一下
主线程进入异步调度成为某一串行信号
到目前为止一切顺利
那个程序块仍不会开始执行
因为没有可利用的额外的主线程
来执行那个程序块
它会呆在那里 等待着某一线程返回
然后我们可将其再度利用
但是之后我们的主线程决定同步调度
成相同的串行队列
问题是对于串行队列
没有可用的线程
主调用将永远阻塞
这就是经典的死锁情况
我们的主线程正在等待资源
在此案例中是我们线程池中的一个线程
所有来自线程池中的线程都在等待资源
主线程都在互相等待 但没有一个会
放弃那个资源 所以导致了死锁
这似乎非常匪夷所思不自然
但是当你的应用程序有许多不同的部分不同的模块同时运行的框架时
死锁会比你想象中更容易碰到
并且实际情况中会更复杂
所以当你在用GCD时
这是你需要时刻铭记的
以保证你可以避免这种情况
这很容易做到
下面我会讲一些可适当避免这个问题的
设计应用程序的方法
首先是一些基础的东西
在任何可能的情况下
尽可能利用异步API
尤其是对于I/O
如果你这样做你可以避免程序块等待
这样你就不用提出更多的线程
更高效
对这类的情况 你也可以用串行队列
如果调度所有此类工作到串行队列上
我们就不会遇到线程激增
我们每次将仅执行一个程序块
我并不是在告诉你们串行化你们全部的应用程序
但是当你建立你的应用程序
并创建不同的队列在你的应用程序中处理不同的模块时
除非你知道对特别的模块你需要
平行运行某些东西
取而代之地为达到你的性能目标
请考虑从串行队列开始
在串行队列上同时运行你应用程序中的各部分从中你可获得很多性能
之后你可以给出你应用程序的轮廓
看什么地方需要额外的平行运行的性能
并对这些地方进行特别设计
以避免线程激增
当然你也可以用有并发限制的
NSOperation队列
最后不要产生无限的工作
如果你可以按照你需要的程序块数量来约束你的工作
就会避免线程激增
让我们来看看更具体的
在这是出现问题的实例代码
第一个是我们混合异步和同步
如果我只是对某队列进行同步调度会非常的快
大体上是得到锁
如果我进行异步调度也会非常的快
大体上是原子入队
如果我有一个队列且仅用两个中的某个
其性能与这些基本体是非常相近的
如果我将这些混合异步到某队列并做同步调度
同步调度就必须等待一线程被建立
并执行那个程序块然后程序块才会被完成
现在我们多了创建线程的时间
但其实本来仅一个锁就足够了
混合这些基本体当然是安全的
但是当你设计应用程序的时候想一下是否你真的需要这么做
在主线程中混合它们的时候需要特别的小心
现在下一个问题是我们尝试一次调度许多程序块到某一并发队列
如果你这么做在我们的这个情况中你只需
避开主线程尝试继续执行
但是试想一下在你异步的地方做一些相似的事情
之后做一个同步屏障
任何一个都是危险的因为它将引起线程激增和死锁
但是我们有一个基本体叫做调度使用
这两段代码对你来说基本上是一模一样
从语义上来看
通过转换为调度应用 你通过GCD
来管理并行性和避免线程激增
当然你也可以用调度信号量
你们中的许多对用信号量作锁非常熟悉
取而代之的是这里我们将信号量用做计数信号量
我们从对它进行初始化着手
通过使用我们想执行的并发任务数
比如说我们想要运行四个
每次我们的程序块完成它会向信号量发出信号
每次我们提交 我们需要等待信号量
结果是：提交线程将进行四次提交
之后阻塞那个信号量 直到
它们中的一个可以完成并发信号给信号量
这个模式非常好 如果你的应用程序中
你可能在多个地点提交
某些东西像是调度应用是不合适的
希望这些帮助你们对线程激增有了解
并知道如何去避免它
我还想简短地谈一下崩溃报告
不幸的是某些时候你们中的大多数都必须
处理一份崩溃报告
这里有许多信息
如果你在用GCD就更是这样
随着你有更多的线程就会有更多的东西需要被剖析
及理解到底是怎么回事
所以我想介绍给你们一对堆栈
它们可以帮助你了解应用程序中
不同线程的作用
第一个是管理线程
你几乎在所有使用GCD的应用程序中
都可以看到管理线程
它负责帮助进程调度来源
你会注意到调度管理线程是根框架
一般来说你可以忽略它
我们有空闲的GCD线程
这些是线程池里空闲的线程
在堆栈的底部你可以看到开始工作队列线程
有迹象指出它是一个GCD线程
工作队列当前返回指出它正在处在空闲
另一方面一个活跃的GCD线程仍将从
开始工作队列线程开始 但你会看到一些
调度客服端调用和调度调用程序块及释放类的东西
跟随着你的代码
你也会看到当你创建队列时曾输入的调度队列名称
给出描述性队列名称是非常重要的
当主线程空闲时 你会看到其列席在
虚拟信息陷阱 CF运行循环端口及CF运行循环运行
你也会看到com.apple主线程
另一方面如果你的主线程是活跃的
由于主队列GCD队列你可能会看到CF运行循环
正在服务主调度队列—如果它是活跃的
并且在这种情况下有我们正调出的NSBlock操作
当你不能依赖于事物不会改变
今天有些内部的细节我也会谈及
为了能给你一个崩溃报告的指南
希望能提供给你一些有用的信息
至此总结一下 记住一个有效的
有响应的应用程序必须接受不同的环境
不管是Watch还是Mac Pro
这些不同的平台有各种各样的可用资源
GCD是可以帮助你合理管理它们的一种非常好的方式
QoS分类允许操作系统
以最有效的方式安排你的资源
所以你应该回家想想如何将QoS分类
整合进你的应用程序
及既存的GCD使用中
最后想一下应用程序是如何使用GCD
并尝试避免线程激增
更多的信息 请查看
Mac和iOS应用程序并发程序指导或能源效率指导
iOS应用程序的那个是这周刚出的
看看吧 它很棒有开发者论坛和我们的宣传员Paul
几个相关的场次：
《获得整日电池寿命》给出了更多关于
我提到的能源话题的信息
《为多任务iOS9优化你的app》
《高级的NSOperations》和在这之后的
《iOS及Watch OS性能》
如果那些你没有看过 我强烈的建议你去看一下 谢谢