00:00:36.937 --> 00:00:39.473 
Core Motion中有什麼新料

00:00:41.408 --> 00:00:43.143 
下午好 歡迎大家

00:00:44.144 --> 00:00:47.447 
我的名字是阿尼爾·卡南加
今天我要講一講

00:00:47.514 --> 00:00:49.183 
Core Motion中有什麼新料

00:00:49.616 --> 00:00:51.552 
我們能講的事情比較多

00:00:51.618 --> 00:00:53.987 
不過今天我們主要講幾個關鍵點

00:00:56.056 --> 00:00:59.693 
我們會首先談一談
Apple Watch

00:00:59.760 --> 00:01:02.596 
這是我們的一個新的平臺
我們會談談怎樣把你的

00:01:02.663 --> 00:01:05.399 
Core Motion apps
弄到Apple Watch上

00:01:05.999 --> 00:01:07.935 
我們也對計步器做了一些

00:01:08.001 --> 00:01:10.571 
新的變更
其中包括一些新的APIs

00:01:12.039 --> 00:01:17.711 
我們還會談一談高度表
在Phone 6上引入的一個傳感器

00:01:18.645 --> 00:01:21.982 
然後加布裏埃爾就會通過一個
以一個非常有趣的方式

00:01:22.049 --> 00:01:25.185 
使用了Core Motion的
應用程序來給我們做一個演示

00:01:25.519 --> 00:01:26.954 
我之前已經看過了 非常棒

00:01:27.821 --> 00:01:29.289 
讓我們開始吧

00:01:29.656 --> 00:01:31.592 
這並不是一個介紹性的會議

00:01:32.025 --> 00:01:35.295 
不過我們會涵蓋非常多的
Core Motion概念 

00:01:35.362 --> 00:01:36.363 
你也可以跟得上

00:01:36.430 --> 00:01:39.800 
即使你不是十分熟悉Motion

00:01:40.167 --> 00:01:44.905 
不過對於那些來到會場的人來說
我們在會議結束後會立即有一個實驗室

00:01:45.239 --> 00:01:47.140 
請帶着你的問題來實驗室

00:01:47.207 --> 00:01:48.976 
我們有工程師以及科學家在場

00:01:49.743 --> 00:01:52.045 
但是如果你沒有問題 那就要恭喜你了

00:01:52.713 --> 00:01:54.781 
不過還是要請你過來

00:01:54.848 --> 00:02:00.053 
告訴我們在你的apps中是怎樣使用
Core Motion 樂意聆聽

00:02:00.487 --> 00:02:04.291 
在Apple developer
上確實也有一些之前的會議

00:02:04.358 --> 00:02:08.061 
在那些會議中深入探討了動作感應、

00:02:08.127 --> 00:02:09.763 
動作活動性以及計步器

00:02:09.830 --> 00:02:11.198 
所以請你去看看那些會議

00:02:11.265 --> 00:02:12.799 
讓我們開始吧

00:02:13.700 --> 00:02:18.639 
一段時間以來
動作感應已經在iOS上取得很大進展

00:02:18.705 --> 00:02:24.711 
先來看個有關它的工作原理的簡短概述

00:02:24.778 --> 00:02:27.614 
這是一個傳統的動作感應的結構

00:02:27.681 --> 00:02:30.684 
你把一些傳感器連接到主處理器

00:02:31.118 --> 00:02:32.619 
就可以很明顯地看到它們的缺點

00:02:32.686 --> 00:02:34.922 
無論你在什麼時候想要訪問傳感器數據

00:02:34.988 --> 00:02:37.291 
你都必須讓主處理器處於活動狀態

00:02:37.824 --> 00:02:39.893 
這會嚴重製約你可以編寫的

00:02:39.960 --> 00:02:42.029 
應用程序的種類

00:02:42.763 --> 00:02:44.598 
所以我們認爲 我們能夠做得更好

00:02:44.932 --> 00:02:49.436 
從iPhone 5S開始
我們就引入了一顆協處理器

00:02:49.503 --> 00:02:51.605 
我們稱之爲M7

00:02:51.772 --> 00:02:54.641 
是一顆微型處理器 它唯一的工作就是

00:02:54.842 --> 00:02:56.577 
對動作數據進行處理

00:02:56.643 --> 00:02:59.980 
這顆處理器可以全天候運行

00:03:00.080 --> 00:03:02.382 
且只有在真正必須時纔會喚醒主處理器

00:03:03.183 --> 00:03:06.286 
對於用戶的電池壽命來說這是好事

00:03:06.820 --> 00:03:10.724 
我們在iPhone 6上又引入了
M8處理器以及一個新的

00:03:10.791 --> 00:03:13.727 
傳感器即“高度表”

00:03:13.794 --> 00:03:17.731 
現在在iOS上
動作感應看起來就是這樣的

00:03:18.732 --> 00:03:20.234 
那麼它對你來說有什麼用呢？

00:03:20.467 --> 00:03:22.269 
如果你讓傳感器

00:03:22.636 --> 00:03:28.108 
實時訪問你獲得的數據
實時訪問原始傳感器數據

00:03:28.175 --> 00:03:31.512 
以及在傳感器上構建的功能特性

00:03:31.812 --> 00:03:35.048 
如能夠給你提供設備的高度的設備動作

00:03:35.115 --> 00:03:37.784 
比如計步器再比如動作活動性

00:03:38.051 --> 00:03:42.523 
若是在有高度計平臺上 還可訪問原始

00:03:42.589 --> 00:03:47.628 
壓力、高度變化以及階梯步級這些數據

00:03:48.795 --> 00:03:51.365 
這就是來自傳感器的實時數據

00:03:51.431 --> 00:03:53.600 
但是動作協處理器能讓你做的

00:03:53.667 --> 00:03:55.402 
遠遠不止這些 沒錯

00:03:55.469 --> 00:03:56.770 
遠遠不止這些

00:03:56.837 --> 00:03:59.806 
你還可以每週七天、每天
二十四小時訪問動作活動性

00:04:00.073 --> 00:04:02.309 
訪問計步器 在有高度計的平臺上

00:04:02.376 --> 00:04:06.213 
你還可以每週七天、每天
二十四小時訪問階梯步級

00:04:06.280 --> 00:04:11.318 
現在在iOS上 你能用動作感應
做的事情就是這些

00:04:12.920 --> 00:04:16.523 
那麼在Apple Watch上
動作感應看起來是什麼樣呢？

00:04:17.057 --> 00:04:20.293 
Apple Watch上
面同樣也有一顆協處理器

00:04:20.827 --> 00:04:22.062 
它上面還有一個加速計

00:04:22.729 --> 00:04:27.634 
這就意味着你同樣可以
每週七天、每天二十四小時

00:04:28.302 --> 00:04:31.238 
訪問動作活動性以及計步器
訪問除了這兩種數據之外

00:04:31.305 --> 00:04:32.940 
你獲得的實時傳感器數據

00:04:33.340 --> 00:04:35.776 
如果你在想 哎呀！
這個看起來這麼眼熟

00:04:36.043 --> 00:04:37.744 
那麼Apple Watch上的動作

00:04:37.811 --> 00:04:40.747 
你看起來也眼熟 你看的沒錯

00:04:41.448 --> 00:04:46.153 
iOS上的Core Motion 
APIs在watchOS上也有了

00:04:47.187 --> 00:04:51.191 
不僅是動作Core Motion 
API iOS和watchOS部分

00:04:51.258 --> 00:04:53.660 
Core Motion APIs
都表現得一樣

00:04:53.727 --> 00:04:56.363 
我們就是在兩個OSs上沿用了

00:04:56.430 --> 00:04:58.065 
這個特性

00:04:59.199 --> 00:05:02.703 
不過Watch基本上就是一個
完全不同的平臺了

00:05:03.270 --> 00:05:05.506 
因此當爲Watch構建應用程序時

00:05:05.572 --> 00:05:09.209 
我們需要知道
一些事情從頭到尾給你們講講

00:05:09.877 --> 00:05:11.945 
我們先來講一下動作活動性

00:05:12.446 --> 00:05:15.816 
動作活動性
可以給我們提供上下文信息 

00:05:15.883 --> 00:05:17.417 
告訴我們用戶正在做什麼

00:05:17.484 --> 00:05:19.019 
可知用戶是否正在走路 

00:05:19.086 --> 00:05:21.255 
是否正在跑步 
是否潛水 是否正在騎車等

00:05:21.421 --> 00:05:25.259 
你能夠獲得的等級非常依賴於平臺

00:05:25.325 --> 00:05:26.894 
非常依賴於它的使用方式

00:05:27.361 --> 00:05:31.632 
這裏簡單對你能夠在watchOS上
得到的狀態進行一個總結

00:05:32.032 --> 00:05:33.667 
你可以注意到 你可以訪問

00:05:33.734 --> 00:05:36.803 
走路、跑步、騎車以及靜止狀態

00:05:37.471 --> 00:05:40.507 
這就是Apple Watch
上的動作活動性

00:05:42.376 --> 00:05:46.914 
開發者早就想要訪問傳感器本身

00:05:47.414 --> 00:05:49.950 
提供通過這個熟悉的
CMAccelerometer

00:05:50.017 --> 00:05:52.753 
API來訪問加速計

00:05:53.887 --> 00:05:55.856 
那些東西都在加速計上

00:05:56.190 --> 00:05:58.458 
不過因爲它是一個不同的平臺

00:05:58.525 --> 00:06:00.627 
我們還是需要記住一些

00:06:00.694 --> 00:06:02.229 
應該考慮的事

00:06:02.629 --> 00:06:06.166 
第一點你的app獲得的處理時間

00:06:06.233 --> 00:06:07.668 
可能是有限的

00:06:08.268 --> 00:06:10.904 
Watch上並沒有真正後臺處理方式

00:06:10.971 --> 00:06:13.106 
因此當你的app顯示在屏幕上時

00:06:13.173 --> 00:06:14.741 
你的app就在高速運行了

00:06:16.410 --> 00:06:19.313 
屏幕可能會因爲多種原因關閉

00:06:19.379 --> 00:06:20.414 
屏幕可能會超時

00:06:21.014 --> 00:06:23.183 
不過Apple Watch
的屏幕是設計成了

00:06:23.250 --> 00:06:25.419 
只有當你在看它的時候屏幕纔會開啓

00:06:25.485 --> 00:06:28.021 
因此如果你不想看屏幕了

00:06:28.188 --> 00:06:30.757 
那麼屏幕關閉、
屏幕關閉後你的app得不到

00:06:30.824 --> 00:06:34.127 
處理時間的可能性就非常大

00:06:34.294 --> 00:06:36.463 
考慮到這些情況

00:06:36.530 --> 00:06:38.732 
我想要談一些

00:06:38.799 --> 00:06:40.133 
最佳實踐

00:06:40.334 --> 00:06:45.472 
首先要把你的app設計成
只有當app在屏幕上顯示時

00:06:45.539 --> 00:06:46.807 
你的app纔會期望數據

00:06:47.074 --> 00:06:48.809 
我知道說起來容易做起來難

00:06:48.876 --> 00:06:50.377 
不過還是要記住這一點

00:06:51.512 --> 00:06:55.549 
其次當你訪問一個流的時候
訪問一個傳感器數據流時

00:06:55.983 --> 00:07:00.053 
你需要確保當你的任務被掛起時

00:07:00.487 --> 00:07:04.024 
也可以以一種優雅的方式處理你的任務

00:07:04.091 --> 00:07:06.627 
幸運的是
可以通過NSProcessInfo

00:07:06.693 --> 00:07:08.262 
來實現這一點

00:07:08.762 --> 00:07:11.431 
如果你使用這個API
performExpiring

00:07:11.532 --> 00:07:14.835 
ActivityWithReason
你就可以在這個API中

00:07:14.902 --> 00:07:16.970 
把你的傳感器數據當成一個塊來處理

00:07:17.437 --> 00:07:20.674 
它就會通知你的塊通知你你的任務

00:07:20.741 --> 00:07:23.477 
就要被掛起了
這樣你就可以採取適當行動

00:07:24.344 --> 00:07:28.182 
那是CMAccelerometer
API

00:07:29.049 --> 00:07:32.052 
不過你們中有人想要的不僅僅是這些

00:07:32.119 --> 00:07:35.055 
事實上你想要長期訪問

00:07:35.122 --> 00:07:36.990 
傳感器數據

00:07:37.457 --> 00:07:39.092 
今天我很高興地告訴大家

00:07:39.826 --> 00:07:41.695 
有史以來第一次 我們開始提供訪問

00:07:41.762 --> 00:07:45.999 
歷史傳感器數據 歷史加速計數據

00:07:47.100 --> 00:07:49.436 
那麼你現在可以拿它做什麼？

00:07:49.770 --> 00:07:53.807 
它允許你訪問很長一段時間內的數據

00:07:54.074 --> 00:07:55.242 
相當長一段時間

00:07:55.976 --> 00:07:57.845 
你也可以訪問這個數據

00:07:58.045 --> 00:07:59.880 
即使你的app不是處於運行狀態

00:08:01.348 --> 00:08:06.653 
這樣的話 你就可以在這個長長的

00:08:06.720 --> 00:08:09.289 
傳感器數據流上運行你自己的定製算法

00:08:09.723 --> 00:08:11.124 
這很酷 我們也期待你們用它

00:08:11.191 --> 00:08:12.593 
來開發出很酷的apps

00:08:13.093 --> 00:08:14.428 
那麼你應該怎麼用它呢？

00:08:14.795 --> 00:08:17.764 
我們有一個新的API叫做
CMSensorRecorder

00:08:18.332 --> 00:08:22.803 
這個API允許
初始化歷史傳感器數據錄製

00:08:23.070 --> 00:08:29.109 
記住這點此API和其他的APIs
一個很重要的不同之處

00:08:29.176 --> 00:08:31.845 
比如計步器以及動作活動性

00:08:32.246 --> 00:08:35.015 
其他的APIs
並不需要你初始化任何錄製

00:08:35.749 --> 00:08:38.919 
對SensorRecorder說
你確實需要對它進行初始化

00:08:39.419 --> 00:08:42.523 
數據錄製的頻率是五十赫茲

00:08:42.823 --> 00:08:45.626 
你最多可以錄製三天的數據

00:08:46.994 --> 00:08:50.931 
這就是SensorRecorder
的使用方式

00:08:51.565 --> 00:08:54.601 
提到執行 我們應該這樣做

00:08:54.735 --> 00:08:58.272 
你首先要通過初始化
recordAccelerometerDataFor

00:08:58.338 --> 00:09:01.742 
錄製數據 然後要提供一個

00:09:02.075 --> 00:09:03.510 
持續時間

00:09:04.211 --> 00:09:07.314 
一旦你完成這一步
設備可能就會進入睡眠狀態

00:09:07.681 --> 00:09:09.283 
你的app可能會被掛起

00:09:09.483 --> 00:09:10.651 
沒關係

00:09:10.717 --> 00:09:14.388 
之後 用戶可能會回來
並且啓動你的app

00:09:15.389 --> 00:09:18.792 
當用戶啓動你的app時
你就可以決定是否查詢傳感器數據

00:09:19.826 --> 00:09:23.597 
通過查詢
accelerometerDataFrom

00:09:23.664 --> 00:09:25.799 
當然你還需要指定一個時間段

00:09:27.801 --> 00:09:30.137 
然後指定的時間段的加速計的數據

00:09:30.504 --> 00:09:32.739 
就會返回回來

00:09:32.806 --> 00:09:35.242 
很明顯 這個時間段可以是

00:09:35.742 --> 00:09:37.744 
你錄製數據的時間的一個子集

00:09:38.645 --> 00:09:42.249 
好的 數據會被作爲一個

00:09:42.316 --> 00:09:45.185 
CMAccelerometerData
對象序列返回回來

00:09:46.987 --> 00:09:49.556 
回想一下 我們提到過的

00:09:49.623 --> 00:09:52.159 
關於優雅地處理任務掛起的內容

00:09:52.226 --> 00:09:54.294 
你在這裏也會遇到同樣的問題

00:09:54.828 --> 00:09:57.798 
因此 當你處理這個很大的

00:09:57.865 --> 00:09:59.399 
歷史數據流的時候

00:09:59.867 --> 00:10:03.403 
你就需要訪問我們的老朋友
NSProcessInfo

00:10:04.271 --> 00:10:09.142 
當你的任務就要被掛起時它會通知給你

00:10:11.144 --> 00:10:12.946 
如果你看一下加速計數據對象

00:10:13.013 --> 00:10:16.683 
它裏面不僅包括了你熟悉的加速度部分

00:10:17.117 --> 00:10:20.988 
而且還包括了一個startDate
你就可以把這個它當做一個定位器

00:10:21.455 --> 00:10:24.525 
你可以從這個點
開始確保下次你的app啓動時

00:10:25.225 --> 00:10:26.760 
向前進行查詢

00:10:27.528 --> 00:10:30.264 
這就是SensorRecorder
的工作原理

00:10:30.998 --> 00:10:34.701 
這個很棒 不過正如你看到的
那裏有一項需要考慮的事

00:10:35.169 --> 00:10:36.870 
不是 是兩項功率與性能

00:10:37.404 --> 00:10:39.873 
SensorRecorder
是一個強大的API

00:10:39.940 --> 00:10:42.743 
但是能力越大 危險性也就越大

00:10:42.809 --> 00:10:46.980 
這裏的危險性就在於
你可能沒有足夠的時間

00:10:47.047 --> 00:10:49.283 
來處理傳感器數據的大量的字符串

00:10:49.850 --> 00:10:52.486 
因此我再介紹幾個最佳做法

00:10:53.020 --> 00:10:57.224 
首先是 僅僅錄製 查詢你的app

00:10:57.758 --> 00:11:00.928 
需要用到的最短持續時間內的數據

00:11:00.994 --> 00:11:04.097 
如果app是一款鍛鍊身體
你大概就不需要十二個小時的數據

00:11:04.164 --> 00:11:06.934 
你大概需要幾個小時的數據就夠了

00:11:07.000 --> 00:11:09.570 
你查詢的數據量越少

00:11:09.636 --> 00:11:11.605 
你的app就越能容易地獲取、處理

00:11:12.940 --> 00:11:15.976 
此外你也應該知道
傳感器數據傳輸率的要求

00:11:16.410 --> 00:11:18.579 
數據是以五十赫茲的頻率提供給你的

00:11:19.012 --> 00:11:21.882 
但是除非你想要從那些數據中
抽取出特性、需要更高的

00:11:22.082 --> 00:11:25.919 
傳感器數據傳輸率
那麼你最好丟棄一些數據

00:11:26.253 --> 00:11:28.222 
處理較少的數據

00:11:28.288 --> 00:11:30.824 
只要採用幾項最佳做法
你應該就沒問題了

00:11:32.659 --> 00:11:35.896 
Apple Watch上Core 
Motion的情況就是這些

00:11:36.396 --> 00:11:39.600 
你已經看過了
我們有很多看起來眼熟的APIs

00:11:39.900 --> 00:11:43.237 
我們也可以訪問歷史傳感器數據

00:11:43.770 --> 00:11:45.105 
這個很棒 你們應該可以用它

00:11:45.172 --> 00:11:46.940 
來開發出很酷的應用程序

00:11:47.407 --> 00:11:49.476 
提到編寫Watch應用程序

00:11:49.543 --> 00:11:51.612 
我們今天上午確實舉辦了一個會議

00:11:51.979 --> 00:11:53.313 
現在就可以看到會議視頻了

00:11:55.182 --> 00:11:58.218 
會議剩餘的時間裏
我想重點關注iOS 我先來講講

00:11:58.285 --> 00:11:59.953 
計步器上有什麼新情況

00:12:01.221 --> 00:12:04.191 
這就是你屬性的計步器

00:12:04.424 --> 00:12:05.859 
步數、距離

00:12:06.627 --> 00:12:07.594 
我們來快速回顧下

00:12:08.095 --> 00:12:10.063 
計步器的設計理念

00:12:10.130 --> 00:12:13.600 
是持續給你
提供身體各個部位的行爲表現

00:12:13.667 --> 00:12:16.170 
無論是放在你的手中
還是放到你的口袋裏

00:12:16.270 --> 00:12:18.672 
計步器的性能應該是一致的

00:12:19.139 --> 00:12:22.509 
即使速度不同
計步器的性能也應該是一致的

00:12:23.443 --> 00:12:25.946 
計步器的一個很棒的特性是

00:12:26.013 --> 00:12:27.915 
它會適應用戶

00:12:28.182 --> 00:12:31.485 
因此使用計步器的用戶人數越多
那麼通過自身的校正

00:12:31.552 --> 00:12:33.654 
它就能更好地理解用戶

00:12:35.155 --> 00:12:38.559 
在iOS 9上我們對計步器
做了一個很大的改進

00:12:38.625 --> 00:12:42.462 
讓它儘可能地合併了GPS

00:12:43.730 --> 00:12:44.932 
我們爲什麼要這麼做？

00:12:45.465 --> 00:12:47.734 
原因在於你的app可能

00:12:47.835 --> 00:12:50.070 
已經訂閱了用戶的位置

00:12:50.137 --> 00:12:52.506 
你可能想要在用戶進行跑步的時候

00:12:52.573 --> 00:12:53.473 
繪製用戶的運動軌跡

00:12:54.208 --> 00:12:56.877 
當你這麼做的時候計步器檢測到

00:12:56.944 --> 00:12:58.512 
GPS數據可以用了

00:12:58.879 --> 00:13:00.981 
通過使用GPS數據
就可以讓軌跡繪製的更精確

00:13:02.850 --> 00:13:05.285 
爲什麼這一點如此關鍵呢？

00:13:05.586 --> 00:13:09.656 
看看這個 
這是我的一位同事在舊金山跑的一次步

00:13:09.990 --> 00:13:11.491 
舊金山是一座“城市峽谷”

00:13:11.558 --> 00:13:15.295 
有很高的建築物對任何GPS來說

00:13:15.362 --> 00:13:16.730 
環境都富有挑戰性

00:13:17.397 --> 00:13:18.932 
如果你看看這裏的這一段

00:13:19.600 --> 00:13:22.369 
GPS在這裏看起來非常靠譜

00:13:22.603 --> 00:13:27.274 
如果你依賴於GPS
我們就可以對距離進行很好的估測

00:13:28.041 --> 00:13:28.909 
很好

00:13:29.843 --> 00:13:31.478 
但是如果你再看這裏不同的段

00:13:31.545 --> 00:13:34.915 
你就會發現在用戶的軌跡中用戶在閒逛

00:13:35.382 --> 00:13:38.118 
一路上有好幾個酒吧 所以...

00:13:38.185 --> 00:13:42.289 
但是這可能
並不是這位用戶真實的跑步軌跡

00:13:42.890 --> 00:13:44.324 
所以說

00:13:44.725 --> 00:13:47.561 
計步器非常聰明 它知道在這裏

00:13:47.995 --> 00:13:50.531 
它就不應該繼續依賴GPS了

00:13:50.931 --> 00:13:53.400 
它應該繼續藉助於自身的基於步幅的

00:13:53.467 --> 00:13:54.468 
距離估計

00:13:54.768 --> 00:13:59.173 
如果你使用了計步器
那麼你得到的最終結果

00:13:59.306 --> 00:14:02.910 
就非常一致
這也就是爲什麼你應該使用

00:14:03.911 --> 00:14:05.479 
計步器的步數和距離的原因

00:14:08.949 --> 00:14:13.420 
今年我們對計步器的API
做了一個很大的改進

00:14:14.321 --> 00:14:15.255 
在我們開始之前

00:14:15.322 --> 00:14:17.991 
我們先來回顧一個
你們已經知道的特性 這是層數計數

00:14:18.559 --> 00:14:21.128 
層數計數有
floorsAscended

00:14:21.195 --> 00:14:23.063 
還有floorsDescended

00:14:23.664 --> 00:14:25.599 
因爲這是計步器的一部分

00:14:25.999 --> 00:14:28.335 
這就是一個徒步功能 你必須實際邁步

00:14:28.402 --> 00:14:29.736 
才能把它用起來

00:14:30.237 --> 00:14:33.674 
也就是說 你需要在這裏

00:14:33.907 --> 00:14:36.376 
贏取授予的層數

00:14:37.744 --> 00:14:40.314 
讓我們更深入地看看 
它到底是如何工作的

00:14:41.481 --> 00:14:42.749 
它有幾項要求

00:14:43.383 --> 00:14:46.353 
首先是 最低提升速率要求

00:14:47.221 --> 00:14:49.590 
還有一個步數要求

00:14:50.090 --> 00:14:54.394 
它們對我們意味着
假如說 如果你進行了一次遠足

00:14:54.461 --> 00:14:55.562 
並且你走的很慢

00:14:55.629 --> 00:14:58.465 
那麼最終你積累的高度就會很多

00:14:59.733 --> 00:15:03.537 
但是你很有可能達不到提升速率要求

00:15:03.604 --> 00:15:04.938 
我們就不會授予你層數

00:15:05.873 --> 00:15:08.942 
但是如果你是在舊金山散步
有一些非常陡峭的丘陵

00:15:09.009 --> 00:15:12.746 
那麼你就有可能達到一些層數

00:15:14.147 --> 00:15:16.350 
因爲步速要求 如果你使用了電梯

00:15:17.251 --> 00:15:20.354 
或者自動扶梯

00:15:20.821 --> 00:15:22.689 
你就不大可能會被授予層數

00:15:22.789 --> 00:15:25.626 
這就是iOS上層數計數的工作原理

00:15:28.095 --> 00:15:29.396 
現在輪到新的API了

00:15:30.264 --> 00:15:32.299 
這是“步幅”

00:15:33.133 --> 00:15:36.370 
長期以來
開發者就要求我們提供“步幅”

00:15:36.803 --> 00:15:38.172 
我們很高興現在能提供了

00:15:39.039 --> 00:15:42.676 
當我們提起“步幅”
我們指的是currentPace

00:15:43.210 --> 00:15:45.279 
這實際上是瞬時步幅

00:15:45.345 --> 00:15:48.148 
而不是在跑步一開始就估算出來的步幅

00:15:48.882 --> 00:15:52.619 
“步幅”是以時間單位內
通過的距離來表示的

00:15:53.387 --> 00:15:57.724 
如果你想問爲什麼這樣表示
而不是時間單位內的速度

00:15:57.824 --> 00:15:59.660 
你知道 因爲對於跑步者來說

00:16:00.194 --> 00:16:03.330 
步幅通常
可以被類推爲走完一個已知的距離

00:16:03.397 --> 00:16:04.932 
需要的實際時間

00:16:06.200 --> 00:16:08.435 
在網站上關注了
Apple Watch的更新情況

00:16:08.502 --> 00:16:11.038 
那麼這個步幅
你看起來就可能很眼熟

00:16:12.072 --> 00:16:13.807 
這就讓我有點 妒忌了

00:16:17.211 --> 00:16:18.645 
計步器既有實時數據

00:16:18.712 --> 00:16:21.648 
又有歷史數據
但是“步幅”是隻有你在進行

00:16:21.715 --> 00:16:23.283 
實時查詢時纔有的

00:16:23.951 --> 00:16:25.419 
別忘了這一點

00:16:25.886 --> 00:16:27.821 
我們爲什麼要提供“步幅”？

00:16:27.888 --> 00:16:31.425 
畢竟我們已經在計步器上
提供了距離和一個時間概念

00:16:31.491 --> 00:16:35.596 
因此我們可以很容易地計算出步幅

00:16:36.363 --> 00:16:38.999 
這樣得出的步幅健壯性更高

00:16:39.800 --> 00:16:42.069 
假如說你想要有所區別

00:16:42.135 --> 00:16:45.172 
想從那些距離組塊中估算出步幅

00:16:45.806 --> 00:16:49.977 
也會向步幅中引入一個可接受的抖動量

00:16:50.777 --> 00:16:54.481 
計步器就可以對此進行處理 

00:16:54.548 --> 00:16:57.117 
確保步幅的估算是平滑的

00:16:59.453 --> 00:17:02.289 
此外你還可以通過回顧歷史組塊

00:17:02.356 --> 00:17:05.726 
然後算出步幅的平均數這一方法

00:17:05.791 --> 00:17:07.560 
嘗試獲得平滑的步幅

00:17:07.627 --> 00:17:11.665 
不過你這樣做的代價就是
如果用戶步幅發生了改變

00:17:11.732 --> 00:17:14.701 
你就無法很快做出響應

00:17:15.169 --> 00:17:18.805 
通過CMPedometer得出步幅
能夠對變更很快做出響應

00:17:18.872 --> 00:17:20.574 
響應性也很高

00:17:21.508 --> 00:17:24.411 
因此平滑性和響應性就
你應該通過CMPedometer

00:17:25.012 --> 00:17:26.413 
使用步幅的理由所在

00:17:27.481 --> 00:17:28.849 
這是步幅

00:17:28.916 --> 00:17:33.754 
步幅有個“近親”叫做“步調”

00:17:34.488 --> 00:17:37.124 
我們現在在計步器上有了步調

00:17:37.858 --> 00:17:39.426 
那麼什麼是“步調”？

00:17:39.493 --> 00:17:43.130 
步調指的是你的步行速率
或者換其他話來說

00:17:43.197 --> 00:17:46.300 
就是你的腳接觸地面的頻率

00:17:46.800 --> 00:17:49.636 
對於跑步者來說步調非常重要

00:17:49.736 --> 00:17:51.538 
現在你就能直接通過計步器

00:17:51.605 --> 00:17:53.974 
在你的apps內提供步調了

00:17:56.076 --> 00:17:56.944 
是的！

00:17:57.010 --> 00:18:01.315 
我們對計步器做的變更就這些

00:18:01.381 --> 00:18:05.586 
這裏快速看看各個平臺內的特性

00:18:05.652 --> 00:18:08.422 
注意看
Apple Watch上也可以用

00:18:08.488 --> 00:18:09.590 
計步器了

00:18:10.991 --> 00:18:13.093 
我們接着來談談壓力感應

00:18:13.861 --> 00:18:17.531 
通過高度表傳感器可以獲得壓力數據

00:18:18.198 --> 00:18:21.602 
這是CMAltimeter API
的一個組成部分

00:18:21.869 --> 00:18:23.437 
它給你提供了兩樣東西

00:18:23.504 --> 00:18:25.873 
第一樣是原始壓力數據
這就是傳感器自身獲得的壓力

00:18:25.939 --> 00:18:29.076 
然後進行過濾後的數據

00:18:29.309 --> 00:18:31.778 
第二樣就是相對高度

00:18:32.246 --> 00:18:34.047 
我們來深入談談高度

00:18:35.315 --> 00:18:37.351 
當我們說到“相對”我們指的是相對

00:18:37.417 --> 00:18:39.253 
提供的第一個樣本而言的

00:18:40.254 --> 00:18:42.923 
這就意味着 你從高度表上獲得的

00:18:43.156 --> 00:18:47.528 
第一個樣本的相對高度爲零

00:18:47.995 --> 00:18:51.231 
後續的樣本都會以此爲基線

00:18:53.567 --> 00:18:56.069 
那麼要使用高度表
我們需要知道些什麼呢？

00:18:56.603 --> 00:19:02.910 
對於層級的變更來說
高度表再合適不過了

00:19:02.976 --> 00:19:05.245 
而對於人體層級的變更來說
高度表就差強人意了

00:19:05.679 --> 00:19:07.648 
因此也許你不應該使用高度表來感知

00:19:07.714 --> 00:19:09.449 
用戶是否擡起了他們的胳膊

00:19:09.516 --> 00:19:11.185 
差錯會讓你失望的

00:19:12.286 --> 00:19:14.555 
對於傳感器來說
這些情況都非常具有挑戰性

00:19:14.621 --> 00:19:15.989 
這一點不要忘了

00:19:16.990 --> 00:19:18.792 
其中一項是環境

00:19:19.526 --> 00:19:22.529 
即使位置不變 
環境也可能隨着時間推移發生改變

00:19:22.596 --> 00:19:25.232 
這樣就會讓你誤以爲高度發生了變化

00:19:25.899 --> 00:19:28.702 
舉例來說 舊金山最近的冷鋒

00:19:28.769 --> 00:19:31.038 
就可以讓壓力發生很大的變化

00:19:31.138 --> 00:19:33.073 
足以讓我們以爲
你的高度發生了變化

00:19:33.140 --> 00:19:35.142 
比如說變化了十五米

00:19:35.642 --> 00:19:37.578 
建議你不要長時間使用

00:19:37.644 --> 00:19:39.680 
傳感器

00:19:41.415 --> 00:19:44.818 
你的設備所處的外套也可以影響到壓力

00:19:44.885 --> 00:19:48.822 
如果你給你的
手機使用了剛性密封防水外套

00:19:49.189 --> 00:19:50.924 
那麼你就指望不上壓力傳感器了

00:19:53.060 --> 00:19:56.196 
說到API的使用
對你來說它應該很眼熟

00:19:56.263 --> 00:19:59.433 
API可以給你提供壓力和高度

00:20:00.000 --> 00:20:03.337 
你訪問這個傳感器的速度能有多快呢？

00:20:04.071 --> 00:20:07.574 
當你第一次進行請求時
第一個樣本需要大約

00:20:08.242 --> 00:20:09.910 
二點六秒可以得出來

00:20:10.177 --> 00:20:13.914 
之後的每次樣本以步調的形式出現
用時一點三秒

00:20:14.214 --> 00:20:16.984 
你從高度表上獲取數據的速度就這麼快

00:20:18.752 --> 00:20:25.425 
總結一下
Core Motion已經出現在了

00:20:25.492 --> 00:20:27.194 
多個平臺上

00:20:27.261 --> 00:20:29.329 
iPads上有了 
iPhones有了

00:20:29.630 --> 00:20:31.265 
Apple Watch上也有了

00:20:31.331 --> 00:20:33.200 
在Apple Watch
上提供不只那些

00:20:33.267 --> 00:20:37.571 
看起來眼熟的APIs
我們還提供歷史傳感器數據

00:20:38.205 --> 00:20:41.275 
計步器自身也有了一大堆很酷的更新

00:20:41.341 --> 00:20:46.480 
它的精確度更高了
並且有了兩個新的APIs

00:20:46.547 --> 00:20:48.215 
即步幅和步調

00:20:48.282 --> 00:20:51.385 
計步器現在是個多面手了
對於你的健身apps來說

00:20:51.451 --> 00:20:53.120 
這是個好消息

00:20:54.221 --> 00:20:56.657 
從傳統意義上說
Core Motion已經被用於

00:20:57.024 --> 00:20:59.359 
遊戲、手勢以及健身

00:20:59.426 --> 00:21:02.296 
對於Core Motion來說
可用的應用程序有很多

00:21:02.696 --> 00:21:08.068 
Core Motion也可以被用來
曾強其它的apps的智能

00:21:08.402 --> 00:21:12.105 
我要把加布裏埃爾請上來
請他給你們解釋下這個概念

00:21:21.381 --> 00:21:22.449 
大家好

00:21:23.350 --> 00:21:25.085 
能到這裏我感到十分激動

00:21:25.819 --> 00:21:29.089 
作爲一名開發者 
我之前從未參加過蘋果全球開發者大會

00:21:29.890 --> 00:21:32.726 
但是無論我在哪裏工作
我總是在六月份的第一週內

00:21:32.993 --> 00:21:37.364 
在家裏用電腦觀看全部會議視頻

00:21:38.432 --> 00:21:39.933 
我瞭解到了很多信息

00:21:40.000 --> 00:21:42.336 
但是其中讓我頭疼的是

00:21:42.503 --> 00:21:43.871 
信息量太大了

00:21:44.805 --> 00:21:48.609 
即使在一個會議視頻中
要吸收的東西也太多了

00:21:48.876 --> 00:21:51.311 
當你看完後
你可能把過去的一小時內

00:21:51.378 --> 00:21:53.180 
學到的東西全都忘光

00:21:54.481 --> 00:21:57.317 
我在這裏要做的
就是把阿尼爾剛剛向你們

00:21:57.384 --> 00:21:59.019 
提到的事情拿出來

00:21:59.553 --> 00:22:01.788 
看看你們到底想在你們的
應用程序中把它們用起來

00:22:01.855 --> 00:22:04.591 
希望能讓你記住這些東西

00:22:06.293 --> 00:22:10.464 
Core Motion非常棒
因爲它不僅能夠用於

00:22:10.531 --> 00:22:12.866 
健身語境或者遊戲語境

00:22:13.433 --> 00:22:16.603 
今天我要向你們展示的
是不管你的app屬於

00:22:16.970 --> 00:22:18.906 
什麼類別 你都可以把它用起來

00:22:20.507 --> 00:22:22.409 
Core Motion
能怎樣爲你效勞呢？

00:22:24.077 --> 00:22:27.748 
Core Motion
允許你檢測用戶正在做的事情

00:22:29.049 --> 00:22:31.385 
你可以知道用戶是否正坐在他們的車裏

00:22:31.652 --> 00:22:34.321 
是否在跑步是否在騎自行車

00:22:35.022 --> 00:22:37.724 
就像我們之前看到的
你可以知道他們的步幅變動

00:22:37.791 --> 00:22:39.159 
我們可以幫你讓它更加平滑

00:22:40.127 --> 00:22:42.196 
藉助這些變動

00:22:42.529 --> 00:22:46.400 
我們無需給用戶發送提示
請他們告訴我們

00:22:46.466 --> 00:22:48.202 
就可以知道他們所處的語境

00:22:48.569 --> 00:22:52.706 
這樣用戶的體驗就更加神奇了
我們的apps也就更智能了

00:22:54.074 --> 00:22:56.510 
其次 我們還能讓用戶參與進來

00:22:57.311 --> 00:23:01.081 
因爲每隔幾秒鐘就有更新
我們就可以知道用戶的步幅

00:23:01.148 --> 00:23:02.449 
發生了怎樣的變動

00:23:02.516 --> 00:23:04.718 
我們可以知道
他們高度的發生了怎樣的變動

00:23:04.785 --> 00:23:08.589 
相應地我們可以快速更新
我們的app UI

00:23:10.424 --> 00:23:12.359 
最後我們還可以“反射返回”

00:23:13.460 --> 00:23:15.362 
我知道“反射返回”聽起來很蹩腳

00:23:15.829 --> 00:23:18.432 
但是對於Core Motion來說
很棒的一點就在於

00:23:18.498 --> 00:23:21.034 
通過始終保持它的運行
我們可以讓你的app看起來好像

00:23:21.101 --> 00:23:24.238 
一天二十四小時、
一週七天都在努力工作

00:23:24.304 --> 00:23:26.206 
實際上工作的是協處理器

00:23:27.541 --> 00:23:29.710 
我們可以看到過去一週內
你的活動性更新情況

00:23:29.776 --> 00:23:32.012 
你的計步器更新情況

00:23:32.246 --> 00:23:33.447 
這一點很贊

00:23:35.449 --> 00:23:38.752 
我記住了這三點
因此我決定來編寫一款

00:23:38.819 --> 00:23:40.120 
音樂播放器

00:23:40.921 --> 00:23:43.857 
不是想與Apple
 Music或者類似產品進行競爭

00:23:44.291 --> 00:23:47.661 
Core Motion怎樣可以
讓我的app的體驗

00:23:47.728 --> 00:23:50.264 
更加迷人、更有魔力

00:23:52.399 --> 00:23:55.969 
很多音樂應用程序都有
這個播放列表的概念

00:23:56.270 --> 00:23:58.639 
我想聽到不同的音樂當我在我的車裏時

00:23:58.705 --> 00:24:02.242 
我想聽到廣播而如果我是在學習或者

00:24:02.309 --> 00:24:04.344 
正在努力工作
可能就想要聽一些古典音樂

00:24:04.411 --> 00:24:06.446 
鍛鍊身體時
也有不同的app播放列表

00:24:07.381 --> 00:24:10.083 
通過檢測某個用戶正在做什麼

00:24:10.417 --> 00:24:13.987 
我的音樂應用程序就可以
相應地改變我的播放列表

00:24:14.121 --> 00:24:15.989 
而無需讓用戶進行選擇

00:24:16.890 --> 00:24:20.694 
類似地我們知道了步幅的變化
我們就可以說

00:24:20.761 --> 00:24:24.198 
嘿！你正在進行慢跑
可能是因爲你剛纔跑到太快

00:24:24.264 --> 00:24:26.900 
並且爬了一座非常高的山
我們就可以給你放一首

00:24:26.967 --> 00:24:29.736 
讓人興奮的歌曲 讓你有一種成就感

00:24:29.803 --> 00:24:32.239 
或者可以試着與你的步調相匹配

00:24:33.674 --> 00:24:35.342 
下面就到了“反射”部分

00:24:35.876 --> 00:24:37.077 
關於“反射”兩點很棒

00:24:37.144 --> 00:24:39.246 
尤其是在我的音樂應用程序

00:24:39.313 --> 00:24:40.514 
這個語境下

00:24:41.882 --> 00:24:45.619 
第一件事我可以看看數據
瞭解用戶當前正在做的事情

00:24:45.819 --> 00:24:47.554 
嘿 你已經有一段時間不跑了

00:24:47.888 --> 00:24:50.691 
可能你很快就要跑
也可能你想使用我們的

00:24:50.757 --> 00:24:52.626 
應用程序來跑步

00:24:52.826 --> 00:24:54.261 
並且聽一下你的播放列表

00:24:55.128 --> 00:24:57.064 
一天結束時 我們想要刺激我們的用戶

00:24:57.164 --> 00:24:58.332 
回到我們的app中來

00:24:59.867 --> 00:25:02.469 
我想用戶可能想要知道他們昨天

00:25:03.637 --> 00:25:07.808 
在車裏聽的播放列表是什麼
如果我們能實現的話 那就太棒了

00:25:08.242 --> 00:25:13.080 
通過查看活動性信息
然後把它與我的播放列表信息進行匹配

00:25:13.447 --> 00:25:15.115 
我就可以把那個信息提供給用戶

00:25:16.617 --> 00:25:18.986 
記住了這三件事

00:25:19.419 --> 00:25:22.456 
我們來看看我的應用程序
實際是什麼樣子的

00:25:25.459 --> 00:25:27.761 
當用戶打開app時
我們僅僅想把一個基本的

00:25:27.828 --> 00:25:29.563 
播放列表展示給他們

00:25:29.997 --> 00:25:32.966 
對我來說
我現在是站着不動 對吧？

00:25:33.333 --> 00:25:35.402 
我們來一些低強度的音樂

00:25:35.502 --> 00:25:36.470 
不要太劇烈

00:25:37.571 --> 00:25:39.573 
當我們檢測到用戶正在加速

00:25:40.073 --> 00:25:42.009 
可能是他們開始進行鍛鍊了

00:25:42.276 --> 00:25:44.011 
我們要對播放列表進行變更

00:25:44.378 --> 00:25:47.014 
給他們一些更加歡快的音樂

00:25:48.348 --> 00:25:50.651 
就是在這裏
app開始與用戶接洽起來了

00:25:50.717 --> 00:25:53.520 
我們看看發生了什麼變動
也許是步調發生了變動

00:25:53.887 --> 00:25:57.891 
也許是高度發生了變動
我們就可以接洽並且跟隨

00:25:57.958 --> 00:26:01.061 
這些變動 這樣當用戶加速時
我們就可以給他們

00:26:01.195 --> 00:26:02.663 
一個強度更高的播放列表

00:26:04.932 --> 00:26:07.201 
然後我們就想要切換環境了

00:26:07.267 --> 00:26:10.003 
當用戶開車時
我就想在他們早晨上班路上

00:26:10.070 --> 00:26:14.308 
把他們的podcast
或者他們經常聽的任何節目

00:26:14.374 --> 00:26:15.576 
提供給他們

00:26:17.644 --> 00:26:21.081 
這是“檢測”部分
以及“接洽”部分

00:26:21.582 --> 00:26:23.483 
接下來是“反射”部分

00:26:24.651 --> 00:26:27.855 
我想把這個信息分成幾個有趣的部分

00:26:27.921 --> 00:26:30.524 
這樣用戶就可以向後滾動
看看他們的“歷史”

00:26:30.824 --> 00:26:33.594 
我可能想把這個與用戶在不同時刻聽的

00:26:33.660 --> 00:26:36.063 
播放列表連接起來

00:26:38.298 --> 00:26:41.702 
既然我們已經知道了
app會是什麼樣子的

00:26:42.202 --> 00:26:44.872 
我們再來看看動作活動性的實際應用

00:26:45.272 --> 00:26:48.642 
看看要實現這些功能
我們需要什麼樣的APIs

00:26:51.445 --> 00:26:53.080 
首先我們有“檢測”部分

00:26:53.146 --> 00:26:56.149 
這個部分是我們希望能夠一直運行的

00:26:56.683 --> 00:26:59.753 
我們想知道用戶是否正在開車

00:26:59.820 --> 00:27:02.823 
用戶是否正在走路
用戶走路的速度有多快

00:27:03.323 --> 00:27:04.825 
那麼以此我們需要什麼？

00:27:05.959 --> 00:27:08.295 
活動性更新情況以及計步器更新情況

00:27:08.729 --> 00:27:12.299 
我們想要監控這些情況 讓它們更平滑

00:27:12.666 --> 00:27:16.737 
看看哪個信息可以使得我們判定語境

00:27:18.405 --> 00:27:20.307 
其次我們有那個“接洽”部分

00:27:21.241 --> 00:27:24.144 
如果用戶正在走路或者跑步對於我來說

00:27:24.478 --> 00:27:26.580 
我想知道他們的速度有多快

00:27:26.847 --> 00:27:31.118 
看看步調 我就可以知道他們是否

00:27:31.185 --> 00:27:35.222 
爬了一座高大的丘陵
這樣我就可以給他們播放一首

00:27:35.289 --> 00:27:36.690 
歡快的歌來慶祝他們的成就

00:27:36.957 --> 00:27:39.526 
爲此 我需要計步器更新情況

00:27:39.593 --> 00:27:42.229 
這些情況裏麪包括步幅、步調的變更

00:27:42.663 --> 00:27:44.131 
以及高度更新情況

00:27:45.933 --> 00:27:47.968 
然後我們還有“反射”部分

00:27:48.602 --> 00:27:50.704 
就像我之前說過
Core Motion很棒的是

00:27:50.771 --> 00:27:53.407 
它們可以一天二十四小時、
一週七天都爲我努力工作

00:27:53.974 --> 00:27:57.377 
因此我就可以進行回顧
獲取那些歷史活動性查詢

00:27:57.678 --> 00:28:02.249 
以及計步器查詢
然後把這個信息分成幾個有趣的部分

00:28:05.819 --> 00:28:09.690 
既然我已經仔細看了
我的app長什麼樣

00:28:09.756 --> 00:28:12.993 
看了“檢測”、“接洽”
以及“反射”部分

00:28:13.060 --> 00:28:16.363 
也知道了我需要使用Core 
Motion哪一部分的APIs

00:28:16.730 --> 00:28:18.932 
我要向你們展示下
我到底是如何編碼的

00:28:18.999 --> 00:28:21.401 
最起碼要讓你們看看我的
應用程序的數據模型

00:28:23.504 --> 00:28:25.372 
我要打開Xcode

00:28:26.006 --> 00:28:28.308 
但是在我走到這邊的電腦之前

00:28:28.709 --> 00:28:31.645 
先提醒你們一下
屏幕上會出現大量的文本

00:28:32.212 --> 00:28:33.780 
別被嚇跑了

00:28:34.081 --> 00:28:37.050 
示例代碼現在已經放到網上了

00:28:37.184 --> 00:28:39.620 
現在請勿打開

00:28:42.122 --> 00:28:43.223 
請僅僅關注

00:28:43.290 --> 00:28:45.626 
我爲你們高亮顯示的部分

00:28:46.093 --> 00:28:48.262 
我之前已經說過了那裏會有大量的文本

00:28:48.495 --> 00:28:52.299 
如果僅看那幾個東西然後會議結束後

00:28:52.366 --> 00:28:54.401 
回去看看示例代碼

00:28:54.701 --> 00:28:57.504 
你就能記住我重點講的東西
而不是想要

00:28:57.571 --> 00:28:59.039 
一次做太多的事

00:29:00.274 --> 00:29:02.242 
我已經說過了 文本會很多提醒過了

00:29:02.976 --> 00:29:05.078 
就像我說過的
屏幕上有大量的文本

00:29:05.379 --> 00:29:08.015 
我只想讓你們記住三個部分

00:29:09.616 --> 00:29:11.952 
就是“檢測”、“接洽”與“反射”

00:29:12.019 --> 00:29:13.520 
記住了這些事情那麼我要仔細看看

00:29:13.587 --> 00:29:16.890 
我的應用程序的數據模型中的這些東西

00:29:17.324 --> 00:29:21.261 
這個就是“數據模型”部分

00:29:21.328 --> 00:29:23.197 
剩下的部分供你以後自己探索

00:29:23.564 --> 00:29:26.400 
我要做的第一件事是“檢測”

00:29:26.533 --> 00:29:29.436 
這就要求獲得活動性更新情況
以及計步器更新情況

00:29:29.503 --> 00:29:31.238 
我們來看看這些活動性更新情況

00:29:36.009 --> 00:29:37.144 
很好 文本很多 是吧？

00:29:38.579 --> 00:29:40.914 
我要做的第一件事
就是校驗下看看這個硬件上

00:29:40.981 --> 00:29:43.717 
能否使用活動性

00:29:44.551 --> 00:29:47.454 
就像阿尼爾之前提到的
活動性並不總是可用

00:29:47.521 --> 00:29:51.725 
因此在我們查詢任何更新情況之前
我們需要進行這些校驗

00:29:53.794 --> 00:29:55.062 
我們要做的第二件事是 使用

00:29:55.128 --> 00:29:58.165 
startActivitiesUpdateToQueue

00:29:58.232 --> 00:29:59.733 
API

00:30:00.033 --> 00:30:03.770 
對於我而言
我只是進行了一個簡單的NS操作查詢

00:30:04.838 --> 00:30:06.840 
然後我要對數據進行處理

00:30:09.209 --> 00:30:12.312 
動作活動性就頻繁顯示出來了

00:30:12.880 --> 00:30:15.415 
你可以自己決定
怎樣對數據進行平滑操作

00:30:15.949 --> 00:30:18.986 
對於我而言當某個用戶跑步時

00:30:19.253 --> 00:30:22.155 
他們可能會遇到紅燈停下
處於半靜止的狀態

00:30:22.523 --> 00:30:24.992 
我不想從跑步時的播放列表
轉移到非常舒緩的播放列表

00:30:25.058 --> 00:30:26.493 
然後這樣 來來回回

00:30:26.560 --> 00:30:27.761 
往往復復

00:30:28.295 --> 00:30:32.499 
所以我想做的是自己指定
應用程序的平滑操作至於你的應用程序

00:30:32.566 --> 00:30:34.701 
最適合什麼樣的平滑操作
我就交給你來決定了

00:30:36.837 --> 00:30:38.839 
讓我們再來看看
計步器的更新情況

00:30:44.344 --> 00:30:47.848 
PedometerUpdates
API看起來也非常眼熟 你看到的

00:30:48.415 --> 00:30:51.752 
我也要校驗下 看看計步是否可用

00:30:52.486 --> 00:30:54.955 
即使我們假定
活動性可能是可以用的

00:30:55.022 --> 00:30:57.491 
那也並不意味着計步也同樣可用

00:30:58.959 --> 00:31:02.362 
假定計步真的可用 那麼我要
startPedometerUpdates

00:31:02.729 --> 00:31:05.766 
這個API可以允許我們提供一個日期

00:31:06.366 --> 00:31:08.635 
如果你所處的是一個更日記化的語境
你可能就想

00:31:08.702 --> 00:31:10.704 
在你的日期一開始 啓動這些更新

00:31:10.804 --> 00:31:11.738 
就我而言

00:31:11.805 --> 00:31:14.808 
我想在我的應用程序的
生命週期內看到這些更新

00:31:14.942 --> 00:31:16.677 
因此我現在就要啓動這些更新

00:31:19.980 --> 00:31:22.749 
有一件非常重要的事情我需要指出

00:31:24.318 --> 00:31:25.485 
我們可能會收到一個錯誤

00:31:27.821 --> 00:31:33.193 
關於Core Motion很棒的是

00:31:33.794 --> 00:31:38.098 
它們會做出這樣的事：喂！是否想讓此
app使用爲你彈出的活動數據？

00:31:39.700 --> 00:31:42.169 
但是用戶可能會第一次
打開你的應用程序

00:31:42.236 --> 00:31:46.473 
然後允許你訪問活動數據
但是他們可以隨時回到

00:31:46.940 --> 00:31:49.142 
“偏好”中把授權刪除

00:31:49.743 --> 00:31:52.679 
在那種情況下
當你試圖接受更新情況時

00:31:52.746 --> 00:31:54.548 
我們就會拋出一個授權錯誤

00:31:54.848 --> 00:31:57.084 
那麼你就需要平滑地處理這些問題

00:31:57.150 --> 00:32:01.321 
提示用戶進到應用程序設置中

00:32:01.522 --> 00:32:04.758 
再次對你的應用程序進行授權

00:32:06.860 --> 00:32:10.097 
我在這裏不去設置中了
但是我會彈出一個簡單的UI

00:32:10.163 --> 00:32:11.798 
提醒視圖 提示要去設置

00:32:13.367 --> 00:32:14.835 
這就是“檢測”部分

00:32:15.202 --> 00:32:18.472 
接下來我要做的就是“接洽”部分

00:32:20.140 --> 00:32:23.477 
就我而言 當我看到活動性更新時

00:32:23.877 --> 00:32:27.247 
我還想啓動、終止高度表的更新

00:32:27.981 --> 00:32:29.349 
我要在這裏這樣做

00:32:31.118 --> 00:32:34.421 
我進行了平滑處理
看看用戶什麼時候在跑步或者在步行

00:32:34.488 --> 00:32:36.890 
在那個例子中
我對高度的更新情況很感興趣

00:32:41.595 --> 00:32:43.363 
很好現在你可以在這裏看到一個主題了

00:32:44.031 --> 00:32:45.299 
我要做的第一件事

00:32:45.365 --> 00:32:47.434 
就是校驗下 看看高度更新是否可用

00:32:48.569 --> 00:32:50.003 
假定它是可用的 我會

00:32:50.070 --> 00:32:52.940 
startRelativeAltitude
UpdatesToQueue

00:32:54.675 --> 00:32:56.310 
我創建了一個隊列

00:32:57.010 --> 00:32:58.846 
然後我要對數據進行相應的處理

00:32:59.546 --> 00:33:01.648 
我再校驗一次 看看是否有錯誤

00:33:01.982 --> 00:33:04.384 
如果沒有錯誤
那麼我要在我的應用程序中把那個數據

00:33:04.818 --> 00:33:08.455 
當成最優服務來處理
至於你的數據該如何進行

00:33:08.755 --> 00:33:10.824 
最優服務處理 那由你決定

00:33:14.061 --> 00:33:16.430 
接下來我要做的就是
因爲我對持續的高度更新

00:33:16.496 --> 00:33:20.834 
不感興趣 因此要確保當我不是處於

00:33:21.068 --> 00:33:22.636 
跑步或者走路時把它停掉

00:33:29.376 --> 00:33:33.580 
很好 在這裏這個API非常直接

00:33:33.647 --> 00:33:35.082 
我校驗下可用性

00:33:35.282 --> 00:33:38.485 
我來
stopRelativeAltitudeUpdates

00:33:40.754 --> 00:33:42.623 
現在我知道了 
當我說我們想要與用戶進行

00:33:42.689 --> 00:33:44.525 
“接洽”時我們也會同時看到

00:33:44.591 --> 00:33:46.193 
計步器的更新情況

00:33:46.860 --> 00:33:49.796 
你可能記得
在我的應用程序的生活週期內

00:33:49.863 --> 00:33:52.966 
我已經看到了計步器的更新情況 因此

00:33:53.033 --> 00:33:54.501 
我無需再次啓動、停止它們

00:33:54.801 --> 00:33:57.871 
我可以把這些融合到高度更新中來用

00:33:57.971 --> 00:34:01.141 
給我提供我的應用程序需要的東西

00:34:01.208 --> 00:34:03.043 
也就是通過音樂來激勵用戶

00:34:04.811 --> 00:34:06.547 
這就是“反射”部分

00:34:12.252 --> 00:34:15.755 
那麼在這裏
我要看看活動性的更新情況

00:34:15.822 --> 00:34:18.792 
以便我以有趣的部分的形式
提供這些東西

00:34:18.859 --> 00:34:20.159 
就像我之前給你們看的那樣

00:34:27.234 --> 00:34:30.404 
很好 我希望你們看的 第一件事

00:34:30.771 --> 00:34:33.172 
就是我們可以查詢日期後的
所有的活動性的更新情況

00:34:33.507 --> 00:34:36.243 
就我而言
我想看看過去一週的情況

00:34:36.643 --> 00:34:38.779 
即使我們不看
那一週的應用程序的使用情況

00:34:38.978 --> 00:34:41.315 
我們也可以獲取所有的數據

00:34:41.380 --> 00:34:42.850 
然後把它們放到一起

00:34:46.719 --> 00:34:49.523 
就我而言
我對那個數據進行下處理

00:34:49.590 --> 00:34:51.225 
讓它們爲我以有趣的部分的形式顯示

00:34:51.291 --> 00:34:53.560 
我等不及想看看你們自己

00:34:53.627 --> 00:34:54.828 
會怎麼做了

00:34:55.495 --> 00:34:57.464 
又出現了 我知道唱片損壞了 對吧？

00:34:57.931 --> 00:35:00.033 
我要對這個錯誤進行相應的處理

00:35:01.468 --> 00:35:04.104 
就我而言
一旦我找到有趣的步行片段

00:35:04.371 --> 00:35:07.908 
我就會給出全部的額外的

00:35:07.975 --> 00:35:09.910 
歷史計步器信息

00:35:09.977 --> 00:35:12.479 
那麼我在這裏要做的
我要爲某個給定的活動性片段

00:35:15.015 --> 00:35:20.621 
請求計步器的更新情況

00:35:26.527 --> 00:35:29.796 
第一件事就是
queryPedometerDataFromDate

00:35:29.863 --> 00:35:32.132 
我提供了一個開始日期
還提供了一個結束日期

00:35:32.199 --> 00:35:35.669 
就我而言
我已經把數據放到程序段中了

00:35:35.736 --> 00:35:38.539 
那麼我來看看這些段的開始和結束部分

00:35:40.073 --> 00:35:42.176 
這裏我要指出的第二件事是

00:35:43.810 --> 00:35:46.346 
如果我想要進行任何UI變更

00:35:46.413 --> 00:35:49.149 
那麼我就需要把這些變更發送到主隊列

00:35:49.550 --> 00:35:51.051 
如果你在你自己的應用程序內

00:35:51.118 --> 00:35:53.086 
不這麼做 那麼你就會遇到問題

00:35:55.189 --> 00:35:56.590 
所以請這麼做吧

00:35:57.257 --> 00:36:01.895 
我要向你們展示的就是這些
想你的應用程序添加活動

00:36:02.196 --> 00:36:04.298 
總共花了我十分鐘左右 因此

00:36:04.698 --> 00:36:07.601 
當你回去後 
給你的應用程序做同樣的事

00:36:07.668 --> 00:36:09.303 
就是這麼容易

00:36:10.170 --> 00:36:13.540 
現在我真的想讓你們看看這個app
但是我不會在這裏

00:36:13.607 --> 00:36:15.108 
跑一圈或者開車

00:36:15.442 --> 00:36:18.645 
我要向你們看看
過去今天內我的歷史數據

00:36:18.912 --> 00:36:21.515 
讓你們看看“反射”部分
是怎樣以有趣的圖段的形式

00:36:21.582 --> 00:36:22.783 
來組織數據的

00:36:28.455 --> 00:36:30.157 
但願這是一臺iPhone

00:36:33.660 --> 00:36:36.964 
太好了！這是我的音樂活動應用程序

00:36:37.731 --> 00:36:39.666 
你可以看到
我的活動強度不大

00:36:39.733 --> 00:36:41.835 
因此 我現在處於低強度模式

00:36:43.704 --> 00:36:45.672 
現在我再來看看我的歷史記錄情況

00:36:46.874 --> 00:36:49.409 
我要從昨天早上開始

00:36:49.877 --> 00:36:51.211 
讓你們看看我一天的情況

00:36:51.278 --> 00:36:53.580 
我昨天所做的
就是圍繞莫斯康走路

00:36:55.148 --> 00:36:58.252 
昨天我醒來後
我決定快速騎行一段時間

00:36:58.852 --> 00:37:02.656 
我所做的就是...
app已經搞定了

00:37:02.723 --> 00:37:04.791 
替我把這些放進了一個有趣的圖段

00:37:06.159 --> 00:37:10.564 
然後我朝着公交車走去
意識到有點晚了

00:37:10.631 --> 00:37:14.301 
於是就開始跑 最終上了公交車

00:37:15.169 --> 00:37:19.439 
你可以在這裏看到
我在這裏的就是步行的圖段

00:37:19.506 --> 00:37:22.709 
有英里信息
有步幅信息

00:37:23.076 --> 00:37:25.946 
層級上升與下降
這些都替我放進了

00:37:26.013 --> 00:37:27.381 
那些有趣的組塊中

00:37:28.215 --> 00:37:30.918 
如果我是在某個單元上
實際開發一款音樂應用程序

00:37:31.251 --> 00:37:34.555 
那麼我可能會把
當時我聽的播放列表

00:37:34.621 --> 00:37:36.456 
放到那個圖塊上

00:37:37.958 --> 00:37:41.028 
有一件事我要指出 話說今天

00:37:41.695 --> 00:37:43.564 
當我在莫斯康附近 走路的時候

00:37:43.964 --> 00:37:46.700 
我沒有出現任何層級的上升與下降

00:37:47.134 --> 00:37:48.235 
這是因爲我今天比較懶

00:37:48.302 --> 00:37:49.870 
到處都乘坐了自動扶梯

00:37:50.904 --> 00:37:53.040 
我希望你們也注意到了這一點

00:37:55.175 --> 00:37:57.211 
這就是我的
基礎的音樂應用程序

00:37:57.945 --> 00:37:59.079 
我來總結下

00:38:03.217 --> 00:38:05.786 
我希望你們喜歡這個演示

00:38:06.086 --> 00:38:08.322 
我儘量把重點放在少數幾個事情上

00:38:08.689 --> 00:38:11.325 
這樣你就可以記住
並且用到你的應用程序上記住

00:38:11.992 --> 00:38:15.362 
這裏有“檢測”片段 使用活動來檢測

00:38:15.429 --> 00:38:17.431 
某個用戶正在做的事情

00:38:17.497 --> 00:38:19.366 
而不是讓用戶告訴你
他們正在做什麼事情

00:38:20.067 --> 00:38:25.172 
通過活動性、計步器、高度表
推送更新與用戶進行“接洽”

00:38:26.206 --> 00:38:28.475 
以及“反射回去”

00:38:28.642 --> 00:38:33.247 
把那些歷史查詢智慧地運用起來

00:38:34.181 --> 00:38:36.350 
如果你有更多的問題

00:38:36.817 --> 00:38:38.185 
請到“開發者論壇”看一看

00:38:38.452 --> 00:38:40.888 
請務必看看音樂活動

00:38:40.954 --> 00:38:42.723 
它應該就在開發者入口處

00:38:43.156 --> 00:38:46.126 
如果是一般的諮詢
請聯繫我們的福音傳道者

00:38:47.961 --> 00:38:49.863 
此外還有一些會議與本次會議相關

00:38:49.963 --> 00:38:51.498 
它們也值得你去看看

00:38:52.299 --> 00:38:53.967 
如果你參加了蘋果全球開發者大會

00:38:54.334 --> 00:38:56.970 
你可能已經看過或者
還沒有看過HealthKit演示、

00:38:57.037 --> 00:38:58.705 
Cocoa Touch演示

00:38:59.106 --> 00:39:01.475 
如果你錯過了這些演示或者你現在在家

00:39:01.542 --> 00:39:03.177 
那麼請去網上看看這些視頻

00:39:03.610 --> 00:39:05.045 
同樣 我也希望你們去看看

00:39:05.112 --> 00:39:07.447 
Core Location的演示

00:39:08.982 --> 00:39:12.452 
如果你能夠真正把活動數據、健康數據

00:39:12.653 --> 00:39:16.523 
位置數據組合起來
那麼你就可以創建一些絕妙的語境

00:39:16.590 --> 00:39:18.559 
來讓你的應用程序更上一層樓

00:39:19.026 --> 00:39:21.862 
我迫不及待想看看你們會在
App Store上何應用程序

00:39:31.738 --> 00:39:33.106 
謝謝 太謝謝了