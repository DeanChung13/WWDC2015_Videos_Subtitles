00:00:20.254 --> 00:00:24.958 
CloudKit技術講座

00:00:30.030 --> 00:00:31.932 
<br/> 
大家下午好 歡迎參加

00:00:31.999 --> 00:00:33.834 
CloudKit技術講座 

00:00:34.668 --> 00:00:36.570 
我是尼哈 沙爾曼 

00:00:36.637 --> 00:00:38.172 
是CloudKit團隊的工程師 

00:00:39.072 --> 00:00:41.942 
我知道 你們一些人可能
對我們的平臺十分陌生 

00:00:42.242 --> 00:00:45.179 
而且是首次遇到
CloudKit框架 

00:00:46.013 --> 00:00:48.715 
而其他一些人可能已經開發
一些APP並且在應用商店中上架 

00:00:48.782 --> 00:00:51.051 
在本講座 我們將介紹
一些對所有人都適用的技術 

00:00:51.451 --> 00:00:52.286 
現在讓我們開始 

00:00:54.621 --> 00:00:55.822 
什麼是CloudKit？

00:00:56.390 --> 00:00:58.892 
去年我們推出了CloudKit

00:00:58.959 --> 00:01:00.961 
<br/>
這是一種全新的方法 

00:01:01.028 --> 00:01:03.997 
讓你能夠與Apple的
iCloud數據庫服務器對話 

00:01:05.032 --> 00:01:05.966 
利用此功能

00:01:06.033 --> 00:01:08.635 
我們爲你
提供一系列的內置技術 

00:01:09.303 --> 00:01:10.504 
例如大文件存儲等 

00:01:12.272 --> 00:01:14.208 
我們提供隱私保護標識符

00:01:14.274 --> 00:01:16.443 
讓你能夠有效地管理

00:01:16.777 --> 00:01:19.012 
任何擁有iCloud帳戶
的用戶 

00:01:21.215 --> 00:01:22.749 
首先也是最重要的

00:01:22.816 --> 00:01:25.853 
這是一個公開的開發者API 

00:01:25.919 --> 00:01:28.689 
因爲我們想希望你
利用這個平臺的強大功能 

00:01:28.755 --> 00:01:31.692 
爲你的用戶開發有用的APP 

00:01:33.527 --> 00:01:35.329 
最後但並非不重要的事情是

00:01:35.395 --> 00:01:36.864 
<br/>
Apple大力投資 

00:01:36.930 --> 00:01:37.764 
開發這項技術 

00:01:38.131 --> 00:01:40.033 
僅在去年
當我們首次發佈此項技術時 

00:01:40.667 --> 00:01:41.502 
我們就去推出

00:01:41.568 --> 00:01:42.636 
一系列重要的客戶端

00:01:42.703 --> 00:01:44.137 
包括iCloud drive

00:01:44.204 --> 00:01:46.173 
和iCloud
photo library

00:01:46.240 --> 00:01:48.041 
今年我們增加了一些新客戶端 

00:01:48.108 --> 00:01:50.711 
例如 Notes APP
 News APP

00:01:51.311 --> 00:01:54.448 
和WWDC APP 本週
你們很多人使用過這些APP

00:01:54.748 --> 00:01:56.283 
而且你們的手機上還有這些APP 

00:01:58.185 --> 00:01:59.753 
如果你不熟悉這些應用 

00:02:00.220 --> 00:02:01.588 
我請你回顧一下

00:02:01.989 --> 00:02:03.423 
去年的開發大會上的

00:02:03.490 --> 00:02:04.825 
CloudKit講座

00:02:04.892 --> 00:02:06.793 
和Advanced
CloudKit講座 

00:02:06.860 --> 00:02:09.263 
這些講座詳細地
介紹了新API 

00:02:09.329 --> 00:02:11.164 
我強烈建議你去看看 

00:02:12.466 --> 00:02:13.901 
我們來先講重要的事情 

00:02:13.967 --> 00:02:16.170 
你們很多人一直在使用

00:02:16.236 --> 00:02:18.872 
令人稱道的Swift 2新功能 

00:02:19.273 --> 00:02:22.342 
我很高興宣佈
對於iOS 9操作系統 

00:02:22.409 --> 00:02:25.445 
在Swift中使用CloudKit
將會更加容易 

00:02:26.480 --> 00:02:28.582 
讓我們來通過一些例子

00:02:28.649 --> 00:02:29.583 
來深入瞭解 

00:02:30.250 --> 00:02:34.288 
直到現在 當你在CK記錄中
設置和獲取值時 你還必須

00:02:34.354 --> 00:02:37.324 
使用陳舊的鍵值對象設置語法
使用對像語法設置鍵值

00:02:37.391 --> 00:02:40.327 
這些工作將由
CloudKit API來完成 

00:02:40.394 --> 00:02:44.097 
但是在iOS 9中  
在處理CK記錄時 

00:02:44.164 --> 00:02:46.567 
你可以使用更爲熟悉和

00:02:46.767 --> 00:02:48.101 
現代的字典訂閱語法 

00:02:49.903 --> 00:02:52.739 
除此之外 我們還利用
庫標識符和輕量級泛型

00:02:52.906 --> 00:02:56.410 
讓你在Swift中編寫的
CloudKit代碼

00:02:56.610 --> 00:02:58.478 
和Objective-C代碼

00:02:58.679 --> 00:02:59.746 
更不容易發生類型錯誤 

00:03:00.414 --> 00:03:05.118 
以前你可能需要爲記錄設置
一組任意類型的對象

00:03:05.552 --> 00:03:09.056 
來確保安全和正確的
CKRecords運算 

00:03:09.723 --> 00:03:13.994 
現在利用iOS 9中的最新工具 

00:03:14.061 --> 00:03:16.663 
當你做這些工作時 編譯器
會發出提醒 讓你及早發現錯誤 

00:03:16.964 --> 00:03:18.398 
編寫更可靠的代碼 

00:03:21.001 --> 00:03:23.170 
對此 請我簡要回顧

00:03:23.604 --> 00:03:25.305 
CloudKit存儲架構 

00:03:27.241 --> 00:03:31.144 
CloudKit的最頂層
稱爲CloudKit容器 

00:03:32.613 --> 00:03:35.749 
它分爲兩個數據庫 

00:03:36.283 --> 00:03:37.284 
一個公用數據庫

00:03:37.751 --> 00:03:40.587 
它是你的所有用戶共享的

00:03:41.288 --> 00:03:43.123 
龐大APP數據 

00:03:44.858 --> 00:03:46.326 
另一個私人數據庫  

00:03:46.393 --> 00:03:48.228 
僅供用戶的iCloud帳戶使用 

00:03:48.929 --> 00:03:50.430 
這個數據庫包含

00:03:50.497 --> 00:03:53.200 
特定iCloud帳戶
跨越所有用戶設備

00:03:53.267 --> 00:03:54.368 
所共享的數據 

00:03:55.769 --> 00:03:59.373 
在每個數據庫內 
我們還有一個分層離  

00:03:59.573 --> 00:04:01.041 
用於存儲記錄 

00:04:01.508 --> 00:04:03.110 
它們稱爲記錄區 

00:04:05.112 --> 00:04:07.948 
CloudKit使用這些數據庫

00:04:08.015 --> 00:04:09.983 
爲你存儲在其中的記錄
提供更多的功能

00:04:10.884 --> 00:04:13.687 
公用數據庫有一個
稱爲默認區域的存儲區域

00:04:13.754 --> 00:04:15.088 
用於存儲所有記錄 

00:04:17.190 --> 00:04:20.226 
私有數據庫也有一個默認區域 

00:04:20.627 --> 00:04:23.163 
利用這一特性  
你能夠創建

00:04:23.230 --> 00:04:25.332 
多個自定義區域 

00:04:25.732 --> 00:04:29.203 
這些區域可以爲你的記錄
提供更多的功能 

00:04:31.438 --> 00:04:33.674 
讓我來介紹

00:04:33.740 --> 00:04:35.943 
我們將在今天的講座中
所要探討的內容 

00:04:37.611 --> 00:04:39.713 
你可能還記得 在去年
我們討論了schema 

00:04:39.847 --> 00:04:42.816 
我們介紹了一個APP的
示例schema 

00:04:42.883 --> 00:04:44.685 
這個APP通過雲端
將內容提供給各方 

00:04:45.519 --> 00:04:48.388 
這裏有一個簡單的schema
其中有一個party記錄類型

00:04:48.455 --> 00:04:50.924 
和clown記錄類型 
這兩個類型的記錄

00:04:51.758 --> 00:04:54.761 
存儲在公用數據庫之中
讓我們來運行這個示例APP

00:04:55.729 --> 00:04:57.798 
並且爲它開發更多的功能

00:04:58.298 --> 00:05:00.734 
我們將這個示例APP
稱爲clown central 

00:05:00.801 --> 00:05:01.702 
因爲它是關於小丑的  

00:05:03.604 --> 00:05:05.239 
我們將使用一個示例來介紹

00:05:05.305 --> 00:05:07.040 
當你使用CloudKit
進行開發時 

00:05:07.207 --> 00:05:09.009 
可以運用的經驗和技巧 

00:05:10.344 --> 00:05:12.279 
我們的APP有一個
簡單的UI

00:05:12.346 --> 00:05:14.181 
在這個UI中

00:05:14.248 --> 00:05:16.884 
我們顯示派對列表 
在這個講座中 

00:05:16.950 --> 00:05:18.318 
我們將會介紹一系列的功能 

00:05:20.120 --> 00:05:20.954 
現在

00:05:21.021 --> 00:05:24.224 
通過示例
我將會討論四個主要方面的內容 

00:05:25.692 --> 00:05:27.594 
第一個方面是錯誤處理 

00:05:28.762 --> 00:05:29.863 
去年 我們曾經講到過

00:05:29.930 --> 00:05:32.165 
CloudKit APP

00:05:32.232 --> 00:05:33.667 
是否處理錯誤

00:05:34.234 --> 00:05:36.770 
不僅關係到APP的好壞

00:05:37.137 --> 00:05:38.906 
甚至還決定APP是否

00:05:39.106 --> 00:05:40.440 
正常運行或者完全崩潰 

00:05:41.041 --> 00:05:41.909 
的確是這樣的  

00:05:42.576 --> 00:05:45.546 
當你使用API時 

00:05:45.612 --> 00:05:48.649 
你會遇到一組特殊的錯誤代碼 
我會講解這些代碼 

00:05:49.116 --> 00:05:50.684 
併爲你提供一些
一般性指導原則 

00:05:50.884 --> 00:05:51.818 
告訴你如處理錯誤 

00:05:53.387 --> 00:05:54.221 
對此

00:05:54.288 --> 00:05:56.356 
我們將會介紹
一系列的技術 

00:05:56.423 --> 00:05:57.724 
你需要記住這些技術

00:05:57.791 --> 00:05:59.359 
當你維護本地緩存 

00:05:59.660 --> 00:06:00.727 
進行CloudKit開發工作時 
可以使用這些技術 

00:06:02.029 --> 00:06:04.097 
然後我們將會討論
如何設置訂閱 

00:06:04.164 --> 00:06:06.934 
以不斷地更新緩存 

00:06:07.634 --> 00:06:10.037 
最後我將介紹一系列的

00:06:10.103 --> 00:06:12.739 
通用性能技術你應該記住它們

00:06:12.806 --> 00:06:15.175 
並用於你的APP開發 

00:06:16.944 --> 00:06:18.579 
因此我們將會講解許多內容 

00:06:18.645 --> 00:06:21.281 
現在讓我們講解錯誤處理 

00:06:26.587 --> 00:06:29.623 
我首先要討論的事項
是關於帳戶的 

00:06:30.824 --> 00:06:32.993 
CloudKit並不需要

00:06:33.060 --> 00:06:35.128 
你具有一個iCloud帳戶 

00:06:35.462 --> 00:06:38.932 
我們允許匿名只讀
訪問公用數據庫 

00:06:40.033 --> 00:06:41.935 
比如說 爲了便於演示 

00:06:42.002 --> 00:06:44.805 
clown central APP
將需要一個iCloud賬戶 

00:06:46.206 --> 00:06:47.708 
我們將討論一系列的功能 

00:06:47.774 --> 00:06:50.844 
這些功能使用私有數據庫 

00:06:50.911 --> 00:06:52.779 
根據定義 將需要
一個通過身份驗證的帳戶 

00:06:54.515 --> 00:06:56.049 
默認情況下 數據庫寫訪問

00:06:56.116 --> 00:06:58.085 
需要一個帳戶 

00:07:00.554 --> 00:07:03.190 
需要注意的是 
檢查當前用戶的

00:07:03.457 --> 00:07:05.959 
帳戶狀態的方法是
使用CK容器內可用的

00:07:06.026 --> 00:07:09.229 
完成處理API進行檢查 

00:07:11.832 --> 00:07:15.035 
在進行CloudKit開發時 
由於身份驗證而造成的錯誤

00:07:15.102 --> 00:07:16.403 
將會導致失敗 

00:07:16.470 --> 00:07:20.107 
並返回CKError
身份未驗證錯誤代碼 

00:07:21.475 --> 00:07:23.744 
處理這種錯誤的一般性做法是

00:07:23.810 --> 00:07:25.045 
重新檢查帳戶狀態 

00:07:26.947 --> 00:07:29.249 
例如 缺少iCloud帳戶 

00:07:30.083 --> 00:07:31.518 
當你檢查賬戶狀態時 

00:07:31.718 --> 00:07:34.488 
你會收到“無帳戶”
 CKAccount狀態 

00:07:36.356 --> 00:07:37.491 
在以前

00:07:37.558 --> 00:07:39.126 
你沒有辦法知道

00:07:39.393 --> 00:07:41.895 
因爲帳戶缺失而失敗的請求

00:07:42.062 --> 00:07:43.297 
是否會繼續 

00:07:44.231 --> 00:07:45.532 
正因爲如此

00:07:45.599 --> 00:07:47.668 
在iOS 9和
OS X El Capitan中 

00:07:47.935 --> 00:07:50.470 
我們添加了CKAccount
變更通知 

00:07:51.138 --> 00:07:54.975 
當用戶帳戶發生變更時 

00:07:55.042 --> 00:07:57.144 
例如無登錄或退出 

00:07:57.444 --> 00:07:59.213 
或者iCloud 
drive功能開關

00:07:59.279 --> 00:08:00.581 
被開啓或關閉 
將會發送此通知 

00:08:02.850 --> 00:08:06.086 
爲此 我想介紹一些
最佳實踐方法 

00:08:06.153 --> 00:08:08.322 
以處理APP中的賬戶缺失錯誤 

00:08:10.290 --> 00:08:11.658 
一種看上去不錯的方法是

00:08:11.725 --> 00:08:13.126 
<br/>
當遇到這種情況時 

00:08:13.193 --> 00:08:14.928 
拋出一個警告

00:08:15.395 --> 00:08:17.264 
告訴用戶他們沒有登錄iCloud

00:08:17.331 --> 00:08:18.832 
<br/>
因此不能繼續 

00:08:19.800 --> 00:08:21.535 
但是這對用戶來說沒有幫助作用 

00:08:21.602 --> 00:08:23.470 
因爲他們可能會忽略警告

00:08:24.004 --> 00:08:25.839 
重新嘗試操作 

00:08:25.906 --> 00:08:28.509 
從而會繼續看到警告 

00:08:29.576 --> 00:08:31.879 
我們建議的方法是

00:08:32.679 --> 00:08:35.048 
巧妙地設置你的UI 

00:08:35.115 --> 00:08:38.684 
禁用需要帳戶的功能 

00:08:39.620 --> 00:08:41.822 
爲此
你可以使用

00:08:41.889 --> 00:08:43.457 
CKAccount變更通知 

00:08:43.590 --> 00:08:45.125 
當你收到此通知時

00:08:45.192 --> 00:08:46.126 
<br/>
應重新檢查用戶狀態 

00:08:46.193 --> 00:08:47.561 
查看帳戶是否可用

00:08:47.628 --> 00:08:49.229 
如果可用 則重新啓用UI 

00:08:52.165 --> 00:08:53.600 
帳戶缺失僅僅是

00:08:53.667 --> 00:08:59.039 
操作臨時發生故障的
的原因之一 

00:09:01.041 --> 00:09:03.177 
但是它可能在未來的
某個時間點發生 

00:09:04.511 --> 00:09:06.980 
例如 在較差的
網絡條件下 

00:09:07.114 --> 00:09:09.883 
你可能遇到這種錯誤 
CKError網絡故障 

00:09:11.318 --> 00:09:13.620 
或者CloudKit服務器忙時 
也會發生這種錯誤 

00:09:13.687 --> 00:09:14.988 
你可能會看到以下錯誤之一：

00:09:15.055 --> 00:09:16.323 
CKError服務不可用

00:09:16.990 --> 00:09:18.225 
或CKError區域忙 

00:09:19.326 --> 00:09:21.995 
遇到這種錯誤時

00:09:22.629 --> 00:09:24.831 
你應該在稍後重試操作 

00:09:26.099 --> 00:09:28.202 
但是你可能會想 

00:09:28.435 --> 00:09:29.736 
我應該在何時重試這些操作？

00:09:30.537 --> 00:09:32.906 
你不需要猜想這個時間值 

00:09:34.842 --> 00:09:37.144 
發生這些錯誤時 
在我們發送給你的用戶信息字典中 

00:09:37.211 --> 00:09:40.314 
在“CKError retry
 after key.”鍵值中

00:09:40.380 --> 00:09:41.949 
<br/>
有一個專用的值 

00:09:42.983 --> 00:09:46.186 
這個值就是
在重新嘗試操作之前 

00:09:46.253 --> 00:09:48.522 
需要等待的時間 單位爲秒 

00:09:51.458 --> 00:09:53.460 
現在讓我們來看一個
類似的例子

00:09:54.061 --> 00:09:57.130 
在這個例中 我們的APP
有一個bug 

00:09:57.197 --> 00:09:58.599 
可能導致APP 

00:09:58.866 --> 00:10:02.336 
在極短的時間內 
向服務器發送大量更新 

00:10:03.270 --> 00:10:06.373 
如果這個APP始終這樣做

00:10:06.440 --> 00:10:08.342 
而且許多用戶觸發這個bug

00:10:08.642 --> 00:10:10.410 
將會導致
iCloud服務器崩潰 

00:10:11.078 --> 00:10:12.412 
爲了避免這種問題 

00:10:12.713 --> 00:10:13.780 
我們需要使用一個

00:10:13.847 --> 00:10:16.650 
名爲CKErrorRequest
RateLimited的

00:10:16.717 --> 00:10:17.684 
專用錯誤代碼 

00:10:19.019 --> 00:10:20.721 
CloudKit利用這種方法

00:10:20.787 --> 00:10:22.222 
避免APP bug造成

00:10:22.289 --> 00:10:24.157 
iCloud服務器崩潰 

00:10:26.159 --> 00:10:29.263 
如果請求數量達到限值 

00:10:29.329 --> 00:10:31.365 
在一定的時間期限內

00:10:31.565 --> 00:10:33.467 
將不發送請求給服務器

00:10:34.168 --> 00:10:35.936 
那麼這個時間期限是多少呢？

00:10:36.737 --> 00:10:39.339 
系統通過“CKErrorretry
afterkey”

00:10:39.406 --> 00:10:40.307 
來告知這個時間期限 

00:10:42.476 --> 00:10:44.111 
因此 當你遇到這種錯誤時

00:10:44.711 --> 00:10:47.114 
請在用戶錯誤信息字典中
查找這個鍵值 

00:10:47.481 --> 00:10:50.050 
請等待一定時間 
然後重試你的請求 

00:10:51.985 --> 00:10:54.154 
現在我想介紹
你可能會遇到的

00:10:54.221 --> 00:10:55.989 
另一種不同類別的錯誤 

00:10:56.857 --> 00:10:58.959 
這類錯誤是由於
schema設計方式造成的 

00:10:59.026 --> 00:10:59.860 
具體地說

00:10:59.927 --> 00:11:02.129 
如果你的schema 
允許多個用戶更新

00:11:04.231 --> 00:11:06.700 
Cloud數據庫中的同一條記錄 
就可能發生這類錯誤 

00:11:07.734 --> 00:11:10.370 
假設我們想要爲APP
增加一項功能 

00:11:10.671 --> 00:11:12.005 
從而允許用戶

00:11:12.472 --> 00:11:13.974 
將他們自己添加到派對之中 

00:11:16.009 --> 00:11:16.910 
但是不幸的是

00:11:16.977 --> 00:11:18.879 
在設計此APP的schema之前

00:11:18.946 --> 00:11:21.548 
我們並沒有參加去年的
關於高級CloudKit的講座 

00:11:23.083 --> 00:11:24.618 
這是我們設計的schema 

00:11:25.853 --> 00:11:27.621 
對於派對記錄本身

00:11:27.688 --> 00:11:28.755 
我們決定存儲

00:11:28.822 --> 00:11:31.425 
一個引用數組 
它指向想要

00:11:31.491 --> 00:11:32.726 
參加派對的人員記錄 

00:11:36.563 --> 00:11:38.699 
現在你可以看到 
每當我想要添加一個參加者

00:11:38.765 --> 00:11:40.701 
到一個特定的派對時 

00:11:41.001 --> 00:11:43.570 
我們都會修改同一個派對記錄

00:11:45.105 --> 00:11:47.641 
讓我們通過一個例子來瞭解 
當兩個不同的用戶

00:11:47.975 --> 00:11:51.345 
想要將他們添加到派對時 
將會發生什麼 

00:11:53.280 --> 00:11:55.949 
由於WWDC bash晚會
即將開始 

00:11:56.216 --> 00:11:58.018 
因此讓我們將這個記錄

00:11:58.085 --> 00:11:59.253 
保存到CloudKit 

00:12:00.621 --> 00:12:03.390 
在我們瞭解
當兩個用戶下載此記錄時

00:12:03.457 --> 00:12:05.192 
將會發生什麼之前

00:12:05.425 --> 00:12:06.260 
我想介紹一下

00:12:06.326 --> 00:12:09.062 
記錄變更標記(record 
change tags)是什麼  

00:12:10.097 --> 00:12:14.201 
你可以認爲它們是一個字符串

00:12:14.268 --> 00:12:15.736 
<br/>
服務器使用它

00:12:16.170 --> 00:12:18.172 
來標識特定的記錄版本 

00:12:18.672 --> 00:12:21.642 
保存在服務器上的記錄版本

00:12:21.708 --> 00:12:24.745 
通過變更標記A表示 

00:12:26.013 --> 00:12:29.383 
它是CKRecords的只讀屬性 

00:12:29.516 --> 00:12:32.553 
但是隻有已經保存的記錄
纔會有這個標記 

00:12:34.054 --> 00:12:36.657 
假設兩個用戶John
和Alice都下載

00:12:36.723 --> 00:12:38.959 
這個特定的記錄版本 

00:12:39.560 --> 00:12:42.262 
你可以看到
他們接收相同的變更標記A 

00:12:43.664 --> 00:12:46.867 
現在 John首先將他自己
作爲參加者添加到派對 

00:12:47.601 --> 00:12:50.304 
然後嘗試將他的記錄
添加到服務器 

00:12:51.438 --> 00:12:54.074 
現在這條記錄被保存  
我們將John的變更標記  

00:12:54.141 --> 00:12:57.010 
也就是A 發送到服務器 

00:12:57.678 --> 00:12:59.746 
服務器發現變更標記匹配 

00:13:00.614 --> 00:13:02.182 
因此接受John的更改 

00:13:03.383 --> 00:13:06.520 
由於服務器記錄版本已發生變化 

00:13:06.787 --> 00:13:09.523 
服務器將生成新的變更標記 
在本例中 此標記爲B 

00:13:10.023 --> 00:13:12.693 
並通過記錄保存響應消息 
將它發回給John 

00:13:15.262 --> 00:13:17.865 
現在Alice上線了 
她決定參加派對 

00:13:19.433 --> 00:13:22.135 
她嘗試相同的操作 
將她自己添加到數組中 

00:13:22.269 --> 00:13:23.904 
並嘗試保存她的記錄版本 

00:13:24.805 --> 00:13:25.939 
這時你會看到

00:13:26.006 --> 00:13:28.242 
她發送舊的變更標記A

00:13:29.142 --> 00:13:30.477 
服務器將會提醒 

00:13:30.577 --> 00:13:33.447 
她正在嘗試修改
已經不存在的

00:13:33.514 --> 00:13:34.681 
服務器記錄版本 

00:13:35.115 --> 00:13:36.750 
她遇到了衝突 

00:13:38.318 --> 00:13:39.920 
在她的設備上

00:13:39.987 --> 00:13:40.854 
CloudKit

00:13:40.921 --> 00:13:44.124 
通過“CKerror:server
 record changed” 

00:13:44.191 --> 00:13:47.060 
專用代碼向她告知這種衝突 

00:13:48.729 --> 00:13:51.532 
其背後的機制並不神祕 

00:13:51.598 --> 00:13:53.200 
我們不必想辦法

00:13:53.267 --> 00:13:55.202 
來解決這種衝突 

00:13:55.669 --> 00:13:57.070 
你自己就可以解決 

00:13:57.571 --> 00:13:59.973 
因此我們會爲你提供

00:14:00.307 --> 00:14:01.775 
儘可能多的有用信息 

00:14:01.842 --> 00:14:04.578 
讓你能夠自己解決衝突 

00:14:05.879 --> 00:14:07.781 
當更新請求被拒絕時  
我們爲你提供的最早

00:14:07.848 --> 00:14:09.683 
也是最重要的信息是

00:14:09.750 --> 00:14:13.353 
服務器中的記錄版本信息 

00:14:14.688 --> 00:14:16.089 
在哪裏可以找到這些信息呢？

00:14:16.156 --> 00:14:18.859 
同樣地 你可以
在用戶錯誤字典中找到它 

00:14:19.126 --> 00:14:21.361 
在本例中其值是
CKRecordchanged

00:14:21.428 --> 00:14:23.297 
errorServer
RecordKey鍵值 

00:14:23.363 --> 00:14:24.965 
在本例中 當我們將它

00:14:25.032 --> 00:14:27.234 
用戶錯誤信息字典中提取出來時 

00:14:27.434 --> 00:14:29.736 
我們會發現
服務器中的記錄

00:14:29.970 --> 00:14:33.340 
已經記錄John將會參加派對 
而且會發新的變更標記B 

00:14:35.342 --> 00:14:37.044 
現在 除了服務器記錄之外 

00:14:37.444 --> 00:14:40.147 
我們還會爲你返回
更多的信息 

00:14:42.349 --> 00:14:46.019 
這些包括在Alice對記錄
進行任何修改之前的

00:14:46.086 --> 00:14:49.423 
原始記錄鍵值 

00:14:50.824 --> 00:14:54.428 
以及客戶端記錄鍵值 
此鍵值包含

00:14:54.494 --> 00:14:56.296 
Alice嘗試保存到服務器的記錄 

00:14:59.733 --> 00:15:01.869 
現在 我想強調的是  

00:15:01.935 --> 00:15:05.439 
在大多數情況下
在解決衝突時

00:15:05.506 --> 00:15:07.441 
最重要的事情 
也是你需要做的事情是 

00:15:07.908 --> 00:15:10.511 
在發生錯誤之前 
及早保存你所做的修改 

00:15:10.577 --> 00:15:12.913 
而不是等待錯誤響消息

00:15:13.480 --> 00:15:16.650 
向你返回
服務器記錄 

00:15:18.185 --> 00:15:20.320 
在本例中 你獲取服務器記錄 

00:15:20.954 --> 00:15:23.624 
我們將對想要保存的
這條記錄進行相同的修改 

00:15:23.690 --> 00:15:26.760 
也就是把Alice作爲參加者

00:15:26.827 --> 00:15:29.329 
添加到派對 包括她和John

00:15:29.696 --> 00:15:31.265 
<br/>
並將這個記錄版本

00:15:31.331 --> 00:15:32.299 
保存到服務器 

00:15:34.401 --> 00:15:37.404 
你會發現
服務器中的變更標記爲B 

00:15:38.138 --> 00:15:40.641 
當我們保存記錄時 
這些變更標記將匹配 

00:15:40.707 --> 00:15:42.042 
服務器將接受保存操作 

00:15:45.612 --> 00:15:47.214 
在這裏 我們應該知道

00:15:47.281 --> 00:15:50.217 
如果我們爲這項功能
設計更好的schema,

00:15:50.417 --> 00:15:52.419 
我們可以避免這類錯誤 

00:15:53.620 --> 00:15:55.722 
稍後我將會討論schema 

00:15:58.425 --> 00:16:00.160 
你會發現 在嘗試修改相同記錄時 

00:16:00.227 --> 00:16:03.463 
每次不同的用戶都要進行這種修改 

00:16:03.530 --> 00:16:05.632 
這並不是最好的方法 

00:16:09.670 --> 00:16:11.271 
讓我們來瞭解一種新的schema 

00:16:11.538 --> 00:16:13.540 
讓我們來看
CloudKit操作 

00:16:14.975 --> 00:16:17.978 
我想爲APP添加一個新功能 

00:16:18.045 --> 00:16:20.681 
以允許用戶存儲派對照片 

00:16:22.015 --> 00:16:24.985 
這次 我們需要
在派對與照片之間

00:16:25.052 --> 00:16:26.186 
建立一對多的關係

00:16:26.587 --> 00:16:28.055 
照片將擁有
它們自己的記錄類型 

00:16:28.856 --> 00:16:31.692 
但是我們不想將它們
存儲到照片記錄 

00:16:31.992 --> 00:16:33.126 
我們應該怎麼做呢？

00:16:33.193 --> 00:16:37.564 
我們可以通過反向引用
照片所屬的派對

00:16:37.631 --> 00:16:39.666 
來保存照片記錄 

00:16:41.935 --> 00:16:42.870 
你可以看到

00:16:42.936 --> 00:16:45.405 
當我們保存照片記錄時 

00:16:45.939 --> 00:16:49.042 
不需要更改
照片所屬的派對記錄 

00:16:53.313 --> 00:16:55.349 
讓我們來瞭解
如何保存這些記錄 

00:16:58.185 --> 00:16:59.820 
在我們的APP中

00:16:59.887 --> 00:17:00.954 
<br/>
我們使用便利性API

00:17:01.021 --> 00:17:03.023 
利用完成處理操作保存記錄 

00:17:03.090 --> 00:17:05.125 
每次保存一個照片記錄 

00:17:06.660 --> 00:17:07.594 
但是

00:17:07.661 --> 00:17:10.731 
用戶可能一次存儲多張照片 

00:17:10.797 --> 00:17:12.398 
對於這種情況

00:17:12.465 --> 00:17:14.701 
目前我們
使用便利性API

00:17:14.835 --> 00:17:17.304 
通過不間斷循環
來保存多條記錄 

00:17:18.204 --> 00:17:21.141 
讓我們來看這些操作的

00:17:21.375 --> 00:17:22.542 
背後機制 

00:17:24.912 --> 00:17:28.015 
APP多次調用便利性API

00:17:28.080 --> 00:17:29.516 
來保存多張照片  

00:17:30.450 --> 00:17:33.320 
在系統中 
必須通過一組默認值  

00:17:33.487 --> 00:17:36.690 
將它們封裝在CK操作中

00:17:39.026 --> 00:17:43.030 
當我們嘗試將記錄
保存到服務器時  

00:17:43.163 --> 00:17:45.165 
這些操作中的每個操作
至少發出一次網絡請求 

00:17:46.099 --> 00:17:48.502 
我們不希望所有這些請求
導致服務器崩潰 

00:17:48.569 --> 00:17:52.072 
但是我們造成了系統瓶頸 

00:17:52.139 --> 00:17:55.375 
系統一次發送多個請求 

00:17:57.711 --> 00:17:59.079 
以保存這些記錄 

00:18:00.113 --> 00:18:02.516 
現在 除了這個瓶頸之外 

00:18:02.583 --> 00:18:05.285 
還需要考慮另外一件事情 

00:18:07.654 --> 00:18:11.558 
這些操作中的每個操作
都請求一次保存一條記錄 

00:18:11.625 --> 00:18:13.493 
在本例中 

00:18:13.861 --> 00:18:15.996 
將會產生大量的網絡請求 

00:18:16.063 --> 00:18:18.232 
從CloudKit APP開發人員
的角度來看 

00:18:19.233 --> 00:18:20.801 
這顯然不是一個好主意 

00:18:22.202 --> 00:18:24.905 
我們希望通過一次網絡請求

00:18:25.172 --> 00:18:28.275 
批處理這些記錄更新操作 
或者 至少應該

00:18:28.342 --> 00:18:29.743 
使用最少的網絡請求來處理它們 

00:18:30.010 --> 00:18:30.944 
我們應該怎麼做呢？

00:18:31.979 --> 00:18:36.383 
我們使用與便利性API

00:18:36.450 --> 00:18:37.618 
相對應的
CK操作 

00:18:38.886 --> 00:18:41.889 
幾乎每個一次處理一個項目的

00:18:41.955 --> 00:18:45.058 
便利性API都有對應的CK操作 

00:18:45.192 --> 00:18:46.793 
這些CK操作能夠批處理記錄更新 

00:18:47.427 --> 00:18:50.831 
在本例中 我們想要使用
CKModifyRecords操作

00:18:51.198 --> 00:18:53.634 
將多個記錄作爲一個數組
提供給記錄保存資產

00:18:54.735 --> 00:18:57.237 
以一次保存多個記錄 

00:18:58.505 --> 00:19:01.008 
讓我們來看此操作的背後原理 

00:19:01.508 --> 00:19:04.144 
現在我們可以將組合所有記錄

00:19:04.211 --> 00:19:05.846 
通過一次操作來保存它們 

00:19:08.448 --> 00:19:09.550 
此操作進入系統隊列 

00:19:09.616 --> 00:19:11.952 
系統能夠使用最少的請求數量 

00:19:12.019 --> 00:19:14.821 
保存這些記錄到服務器 

00:19:14.888 --> 00:19:17.858 
我們就消除了瓶頸 

00:19:19.393 --> 00:19:24.164 
同時 我們最大限度地

00:19:24.231 --> 00:19:25.165 
減少了請求數量 

00:19:26.500 --> 00:19:30.370 
我希望你們所有人
在你的APP中

00:19:30.437 --> 00:19:32.840 
使用便利性API時 
使用這項技術 

00:19:33.640 --> 00:19:36.443 
如果你考慮將它用於

00:19:36.510 --> 00:19:39.680 
在多個位置或同一個類型的循環中 
處理同一種類型的請求 

00:19:40.514 --> 00:19:43.083 
應考慮使用
CKOperation API

00:19:43.150 --> 00:19:44.852 
以批處理這些請求 

00:19:45.719 --> 00:19:47.487 
這將會減少請求數量 

00:19:47.554 --> 00:19:50.490 
同時提高系統的效率

00:19:52.759 --> 00:19:55.195 
好的 
現在我們來討論批處理 

00:19:57.197 --> 00:19:58.765 
這是我們需要考慮的

00:19:58.899 --> 00:19:59.833 
另外一件事情 

00:20:02.970 --> 00:20:05.772 
服務器限制
一次可以設置

00:20:05.839 --> 00:20:07.908 
的批處理數量 

00:20:10.177 --> 00:20:12.012 
這些限制包括

00:20:12.079 --> 00:20:14.181 
每個請求中的項目數量

00:20:15.916 --> 00:20:18.318 
和請求總數量 

00:20:18.519 --> 00:20:19.987 
請求總數量是

00:20:20.053 --> 00:20:22.356 
在隸屬於該請求的記錄中

00:20:22.422 --> 00:20:25.025 
設置的鍵值數據之和 

00:20:26.360 --> 00:20:28.495 
必須注意的一點是

00:20:28.562 --> 00:20:30.030 
<br/>
通過CKAsset API

00:20:30.097 --> 00:20:32.466 
作爲批量存儲的組成部分
存儲的數據量

00:20:32.533 --> 00:20:35.636 
並不會計入

00:20:35.702 --> 00:20:37.638 
這個鍵值數據 

00:20:40.307 --> 00:20:43.510 
但是 如果你的請求
想要繞過任何此類限制 

00:20:44.778 --> 00:20:45.879 
你將會收到一個名爲

00:20:45.946 --> 00:20:48.115 
CKErrorLimit
Exceeded的專用錯誤代碼 

00:20:49.316 --> 00:20:51.685 
對於這種錯誤的處理方法 

00:20:51.752 --> 00:20:54.621 
我們通常建議開發人員將
將項目對半拆拆分

00:20:54.688 --> 00:20:58.825 
成爲批處理 進行兩次操作
而不是一次操作 

00:21:00.093 --> 00:21:02.129 
如果再次遇到相同的錯誤 

00:21:02.196 --> 00:21:04.298 
則應該進行同樣的拆分 

00:21:06.366 --> 00:21:09.169 
如果僅有批處理中的部分項目
發生錯誤 應該怎麼辦呢？

00:21:10.871 --> 00:21:15.008 
由於批處理包括很多項目 

00:21:15.075 --> 00:21:18.445 
但是隻會返回一個錯誤 
但是我們仍然希望向你

00:21:18.512 --> 00:21:20.247 
告知其中每一項錯誤 

00:21:20.981 --> 00:21:21.915 
爲此

00:21:21.982 --> 00:21:23.584 
我們使用一個名爲

00:21:24.651 --> 00:21:26.553 
CKError partial 
failure的專用錯誤代碼 

00:21:28.155 --> 00:21:30.324 
這是一個頂層錯誤代碼

00:21:30.657 --> 00:21:32.459 
你並不希望直接處理它 

00:21:33.827 --> 00:21:34.661 
但是與前面一樣 

00:21:35.262 --> 00:21:37.030 
在用戶錯誤字典中 

00:21:37.097 --> 00:21:40.000 
如果你按項目ID鍵值查找 
CKPartial錯誤鍵值 

00:21:40.701 --> 00:21:41.702 
我們將會提供

00:21:41.768 --> 00:21:44.238 
與你的批處理錯誤相應對應的

00:21:44.304 --> 00:21:45.706 
項目ID字典 

00:21:47.274 --> 00:21:51.078 
例如 在本例中 
有一個項目ID 

00:21:51.144 --> 00:21:52.846 
發生CKRecord無效參數錯誤

00:21:53.213 --> 00:21:54.781 
另外 批處理中的其他項目

00:21:54.848 --> 00:21:56.416 
可能發生錯誤 
也可能沒有錯誤 

00:21:56.750 --> 00:21:59.987 
你需要打開這個字典 
在字典中進行查看 

00:22:00.053 --> 00:22:01.488 
單獨處理該錯誤 

00:22:03.757 --> 00:22:06.293 
如果考慮自定義區域中的原子更新
(atomic update) 

00:22:06.360 --> 00:22:09.530 
情況會略微發生變化 

00:22:11.665 --> 00:22:14.101 
需要注意的是 自定義區域

00:22:14.168 --> 00:22:17.704 
具有CKModify
記錄操作功能 

00:22:17.771 --> 00:22:19.039 
能夠發送原子更新 

00:22:19.106 --> 00:22:22.276 
在這種情況下 服務器將整個
批處理作爲一個操作予以接受 

00:22:22.342 --> 00:22:24.444 
或者拒絕整個批處理 

00:22:25.812 --> 00:22:28.448 
如果批處理中的一個項目

00:22:28.515 --> 00:22:31.051 
發生CKError無效參數錯誤
（與本例相同） 

00:22:31.118 --> 00:22:33.654 
其餘項目ID
將包含錯誤信息

00:22:34.021 --> 00:22:36.890 
和CKRecords批處理
請求失敗專用錯誤代碼 

00:22:38.091 --> 00:22:39.793 
在處理原子更新時 

00:22:39.860 --> 00:22:41.828 
必須檢索字典內容 

00:22:42.329 --> 00:22:43.764 
處理未包含在

00:22:43.830 --> 00:22:45.599 
批處理請求失敗中的所有錯誤

00:22:47.734 --> 00:22:51.705 
關於如何通過優化方式
將我們的照片記錄存儲到

00:22:51.772 --> 00:22:53.273 
Cloud服務器 
我們就講到這裏 

00:22:53.674 --> 00:22:55.876 
下面我們來討論另外一半

00:22:55.943 --> 00:22:57.544 
<br/>
即如何下載 

00:22:57.611 --> 00:23:00.113 
我們使用
CloudKit查詢來進行下載 

00:23:01.481 --> 00:23:03.150 
現在 
利用我們設計的schema  

00:23:03.217 --> 00:23:06.053 
下載特定派對的照片變得十分簡單 

00:23:06.119 --> 00:23:08.889 
在這種schema中 

00:23:08.956 --> 00:23:11.758 
照片記錄引用它們所屬的派對 

00:23:12.759 --> 00:23:15.562 
我們只需要創建一個CK查詢 

00:23:15.863 --> 00:23:17.497 
這個嘗試匹配將這個引用

00:23:17.698 --> 00:23:19.132 
與已知派對記錄ID進行匹配 

00:23:22.035 --> 00:23:25.072 
現在 如果我們發出查詢 
以下載一個派對的照片 

00:23:25.772 --> 00:23:27.741 
一些派對可能有大量的照片 

00:23:28.041 --> 00:23:29.877 
我們是否需要全部下載它們呢？

00:23:31.111 --> 00:23:35.115 
讓我們來看如何
使用CKQuery操作

00:23:35.182 --> 00:23:37.017 
發出特定派對照片

00:23:37.351 --> 00:23:38.952 
優化下載查詢 

00:23:42.589 --> 00:23:44.391 
首先需要解決的問題是：

00:23:44.691 --> 00:23:47.661 
我們並不知道有多少張照片
隸屬於一個特定的派對 

00:23:47.928 --> 00:23:49.296 
我們應該下載多少張照片呢？

00:23:50.163 --> 00:23:52.132 
下載全部照片並沒有意義 

00:23:53.267 --> 00:23:55.469 
對於我們的UI來說 

00:23:55.536 --> 00:23:57.304 
應該回答這個問題 

00:23:58.238 --> 00:24:00.274 
如果你看一下
我們這裏的示例UI 

00:24:00.541 --> 00:24:03.443 
你可以看到 當我們調出
一個特定的派對時 

00:24:03.677 --> 00:24:06.380 
我們看到20張照片 

00:24:07.648 --> 00:24:09.449 
正確的做法是 

00:24:09.516 --> 00:24:11.718 
當我們首次發出查詢時 

00:24:12.052 --> 00:24:14.221 
查詢應僅返回20張照片給我們

00:24:15.189 --> 00:24:18.358 
我們可以使用
CKQuery操作的結果限值屬性

00:24:18.525 --> 00:24:19.726 
來做到這一點 

00:24:21.295 --> 00:24:25.098 
當你不知道總共會
返回多少個項目時  

00:24:26.300 --> 00:24:28.368 
這個屬性能夠幫助你

00:24:28.435 --> 00:24:31.738 
管理特定批處理中
的項目數量 

00:24:33.774 --> 00:24:35.676 
因此 這個屬性也可以用於

00:24:35.742 --> 00:24:37.544 
CKFetch記錄變更操作 

00:24:38.045 --> 00:24:39.980 
此操作可能會返回大量的變更 

00:24:40.047 --> 00:24:42.516 
而你並不知道自定義區域

00:24:43.851 --> 00:24:46.086 
和CKFetch通知變更操作
會返回多少個變更 

00:24:46.153 --> 00:24:47.588 
其原因與前面一樣 

00:24:50.357 --> 00:24:52.526 
好的 
現在我們只想下載20個記錄 

00:24:52.993 --> 00:24:53.894 
這樣更簡單一些 

00:24:54.494 --> 00:24:55.996 
但是 我們可以做得更好嗎嗎？

00:24:56.763 --> 00:24:58.465 
讓我們來看我們的下載 

00:24:59.266 --> 00:25:02.069 
我們再次來讓UI
爲我們回答這個問題

00:25:02.236 --> 00:25:04.605 
當我們查看一個特定派對時 

00:25:04.671 --> 00:25:07.774 
我們看到的是
特定派對的經過裁剪和

00:25:07.841 --> 00:25:09.810 
縮小的縮略圖

00:25:12.613 --> 00:25:14.882 
但是我們存儲在照片記錄上

00:25:15.115 --> 00:25:17.985 
而且默認情況下將會完全下載的

00:25:18.051 --> 00:25:22.256 
可能是我們使用iOS設備

00:25:23.457 --> 00:25:25.459 
高畫質相機拍攝的

00:25:25.526 --> 00:25:26.593 
照片的高分辨率版本 

00:25:27.794 --> 00:25:30.898 
如果我們能夠將該信息添加到

00:25:30.964 --> 00:25:33.667 
我們的照片記錄

00:25:34.635 --> 00:25:37.738 
讓我們能夠調出部分記錄 
將會很有幫助作用 

00:25:38.605 --> 00:25:40.107 
但是 我們如何
調出部分記錄呢嗎？

00:25:41.008 --> 00:25:42.476 
我們通過對CKQuery操作

00:25:42.543 --> 00:25:45.179 
使用desiredKeys屬性
來完成此任務 

00:25:46.313 --> 00:25:47.814 
在本例中

00:25:47.881 --> 00:25:50.684 
desiredKeys屬性
接收一個鍵值屬性數組 

00:25:50.751 --> 00:25:52.953 
這些鍵值是符合查詢條件的

00:25:53.020 --> 00:25:53.854 
所有記錄的鍵值 

00:25:55.122 --> 00:25:57.291 
因此 如果我們將它設置爲
thumbnail 

00:25:57.357 --> 00:26:00.327 
你可以看到 當查詢返回時 

00:26:00.394 --> 00:26:02.896 
載入的數據量大幅減少了 

00:26:06.066 --> 00:26:08.936 
這也可以用於
CKFetchRecords操作 

00:26:09.536 --> 00:26:13.440 
在這種操作 你可能已經提前
知道你想要獲取記錄的ID 

00:26:14.007 --> 00:26:15.042 
但是你的UI

00:26:15.108 --> 00:26:17.277 
或者因其他原因 
你只想要

00:26:17.678 --> 00:26:19.246 
下載部分記錄 

00:26:21.882 --> 00:26:24.251 
另外 也可以用於CKFetch
記錄變更操作 

00:26:24.384 --> 00:26:27.387 
默認情況下 此操作下載
任何已經變更的記錄的

00:26:27.788 --> 00:26:29.356 
全部記錄內容 

00:26:31.925 --> 00:26:35.028 
現在 如果我們只想顯示
20張照片 當我們首次向用戶

00:26:35.095 --> 00:26:38.165 
顯示這些照片時 

00:26:38.232 --> 00:26:39.800 
照片應該以特定的順序顯示 

00:26:40.400 --> 00:26:43.203 
假設我們想要按照

00:26:43.270 --> 00:26:45.439 
照片在iCloud上的存儲順序

00:26:45.506 --> 00:26:48.075 
顯示這些照片 

00:26:50.711 --> 00:26:54.615 
我們可以對CKQuery
設置sortDescriptor 

00:26:54.681 --> 00:26:56.984 
並使用這些描述符
初始化CKQuery操作 

00:26:58.752 --> 00:27:01.822 
你可以看到 在這裏
我們將sortDescriptor

00:27:01.889 --> 00:27:04.958 
設置爲創建日期鍵值 
這是一個系統字段 

00:27:05.092 --> 00:27:07.961 
保存在服務器上的所有
CKRecord都有這個字段 

00:27:09.930 --> 00:27:11.098 
我們將它設置爲降序 

00:27:14.735 --> 00:27:17.638 
在這裏 需要注意的是 
由於它是一個系統字段 

00:27:17.905 --> 00:27:21.108 
因此你需要可以在服務器上
使用此字段進行排序 

00:27:21.642 --> 00:27:24.745 
你可以通過iCloud 
Dashboard進行此設置 

00:27:25.612 --> 00:27:26.580 
應該在保存記錄之前

00:27:26.647 --> 00:27:29.416 
進行此項設置 

00:27:29.917 --> 00:27:34.855 
否則 在設置之前
保存的記錄

00:27:34.922 --> 00:27:36.123 
將不會有此項索引值 

00:27:38.292 --> 00:27:41.128 
我們想要獲取所有記錄中的
小部分記錄 

00:27:41.195 --> 00:27:43.897 
你可能會想 

00:27:43.964 --> 00:27:45.532 
如何向用戶顯示其餘記錄？

00:27:45.799 --> 00:27:48.435 
假設用戶開始向下滾動 

00:27:48.502 --> 00:27:49.770 
想要查看下一批照片 

00:27:52.206 --> 00:27:55.209 
在這種情況下 
我們如何實現分頁顯示？

00:27:55.676 --> 00:27:58.679 
我們通過分析查詢處理語句
返回的結果

00:27:58.745 --> 00:27:59.980 
來處理這個問題 

00:28:01.315 --> 00:28:04.918 
當查詢完成時 

00:28:04.985 --> 00:28:06.954 
我們不僅獲得
查詢返回的所有結果 

00:28:07.254 --> 00:28:09.056 
還獲得一個
CKQueryCursor 

00:28:10.591 --> 00:28:14.027 
這是一個不透明的標記符 

00:28:14.094 --> 00:28:18.198 
顯示你在整個查詢結果中
所處的位置 

00:28:18.932 --> 00:28:20.968 
因此你應該存儲

00:28:21.034 --> 00:28:23.437 
首次查詢操作返回給你的
QueryCursor

00:28:25.005 --> 00:28:26.907 
當你想要

00:28:26.974 --> 00:28:28.509 
獲取下一批結果時 

00:28:28.942 --> 00:28:32.479 
你可以始使用先前存儲的
Cursor初始值 

00:28:32.546 --> 00:28:34.648 
傳遞這個值 來初始化

00:28:34.948 --> 00:28:37.217 
另一個CKQuery操作 

00:28:39.753 --> 00:28:43.323 
當我們通過這種方式
優化CKQuery操作時 

00:28:43.390 --> 00:28:47.160 
應確保對新查詢操作
設置相同的必要鍵值 

00:28:47.227 --> 00:28:49.963 
和結果返回數量限值 

00:28:50.964 --> 00:28:54.268 
這將優化下一批照片
查詢結果 

00:28:57.271 --> 00:28:59.706 
關於下載記錄就是這些 

00:29:01.074 --> 00:29:02.910 
現在我想要切換主題 

00:29:02.976 --> 00:29:06.914 
介紹一些在使用CloudKit時

00:29:07.014 --> 00:29:10.250 
維護本地緩存方面的技術 

00:29:10.317 --> 00:29:12.719 
讓我們首先來討論一項新功能 

00:29:15.189 --> 00:29:17.257 
假設我們希望
用戶能夠爲派對添加一些

00:29:17.324 --> 00:29:20.427 
簡短的個人評論 

00:29:22.462 --> 00:29:24.331 
假設這些評論是個人化的 

00:29:24.932 --> 00:29:27.167 
我們想要將它存儲到
用戶的私人數據庫之中 

00:29:30.604 --> 00:29:33.540 
我們不想要在用戶每次查看
或修改這些評論時 

00:29:33.607 --> 00:29:35.709 
獲取這些評論 

00:29:36.443 --> 00:29:37.945 
我們希望提供

00:29:38.011 --> 00:29:39.780 
提供某種離線訪問功能 

00:29:42.249 --> 00:29:45.953 
你可以看到 在這種情況下 

00:29:46.386 --> 00:29:50.057 
我們需要的是
在特定的設備用戶上

00:29:50.123 --> 00:29:51.592 
提供少量的數據 

00:29:52.926 --> 00:29:55.963 
在這情況下使用CloudKit時 

00:29:56.630 --> 00:29:58.298 
維護本地緩存是不錯的做法  

00:30:00.434 --> 00:30:03.270 
讓我們先來看
如何從私人數據庫

00:30:03.337 --> 00:30:04.404 
下載內容 

00:30:05.572 --> 00:30:09.343 
前面講過 我們能夠將記錄
存儲到私人數據庫中的

00:30:09.409 --> 00:30:11.879 
自定義區域
 此區域爲我們提供一些附加功能

00:30:13.080 --> 00:30:14.848 
讓我們來進行這些操作 

00:30:15.382 --> 00:30:18.685 
我們在私人數據庫中
創建一個新區域 

00:30:19.920 --> 00:30:21.788 
其名稱爲NotesZone 

00:30:22.089 --> 00:30:24.324 
我們可以通過兩種方法 
獲取此區域中的數據 

00:30:26.126 --> 00:30:28.862 
與前面一樣 我們可以
使用CKQuery操作 

00:30:29.162 --> 00:30:31.131 
並對它進行優化 
方法與前面一樣 

00:30:32.533 --> 00:30:36.570 
我們還可以通過
CKRecordsFetch操作

00:30:36.670 --> 00:30:41.175 
使用delta下載 讓我們僅獲取

00:30:41.241 --> 00:30:42.543 
區域中僅發生變更的記錄 

00:30:43.076 --> 00:30:48.215 
我們說過 此操作只適於

00:30:48.282 --> 00:30:50.050 
具有獲取變更功能的區域

00:30:50.551 --> 00:30:52.152 
目前 私人數據庫中的
所有自定義區域

00:30:52.219 --> 00:30:54.421 
都具有此功能 

00:30:55.923 --> 00:30:57.191 
如果你想要更詳細地

00:30:57.257 --> 00:30:59.993 
瞭解delta下載的工作原理 

00:31:00.060 --> 00:31:01.128 
我建議你

00:31:01.195 --> 00:31:02.896 
回顧去年的
高級CloudKit講座 

00:31:03.230 --> 00:31:06.600 
這個講座詳細地介紹
這種操作是如何工作的 

00:31:09.369 --> 00:31:10.737 
假設我們想要使用這項功能 

00:31:11.238 --> 00:31:12.773 
我們開始獲取變更記錄 

00:31:13.140 --> 00:31:16.677 
我們將APP對象存儲在

00:31:16.743 --> 00:31:18.478 
一個本地數據庫之中 
它可能是核心數據 

00:31:18.679 --> 00:31:20.247 
或你選擇的其它數據庫 

00:31:21.815 --> 00:31:24.284 
在這個位置
我們編碼APP對象 

00:31:25.953 --> 00:31:28.222 
這裏有一個party對象 

00:31:28.422 --> 00:31:31.959 
我們爲它添加了
一個notes鍵值

00:31:32.092 --> 00:31:34.094 
對應於用戶爲這個派對
添加的評論 

00:31:34.895 --> 00:31:39.199 
我們將APP編碼到
本地存儲 

00:31:39.266 --> 00:31:42.169 
當處理相應的CKRecords時 

00:31:42.669 --> 00:31:44.738 
我們想要將記錄
存儲在Cloud之中 

00:31:46.907 --> 00:31:50.611 
我們可能考慮
編碼整個CKRecord 

00:31:51.879 --> 00:31:55.782 
因此我們緩存這些記錄
和我們的APP對象 

00:31:56.183 --> 00:31:57.651 
讓我們來看會發生什麼 

00:31:58.051 --> 00:32:00.721 
你可以看到 
CKRecord還具有爲其設置的

00:32:00.787 --> 00:32:02.356 
所有APP對象鍵值 

00:32:02.689 --> 00:32:04.358 
當然 在我們編碼時

00:32:04.424 --> 00:32:06.527 
我們會複製所有的APP鍵值 

00:32:07.928 --> 00:32:09.897 
當我們編碼APP對象之後 

00:32:09.963 --> 00:32:11.565 
以及當我們編碼
CKRecord時 

00:32:12.266 --> 00:32:13.734 
這就是我們想要的 

00:32:16.003 --> 00:32:18.138 
你看到 CKRecord對象中的
橙色字段

00:32:18.205 --> 00:32:19.673 
屬於CKRecord 

00:32:19.973 --> 00:32:22.409 
服務器通過這些字段

00:32:22.476 --> 00:32:26.780 
來識別記錄的特定版本 

00:32:27.014 --> 00:32:28.549 
它們稱爲系統字段 

00:32:29.850 --> 00:32:32.119 
在本例中 你真正的想要是的

00:32:32.186 --> 00:32:35.189 
記錄的系統字段的編碼方法 

00:32:36.089 --> 00:32:39.126 
你可以使用編碼系統字段和

00:32:39.193 --> 00:32:41.328 
編碼器API對
CKRecord進行編碼 

00:32:42.896 --> 00:32:45.465 
你需要使用這些代碼

00:32:45.532 --> 00:32:46.867 
對這些系統字段進行編碼 

00:32:47.134 --> 00:32:50.337 
我們強烈建議你使用這種方法 

00:32:50.404 --> 00:32:52.773 
如果遇到這樣的情況 
你需要回顧以往的講座 

00:32:55.008 --> 00:32:58.412 
現在讓我們來看當我們開始
編碼系統字段時將會發生什麼 

00:32:59.680 --> 00:33:02.583 
我們想要高效地存儲

00:33:02.649 --> 00:33:05.385 
CKRecord的重要信息和
相應的party對象 

00:33:08.121 --> 00:33:11.091 
現在 讓我們來看 
嘗試修改一個party對象時  

00:33:11.291 --> 00:33:13.160 
將會發生什麼 

00:33:13.560 --> 00:33:16.196 
我們已經使用前面所述的方法
存儲這個對象的系統字段 

00:33:18.432 --> 00:33:22.669 
爲此 我們使用CKRecord的
編碼器初始化函數 

00:33:27.140 --> 00:33:28.575 
你可以看到 當我們調用它時 

00:33:29.443 --> 00:33:34.648 
我們獲得先前存儲的
所有系統字段 

00:33:34.715 --> 00:33:37.317 
爲了簡潔起見 我僅顯示
記錄ID和我們已經看到的

00:33:37.651 --> 00:33:38.585 
變更標記 

00:33:40.420 --> 00:33:44.324 
對於這個CKRecord 
你完全可以設置

00:33:44.391 --> 00:33:48.762 
此記錄發生變更的鍵值 

00:33:49.162 --> 00:33:50.831 
比如說 我們想要變更派對名稱 

00:33:51.698 --> 00:33:54.935 
將派對名稱更改爲
WWDC bash 

00:33:55.169 --> 00:33:57.171 
我們爲這個鍵值設置爲新的值 

00:33:57.538 --> 00:33:59.006 
並在服務器上保存新記錄 

00:34:01.875 --> 00:34:05.612 
必須指出的是 
當存儲記錄的變更值時  

00:34:05.679 --> 00:34:07.848 
你不必設置記錄的

00:34:08.047 --> 00:34:10.117 
所有鍵值 

00:34:12.553 --> 00:34:15.155 
我們正式地維護和存儲

00:34:15.222 --> 00:34:19.525 
本地緩存 讓我們來看
如何從自定義區域

00:34:19.592 --> 00:34:22.862 
獲取變更值 
以使緩存保持爲最新 

00:34:24.197 --> 00:34:27.100 
與前面一樣 我們使用

00:34:27.167 --> 00:34:29.469 
CKFetchRecord
Changes操作

00:34:29.536 --> 00:34:31.205 
來完成這個任務 

00:34:31.271 --> 00:34:33.206 
此操作提供區域中
所有已經發生變更的記錄 

00:34:33.774 --> 00:34:36.944 
真正的問題是 
應該在何時使用此操作？

00:34:37.578 --> 00:34:40.514 
因爲 單獨使用此操作
並不會告訴我們 

00:34:40.647 --> 00:34:42.482 
存儲區域在何時已經發生變更 

00:34:43.016 --> 00:34:44.384 
爲此 我們需要

00:34:44.451 --> 00:34:47.387 
通過CKSubscription 
API來使用通知 

00:34:49.690 --> 00:34:52.525 
更具體地說 
由於區域中的變更

00:34:52.592 --> 00:34:56.429 
並不是你想通知給用戶的變更 

00:34:56.864 --> 00:34:59.566 
因此在這裏我們應該
使用靜默通知 

00:35:01.735 --> 00:35:06.406 
在下一節中 我將介紹

00:35:06.473 --> 00:35:09.343 
始何啓用並運行訂閱 

00:35:09.409 --> 00:35:11.645 
尤其是當你想要
使用靜默訂閱時 

00:35:12.446 --> 00:35:14.448 
讓我們簡要回顧

00:35:15.148 --> 00:35:16.350 
什麼是訂閱?

00:35:17.484 --> 00:35:19.286 
訂閱內容是根據

00:35:19.353 --> 00:35:21.555 
用戶存儲在服務器上的
定期內容查詢請求而提供的

00:35:23.490 --> 00:35:26.026 
你或你的APP通過這種方法

00:35:26.159 --> 00:35:29.463 
接收相關內容變更遠程通知 

00:35:30.497 --> 00:35:33.200 
有兩種類型的訂閱 
它們的不同之處在於

00:35:33.267 --> 00:35:36.570 
你如何定義哪些變更
是你需要關注的

00:35:38.639 --> 00:35:41.275 
第一種是查詢訂閱

00:35:41.708 --> 00:35:43.210 
允許你存儲
一個預設條件 

00:35:44.011 --> 00:35:46.413 
如果變更符合預設條件時 

00:35:46.613 --> 00:35:47.681 
就是你所需要的變更 

00:35:48.982 --> 00:35:51.285 
第二種是區域訂閱 
在這種方法中 

00:35:51.351 --> 00:35:53.253 
區域中的每次記錄修改

00:35:53.320 --> 00:35:55.622 
都被計爲一個相關變更 

00:35:58.358 --> 00:36:01.428 
因此 很明顯 在本例中 
我們需要靜默通知 

00:36:02.529 --> 00:36:05.699 
當我們的區域發生變更時 
將會發送此通知 

00:36:07.501 --> 00:36:10.737 
但是 我們首先需要了解
當你處理各種CloudKit訂閱時

00:36:11.071 --> 00:36:13.340 
所需要的常規設置 

00:36:14.675 --> 00:36:16.977 
對這個設置 我想強調的是 

00:36:17.144 --> 00:36:22.149 
如果遠程通知
並非來自於CloudKit. 

00:36:22.216 --> 00:36:24.084 
你仍然需要

00:36:24.251 --> 00:36:26.386 
設置遠程通知 

00:36:27.554 --> 00:36:28.722 
讓我來闡明其含義 

00:36:29.256 --> 00:36:31.892 
首先 你仍然需要
在開發者門戶中 

00:36:31.959 --> 00:36:34.595 
爲這個APP ID 
開啓APS功能 

00:36:35.262 --> 00:36:38.165 
當你開啓CloudKit功能時 

00:36:38.232 --> 00:36:39.566 
將會自動爲你開啓此功能 

00:36:41.368 --> 00:36:44.771 
第二 在測試你的APP
而且預計會收到遠程通知時  

00:36:44.838 --> 00:36:47.641 
你需要在你的APP中
將APS環境鍵值

00:36:47.708 --> 00:36:49.276 
設置到P列表之中
以用於開發工作 

00:36:51.778 --> 00:36:52.880 
第三 你仍然需要

00:36:52.946 --> 00:36:55.782 
通過UI應用API
進行註冊 

00:36:56.650 --> 00:36:58.886 
如果你計劃在你的App中
顯示用戶通知

00:36:58.952 --> 00:37:02.890 
至少 你需要調用
遠程通知註冊  

00:37:03.023 --> 00:37:05.692 
並且提醒用戶 

00:37:05.759 --> 00:37:08.328 
註冊用戶通知設置

00:37:11.198 --> 00:37:14.134 
由於我們需要靜默通知 

00:37:14.501 --> 00:37:16.103 
而且會通過
CloudKit服務器

00:37:16.170 --> 00:37:19.273 
向我們發送通知 
我們應該如何告訴服務器 

00:37:19.973 --> 00:37:21.642 
此通知應該是靜默通知呢？

00:37:22.743 --> 00:37:26.346 
我們通過與CK訂閱相對應的

00:37:26.413 --> 00:37:28.815 
CKNotification信息
來完成這個任務 

00:37:28.882 --> 00:37:30.150 
我們將它作爲入口點

00:37:30.417 --> 00:37:32.819 
告訴CloudKit服務器
應該發送哪種類型的

00:37:32.886 --> 00:37:36.156 
推送內容和以哪種優先級
進行發送 

00:37:36.523 --> 00:37:37.724 
讓我們來說說優先級 

00:37:39.960 --> 00:37:44.431 
如前所述 我們配置
CKNotification信息 

00:37:44.531 --> 00:37:45.933 
以告訴CloudKit服務器

00:37:46.166 --> 00:37:48.635 
這是一個靜默通知 

00:37:48.702 --> 00:37:49.837 
它需要以低優先級發送 

00:37:51.772 --> 00:37:53.574 
如果你爲
CKNotification

00:37:53.640 --> 00:37:55.108 
信息設置這些鍵值 

00:37:55.175 --> 00:37:57.411 
服務器將爲你發送
高優先級推送內容 

00:37:57.811 --> 00:38:02.149 
無論它是提醒正文 
徽標或聲音名稱 

00:38:03.584 --> 00:38:06.320 
我們將它們稱爲訂閱
使用的UI鍵值 

00:38:06.420 --> 00:38:07.754 
如果你發送其中任何一項 

00:38:08.188 --> 00:38:10.657 
服務器將發送
高優先級推送內容 

00:38:10.724 --> 00:38:12.159 
這意味着 需要立即發送 

00:38:14.027 --> 00:38:17.664 
所有其他推送內容
將會以中優先級發送 

00:38:17.731 --> 00:38:19.032 
並計入靜默通知數量 

00:38:21.435 --> 00:38:23.904 
讓我們來看你需要

00:38:23.971 --> 00:38:26.206 
什麼樣的靜默通知設置 

00:38:29.309 --> 00:38:30.711 
首先 你需要爲你的APP

00:38:30.777 --> 00:38:33.614 
開啓遠程通知後臺模式 

00:38:34.281 --> 00:38:36.884 
你可以通過
Xcode中的功能窗格來啓用它 

00:38:37.951 --> 00:38:39.653 
你應該記得選中該選項 

00:38:42.055 --> 00:38:43.690 
第二 你應該確保

00:38:43.757 --> 00:38:45.692 
你實現的APP

00:38:45.759 --> 00:38:47.361 
接收遠程通知 

00:38:47.694 --> 00:38:49.596 
獲取應用委派的API

00:38:49.663 --> 00:38:51.031 
完成處理通知

00:38:52.699 --> 00:38:55.636 
將會在後臺調用其他版本 

00:38:55.702 --> 00:38:58.405 
在計劃使用靜默通知時 

00:38:58.472 --> 00:38:59.973 
請確保已經實現這個版本 

00:39:03.210 --> 00:39:06.313 
第三 我們需要再一次
告訴CloudKit服務器 

00:39:06.380 --> 00:39:08.248 
通知是靜默推送通知 

00:39:08.715 --> 00:39:11.118 
我們如何配置CK
Notification信息呢？

00:39:12.953 --> 00:39:14.388 
首先也是最重要的 

00:39:14.454 --> 00:39:15.289 
你應該將

00:39:15.355 --> 00:39:17.224 
shouldSendContent
Availablent屬性

00:39:17.291 --> 00:39:18.458 
設置爲true.

00:39:18.792 --> 00:39:21.094 
這個屬性告訴
CloudKit服務器 

00:39:21.161 --> 00:39:22.629 
在你的推送內容中 
應該包含

00:39:22.696 --> 00:39:23.564 
可用內容鍵值 

00:39:26.066 --> 00:39:29.703 
其次 你應該爲C
Notification信息

00:39:29.770 --> 00:39:32.806 
設置我們前面所述的UI鍵值 

00:39:33.507 --> 00:39:35.309 
目前並不支持
同時設置這些屬性和

00:39:35.375 --> 00:39:38.278 
shouldSendContent
Available屬性 

00:39:38.345 --> 00:39:40.714 
這將會導致服務器錯誤 

00:39:44.318 --> 00:39:46.553 
現在 讓我們探討
靜默推送內容送達 

00:39:46.620 --> 00:39:49.189 
我們已經配置
與推送相關的所有設置 

00:39:49.556 --> 00:39:51.959 
我們將於何時獲得推送內容呢？

00:39:52.292 --> 00:39:55.529 
由於這些通知的目的
並不是爲了提醒用戶 

00:39:55.596 --> 00:39:58.765 
因此係統將會在適當的時機

00:39:58.832 --> 00:40:00.334 
發送這些通知 

00:40:00.834 --> 00:40:03.737 
在決定何時發送這些通知時  

00:40:03.804 --> 00:40:04.905 
系統將會考慮各種因素 

00:40:07.875 --> 00:40:10.544 
通常來說 推送是盡力而爲的 

00:40:11.645 --> 00:40:14.348 
也就是說 推送可能會被合併

00:40:14.648 --> 00:40:17.284 
甚至被丟棄 
具體視設備狀況而定 

00:40:17.951 --> 00:40:21.355 
例如 如果在需要接收緊急通知時  

00:40:21.421 --> 00:40:24.658 
設備處於飛行模式 
當設備退出飛行模式時 

00:40:24.725 --> 00:40:27.494 
Apple推送通知服務器
僅會向設備發送

00:40:27.561 --> 00:40:29.796 
確實需要接收的
最後一條推送通知 

00:40:31.832 --> 00:40:34.067 
現在 我們有辦法
來解決這個問題 

00:40:34.134 --> 00:40:36.470 
因爲我們可以
使用CloudKit通知 

00:40:37.471 --> 00:40:38.772 
具體來說

00:40:39.273 --> 00:40:42.576 
CloudKit服務器
存儲需要發送到你的設備的

00:40:42.643 --> 00:40:44.645 
所有通知 

00:40:44.745 --> 00:40:46.847 
我們將它稱爲通知集合 

00:40:48.382 --> 00:40:50.851 
因此當你接收靜默通知時 

00:40:51.084 --> 00:40:53.720 
應該確保從這個通知集合中

00:40:53.787 --> 00:40:55.222 
獲取變更通知 

00:40:55.322 --> 00:40:56.523 
你可以通過CK

00:40:56.590 --> 00:40:59.493 
FetchNotification
Changes操作來完成 

00:41:01.528 --> 00:41:04.565 
因此 當我們獲取靜默通知時 
我們檢查

00:41:04.665 --> 00:41:06.400 
是否有任何丟失的通知 

00:41:07.134 --> 00:41:09.036 
而且我們知道
我們的區域已經發生變更 

00:41:09.102 --> 00:41:11.572 
這也是我們獲得通知的原因 

00:41:12.339 --> 00:41:13.574 
在這種情況下 我們使用

00:41:13.640 --> 00:41:15.876 
CKFetchRecord
Changes操作

00:41:15.943 --> 00:41:17.578 
來查看我們的區域內
發生了哪些變更 

00:41:20.314 --> 00:41:22.382 
和前面討論的一樣 

00:41:22.449 --> 00:41:24.918 
我們並不知道區域內
發生了多少變更 

00:41:25.919 --> 00:41:28.055 
因此這可能一個
長時間運行的操作 

00:41:28.388 --> 00:41:31.191 
如果操作需要較長的時間來完成 

00:41:31.692 --> 00:41:32.759 
我建議你考慮使用

00:41:32.826 --> 00:41:35.429 
針對UI應用的後臺任務API 

00:41:37.264 --> 00:41:39.399 
這將允許你分配更多的時間

00:41:39.466 --> 00:41:41.735 
給你的操作 直到操作完成 

00:41:44.137 --> 00:41:46.340 
現在 在我們開始討論通知之前 
我需要告訴你們 

00:41:46.940 --> 00:41:50.544 
在iOS 8中 我們引入了
一個全新的通知類別 

00:41:50.811 --> 00:41:53.413 
稱爲交互式通知 

00:41:53.647 --> 00:41:57.684 
它允許用戶在信息條 

00:41:57.784 --> 00:41:59.620 
提醒界面或通知中心
處理推送通知 

00:42:01.455 --> 00:42:03.724 
利用CloudKit 你可以
將大量的請求

00:42:03.790 --> 00:42:06.193 
配置爲交互式通知 

00:42:06.727 --> 00:42:09.229 
我很高興地告訴你們 
在iOS 9中你只需要很少的設置 

00:42:09.296 --> 00:42:10.964 
就可以完成此操作 

00:42:11.431 --> 00:42:14.001 
同樣地如果CK
Notification信息

00:42:14.067 --> 00:42:15.302 
設置新的類型屬性 

00:42:15.369 --> 00:42:17.237 
當註冊用戶通知設置時  

00:42:18.672 --> 00:42:21.441 
這個屬性將對應於

00:42:21.942 --> 00:42:23.343 
你使用UIMutable

00:42:23.410 --> 00:42:26.580 
Notification
Categories註冊的標識符

00:42:27.481 --> 00:42:28.949 
只需要進行這些設置 

00:42:29.016 --> 00:42:31.685 
就可以通過
CloudKit運行交互式通知 

00:42:39.193 --> 00:42:40.027 
<br/> 
謝謝 

00:42:40.594 --> 00:42:43.463 
結合這些功能 我想介紹一些

00:42:43.530 --> 00:42:46.099 
你應該掌握的一些常用性能技術 

00:42:46.200 --> 00:42:49.102 
在使用CloudKit
開發APP時 

00:42:49.303 --> 00:42:50.571 
你應該使用這些技術 

00:42:52.339 --> 00:42:55.209 
CloudKit是高度異步API 

00:42:56.977 --> 00:43:00.380 
大多操作在網絡上進行 
你經常會遇到

00:43:00.447 --> 00:43:03.750 
許多具有依賴關係的任務 

00:43:04.318 --> 00:43:07.221 
而且你需要保持
特定的任務完成順序 

00:43:09.756 --> 00:43:15.062 
當針對這些任務實施任務管理時 

00:43:15.362 --> 00:43:18.732 
需要實現一些目標 

00:43:18.799 --> 00:43:20.400 
你們需要記住一些重要的目標 

00:43:22.069 --> 00:43:23.971 
首先 很明顯 

00:43:24.271 --> 00:43:27.474 
無論你使用什麼樣的技術 
你都需要

00:43:27.541 --> 00:43:29.643 
爲每個CloudKit任務

00:43:29.710 --> 00:43:31.712 
實施良好的錯誤處理方法 

00:43:33.447 --> 00:43:35.916 
其次 由於這些操作
是異步操作 

00:43:35.983 --> 00:43:38.485 
你應該確保
在任何情況下 

00:43:38.552 --> 00:43:39.853 
避免阻止主線程

00:43:40.287 --> 00:43:41.822 
和降低它們的UI性能 

00:43:44.358 --> 00:43:47.528 
最後但非不重要的是 
作爲開發人員 

00:43:47.928 --> 00:43:51.164 
你應該確保你的任務管理方案
能夠保持良好的代碼可維護性

00:43:51.231 --> 00:43:54.301 
當你爲APP添加新功能時 
代碼應該便於分析 

00:43:54.368 --> 00:43:56.970 
調試和擴展 

00:43:59.006 --> 00:44:01.308 
讓我們來看一些方法 

00:44:01.675 --> 00:44:03.110 
並且瞭解一些技巧和缺點 

00:44:05.913 --> 00:44:09.249 
第一點是不要嵌套
便利性API調用 

00:44:11.051 --> 00:44:14.154 
讓我們來看一個簡單的例子 

00:44:14.288 --> 00:44:17.090 
在前面所述的schema中 
如果我們想要修改

00:44:17.191 --> 00:44:20.294 
一個派對參加者記錄 
請不要在實際中編程中 

00:44:20.360 --> 00:44:21.461 
使用這個schema 

00:44:21.795 --> 00:44:24.264 
但是 當你使用便利性API時 

00:44:24.331 --> 00:44:27.034 
如果你想要修改派對參加者記錄 
你就必須這樣做 

00:44:27.401 --> 00:44:29.837 
你首先需要使用ID獲取記錄 

00:44:29.903 --> 00:44:31.038 
然後嘗試獲取

00:44:31.104 --> 00:44:33.173 
參加者想要參加的派對的記錄 

00:44:33.841 --> 00:44:36.844 
然後從參加者數組中

00:44:36.910 --> 00:44:41.448 
找到參加者記錄ID 
然後對參加者記錄進行修改 

00:44:41.515 --> 00:44:44.251 
然後嘗試保存記錄 

00:44:45.285 --> 00:44:48.155 
當需要修改一條具有很多
依存關係的字段的記錄時 

00:44:48.555 --> 00:44:50.090 
你必須執行這些操作 

00:44:50.290 --> 00:44:52.359 
你會看到一大堆

00:44:54.895 --> 00:44:58.565 
雜亂無章的代碼 

00:44:58.632 --> 00:45:02.236 
你不知道在哪裏處理哪些錯誤 

00:45:02.669 --> 00:45:05.105 
以及如何最合理地
重試這些操作 

00:45:06.106 --> 00:45:07.708 
除此之外 還需要

00:45:07.774 --> 00:45:10.177 
考慮另外一件事情 

00:45:11.378 --> 00:45:14.014 
假設用戶的某些APP操作

00:45:14.081 --> 00:45:16.283 
導致我們需要進行這些操作 

00:45:17.351 --> 00:45:20.387 
如果一個用戶後續操作

00:45:20.454 --> 00:45:22.923 
而導致不再需要這些任務 

00:45:23.223 --> 00:45:25.626 
由於這些任務已經進入隊列 

00:45:25.692 --> 00:45:26.693 
你將無法取消這些任務 

00:45:27.661 --> 00:45:30.163 
如果它們的運行時間很長 
當它們運行時 

00:45:30.230 --> 00:45:32.666 
你將無法進行其它操作 
你必須等待它們完成 

00:45:34.468 --> 00:45:36.570 
當你管理相關依賴的任務時 
尤其是在你需要

00:45:36.670 --> 00:45:39.540 
對批量記錄進行相同的修改時 

00:45:40.374 --> 00:45:43.510 
我們建議你不要使用這種方法  

00:45:45.679 --> 00:45:47.881 
另一種方法是
消除API的異步性質 

00:45:47.948 --> 00:45:50.717 
這可以使用信號燈

00:45:50.784 --> 00:45:52.786 
並且等待信號燈來實現 

00:45:54.521 --> 00:45:57.224 
在一些情況下 
這也會變得十分複雜 

00:45:57.925 --> 00:46:00.527 
你不應該嘗試這樣做 

00:46:00.827 --> 00:46:04.998 
如果你這樣做 你應該知道 

00:46:05.766 --> 00:46:08.769 
尤其是在你的長時間
等待操作完成時 

00:46:08.836 --> 00:46:10.838 
你很容易遇到

00:46:10.904 --> 00:46:12.606 
循環式的依賴關係 

00:46:12.673 --> 00:46:14.174 
而導致APP陷入死循環 

00:46:15.609 --> 00:46:19.213 
或者 如果你想對主線程
使用這種方法 

00:46:19.847 --> 00:46:23.116 
在網絡上等待被處理的操作

00:46:23.183 --> 00:46:25.352 
將會導致UI停止響應  

00:46:25.419 --> 00:46:26.820 
從而嚴重影響用戶體驗 

00:46:28.956 --> 00:46:30.057 
因此我們不建議這樣做 

00:46:33.927 --> 00:46:36.396 
我們建議你查看

00:46:36.463 --> 00:46:40.334 
NSOperation 提供的
依賴關係管理API 

00:46:41.902 --> 00:46:43.570 
就是這個API 

00:46:44.071 --> 00:46:46.840 
NSOperation
讓你能夠輕鬆添加

00:46:46.907 --> 00:46:49.343 
和消除其他NSOperations
之間的依賴關係 

00:46:50.544 --> 00:46:52.246 
讓我們來看如何使用

00:46:52.312 --> 00:46:53.547 
CKOperations
實現這一點 

00:46:53.614 --> 00:46:56.450 
CKOperations是
NSOperations的子類 

00:46:58.185 --> 00:47:01.154 
如果有兩個互相依賴的
獲取記錄操作 

00:47:01.722 --> 00:47:05.125 
而且第二個操作應該
在第一個操作完成之後開始 

00:47:05.192 --> 00:47:09.062 
你只需設置這兩個操作 

00:47:09.596 --> 00:47:13.267 
將第一個獲取操作設置爲
第二操作的先決條件 

00:47:13.333 --> 00:47:14.935 
然後將這兩個操作送入隊列 

00:47:15.936 --> 00:47:19.806 
這將保證
在第一個獲取操作完成之前 

00:47:20.140 --> 00:47:21.542 
第二個獲取操作不會啓動 

00:47:22.543 --> 00:47:25.512 
你會看到 
這提供一個符合邏輯的方法 

00:47:25.579 --> 00:47:27.915 
讓你能夠發現特定操作的錯誤 

00:47:28.248 --> 00:47:30.384 
並且能夠方便地

00:47:30.450 --> 00:47:32.252 
管理它們的依賴關係 

00:47:34.721 --> 00:47:37.357 
現在 當我們從性能的角度

00:47:37.424 --> 00:47:39.459 
考慮NSOperations時 

00:47:40.928 --> 00:47:43.997 
我希望你們思考

00:47:44.064 --> 00:47:45.365 
另外一個不同之處 

00:47:47.134 --> 00:47:49.336 
並非所有NSOperations
都是同等的 

00:47:49.903 --> 00:47:52.606 
有些NSOperations 
可能是因爲用戶在APP中的

00:47:52.673 --> 00:47:54.241 
顯式操作而產生的 

00:47:54.308 --> 00:47:56.543 
其他一些
NSOperations示操作

00:47:56.743 --> 00:47:58.312 
則可能是一些
低優先級的後臺任務 

00:47:59.379 --> 00:48:02.182 
爲了向系統告知

00:48:02.249 --> 00:48:04.351 
這些NSOperations
的相對重要性 

00:48:04.518 --> 00:48:07.154 
在iOS 8中 
我們爲NSOperations.

00:48:07.221 --> 00:48:09.656 
引入了服務質量屬性  

00:48:11.325 --> 00:48:14.862 
你可以用這個屬性
指定NSOperation封裝的

00:48:14.928 --> 00:48:17.598 
作業的性質和重要性 

00:48:19.032 --> 00:48:21.201 
可以將這個屬性

00:48:21.268 --> 00:48:24.605 
設置爲不同的服務質量級別 
我建議你們

00:48:24.671 --> 00:48:26.874 
查看相關文檔 
來瞭解各個服務質量等級

00:48:26.940 --> 00:48:28.675 
以及它們的重要性 

00:48:29.476 --> 00:48:32.012 
在這裏 需要記住的一點是 

00:48:32.079 --> 00:48:35.148 
這個服務質量值
直接影響NSOperation的

00:48:35.215 --> 00:48:38.952 
資源分配優先級 

00:48:39.353 --> 00:48:43.156 
例如CPU時間、
磁盤資源和網絡資源 

00:48:45.092 --> 00:48:47.794 
現在結合去年推出的CloudKit

00:48:47.861 --> 00:48:50.163 
<br/>
 我們想要爲你提供類似的方法  

00:48:50.230 --> 00:48:53.267 
讓你能夠將低優先級
CKOperations

00:48:53.467 --> 00:48:55.202 
優化成爲自主性網絡行爲 

00:48:56.570 --> 00:48:57.538 
我的意思是

00:48:57.604 --> 00:49:01.341 
優化非用戶發起的任務 

00:49:01.775 --> 00:49:04.344 
預取用戶內容 
就像我們在前面

00:49:04.411 --> 00:49:07.247 
使用CKRecords
獲取記錄變更操作

00:49:07.314 --> 00:49:09.383 
來響應靜默通知所作的那樣 

00:49:10.317 --> 00:49:13.153 
你需要將這些任務
優化成爲自主性行爲 

00:49:13.220 --> 00:49:16.356 
使系統在合適的時機

00:49:16.924 --> 00:49:18.625 
執行這些網絡請求 

00:49:19.760 --> 00:49:22.362 
在決定何時執行這些請求時 

00:49:22.596 --> 00:49:25.432 
系統會考慮很多因素 

00:49:26.133 --> 00:49:27.534 
例如蜂窩網絡連通性等 

00:49:27.935 --> 00:49:31.872 
系統可能會等待網絡
連通性改善之後 

00:49:31.939 --> 00:49:34.775 
再發送這些請求

00:49:35.375 --> 00:49:36.777 
另外還會考慮電量等 

00:49:37.277 --> 00:49:38.812 
如果用戶設備電量過低 

00:49:39.046 --> 00:49:41.882 
或者設備未在充電 
系統將會等待

00:49:41.949 --> 00:49:45.252 
電量增加之後 
再發送這些請求 

00:49:46.153 --> 00:49:47.154 
我們通過使用

00:49:47.221 --> 00:49:48.522 
CKOperations的

00:49:48.589 --> 00:49:51.491 
userBackground
Session屬性來實現這一點 

00:49:53.126 --> 00:49:55.529 
在iOS 9中

00:49:55.596 --> 00:49:57.364 
我們可以

00:49:57.564 --> 00:50:00.868 
極大地簡化和統一這些功能

00:50:00.934 --> 00:50:02.536 
這兩個概念

00:50:02.603 --> 00:50:06.340 
我們通過服務質量來
推測你的網絡行爲 

00:50:06.940 --> 00:50:09.877 
同時應用特定服務等級參數

00:50:09.943 --> 00:50:12.646 
向系統發送的所有其他設置 

00:50:13.647 --> 00:50:15.048 
這就是我們使用的方法 

00:50:16.283 --> 00:50:18.519 
我們不建議用戶
使用後臺會話屬性 

00:50:19.119 --> 00:50:22.155 
而建議你爲所有
CKOperation操作

00:50:22.322 --> 00:50:24.091 
設置服務級別 

00:50:25.792 --> 00:50:27.761 
現在 對於網絡行爲  

00:50:28.061 --> 00:50:29.997 
可以設置將服務級別設置爲

00:50:30.063 --> 00:50:32.165 
UserInteractive

00:50:32.232 --> 00:50:33.634 
或UserInitiated 

00:50:33.700 --> 00:50:35.736 
來優化這些自主性行爲

00:50:38.705 --> 00:50:41.074 
對於自主性行爲 

00:50:41.141 --> 00:50:43.777 
你可以設置utility值 

00:50:44.811 --> 00:50:45.879 
在這種情況下 

00:50:45.946 --> 00:50:49.449 
系統將推測 
是否根據發送請求的APP

00:50:49.516 --> 00:50:53.954 
在前臺或在後臺運行
來優化自主性行爲 

00:50:54.755 --> 00:50:57.391 
從而始終會產生
自主性網絡行爲 

00:50:59.259 --> 00:51:01.862 
請記住中 
如果你在iOS 9

00:51:01.929 --> 00:51:05.432 
和OS X El Capitan
或後續版本中開發APP 

00:51:06.466 --> 00:51:08.669 
默認情況下 
所有新CKOperations

00:51:08.735 --> 00:51:10.971 
將具有後臺服務質量級別 

00:51:11.839 --> 00:51:15.175 
你應該確保
審查所有CKOperations,

00:51:16.176 --> 00:51:17.477 
查看它們所代表的

00:51:17.544 --> 00:51:18.745 
作業的重要性 

00:51:19.079 --> 00:51:20.480 
應該保持良好的系統性能 

00:51:20.714 --> 00:51:22.983 
爲這些操作合適的QS值 

00:51:24.818 --> 00:51:26.820 
NSOperation是
功能強大的API 

00:51:26.887 --> 00:51:28.789 
你可以使用它實現很多功能  

00:51:29.556 --> 00:51:32.759 
如果你想了解更多信息 
我強烈建議你們

00:51:32.826 --> 00:51:36.163 
參加明天上午在Presidio舉行
的高級NSOperation講座 

00:51:37.831 --> 00:51:38.866 
作爲總結

00:51:40.701 --> 00:51:42.002 
我想重新強調

00:51:42.069 --> 00:51:45.005 
CloudKit代碼中的
錯誤處理方法很重要 

00:51:45.339 --> 00:51:47.574 
它與功能一樣重要 

00:51:48.108 --> 00:51:50.043 
我希望你們反覆檢查你的代碼 

00:51:50.110 --> 00:51:52.379 
查看你的所有操作 

00:51:52.446 --> 00:51:54.581 
弄清楚你遇到哪些類型的錯誤 

00:51:54.648 --> 00:51:56.483 
以及你是否遵守了
今在我們所講述的

00:51:56.550 --> 00:51:58.719 
關於錯誤處理的
一般性指導原則 

00:52:00.521 --> 00:52:03.023 
第二 應該批處理你的請求 

00:52:03.290 --> 00:52:07.394 
當你發現你的APP
使用便利性API,

00:52:07.461 --> 00:52:09.663 
一次處理一個項目

00:52:10.163 --> 00:52:11.798 
而且在多個位置
進行這樣的處理時 

00:52:11.865 --> 00:52:15.135 
你應該考慮使用該API的
CKOperation版本 

00:52:15.502 --> 00:52:16.703 
並且批處理這些請求 

00:52:17.237 --> 00:52:19.173 
你不僅會全面提升

00:52:19.540 --> 00:52:22.509 
系統的操作執行效率 

00:52:22.910 --> 00:52:25.512 
而且會減少網絡請求數量 

00:52:28.048 --> 00:52:29.416 
應考慮優化schema 

00:52:29.616 --> 00:52:31.285 
我們看到兩種情況

00:52:31.351 --> 00:52:33.654 
需要我們優化schema...

00:52:35.556 --> 00:52:38.325 
讓我們能夠獲得優化的好處 

00:52:38.492 --> 00:52:41.295 
例如 當我們爲照片記錄

00:52:41.361 --> 00:52:42.896 
添加縮略鍵值時

00:52:43.096 --> 00:52:45.465 
<br/>
我們可以僅下載需要的數據

00:52:45.532 --> 00:52:48.168 
從而能夠優化下載性能 

00:52:48.902 --> 00:52:51.972 
在另一種情況下 
當我們避免

00:52:52.039 --> 00:52:54.474 
某些派對照片被修改時

00:52:54.541 --> 00:52:56.977 
<br/>
當我們爲派對存儲照片時 

00:52:57.044 --> 00:52:58.478 
可以避免發生
整個類別的錯誤 

00:52:59.112 --> 00:53:01.281 
因此 在設計功能時  

00:53:02.349 --> 00:53:03.684 
請認真思考你的schema 

00:53:05.252 --> 00:53:06.687 
最後並非不重要的是

00:53:06.753 --> 00:53:08.522 
應該配置你的
CKOperations 

00:53:08.589 --> 00:53:11.124 
它們是功能非常強大的API 

00:53:11.191 --> 00:53:14.061 
它們提供大量的優化特性
讓你能夠優化

00:53:14.228 --> 00:53:16.864 
發送至CloudKit服務器的

00:53:16.930 --> 00:53:17.931 
網絡請求 

00:53:20.234 --> 00:53:22.736 
要想獲取更多信息 
請訪問我們的文檔地址是

00:53:22.803 --> 00:53:25.706 
developer.Apple.com/CloudKit.

00:53:26.240 --> 00:53:28.775 
關於其他所有問題和解答 

00:53:28.842 --> 00:53:31.879 
可以諮詢技術支持部門 
論壇和CK支持網站 

00:53:32.279 --> 00:53:33.113 
對於一般性諮詢

00:53:33.180 --> 00:53:35.582 
請發送郵件至
CloudKit@Apple.com 

00:53:36.850 --> 00:53:38.919 
這周我們舉行了
一些很不錯的講座 

00:53:38.986 --> 00:53:41.221 
我希望你們回去後
觀看這些講座視頻 

00:53:41.522 --> 00:53:44.091 
瞭解Web服務新功能

00:53:44.558 --> 00:53:46.159 
和CloudKit其他新功能 

00:53:46.960 --> 00:53:48.061 
明天上午9點 

00:53:48.128 --> 00:53:50.163 
我們還會在
Frameworks lab D

00:53:50.230 --> 00:53:51.498 
舉行另外一場講座 

00:53:52.299 --> 00:53:54.301 
請準備好你們的問題 
我們將樂意爲你解答 

00:53:54.768 --> 00:53:55.602 
謝謝 