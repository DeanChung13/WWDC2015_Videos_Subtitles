早上好
采用新Trackpad特性
欢迎来到会议217：
“采用新Trackpad特性”
我叫罗利·雷德 我是一名AppKit工程师
我是使用新的压力触控trackpads方面的“大师”
我们接下来要讲的就是这个
新的压力触控trackpads
它们是很酷很酷的技术
与我们之前的trackpads不同之处在于
它没有可供你按压的实体键
代替实体键的是四个力传感器
这样我们就可以测量用户对trackpad
施加了多大的力然后我们会把它
和我们的Taptic引擎结合起来
当我们确定用户在trackpad
按压的力足够大足以触发鼠标的时候
我们就会使用Taptic引擎
把trackpad向侧面
稍微拉一下
这样用户就会感觉
他们实际上已经按压到了一个按钮
就是这样 trackpad向侧面移动
但是你的大脑会让你以为
你实际上已经按压到了一个按钮
这种感觉真的很棒这样欺骗你的大脑
让你的大脑以为你已经
按压到了一个按钮这真的很奇妙
我们楼下实验室有一些trackpad
如果你还没有体验过它
请下来试试
在那里顺便看看Taptic引擎
真的很棒
概括一下你施加了一点压力
我们给你算一次单击 但是当你向trackpad施加
更大的力我们也可以辨别出来
我们也可以感觉得到
我们称之为Force click
我们也会给你一个更加强烈的
触觉感受
那么有了Force click
你就可以很多好玩的事
事实上 让我给你演示一些
你现在就可以用Forceclick做的好玩的事
像我这样你可以看到我四处移动光标
你可以看到我对trackpad施加的力
如果我再进一步 你就可以得到Force click
那么大家都听到了吧？
是我添加的 你知道
通常情况下 当你进行Force click
的时候 你的电脑并不会发出声音 我加了这个声音
是因为你们并不能实际感受到这个触觉反馈 因为
你们在那里 而我在这里
这样 当我在演示中向trackpad施加力的时候
你们就可以观看了
你能做的一件事就是在取景器中重命名文件
有时候这有点棘手
你必须点击它然后像这样
再来一次...我又失败了
你的时间选择要正好
这样你才不会双击打开它
但是有了Force Touch
我就可以Force click它
然后就立即可以编辑文件名了
编辑文件名就非常容易了
但这只是你可以用Force click
完成的事情中的小小的一件
我要很快打开TextEdit
我来捕获窗口
你也已经看过这个例子了
你可以Force click
你就可以看到“快速浏览”
非常奇妙你可以坐在那儿 如果你
调整你施加的力的程度的话你就可以“调戏”下动画
我们还有另外一项功能特性
我刚才快速向你演示了一些东西 这个你是知道的
通过改变力的大小我可以改变速度
照片显示的速度
显示的指示器的量
你可以控制力的量
当然了没有绘制区
你就没法绘制任何东西压力演示也就没法完成
最后不要像这样连接音响
而是要在这个控制器上...
当你把照片归零时
你会感受到轻微的触觉反馈
就是在trackpad上
真的很奇妙
我们再回到幻灯片中
我们已经讲了很多东西
我们再来讲讲API
就是那个应用程序用的API就是我们在系统中使用的
各种API这样你就可以在你的应用程序
中使用Force ToTouch trackpad
添加各种各样的
新的功能特性
我今天会教你如何成为
在OS X上使用ForceTouchtrackpad
的“大师”
要成为
Force Touchtrackpad方面的大师
尽管我们会让你在一天内速成
你也得从小处着手
你得学习所有的事情
你得学习一个“侍从”在使用
Force Touchtrackpad方面
全部的知识
这些都是与高级API
以及内置工具相关这些API和工具
有些是在我们的掌控下
然后我们会继续 我们需要学习一名“骑士”在使用
Force Touchtrackpad方面
全部的知识
这些都与压力流在系统内的变化有关
事件流我们会讲讲如何在你的
应用程序定制“弹性加载”然后讲一讲进行
“对齐反馈”的方式
给用户提供更多的触觉反馈
最后我们会让你成为
Force Touchtrackpad
方面的“大师”
这与力的控制有关
对trackpad进行配置
这样它可以在给定的情景中给出适当的触觉反馈
以便你进行控制
并且在适当时机手动进行触觉反馈
我们来看看吧
要成为一名“侍从” 我们要说的是“表格行动作”
它是一项很棒 很奇妙的新功能
你在克雷格在keynote上进行的电子邮件应用程序
演示中已经看到过了
我们来讲讲弹性加载控制
内置的一些东西还有加速器控制
我们会通过一些案例研究来实现这一点
比如说 在邮件这里如果你在邮件的某行上做
双指滑动这个动作你会看到更多的
“表格行动作”你就可以点击它们
或者你可以进行平滑的滑动一个时间更长的滑动
实际上它会激活默认动作
这是用户的完整手势之一
这样向你的应用程序中
添加一些其它的功能就
非常棒
我自己每天都在邮件中用它
它用的API非常简单
在你的tableView授权中
只要实现
tableView ow
ActionsForRow界限即可
我们会告诉你是什么界限要么是前面的
要么是后面的这样我们就可以为你处理为
从右到左 从左到右
然后你只要返回一个“表格行动作”阵列
创建一个新NS表格行动作你以一个类型 一个标题
以及一个处理程序如果选中了一个项目
那么回调的就是这个处理程序无论是点击选中
或者是完成了默认的完整的滑动
那么它就会调用处理程序
我们有这么几种类型：“规则的”以及“破坏的”
蓝色高亮的就是“规则的” 在你的
“表格行动作”大部分类型中你都应该使用
“规则的”
红色的是“破坏的”
不要因为它们的颜色而做出选中
它不仅仅只是红色那么简单
破坏性的项目 因为它们本质上就是破坏性的
事实上我们也让用户更难完成一次
完整的滑动
他们必须在trackpad上滑动较长的距离
这样才能触发默认的
破坏性的动作
这样是为了防止他们意外触发破坏性的动作
尽量在所有的事情上使用“规则的”
把“破坏的”留给破坏性的项目
不要尝试用红色它的语义非常重要
你要注意这一点
这个API就是这样
非常简单
这个适用于新的Force Touch trackpad
也同样适用于我们的
老款trackpads和Magic Mouse
这样你很容易就能把它们加到你的应用程序中
你就可以开启新的奇妙的可能
我们再来看看取景器中的“弹性加载”
我这里有下载的一张洛拉的图像
我想把她移动到“我的文档”文件夹
我要通过Force clicking
开始拖动它
回到我的历史我甚至还要改成图标模式
这样我就能更加容易地找到文档文件夹
最后 把它放进“我的文档”文件夹
你之前可能已经知道了弹性加载
你可以悬停在一个文件夹上超时后
文件夹就会进行弹性加载
我们向许多地方和应用程序中添加了
弹性加载以便把窗口置前
就像你刚才看到的按钮是弹性加载的
你只要进行Forceclick 就可以越过
悬停超时
这样用起来就更直观更便利
要在这项工具栏按钮上
实现弹性加载取景器所做的
就是把NSButton的弹性加载属性设置为“真”
他们就是在IB内校验了下框
就这么简单
分段控制你也可以这么做
当我把图标布局从列表视图改为图标视图
那就是NSSegmentedControl
再说一遍 它就是个springLoaded属性
你可以在IB的一个勾选框上进行设置
在你的按钮 分段控制上打开弹性加载
就这么简单
你可以勾选使用但是如果是
在导航中那么拖放
就很有用我建议你们去试试
打开它
这是施加力的另一个实例这是QuickTime
我想让你们注意看这里的这个快进按钮
我要使用ForceTouchtrackpad
我要向那个按钮
施加不同的压力
你可以看到 我可以达到5x10x 30x
你也可以放慢速度
当你翻看你的电影文件时
你可以控制前进的速度
当你接近你要找的区域时你就可以放慢速度
避免跑过头
QuickTime能这样做是因为
我们有了一种新的按钮类型
因此快进按钮就是带有自定义图像的NSButtons
它们可以把按钮的类型设为
AcceleratorButton或者
MultiLevelAcceleratorButton
对AcceleratorButton来说
你可以在IB这里设置
当trackpad上的力发生改变时
这个按钮就会持续发送活动消息
因此当力发生改变时你就会得到新的活动消息
如果力再次发生改变你又会收到新的活动消息
当用户点击按钮达到两次时
doubleValue的域为1 这是因为
用户达到了我们在trackpad上
接受的力的按压的最大值
你可以看到压力在1到2之间变动
你可以随意
对它进行调整
QuickTime这个实例中 它控制的是加速度
你最终得到的值为零
当用户结束追踪按钮时你会得到
一条值为零的活动消息
当他们释放鼠标按钮时
你会得到最后一条域为零的活动消息
实际上 QuickTime在这里使用的
就是MultiLevelAcceleratorButton
你可以在IB这里进行设置
MultiLevelAcceleratorButton
是离散的
而AcceleratorButton是一个平滑域
一个介于一到二之间的连续域
AcceleratorButton是整数层
是一个离散整数层你可以用
maxAcceleratorLevel
对它 进行设置
我们的域是介于一到五因此你可以设置
在你的加速中你想要的层数
默认是二
QuickTime把它设置成了五
你又看到了doubleValue
域为零到五当你点击时为一
当用户上升层级时
它会上升到你设置的最大层级
当用户停止追踪时你会得到零的最终
活动消息
QuickTime做的就是这个
这里你可以看到
QuickTime是如何映射你的各种速度为
一、二、三、四、五
比如说三就是10x快进
加速器控制的另一个实例：这是“地图”
“地图”上有这个漂亮的缩放按钮
实际上
这些是当做NSSegmentedControls
实现的
NSSegmentedControls
有一种新的追踪模式
即MomentaryAccelerator
它和加速器NSButtonType
的工作方式一模一样
在IB中设置这个同样也非常容易
但是当分段控制活动消息发出后
你应该请求选定的分段的doubleValue
而不是请求
doubleValue
它和我们之前谈到的域是一样的
当用户结束追踪时它为一到二
并且最后活动消息值为零
分段控制没有多层选项
它们仅仅支持连续模式
这是一个照片的例子
通过施加力 调整力浏览
“照片”中的照片
我可以控制照片移动的速度
我们称之为连续加速控制
如果你在NSButton
或者NSSegmentedControl上
有一项加速控制设置
你可以在NSControl节
把连续标志设置为“真”
或者在IB中勾选框
你就可以得到我们所说的连续加速控制
连续加速控制是不同的
因为你不太需要关心
它们的doubleValues
当动作发生时你只是想尽快移动到
下一个滑动上
doubleValue无关紧要
它们会像心跳一样回来
而力会改变心跳的频率
这就是区别所在
要把问题讲清楚让我们来对两者进行对比
在加速控制中
只要压力发生变化 我们就可以获取到你的活动消息
因此可能会有延迟
它们可能会互相靠近
这样你就改变了你在电影中
的快进速度
如果是连续控制对连续加速来说
它会参加到心跳中
然后你就可以完成你的动作
如果用户施加了多次力频率会很高
它们可能会
紧密结合起来
像滑动照片此时动画速度是连续的
它就非常适合不过你何时应该呈现
下一张照片？
应该在下次发出活动消息时呈现
它为用户提供了许多控制
要成为一个“侍从”你需要了解的就这些
恭喜你们现在都成了使用
Force Touchtrackpads方面的“侍从”
我们讲了“表格行动作”一个非常容易实现的API
弹性加载NSButtons
加速器NSButtons 分段控制
打开它们很容易我们的高层API
使用这些API在这里真的物有所值
我们希望你们在你们的应用程序内打开它们
我们接着来看看怎样成为一名“骑士”
要成为一名“骑士”
那就需要理解力在系统内的流动方式
我们来讲一下力的事件流
然后我会讲一下
弹性加载协议
这样你就可以使用和NSButton相同的API
在你的自定义应用程序内提供弹性加载
我们最后会谈一些对齐反馈API
可以帮助你进行对齐指导以及类似的事情
我们再来谈谈事件流
我们在OS X已经有了很多事件
你向上和向下移动鼠标
你的放大 旋转手势
现在我们再介绍一个：
NSEventTypePressure

新MacBooks时引入的
你也可以在那里获得
它们是压力手势
当然了和新的事件类型
我们有事件掩码：NSEventMaskPressure
这意味着在你的跟踪回路中
你可以向你的跟踪回路中添加
事件掩码压力
当你追踪鼠标时你也可以让
压力事件起作用
使用真的很方便
如果你更喜欢响应器这种方式 这样你可以
覆盖鼠标向上鼠标拖动 鼠标向下
我们也还有一种新的响应器方式
pressureChangeWithEvent
这样如果你喜欢的话
你就可以获取它们
我们再来挖掘下压力手势的属性
这是一种手势和鼠标事件序列不同
后者为鼠标上移 鼠标拖动鼠标下移有个体类型
压力只有单一类型
它有一个段会经历开始 改变 结束
这样的一个循环直到手势结束
我们也有一个阶段
阶段是指我们如何确定
Force click是否发生了
当你用trackpad进行鼠标下移
你会得到“开始”段
压力手势它是阶段一
这是标准点击层次
用户增加力度
在trackpad上达到了Force click
层级就变成了阶段二
这样你就知道用户实现了Force click
你就可以立即完成你的Force click动作
比如说重命名取景器
这样当用户从trackpad上
释放力的时候
当它到达点击层级时就会返回阶段一
当手势结束时最终到了阶段零
因为鼠标按下去后就不再往下了
这样得到了阶段零“结束”段的最后事件
现在 当然了没有真正的压力值
就不会完成任何压力手势
因此我们也有压力属性
它的域为零到一
注意这里
压力属性就是当前阶段的
压力
正如你在这个图表中看到的
当你进入阶段一压力开始上升
并且在你进入阶段二时达到了1
当你越过阶段二压力立即掉回了零
当你在阶段二增加压力时压力又重新
开始上升
压力属于当前阶段
现在我展示的是
trackpad上的力和用户在压力事件中的值
这两者之间的
线性映射但是
我不希望你们过度曲解
我们喜欢把trackpad上的每次点击
都当成一次冒险我们看到了很多
不同的变量用户使用他们的拇指
他们偏好的硬度设置
他们如何与trackpad进行交互
因此我们忙着对这些曲线进行动态变更
给用户尽可能好的体验
我们把trackpad的输入标准化为
零到一的压力域
你在你的应用程序中也应该用这个
你可能注意到了之前我在演示时四处点击
仅仅在TextEdit四处点击
我并不会看到动画弹出
直到我离的足够近施加的压力非常接近
Force click
当用户只是随意点击时你不会希望有
一大堆的动画出现
分散用户的注意
当他们接近转移到阶段二时
这个动画很有用
阶段的转移属性
就是用来干这个的
你可以在这里看到它的域为零到一
但是在零这里停留了很长时间
直到你开始接近下一阶段
这个例子中是阶段二
我想让你们接近阶段二它会暴涨到一
你可以用这个域控制你的动画
而如果你只是在界面内随意点击
它就不会妨碍你
你可以得到这个动画你一接近阶段二
你就可以弹出结束动画
你可以看到你一接近阶段二
阶段过渡值就掉回了零在这个例子中
我们没有阶段三可以过渡因此剩余的时间
它仍然停在零
我之前提到过当压力手势存在
鼠标事件也就同时继续
trackpad还是会继续模仿鼠标
它也会发出压力手势
我要看看这些流是如何在系统中
同时并行
我们接着要讲的就是这个
这是一个实例 用户向trackpad施加力
进行点击慢慢接近
Force click阈值
然后释放了压力
这就是他们的输入
下面这里我们要向你演示
进入你的应用程序的事件
一开始用户施加的是轻微的压力
这些就是全部的鼠标移动
我们还没有到达点击阈值
我们还没有开始压力手势
这些只是鼠标移动
还没有压力手势进来
你达到点击阈值出现了鼠标下移
你也到了阶段一得到压力开始事件
此时压力值要变成零
我们不能保证
是压力开始事件先发生还是
鼠标向下先发生它们有时候会交换位置
处理这个最容易的方式是寻找鼠标向下这个事件
如果你也要压力事件那么在鼠标向下发生之后
继续寻找压力事件
当用户开始向trackpad施加更多的力
你可以看到 当我们接近Force click阈值时
压力朝着一升上去了
如果光标移动这些将作为鼠标拖动事件
体现出来
你就有了鼠标拖动事件以及
压力事件我们仍然处于阶段一
我们达到了Forceclick阈值
现在你在阶段二得到了压力手势
压力值一路掉回了零
用户继续向trackpad施加更大的力
压力再次开始增加 当他们从trackpad上释放
压力时它就开始
朝着零回落
现在他们释放回到了Force click阈值
压力为零
此时我们仍然处于阶段二
用户再多释放一点压力
我们也仍然处于阶段二
实际上 在这个图表上我们夸张了一点
不过对于一个人来说在trackpad上以一个
恒速保持压力非常困难
如果他们恰好处于Forceclick层级 他们就会
超越 然后略微下降我们并不希望
触发 关闭Forceclick
触发 关闭 触发 关闭
这不是用户想做的
我们要求你往Forceclick阈值下
多降一点直到我们最终脱离阶段二
然后我们给你最终的阶段一事件
在那个小的时间段内
事件的压力将为零
很明显 你在Forceclick阈值下方
压力将会开始上升
既然你处于阶段一用户继续释放
压力上升再次开始回来
你注意到 它并不是一路跳回阶段一
因为那是间隙的一部分
要注意的一点是这就是为什么你不应该
尝试合并阶段一和阶段二 获得更大的
动态范围的原因
但我们到了“大师”阶段时我们会再
多谈谈
无论何时发生阶段二
我们也会自动提供触觉反馈因此不要尝试把
压力合并到两个阶段
要么看着阶段一 使用压力要么看着阶段二 使用压力
如果你需要在后者进行你的动画
或者阶段过渡属性
我们达到了阶段一的点击阈值点
因此你的压力现在回到了零
就像我们用Force click阈值
做的那样实际上 在我们
最终从阶段一释放之前
用户必须释放更多的力
我们要施加一个力结束时阶段为零
鼠标上移
还是这样无法保证是鼠标上移先发生
还是压力结束事件
先发生处理这个最容易的方式是：
寻找鼠标上移同时追踪压力
和鼠标运动直到
发生了鼠标上移
忽略任何可能在压力事件之前
之后发生的序列
这个适用于Mice也同样适用于我们的
老款trackpads
以及新ForceTouchtrackpads
最后 鼠标上移后如果用户用非常非常轻微的
压力四处移动这些鼠标移动
压力手势结束了我们会再次开始循环
就像我们一开始做的那样
如果压力会和这个鼠标下移联系起来
了解鼠标下移
就非常重要
是否来自一台模仿鼠标的设备？
是否给出了压力手势事件？
我们就是通过使用鼠标下移事件上的
associatedEventMask属性
来帮助你做这个
你在鼠标移动事件上也可以看到这个
使用真的非常方便
你为associatedEventMask
请求鼠标下移事件
你发现它包括了EventMaskPressure
如果你正在使用Cocoa
你就用NSEventMaskPressure
把它结束了
因为你正在校验位域
如果它确实包括EventMaskPressure
你知道压力事件就要来了
你就可以把它设置好 这样你就可以有不同的笔刷宽度
比如说在你绘画时
这很棒
如果它不包括EventMaskPressure
那么它就来自一个鼠标或者 比如说
一台老款trackpad此时你想选择一个默认的
笔刷宽度
通常你在此时选择最大的笔刷宽度
或者你想要选择一半的笔刷宽度
你在整个鼠标拖动序列中
都使用这个定值
这是新EventTypePressure
它有很多新属性有一个段
因为它是一个手势当前阶段的压力
位于零到一的域内
当然你有阶段你很容易就可以看到
当用户达到Force click
那些过渡动画的阶段过渡
相连事件掩码
你知道 当你的鼠标事件会有压力
与它们相连时
当然如果你使用了响应器方式
事件响应器方式
会引起压力变化
我们再来讲讲弹性加载
讲一讲NSButton是如何实现弹性加载的
你可以在你的定制控制器中使用完全相同的API
向你的应用程序添加弹性加载
这是一个
NSSpringLoadingDestination协议
如果你曾经实施过的话
它和NSDraggingDestination
协议非常类似
在你的目标中在你的目标视图中
你需要实现springLoadingEntered
或springLoadingUpdated
这里给你一个实例看看是如何实现的：
NSButton实现
springLoadingEntered
而不是springLoadingUpdated
因为一个按钮要么是激活的 要么是禁止的
因此你一按住按钮
它就会返回弹性加载选项然后它就
在生命期内就不变了
拖曳就发生在按钮中
NSSegmentedControl另一方面
实现了springLoadingUpdated
每个段都可能是激活的或者禁止的 彼此独立
是一个视图
因此有了springLoadingUpdated
分段控制就可以对拖曳进行观察 精确找出拖曳
在控制器哪里
如何动态改变弹性加载选项的
就像我提到过的 你需要...
如果你实现其中的一个方式
你需要实现弹性加载选项
如果你愿意你可以两者都实现
你并不需要仅仅实现其中一个 但是
你最起码要实现其中一个
对你的弹性加载选项来说很明显
你返回弹性加载选项应该是“激活的”还是“禁止的”
非常简单
我们还有其它一些有趣的选项
持续激活
一般来说弹性加载动作是离散的
弹性加载产生了
按钮发出了动作结束了
还有一个持续版本我们在下面的
幻灯片中 会
讲到
我想再讲讲没有悬停的情况
就像我之前提到的弹性加载可以通过
悬停或者Force click激活
悬停非常适合
没有Force Touchtrackpads的
人群
举例来说如果你想在一块很大的画布上
进行Force click
用户把项目拖拽过画布
他们只是试图拖到画布另一边
他们抬起手指回来继续拖拽
或者抬起鼠标继续拖拽
这个时间可能会很长
光标停住不动而
弹性加载一直处于激活状态
这就是一个假的激活
这不是用户试图做的
如果因为悬停 你收到了大量假的激活
如果你遇到了这种情况你可能想考虑下
无悬停弹性加载选项
用户就可以用
Force Touchtrackpad进行
Force click在你的视图的那个位置
得到弹性加载
你要保守地使用使用之前务必三思
因为我们不想遗漏任何没有Force Touch trackpad
的 用户
但是如果你收到了大量的假的激活
那么偶尔用一个这个选项就很好
与springLoadingEntered
和“已更新”一起我们当然还有
springLoadingExited...
当用户退出了你的视图它就会告诉你
还有draggingEnded
弹性加载是拖放操作的一部分
因此如果用户拖过了你的视图
你的弹性加载目的
你实现了draggingEnded
当拖拽完成后当用户释放了鼠标
取消了拖拽
你会拿回draggingEnded
无论用户是在你的应用程序中还是在另一个进程中
完成了拖拽都不重要
任何实现了draggingUpdated的人
都会得到他们的回调
因为这是拖拽的一部分
NSDraggingDestination
还有一个draggingEnded函数
它和我们这里的函数一模一样
如果你同时使用了弹性加载目的
和NSDraggingDestination
那么你只需要
实现一个draggingEnded
它会应用于两者之上因此如果你同时使用了
弹性加载目的和拖拽目的
你就需要为弹性加载目的和拖拽目的
完成清除工作
现在我们来看看弹性加载真正好玩的地方
因此 要求你实现springLoadingActivated
我们就是在这里告诉你的目的
用户进行了弹性加载
我们有一个布尔值通常这个值为“是”
就像我提到的弹性加载是一个离散动作
它发生了NSButton刚刚发生了动作
大家都满意了
但是 如果你有连续位组
那么只要用户进行Force click
我们会发送一个springLoadingActivated“是”
你可以启动一个计时器你可以继续
往那个计时器添加你的活动消息
当你从Force click释放后 它会回复给你
一个springLoadingActivated“否”
你就知道你该关闭你的计时器了
如果用户使用悬停
当悬停超时时 你会得到
springLoadingActivated“是”
当它们从控制器移出时你就会得到
一个“否”
要把这个和正常的离散动作进行对比
通常是在释放Force click时
来自Force click的弹性加载
它们会一路进入Force click
当它们释放Force click
如果你不是连续使用你就会得到
一个springLoadingActivated“是”
除非你在弹性加载时需要连续发出你的活动消息
那么我们通常
会建议你用它
最后 我们有
springLoadingHighlightChanged
我们希望给用户提供反馈告诉它们当前的情况
我们有三种高亮形式：不高亮
标准高亮 增强高亮
当你得到一个
springLoadingHighlightChanged
消息 你需要告诉draggingInfo那个
springLoadingHighlight是为了什么
设置需要展示的视图
然后你就可以更新在正确的高亮显示
那里绘画
重要的是不要试图推断
用户的任何动作
这就是springLoadingActivated的用途
就像当你从一个菜单中选择一个项目时
我们会让那个菜单项目闪烁让用户知道 确认他们已经
选择了那个项目我们在弹性加载中
也做了类似的事
我们是通过改变高亮实现的
因此你需要做的就是用任何需要的
高亮方式绘画然后你的应用程序的
风格就会和系统的其它地方
保持一致
使用springLoadingActivated来知道何时
发出活动消息
这是弹性加载目的
我们有对齐反馈 当你在Interface Builder中
有两个项目在一起时你可以看到这个
我们把它们对齐了绘制了这个漂亮的对齐指导
我们有一些新的API能帮助你实现这一点
绘图由你决定但是我们的新API能帮助你
决定何时应该对齐
这里给你一个例子我们来看看这个跟踪回路
一个典型的跟踪回路
我们放大下
你得到了你的鼠标下移事件
你找出你的事件掩码是什么你想要追踪哪个事件
你请求下个事件你移动你的项目
更新你的数据模型设置你的需求显示
鼠标上移了吗？没有你就继续这个循环
无论drawRect什么时候被调用你就绘制
你把你的项目拖过屏幕直到发生了鼠标上移
我们有一个
NSAlignmentFeedbackFilter对象
能帮到你
你把鼠标上移你做的第一件事
你从对齐反馈过滤器中
得到输入事件掩码
对齐反馈过滤器需要知道这个
当你调用nextEventMatchingMask时
你只需要或者把它们 或者
把它们的并集 在Swift实例中和你的事件掩码并运算
你一旦得到下个事件你要做的第一件事
就是把事件送到对齐反馈过滤器
它会立即返回
它只是更新一些内部状态
你移动...不好意思 如果你使用的是pan手势识别器
你也可以用pan手势识别器来进行更新
它和跟踪回路工作方式十分类似
一切都适用除了这个消息差异
对齐反馈过滤器一旦处理完输出 返回后
像你平常那样你把项目移到你的数据模型
然后你准备对齐
我们来挖掘一下准备对齐你得使用对齐反馈过滤器
来帮助你实现这一点
我们之前在数据模型中有对象
我们得到了事件我们决定用户移动到这里
如果我们不进行任何对齐
这里就是默认位置
这是对象结束的地方
我们想知道：是否应该在这里对齐 是否应该
向下对齐这条线 或者我们是否要同时对齐
弄到下面角落里
使用对齐反馈过滤器对象来帮助你
决定这个
alignmentFeedbackToken
ForHorizontalMovementInView
previousXalignedX和defaultX
这些坐标都位于窗口坐标空格上
因此无论你在视图内的缩放层级是什么
它都工作的很好
如果发生对齐我们就会返回给你一个
对齐反馈令牌
如果你没有得到对齐反馈令牌
那就不要进行任何对齐
如果你得到了对齐反馈令牌
在这个例子中 在你的数据模型中改变X位置
改变为对齐位置留住那个
对齐反馈令牌
然后你也可以校验纵向运动
除了你要发送你的Y值代替你的X
你还是可能得到 或者得不到对齐反馈令牌
如果你得到两个对齐反馈令牌 你就需要
在两个轴线中对齐这样你的对象就会
到下面角落这里
有时候这个并不经常发生
但是如果它同时在X轴和Y轴对齐
你只想对齐到一个位置它要么对齐
两个轴要么哪个轴都不对齐
此时我们有运动的对齐反馈令牌
你越过点而不是一个个体X坐标
或者Y坐标两者都可以
你可能得到 也可能得不到对齐反馈令牌
你对拖拽的各种项目进行迭代 这样它们
可以对齐你拿回你的对齐反馈令牌
如果发生对齐你就改变你的数据模型
现在你有了一系列令牌
你想要给使用新Force Touch trackpad的
用户提供触觉反馈
我们会使用对齐反馈过滤器来帮助我们这样做
我们会让对齐反馈过滤器在执行时间来
执行反馈
现在执行时间先使用默认值
我们稍后会再讲一讲执行时间
然后你给阵列传递一个反馈令牌
如果没有对齐 你甚至可以传递一个空的阵列
对齐反馈过滤器在这方面很健壮
它知道什么都不用做
然后你设置你的视图为需要显示
无论什么时候要求你就重新绘制 如果你
有令牌 你就知道你何时在重新绘制
如果对你的UI合适的话绘制对齐指导
然后反馈就会同步和屏幕改变执行
用户就可以有一个漂亮的
同步看到对齐指导弹出
他们也同时从trackpad上感受到
触觉反馈
如果用户用的不是ForceTouch trackpad 对齐
反馈过滤器也知道应该如何工作
所以你只需要假设是Force Touch trackpad
你只需要写就可以了
如果不是那就没问题
所以 实际上
就是使用对齐反馈过滤器
它们非常简单的API添加到你的应用程序
和现有的跟踪回路中很容易
让整个app提供一致的风格
比如 我们看看光标的速度
因此如果用户移动的很快我们就不对齐
因为我们不想在那个时候
进行对齐
那不是用户想要做的
我们来看修改值
这会给所有使用系统宽度对齐反馈API
的应用程序提供
一致的风格
你就可以用它不仅仅是拖拽一个项目
如果你重新调整尺寸比如说 或者自动调整
那就非常适合用对齐反馈过滤器
它可以用在很多不同的地方
要成为一名“骑士”你需要了解的就这些
恭喜
你们现在都是使用
Force Touch trackpad的“骑士”了
我们来继续成为“大师”
都是关于力的控制
是关于对trackpad进行配置
这样它就能适用于你的定制情景
手动提供触觉反馈
我们再回到绘图这个例子
你开始绘图 你按压ForceTouch trackpad
你得到了Force click
但是它并不真的适用于你的绘图
就像我之前提到的你不希望尝试合并
阶段一的压力值和阶段二的压力值
合并 甚至在释放时也不行
这样用户就会在绘图过程中
得到触觉反馈这种经历
可不妙
因此我们想要对trackpad进行配置
让它在这个例子中不提供一点Force click动作
我们能用压力配置对象做的 就是这个
我们先用一个pressureBehavior开始
校验下头部文档和资料
校验NSEvent.h头部文档中对每个
都有大量的描述
我不会每个都讲
默认的是DeepClick这是系统
发生的
在这个例子中 我们想要PrimaryGeneric
PrimaryGeneric是个阶段一手势
因此当用户在绘制时他们就不会得到
Force click动作
给用户提供了在他们的trackpad上输入力的
最大的动态范围把它向你映射回去
映射到零到一的压力
最适合绘图以及其它多个
情景校验头部文档
看看其它行为描述看看
哪个适合你的情景
一旦你完成压力配置后
你就可以调用设置
trackpad现在在新的配置中配置好了
一切都很好有了一些画布
在鼠标拖拽时 你可以
仅仅把trackpad设置成一个不同的配置
在鼠标上移中 你对鼠标的位置进行校验
如果这个特定的
鼠标位置需要改变
创建一个压力配置调用设置
trackpad就会做出改变
你需要意识到此时你在和用户竞赛
用户可能使用光标翻过你的视图 立即进行
Force click 释放鼠标而你甚至
还没有下移鼠标
也许你被从虚拟内存中置入分页
你的app失去响应了
你可以试着设置压力此时的trackpad配置
但是用户已经完成了他们的手势
手势不会生效
当你设置trackpad配置时它会自动重置为
系统默认值用户也会同时
结束手势因此你不需要担心
对它复原
但是对多数情况来说这不够理想 当你需要
根据鼠标位置 在最后一分钟决定
配置应该是什么时这很有用
而不是在NSView上设置压力配置
提前创建一个压力配置
在NSView上把它设置为压力配置属性
系统就会在鼠标下移发生之前
设置好trackpad
事实上 系统可以给trackpad配置为这种配置
即使你的app
失去了响应
现在用户就可以继续和你的应用程序交互了
你甚至还没有完成鼠标下移
但是他们没有感受到Force click
因为它位于PrimaryGeneric行为
以及你从应用程序中得到的事件
当你最终得到你的事件此时从系统中
获得如果
你失去了响应 不要在它们里面进行Force click
它们不会到阶段二
我们再来讲讲触觉反馈
触觉反馈应该保守使用
它们是用于微妙的交互
我们想让trackpad感觉很奇妙不是吗？
当用户想要对齐某些东西时
它们会得到触觉反馈感觉很棒
但是我们不是想在这里按摩用户的指头
我们只是想进行微妙的交互
事实上 如果用户用回我们的老款
trackpads我们希望他们根本
意识不到 虽然设备换了但是却
基本感觉不到
使用触觉反馈的意义就在这里
正确使用的话当用户试图做一些事情
的时候给他们一点微妙的反馈
是的 就这样
它就应该一直是这样
我都不知道
微妙的交互
你为defaultPerformer请求了
NSHapticFeedbackManager
始终请求defaultPerformer
因为它可以根据输入设备以及用户的偏好
进行改变
在某个特定的运行时间你要求执行反馈模式
我们有三个
模式：“通用”“对齐”以及“LevelChange”
对齐可以用于很多事情
即使你只是旋转一幅照片进行水平对齐
打个比方 你也可以为它使用对齐
“LevelChange”就是NSButton在不同的多次方式中用的
当层级改变时它会提供触觉反馈
如果那两项对你试图做的事情描述的不够充分
那就使用“通用”
你想让你的触觉反馈与屏幕上进行的事物
同步执行那么默认的
就是DrawCompleted
如果你用Cocoa绘画或者用核心动画
你就用DrawCompleted执行时间
这个会自动把它们为你同步起来
这样在事件进程中 绘画中你就能确定你的触觉反馈
你就可以仅仅关注绘画
如果你直接用Medal或者OpenGL
那就可以用“现在”当事情在屏幕上更新时
你需要确保你排列了它们这样
它们可以同时发生
就是这些
你们现在都是使用
Force Touchtrackpad的“大师”了
我迫不及待想看看你们在你们的
应用程序中运用这些东西我们讲了“表格行动作”
加速按钮 弹性加载我们讲了力在
系统中的流动
进行对齐反馈最后是控制trackpad
为你的特定需求配置trackpad
你能做的事情很多
刚才在我的演示中的小app
叫做Force TouchCatalog
你可以下载后看一看
我们也有对齐指导样例应用程序
把它们用起来也确实有用
我建议你们看看“WebKit和Safari中的
网站开发有什么新料”
这样你就可以了解Safari在网站环境中
是如何承担压力的
这之后我们会有个实验室
“Cocoa和Force Touch 手势”
实验室 我当然也会到场
我十分乐意倾听你们就如何在你们的
应用程序中使用ForceTouch的想法 你们甚至可以给我
展示下你们已经完成的东西我会十分乐意观看
并且和你们讨论
会议结束后请到实验室找我
非常感谢祝你们剩余的时间过得愉快