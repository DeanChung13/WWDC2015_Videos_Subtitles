低能耗，高性能：压缩和加速框架
早上好
欢迎来到矢量数字组讲座
我叫埃里克·比安维尔现在就职于矢量数字组
我们组提供大家都知道的加速框架
还在系统里的一些库
在加速框架中你会发现图像
是图像操作的数百种
功能集合
你还会看到加速内部的vDSP是用于
信号处理和三层线性代数库
在加速框架以外我们还维护Math library
LibM和字符串函数
去年 我们引入了SIMD这是一系列
头文件和函数可提供矢量类型
可以向SSC和AVX附近的CPU矢量单元直接映射
今天 我们要介绍这些函数的三种补充
首先是压缩这是数据压缩库
然后史蒂夫会介绍SIMD库的补充内容
最后卢克会讲稀疏BLAS的内容
稀疏矩阵的线性代数
我们先来看压缩
压缩是什么?
压缩是个新库它可提供统一
和简单的API进行无损数据压缩
在app中想要使用压缩时
为什么会需要这样的东西呢
首先需要找到
压缩读取手册编写代码进行测试
如果不工作就需要另选一个再编写代码
这会非常麻烦
有时 甚至会在你的app中
还包括压缩曲线这对于
维护来说就是噩梦
因此要为常见的压缩算法
和统一的API提供包装
以及诸如优化代码
和算法间的轻松转换类好处
我们先从放入其中的算法开始
当我们谈到压缩算法时需要考虑两个矩阵
第一个显然是压缩比率
这是原始数据大小和压缩有效
载荷大小之间的比率
我们感兴趣的是编码速度和解码速度
为选择算法他们将其放在同一图形中
在这张图中X轴上显示的是压缩比率
在Y轴上则是编码速度
在中间是参考参考压缩器
所有的算法都要与这个参考进行比较
如果你是在右侧压缩效果较好
如果是在顶部压缩速度较快 就是这样
我们放入一些算法
中间的是zlib
这是最常用的
那我们做了什么呢？
我们选择最好的压缩对就是LZMA
和最快的LZ4
你会看到灰线表明压缩得越多难度就会越大
压缩更多 意味着
速度越慢压缩越少则速度越快呈指数关系
正如仔细来看这就是在zlib之上
的第一个点也就是速度更快 稍靠右侧一点
这是说压缩得更好这就是LZFSE
我们今天要介绍的新压缩器
是对zlib的很好替代我稍后会谈到这点
在压缩库中我们放了4个压缩器
解码是这个样子看似是同样内容
如果压缩得越多也就需要更多的解压时间
我们的4个压缩器都在同样的位置
这些是我们选择放入压缩库的4个算法
LZMA用于高压缩但它位置却很低
LZ4用于快速压缩但是它不能压缩很多
在中间位置是zlib和LZFSE 
为在压缩比率和速度之间取得平衡
如果是在不同的应用情况中做比较
对于软件分发你会使用LZMA
因为要在服务器上压缩一次 然后发送
这样你会希望发送部分越小越好
那我们做了什么呢？
我们在Apple硬件上做了部分优化
这是什么意思呢？
像这样例如我们优化了zlib解码器
我们提供的zlib解码器的性能
压缩能力几乎比普通的zlib快1.6倍
LZ4也是如此
因此这是另一个好处
你还会因为无需改变代码
就可以实现数据安全和性能升级而受益
我们简单介绍一下新的压缩器LZFSE
你为什么会需要新款压缩器呢？
首先它很有趣
然后 为什么我们要优化zlib?
在zlib的熵编码部分我们得出了结论
这里是个瓶颈问题无法解决
除非是用其他的内容加以取代我们就是这么做的
我们采用了新技术更精致的状态熵
并用它取代了zlib编码
好消息是LZFSE可以在 
现代CPU架构上实现更好的映射
当初的设计目标是要匹配zlib的压缩比率
使之能实现尽可能快的速度
我来给大家看看相关的数字
这是压缩比率通过设计也是同样的数字
这里是能源效率编码和解码都有LZFSE  
如大家所见 在编码方面 
我们快了2倍多在解码方面我们快了2.5倍
不仅是快是更高效
这是什么意思呢？
假设你有的电池是满格电量并未进行压缩
通过zlib比如说在电池没电之前可以压缩5千兆数据
通过LZFSE 耗费同样的电量你可以压缩12千兆数据
这就是高能效的意思
实际上 速度方面也不差
因为我们在相同的压缩比率下在编码
速度方面快了2倍多解码速度
则快了3倍
这就是LZFSE
我来给大家展示这个API该怎样使用
共有两个API在一个缓冲区中立刻出现了所有的数据
则要用到缓冲API
这是从PC中接收数据时用到的流API
缓冲API非常简单
就像是超级的内存拷贝你提供缓冲
和字节数目的地缓冲
和容量还还可以提供
所需用到的算法
这就是LZFSE
你会看到在压缩器之间的转换
就是改变常数即可不需要重写任何代码
新代码是压缩解码缓冲函数
如果出现错误或者目的地缓冲区
没有足够空间它就会将
返回目的地缓冲区的字节数变为0
解码也是同样道理
你会传递包括压缩有效载荷的缓冲区
和接收解码数据的缓冲区
不同之处在于它放入输出
缓冲区的字节数
如果出现问题它会填充缓冲区
也会截取输出内容
我来给大家展示流API
这稍微有些复杂
因为你需要在调用之间有些状态
我们会用需要压缩的新原始数据多次调用库
这就像个糖果工厂
从这边送入白糖输出的就是糖果
你需要将流对象进行初始化
然后多次处理函数
最后你会调用函数释放流对象占用的资源
我来给大家看看代码细节
首先我们初始化流对象你表示认可
我要编码要使用LZFSE初始化
然后你会调用过程
在调用过程之前通常是在其他压缩库中
你需要告知它在哪里压缩字节
在哪里放置输出数据
然后调用过程它会和消费者端一样
输入或填充输出数据
它还会为你更新这些域
最后你会告知它好了做完了
没有白糖原料了 
结束之后你就不得再发送需要压缩的数据
但是你需要多次调用清空管道获得输出数据
此刻它会返回结束意思是说
最后你需要调用压缩流销毁来释放资源
这就是编码解码则要更为简单
你需要相同的初始化代码
这次是要解码而不是编码
然后你发送数据它会自行分辨
这是否为流的结束部分
在某些点它会返回结束这意味着
你可以获得所有数据你还要再次销毁就这样
我们完成了压缩
现在来进行打包有一个新的库
可以在几个压缩器上提供简化和统一的API
LZMA LZ4 zlib和 LZFSE
哪个在zlib上更受青睐
LZFSE就是新的 高性能压缩器
谢谢大家 有请史蒂夫他会介绍
有关SIMD库的改进内容
谢谢
谢谢 埃里克
我是史蒂夫·坎农 和埃里克一起是矢量数字组的工程师
今天 我想谈谈SIMD 
这是个二维三维和四维的矢量数学
去年在Yosemite版本和iOS中 我们引入了SIMD
它可以用于CObjective-C
和C++它与Metal着色语言非常相似
也就是说它很容易编写在GPU上
运行的Metal代码使用和SIMD
相同的数据结构和相同的CPU代码
它非常接近着色语言的传统
以及与矢量和矩形工作的方式
那么今年的新增
内容是我们也会支持Swift
那么本次讲座中以及我主讲的部分都是与Swift有关
所有的实例都是Swift
大部分情况下 它与CObjective-C和C++中
都是完全相同
如果想在深入了解这些语言可以看看
我们去年的讲座视频其中有些很重要的
不同之处我会在讲座中明确指出
但是 所有的实例都是Swift
我们为什么要引入新的矢量库呢?
在平台上有一系列矢量库
我也用过相当多
为什么还要添加新的呢？
我给大家看看几项实例都是用其他矢量库
小有不便以及使用SIMD则会好了许多
BLAS是很好的矢量库 
它是加速的一部分这是我用到的第一部分内容
这里是用向量乘以矢量一个例子
并将之加入BLAS的另一个矢量
我们生成了两个Swift数组
这些就我们的矢量
我们称之为C BLAS Saxpy函数 它会将X乘以2 
在加上Y并把结果保存在Y
我们需要传递的还有一些其他信息
因为这里是用到原始生成的API
它对于长度或步幅一无所知
我们需要提供这类信息
若是提出显性调用来做
这项工作效率也会很低
我们来看GLKit这是另一个很棒的库我喜欢GLKit
它有显性矢量类型这样你就不必
使用原始数组但是函数却非常啰嗦
你必须要调用GLK矢量3乘以向量
来做算法这非常麻烦
使用SIMD是这样的效果
好多了 对吧？
你可以写下想用的算法它会发挥作用
你不必调用函数
生活真美好
那么这样就好多了
你还能做什么呢？
我们有浮点矢量 双矢量32bit整数2 3 4的长度
在C Objective-C和C++还有其他矢量类型可用
现在我们有了Swift的子集
我们选择这个子集是因为当你想用I/O模型
想使用图形内容这是编写Metal
程序最常用来与其他的库
进行互通的部分这些就是你希望可用的类型
这些类型可以用来做什么？
首先 你要生成它们
我们有一系列不错的起始程序你可以生成零矢量
可以显性规定矢量元素
可以有所有组件相等的矢量有许多不错的初始程序
你可以完成算法
可以有元素方面的算法算子也可以用
如果我用两个矢量相乘就会得到一个新的矢量
其中的每个元素元素的值
就是输入矢量对应元素相乘的结果
相除也是同样我可以用向量相乘
我可以进行向量点积向量叉积等等
我已经给大家看了一个实例我马上给你们再看一个简单的例子
这是个反射函数我可能会在图像中经常使用
它用1个矢量X它通过垂直于
标准矢量N来反射N
要写下它需要编写数学表达式
写下X减去2倍的X向量点积和N倍的N
你实际上不必写下这个函数 对吗？
应该已经有现成的可供使用
对的 我们有一系列几何着色器数学函数可供使用
我们还有向量点积向量叉积 反射 折射
距离 等等 所有这些你都会用到
如果你之前写过着色器程序
你就曾多次用过这些函数
这些都是在Metal或开放式CL或GLSL 
你所喜爱的着色器语言中的标准内容
我们还有浮点4类型的加速
的各类数学函数可用因此可以使用 V sign F
VCosf 用这些类型进行数学函数计算
我们还有矩阵和矢量
矩阵的类型是浮点数N乘以N 双精度N乘以M
N是列数M是行数
如果你是个数学家就会感觉很奇怪
如果你是图形编程人员这就很正常
所以大家会感觉轻车熟路
N和M可以是2 3或4但是不一定是正方矩形例如
浮点2乘3 是个两列三行的矩阵
同样 我们有各种初始程序
你可以生成零矩阵可以生成标识矩阵
可以生成对角矩阵
如果你想可以规定对角元素
如果你想还可以规定所有元素或作为数组的一列
或作为矢量的一列
各种很棒的内容
我给大家展示一个使用矩阵的小算法实例
我们在对角上用2s生成矩阵
这个矩阵当你相乘时可以用矢量乘以2
我们把最后一列进行调整 放入一些值
这是个变形矩形矢量乘以2
这也使用于偏差可以转化
我们可以把这个用于所有都是1的矢量
还可以用矩阵的反向属性
获得相反变形这样就可以恢复到最初的矢量从而取消变形
当我希望在两种语言之间互通时
可以使用Objective-CAPI 如你想要
调用的I/O模型 API
Swfit矢量类型与Objective-C
矢量类型在布局上兼容
我的意思是说它们在内存中有着完全相同的表现
编译器了解它们是相同的
这样你就不必考虑将Swift矢量类型
转变为Objective-C矢量类型或是将Objective-C矢量类型
转变为Swift矢量类型我这里有一个返回矢量SIMD矢量的
Objective-C API我可以立即将之用于Swift
对于矩阵而言我必须从我所获得的
Objective-C矩阵中初始化Swift矩阵
这是个成本很低的操作基本上是个拷贝
因为布局相同但是我需要调用初始程序
我希望将Swift类型传递给Objective-C时也是同理
我可以将所用
C矩阵属性的矩阵传递矢量
以获得Objective矩阵 可以将之传递给
Objective-C API
这就是SIMD
当配合小矢量和矩阵使用时SIMD效果很好
有时你也会需要使用更大的矢量和矩阵
我就要和大家谈谈LAPACK
BLAS 线性代数
这是很有意思的环节我们需要离开数学分支片刻
LAPACK和BLAS 是业界标准的数学库
这些是平台上部分最古老的API
也就是说看起来有些晦涩难懂
不过网上有很多文档资料
因为它们已经存在了近40年
很多情况下你可能会从
库中获取部分代码这就需要依靠这些API
只要连上加速效果很好
用起来很简单
线性代数是我们去年介绍的新界面
其中有更简单的API
来完成更常见的线性代数操作
这和上一个幻灯片是完全相同的操作
它在解析线性系统 
而不是用8个参数调用晦涩的函数
你调用LA求解 你提供需要解析的矢量和矩阵
非常好
在过去几年间 我们对LINPACK谈得很少
以及在线性代数方面我们可以实现多快的速度
LINPACK基准表明 对于系统线性等式
我们可以多快地求解？
这完全是我们在上一页幻灯片看到的操作
历史上而言该基准共有三种变体
开始是作为可以多快速地为100x100系统求解？
但是随着电脑越来越强大 速度越来越快
它不可能通过这样的小问题
显示自己的速度有多快 因此变成一个1000x1000的系统
如今 当人们谈到LINPACK
它们实际上不再构成阻碍
你可以随意选择所需的大矩阵来显示自己能实现多快的速度
当你看到超级计算机排名时
其中提供的LINPACK分数
都是百万x百万的量级
你尽可选择让你的速度可以最快的即可
几周前 我在网上看到
有人在说iPad Air 2的速度已经相当惊人
LINPACK可以实现每秒1.8个十亿次浮点运算 相当厉害
这可是每秒1.8个十亿次浮点运算
我知道这个数据不高
有人编写了简单的程式来解决
就是用编译器所能提供的内容
这就是实现的LINPACK分数
我在四周看了看看到有人在认真优化他们的
LINPACK程式他们编写了矢量代码
做了隐藏层还有多线程
结果实现了LINPACK每秒5.6个十亿次浮点运算
这要快上3倍改进更多
不用再去做所有这些工作
只需要调用加速即可
在前面的幻灯片中我展示了D获取RS和LLA解析函数
你可以编写一行代码
如果这么做 就可以实现每秒25个十亿次浮点运算
我们的确是想这么做
我们就是想为大家带来便利
我们希望让大家只需编写一行代码
而不是去着手优化每项内容
实现更好的能源利用更好的表现
而不需要做太多工作
现在有请卢克回到台上 他会介绍
当矩阵非常巨大时你该怎么做
谢谢 史蒂夫 我是卢克·常
是矢量数字组的工程师
今天我来谈谈Sparse BLAS的内容
BLAS代表基础线性代数解析程序
稀疏BLAS是稀疏矩阵的BLAS
这是iOS 9和OS X.11的新库
它是为简单的API和优良性能而设计
可以支持单精度和双精度
我们为什么需要稀疏BLAS?
我可以在已经了解具体工作方法的
稀疏BLAS上使用紧密BLAS吗
对的 它可以对不大的矩阵提供维数
但是使用Sparse BLAS在很多方面会更胜一筹
为了说明这一点
我来给大家展示一个典型的Sparse矩阵
这是机器学习的典型矩阵
有着1百万行和20万列
这就是提供了3000亿次的输入
但是矩阵的密度仅为0.05%
这里是视觉化稀疏矩阵的图片
蓝色部分越深密度就会越大
正如大家所见图片上很多区域都是白色的
这些都是零值
我们不希望把内存耗费在零值上
如果你是在常规的矩阵格式中
存储这个稀疏矩阵
你就可以使用常规紧密的BLAS
假设这是单精度数字 则会
占用1个太字节以上的内存这并不可行
你不会希望在手机和iPad上这么做
这样会节省内存此外稀疏BLAS 
还更节能速度更快
我们在MacBook Pro衡量稀疏BLAS的性能13英寸
密度为0.5%的稀疏
BLAS的能效要比紧密BLAS高18倍
性能方面要快15倍
随着密度的下降性能会提高
在密度为0.05%时这是我们在之前的矩阵
看到的密度在能效和性能方面
会比使用常规密度的BLAS高100倍
这样大家看出使用稀疏BLAS
有着许多强有力的原因节省内存能效更高速度更快
在稀疏BLAS中可以用到什么？
我们有产品 三角解析我们可以计算范数
L1 L2 L 无穷范数等等
我们会看到迹这是对角和
它可以交换行和列为矩阵增加新值
从矩阵中提取行和列
在我介绍操作之前
我们来看如何保存稀疏矢量
正如我之前所说我们不希望把内存浪费在零值上
我们保存非零值就像这样
然后我们需要了解这些非零值从何而来
因此我们保存非零值的指数
最后 我们需要了解我们保存了多少
这就是非零值非零值的指数
这些是稀疏矢量需要保存的三项内容
为了从常规密度矢量
转化为稀疏矢量Sparse BLAS提供了效用函数
帮助完成转化
如果想从密度专为稀疏则需要调用压缩
反之 则是需要调用解压
如果你需要了解非零值的数量
可以调用获取矢量非零值数量
现在我们来看稀疏矩阵怎么保存呢？
我们可以将稀疏矩阵视作行的集合
或是列的集合
如果我们压缩稀疏行稀疏列
或是忘记了行和列这就会非常乱
我希望将矩阵视作非零值列表 
每个非零值我们都会存储
列索引和行索引
还有许多其他保存格式 
每种都有自己的优势和不足
对于你所要进行的具体操作
可能会有最佳的保存格式
我们决定让事情更容易些
我们定义了稀疏矩阵数据类型
这是个不透明指针如果你想用的话
必须先用创建函数来生成
并且可以对其进行操作做完之后
必须销毁
这么做的好处是
我们可以为你管理内存
想在矩阵中添加新值时
你也不必担心分配新内存
或重新调整缓冲区或最后释放缓冲区
我们来做这些
更好的是我们可以选择最好的保存格式
例如如果你在稀疏矩阵中
插入一组行我们会按照稀疏行来保存
当你插入一组列时我们会按照稀疏列来保存
如果你想做特殊的操作
还有最好的保存格式我们也会自动转化为该格式
最后 这会让我们在API中
隐藏维数细节让API更为干净
当你调用稀疏函数时
你不必每次传递稀疏矩阵的维数
这里是个示例
首先创建稀疏矩阵
然后你会在稀疏矩阵中插入一个值
或是插入稀疏矢量作为行或列
然后提交稀疏矩阵的更改
在下一个幻灯片中我来讲详细介绍提交函数
完成之后要调用销毁
好的 为什么需要提交函数？
数据插入造价很高因为我们以压缩格式保存值
每次你需要在涉及数据移动的
压缩存储中
加入值就会涉及更多内存分配这样造价很高
我们需要延迟所有的数据插入这样可以分批处理
好消息是即便你忘记调用提交函数
当你在矩阵中进行操作时 
提交函数也会自动启动
现在你可能会问为什么要用提交函数?
如果想要控制代码性能
你显然要用到提交函数
加入你在app启动期间
让稀疏矩阵就绪这样app可以对
用户的数据 尽快做出反应
那么就要在启动代码中加入提交函数
这样相当好用
好 考虑到时间问题我只介绍稀疏BLAS中
最常见的两个操作
第一个是乘积C=AxB
我们支持矢量内积 矢量外积
矩阵矢量乘积矩阵矩阵乘积
A B C的类型是什么？
对于内积A是稀疏B为稀疏或紧密C为单一值
对于外积 A为紧密B为稀疏
结果C是稀疏矩阵
对于矩阵矢量和矩阵矩阵乘积
A为稀疏 B为紧密C为稀疏
你需要两个稀疏矩阵乘积的情况非常罕见
因此不做支持
这里是矩阵乘积的函数原型
稀疏函数的命名规则是先
是下划线稀疏后面是我们要做的操作在本例中是矩阵相乘
紧密是指BC为紧密浮点是数据类型
你将会返回成功或错误代码
这个函数的参数正如常规BLAS
你规定B和C的次序是列主序或行主序
你来表示自己是否需要将A换位
B和C的列数 其余则和BLAS一样
下一个操作是三角解析
你来为三角系统等式求解
T必须是上或下三角矩阵
我们支持紧密紧密矢量或B矩阵
主要注意的是上或下三角
属性必须在进行数据插入前设置
这里的代码就是强调这一点
设置矩阵属性需要在进行任何数据插入前完成
在数据插入后可以调用三角求解
参数则和BLAS一样
总之稀疏BLAS是和简单API一起设计
它有着非常广的操作范围
性能也很好
好的现在就来总结一下讲座内容
我们今天介绍了三个新库
用我们的新压缩器LZFSE进行压缩
现在 你可以在Swift上
使用SIMD还有稀疏BLAS库
它们有着共同的设计目标
都是速度更快能效高便于使用
我们鼓励大家试一试让我们知道你们是怎么想的
我们很希望能听到大家的反馈
我们对开发人员的要求和反馈都认真对待
实际上 我们添加到加速框架中的许多功能
都是根据开发人员的要求进行的
如果你发现自己想用的功能没有
请填写功能申请
若想了解更多详情我们还有vDSP和
压缩的在线文档资料
如果想了解加速框架的其他内容
可以看看我们以往的WWDC讲座视频
我们还有压缩vDSP的简单代码
还可以参加论坛讨论
如果是一般性咨询可以联系开发顾问保罗·登博
这里就是相关讲座我们介绍过I/0模型
Metal Swift 如果想了解更多详情
可以去找这些讲座的视频看看
就是这样
感谢大家光临 希望在实验室见到大家
非常感谢！