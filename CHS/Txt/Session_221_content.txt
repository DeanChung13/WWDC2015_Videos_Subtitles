改善全屏窗口体验
嗨！
欢迎莅临《改善全屏窗口体验》专题讲座
我叫 Corbin Dunn是一名 AppKit 软件工程师
今天我将与我的同事Taylor Kelly一起完成这个讲座
就让我们直入主题吧！
那么我们今天要讲些什么呢?
首先我要讲的是全屏幕
它将包括三个部分
我将讨论全屏幕的采用
以及如何正确采用
我将谈到标题栏附件视图控制器
它们是什么以及如何使用它们
然后我将讲一下全屏幕平铺 API
查看并利用一些大家已在
Mac OS 10.11中看到的新特性
Taylor将会上台 并讲一下
Split View控制器内的灵活布局 自动布局 堆叠视图
并在最后讲下关于集合视图方面的内容
那么 全屏幕
全屏幕的目的是什么？
它是为了让您的用户将注意力集中到某个单一任务上
您可以充分利用您的屏幕空间
其他一切都靠边站
您要全神贯注于一个窗口
那么我们为何使其成为一个系统特性呢？
我们使其成为一个系统特性
因为它一种非常一贯的用户体验
你进入全屏幕的方式
你退出全屏幕的方式都是一样的
你在不同的位置之间导航定位的方式等等
那么 什么是“可全屏化的窗口”？
这里有一个Safari窗口的例子
我肯定您知道只要点击绿色按钮
它就会把您带入全屏状态
一旦您进入全屏状态您可以将鼠标移到窗口的上方
标题栏和工具栏将会向下展开
而你可以再次点击绿色按钮
它将把你带回全屏状态
那么为了采用全屏幕需要做些什么呢？
希望大家已经对此有所了解
不过它是相当容易的
您将指定哪些窗口是您希望可以全屏化的
您将为它增加一个菜单项
而且你很可能会做些额外的事情
你可能希望做的额外的事情
是自动隐藏您的工具栏修改您的内容
以便更充分地利用全屏幕带来的空间
利用新的标题栏
辅助视图控制器
而我将谈一下如何以及为何我要那么做
当然 您希望进行很好的全屏平铺操作
因此我将讨论一些我们已有的API来实现那种效果
首先 有两种类型的窗口
或者实现全屏化有两种可选窗口
通常当一个窗口是全屏时
就不允许对其进行进一步操作了
而那样的窗口也是我们所谓的“主窗口”
它是您的应用的
主文件窗口
它是您能够使其全屏化的东西
然而还有另一种选择如果你已经看到它的话
那就是“辅助窗口”通常你并不需要这个
它的目的是什么？如果你在某个应用中有一个窗口
想要占据另一个应用的全屏空间
它允许你那么做
我不会讨论这方面
而我鼓励您查阅几年前的AppKit  版本说明
了解关于它的一些细节
那么您如何采用全屏窗口呢？
在Xcode和InterfaceBuilder中它非常简单
您选择您的窗口有一个FullScreen(全屏)部分
您将菜单项下拉
就有主窗口和辅窗口的选项
那么您将很可能希望
在您作为主窗口的全屏窗口上设置主窗口
当然您也可以用代码实现,而在InterfaceBuilder选项下
它所做的不过是修改
window.collectionBehavior
而它将向窗口添加.FullScreenPrimary
或.FullScreenAuxiliary
以便让那些选项进入窗口并让窗口实现全屏化
一旦您进入全屏状态您可能需要
做各种基于全屏幕的事情
而且您可以通过查看样式蒙板进行检查
就是当您的窗口进入全屏的时候
我们添加
NSFullScreenWindowMask
而且您可以在样式蒙板中查看
您的窗口是否处于全屏状态
并有可能做其他的事情
现在让我们谈下如何自动隐藏工具栏
通常如果您在窗口内有一个工具栏
它总是可见的就像这里显示出来的一样
当您把鼠标移到窗口的上部
菜单栏会向下展开
标题栏的控制按钮向下展开
从而露出了工具栏
有一个选项可以让您将工具栏自动隐藏
所以当你进入全屏的时候其他什么都看不到
而你可以最充分利用您的屏幕的空间
当您将鼠标向上移动到菜单栏的时候
工具栏会与菜单栏和标题栏一起
同时向下展开
这确实是很容易做的
有一个windowdelegate方法
Window.WillUseFullScreenPresentationOptions
再加上 proposedOptions
您选择那些建议的选项并且增加AutoHideToolbar并将其返回
而工具栏将自动隐藏
因此是非常容易的
那么然后是自定义动画您可以创建全屏进入和退出
自定义动画
我们有两种delegate方法实现它
customWindowsToEnter
FullScreenForWindow
这种方法可以返回一系列的窗口来实现您的动画
然后我们把您叫回来说 嗨！
开始您的自定义动画进入全屏状态吧
并请指定持续时间
关于这些操作我们需要注意的一点是
在 Mac OS 10.11 中通过我们进入全屏的方式
您可能不会让这些参数得到调用
因此重要的一点是
不要依赖这些参数一直被调用并设置状态
相反 有更好的方式实现过一会儿我将讲到这些方式
好了 关于全屏幕以及如何正确采用就讲这么多
让我们继续往下进行
谈一下标题栏辅助视图控制器
那么在我讲标题栏辅助控制器之前
让我们先看一下全屏幕窗口
而且我将对标题栏区域突出显示以便于您觉察到它
那么这就是全屏中的标题栏
在标题栏下面是工具栏
而在工具栏下面是我们所谓的“辅助视图”
那么您可以在窗口中的这个位置增加您自己的标题栏
辅助视图控制器
好在窗口不是全屏状态下
也能添加它们
那么这就是在窗口不是全屏状态下它们看上去的样子
然后它们被自动地反复管理
为了理解这种模式的重要性
最好先理解我们为什么会用这种模式
那么让我们看下您的窗口
通常 在工具栏和标题栏下方的区域
是内容被替换的地方
您的内容就在它下面
但是从Mac OS X.10 开始
您可实际利用一个完整的内容区
它可以在标题栏和工具栏下面扩展
那么您的标题栏
和工具栏将会在它后面自动为您进行模糊化处理
而您可以在这个位置为您的视图
放置全屏辅助视图控制器
那么您怎样才能实现那种全屏蒙板效果呢？
它真的是很容易的您只需在window.styleMask后面
加上NSFullSizeContentViewWindowMask
而那将让您的内容在标题栏下以全尺寸显示
用于使用标题栏辅助视图控制器的实际API
这些控制器是NSViewController的
一个非常简单的子类
因此所有的标准视图控制器
将会与它互动决定如何加载它们
而它增加了两个属性一个是layoutAttribute
另一个是FullScreenMinHeight
过一会我将谈到它们
但是让我们看一下
标题栏辅助视图控制器能为您做的几件事情
正如我以前所说的
它们将自动为您模糊化处理它们后面的一切东西
您无须做任何特别的事情
它自动以某种视觉效果为您呈现
那就是实际的模糊化处理
它们自动以全屏状态显示
因此当您的窗口进入全屏或退出全屏时
它们被放置在正确的位置
而且在某种程度上它的大小也是自动为您管理的
而我们稍后将讨论这个内容
那么让我们看一下第一个属性layoutAttribute（布局属性）
那么这里就是布局属性当它被设置为“.bottom”时
“.bottom”的意思是您的视图
将被放在标题栏的下方
它的高度是您在NIB文件中为该视图实际指定的任何高度
或者是您以任何方式指定的高度
而宽度会随着窗口大小的更改而自动变化
另一个选项是 “.right”
这是一个 Safari 的例子
他们在使用 “.right” 选项
以便当Safari窗口处于非全屏或全屏时
向Safari窗口添加 “+” 按钮
宽度是视图已经指定的任何宽度
而高度则是自动设定为标题栏或工具栏的高度
Mac OS 10.11 的新特性还包括指定一个“.left”的能力
通过它 你可以把项目
放在窗口按钮旁边
所以您可以在这里添加一个注册按钮
或者您希望向用户展示的其他备注
而这就是X.11的另一个新特性
接下来我们有全屏幕最小高度
让我们看一下那个属性
那么全屏幕最小高度是什么意思呢？
这个属性仅当您
已处于全屏状态时才适用
而这就是您在全屏状态下
能够看见的最小高度
当您将鼠标移动到工具栏之上时
任何未被显示的内容将被自动显示
过一会儿我将向您展示那种情况的一些屏幕快照
工具栏的默认高度为 0
那么让我们看一下它的意思是什么
那么 全屏幕最低高度为 0
这里是一个工具栏
那里是一个辅助视图控制器但它是隐藏的
因为高度为 0
如果高度不是 0
您在那里将总是会看到您设定的任何值
用户让其显示的方式是
当你把鼠标移到菜单栏上部时标题栏将被显示
而您的全屏辅助视图也将随其自动显示
那样将把该部位突出显示
如果您已经用过 NSToolbar您可能已经熟悉了
NSToolbar实现的全屏辅助视图
而这个新的标题栏辅助视图控制器取代了这个旧的 API
因此我们不鼓励您再使用它
但是最小高度和最大高度属性的工作原理
与标题栏辅助视图控制器里面的非常类似
那么您如何实际添加它们呢?
我们在 NSWindow 上有四种方法
我们有一系列的标题栏辅助视图控制器
您可以读取窗口的附件
您可以添加它们
您可以将它们作为特殊索引插入
而且您也可以将其作为特殊索引删除
但它确实是容易添加和删除的
那么这里是您通常将要做的事情
您将调用Window.AddTitleBarAccessoryViewController
将您的辅助视图控制器传递给它然后当您希望去掉它时
您将使用默认的NSViewController API
将其从父视图控制器中移除父视图控制器自动确定它的位置
并将其移除
关于标题栏辅助视图控制器就讲那么多
让我们谈一下全屏幕平铺
以及 Mac OS 10.11里面的一些新特性
那么全屏幕平铺的目的是什么？
它们仍然让您或用户的注意力
集中在某个单一任务上
但是它可能涉及到多个窗口
您必须利用屏幕的全部空间
那么在这个屏幕快照上我们有Safari浏览器窗口
在边上有提示信息让我们同时关注几个任务
那么让我们看一下当您实际处于这一状态
并调整分割器大小的时候会发生些什么
请注意 随着我改变其大小Safari窗口达到了最小状态
并且提醒栏也达到最小状态
而且对于一个给定窗口不会让它收缩得太厉害
因此它有一个可以达到的最小和最大状态
那么我将谈一下如何实现
以及您需要做些什么
但是让我们先讨论一下什么样的窗口
可以进行全屏幕平铺
我们将明确允许任何窗口
进入全屏平铺只要它的大小可调并且不是面板
那意味着你的窗口不必
一定是可全屏化的
但是它仍可以被添加并平铺到
另一个可全屏化的窗口内
具体我们做些什么
以及如何确定都会随时间改变
因此您可能希望让这个过程更明确
那么让我们假定您有一个可调整大小的窗口
它无法被放入平铺窗口而你希望将它放入平铺窗口
您可以在collection Behavior后
明确添加FullScreenAllowsTiling
使其能够被放入平铺窗口
类似地 您可能有一个窗口
您希望它永远不被放入平铺
那么我们就规定...它可以被放入平铺
但是您不希望它被放入平铺
因此您可以让FullScreenDisallowsTiling
来防止它被平铺
此外 您可能有一个窗口您让它全屏化
而且希望它总是独立状态您可以在那个窗口上设置
FullScreenDisallowsTiling
以防止任何其他窗口与它放在一起
那么现在您了解了如何
让一个窗口进入平铺
让我们谈一下那个窗口的
最小和最大尺寸
通常 当您的窗口未处于全屏状态时
您可以调整其大小并且自动受到
其最小和最大尺寸限制
而当你使用 AutoLayout 时那通常是由 AutoLayout
自动确定的
如果您没有使用 AutoLayout
那么窗口的最大和最小尺寸就发挥作用了
那些只是显示的
您在窗口内设置的属性
或者是内容的最小尺寸或者是内容的最大尺寸,
都取决于您使用的API
如果您选中一个窗口并准备将其全屏化
或者您准备全屏平铺那些就是您
通常应该使用的API
但是那个规则也会有例外
而我们有更多的API来解决例外
首先让我们谈一下该规则的一个例外以及您将做些什么
那么这里是可能是一个小的
计算器应用
它的尺寸是不可调整的
那么这位开发者就可能说好吧 我们将让它
放入平铺
但是当它被放入平铺的时候如这里所示
现在那个计算器应用的高度比以前高了很多
即使它是不可调整大小的
因此它需要对其进行处理并做些特殊的事情
您可能还会在那里加些额外视图以便在其全屏平铺时
向用户显示更多信息
因此您可以动态实现这种效果
而且您只是使用一些window delegate方法
WindowWillEnterFullScreen
而在这种特定情况下当我们进入全屏模式时
我们将取消一些视图的隐藏状态
更改一些约束优先级
当窗口处于全屏化时它们让系统对窗口大小
实际进行调整
而当它退出全屏幕时它再将那些工作取消
重要的一点是知道你实际可能必须
使用这些 delegate 方法即使您的窗口
通常并不构成一个全屏幕主窗口
因此这可能是为一个平铺窗口调用
现在那些窗口在进入全屏状态之前
它们的尺寸是尤其厚的
但是当它们处于全屏状态时尺寸就不同了
当它将进入全屏状态时您很可能
需要告诉系统那些尺寸
那么我们有一个显式API来实现
我们有一个minFullScreenContentSize
和一个maxFullScreenContentSize来实现
您需要及早设置这些参数因为如果您
曾经尝试 Mac OS 10.11您可能注意到当您点击并
按住绿色按钮不放的时候系统会为您提供
尺寸符合可用空间的其他备选窗口供您选择
因此 作为开发者您需要及早设置这些最小值
以便让系统能够确定
适合该区域的潜在备选窗口
正如我以前所言通常您不需要使用这些设置
当您的窗口正好是通常的尺寸可调窗口的话
它们在很大程度上是自动的
那么这就会导致一种两难困境
如果您的窗口尺寸比如说是1200
而另外一个窗口窗口 B 的尺寸是 300
会发生什么?
那么系统将不会
让这两个窗口在一起
它们的minFullScreenContentSize值太大
而无法实现
那么作为开发者您需要做些什么呢？
对于这方面我将请上我的同事Taylor Kelly
他将会讨论如何通过灵活布局
而解决那个问题
谢谢大家！
大家好！
在这下半个环节中我们将讨论
如何让您的布局更灵活
尤其当它们处于新的SplitView中时可以被调整到多窄
在 Mac 平台上我们有多种显示尺寸
供您的应用在其上运行
而在全屏状态下用户能够将其自身全部浸入
占据整个显示空间
在Split View下用户现在可以让另外一个窗口
进入这个环境从而营造一种更丰富的体验
但是这要求两个窗口灵活的
其尺寸大小可以调整
以防止出现冲突的情况
Corbin 早些时候也谈到了这一点
这对于较小显示尺寸如Retina MacBook
可能是尤其严格的
它的默认分辨率为1280*800
表示在Split View中
当平均分割时每个窗口大约被分配638
每个窗口大约被分配638个点
如果您的应用的最小宽度
目前比这个大这些显示尺寸的用户
通常将不能将您的应用平铺
因此我将谈一下您可以使用的四种技巧
以确保您的窗口在全屏状态下有令人满意的表现
首先 是使用自动布局和优先条件
其次是自动折叠的新侧栏行为
然后是使用 NSStackView轻易地构建
您的界面的各个部分同时将灵活性内置其中
最后是更新过的NSCollectionView
它有了强大的布局支持
那么自动布局是一个我们在OSX Lion和iOS 6中
推出的基于约束条件的布局系统
它让您声明不同的UI 元素之间的关系
比如它们的间隔或者对齐
而它确实是强大的
窗口的视图尺寸被动态调整
比如在进行本地化的时候
您可以在这些约束条件之间建立优先顺序
让级别高的优先于级别低的
对此我将不去过多讨论细节
今天早些时候有两个讲座
《自动布局的奥秘》的第一和第二部分
不管您在自动布局方面是初次接触还是已有接触
它都有一些确实不错的内容
相反 在这个 UI 例子中
我将重点关注优先顺序
我们在中部有一个标签它的左右两侧
都有固定按钮
这些可能是您会用来创建那种效果的水平约束
仅仅使用这些约束的话如果视图的尺寸动态调整
您最后可能会让标签和较宽的按钮相互重叠
这是非常容易解决的
您可以在按钮和标签之间增加一个最小间隔约束
而现在当容器的尺寸调整时
它的尺寸只能调整到
它能同时满足居中对齐和最小间隔的程度
这是一个完美的布局除非这个视图
能够变得更紧凑
去掉较窄按钮和标签之间的	那些空白就太好了
回过来 我们可以让这个居中对齐成为可选条件
意思是它可以被更优先的约束条件打破
此外 我们将会在标签和较窄按钮之间
增加一个最小间隔以防在那一侧出现重叠
这次 标签尽可能居中
直到它触及了最小间隔的填充
而如果我们继续调整容器的大小我们可以打破居中条件
以便最大化地压缩布局
直到我们满足两侧的最小填充
您可以仅仅通过设置优选顺序属性
来为您的约束条件进行这样的设置
而这也通过InterfaceBuilder暴露出来
默认情况下 需要满足约束条件
就是说它们必须被满足
但是任何低于那个的约束条件将成为可选的
我们有些要点帮您决定您的约束条件
优先顺序应该是什么样子
另外还有Default Low它是一个优先条件
通常您的约束条件弱于大多数其他约束软件
还有DragThatCannotResizeWindow
它是一个特定的优先条件
在此条件下一个SplitView分割线会被拖动
如果您希望自己的约束条件
比这种行为更加强大您应让您的优先条件级别更高,
否则更低
您通常永远不会设置跟这个完全一样的优先条件
此外还有WindowsSizeStayPut
这个优先条件规定一个窗口维持当前的尺寸
最后是DragThatCanResizeWindow
在这个条件下一个窗口被拖拽
但是还有 Default High它是另外一个优先条件
在此条件下您的约束条件
通常高于多数其他条件
那么这就是Auto Layout的优先条件
在此后的几个部分内
我将回过头来参考一下优先权的概念
但是接下来我想谈一下NSSplitViewController
这是我们在Yosemite中推出的一个容器视图控制器类
它让您的子视图控制器
被安排在 NSSplitView 内
并且暴露了NSSplitView 项目的概念
它概括了那些在SplitView中的子类的状态
这些子类包括holdingpriority
Collapsed状态而且它允许以一种真正简单的方式获得动态折叠效果
去年的OSX Storyboard和控制器讲座更多地讨论了
这个特性以及其他视图控制器特性
但是我想重点谈一下OS 10.11中的新内容
首先是侧边栏的显式概念
及其伴随的特殊行为
以及spring loading它是当一个项目
被在Split View中拖拽时可能发生的行为
以及几个新的度量指标
它们让您在调整大小期间精确地声明
Split View的行为
我们看一个例子这里是 Safari 中的侧边栏
随着窗口尺寸的调整一旦它达到某个点
侧边栏将会自动折叠
而如果它在全屏状态被重新显示
它将覆盖其他窗口内容
这个过程是短暂的类似于弹出框
因此点击其外侧将使其自动消失
这真的是容易理解的
您只须在NSSplitViewItem上
使用sidebarWithViewController这一构造函数
或者在InterfaceBuilder中将行为传递给侧边栏
这将返回给您一个split view项目
您可以把它添加到您的split view控制器上
而且它也伴随一些特殊行为比如 Yosemite 中将推出的
内置的半透明材质背景和醒目的分割线
您不必再加入您自己的视频效果视图
才能获得这种效果
NSSplitViewItem将会为您进行添加和管理
此外还有您刚才看到的
autocollapse和autouncollapse行为
通过它 覆盖层将占据整个屏幕
此外还有另外几个默认属性
以及侧边栏的标准值
因此您的侧边栏对系统的行为正如其他要素一样
伴随它的还有一个split view方面的
新的行为方法即 toggleSidebar
它将具有动画效果地折叠或
展开它包含的第一个侧边栏
通过这种方式 无须书写一行代码
您就可以关联菜单项使其具有这种效果 或切换按钮
另外一个确实很酷的行为是spring loading
这是当用户在您的splitview边缘上存在折叠窗格
并将一个项目向该边缘拖拽时发生的行为
我们将平移并让侧边栏展开
让它们与其互动在它们的动作完成之后让侧边栏再次折叠
您可通过将springLoaded设为True来达到此效果
在您的split view项目中您将获得此行为效果
且对侧边栏和非侧边栏同样适用
区别在于侧边栏将默认为 True
我们认为大多数的侧边栏将希望这种行为
接下来我想谈一下我们在NSSplitViewItem控制器上的
几个新的度量指标
我将每次讲两个
首先是minimumThickness
和maximumThickness
这些与split view项目正在自我管理的
约束条件直接相关
它们描述了这个项目可以实际变得多大或多小
侧边栏将默认将这些值设为标准值
但这的确是一个
您自己设置约束条件的非常方便的方式
HoldingPriority是OS 10.11中惟一的一个不是新的度量指标
它描述了split view 项目
维持其当前大小的一个优先权
在本例中侧边栏被默认设置为
一个略高的值因此这意味着它们比其他项目
被调整尺寸的可能性更小
那么作为一个例子当它调整此窗口大小时
尺寸调整的全部权重都分配给了内容区
而侧边栏的宽度保持不变
回顾一下 你可能也将这个
设置为在两个项目间
具有同样的保持优先权
如果您熟悉自动布局您可能将这种情况
认为是一种模棱两可的情况
但是NSSplitView会对这种情况进行特殊处理
这次当您调整其大小时
两个视图会根据它们在尺寸调整之前的大小
按比例地调整大小
因此两个视图都尺寸都被调整得稍微大一点
那就是 holdingPriority
下一个度量指标是preferredThicknessFraction
它描述了某个splitview项目希望占据的空间
占split view的理想百分比
例如 侧边栏被默认为15 %
当用户进入全屏状态或双击分割线的时候
该项目将自动跳到那个首选厚度
它们的确非常容易地就能恢复到那一标准值
作为一个限值 自动最大厚度对所有这些尺寸调整行为
都发挥作用
如果15%对应于350的话
那么它将被限制为不超过280
那些是NSSplitViewItem度量指标
在NSSplitViewController上还有另一个度量指标
那就是用于内嵌侧边栏的minimumThicknessForinlineSidebars
它描述了您的split view控制器中侧边栏将自动折叠的宽度
因此 将尺寸调整到那一数值将让它们保持内嵌状态
进一步拖拽将让您的侧边栏折叠
这也适用于全屏幕状态
关键区别在于当处于全屏幕状态时
如果它总是被明确重新显示它就被显示为叠加状态
这说明了全屏状态下的一个重要概念
在全屏状态下我们希望避免让窗口运行
以防止和相邻元素的可能的冲突
在您的窗口内重新安排各个元素
总是比扩大窗口要好
为支持NSSplitViewController中的
这样一些新特性我们已经对 NSSplitView
做出了一些改进具体而言是通过对子视图的排列
在 El Capitan 之前
split view中的所有子视图都被视为分割开来的窗格
这意味着管理它的 API
只是从NSView继承来的子视图 API
这是方便的但是也带来了两个确实很大的问题
一个问题是您不能增加
您不希望被视为分割窗格的子视图
例如 分割线
在此模型中分割线不可以由视图表示
此外 您不能将 Z-顺序
与子视图的排列顺序区别开来
因此您的零索引子视图是按Z顺序的第一个也是最下的
而没有办法将它们区别
因此 现在在10.11中您可以指定一定的子视图
作为使用NSSplitView的新API而创建的split view
所排列的子视图
在管理已被排列的子视图方面这个API与NSStackView的API
和UIStackView的API精确匹配
此外还有这个属性ArrangesAllSubviews
它默认是 True
意思是说您的子视图仍总与被排列的子视图相同
并且匹配那种遗留行为
即使您将此属性设为FalseNSSplitView 仍会确保
您的已被排列的子视图
永远是子视图的一个子集
例如 如果您添加了一个还不是子视图的
被排列的子视图它将被添加为子视图
最后 我们鼓励您开始使用被排列的子视图
并将ArrangesAllSubviews设为False
因为当您那么做的
时候NSSplitView现在能够使用视图
代表分割线并为分割线的醒目性
和特殊的窗口拖拽行为创造条件
您可通过Interface Builder控制它
选中这个ArrangesAll Subviews 复选框
更新后的 NIB 文件将选中此复选框以匹配遗留行为
但是从对象库里面拖拽出来的新的split view将不会将其选中
这也是将来我们鼓励的行为
为了帮研究您目前在split view上可能有的问题或试图理解
您的split view的工作机制
我们已经改进了对调试的描述以便告诉您
诸如它如何执行布局
以及它将用什么代表它的分割线
关于布局 有几种可能性
但是我们建议确保split view使用约束条件
这让它简单地描述它的分割窗格之间的关系
并与您在窗口中的其他约束条件互动
此外 它将允许对您的split view窗格的
从右到左的翻动
而且我们也建议...
开始使用视图代表分割线
原因如我以前所述
为了帮助弄清楚为何您的split view可以或不可使用约束条件
我们已经添加了这个DebugReasonForLayoutMode
它将给您提供具有可读性的描述以便了解它是否会使用约束条件及其原因
最常见的原因是Delegate将优先于特定的
与自动布局不相容的方法
而且将准确地告诉您那些方法是什么
它是否在一个使用自动布局的窗口内
还将决定它是否可以使用约束条件
最后如果它正在被NSSplitView Controller使用
则要求它使用约束条件
而如果您曾试图调试splitview的一些布局问题
并已输出约束条件
它很可能看上起像是这样
它是很难解读的
如果您确实希望理解它您必须画一张图
您无法很好地辨别哪些约束条件是您的app添加的
哪些约束条件是框架添加的
在OS10.11中NSSplitView目前为所有它添加的约束条件
给出识别符
因此您不仅可以辨别您在使用哪些约束条件
而且还可知道它在试图用那个约束条件做些什么
您可以快速地辨别
您的app添加了哪些约束条件
或者是否有怪异的您无法确定在发生什么的
尺寸调整行为您可以快速地看出
哪些约束条件可能会解决那一问题
NSStackView有适用于其每个约束条件的
类似的识别符
现在我想谈一下NSStackView
这是一个我们在 Mavericks中引入的类
它确实简化了
使用自动布局进行的水平或垂直视图堆叠
它完全与您在窗口中使用的其他约束条件相容
但是它会管理它使用的所有约束条件
来创建堆叠
因此您可以添加或移除视图而不必担心
对那些约束条件的更新
它内置了对齐和分布的概念
因此您可以控制您的视图
在堆叠视图内的放置方式
以及剪裁和附加行为因此当堆叠视图
试图建立比它所包含的视图更小的视图时
您可以控制发生的事情
此外 在 10.11 中我们做出了一系列性能改进
降低了它使用的约束条件的数量
并且从使用内部专用视图转换到使用 NS 布局指南
而我们已经看到一些非常不错的性能改进
《自动布局的奥秘》的第一部分谈到了这一点
和新的UIStackView 在 iOS
以及对我们现在所拥有的
新的InterfaceBuilder的很好的支持
我的确想重点谈一下新的分配形式
它们描述了堆叠视图如何沿着堆叠轴排列
您可以通过NSStackView的Distribution属性
对此进行设置我将逐一说明它们是如何工作的
那么GravityAreas匹配10.11 版本之前的行为
通过它您可以指定特定的视图被吸引到split view的
特定的边缘
对于水平方向有领先 居中和尾随
对于垂直方向有顶部 居中和底部
那么在本例中随着我们让堆叠视图的增加
这些视图将趋向于朝边缘移动
.Fill 是一个新的行为它要求各个视图
将堆叠视图完全填充
而通过使用其他约束条件您可以决定它们的增长方式
或尺寸分配方式
在本例中 Tiny 已经设置了最低的拖拽优先权
因此随着我们让堆叠视图的增长
它获得了全部的尺寸调整权重
.FillEqually 是类似的
只是现在堆叠视图将增加约束条件
各个视图将有相同的尺寸
在本例中 我们将增加更强的约束条件
以便将堆叠视图向下挤压
而且它将优先于这些均等填充的约束条件
但是随着我让堆叠视图增长
它们趋向于朝着尺寸均等化发展
.FillProportionally也是类似不过它们是
根据其自身内容的尺寸按比例增长
那么在本例中较大的视图增长得更大
而更小的视图增长不多
.EqualSpacing是一种分配方式根据此方式
获得额外尺寸的并不是视图
而是视图之间的间隔
在本例中随着我们让边缘之间的间隔增大
各个视图之间的距离都被调整到相同大小
.EqualCentering也是类似不过在这里
不是视图边缘之间的间隔
而是视图中心的间隔被调整到相同
有了这些新的分配行为
我们认为您可以将堆叠视图用于您的 UI 中的更多地方
而且真正从它所带来的变化中获益
堆叠视图的另一个方面是剪裁行为
堆叠视图可被默认增大到
包含所有其他项目所需的最小尺寸
但是您可能也需要设置剪裁抵抗优先权
让视图根据该优先权剪裁其内容
所以 现在我们的堆叠视图可以被调整到小于它的容器
通常您并不希望对视图进行这种部分剪裁
但这比视图被完全丢弃的情况要好
您可以通过为不同视图设置可见性优先权进行控制
一旦堆叠视图开始剪裁其中的视图
有最低可见性优先权的视图	将被完全丢弃
在本例中我们将设置由高到低的顺序
以便随着堆叠视图开始剪裁某一视图
它只是暂时性的完全脱离
因此在本例中第6个不再看得见了
如果堆叠视图再次增大
它将重新附加这些项目因为有了足够的尺寸容纳它们
此外 当这种脱离或重新附加发生时
您会获得回调告诉您脱离或重新附加何时发生
以便于您对您的UI的其他部分做出可能的调整
比如增加一个溢出菜单
接下来我想快速地概述一下
最新更新过的集合视图
现在它与 UI 集合视图有等同的特色
包括项目的可重用性
因此 对那些本部分支持的项目的大型集合
您可以有真正可扩展的呈现方式
此外 有一些真正强大的布局支持
所以不管您的集合视图的尺寸多大它的行为都是极其良好的
包括内置的网格布局
与 iOS 匹配的流程布局
以及创建您自己的定制化布局的能力
Troy 将在今天稍晚时就此做一个很棒的讲座
名为《集合视图中的新特性》
我真心建议您看一下
与此讲座相关联的还有示例代码
它是一个图片浏览app
展示Corbin和我谈到的各种特性 API 以及行为
例如 它展示各种全屏 API
尤其是最新的平铺 API
我们这个单独的小窗口
通常被要求尺寸符合宽高比
而且可被全屏化
然而 我们让它可被平铺
且一旦处于平铺状态便会有自定义布局
它还采用了最新的split view 控制器特性
比如带有覆盖效果的自动折叠侧边栏
以及 NSStackView
它使用零约束条件创建了这个底部工具栏
的的确确是很棒的
它还使用脱离行为
以便能够让菜单调整到更小
并显示这个小巧的溢出菜单
以便用户仍能使用那些被隐藏的菜单项目
它还使用经过更新的NSCollectionView
用于显示这个小图片网格它的表现非常可靠
那么 Corbin 带我们概览了Full Screen 的各种特性
比如如何在我们的应用中采用全屏
以及使用标题栏辅助视图
让那些在工具栏下方的标题栏在全屏幕状态下有真正不错的表现
此外 他还向我们展示了一些全屏幕平铺 API
以便让我们能够确保
我们在特定情况下的窗口是否在全屏状态下表现正常
最后是一些确保我们的布局真正具有灵活性的方法
尤其是在这种狭窄环境下
比如将新的标题栏与Split View控制器
自动布局和NSStackView配
合使用以在您的UI的其他部分构建灵活性
而NSCollectionView有真正很棒的对布局的支持
若您有任何问题您可以联系 Paul Marcos
他乐于接收电子邮件
此外我们还有一些相关的讲座环节我早些时候也提到了
现在它们已经都讲完了但是您可以在视频上观看它们
此外 我们今天晚些时候还有一些实验室活动
有的正在进行中有的将在今天稍晚和明天进行
如果您有任何问题敬请提出
祝您在WWDC上有美妙体验敬请欢享盛会！
回头见！