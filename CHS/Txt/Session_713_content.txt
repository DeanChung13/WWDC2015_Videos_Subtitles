Watch Connectivity介绍
早上好
欢迎来到Watch Connectivity介绍
我叫克里斯
今天 我的同事亚历克斯将和我一起 
他随后会上台
我们很兴奋为你们展示 
我们一直在watchOS 2和iOS 9上做的东西
今天 我们要说的是 
帮助你们为Watch app做出
更好更有反响的用户体验
为了简单说明我们的出发点
watchOS 1上的世界看起来像什么
之前iOS app和WatchKit扩展都是依赖
iPhone的 且当时主要处理的是WatchKit app通信 
而且这二者都可以共享数据存储
在watchOS 2 我们已经把WatchKit扩展
扩展到Watch之上 app在Watch可以运行更流畅了
这有不少的好处 
但是也意味着它们都各自使用自己的数据存储
显然 下个问题是 我们如何把数据 
搬到Apple Watch上 
这是我们今天要讨论的内容
我们将为你展示解决这个问题的两个主要方法
如何将数据移到Watch上 
这是新框架WatchConnectivity
我们将它引入了watchOS 2 和iOS 9
然后这是可在Foundation上获NSURLSession API
也适用于WatchKit扩展 
也已经集成到watchOS 2 
我想今天要讨论的话题适用于
大多数Watch app 对于多数人来说也是适用的
今天展示中即将用到的大量示例
将会证明这一点
你可以看到 这个范围很广 我们希望每个人
都可以至少辨认出一种
我们先讨论WatchConnectivity
这是我们引入watchOS 2 和iOS 9的新架构
它在两个平台中都适用 
几乎所有的API在两边都适用
我们将会看到不少iPhone专用的 API
当你开始采用WatchConnectivity
你想做的第一件事是
仔细设置
我们建议尽早进行设置
在使用app的整个过程中 在两方面都要
在Watch运行的WatchKit扩展和在iOS 9 app内部
你要确保使用代码路径进行设置
这样一来 尽管是在后台启动
也还是可以被执行
所以不要把它放在里面如视图控制器View Did Load内
因为当你在后台启动时 这些是不会被调用的 
所以在iOS app中
你做的第一件事是查看
是否支持WCSession  
你或许有一个通用的iOS app
意思是代码可以在iPad上执行 
iPad无法使用WatchConnectivity
你在Watch上执行任何工作之前 请事先检查一下 
因为我们不想你浪费CPU做无用功
下一件事情是创建一个对象实例 
你可以通过调用Default Session进行创建
然后在会话对象上设置指派 
最后调用Activate
滴啊用后就可以继续设置WCSession对象 
初始化所有属性 而且一旦调用返回 
所有属性将被更新
更新为正确的初始化数值
同样此刻 任何指派回调
任何向上尾接的内容会可以开始进入
这是为什么你需要
尽快执行上述步骤的原因
或许有内容正等着上传到你的app上
所以 请确保提前处理这些步骤
一旦这些步骤完成
下一件你将想做的事情是 查看会话状态
然后通知你的app  
iOS app和the Watch之间目前的关系如何
所以这些属性只适用于iPhone app
它正在通知iOS与Watch的关系
所以没有必要在你的Watch app上使用
因为基本上不适用
在这个示例中  我们将使用一款新闻app
一款推送最近
有趣文章的应用
首先要做的是执行我们刚才讨论的设置过程
这应当在使用应用的时候尽快完成
下一步进行设备检查 检查该设备是否与Watch配对？
如果未配对 那么相当于这是在iPad上运行
没什么需要做的了
你无法进行通讯
所以这个时候 你可能要停止所有在Watch上进行的工作
用户会出去并买个新的Watch 
然后执行配对步骤
启动Apple Watch app
操作配对 
设置这些设备
现在当你的app启动后 
你会得到一个指派回调
说明Watch状态会话改变了
当你检查配对属性的数值时 
你会看到返回为真 
因为设备已经配对了
所以 这时候你可以继续
检查下个属性 也就是
Watch app是否安装了？
如果还未安装 那么就没法通讯 
工作到此为止
但是 通过默认设置Watch app是默认安装的 
但是用户可能会由于某些原因 选择不进行安装
在这种情况下 用户将接续执行并进行重新安装
返回Apple Watch app
打开设备 如果你的Apple正在运行 
你将再一次获得指派回调 
你就可以检查该属性数值了 
可见Watch App Installed返回为真
现在 你可以进行通讯了
这时候说明你可以
使用Watch app开始进行通讯了
你需要输入通讯的内容
无论何时一旦Watch App Installed值为True 
另个属性Watch Directory URL也可用 
你会发现一旦Watch App Installed值为True
Watch Directory URL将会有一个非0值
这将指向在container创建的一个目录
我们稍微深入地讨论一下这个
目录和它的内容 它的使用周期与
Watch AppInstalled属性息息相关
WatchAppInstalled值从True变成False 
这个目录和它的所有内容都会消失
无论何时 当值为True时 
目录会再次出现 但是是空目录
我们建议你 仅在数据与
你的Watch app特别实例有关时才使用
实例是要说明什么呢 
一些事物 比如最后队列项目标记
就可以存储在这
若用户未安装并重新安装app 
那么Watch app是从一个空的容器开始的
因此这个目录以开始是没有内容的 
你需要同步到app通讯的位置
其他你可以保存的事物有偏好设置
当用户首次运行iOS app时 
你可能想让他设置一下
想要的Watch app体验
或许他不想显示全部内容 
但想要显示特别主题的前十条新闻 
比如国际新闻或体育新闻
这个位置就很适合来存储这些设置
同样 如果你正处理全尺寸的资料 
想生成适合Watch尺寸的资料 
你要压缩图片 音频 视频 
在提示传输时可使用WatchConnectivity
API 将这些资料储存到这里 随后我们会说到这点
所以 这就是Watch 目录
我们建议你将内容存储在这 
因为随后我们会将内容清理掉 如果Watch消失了 
如果他未配对他的手表 我们将自动清除这些内容
这样就省去了管理的麻烦
最后会话状态属性是Complication Enabled
用户并不能启动Complication 
但可编辑Watch表面然后启动 
之后你会收到同样的的回调 
会话或状态变换信号
当你查看属性时 现在值将是True
你已经设置 会话WatchConnectivity
已知道watch的状态是什么的 
iOS app和Watch app 
之间是什么关系
下一件事情是开始将信息传输到Watch上 
或从Watch传输到iOS app上
为了这么做 我将邀请亚历山大 
他将为我们讲解通讯API
谢谢 好的所以就像克里斯说 你设置好了会话
也已经检查过 设备已经配对了
Apple Watch app也已经安装了
现在 我们从如何才能
在两台设备之间进行通讯
关于通讯 我们有不少分类
第一类是后台传输
后台传输意思是说 
在收到方看来内容并不是立即需要的
因为内容不是立即需要的 
这意味着在传输这些内容时 
系统可以处理其他的事情
除了后台传输外 我们还将讲到
交互式信息传输
交互式信息传输是指
两个实时沟通的app之间的通讯
所以 这时候两个app都在使用中它们来回发送信息 
要求响应 之类的事情 
这里有你可能需要使用
交互式信息传输的一些情况
假设你有一个游戏 用户正在同时使用两个app进行游戏时候 
或者你正在Apple Watch上 
你需要启动iOS上的一些东西
比如你想要触发iOS设备 
以便了解用户位置
我们先来说说第一个 后台传输
关于后台传输 首先要讲的是
app内容的类型 以及用户如何
与这两台设备进行互动
还是用新闻app的示例 
这个新闻app有很多内容
它从服务器读取了不少内容 
而且它断定这些内容
对于Watch是有用的 
现在用户并未在目前情况下使用Watch
所以在Watch方面来说 这些内容并不是立即需要的
当然啦iOS app 这个新闻app 
想要挑一些新闻 在系统里列队备好
以便系统可以挑选对的内容
进行传输
在用户真的进行接收时
在这个示例中是Apple Watch 
系统将考虑电源和性能的情况
当条件都正确的时候内容将传输
它将在接收方这个示例中的Apple Watch中等待
直到用户启动接收app  
当接收app启动 
内容将被传输过去 
app也可以更新它的状态
这是后台传输所提供的
它允许内容列队等候
系统将为你传输内容
这允许了发送方 发送方app退出
系统将处理接下来的一切
它允许系统挑选合适时间传输内容 
允许系统将信息存储到
接收方 并等待接收app启动
对于app上有的大部分内容 
我们建议你使用后台传输
原因是 对于接收方来说 
大部分内容并不是立即所需的
当然啦 一旦接收app打开 就需要这些内容了
所以 我们来讲讲具体细节
我们有三种不同的后台传输类型
第一种是应用上下文
应用上下文代表的是app提供给
另一方的最有趣的
信息单一集合
比如说在iOS方面 有个app 
它跟踪用户位置 根据用户位置 
app挑选该位置附近的一个饭店 
并想推荐给用户
除了在iOS方面分享饭店外 
也想在Apple Watch app上
显示这个饭店
所以你可以将建议打包到
应用上下文中 
它将传输信息 
然后下次用户在Apple Watch启用
这个app时 内容就会出现 
推荐也会出现
可能想使用应用上下文的其他示例 
假设在iOS方面 你有一个社交app 
它读取了一堆的帖子 并确定了
10个最有趣的帖子 
在Apple Watch设备上展示
用户可看Apple Watch 
并立即可以看到有趣的信息了
你也可以将这排名前10的帖子
打包到应用上下文中他们将传输过去 
现在 应用上下文是
后台传输最简单的方法 
但如果你需要一些稍微复杂的东西 
或你需要进行排队等候 而不是信息的一个单一集合
我们为你提供两种方法
第一种是用户信息传输
这允许你传输你想打包的 
用户信息字典的内存内容
举个例子 假设你在Apple Watch上
有一个游戏
用户不断升级继续游戏 
当用户升级后继续游戏时 
你想将进度后台同步到iOS app
iOS app将展示一些细微图形 
说明用户在每个等级是如何操作的
除了用户信息传输 
我们还提供文件传输
非常类似
它允许你让内容进行排队等候 
在这个案例中 内容是一个文件
在这个展示中 接下来我们要讲到的
关于文件传输的示例是 假设你有一个iOS app 
它可让你对图片进行编辑 
在编辑完图片后 
用户可挑选他们喜欢的
这些喜欢的图片就是
想在Apple Watch显示的
你可以在喜欢的图片之间
使用文件传输进行传输
图片可通过Apple Watch查看
用户可以向他们的朋友进行展示之类的
让我们一个一个来说
我们从应用上下文开始
为了示范说明
我们使用社交网络app
刚才我提到 这个在iOS上的app
从社交网络网站读取所有的帖子
然后选出最有趣的 
发送到Watch app
关于应用上下文 首先要说的是这两个属性
第一个属性Application Context
它是这样一种属性 先在发送方 
然后在接收方存储最新内容 
Received Application
Context将在接收方存储
最新收到的内容
假设这个iOS app已经读取了一堆的帖子 
它也已经为Watch打包好最有趣的那些
将调用UpdateApplication Context
这个方法读取一个词典 
代表你想要发送的最新最有趣的状态
我们获得这个内容 Update
Application Context被调用后 
将它叠加到Application Context属性
这样内容就在那里了 
系统将决定传输内容的最佳时间 
或许是当用户启动他们的Watch的时候
现在 与此同时  
这个iOS app可以读取更多内容
并决定它想发送到Watch 
最新的有趣信息
在这个示例中 它将再一次调用Update
Application Context
然后 我们将把那些内容
叠加到Application Context属性
它将把旧的相关状态清出 
并放入新的相关状态 因为我们真正在意的是
那些最有趣 最新的数据集合
这个新内容就在那里了 再一次
等待系统挑选一个合适的时间 
将内容传输过去
一旦系统挑出合适的时间 
内容就会被传输过去
它将传输到到Apple Watch方
它将等待用户启动app 
即Apple Watch app
当app启动后我们将把内容转传输到
你的WatchKit扩展 
这里是在Apple Watch上所有代码执行的地方
所以以上是应用上下文的流程
我们来看一些代码
你想做的第一件事是打包
你的上下文词典 代表你想要发送的
最新状态的词典
调用Update Application
Context 你将使用词典
关于代码示例需要提的最后一件事情是Update
Application Context调用被打包到
Do Catch块中这个调用通过调试是事先引导的
这是Swift的新错误处理方式 Update
ApplicationContext会返回一个错误
若错误被返回Catch块将被激发 
我们强烈建议你
恰当的处理错误
所以这是应用上下文的发送方
我们来看看接收方
在接收方看来 
接收方将得到指派回调
Did Receive Application Context
它将向发送者
发送打包的字典
然后此时 接收者可以获得内容 
并更新它的app状态
关于API中这个指派回调
和所有指派回调我们需要知道的一件事是 
它们按照非主要串行队列被返回
假若由于你因为要更新某些UI 
而需要在主要队列中做些事情 
需要在此内容或其他事情的基础上 
发送到主要队列 从而更新你的UI
以上是应用上下文
它是app为另一方所提供的的 
最有趣的相关内容
它的行为优先权确实更高 
这是因为你重视接收方在意的内容
并处理最新内容而任何非最新的内容
都是无关紧要的
应用上下文有一个词典
这个词典有属性清单类型
属性清单类型是基本对象类型 比如数字 
字符串 基本集合型 字典 阵列
如果你想要更新属性清单类型 
Apple有很棒的在线文件
所以 对于应用上下文 
我们有一些特别推荐的使用示例
对于Apple Watch app来说应用上下文真的很不错 
因为不少Apple Watch app展示
iOS所有信息的一个子集
如果app是这样工作的 我们建议你
将那信息的子集放到应用上下文中 
让它可发送到Apple Watch
除了这些app 
应用上下文在Glance上也很好用
Glance获得app提供的
单个最有趣的数据段
我们建议你将该数据段
放到iOS方的应用上下文中 
这样它就可以被传输到Watch方
当用户扫过手表表面显示Glance时 
就可以看到数据了
结束应用上下文部分 现在将继续谈谈
用户信息传输
我们将用到的一个示例是 
Apple Watch上有个游戏
用户不断升级从而进行游戏 
当用户升级后 你将把进度
后台同步到iOS方 
iOS app展示一些细微图形 
是关于用户在该等级的信息用户信息传输要讲到的
第一件事是未解决的用户信息传输队列
这控制了所有
等待传输的内容
当用户升两级后 
这时候的当前状态
进度位于
未解决的用户传输队列中
目前 用户的等级是3级
一旦他们再次升级你将打包那些内容 
调用TransferUser Info 
然后传递一个描述进度的词典
获取到该词典后系统将对其进行打包 
并将它放到未解决用户输入传输队列中
现在这个内容将在这里等待然后系统会根据电源情况
或在用户开始使用iPhone的时候 
决定传输内容的最佳时机
内容将被传输和先前的API一样
我们需要等待直到iOS上app启动
当它启动后 我们将传输内容 
现在iOS app可以更新这些图形
以显示用户在Apple Watch游戏中的进度
所以这是用户信息传输流程
我们来看一些代码
首先要做打包所有用户信息词典 
这代表的是你想要发送的
目前状态的内容全部
然后你调用带有那个词典的
传输用户信息
传输用户信息返回一个用户信息传输对象
对象包含你正在发送的字典 
倘若传输仍然在未解决队列 
你可以选择取消这个传输
除了返回这个传输对象 
我们也提供了一个方法用来获取所有
仍在队列中的未解决用户信息传输
这方法返回一个数组 你可以迭代这个数组 
查看所有内容 
若你需要也可取消
所以这是用户信息传输的发送方
我们来看下接收方
在接收方看来你将调用 
Did Receive UserInfo Transfer
和应用上下文和其他所有指派回调一样 
这是在一个非主要串联队列中被返回的
一旦你获得回调 就可以获得
内容和词典内容 然后可以更新app状态
那是用户信息传输
它有用户输入词典
这些词典和应用上下文词典一样 
里面有属性清单类型
这对于内存内容 比如游戏进度而言 这种方法很好
我们允许你访问
队列中未解决的用户信息传输
接下来 我们谈谈文件传输
文件传输中要用到的示例是
这个图像编辑app
用户可在iOS编辑图片 
然后挑选他们喜欢的图片 
这些喜欢的图片就是我们想要
传输到Apple Watch上的
所以首先要说的是
未解决的文件传输队列
这里是所有文件传输
等待发送的地方
然后在接收方 文件在等待被转交到
接收方app时 将被放入
Documents/Inbox文件夹
这时候的状态是用户有两张喜欢的图片 
两个图像正在队列里等待 
进程进行到第三个
一旦完成进程并且将它挑选为
喜欢的图片后 你将调用Transfer File
你将传输一个文件URL 它指向
你想要传输的文件 我们提供一个方法 
以词典的方式传输附加的元数据
你可能想要增加一些元数据的一个情况是 
通过在每个元数据词典中放一个标识符 
将一些文件集合在一起
接收方可以识别那个标识符 
把正在接受的文件聚集在一起
所以这是用户喜欢的图片
我们称之为文件传输
现在我们将获得打包好的内容 
我们将把它放入未解决的文件传输队列
它将在这里等待 直到系统确定
传输内容的最佳时间
当系统确定传输内容的最佳时间后 
它将开始传输内容 
等待接收方启动并接收内容
需要注意文件的一件事是 
文件可能会稍微大一些
文件越大 
传输的时间就越长
当传输的时候 你可能需要注意
电源和性能的情况
请注意如果准备传输的是大文件 
相比使用其他API 这种方法
可能花费更长的时间
现在接收者将启动设备 
然后我们将传输这些图像
现在Apple Watch app可以显示这些图像了
所以这是文件传输流程
我们来看一下代码
首先你想做的是为你想要传输的文件
获取一个URL
然后打包你的元数据 最后
调用Transfer File 传输URL 
以及元数据词典
之后返回一个文件传输对象 
文件传输对象包含URL 
元数据词典 同样你也可以
取消任何未解决的文件传输
和用户信息传输一样 我们允许你
撤销所有未解决文件传输的数组
你可以迭代这个数组 检查内容 
如若需要 也可以取消
所以这就是文件传输的发送方
现在我们来看看接收方
在接收方看来 接收方会收到
这个指派回调Did Receive File
关于这个指派回调 需要注意的是
它与前面两个略有不同
首先获得WCSession文件对象
这个对象只包含文件URL和元数据
关于这个回调的第二件事是
文件现在位于app container的
Documents/Inbox文件夹下
说到控制这个文件 你需要将文件移出
Documents/Inbox并放到另一个
永久位置
移出文件的主要原因是
在指派返回后
Documents/Inbox将被清空
意思是文件将和其他内容一起被删除
所以重要的是在文件传输之前
将文件放到其他的位置 
需要记住一件事 如果你正在指派到
另一个队列 因为这是在从
非重要串行队列返回的 
如果该指派不同步的话 
你需要在指派之前移动文件
所以这是文件传输
它和用户信息传输非常相似但是它允许你
传输文件或文件列队
我们允许你
访问队列中未解决的文件
我们也允许你传输附加元数据
我们建议你使用较小的元数据体积 
另外 这个元数据词典
和其他我们说过的词典一样 
有属性清单类型
所以以上是三种后台传输模式
若接收放不是立即需要这些内容 
请用这些模式
但如果你需要实时来回传输信息 
你可以使用交互信息传输
交互信息传输指的是实时通讯 
两个app当前都处于开启状态
而且正在来回发送信息
就像我先前提到的 这里有你可能需要这么做的一些示例
假设我们有一个游戏游戏中两个UI都处于启动状态 
而你想要用户与两个UI同时进行交互
或者你正在使用Apple Watch 你需要
触发iOS app 
比如查询用户的位置
如果要使用交互信息传输 
需要满足特定条件
所以我们来说说这些条件
这些条件与我们引进的概念有关 
这个概念叫做可达性
可达性意思是
其他app也可以访问内容
这要求其他app是可以访问和启动的
从而可以使用交互信息传输
你查看另一方是否可达的方法是 
在默认会话中我们有可达性这个属性 这样你可以进行查看 
现在 可达性的条件与之前的有些不同 
取决于你所处的平台 不论你的代码
是否在iOS app上执行
或是在WatchKit扩展上执行
我们一个一个来看
我们从iPhone开始
满足可达性为True的第一个条件是
设备需被连接
我们可以通过Bluetooth或Wi-Fi连接 
但是如果用户将Watch放在家里 
拿了iPhone去上班这种情况下设备就无法被连接 
交互信息传输就无法进行
iOS上可达性为True 
需要满足的第二个条件是
Watch app必须处于前台操作状态
意思是为了在iOS上进行交换信息传输 
用户必须与Watch app交互
一旦满足以上两个条件 
你的iOS app上可达性属性也将为True
所以这是iPhone方面
来说说Apple Watch方面
在你的WatchKit扩展设备上
可达性为True的第一个条件是
必须连接设备
意思是说倘若用户去跑步 没带iPhone
只带了Watch
可达性就不会为True设备将无法被连接
第二个条件是
WatchKit外设必须处于前台运行状态
提到WatchKit外设处于前台运行状态
是因为在不少示例中
WatchKit外设可以在后台运行
主要与complication有关
我们等下会谈到这个
所以现在 当用户使用你的app时
你的WatchKit外设
也将被启动并被置于前台运行状态
这也就是说你可以使用交互信息传输
并且可达性属性为True
关于这个图表 还需要注意的是
我们并没有说iOS app当前正在运行
iOS app必须处于运行状态  以对进来的信息作出反应
并发出自己的信息
所以当iOS app在WatchKit外设之外运行时
我们如何进入一个状态呢
仅针对这个词典将信息从Watch发送到iPhone
或者允许iOS app
在接收信息的基础上在后台启动
我们拿这个做例子
你有一个运行追踪器app
它需要发送信息到iPhone
告诉CoreLocation开始追踪用户的信息
所以这个app将打包一个信息
告诉iOS app开始运行CoreLocation
它将发出启动信息
当系统受到这个信息时
我们将在后台启动iOS app
并传输那个信息
现在 两个app都在运行  它们可以进行互动了
这个示例中的app
可以开始追踪用户位置
所以那是交互信息传输流
当你可以使用它时
它如何和可达性有关系
现在我们来具体讲讲
如何在你的代码中使用它
我提供两种不同类型的信息
第一种发出一个词典
你使用词典调用Send Message
这个调用携带词典
加上一个回复处理器和一个错误处理器
这个词典和我们先前说过的词典一样 
里面有属性清单类型
除了词典外
我们还引入了发送数据的方法
可调用Send Message Data发送数据
这个携带数据 相同的回复处理器
和错误处理器
关于发送数据 
如果你有存储自己信息的自定义数据
或你自己的序列化格式我们建议你使用这个
若你使用自己的序列化格式
我们强烈建议你使用小而快的格式
这样用户体验更快
因为内容可以更快进行传输
关于这些调用 我想要指出一点 就是回复
你或许注意到了先前两个调用中有回复处理器
这个处理器是可选的
然而 在多数情况下 我们建议你使用它
原因是
这可让接收者确认进来的信息
接收者可以确认它接收到信息
信息包含正确的内容
它也可以处理那些内容
这样一来 发送方就知道它不需要再发送任何东西了
它不需要在发送新信息了
因为它发的是错误的信息
回复需要谈到的另一部分是
接收方这边的情况
如果发送者说 我想要回复 所以我将提供一个回复处理器
与之相反的 如果发送者说
我不想回复 不提供一个回复处理器 这时会发生什么呢
这种情况下
接收方会收到单独指派回调
这取决于我们是否应该提供回复
我们来说说这些指派回调
第一种情况 发送者说
我需要回复 我为系统提供一个回复处理器
意思是接收方将收到这个指派回调
Did Receive Message它有一个回复块
你可以在接收者接收并处理信息之后调用回复块
接收者就可以决定
是否发回一些内容
或者如果信息是错误的  就发回一个错误
现在 从另一方面来说
倘若发送者并未提供一个回复处理器
接收者将获得
指派回调Did Receive Message
它没有回复块
接收方可以处理进来的内容
然后就结束了
关于这两个指派回调
需要注意的最后一件事是他们通过一个词典
意思是说发送者使用发送信息
从发送方这边发送出一个词典
倘若 发送者使用发送信息数据发送数据
在接收方会收到一个类似的回调通过数据
现在 我们简单了解了交互信息传输
将所有的这些放在一起 并进行编码
你首先要做的是
检查可达性
确保另一边是确实可达的
然后 倘若可达性为True那你就可以打包你的信息了
一旦你有了信息
你就可以使用词典调用Send Message
然后期待收到一个回复
所以我们将提供回复处理器
我们想要处理我们的错误
所以我们将启动错误处理器
使用WatchConnectivity
传输内容的不同方法
来总结一下所讲的
关于WatchConnectivity
首先要做的是
设置会话
为做到这个 你设置指派  调用Activate
你需在app的使用周期里今早执行
这样app就可以开始接收内容
然后检查属性
在检查这些属性时候 你可以查看会话状态
一旦一切都好了
而且你知道Watch已经配对
同时Apple Watch app也安装了
你就可以开始通讯了
第一种沟通是后台传输
我们提供三种类型
第一种是应用上下文
这是信息的单一子集
这个子集是为另一方app准备的
或者 倘若你需要列队内容
你可以使用用户信息传输或文件传输
除了后台传输
在实时沟通方面
我们还可以使用交互信息传输
就是WatchConnectivity
它允许你的app进行设备对设备的通讯
我们非常期待
你们会如何使用这个API进行通讯
如何提供更棒的用户体验
接下来...将简要说说NSURLSession
什么是NSURLSession
它是一个现有的基础类
它允许你为服务器提出HTTP请求
从而读取内容
它在watchOS 2上适用倘若在你的服务器上
有内容需要读取 我强烈建议你使用它
它利用了Tetherless Wi-Fi特征
在没带iPhone的时候Tetherless Wi-Fi
允许Apple Watch连接到已知的Wi-Fi网络
若Apple Watch已经连接到已知Wi-Fi网络
你可使用NSURLSession通过Wi-Fi网络
连接到你的服务器并获取信息
所以你会如何使用NSURLSession呢？
当你的服务器有新内容时你都可以使用它
这个和你通过iOS app进行的操作
非常的相似
我们建议根据Apple Watch的需求
定制发送到Apple Watch的内容
若你的服务器上有图片
建议按照Apple Watch屏幕尺寸按比例决定图片尺寸
若是一个新app
你只想在Apple Watch上显示部分内容或许只是文本
我们建议你只截取你所需的部分
以上是关于NSURLSession的简要介绍
在WWDC会议上 有关于这个API的部分
同样也有在线资源部分
我们建议你看看这些
关于NSURLSession
最后要讲的是使用WatchConnectivity
NSURLSession
再一次 我们有新app的示例
这个新app从它的服务器上读取一些内容
而且它知道
Apple Watch app可能将读取这些相同内容
下次用户启动Apple Watch app时
为了不让Apple Watchapp重新获取内容
我将利用应用上下文
将内容从iOS传输到Watch
内容会不断被传输进来
再启动Apple Watch app会被传输到它上
Apple Watch app可以
显示在iOS上看到的相同内容
而且它提供更多的细微体验
用户下次启动Apple Watch app时
可能是数小时后
这也就说
服务器有更新的内容要读取
所以 我们建议
除了在应用上下文获取已经发送的内容外
使用带NSURLSession的HTTP请求
从你的服务器上读取绝对最新的内容
这样在用户等待新内容时
他们将看到在iOS上看到的相同内容
这样将有更好的体验
所以这是NSURLSession和
WatchConnectivity
现在 我们想要采用这两种API我们想要为你展示
如何使用它们获取数据 放到complication中
关于这部分
有请克里斯上台为我们讲解
谢谢你 亚历克斯这些东西很酷 是吧
我想你们使用Watch Connectivity API
和NSURLSession API
做的东西 一定很棒
现在我们来讨论complications
在深入讲解之前
先确定大家看的是一个内容
这些是在Apple Watch上的
三个Watch表面 三个时钟画面
若你移除时钟 
剩下的就是complications
每次用户看时钟画面时
他们会看到少量信息
这将让用户可以快速获得
最重要的信息
当你使用complication时
你将需要解决两个主要任务
你需要知道如何更新时钟画面
第二件事是 你需要拿到用来更新时钟画面的内容
我们来讨论一下 你如何简单地更新时钟画面
其他会议上 有深入讨论
在这个示例中
用一个天气app有个月相complication
这个月相complication不需外部数据
它已经有它所需的全部信息
因为它只需要数据和时间
所以它所关心的是如何更新时钟画面
为做到这点它将使用新ClockKit API
watchOS 2引进的ClockKit框架
流程运作的方式是
我们将在后台启动WatchKit外设
当这发生时 我们将获取到
一个CLK complications服务器例
你调用Shared Instance来实现
用Extend Timeline For Complication
进入正在更新的complication
接下来会发生的是
它们将调用ClockKit激发程序
然后开始问一堆的问题
它们询问现有时间轴项目
这是即将显示的内容之一
它们询问先前的时间轴项目
未来的时间轴项目
最后它们询问你的建议什么时候这些数据才算过时
这是给系统的建议
这样我们才知道你什么时候需要再次启动
你可以进一步更新时间轴
以上是更新时钟画面的 简要介绍
你可用ClockKit来做上述事情
你可以提供过去的
现在的 以及未来的内容
你的WatchKit外设将在后台进行这些更新
而且你可以规定
所提供的的内容什么时候过时
需要注意的一点是
WatchKit外设更新
complication动作是预设
所以你尽可能使之尽快完成
这样就可以一整天保持启动状态
以更新你的complication
正如我提到的关于这个话题 有个很棒的演讲
Creating Complications 
with ClockKit 如果你还没看过 我们希望你去看一下
下一个你必须做的事是
如何将内容放到你的complication
有个特别的示例即初始激活
用户首次进入时钟画面时
他可以进入对其进行编辑
会启动你的complication
这里指的是新app complication
此刻
那个complication的时间轴上
数据可能很少或甚至没有数据
所以它对内容有大量的需求
马上要做的是
立即在后台启动WatchKit外设
现在 你有很多方式可以获得内容
所以 你可以初始化时间轴
你可以调用NSURLSession与服务器通讯
从而获得内容
或可选择使用WatchConnectivity
若你在这个特别情况下
使用WatchConnectivity
设备是连接的你会发现可达性为True
这是亚历克斯先前提到的
在特定情况下
这时候的这个属性是True
这是其中之一
在这个示例中另外可调用Send Message
它将把信息传输到iPhone上
我们将在后台启动天气app
此时 iOS上的天气app
可以使用任何WatchConnectivity
API返回信息并填充到时间轴
总的来说
当你运行初始激活时
WatchKit外设将在后台启动
你可以使用NSURLSession或者
因为这是非常特殊的情况
WatchConnectivityAPI启动iOS app
因为可达性为True
我建议你用这个
尽可能多的填充ClockKit时间轴
因为开始时 里面没有数据
接下来是如何保持最新状态
你的时间轴现在已被填满
而更新也即将开始
如何保持更新complication
有很多不同的方法
可以用来更新你的complication
你可以将内容传输到complication
也就是说 若你有个外部源
比如说web服务器 它知道新内容出现的具体时间
而且是不定期更新的
你将做的是
将内容从云中拿出 放到iPhone
然后传输到Apple Watch
我们比较容易理解这点的一个示例是比如体育app
显示比赛分数时就是complication
多数时间里 
分数只在一天当中很短的一段时间内发生改变
所以可以很快进行更新
然后 接下来我们认为更合理的方法是使用推送方法
另一个方法是我正在调用请求间隔读取
这个更多的是用在你知道有定期更新的情况
这样你可以保持更新你的complication
可用像NSURLSession
直接进入云
有些冲浪app带有潮汐complication
显示潮汐模式
这样你就可以知道什么时候可以冲浪了
我们先来看一下这个例子
你想用NSURLSession和ClockKit
更新complication
从时钟画面的角落可看到
冲浪complication已经启动
这个流程看起来是这样的
在后台启动的WatchKit外设
你想创建一个NSURLSession请求
并将它发送到服务器以获取内容
服务器将生成一个响应
并将传输回WatchKit外设
现在你想打开并更新ClockKit
你将要求他们扩展你的时间轴
它们将通过问问题开始
你将提供过去 现在的时间轴更新
最后 你将给出一个建议时间
什么时候应该再次启动
最后一件事
当你提供下次启动时间时
系统会获得你的工作已经做完的提示
你的WatchKit外设也将被隔离
现在 我们假设经过一段时间后
系统根据你的提示和系统条件
认为现在是重启complication的
最好时间
再一次 你将在后台启动
你将调用NSURLSession生成一个请求
你将把它发送到服务器
服务器将生成一个响应
你将使用ClockKit打开并更新你的complication
概括一下 我们建议你
如果可能的话就使NSURLSession后台会话
这是因为 在下次外设运作之后
NSURLSession请求才会完成
使用后台会话 
可使它在下次运作时传输内容
提供的请求时间只是给系统的一个建议
并不能保证确实如此
我们将尽可能逼近准确时间而且使用条件
在这时候也不一定总是满足
我们建议你让运作时间尽可能的短
你调用ClockKit更新时钟画面
你想让运行时间尽可能的短
而且让下次更新请求的时间间隔尽可能的大
因为这是预设的 你不想在一天结束之前就用完这些安排
另一个获得内容的方法
比如在使用体育app的示例中
是推送这些内容
我们将在不同数个阶段中查看内容
因为这会用到两个非常独特的进程
首先 你用PushKit
将内容从云推送到iPhone
第二部分是用WatchConnectivity
将内容从iPhone推送到Apple Watch
我们分别来看一下
所以第一部分是
用PushKit将内容传输到iPhone
你已更新PushKit框架
从而支持complication推送
使用方法是创建一个PKPushRegistry实例
接下来 你将自己设置成指派
这样 你就可以接收回调了
最后 你将设置推送类型
并传输新PK推送类型complication
这是之前添加到iOS9中的
一旦完成 你将收到带新Push记号的指派回调
之后上传到你的服务器
也将让服务器可以将推送发送到设备上
最后 当服务器发出推送时
将收到携带负载Did Receive
Incoming Push回调
这是你可以返回来 
使用WatchConnectivity
API 将内容发送到iPhone时
所以 第二部分 这时候
可以使用WatchConnectivity
将在iOS app上收到的内容
发送到Apple Watch app
首先要用到的是
亚历克斯先前说到的传输用户信息API
这种方式可让你项目排队等候
Watchcomplication可能需要的
为过去和未来的时间轴
一旦所有的时间轴项目排完队
在完成工作前需要做的最后一件事是
调用一个专门的API
WatchConnectivity的一部分
它调用了传输当前complication用户信息
这是传输用户信息的专门版本
不管在什么时候
只允许存在一个当前complication用户信息
若你调用两次
只有最后一次被标记为当前complication用户信息
当你调用时
对于系统来说 意思是事情已经做完了
在接收方 所有的回调将生成这个指派回调
Did ReceiveUser Info
所以 总体而言
这流程看起来像什么呢 好的
所以 当用户第一次启动一个体育app时
app在其使用周期的知哦啊其
将建立PK推送注册表并设置期待类型
然后注册该推送类型
即带Apple推送服务器的设备
然后类型推送到Apple服务器上
随后将反过来生成一个Push记号
然后你将在你的iOS app上收到指派回调
你需要收到该记号并上传到你的服务器
这样以后 你的服务器
就可以发送推送到这个设备了
这个时候 PushKit初始化设置就已经完成
不需要用到你的app了
假设这一切开始了 服务器决定
更新complication
它将发送一个推送到你的设备上
设备将收到推送
我们将在后台启动体育app传输推送
那是另一个指派调用
这时候 你需看看推送负载上的数据
确定如果要使用WatchConnectivity
需要发送些什么
你将调用Transfer User Info
将过去和未来的时间轴项目加入列队
然后我们可以访问未解决用户信息传输列队
然后调用专门传输当前
complication用户信息的重要队列
这也是将在Watch表面显示的队列
它将进入未解决用户信息传输队列
但会跳过开头
因为它是最重要的队列
而且被指定为紧急优先
我们将立即把它传输到Apple Watch
然后在后台启动WatchKit外设
传输当前complication用户信息
如满足相关条件 部分内容也会同时传输
你将获得其他时间轴项目
但是最重要的队列一定会被传输
最后 可以使用ClockKit
更新你的complication
就是这样你已使用PushKit更新了complication
我们已经添加新PK推送类型complication
你可以使用服务器上的信息
快速更新complication
使用这些推送类型
还有很多限制条件
complication在时钟画面必须是处于活跃状态
否则将无法进行推送
且每天的推送数量也是有限的
所以 请节约使用
平均大概是每小时1到2个推动
但体育app可能在很短的时间内全部用光
你可使用传输用户信息
对时间轴项目进行列队
最后 你可以使用传输当前complication
用户信息列队当前
或现有的时间轴项目
可使用ClockKit更新时钟画面
请记住 很多这些事都是有预算限制的
在iOS和WatchKit上执行的
complication更新的任何操作 
都会消耗预算
我推荐 将你需要用来更新complication的
任何信息都包括在推送中
complication推送类型有4K有效负载
大于标准负载 所以你可以将需要的大部分
信息放入其中
若你收到其中一个推送
并打开iOS app提交NSURLSession请求
你将很快就消耗完预算
请确保所有你需要的内容都在推送中
这部分就到此结束
简要地讨论下我们今天所说的
我们说了框架WatchConnectivity
和API
我们很期待看到你们用这些API做出来的东西
简要地讨论了NSURLSession和使用方法
还有其他部分
深入地讨论NSURLSession及如何使用NSURLSession
最后 我们讨论了如何把数据放到complication
这是个更为高级的话题
还有很多可以查看的重要资源
我们有一些很棒的样本代码
我们也有专员他们已经准备好回答你的问题了
关于其他的内容
建议你看Creating Complications
with ClockKit以及Networking with NSURLSession
因为他们与我们今天讨论的内容紧密相关
谢谢