00:00:20.721 --> 00:00:24.324 
Core Data 新中的內容

00:00:31.465 --> 00:00:34.201 
下午好！
歡迎收看第 220 課

00:00:34.768 --> 00:00:38.172 
我叫瑞西 衛爾瑪稍後
斯克特 佩瑞將跟我一道

00:00:38.572 --> 00:00:41.408 
爲您展示今年
Core Data 中的新內容

00:00:43.177 --> 00:00:44.778 
不過 在我們進入正題之前

00:00:45.012 --> 00:00:47.381 
我想給大家講一下什麼是
Core Data

00:00:48.315 --> 00:00:52.819 
現在 你們中的很多已經開發了
這些很棒的有漂亮 UI 的 app

00:00:52.886 --> 00:00:55.322 
你們已經把它
與從外部數據源獲取的

00:00:55.389 --> 00:00:57.858 
或者來自於提供給你們的

00:00:57.925 --> 00:00:59.226 
資源框架的數據結合起來

00:00:59.726 --> 00:01:02.029 
那麼當你處理那些對象的時候

00:01:02.262 --> 00:01:06.767 
你將創建一個複雜的圖形
並將所有的那些更改向UI傳遞

00:01:07.434 --> 00:01:09.837 
然後當你的用戶
對 UI 做出更改的時候

00:01:09.903 --> 00:01:11.972 
您將把所有的那些改動
推送回到您的對象圖

00:01:12.072 --> 00:01:16.076 
並推送回到您的數據源

00:01:16.143 --> 00:01:17.845 
那麼 Core Data
讓這個變得容易

00:01:18.679 --> 00:01:20.781 
Core Data
將爲您管理對象圖

00:01:21.682 --> 00:01:24.451 
簡單告訴我們一點
關於您的 Cocoa 模型

00:01:24.685 --> 00:01:26.987 
以及對象模型編輯器的信息
告訴我們一點

00:01:27.054 --> 00:01:29.223 
關於您的對象和它們的屬性的信息

00:01:29.590 --> 00:01:33.260 
以及它們的相互關係
而我們將負責剩下的工作

00:01:33.594 --> 00:01:37.631 
而且我們也將
在您選擇的後臺維持它

00:01:37.998 --> 00:01:41.368 
不管它是 SQLite
或是您自己設定的存儲方式

00:01:42.469 --> 00:01:47.407 
於是 隨着你不斷導入對象
你的各種關係將發生改變

00:01:47.774 --> 00:01:49.943 
而Core Data
將爲您維護這些關係

00:01:50.010 --> 00:01:52.446 
因此如果您在您的對象模型
設置任何通用刪除規則

00:01:52.513 --> 00:01:55.082 
我們將刪除一個對象

00:01:55.148 --> 00:01:57.317 
並將按照你的定義
根據規則統一刪除

00:01:59.319 --> 00:02:03.423 
在你的對象圖裏
找到對象也是特別容易的

00:02:04.324 --> 00:02:06.493 
只須使用一個
NSFetchRequest

00:02:07.127 --> 00:02:08.662 
並賦給它一個 predicate

00:02:08.729 --> 00:02:10.430 
來找到你在尋找的對象

00:02:10.830 --> 00:02:12.399 
我們將爲你扎到它們

00:02:13.734 --> 00:02:16.036 
批處理也很方便

00:02:16.770 --> 00:02:20.874 
這讓你從讀取請求得到的數據集裏面

00:02:20.941 --> 00:02:23.777 
僅提取一小部分對象

00:02:24.278 --> 00:02:27.614 
讓您在檢查數據集的時候
需要處理的數據變少

00:02:27.681 --> 00:02:31.451 
此外
NSFetchRequest 的

00:02:31.618 --> 00:02:35.022 
另一個特性是關係的預讀取

00:02:35.822 --> 00:02:39.593 
告訴我們一個需要讀取的對象

00:02:39.660 --> 00:02:41.895 
我們會預讀取所有與其相關的對象
所以當你遍歷那一關係的時候

00:02:41.962 --> 00:02:44.865 
你將仍然在內存中進行

00:02:47.067 --> 00:02:50.070 
然後你只須把所有這些綁定到 UI

00:02:51.071 --> 00:02:54.041 
你把一個NSFetchResult
Controller

00:02:54.174 --> 00:02:56.376 
綁定到一個餐桌視圖
就像我們這裏所做的一樣

00:02:56.944 --> 00:02:58.579 
而當我刪除蘋果醬時

00:02:59.012 --> 00:03:00.747 
我的 UI 會相應地更新

00:03:01.882 --> 00:03:06.286 
然後當我插入更多對象時
我添加了香蕉麪包

00:03:06.787 --> 00:03:08.689 
我的 UI 也會相應更新

00:03:09.356 --> 00:03:12.392 
這些都爲你處理
所有的關鍵視圖行爲

00:03:12.693 --> 00:03:15.562 
以及更改通知 Core Data
都會爲你進行處理

00:03:17.064 --> 00:03:18.866 
抱歉

00:03:19.833 --> 00:03:21.668 
不過可能有一種情況

00:03:22.069 --> 00:03:25.172 
您的用戶正在主上下文操作一個對象

00:03:25.739 --> 00:03:30.410 
而在背景上下文
也在導入同樣的新對象

00:03:30.477 --> 00:03:34.214 
而且可能正在更新目前用戶

00:03:34.281 --> 00:03:35.449 
正在操作的對象

00:03:36.216 --> 00:03:38.652 
這就引入了“多寫入者衝突”的概念

00:03:39.553 --> 00:03:42.289 
在 Core Data 中
這裏它也爲您進行了處理

00:03:42.990 --> 00:03:46.960 
我們爲所有對象進行版本描述
並讓您設定合併策略

00:03:47.728 --> 00:03:50.764 
如果您不捨得合併策略
我們將在您將其存入上下文時

00:03:50.831 --> 00:03:52.165 
默認出錯

00:03:52.766 --> 00:03:55.202 
並提示您出現了衝突錯誤

00:03:55.769 --> 00:03:57.838 
讓您以自己認爲合適的方式
處理衝突

00:03:58.605 --> 00:04:01.241 
或者您可以從我們已提供的策略中

00:04:01.308 --> 00:04:02.543 
選擇多個合併策略

00:04:02.776 --> 00:04:07.014 
不管它是在內存中
還是在持久存儲中

00:04:07.080 --> 00:04:10.951 
不管是持久存儲優於內存
還是相反

00:04:11.618 --> 00:04:14.087 
選擇最適合您的
最適合您的特定情況的

00:04:15.455 --> 00:04:18.058 
一旦您選用了 Core Data
你會有幾大好處

00:04:18.125 --> 00:04:20.560 
我要給特別大家講兩個

00:04:20.627 --> 00:04:22.963 
真正最大的好處

00:04:23.664 --> 00:04:27.401 
出色的內存可升級性以及
積極的延遲加載

00:04:28.135 --> 00:04:32.239 
那是什麼意思呢？
就是說我們僅當您在內存中

00:04:32.472 --> 00:04:34.241 
需要那些對象的時候我們才加載它們

00:04:35.375 --> 00:04:38.745 
採用Core Data會導致
佔用空間的大幅減小

00:04:39.513 --> 00:04:42.749 
您需要維護的代碼
減少 50 到 70%

00:04:42.816 --> 00:04:44.685 
讓您有更多的時間

00:04:44.751 --> 00:04:47.154 
開發您的 app 的新特性

00:04:48.088 --> 00:04:49.489 
然後您就可以加入

00:04:49.556 --> 00:04:51.491 
App Store中
已在使用Core Data的

00:04:51.558 --> 00:04:53.493 
40多萬個 app 了

00:04:54.728 --> 00:04:56.463 
Core Data 的概述到此爲止

00:04:57.431 --> 00:04:59.366 
現在讓我們進入新內容

00:04:59.666 --> 00:05:01.535 
我們爲您準備的所有新的 API

00:05:03.003 --> 00:05:05.706 
首先讓我們從
NSManagedObject

00:05:06.440 --> 00:05:08.208 
和一個新的屬性

00:05:08.275 --> 00:05:10.310 
hasPersistent
ChangedValues開始

00:05:12.045 --> 00:05:14.748 
以前您可能
已經用過hasChanges

00:05:14.982 --> 00:05:19.086 
這是一個相當基礎的髒標誌
如果你碰了這個對象

00:05:19.152 --> 00:05:20.821 
我們會將其
標誌爲髒的 dirty

00:05:20.888 --> 00:05:24.057 
但是通過
hasPersistentchangedValues

00:05:24.124 --> 00:05:27.928 
我們將確保對象的屬性

00:05:27.995 --> 00:05:31.331 
與持久存儲中的不同
確保您不會有任何誤報

00:05:33.800 --> 00:05:37.171 
NSManagedObject
的新特性還包括

00:05:37.237 --> 00:05:39.406 
objectIDsFor
RelationshipNamed

00:05:39.940 --> 00:05:43.577 
這個非常適合用於大型關係

00:05:44.878 --> 00:05:47.714 
因爲將不會在內存內
將整個關係實體化

00:05:47.781 --> 00:05:49.983 
而是會將已經歸類的

00:05:50.050 --> 00:05:52.653 
一系列對象的ID返還給您

00:05:53.287 --> 00:05:56.390 
這讓您能夠以更小的規模
檢查這些對象的ID

00:05:56.456 --> 00:05:58.225 
並且以處理您的更小的對象

00:05:58.992 --> 00:06:00.961 
讓我快速地爲您
展示一個代碼示例

00:06:02.763 --> 00:06:04.631 
這裏是我的人物對象

00:06:04.698 --> 00:06:08.635 
而我請求它的關係對象
ID“family”

00:06:09.303 --> 00:06:11.872 
這會給我全部關係
然後我可以

00:06:11.939 --> 00:06:15.209 
去讀取這些關係
每批 100 個

00:06:16.276 --> 00:06:18.979 
然後以每次100個的速度
遍歷這些關係

00:06:19.046 --> 00:06:23.083 
這讓我把向內存的輸入
維持在相當小的水平

00:06:23.483 --> 00:06:24.852 
而且易於管理

00:06:26.486 --> 00:06:29.489 
讓我們繼續往下講NSManaged
ObjectContext

00:06:30.057 --> 00:06:34.361 
和一個名爲refresh
AllObjects的新方法

00:06:36.430 --> 00:06:39.666 
RefreshAllObjects
所做的事情和你料想的完全一樣

00:06:39.733 --> 00:06:41.635 
它把您的上下文中的對象更新

00:06:42.302 --> 00:06:44.137 
但是保留未被保存的更改

00:06:44.204 --> 00:06:47.040 
而且與reset
on the context不同的是

00:06:47.107 --> 00:06:49.610 
您對對象的引用仍然有效

00:06:50.110 --> 00:06:52.713 
因此 您不必重取任何引用

00:06:52.779 --> 00:06:56.049 
而它最適合用於
打破可能已出現的循環引用

00:06:56.116 --> 00:06:59.086 
循環引用是當你
遍歷一個雙向關係時

00:06:59.152 --> 00:07:01.054 
你陷入循環中

00:07:02.923 --> 00:07:05.759 
此外NSManagedObjectContext的
新特性還包括：

00:07:06.159 --> 00:07:09.329 
對於那些在您的存儲中
使用多個協調程序的朋友

00:07:10.364 --> 00:07:12.999 
MergeChangesFrom
RemoteContextSave

00:07:13.066 --> 00:07:16.904 
將從一個協調程序接收通知

00:07:16.970 --> 00:07:19.473 
並將其用於另一個
協調程序的上下文

00:07:20.007 --> 00:07:21.842 
這讓您在您的上下文中
有最新的行數據

00:07:21.909 --> 00:07:25.279 
而我們將爲您照看

00:07:25.345 --> 00:07:27.247 
所有必要的上下文

00:07:32.953 --> 00:07:35.322 
在 Core Data 中
偶爾你會遇到某個特別的例外

00:07:35.389 --> 00:07:37.357 
而那對於開發者

00:07:37.424 --> 00:07:38.692 
將是非常容易識別的

00:07:39.193 --> 00:07:41.061 
那就是無法加載某個錯誤

00:07:42.529 --> 00:07:44.831 
爲什麼Core Data
無法加載這個錯誤呢?

00:07:45.566 --> 00:07:48.468 
好了 正如我早些時候提到的
在延遲加載對象方面

00:07:48.535 --> 00:07:52.239 
Core Data 是非常積極的
您在內存中

00:07:52.306 --> 00:07:55.609 
將只有對象圖中的一部分
而且當我們試圖遍歷一個關係時

00:07:55.676 --> 00:07:59.246 
我們將可以回到磁盤

00:07:59.646 --> 00:08:02.015 
並發現那個對象已經被刪除了

00:08:03.483 --> 00:08:05.285 
什麼是比遇到例外更好的事情？

00:08:05.485 --> 00:08:07.054 
有很多

00:08:07.154 --> 00:08:08.488 
我們已經在

00:08:08.555 --> 00:08:10.490 
NSManagedObjectContext
上面

00:08:10.557 --> 00:08:12.226 
推出了一個新的屬性

00:08:12.292 --> 00:08:14.394 
它讓你能夠設置一些基礎的

00:08:14.461 --> 00:08:16.563 
faultingDelegated
API

00:08:21.001 --> 00:08:21.935 
目前

00:08:22.002 --> 00:08:24.171 
shouldDelete
InaccessibleFaults

00:08:24.238 --> 00:08:25.506 
默認爲 yes

00:08:25.806 --> 00:08:29.576 
如果我們遇到一個錯誤
我們將把它標記爲deleted

00:08:30.077 --> 00:08:33.280 
而任何缺失的屬性都將是null或0

00:08:33.847 --> 00:08:37.284 
這讓您的app持續這一對象

00:08:37.717 --> 00:08:39.318 
並將其當作一個
已被刪除的對象處理

00:08:40.120 --> 00:08:42.188 
您將不會再崩潰
但是您將可以繼續下去

00:08:42.256 --> 00:08:47.361 
並且向用戶展示
他們預期將會看到的東西

00:08:50.230 --> 00:08:51.098 
現在關於

00:08:51.164 --> 00:08:54.768 
NSPersistentStoreCoordinator

00:08:54.835 --> 00:08:56.970 
我們要介紹兩個新的 API

00:08:58.372 --> 00:09:01.542 
我們推出了這兩個新的API
是因爲我們發現開發者

00:09:01.642 --> 00:09:05.579 
在如何清理他們的
持久存儲方面存在問題

00:09:06.413 --> 00:09:07.814 
你們中的一些人做過這樣的事情

00:09:07.881 --> 00:09:10.717 
您已經經過或繞過
Core Data API 層

00:09:11.118 --> 00:09:12.986 
而直接操作你的數據庫

00:09:13.887 --> 00:09:17.724 
不幸的是帶來了意想不到的後果

00:09:18.492 --> 00:09:21.061 
您可能讓壞卷描述符保持開放狀態

00:09:21.762 --> 00:09:24.164 
所以我們爲您提供了

00:09:24.698 --> 00:09:27.067 
destroyPersistentStoreAtURL

00:09:32.773 --> 00:09:34.808 
就像 addPersistent StoreAtURL
一樣

00:09:34.875 --> 00:09:36.076 
你做出了同樣的選擇

00:09:36.343 --> 00:09:38.178 
而且你可以破壞那一持久存儲區

00:09:38.712 --> 00:09:42.749 
而我們將遵守所有的鎖定協議

00:09:42.816 --> 00:09:45.819 
並將所有相關文件清理出來
放到您已選擇使用的

00:09:45.886 --> 00:09:46.887 
特定類型的存儲區

00:09:47.688 --> 00:09:49.456 
以那種同樣的方式

00:09:49.523 --> 00:09:52.793 
我們推出了
replacePersistentStoreAtURL

00:09:53.327 --> 00:09:56.897 
這和破壞的模式類似
而如果目標數據庫並不存在

00:09:57.197 --> 00:10:00.133 
我們將只須把它複製到位即可

00:10:00.868 --> 00:10:04.872 
一個大家都曾遇到的問題是副本

00:10:06.039 --> 00:10:08.842 
一個帶有副本的數據庫是無用的

00:10:09.309 --> 00:10:10.677 
你已經寫了大量的代碼

00:10:10.911 --> 00:10:12.279 
來確保你沒有副本

00:10:13.213 --> 00:10:15.516 
這裏 Core Data
也可以幫你

00:10:16.517 --> 00:10:19.152 
首先讓我們看下
爲了發現副本

00:10:19.453 --> 00:10:20.654 
你們可能已用過的常見模式

00:10:21.154 --> 00:10:22.723 
即“尋找或創建”模式

00:10:23.924 --> 00:10:28.028 
在這裏 如你所見
我建立了一個讀取請求並且

00:10:28.095 --> 00:10:30.998 
我必須尋找一個特別的對象

00:10:31.064 --> 00:10:34.201 
看它是否存在
然後才能創建它

00:10:34.268 --> 00:10:36.436 
如果它確實存在 我就更新它

00:10:37.404 --> 00:10:41.108 
不過這種模式可能是相當有風險的
而且如果我有

00:10:41.475 --> 00:10:45.712 
來自於多個數據源的線程的話
它可能導致多個副本

00:10:46.480 --> 00:10:50.284 
而Core Data今年已爲您
提供了保護

00:10:50.350 --> 00:10:53.320 
只須告訴我們在一個實體內的
哪些屬性應是唯一的

00:10:53.587 --> 00:10:56.356 
我們就將確保該實體的所有實例

00:10:56.723 --> 00:11:00.227 
都保持那一唯一屬性
不管它是電子郵件 零部件編號

00:11:00.294 --> 00:11:02.863 
通用產品代碼 等等
我們將確保它在

00:11:02.930 --> 00:11:04.431 
它在所有實例中都是唯一的

00:11:11.538 --> 00:11:16.009 
當唯一實例
唯一約束條件

00:11:16.410 --> 00:11:18.745 
被用於對象創建後的
未被修改的數值時

00:11:18.812 --> 00:11:21.315 
是最佳的

00:11:21.381 --> 00:11:24.418 
通常當你創建對象的時候
這些唯一約束條件

00:11:24.518 --> 00:11:27.087 
應被一次性設定
然後在對象存續期間永不更改

00:11:28.222 --> 00:11:31.625 
更改它們可能導致衝突

00:11:32.192 --> 00:11:35.362 
因爲您的唯一屬性可能會與

00:11:35.429 --> 00:11:37.197 
有同樣的唯一屬性的
另一個對象衝突

00:11:37.731 --> 00:11:40.367 
那時候您就可以使用我們之前

00:11:40.434 --> 00:11:42.669 
在合併策略中講到的恢復方法

00:11:43.337 --> 00:11:44.371 
來解決那些問題

00:11:45.305 --> 00:11:49.276 
此外 任何從具有
唯一約束條件的父實體

00:11:49.343 --> 00:11:53.013 
繼承的實體也將繼續那些約束條件

00:11:53.714 --> 00:11:56.884 
在上面的例子中您可以看出
父實體有一個已被確認的

00:11:56.950 --> 00:11:59.119 
UUID約束條件
作爲唯一約束條件

00:11:59.853 --> 00:12:03.857 
子實體已經添加了電子郵件

00:12:03.924 --> 00:12:05.559 
作爲對其唯一約束條件的補充

00:12:07.895 --> 00:12:11.331 
現在我想爲您快速展示一下

00:12:11.532 --> 00:12:13.600 
如何利用唯一約束條件

00:12:16.069 --> 00:12:19.373 
那麼這裏我們將使用食譜 app
我們前些年一直在爲您展示

00:12:19.439 --> 00:12:23.043 
可以在開發者門戶
將其下載

00:12:23.777 --> 00:12:26.680 
我們增加了一個新性能
即右下方的 import 導入

00:12:27.514 --> 00:12:30.117 
這讓我可以導入任何我喜歡的

00:12:30.384 --> 00:12:31.852 
與蘋果相關的食譜

00:12:33.420 --> 00:12:35.556 
這裏我們回退
你看到我增加了

00:12:35.622 --> 00:12:39.660 
所有我喜歡的蘋果食譜
然而我的 UI 並不是非常直觀

00:12:39.726 --> 00:12:42.763 
用戶在點擊的時候

00:12:42.829 --> 00:12:44.831 
可能會懷疑哪裏出錯了

00:12:44.898 --> 00:12:47.301 
不幸的是他們已複製了他們的數據

00:12:50.470 --> 00:12:52.773 
這裏我們可以有很大的改善

00:12:53.340 --> 00:12:55.876 
讓我們回到 Xcode
並看一下我們的對象模型

00:12:56.777 --> 00:12:59.847 
而這裏我們在設置我們的實體
我將選擇一個食譜

00:13:02.382 --> 00:13:05.185 
而現在我這裏有了一個新選擇

00:13:05.252 --> 00:13:07.888 
就在右邊
叫做 unique 唯一

00:13:08.655 --> 00:13:11.391 
這讓我指定那些屬性

00:13:11.458 --> 00:13:13.527 
對於這個特定實體
是唯一的

00:13:14.261 --> 00:13:17.364 
在此例中我們將有
源 ID 和永久性 ID

00:13:21.468 --> 00:13:24.371 
那麼現在當我運行這個食譜app時

00:13:26.240 --> 00:13:28.108 
我們將看到我有一個原始清單

00:13:28.575 --> 00:13:32.479 
我可以把它導入
然後選擇我的蘋果食譜

00:13:32.980 --> 00:13:34.381 
但是我也缺乏耐心

00:13:34.448 --> 00:13:37.050 
沒看到任何 UI
所以我不斷點擊

00:13:37.684 --> 00:13:41.688 
這次我們有了單一對象
代表它們全部

00:13:42.689 --> 00:13:45.826 
不必尋找或創建任何副本
任何代碼

00:13:46.593 --> 00:13:49.730 
您的唯一約束條件確保了您的唯一性

00:13:57.671 --> 00:14:02.509 
然而有了所有那些副本並不是理想的

00:14:03.377 --> 00:14:05.579 
刪掉副本可能需要做大量工作

00:14:05.979 --> 00:14:07.781 
這時候就要
斯克特 佩瑞出場了

00:14:07.848 --> 00:14:09.616 
他將向我們展示
我們對此能做些什麼

00:14:15.889 --> 00:14:16.723 
謝謝 瑞西！

00:14:18.058 --> 00:14:20.394 
那麼假如您已經有了一個app

00:14:20.694 --> 00:14:22.496 
而且您已經有了所有這些
已被複制的數據

00:14:23.197 --> 00:14:25.199 
現在您必須把它們全部刪除

00:14:25.866 --> 00:14:29.203 
今天您必須要做的是
將它們全部從內存中提取出來

00:14:29.670 --> 00:14:32.639 
抱歉 是從存儲中...
一旦它們進入內存

00:14:32.706 --> 00:14:35.576 
你將它們標記以便刪除
然後您必須將其

00:14:35.642 --> 00:14:37.811 
存儲到持久性存儲中
如果您有很多對象

00:14:37.878 --> 00:14:41.315 
您將不得不一次又一次地刪除

00:14:41.682 --> 00:14:44.084 
以維持足夠低的內存佔用

00:14:44.151 --> 00:14:45.786 
讓您的 app 維持活躍狀態

00:14:47.020 --> 00:14:51.825 
若只是爲了將它們刪除
而將對象加載到內存中

00:14:51.892 --> 00:14:54.027 
似乎有點愚蠢

00:14:54.094 --> 00:14:56.630 
今年我們已推出了一種新的 API

00:14:56.697 --> 00:14:58.432 
它的形式是
NSBatchDeleteRequest

00:14:59.766 --> 00:15:01.668 
NSBatchDeleteRequest
的工作原理

00:15:01.735 --> 00:15:03.437 
類似於
NSBatchUpdateRequest

00:15:03.670 --> 00:15:07.107 
在於它直接在持久性存儲中發揮作用
而無須向內存中加載任何對象

00:15:08.308 --> 00:15:10.077 
你可以使用NSFetchRequest
的一個實例創建它

00:15:10.143 --> 00:15:14.181 
指定一個實體
一個或更多的存儲

00:15:14.314 --> 00:15:19.353 
並使用predicate
來源或限制來分割數據

00:15:19.419 --> 00:15:22.322 
以您希望的任何方式

00:15:24.691 --> 00:15:26.627 
批刪除請求會返回一個方框型

00:15:26.693 --> 00:15:28.729 
NSBatchDeletesResult

00:15:28.896 --> 00:15:30.731 
而你可以對請求進行配置

00:15:30.797 --> 00:15:33.534 
以便返回一個默認的成功或失敗

00:15:34.067 --> 00:15:37.137 
被刪除的對象的總數

00:15:37.204 --> 00:15:39.306 
或該方框中的對象的對象ID

00:15:41.608 --> 00:15:43.243 
這樣的做法有幾個限制

00:15:43.377 --> 00:15:45.145 
因爲對象都沒有被加載到內存中

00:15:45.579 --> 00:15:47.781 
更改並沒有別反映到上下文中

00:15:47.848 --> 00:15:49.950 
而且您的驗證規則都沒有被運行

00:15:50.817 --> 00:15:54.054 
各種關係將被酌情刪除或作廢

00:15:54.121 --> 00:15:56.590 
但是那是你得到的所有保證

00:15:56.657 --> 00:15:58.292 
也有“無對象通知”

00:15:59.293 --> 00:16:02.062 
我們認爲這對有大量副本的人們

00:16:02.129 --> 00:16:03.797 
將確實是有幫助的

00:16:03.864 --> 00:16:05.599 
現在我想爲大家展示它如何工作

00:16:10.037 --> 00:16:12.940 
那麼我這裏有同樣的食譜 app

00:16:13.006 --> 00:16:14.374 
而且帶有一份從我的經理那裏
拷貝來的數據庫

00:16:14.441 --> 00:16:18.579 
他說他的一個孩子拿到了它

00:16:18.645 --> 00:16:21.281 
並且添加了大量的食譜
比如數以千計

00:16:22.349 --> 00:16:24.451 
如果我們以舊的方法檢查它

00:16:24.518 --> 00:16:28.856 
那麼我們將只是用一個讀取請求

00:16:28.922 --> 00:16:32.092 
讀取我們想要刪除的所有對象

00:16:32.726 --> 00:16:36.430 
然後對它們全部進行迭代
刪除它們

00:16:36.530 --> 00:16:39.333 
然後以我們設置的
每批1000的規模

00:16:39.399 --> 00:16:41.368 
保存更改

00:16:41.869 --> 00:16:43.403 
如果您試着這麼做

00:16:47.241 --> 00:16:51.211 
我們可以在這裏的控制檯看到
它會耗費一點時間

00:16:52.346 --> 00:16:53.380 
你可以看到我們在...

00:16:53.447 --> 00:16:54.781 
由於我們在進行
以成千上萬計算的批處理

00:16:54.848 --> 00:16:58.218 
我們現在正在進行第一批
現在仍在進行中

00:17:00.320 --> 00:17:02.723 
這會耗費一點時間
我們將不會站在這裏等着它

00:17:02.789 --> 00:17:07.327 
如果我們在一個合適的點闖入
我們可以強制停止app

00:17:09.229 --> 00:17:12.432 
並再次嘗試使用批刪除

00:17:15.969 --> 00:17:17.271 
讓我們把這些刪了

00:17:22.809 --> 00:17:25.546 
使用與我們之前使用的
同樣的讀取請求

00:17:25.612 --> 00:17:28.849 
建立一個重複刪除請求
然後我們

00:17:28.916 --> 00:17:31.351 
將選擇一個
計數器resultType

00:17:31.418 --> 00:17:33.220 
以便我能夠看到
我們做了些什麼

00:17:34.888 --> 00:17:35.923 
這裏我們將執行它

00:17:35.989 --> 00:17:39.426 
它的代碼少得多
而且只有一個執行請求

00:17:39.493 --> 00:17:41.461 
沒有循環
沒有與對象的互動

00:17:41.528 --> 00:17:43.063 
如果我們運行這段代碼

00:17:47.801 --> 00:17:49.036 
...我們將回到這裏

00:17:53.207 --> 00:17:56.677 
這裏你可以看到
在查詢語句中編輯器

00:17:56.743 --> 00:17:58.745 
建立了一個觸發器
它刪除了所有

00:17:58.812 --> 00:18:01.281 
需要被清理的關係
我們也就完成了這點工作

00:18:03.517 --> 00:18:05.118 
回到下邊簡單地看一些食譜

00:18:05.185 --> 00:18:07.187 
那麼現在我們就可以應用
這些唯一約束條件了

00:18:14.595 --> 00:18:16.597 
那就是
NSBatchDeleteRequest

00:18:18.131 --> 00:18:21.134 
接下來我想談一下模型的版本控制
model versioning

00:18:22.135 --> 00:18:24.872 
當我們創建新版本的食譜app時

00:18:25.706 --> 00:18:27.541 
爲了支持“導入”這一特性

00:18:27.608 --> 00:18:30.410 
我們不得不對食譜實體
添加兩個屬性

00:18:30.477 --> 00:18:33.647 
來源以及外部 ID
瑞西 早些時候給大家演示過了

00:18:34.348 --> 00:18:37.384 
在進行這個工作期間
我們打開了模型

00:18:37.451 --> 00:18:39.353 
添加了兩個屬性
然後構建並運行

00:18:39.419 --> 00:18:41.922 
我們立刻就遇到了錯誤

00:18:43.223 --> 00:18:44.858 
我突出顯示了最重要的部分

00:18:45.392 --> 00:18:48.428 
我們遇到了一個遷移問題
因爲版本已經發生了變化

00:18:48.495 --> 00:18:50.564 
但是我忘記加入
起初的源模型

00:18:50.631 --> 00:18:53.400 
因爲我們就是在它基礎上做出更改的

00:18:54.801 --> 00:18:57.004 
而爲了創建新模型
而複製舊模型的模式

00:18:57.070 --> 00:18:58.472 
確實不方便

00:18:58.539 --> 00:18:59.673 
進行您的app的迭代

00:18:59.773 --> 00:19:02.776 
而如果您忘記將某個模型
部署到運行該版本的客戶手中

00:19:02.843 --> 00:19:04.578 
那確實是危險的

00:19:05.279 --> 00:19:09.416 
這似乎就是自動的輕量級遷移
爲您發揮作用的時候了

00:19:10.350 --> 00:19:14.388 
現在我們的 iOS 9
和 OS X11

00:19:15.222 --> 00:19:16.490 
有模型緩存功能

00:19:17.524 --> 00:19:20.627 
不管你何時創建或遷移存儲

00:19:20.694 --> 00:19:23.197 
或者僅是在新的 iOS 上

00:19:23.263 --> 00:19:26.667 
打開較舊的模型
用來創建它的受管理的對象模型

00:19:26.733 --> 00:19:30.871 
被緩存到存儲內
並且當輕量級遷移任務

00:19:30.938 --> 00:19:32.773 
它們無法找到合適的源模型的時候

00:19:32.840 --> 00:19:36.610 
這可以作爲一種最後一搏的嘗試

00:19:45.185 --> 00:19:46.553 
有幾個限制

00:19:46.620 --> 00:19:48.555 
這隻適用於 SQLite 存儲

00:19:48.789 --> 00:19:50.057 
而且對重量級遷移

00:19:50.123 --> 00:19:51.325 
不提供緩存版本

00:19:51.625 --> 00:19:54.094 
如果您在進行重量級遷移
那您就該讓您的版本準備就緒

00:19:54.161 --> 00:19:58.198 
因爲您需要知道您的遷移
是來自何方 去往何處

00:20:00.467 --> 00:20:03.403 
瑞西 稍早時談到了
我們添加的 API

00:20:03.470 --> 00:20:05.405 
而我現在想談的是一些變化

00:20:06.240 --> 00:20:08.742 
對於 iOS 9 和
iOS X 1010

00:20:08.809 --> 00:20:10.511 
Core Data採用了您已經在

00:20:10.577 --> 00:20:12.679 
Objective-C中看到的
所有語言特性

00:20:12.746 --> 00:20:14.147 
包括泛型和空值

00:20:14.548 --> 00:20:19.820 
我們也利用了一個調用的新屬性
它讓向下轉換變得容易一些

00:20:20.454 --> 00:20:22.256 
您在其他講座裏面可能沒有看到

00:20:22.322 --> 00:20:25.058 
但這對Core Data來說
確實是方便的

00:20:25.459 --> 00:20:28.128 
因爲如果你正在
與一個對象類型ID互動

00:20:28.195 --> 00:20:31.465 
您可以將其向下轉換
到甚至完全不適合的類型

00:20:31.932 --> 00:20:34.635 
你可以爲某個類型設置屬性

00:20:34.701 --> 00:20:37.538 
但是它只能被向下轉換
到該種類型的子類型

00:20:39.072 --> 00:20:41.208 
這將會在編譯器上爲您的代碼
增加很多安全性

00:20:41.775 --> 00:20:43.944 
因爲當一個緩存似乎毫無意義時

00:20:44.011 --> 00:20:46.747 
它會限制發出警報

00:20:49.249 --> 00:20:51.919 
爲了使用泛型
已生成的子類也已被更新

00:20:52.186 --> 00:20:54.521 
以便滿足大量的關係
以及空值的需求

00:20:54.955 --> 00:20:56.423 
而且我們已經對子類的生成機制

00:20:56.490 --> 00:20:58.625 
做出了一些其他的更改

00:20:59.359 --> 00:21:04.364 
在 Xcode 6 中
您會有一個執行文件

00:21:04.431 --> 00:21:07.201 
和一個頭文件用於使用同時包含
Core Data聲明

00:21:07.634 --> 00:21:11.905 
和放置您的所有代碼的空位的
Objective-C

00:21:11.972 --> 00:21:14.908 
它被用過之後就被扔掉了

00:21:14.975 --> 00:21:17.511 
但是如果你更改了自己的版本

00:21:17.578 --> 00:21:19.279 
更新日期就會變得有些不方便

00:21:19.346 --> 00:21:21.882 
因此在 Xcode 7 中
我們增加了一個新的文件

00:21:23.584 --> 00:21:26.119 
這個文件是一個擴展或類別

00:21:26.186 --> 00:21:27.421 
取決於頭文件中

00:21:27.487 --> 00:21:30.891 
包含所有你熟悉的聲明的語言

00:21:32.926 --> 00:21:35.529 
那麼現在 頭文件
和執行文件是屬於你自己的

00:21:35.596 --> 00:21:39.199 
不管你何時更新模型
你所需做的就是更新這個文件

00:21:48.942 --> 00:21:50.344 
關於變化就說那麼多

00:21:50.878 --> 00:21:53.013 
我想談一下我們棄用的東西

00:21:53.647 --> 00:21:56.250 
我們將在 iOs9 和
OS 1010 中

00:21:56.884 --> 00:21:59.019 
去掉confinementConcurrency

00:21:59.086 --> 00:22:01.421 
它已經被標爲“棄用”
我們將在以後去掉它

00:22:03.490 --> 00:22:06.593 
因爲對於新的受管理的對象上下文

00:22:06.660 --> 00:22:10.063 
Confinement是默認行爲
因此我們也已經將其棄用

00:22:10.797 --> 00:22:13.800 
因此未來您將使用
init concurrencyType

00:22:13.867 --> 00:22:15.269 
爲您的上下文使用

00:22:15.335 --> 00:22:17.538 
專用隊列或主隊列

00:22:18.005 --> 00:22:18.906 
如果您已經

00:22:18.972 --> 00:22:23.043 
進行到了區塊 API
這確實是一個不錯的主義

00:22:23.110 --> 00:22:25.412 
封裝操作大大簡化了您對

00:22:25.479 --> 00:22:28.448 
自己的模型代碼的推演而對Core
Data的併發性調試支持

00:22:28.515 --> 00:22:30.150 
也增強了很多

00:22:31.885 --> 00:22:35.255 
我強烈建議查看在線文稿

00:22:35.489 --> 00:22:38.292 
今年 Core Data
指南已被徹底更新

00:22:38.959 --> 00:22:41.028 
而 亞當·斯威夫特 也介紹了
區塊 API

00:22:41.094 --> 00:22:42.863 
他在 WWDC 2011 中的

00:22:42.930 --> 00:22:44.264 
《Core Data on iOS
中的新內容》

00:22:44.331 --> 00:22:46.366 
講得確實不錯

00:22:47.301 --> 00:22:49.770 
最後我想談一下性能

00:22:52.172 --> 00:22:55.709 
隨着時間推移
我們開始爲模型增加屬性

00:22:56.810 --> 00:23:00.380 
由於這些年對我們的app不離不棄
您的用戶攜帶的數據量在增大

00:23:00.447 --> 00:23:03.784 
而我們試圖查詢和顯示數據的方式

00:23:03.851 --> 00:23:07.054 
也在變得更加有趣 更加先進

00:23:07.487 --> 00:23:09.923 
我們的 app 也在維持很快的速度

00:23:11.925 --> 00:23:14.962 
但是您怎樣避免
突然出現性能問題呢？

00:23:15.963 --> 00:23:17.397 
在開發過程中
您處理的是

00:23:17.464 --> 00:23:19.266 
已知的可能較小的數據集

00:23:19.333 --> 00:23:20.534 
比您的客戶將要處理的要小

00:23:20.734 --> 00:23:23.837 
而模擬器又比僅僅
維持設備運行所需快得多

00:23:24.638 --> 00:23:26.373 
儘管它對開發非常有幫助

00:23:27.107 --> 00:23:29.443 
用戶將會使用帶有生產數據的設備

00:23:30.744 --> 00:23:34.515 
幸運的是我們提供一些工具

00:23:35.682 --> 00:23:37.751 
讓您發現能夠表明性能問題的模式

00:23:37.818 --> 00:23:39.820 
因此在它們在您的客戶手裏
成爲問題之前

00:23:39.887 --> 00:23:41.488 
您就可以解決它們

00:23:41.788 --> 00:23:44.858 
我想講三個需要注意的事情

00:23:44.925 --> 00:23:47.160 
首先是關係錯誤

00:23:48.629 --> 00:23:50.564 
這是 Core Data 工具

00:23:51.598 --> 00:23:53.500 
我們剛剛運行了食譜 app

00:23:53.901 --> 00:23:58.539 
在緩存缺失的工具項目下
我們立刻看見

00:23:58.605 --> 00:24:02.409 
我們在三個想要顯示的
對象上的緩存丟失了

00:24:03.076 --> 00:24:06.513 
如果我們查看中間的那一列
我們會看到它們的食譜類型

00:24:07.981 --> 00:24:10.384 
而現在你還記得我們今年
開發這個食譜 app 時

00:24:10.450 --> 00:24:12.819 
我們對其進行了更新
以便讓主列表視圖

00:24:12.886 --> 00:24:14.721 
在顯示食譜本身的同時
顯示食譜的類型

00:24:14.788 --> 00:24:16.390 
但是我們從未更改讀取請求

00:24:17.791 --> 00:24:19.660 
我們可以通過向我們用來查看

00:24:19.726 --> 00:24:21.161 
NSFetchResultsController
的

00:24:21.228 --> 00:24:22.429 
查詢命令增加一個

00:24:22.496 --> 00:24:24.565 
relationshipKeypathsForPrefetching

00:24:24.631 --> 00:24:26.166 
來解決這個問題

00:24:27.100 --> 00:24:29.403 
現在 那些-那第一組

00:24:29.469 --> 00:24:31.872 
丟失的緩存將不再是個問題

00:24:32.172 --> 00:24:34.374 
如果我們回到同樣的工具

00:24:34.441 --> 00:24:35.843 
並且在稍後時再看下app裏面

00:24:35.909 --> 00:24:38.045 
我們可以看到
當我們查看一個食譜的詳情時

00:24:38.111 --> 00:24:40.314 
我們也引發了幾個

00:24:40.380 --> 00:24:41.682 
對數據庫的查詢

00:24:42.549 --> 00:24:47.254 
這是因爲詳情查詢控制器
從列表獲得模型對象

00:24:47.621 --> 00:24:50.123 
然後在詳細視圖裏面我們顯示

00:24:50.190 --> 00:24:51.792 
那個食譜中的所有原料

00:24:52.392 --> 00:24:53.727 
我們不能使用預讀取操作

00:24:53.794 --> 00:24:55.796 
因爲那樣我們將預讀取
列表視圖中顯示的

00:24:55.863 --> 00:24:57.865 
所有食譜的所有原料

00:24:57.931 --> 00:25:00.868 
在詳細視圖中
在控制器中

00:25:01.168 --> 00:25:04.338 
我們必須執行另一個讀取請求
以便讓那些原料出現在內存中

00:25:04.671 --> 00:25:07.107 
現在我們已經將9個查詢變成1個

00:25:07.174 --> 00:25:09.843 
而我們仍能在食譜上使用這一關係

00:25:09.910 --> 00:25:12.079 
對其遍歷並且與它返回的數據集互動

00:25:12.145 --> 00:25:14.114 
因爲數據是在多個對象間共享的

00:25:17.451 --> 00:25:20.721 
最後如果我們看一下
Core Data 工具視圖中的

00:25:20.787 --> 00:25:23.824 
讀取工具
我們可以看到

00:25:23.891 --> 00:25:27.895 
第一個讀取請求花費的時間
超過了我們的預期

00:25:28.896 --> 00:25:31.164 
它讀取了 85 個對象

00:25:31.598 --> 00:25:33.300 
當時我們只有 85 個對象

00:25:33.367 --> 00:25:35.903 
如果我們有3萬個對象的話
就像我在的示範中演示的那樣

00:25:35.969 --> 00:25:38.372 
這將確實是糟糕
app 甚至很可能不會啓動

00:25:40.407 --> 00:25:44.278 
在 Mac Pro上
它花費了15 毫秒

00:25:45.212 --> 00:25:47.948 
那在 iOS 上會有大量的掉幀

00:25:48.348 --> 00:25:52.085 
那麼爲解決這個問題
我們能做的就是增加

00:25:52.152 --> 00:25:54.855 
我們向讀取結果控制器
輸入的讀取請求的批的大小

00:25:54.922 --> 00:25:58.358 
以便讓對象僅按顯示的需要
從存儲讀取

00:25:59.359 --> 00:26:03.864 
我想展示的最後一項內容是...
sequence blocking

00:26:05.132 --> 00:26:08.068 
如果您的讀取確實複雜
且耗費大量時間

00:26:08.836 --> 00:26:11.939 
那麼您可以通過在程序上
使用這個參數找到它們

00:26:12.005 --> 00:26:15.042 
而它會在您的讀取請求
運行的同時

00:26:15.309 --> 00:26:20.180 
開始輸出相關數據

00:26:20.280 --> 00:26:23.617 
這種情況下我們有一個查詢
而它所花費的時間

00:26:23.684 --> 00:26:28.322 
大約是十分之一秒

00:26:28.388 --> 00:26:29.790 
返回了 85 行結果

00:26:30.290 --> 00:26:31.491 
那是相當慢的

00:26:31.558 --> 00:26:33.060 
我們將看一下如何做得更好

00:26:33.961 --> 00:26:35.762 
如果我們向控制檯的更高處滾動

00:26:35.829 --> 00:26:37.998 
我們看到它輸出了
我們正在使用的文件

00:26:38.432 --> 00:26:40.501 
我們可以使用
SQLite連接那個文件

00:26:40.567 --> 00:26:42.169 
以便弄清楚正在發生的情況

00:26:43.670 --> 00:26:44.838 
如果我們把查詢粘貼進去

00:26:44.905 --> 00:26:46.874 
在 EXPLAIN QUERY
PLAN之後

00:26:46.940 --> 00:26:48.275 
SQlite將告訴我們
它將試圖做些什麼

00:26:48.342 --> 00:26:51.512 
以便用這個圖表來回答我們的查詢

00:26:52.813 --> 00:26:56.850 
這裏有幾個需要注意的事情

00:26:56.917 --> 00:26:59.319 
我們可以將其作爲
衡量性能如何的度量指標

00:26:59.386 --> 00:27:03.323 
第一個是掃描表
掃描表就是說SQLite

00:27:03.390 --> 00:27:07.427 
將觸探每行內容 檢查每行內容
以完成查詢

00:27:08.095 --> 00:27:10.364 
而在食譜表裏面
就像是稍早些時候一樣

00:27:10.430 --> 00:27:12.599 
我們有 3 萬行內容
而我們將進行兩次檢查

00:27:12.666 --> 00:27:14.134 
因此那將不會太快

00:27:14.201 --> 00:27:15.669 
我們將進行考查 讓它變得更好

00:27:16.770 --> 00:27:19.806 
此外 我們還使用臨時 B 樹

00:27:20.374 --> 00:27:23.944 
在這一步 SQLite利用數據
創建其自身的內存架構

00:27:24.011 --> 00:27:28.348 
以便實現排序或快速搜索

00:27:30.317 --> 00:27:33.453 
現在使用臨時 B-樹
是因爲這裏的這個group by

00:27:33.720 --> 00:27:36.323 
如果我們更仔細地看一下

00:27:36.390 --> 00:27:38.825 
它是因爲外部 ID 中的來源

00:27:39.893 --> 00:27:42.930 
通過使用複合索引
我們應能夠讓這個過程加快

00:27:43.430 --> 00:27:45.933 
在Core Data模型編輯器中
我們可以在這裏的右側

00:27:46.033 --> 00:27:47.568 
添加一個複合索引

00:27:50.137 --> 00:27:52.573 
現在如果我們退出 SQLite
重建我們的項目

00:27:52.739 --> 00:27:55.175 
執行遷移並且用SQLite連接
到新的數據庫

00:27:55.242 --> 00:27:58.312 
我們會發現
我們正在使用索引

00:27:59.012 --> 00:28:02.583 
使用索引意味着搜索將會很快

00:28:03.417 --> 00:28:06.753 
使用覆蓋索引更快
這意味着那一步的結果

00:28:06.820 --> 00:28:09.423 
是按照下一步需要的
自然順序排列的

00:28:09.990 --> 00:28:12.392 
因此我們已經
完全清除了臨時 B 樹

00:28:13.460 --> 00:28:15.829 
但我們仍有這個掃描表

00:28:17.130 --> 00:28:20.067 
在這種情況下
我們將匹配重複對象

00:28:20.133 --> 00:28:24.238 
這是我們在示範中使用的查詢
目的是找到需要刪除的對象

00:28:24.838 --> 00:28:27.641 
它必須掃描整個表格
它的速度是可以更快的

00:28:28.775 --> 00:28:31.745 
剩下的唯一要做的事是確保
我們不碰主線程

00:28:32.379 --> 00:28:34.581 
在此例中我們將使用
一個專用隊列上下文

00:28:35.015 --> 00:28:38.785 
但是如果您打算創建某些複合數據

00:28:38.852 --> 00:28:40.854 
以便向用戶展示

00:28:40.921 --> 00:28:42.823 
您可能希望使用這個同步讀取請求

00:28:42.890 --> 00:28:45.058 
它將在主線程工作的時候
離開主線程

00:28:45.125 --> 00:28:46.960 
然後當得到結果的時候再返回

00:28:47.995 --> 00:28:50.397 
那麼這些就是在您的 app 中
需要留意的三種主要模式

00:28:50.464 --> 00:28:52.099 
它們讓您能夠在性能問題

00:28:52.165 --> 00:28:55.235 
真正成爲問題之前
解決它們

00:28:57.905 --> 00:29:00.174 
關於今年Core
Data中的新內容就講到這裏

00:29:00.240 --> 00:29:02.075 
如果您發現任何問題
請將其提交

00:29:02.142 --> 00:29:04.478 
對立刻重新寫出的示例app代碼
有一個獎勵

00:29:04.545 --> 00:29:06.880 
它的錯誤會最先得到修復

00:29:07.548 --> 00:29:09.149 
但是我們也有興趣聽到

00:29:09.216 --> 00:29:11.285 
你們希望在Core Data
中看到的東西

00:29:11.351 --> 00:29:13.787 
功能上的要求 改善方面的想法
而如我所言

00:29:13.854 --> 00:29:17.524 
今年的文稿指南已全部經過修改
因此如果您發現任何相關問題

00:29:17.591 --> 00:29:19.560 
我們也將樂於瞭解

00:29:20.794 --> 00:29:23.197 
如需更多信息
請訪問開發者門戶

00:29:23.864 --> 00:29:25.799 
我們的文稿以及示例代碼

00:29:25.866 --> 00:29:28.802 
您可以在開發者論壇
或通過 DTS 獲得支持

00:29:29.870 --> 00:29:30.971 
感謝您的蒞臨！