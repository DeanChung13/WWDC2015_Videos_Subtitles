SpriteKit 新功能 
大家好欢迎来到“SpriteKit新功能 ”讲座
今天 我们将要告诉大家一系列很棒的
新功能和改进
我知道在座的各位中有很多人是第一次来听SpriteKit讲座
首先 我想要花几分钟来
回顾我们所要讲的是什么
SpriteKit是苹果2D游戏和图形的框架
我们将给你提供集成的物理运动 
离子运动模拟 动作
以及动画 当然 还有计算机子图
我们启动（这个项目）是想要将SpriteKit做得不仅仅是强大
而且要非常容易上手使用
我们希望一个之前完全没有做过游戏的人
能够来到我们的平台
开始使用SpriteKit
并且能够花很少的时间得到提高并熟悉（SpriteKit）
我们非常期望能够传达出一些东西
能够使你专心致志地做你最擅长的事情
那就是做出最棒的游戏
我们将SpriteKit设计成
可以在iPhone、iPad以及Mac上工作
并且你也能够通过这个平台将你的app
应用到多个平台上这也就意味着
你能够直接在Mac上设计原型
并测试你的SpriteKit游戏
在你将它（游戏）安装到一个设备上之前
可以说 有了SpriteKit 游戏构架的开发能够做到事半功倍
在刚开始的时候我们花费了大量的精力在我们的工具上
在后续的几年里我们也在持续地进行投资
就是为了能够
让你能够像编辑整个画面一样编辑粒子效果
直到今年年初也同样
能够对运动和动画进行编辑
只需要在写代码前
加入一段Xcode即可
现在 我们可以开始讲解这个构架有哪些新功能了
第一点 也是开发人员强烈要求的一点
就是视窗
视窗是指
当我们在讨论你的场景的时候这部分（场景）是可见的
在任何时候通过SpriteKit视角
现在的这种工作方式是如果你想要移动你的镜头
你不得不移动你游戏中的每一块几何图案
或者如果你想要跟随你的一个英雄人物
穿越你的整个游戏界面
你就需要做这些计算
现在这样的工作
但是它并不像我们想象中的那样直观
如果你想要对这些游戏实体进行物理模拟 
当你移动他们的实际位置时
你可以从中看到一些伪影
我们认为我们能够做的更好
接下来我们介绍SKCameraNode.
通过CameraNode
我们允许你能够简单的指定你看到的部分
变得可视化 镜头通过
展现你的场景中所包含的
可视化中心来达到这样的效果
这样你就可以在你的画面中任意移动
CameraNode
同样的你也可以在你的画面中移动其他的
所有的游戏实体
我们在SKScene中设置了一个属性
这个属性将允许你选择你想使用的包含这些场景的镜头
在你的场景中你可以选择多个镜头
同样你也可以通过属性选择活动的镜头
如果你不理会属性 即其缺省值为零
我们将会保存所有你今天的使用记录
并且所有的SpriteKit渲染效果
都和从前一样不会改变
但是SKCameraNode中最棒的功能是
它作为一个节点存在
这就意味着你能够使用SpriteKit节点中
所有伟大的功能
你可以访问我们的动作数据库
这样你就能够在镜头上运行这样的动作（数据）
你也可以使用我们的约束系统
这样你就能够对镜头进行约束
你可以让它与游戏实体相结合
你也可以让它总是保留在
距离你游戏中物体的一定范围内
除了移动镜头之外你还能够通过这些节点的属性
来控制旋转和尺度
例如
在这样一个游戏中 
我想将镜头放到一旁
我可能应用一些移动动画
来揭示我的视线中有坏人
在我将我的游戏角色放在视线中央之前
之后我可以应用一些尺度命令 
来实现镜头的变焦操作
我甚至可以使用我们的跟踪路径运动
如果我想要镜头跟踪一个贝塞尔曲线
如果我真的非常想让我的用户感到恶心
我可以旋转镜头
或者将镜头在场景中到处扔来扔去
所以现在在SpriteKit中你完全可以控制你的游戏
哪些部分是可见的
我认为这将会是你的工具中的一件很棒的新品
对镜头的改进
同样的我们也针对音频做了很多工作
我们添加了一个SKAudioNode
允许你在你的SpriteKit游戏中
添加位置和环境的背景音
我们借助了我们去年发布的Apple强大的
AV音频引擎构架
如果你对这个并不熟悉
它允许你指定你的语气音量
并能够作为特定环境中的声音发射器
它可以回放你制定位置
侦听器获得的声音
在SpriteKit中我们将为你做好所有的画线工作
所有你需要做的工作就是通过文件名或者URL指定
你想要播放的背景音乐
我们将会使用AudioNodes 
跟随你指定的侦听器的位置在你的场景中定位
并画出音频曲线 让你能够更容易地
身临其境地在游戏中定位你的音频
如果你想深入一点 亲自动手
你也可以通过底层AVAudioNode的
一个节点的属性 去掉所有的约束
在那里设置所有的你想要的东西
为了掩饰这种效果
你能够使用
最新的技术将其添加到你的SpriteKit游戏中
现在我又一个例子
这里是我的制作的一个地精
我打算让他作为我的听众
所以我把我的侦听器位置放在这里
我已经在我的场景中添加了一个火球
这是我的音频资源
在这里我已经将其作为一个SKAudioNode添加了进来
我重新播放这个音乐的时候
注意听这个音频的效果怎么样
当火球在整个场景中来回运动的时候
你能够注意到
它变得更加饱满 更加集中 声音也更大了
当它靠近我们的侦听器时
从远到近
直到来到场景这一边现在我们听一下
很酷 不是吗？
除了这些额外的设置
我不需要做任何事情来处理这些特效
当他们在游戏场景中运动的时候他们已经和
驱动游戏运行的逻辑联系在了一起
同样的今年我们也重点关注了引用和实例化
我们知道你花了很多时间为你的游戏设计
内容和动画 我们也希望你能够在
任何你想用的地方重新使用这些内容
我们将允许你能够为你的节点和动作创建序列化数据文件
创建序列化数据文件
并将其作为一个引用参数添加进来
而不是简单的加载到你的场景中
这样
你每次对资源文件进行修改之后
将会自动地对你的游戏内容产生影响
我怎么做这个节点呢?
我设计了一部分场景作为节点
可以是一个背景元素或者是Xcode编辑器中的一些画面
接下来我可以通过Xcode将这些文件
拖放到主场景中
接下来它会自动地创建一个参数
这些都是为你设置好的
如果你想写代码来完成这些事情同样可以
你可以手动构建一个SKReferenceNode
为其分配一个文件名或者URL
当这些内容在你的游戏中是第一次发布时
我们会将你的包中这些内容的最新版本的
文件进行上传
我们同样能够这样处理一些动作
通过这些动作作品
能够看出我们的新动作编辑器是多么的伟大
同时那些你在Xcode中创作的动作你都 有命名的权利
这些名字将是你在游戏中使用它们时候的关键字
我们在SKAction中添加了
一个名叫actionNamed的筛选器
它的作用就像
textureNamed对于SKTexture一样
你可以输入你想要的动作的名字
我们将自动在你的App包中的
序列化动作文件中 找到
一个最合适的文件
然后将其在应用程序中呈现出来
在你的游戏中请频繁使用这个功能
我们做了所有的关于内存的工作
我们可以保证你的游戏中所有相同的动作绝对不会
从硬盘中重复地加载多次
有时候你可能会想要让同一个动作重复多次
但它会播放得时快时慢
我们添加了一个额外的选择器
它将允许你能够覆盖操作的持续时间
这是一个智能时间轴
所以即使你使用的是嵌套组和序列中的嵌套 动作
它将动态规划新的时间轴
这样 每个时间区间内的动作组件
都将会是一样的大小
这些都是为可重复使用组件设计的工具
这些可重复使用组件你可以在同一个游戏的同一个场景
或者跨越多个不同的游戏中使用
我们同样在构架中添加了一系列新的动作
所以现在我们有了这些位置AudioNodes
就能够通过动作更好的控制回放
我们已经添加了播放,暂停,回放速度
以及操作体积和立体平移等开关
我们也在帧动画中做了一些改动
在SpriteKit中我们一直都有通过纹理动作运动
做出来的基于帧的动画
但是去年我们在SpriteKit中引入了lighting
通过lighting
你不仅能够在你的场景中为Sprites自动生成
也能够自主添加常规的纹理动作
然后我们可以在运行时动态的点亮他们
通过在你的场景中移动光节点
这种做法对于稳定的元素来讲很方便
但是如果我有一个基于帧的动画例如这个东西
我们想要这些高亮和阴影部分
在当前位置分开
我们不想要腿前面所在的区域高亮
所以 我们添加了一个
正常纹理运动的动画
所以你可以使用这个 在正常的动画
与每一帧之间 进行同步
如果我在我的人物上运行了这种动画并给场景添加了lighting
你就会看到所有的高亮区域 阴影都能与每一帧保 持同步
无论我的人物如何跑动
这些就是我们添加到构架中的新功能
我们也做了很多其他的工作使这些功能能够与
系统的其他部分更好的结合在一起
更好的发挥已经添加到我们平台上的
新硬件和构架的优势
首先我想讲的是Metal
我们正在开发SpriteKit
并且我们正准备将它直接链接到IOS和 Mac的Metal平台上
将能够在任何支持Metal的设备上使用
以及那些不会自动降级到OpenGL的设备上
这意味着你的CPU使用率会降低
这意味着作为一个开发人员你将会得到更好的绘制调用性能
以及更好的电池使用寿命
因为将能够做到零运动请求
我们将自动升级所有的SpriteKit程序
你不需要重新编译
或重新提交
只要它支持Metal 你就能够运行
如果你对自定义着色器感兴趣的话
我们也同样顾及到了
如果你的游戏中有自定义着色器
我们几乎支持所有的Metal变体的升级
同样能够在支持Metal的设备上很好地运行
接下来是Swift
我们看了整个API的文件
并且我们向其中添加了可空性限定符
我们采用了Objective-C泛型数组类型
用作参数或者返回类型
这将是你能够很方便的
从Swift中访问SpriteKit的所有功能
这也能够给你的软件提供增强版的安全性
增强版的安全性无论你是使用Swift
还是Objective C
现在我想讲一下SceneKit
或许你并不知道Scenekit
我们允许你用SceneKit体现SpriteKit
也可以用SpriteKit体现SceneKit
今年我们允许你能做到的更多一点
可以直接在SceneKits游戏中使用
所有你知道和你喜欢的SpriteKit过渡效果
你甚至都不需要用SpriteKit去做
你可以像使用门一样使用这个转换器剪辑
甚至你的SceneKit游戏中基于转换效果的核心图片
同样能够有很好的效果
这个版本的SceneKit同样支持
Metal背景下的内容
我们可以自动匹配好
如果你有一个支持在Metal上运行的SceneKit游戏 
我们通过使用Metal
可以使你得到SpriteKit内容
去过你有一个支持GL上运行的SceneKit游戏
我们可以通过使用OpenGL使你得到SpriteKit
你永远不会产生额外的开销
在两个API之间进行转换时
今年我们也发布了一个全新的构架
叫做 GameplayKit
这个构架很棒
它将提供给你创建一个游戏逻辑结构所需的所有基础
就像Entity/Component系统一样
作为状态机
而且还提供了非常棒的工具
例如AI对手和确定性随机源
有一点我非常喜欢
那就是它能够为你的游戏提供一个路径寻找的解决方案
我相信很多SpriteKit工程师会对这个功能感兴趣
GameplayKit中寻路的工作方式是
你指定一个可穿越的导航图
在你的游戏世界中
之后你将会在这些节点之间连线
并给出一个相关成本
只要你给出了这个地图
GameplayKit 将计算出地图上
这两个点之间的最优路径
我怎样在游戏中设置呢？
加入我这里有一个SpriteKit游戏
我的英雄在下面的这个角 我...嗯…
假如我想让他移动到某一个目的地
然后在我的地图上指定几个障碍物
障碍物是不可穿越的地区
将这些数据给GameplayKit之后
给我的想要穿越地图的角色周围设置一个缓冲半径
GameplayKit 会将缓冲半径计算进去
自动扩展所有的障碍物
这样我们不会进入任何障碍物的缓冲半径中
然后在地图中创建有效的连接图
并且只创建有效的连接
所以我们永远不会穿越这些障碍物
然后你就可以在你的游戏中使用这些来进行
寻路操作
这个功能并不专属于 SpriteKit
所以你可以在SceneKit中使用GameplayKits
SpriteKit, OpenGL, Metal
等等任何类型的游戏都可以
如果你使用的是SpriteKit我们可以使它变得更容易
你甚至都不需要创建障碍物
你可以使用Sprite界限直接创建障碍物
你可以根据你在Sprite上设置的物理主体
创建障碍物
甚至从与你游戏中Sprite相关纹理的
Alpha透明度信息中创建障碍物
这给了你一种非常简单的在SpriteKit软件中利用
GameplayKits寻路的方法
就像我之前说的
构架只是我们工作的一部分
今年我们对我们的工具进行了大量非常棒的改进
接下来我想将这些交给Norman
来讲解
谢谢你 提姆
开发游戏是一个复杂并且不断迭代的过程
游戏的各个部分需要像玩游戏一样不断迭代
以保证一个游戏的趣味性
动画 用来确保一个角色移动的流畅性
艺术性 用来保证屏幕上的像素点
能够流行起来
作为一个游戏工程师你不仅会遇到迭代问题
你还会遇到可伸缩性问题
我要怎样才能跨越多个等级复制我的设计呢？
在苹果公司我们当初启动设计SpriteKit 的工程时
我们不仅想要为你提供一个高性能
且易用的API
而且要为你提供一个可伸缩和迭代的工具
这样我们就能专注于开发游戏
从SpriteKit 构架的第一个版本发布
我们已经开发并
持续向Xcode中
添加了多个工具
让我来给你们展示一下作为一个SpriteKit用户
你能够使用哪些工具
第一个要介绍的是纹理地图集
使用texture atlas的第一个主要好处就是
能够提升性能
SpriteKit通过纹理地图集将大量的图片调用命令最小化
并发送给GPU以达到优化效率的目的
我们不想强迫我们的用户适应手动
创建这些纹理地图集的过程
每次对资源进行修改的时候
这些手动的过程都必须从头再来一遍
所以我们开发了一个自动的纹理地图集生成器
在Xcode中
创建一个这种地图集
就像拖拽一个文件夹到你的工作区中一样简单
同样的我们在开发的时候也会自动做一些事情
每一张资源图片
都会自动经历一个复杂的后期处理过程
例如我们会为图片修剪Alpha透明像素
但是这并不会在屏幕上有任何体现
如果旋转90度能够让这些图片更紧凑
或者能得到一个更小的地图集的话 我们会进行这样的旋转
对于每一个资源图片 
我们都会对其进行其边缘的审查
如果其实完全不透明的
我们将会对其边缘进行压缩
当你在场景中堆叠这些图片时
你不会看到任何接缝
这就是纹理地图集自动生成器
今年我们将它做得更好了
现在你可以生成纹理地图集
来代替资源目录了
使用资源目录生成地图集
有两个主要好处
第一
你可以精确地
为你的目标设备
适配到合适分辨率的图片
你不需要严格按照你的图片名字的后缀来查找
例如添加2X或者添加2X到iphone
所有的这些都能在在UI中设计好
第二个
有点就是我们现在支持 ...
在资源目录中
每一组的目标分辨率
将会根据他们设备的独立纹理来生成
当用户打开App Store
并下载下来你的SpriteKit授权游戏时
只有与他或她的设备
相适配的地图集才会被下载下来
这不仅能够使下载时的带宽最小
同样能够使其安装到用户手机的时间最短
同样能够最小化应用程序的存储开销
另外 纹理地图集支持基于命令资源
基于命令的资源是一个全新的API
它使你能够在游戏运行的情况下
从网上下载艺术资源流
SpriteKit也集成了这种功能
这种资源是通过标签来识别的
例如
这是我的Inspector中的Xcode写的背景元素
我可以指定一个与其相关联的标签
我把它叫做一级背景
这些就是标签 你可以通过这些标签
检索这个资源
并且开启背景流媒体
当你的程序调用它的时候
粒子效果
可以有效地帮助你准确的建立起游戏
我们将这个构架中的SKEmitterNode
作为一个强大且灵活的APIs
提供给你来使用
强大并灵活也有缺点
那就是你需要设置49个属性
你需要对这49个属性
进行排列组合
来达到你想要的视觉和感觉效果
你需要做的就是花费更多的时间
因为我们在Xcode中
开发了一个粒子编辑器
它是使用同一个SpriteKit呈现驱动
可以让你能够
在你的工作区中直观的看到它
所以你无需编写任何代码
就能够对这49个属性进行调整和改变
也无需重建你的游戏
这些粒子将作为一个很小的数据文件导出
并能够被序列化
也能够部署在多个等级或者多个项目中
SpriteKit同样支持Quick Look.
例如 我正在努力学习新的Swift
我创建了一个全新的场景
并努力地在SpriteKit API中使用
全新的Swift 2.0语言
我正在做的事情就是创建一个坏蛋角色
就叫坏人 这是一个Sprite节点
它是一个叫做车罩的单独纹理复制出来的
另外 我创建两个子节点 
在这个坏人节点之下
一个有屋顶的纹理
另一个有树干的纹理
这里会发生什么呢？
SpriteKit的部分屏幕中将会呈现这些看不见的东西
当你努力去
内观一个Sprite节点的时候
它会将结果为你呈现在窗口中
这样 你试着学习一个新的语言或者
更改一个对象的每一步都会呈现出来
你将会在窗口中看到实时的变化
另外SpriteKit中的Quicklook
同样支持
在你调试程序的时候
无论你是使用Swift
还是Objective-C
无论他们是在IOS设备上运行
还是在Mac OS X上运行
这里我想试着去调试一个我写的程序
我触发了一个断点
目标过程其实停止了 
但是我们仍然能够
隐藏这部分显示并呈现出目前的纹理
并在调试器中显示出来
所以你能够清楚地知道
这个纹理是我之前调试的
并将它抓取出来分配给了一个SKSpriteNode
去年 IOS8中我们发布了一个虚拟场景编辑器
他允许你建立一个完整的场景布局
并不需要编写任何代码
你不仅可以设置场景中每一个
可选节点的位置 旋转和尺度
你同样可以定义其物理属性例如
图片 重力 质量和摩擦
你也可以进行这些物理仿真的
实时模拟
而这些并不需要你登陆游戏或者重新编译你的程序
SpriteKit也将支持一些先进的渲染技术
例如自定义着色器等
在这一层上 这个瀑布的背景和
雾的底部实际上我使用了
两个自定义着色器
要添加着色器 
他就像打开帮助编辑器一样简单
它会自动在你的当前场景中显示出来
当然这是渲染过后的
并向你展示附有源代码的
助理编辑器
你在助理编辑器中
所做的任何实时的修改
都会自动进行编译
打开OpenGL或者Metal
会为你提供一个真正实时的视窗
而不是都建整个游戏
跨越整个层
以及特定的节点
触发这个事件来确定我是否真的发送了一个流给OpenGL或者Metal
无论是否编译成功
这将节省很多迭代的时间
今年我们花了大量的时间来
对虚拟场景编辑器进行改进升级
第一个请求的类型是自定义的
现在 在我的英雄角色所处的这一层
我可以将它指定为一个类
这个类的名字叫做角色类
当场景被反序列化运行时
无论你的程序是用Objective-C还是用Swift写的
正确的类将会被创建并实例化
并加载到场景中 在场景运行的时候
另外
从SKNodes项目开始的第一天起
我们就一直忙于它的支撑工作
现在你能够使用编辑其中的
镜头节点
音频节点定位 
以及ReferenceNode
来设计你的场景
能够在编辑器中看到镜头发送
准确的时间轴、缩放因子
以及动作
而并不需要
编译整个游戏是多么酷炫的一件事
你也可以
设置SKAudioNode的位置
并将之移动
来亲自听实时的音效变化
以确定你在场景中想要的效果是否设置正确
今年 前端工具中最激动人心的功能是
能够设计
复杂的动作
你可以通过基础构建模块
设计出一个非常复杂的动作
我们已经将其作为SpriteKit的动作部分提供给了大家
它是基于时间线的
和Xcode中的其他编辑器一样
他也支持实时可视化
你不仅可以
用它来开发2D动作
也可以用来为SceneKit设计3D动画
都是同样的编辑器
你也可以创建电影动画
电影动画可以作为场景动画的一部分
当场景加载的时候任何包含这种动作的节点
都会自动运行起来
你也可以创建交互式动画
例如循环动画
或者跳转动画从窗台掉落
通过一行或两行代码出发折叠动画
在不同的游戏场景中
这里有一个场景
我将镜头设计为移动的
现在锁定游戏角色
角色开始运动
运行行走动作循环
穿越整个场景 这就是开场
你也可以在五分钟之完成这些
今年2D和3D的前端工具中
另一个主要关注点就是
能够做引用和实例化
在SpriteKit上
一直是支持对动作或节点的引用
这些都是你场景中的艺术资源
这些都是可重复使用的组件
这些都是数据文件
能够在不同的工程中
不同的人之间 不同的层次上共享
在使用这些引用文件时
你不需要写任何代码
创建引用动画非常简单
我们在Xcode中提供一种全新的SK动作文件模板
你可以打包一个纯粹的动画文件
设计好所有的复杂的动画
将之命名
使这些动作可以被SKAction检索
使用actionNamed选择器
创建正确的实例并将之添加到你的场景中
任何引用的动作都将会被自动筛选出来
放到一个对象库中
如果你想在不同的场景中
或者不同的层中
再次使用这些动作 这只是一个
从对象库中拖放的问题
创建一个引用节点也很简单
就像在你的工作区中拖一个SKS文件
放到你的场景中一样简单
对于这些引用
我们会自动在编辑器中
生成SKReferenceNode实例
并为你分配合适的URL
你同样可以使用API创建一个自定义节点收藏夹
例如 我有一个鸟笼
我打算用它作为一个
不同的层之间的层道具
我可以在多个层之间建立起来
并将其实例化
任何对鸟笼原设计的修改
都会被自动地反映到
每一个引用了这个设计的实例中
这样你就能够在编辑器中手动地
修改和更新引用文件了
接下来我想邀请泰勒上台来给大家
演示一下Xcode中的这些新功能
谢谢你诺曼
就像你看到的那样
我们为SpriteKit和Xcode 7增加了很多优秀的功能
我想通过展示一个简单地例子向
你们展示它们是如何在你的开发流中集成工作的
这个例子展示了创建一个简单的层添加场景
创建一些互动的游戏等内容
好的看这里 我刚刚创建了一个游戏工程
我在这个工程中添加了一个层
我们创建了一些平台和一个角色
我想做的第一件事就是在其中创建环境
添加一些背景和前景元素
放在从前我会直接在场景中做这些事情
然后一个个复制我所需要的实例
如果我需要修改一些东西的话这很快就会变得非常麻烦
因为我需要对非常多不同的点进行修改
并且很难重复使用
现在我们用ReferenceNode
解决了这个问题
所以在这里我创建了我的环境中
所需要的所有的元素并将其放在单独的文件中
这样我就得到了一个有瀑布的背景
和一个有雾气效果的前景
引用这些内容文件所需要进行的操作
就是将其拖放到我的层中
现在 我们自动创建一个
包含所有元素的ReferenceNode你会注意到
前景的Z值被保留了下来
当我们将它添加到我的场景中的时候
接下来创建一些复制来填充起来这一层
你会注意到我复制了ReferenceNode
其本身
而不是我所引用的场景中的
单独的元素
这在我之后的工程中会显得很棒
例如 当我想要跟换背景纹理时
因为它并不是特别合适
我做的这个平台 
我不需要改变我现有的三个实例
我可以打开我单独的资源
只需要做一次修改
改动的地方就会自动送给所有的实例
在这个层中
接下来
我想在我的层中创建一个跳转场景
我会使用我们刚才介绍的
新的动作编辑器来做
放在从前 你只能在代码中创建动作
这非常不容易看到
所以我们想要开发一中编辑器能够很容易的创建复杂的动作
并给你实时的
你正在创建的图像信息
访问动作编辑器
你可以点击左下角的按钮
你会看到显示出来
你的场景中的所有节点以及时间轴
其中包含所有的动作
我们能够看到我们的角色已经有了一个动作
这是一个由纹理动作组成的动画
我们将它放在一个空闲的帧内
现在点击播放
我们可以看到我们的角色在我们的场景中
动了起来
接下来在我们的层中创建一个跳转场景
我们准备让角色穿过这一层
要做到这些
我们需要过滤出来我们的玩家互动编辑器和
我们的对象库中的动作
我们为你提供了一组动作构件
可以用来创建更加复杂的动作
这正是我接下来要做到的事情
我们首先添加一个移动的动作
到我们的跳转场景中
我需要做的所有事情就是拖放从对象库拖放到时间轴中
现在对于这个运动
我们可以看到在X方向上有850个单位组成
我们想要将这个动作做得更缓慢更自然
现在点击这个播放
我们可以看到我们的角色是这样跑的
这有点快所以我们需要修改持续的时间
将这个动作拖长大概2秒
我想要调整一下时间轴
所以现在运行一下
这时的运动就有了一个更合理的速率
现在我想让角色在穿越屏幕的时候跑起来
所以我要添加一个带有纹理动作的动画
要定义我们准备使用的动画
我可以打开媒体库
过滤下来我们的奔跑的框架
我可以选择之后将其简单地拖动到我们的运动中
现在我们运行一下
可以看到角色将会做这个动作
当然 如果我们只使用一次的话
我们可以添加一个循环
这样就能在其移动的整个时间段中持续下来
我可以点击角落里的这个循环按钮创建一个循环
我能够看到
循环的所有控制参数
我可以增加迭代的次数 
也可以减少 也可以自定义循环
在这个例子中我想要让它循环两次
接下来我将调整一下持续时间来适应我们的运动过程
现在我们就得到了我们的角色跑着穿越整个场景的动画
接下来 我们在层中添加两个沟
让这个角色跳过它们
在动作编辑器中我们可以定向清除我们动作中的时间点
在刚刚到达沟的旁边的时候我可以清除掉
然后添加一个其他的动作
我们可以正好对齐我们刚才擦除的地方
对于这个移动我们会在Y轴方向移动100个单位
我将其设置成缓慢输出
这样在到达我们跳跃的顶部的时候角色的动作会变慢
在到达沟的中间的时候我会再做一次擦除
调整一下持续时间 使角色能够在
达到最高点的时候刚好到达沟的中间
然后复制我们动作的第一部分然后翻转
得到一个完整的跳跃运动
跳跃的最后一步
我准备再创建一个动画
包含跳跃的构架
同样的方法打开媒体库 过滤下来我们的跳跃构架
添加到动作中
现在我们的角色就能够从第一个沟上面跳过去
当然 我们还有一个沟
我需要做的就是复制我刚刚添加的动作
然后替换但是接下来我们会碰到同样的问题
那就是在地图上的哪里进行修改
我将要对每一个复制的实例进行修改
很可能我会在不同的层中
重复使用这些动作
甚至可能在不同的工程中
我们用同样的方式解决了这个问题
就是允许你引用运动
我们在Xcode中引入一个新文件
这是一个SpriteKit动作文件夹
这个文件夹中放了一些动作文件
这些动作文件的名字
你可以在场景、工程或者代码中全局引用
接下来 选定动作文件  
创建一个这样的文件夹
并将其转换成引用的形式
我准备给它命名 将其命名为跳跃
我们可以选择一个动作文件夹放进去
在这个例子中我会新建一个新的文件夹
我给这个文件夹命名为角色动作
因为我打算将所有的跟角色有关的动作都放进这个文件夹
将这个文件添加到我们的工程
现在你会看到我们创建的这些动作
例如跳跃已经在跳跃文件夹的下面了
并且在我们的场景中
我们可以引用这些动作
现在你放到这个文件夹中的动作
已经完全从所有的场景或者工程中独立了出来
但是在一些场景中某些背景下
你经常会想要修改他们
我们允许你设置一个预览窗口
你可以分配你文件夹中的任何动作在你的场景中的任何节点
例如我可以在这个场景中的任何节点预览我 的跳跃动作
或者打开一个自己的场景
在角色的不同角度
例如 我可以预览角色左边或者
右边跳跃动作是怎样的
所以现在 在这里 我们继续 
回到擦除第二个沟的地方 在对象库中
我们可以用可以引用的动作
自动填充进去
因为我刚才创建的跳跃动作
已经自动放在了对象库中我就能够将它拖放进去
现在我们就完成了我们的跳转场景让我们欣赏一下
看起来很棒
现在我想向你展示一下怎样在代码中使用
而不仅仅是一个跳转场景
我想要做的就是在每一个角色可能存在的地图中
都创建一个动作 然后通过代码引用它
我要创建一个引用
这个可引用的动作叫跑
其中包含我们动画
我也同样对对空文件这么处理
现在开始 删除这些
因为现在我们要把这些做成交互式的
现在你可以看到
我们的动作文件夹中
包含了三个地图
现在通过代码使用这些动作
你所要做的就是使用我们刚才介绍的新选择器
动作名称选择器 
给它们提供我们刚刚创建的动作的名称
空 跑 和跳跃
现在当我运行我们的游戏时
你能够看到我刚才创建的动作现在正在游戏中使用着
交互式的
这一点最强大的地方在于
当你想要修改你的动作时
我可以直接打开动作文件夹
例如 让角色在跳跃的时候翻个筋斗
我可以打开这里然后添加一个旋转的动作到跳跃上
给它赋值负360 缓进缓出
现在我们不编译就运行我们的游戏
我们可以看到发生了改变
我刚做的修改已经提交给了角色
现在这一层看起来已经很棒了
所以最后要做的事情就是创建一个漂亮的电影动画开场
将角色引入到这一层
我可以通过创建一个SKCameraNode到场景中的方式实现
让我们在镜头节点中定义一个Viewport
我们可以开始使用我刚添加的镜头
来分配我们的场景
作为电影动画开场我想用从这个角落开始
使用镜头放大
我准备放大这里的雾气
最棒的是因为这只是一个SKNode 
我可以向镜头中添加动作
过滤下来适应我们的镜头
之后添加一个有两个动作的移动
我准备要做的电影动画开场
就是讲镜头平移到这一层的中心
同时缩放
第二步我将要把X轴的值
设置为507作为中 心
同时将Y轴的值设置为384个单位并作为中心
并将这些设置为
缓进缓出
我打算在我们打开我们的场景半秒钟后
开始移动我们的动画
并耗时3秒将其平移过去
同样我添加了第二个动作并给其半秒钟从我们的动画中抵消
在动画结束后同时结束
现在 在短短时间内
我们创建了一个电影动画式的开场
我们也已经结束了这一层
接下来让我们看一下它现在什么样子
这就是你现在可以使用SpriteKit和Xcode 7
做的事情了
与此同时 我想将话题重新交给提姆
让它来为你们总结一下
谢谢泰勒
这真的是一个非常棒的工作
我相信大家有目共睹
这对于SpriteKit工程师来讲
将会是超级棒的一年
我们新增了AudioNode,也新增了CameraNode
我们也有了可以引用的动作和节点
也有了一个全新的
基于运动编辑器的集成在Xcode中的时间轴
我们整合了纹理地图集和资源目录
并给你提供了新的功能
例如基于命令的资源库和更加简洁的App
同时也使SpriteKit适配所有的支持Metal的设备
让你能够更容易地访问
全新的GamePlayKit构架
如果你需要更多的信息
请访问我们的开发者网站
或者拨打咨询电话
联系我们的图形专家AllanSchaffer 
还有几个与之相关的会议
如果你想对GamePlayKit
或者SceneKit了解更多的话
我们也有一些实验室
第一个就是SpriteKit实验室
现在马上就会启动
大家放松 跟我们一起下楼
我们将很乐意回答你们的所有问题
非常感谢请享受您的会议