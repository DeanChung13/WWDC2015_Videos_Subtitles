00:00:19.786 --> 00:00:22.122 
核心圖像的新方面

00:00:25.759 --> 00:00:27.561 
大家早上好
我的名字是大衛·海沃德

00:00:27.628 --> 00:00:29.363 
今天我很榮幸能給大家講講

00:00:29.429 --> 00:00:32.432 
iOS 9和Mac OS X El
Capitan “核心圖像” 上

00:00:32.566 --> 00:00:34.501 
有什麼新料

00:00:35.202 --> 00:00:38.172 
首先說一下我們今天
要講哪幾件事

00:00:38.272 --> 00:00:40.574 
首先 我會給那些剛剛
接觸主題的人

00:00:40.674 --> 00:00:42.743 
簡單介紹下 “核心圖像”

00:00:42.876 --> 00:00:44.278 
我建議你們回去後

00:00:44.344 --> 00:00:46.246 
看看我們去年以來的
演示

00:00:46.313 --> 00:00:48.849 
尤其是其中那個關於如何
在 “核心圖像” 中編寫內核的

00:00:48.916 --> 00:00:49.950 
討論 非常棒

00:00:50.684 --> 00:00:52.853 
接下來我們會講一講
今年在 “核心圖像” 上

00:00:52.920 --> 00:00:53.854 
有什麼新料

00:00:53.921 --> 00:00:55.455 
我們在這裏要講的東西
很多

00:00:55.889 --> 00:00:58.659 
我們今天會議剩下的三分之一
時間會用來談談如何使用

00:00:58.725 --> 00:01:00.727 
“核心圖像”
如何把它與我們的平臺上的

00:01:00.794 --> 00:01:02.896 
其它圖形框架
橋接起來

00:01:04.131 --> 00:01:05.132 
首先

00:01:05.933 --> 00:01:07.835 
來簡單介紹下
“核心圖像”

00:01:09.469 --> 00:01:10.971 
在概念上

00:01:11.038 --> 00:01:13.907 
“核心圖像” 的
理念是指你可以在圖像上使用濾鏡

00:01:14.441 --> 00:01:17.010 
舉個簡單的例子
你有一張輸入圖像

00:01:17.077 --> 00:01:19.980 
然後你通過一個濾鏡增加了
一種色彩效果 如棕黑色調

00:01:20.714 --> 00:01:22.216 
但是如果你不喜歡這個

00:01:22.282 --> 00:01:24.651 
棕黑色調 那麼你就可以再
改變一次色彩效果 把色調

00:01:24.751 --> 00:01:27.254 
改成
偏藍色調

00:01:27.821 --> 00:01:30.591 
你也可以使用 “核心圖像”
來增加類似幾何扭曲這樣的

00:01:30.657 --> 00:01:32.159 
事件
效果

00:01:32.426 --> 00:01:36.363 
在這個例子中 我們使用的
就是一種簡單的轉換

00:01:36.430 --> 00:01:37.564 
放大了圖像的某一部分

00:01:38.465 --> 00:01:40.701 
你可以把這些想象成
各個濾鏡上都有一張

00:01:40.801 --> 00:01:41.802 
中間圖像

00:01:42.402 --> 00:01:45.339 
但是
我們實現濾鏡的方法

00:01:45.405 --> 00:01:46.974 
它們實際上是非常簡便的
對象

00:01:47.040 --> 00:01:48.876 
生成時耗時
極少

00:01:49.343 --> 00:01:51.311 
在它們之間並無
中間緩衝區

00:01:51.378 --> 00:01:52.713 
存在的必要

00:01:52.779 --> 00:01:54.882 
還有一個概念也很重要
和每個濾鏡聯繫在一起的

00:01:54.948 --> 00:01:57.217 
是一個或者多個
內核

00:01:57.651 --> 00:02:01.255 
CI內核是小的子例程
這些子例程施加的效果

00:02:01.321 --> 00:02:03.323 
就是內核想要實現的
效果

00:02:04.591 --> 00:02:06.527 
“核心圖像” 的另一項特性是

00:02:06.593 --> 00:02:09.496 
我們把這些內核

00:02:09.562 --> 00:02:12.132 
連接到了一個
程序

00:02:12.466 --> 00:02:15.502 
儘可能減少中間緩衝區的
使用

00:02:15.569 --> 00:02:16.703 
以此來提高性能

00:02:19.773 --> 00:02:22.643 
“核心圖像” 還有一項關鍵特性
我們稱之爲

00:02:22.709 --> 00:02:23.577 
“興趣域支持”

00:02:24.144 --> 00:02:26.747 
這個理念指的是如果你僅僅
對某個圖像的某一部分進行

00:02:27.314 --> 00:02:29.650 
渲染 這可能是因爲你在某張
較大的圖象上進行了放大

00:02:29.716 --> 00:02:31.451 
或者是因爲這些渲染是在
圖塊上進行的

00:02:32.553 --> 00:02:35.589 
我們就可以問一下每個濾鏡
正在渲染的圖塊需要多大的

00:02:35.656 --> 00:02:38.825 
圖像輸入 這樣我們就可以
向源圖像計算回

00:02:38.892 --> 00:02:41.328 
要生成想要的輸出
需要用到的圖像的

00:02:41.562 --> 00:02:45.132 
精確
區域

00:02:45.299 --> 00:02:48.802 
“核心圖像” 還有一項很棒的
特性 允許我們獲得良好的

00:02:48.869 --> 00:02:50.270 
性能
尤其是當我們處理

00:02:50.337 --> 00:02:51.672 
大圖像時

00:02:53.140 --> 00:02:55.976 
當你使用 “核心圖像” 時
你需要注意其中的

00:02:56.043 --> 00:02:57.311 
四個
主要類

00:02:57.711 --> 00:02:59.012 
第一個是CI內核

00:02:59.079 --> 00:03:00.647 
我之前已經提到了

00:03:01.048 --> 00:03:03.283 
它代表的是寫在 “核心圖像”
內核語言的

00:03:03.350 --> 00:03:05.485 
程序或者例程

00:03:05.986 --> 00:03:09.456 
第二個關鍵的類是濾鏡
即CI濾鏡

00:03:09.823 --> 00:03:13.293 
這是一個可變對象
可以有多個輸入

00:03:13.360 --> 00:03:16.530 
這些輸入參數可以是數字、
向量

00:03:16.597 --> 00:03:18.031 
或者其他圖像

00:03:19.399 --> 00:03:23.036 
根據輸入參數的當前狀態
濾鏡會使用一個或者多個

00:03:23.103 --> 00:03:26.073 
內核
來生成

00:03:26.139 --> 00:03:27.241 
一幅輸出圖像

00:03:27.908 --> 00:03:30.344 
一個CI圖像就是一個
不可變對象

00:03:30.744 --> 00:03:33.614 
表示根據已經使用的
上一個內核

00:03:33.680 --> 00:03:35.949 
生成圖像的
“食譜”

00:03:37.451 --> 00:03:40.120 
最後是
CIContext對象

00:03:40.354 --> 00:03:41.755 
這是一個非常
重量級的對象

00:03:41.822 --> 00:03:44.424 
“核心圖像” 就是通過這個對象
來進行渲染的

00:03:44.925 --> 00:03:47.895 
建議你不要太過頻繁地在你的
應用程序中創建

00:03:47.961 --> 00:03:50.464 
這個CIContext對象 如果
你處理的是快速動畫

00:03:50.531 --> 00:03:51.765 
那麼創建一次就夠了

00:03:51.832 --> 00:03:53.567 
關於CIContext還有一點很棒

00:03:53.634 --> 00:03:57.738 
它們可以實現到我們的系統中
各種不同的後端渲染器上

00:04:01.141 --> 00:04:04.444 
現在我想講的下一件事
就是我們後面的這個介紹講的是

00:04:04.511 --> 00:04:06.446 
今年 “核心圖像” 上
有什麼新料

00:04:07.714 --> 00:04:09.550 
我們今天要講這麼幾件
事情

00:04:10.150 --> 00:04:13.787 
我們會講一下Metal
講一下新的濾鏡

00:04:14.288 --> 00:04:18.325 
新的檢測器 顏色管理支持
以及內核類和語言的

00:04:18.392 --> 00:04:20.827 
某些
改進

00:04:21.827 --> 00:04:24.565 
關於 “核心圖像” 我要講的
最重要的事情

00:04:24.932 --> 00:04:28.035 
就是我們現在把它統一實現到了
我們的各個平臺上

00:04:28.101 --> 00:04:32.072 
因此只要我們不專門提起
那麼大多數情況下

00:04:32.139 --> 00:04:34.775 
“核心圖像” 的行爲在iOS
和OS X上是完全一致的

00:04:35.042 --> 00:04:37.244 
是完全
等價的

00:04:37.311 --> 00:04:40.981 
這是一個很棒的特性
開發者就可以依賴這個

00:04:41.048 --> 00:04:42.182 
這個一致的行爲

00:04:43.050 --> 00:04:46.053 
這些可能是一些小事
比如

00:04:46.119 --> 00:04:47.888 
當你包含 “核心圖像”
頭部時

00:04:48.155 --> 00:04:50.624 
無論你是在哪個平臺
你就可以包含 “核心圖像”

00:04:50.824 --> 00:04:52.259 
包含
“核心圖像” H

00:04:52.326 --> 00:04:53.260 
這樣如果你編寫的是

00:04:53.327 --> 00:04:55.562 
跨平臺的代碼
那就容易了很多

00:04:55.963 --> 00:04:58.632 
我們現在在兩個平臺之間

00:04:58.699 --> 00:05:01.668 
會進行API奇偶校驗

00:05:03.971 --> 00:05:04.805 
因此

00:05:04.872 --> 00:05:07.241 
今天我們想說的一件
主要的事情就是

00:05:07.307 --> 00:05:09.676 
“核心圖像”
對Metal的支持

00:05:10.410 --> 00:05:13.514 
我們稍後會在演示中
展開講更多的細節

00:05:13.847 --> 00:05:15.482 
不過現在我就想先向你們
強調這一點

00:05:15.883 --> 00:05:17.584 
關鍵的一點在於

00:05:17.951 --> 00:05:19.453 
現在Metal Textures

00:05:19.720 --> 00:05:21.255 
既可以當做
“核心圖像” 的輸入

00:05:21.822 --> 00:05:24.124 
又可以當做
“核心圖像” 的輸出

00:05:25.158 --> 00:05:27.628 
從內部來說
“核心圖像” 環境可以把

00:05:27.895 --> 00:05:30.430 
Metal當作它們的
內部渲染器

00:05:31.231 --> 00:05:32.933 
這就意味着
如果你在CI的內核語言中

00:05:32.999 --> 00:05:35.969 
寫好了一個內核
那麼它就會自動即時翻譯成

00:05:36.403 --> 00:05:38.338 
Metal語言

00:05:40.240 --> 00:05:42.643 
還有一件事要記住
我們的內置濾鏡

00:05:42.709 --> 00:05:45.245 
尤其是 “高斯” 和 “卷積”
濾鏡

00:05:45.646 --> 00:05:47.714 
現在是構建在
Metal性能材質的頂部

00:05:47.781 --> 00:05:51.718 
爲的就是在支持的多個平臺上
獲得儘可能好的性能

00:05:55.189 --> 00:05:56.590 
關於濾鏡還有一些要說

00:05:57.391 --> 00:05:58.725 
就像我之前提到過的

00:05:58.792 --> 00:06:00.961 
我們現在有一個統一的
“核心圖像” 執行

00:06:01.028 --> 00:06:04.364 
這就意味着我們現在在各個
平臺上內置了二百種濾鏡

00:06:04.898 --> 00:06:06.333 
也就是說

00:06:07.267 --> 00:06:08.902 
我們向iOS
“核心圖像” 執行中

00:06:08.969 --> 00:06:10.737 
添加了
海量的濾鏡

00:06:10.871 --> 00:06:12.739 
這次發版時添加了
超過四十種濾鏡

00:06:13.140 --> 00:06:14.775 
它們分別屬於不同的
類別

00:06:14.842 --> 00:06:18.345 
有些濾鏡很有趣 比如
喜劇效果、CMYK半色調、

00:06:18.412 --> 00:06:20.280 
德羅斯特以及卷頁效果

00:06:20.347 --> 00:06:22.783 
還有一些卷積濾鏡
也很有用

00:06:22.850 --> 00:06:24.184 
比如中值濾鏡、

00:06:24.251 --> 00:06:27.321 
邊緣檢測
以及噪聲抑制

00:06:27.921 --> 00:06:31.792 
我們還有一些對圖像分析來說
非常有用的簡化濾鏡

00:06:31.859 --> 00:06:34.528 
比如對一幅圖像進行
“區域最大化”

00:06:34.595 --> 00:06:36.096 
或者 “平均分佈列”

00:06:37.831 --> 00:06:40.000 
爲了讓你們體驗一下它

00:06:40.367 --> 00:06:42.503 
我想向你們展示我們的
一個示例應用程序的最新

00:06:42.569 --> 00:06:44.905 
最新版本 名字叫
“核心圖像奇幻屋”

00:06:45.606 --> 00:06:48.342 
我們儘量每年都更新這個
應用程序

00:06:49.276 --> 00:06:52.346 
我們現在已經有
二百個濾鏡

00:06:52.913 --> 00:06:55.883 
當你在這個應用程序中打開
濾鏡彈窗時

00:06:55.949 --> 00:06:58.151 
你可以看到我們現在把它們
分成了不同的種類

00:06:58.552 --> 00:07:00.654 
你還可以看到我們用紅色
高亮顯示了我們新加的

00:07:00.721 --> 00:07:03.223 
濾鏡
這裏有一個API

00:07:03.290 --> 00:07:06.493 
可以幫助你確定某個濾鏡
是在哪次發版時加進去的

00:07:07.828 --> 00:07:10.130 
這個 當然了
展示了 “CMYK半色調” 特效在

00:07:11.164 --> 00:07:12.900 
一臺iPad上視網膜分辨率
情況下的

00:07:13.667 --> 00:07:14.701 
良好性能

00:07:17.938 --> 00:07:20.107 
這是我們應大家要求

00:07:20.541 --> 00:07:22.309 
<br/>
添加到各個平臺的

00:07:22.376 --> 00:07:24.244 
“核心圖像” 上的
兩個新的濾鏡

00:07:24.578 --> 00:07:26.413 
這些濾鏡可以用來

00:07:27.014 --> 00:07:28.081 
生成
條形碼

00:07:28.482 --> 00:07:31.151 
因此在這個實例中
輸入一個濾鏡的就不是

00:07:31.218 --> 00:07:33.253 
一個數字或者另一幅圖像
而是一個文本串

00:07:34.021 --> 00:07:38.258 
我們添加了這兩個濾鏡
以便生成PDF417條形碼

00:07:38.325 --> 00:07:40.160 
以及code 128條形碼

00:07:43.597 --> 00:07:46.533 
“核心圖像” 還有一項特性
我們稱之爲我們的

00:07:46.600 --> 00:07:47.601 
CI檢測器類

00:07:47.868 --> 00:07:49.837 
這些是我們過去發佈的
類

00:07:49.903 --> 00:07:52.940 
它們可以用來做像
檢測圖像中的人臉、

00:07:53.407 --> 00:07:55.342 
檢測圖像中的QR codes碼、

00:07:55.809 --> 00:07:57.377 
檢測圖像中的矩形
等事情

00:07:57.644 --> 00:07:58.779 
今年我們又新增了一個類

00:07:58.846 --> 00:08:01.582 
它可以用來檢測圖像中的
文本區域

00:08:02.049 --> 00:08:04.952 
這個濾鏡的理念是
定位可能包含直立文本的

00:08:05.018 --> 00:08:06.887 
區域

00:08:07.621 --> 00:08:10.657 
我來在一臺iPad上運行下
簡單給你們做個演示

00:08:10.991 --> 00:08:13.760 
我們已經把它連接到了
“核心圖像奇幻屋”

00:08:14.194 --> 00:08:17.731 
我的書架上有個舊盒子
如果我們打開文本檢測器

00:08:17.798 --> 00:08:20.767 
它就定位到了直立文本
定位到了

00:08:21.235 --> 00:08:24.238 
文本的滾動以及
單獨的字符

00:08:24.771 --> 00:08:27.774 
當我們放大
並且旋轉攝像頭

00:08:28.141 --> 00:08:30.711 
直立文本也檢測到了
成一個角度的

00:08:30.777 --> 00:08:33.380 
某些文本

00:08:34.414 --> 00:08:36.950 
這就是我們的新文本檢測器
開發者會用這個檢測器來實現

00:08:37.017 --> 00:08:38.784 
什麼好玩的功能
我對此十分期待

00:08:42.523 --> 00:08:44.858 
隨着我們現在在iOS上的
“核心圖像” 統一實現

00:08:44.925 --> 00:08:46.560 
我們還有了 “自動顏色管理”

00:08:46.627 --> 00:08:48.362 
這一
很棒的

00:08:48.428 --> 00:08:49.863 
功能

00:08:50.130 --> 00:08:53.200 
自從 “核心圖像” 出現後
OS X上就可以使用

00:08:53.267 --> 00:08:56.470 
這項功能了 但是現在
我們也把它弄到了iOS上

00:08:57.104 --> 00:09:01.275 
這就意味着
現在 “核心圖像” 完全支持

00:09:02.409 --> 00:09:04.945 
基於ICC的CGColorSpac
eRefs了

00:09:05.846 --> 00:09:08.515 
這些可以被用到輸入文本、
輸出文本上

00:09:08.582 --> 00:09:10.651 
甚至還可以被當做
“核心圖像” 的一個工作區

00:09:11.852 --> 00:09:14.488 
這是因爲完成了在iOS上
支持ColorSync這一

00:09:14.555 --> 00:09:19.459 
很棒的工作
才實現的

00:09:21.061 --> 00:09:22.095 
對用戶來說 這就意味着

00:09:22.162 --> 00:09:25.332 
你可以自動得到用色彩空間
標記的TIFF或者JPG

00:09:25.399 --> 00:09:27.768 
正確
渲染

00:09:28.435 --> 00:09:29.770 
很多圖像是用sRGB標記的

00:09:29.837 --> 00:09:34.074 
在之前的iOS版本上它們已經
可以正確渲染了

00:09:34.141 --> 00:09:38.979 
不過現在如何你的圖像是用
一個色彩空間而不是用sRGB

00:09:39.146 --> 00:09:41.114 
來標記的 那麼你也可以
得到正確的行爲了

00:09:41.515 --> 00:09:43.684 
這裏有一個例子
是用Pro Photo色彩空間

00:09:43.750 --> 00:09:45.018 
標記的一幅圖像

00:09:45.085 --> 00:09:48.522 
背景中的紅色臺子
不飽色

00:09:48.589 --> 00:09:50.190 
膚色也很難看

00:09:50.691 --> 00:09:56.296 
當你在這個上面正確看到
嵌入ICC輪廓時

00:09:56.463 --> 00:09:57.698 
圖像就正確進行了渲染

00:09:58.866 --> 00:10:00.934 
這是你在 “核心圖像” 上
自動得到的

00:10:04.071 --> 00:10:07.708 
我們還對CI內核類做了一些
新的支持

00:10:07.774 --> 00:10:09.343 
現在在OS X上已經可用了

00:10:09.409 --> 00:10:11.144 
當然它在iOS上早就可以
用了

00:10:11.211 --> 00:10:13.447 
這是我們的統一執行的
另外一項福利

00:10:14.615 --> 00:10:17.784 
舉例來說 我們有兩個類
分別叫做CI顏色內核

00:10:17.851 --> 00:10:19.019 
以及CI扭曲內核

00:10:19.319 --> 00:10:22.022 
這些類背後的理念
是讓你能夠更容易地

00:10:22.089 --> 00:10:23.957 
最常見的
基礎濾鏡

00:10:24.791 --> 00:10:27.928 
之前在OS X上
如果你想要寫一個簡單的融合濾鏡

00:10:27.995 --> 00:10:29.530 
用給定的遮罩把這三個圖像

00:10:29.596 --> 00:10:32.666 
融合到一起 那麼你就需要

00:10:32.799 --> 00:10:34.468 
寫幾行代碼
對採樣器

00:10:34.835 --> 00:10:36.036 
正確進行取樣

00:10:36.670 --> 00:10:38.338 
然後你需要寫好遮罩

00:10:38.572 --> 00:10:39.806 
把這三幅圖形組合到一起

00:10:40.741 --> 00:10:42.609 
而如果你用CI顏色
內核類

00:10:43.010 --> 00:10:44.244 
那麼代碼就簡單的多了

00:10:44.778 --> 00:10:48.315 
現在內核的輸入就是一個
採樣器 下劃線

00:10:48.382 --> 00:10:51.251 
下劃線採樣參數
那麼內核的代碼就只不過是

00:10:51.318 --> 00:10:54.254 
把三個結果混合到一起的
數字遊戲

00:10:54.821 --> 00:10:57.391 
對開發者來說
這是件大好事 事情更簡單了

00:10:57.457 --> 00:11:01.328 
“核心圖像” 簡化、連接
項目的工作

00:11:01.895 --> 00:11:04.031 
就更加容易了

00:11:07.134 --> 00:11:09.036 
我們還對OS X上可用的
CI內核語言

00:11:09.102 --> 00:11:12.005 
做了大量的
優化

00:11:12.606 --> 00:11:16.009 
我們的統一執行
當我們把CI內核語言

00:11:16.076 --> 00:11:18.979 
編譯進
目的環境語言時

00:11:19.913 --> 00:11:22.349 
我們會通過Apple的
LLVM技術來實現

00:11:22.416 --> 00:11:26.787 
這樣 我們的語言中
就有了一項新的特性

00:11:27.387 --> 00:11:30.224 
比如If、For以及While
這些之前都是不可用的

00:11:31.458 --> 00:11:33.694 
現有的apps中的CI內核
應該不會受到影響

00:11:34.094 --> 00:11:36.563 
不過有了新的編譯器
我們的報警更嚴謹了

00:11:36.630 --> 00:11:38.365 
所以如果你的app鏈接到了

00:11:38.432 --> 00:11:40.133 
El Capitan
或者稍後會鏈接它

00:11:40.400 --> 00:11:42.302 
請密切留意
編譯器報警

00:11:44.571 --> 00:11:47.174 
舉例來說
這是一個內核的簡單示例

00:11:47.241 --> 00:11:51.411 
之前在OS X使用內核語言
是不可能的

00:11:51.778 --> 00:11:54.481 
因爲這個特定的濾鏡
有一個輸入參數

00:11:54.548 --> 00:11:55.916 
這個參數是一個計數

00:11:56.550 --> 00:11:58.652 
我們想在這個內核中有一個
For循環

00:11:58.952 --> 00:12:00.687 
會基於那個計數變量
進行循環

00:12:01.455 --> 00:12:03.490 
在這個特定的例子中
我們想要對n點進行

00:12:03.557 --> 00:12:06.026 
矢量
動態模糊

00:12:06.627 --> 00:12:08.529 
現在寫這個內核
就很容易了

00:12:09.429 --> 00:12:12.266 
你可以更加天馬行空
你可以有一個

00:12:12.332 --> 00:12:13.767 
提前退出的For循環

00:12:14.601 --> 00:12:17.271 
在這個例子中
我們會對那副圖像進行採樣

00:12:17.337 --> 00:12:21.508 
直到我們得到了圖像上的
一個不透明區域 然後我們

00:12:21.575 --> 00:12:24.678 
For循環
僅僅返回圖像中的

00:12:24.745 --> 00:12:29.750 
顏色的
平均色

00:12:29.917 --> 00:12:32.252 
因此你要記住

00:12:32.319 --> 00:12:35.055 
我們的內核語言
就是我們這個語言的整體目標

00:12:35.489 --> 00:12:38.492 
我們想實現的
就是讓你僅僅寫一次內核

00:12:38.559 --> 00:12:42.696 
然後不管你的內核運行在
什麼樣的設備上

00:12:42.763 --> 00:12:44.031 
你的內核
就都可以運行

00:12:44.531 --> 00:12:46.800 
這樣它就可以獨立運行
不管運行在什麼樣的系統中

00:12:46.867 --> 00:12:50.838 
不管是iOS還是OS X
不管你的輸入圖像尺寸如何

00:12:51.171 --> 00:12:54.842 
內核語言也同樣支持
目的核心

00:12:54.908 --> 00:12:58.078 
以及採樣器轉變因此我們也支持圖像自
動鑲嵌圖案

00:12:59.513 --> 00:13:02.115 
此外
CI內核語義和我們的

00:13:02.182 --> 00:13:03.650 
後端渲染器
是獨立工作的

00:13:03.851 --> 00:13:05.285 
因爲無論我們用到是
Metal

00:13:05.352 --> 00:13:07.120 
還是OpenCL，還是OpenGL

00:13:07.187 --> 00:13:10.424 
還是OpenGL ES
你在CI內核語言中

00:13:10.591 --> 00:13:11.992 
寫一次你的算法就可以了

00:13:16.496 --> 00:13:19.366 
這就是今年“核心圖像”上
有什麼新料的重點內容

00:13:20.067 --> 00:13:22.035 
我們接下來的主題
是要講一講如何

00:13:22.102 --> 00:13:23.871 
把 “核心圖像”
和其他框架橋接起來

00:13:24.071 --> 00:13:25.939 
具體來說 指的就是

00:13:26.006 --> 00:13:28.742 
我們的平臺上可用的
某些很棒的圖形資源

00:13:30.410 --> 00:13:33.614 
我們的平臺上有很棒的

00:13:34.281 --> 00:13:35.182 
成像框架

00:13:35.249 --> 00:13:36.683 
比如 “核心動畫” 、

00:13:37.150 --> 00:13:39.653 
SceneKit、
SpriteKit、Metal、

00:13:39.720 --> 00:13:41.088 
AV Foundation、

00:13:41.154 --> 00:13:43.824 
IOSurfaces
以及多個視圖類

00:13:44.291 --> 00:13:47.928 
我們今年花了大量的時間
來讓它們能夠

00:13:48.695 --> 00:13:49.863 
和 “核心圖像” 兼容

00:13:49.997 --> 00:13:51.798 
開始討論前

00:13:51.932 --> 00:13:55.068 
我想介紹下託尼·朱
他會展開講一下

00:13:55.135 --> 00:13:56.904 
“核心圖像”
以及Metal

00:14:05.112 --> 00:14:05.979 
謝謝 大衛

00:14:06.113 --> 00:14:07.781 
早上好
我的名字是託尼

00:14:08.182 --> 00:14:10.017 
首先我要告訴你們關於
“核心圖像”

00:14:10.384 --> 00:14:12.119 
以及Metal
更多的信息

00:14:14.188 --> 00:14:17.090 
就像大衛之前提到的
今年我們在 “核心圖像” 中

00:14:17.157 --> 00:14:18.892 
添加了Metal渲染
支持

00:14:19.393 --> 00:14:21.828 
我們這樣做的一個原因
是爲了增加我們的

00:14:21.895 --> 00:14:24.264 
圖像類型支持
擴展套件

00:14:24.731 --> 00:14:26.834 
例如IOSurface以及CGIm
ag

00:14:27.367 --> 00:14:29.169 
無論你的CIContext類型是什
麼

00:14:29.236 --> 00:14:31.271 
你都可以把它們用作

00:14:31.338 --> 00:14:33.240 
一個CI濾鏡的
輸入或者輸出

00:14:34.107 --> 00:14:36.743 
不過如果你有一個基於OpenGL的
CIContext

00:14:37.044 --> 00:14:39.646 
你也可以渲染進、
渲染出OpenGL紋理

00:14:40.981 --> 00:14:43.717 
今年 如果現在你有一個
基於Metal的CIContext

00:14:43.884 --> 00:14:45.919 
那麼你也可以渲染進、渲染出
Metal紋理

00:14:46.653 --> 00:14:48.222 
之前沒有這項支持時

00:14:48.422 --> 00:14:51.692 
你就必須把一個Metal紋理
轉換成某種現有的圖像類型

00:14:52.159 --> 00:14:54.161 
這就有可能在CPU和GPU之間

00:14:54.228 --> 00:14:56.897 
造成 “昂貴的”
數據複製

00:14:57.564 --> 00:14:59.433 
有了這項支持
我們就可以高效

00:14:59.499 --> 00:15:01.268 
渲染進、渲染出
這些資源

00:15:03.871 --> 00:15:06.173 
我們再來看看 “核心圖像” 內
用於Metal支持的

00:15:06.240 --> 00:15:08.175 
一些新的APIs

00:15:09.009 --> 00:15:12.546 
首先是一個允許你用一個
輸入Metal紋理對一個

00:15:12.913 --> 00:15:14.348 
CI圖像進行初始化的API

00:15:14.982 --> 00:15:18.051 
以及一本你可以在其中

00:15:18.118 --> 00:15:20.554 
指定
諸如紋理標記顏色空間

00:15:21.121 --> 00:15:22.589 
等事情的
可選字典

00:15:23.223 --> 00:15:25.025 
這是一個使用高層框架的
優點的

00:15:25.092 --> 00:15:27.427 
一個示例
例如 “核心圖像”

00:15:27.828 --> 00:15:29.162 
優點是它會自動幫你處理
類似

00:15:29.229 --> 00:15:31.298 
顏色管理等等
細節問題

00:15:34.268 --> 00:15:35.636 
要使用這些基於Metal的

00:15:35.702 --> 00:15:37.504 
資源進行渲染
你需要通過給它你的

00:15:37.704 --> 00:15:40.007 
應用程序正在用的Metal設備

00:15:40.073 --> 00:15:41.842 
<br/>
來創建一個基於Metal的

00:15:42.176 --> 00:15:45.012 
CIContext
新的CIContext

00:15:45.979 --> 00:15:49.216 
再說一遍 你可以爲
中間緩衝器指定

00:15:49.283 --> 00:15:52.819 
類似工作顏色空間或者
工作地墊的

00:15:52.886 --> 00:15:54.488 
選項字典

00:15:54.555 --> 00:15:56.823 
你甚至還可以說明

00:15:56.890 --> 00:16:00.027 
你想要使用某個
次優GPU

00:16:03.530 --> 00:16:04.364 
無論是哪種情況

00:16:04.431 --> 00:16:06.834 
有了這個新的基於Metal的CIC
ontext

00:16:06.900 --> 00:16:09.670 
我們就有了新的渲染API
允許你把任何

00:16:09.736 --> 00:16:12.973 
CI圖像渲染到一個
輸出Metal紋理

00:16:14.007 --> 00:16:15.709 
這個API有個很棒的特性
我想要

00:16:15.776 --> 00:16:17.744 
專門提出來
就是可以指定

00:16:17.811 --> 00:16:19.580 
任選
命令緩衝區

00:16:21.114 --> 00:16:23.750 
如果你想又快又好地做事
你可以指定爲 “無”

00:16:24.418 --> 00:16:26.720 
此時 “核心圖像” 就會在內部
創建一個

00:16:27.287 --> 00:16:29.056 
然後把所有必要的命令
編碼到那裏

00:16:29.590 --> 00:16:31.091 
然後在返回之前
把它提交上去

00:16:31.658 --> 00:16:34.661 
這樣就可以高效調度
GPU上的渲染調用

00:16:36.496 --> 00:16:39.199 
不過你也可以給那個調用
提高一個命令緩衝區

00:16:39.566 --> 00:16:42.603 
此時 “核心圖像” 只會
向它編碼命令

00:16:42.903 --> 00:16:44.872 
然後不經過提交
就把它返回回來

00:16:45.372 --> 00:16:48.342 
這樣的話
你就可以完全控制你對

00:16:48.408 --> 00:16:53.413 
命令緩衝區的調度
以便在GPU上進行渲染

00:16:53.480 --> 00:16:56.416 
你也就有了在命令緩衝區
的任何地方插入CI濾鏡

00:16:56.483 --> 00:16:57.451 
靈活性

00:16:59.219 --> 00:17:00.821 
我來詳細
解釋下這點

00:17:01.755 --> 00:17:03.323 
對於那些第一次使用Metal的

00:17:03.390 --> 00:17:06.093 
人來說 使用Metal進行渲染
基本上就是向一個命令緩衝區

00:17:06.159 --> 00:17:08.060 
編碼一系列的
渲染命令

00:17:08.561 --> 00:17:10.664 
在這個例子中
我們有兩組命令

00:17:11.531 --> 00:17:14.300 
用我們剛纔看到的那個新的
API

00:17:14.935 --> 00:17:16.103 
你現在就可以向

00:17:16.170 --> 00:17:17.671 
這個命令緩衝區的任何地方

00:17:17.738 --> 00:17:19.673 
插入那個CI濾鏡

00:17:19.740 --> 00:17:20.741 
比如在緩衝區的開頭、

00:17:21.675 --> 00:17:22.509 
結尾

00:17:23.377 --> 00:17:26.146 
甚至可以是在那兩個渲染命令的
正中間

00:17:26.847 --> 00:17:29.082 
你想象一下這種情況
你需要對某些紋理進行

00:17:29.149 --> 00:17:32.152 
某些繪製、引發
或者渲染

00:17:32.553 --> 00:17:35.656 
然後把紋理送入一系列的
CI濾鏡

00:17:36.690 --> 00:17:38.125 
並由此生成一些
輸入紋理

00:17:38.192 --> 00:17:39.493 
在上面進行更多的渲染

00:17:42.396 --> 00:17:46.099 
然後 “核心圖像” 會從內部
爲你的圖像圖表中可能有的

00:17:46.266 --> 00:17:48.468 
每個濾鏡編碼
全部命令

00:17:50.637 --> 00:17:52.306 
實際上
就像大衛之前提到過的

00:17:52.806 --> 00:17:55.042 
我們的某些內置濾鏡也會
使用Metal性能材質

00:17:55.108 --> 00:17:56.510 
來利用這些專門爲

00:17:56.577 --> 00:17:59.446 
支持Metal的設備進行了調整的
高度優化的

00:17:59.513 --> 00:18:00.781 
材質

00:18:04.218 --> 00:18:06.286 
最後我想提一下
這種調用協定

00:18:06.353 --> 00:18:09.056 
完美地賦予了它自身
使用CI、直接向一個

00:18:09.122 --> 00:18:11.992 
MetalKit視圖進行渲染的
能力

00:18:12.559 --> 00:18:15.095 
我想向你們演示一個

00:18:15.162 --> 00:18:16.630 
示例代碼
以便進一步向你們解釋

00:18:17.931 --> 00:18:20.601 
這是一個示例代碼
如果你需要基於新的MetalKit

00:18:20.667 --> 00:18:23.203 
框架、創建一個新的
應用程序

00:18:23.270 --> 00:18:25.405 
那麼你就需要寫這個代碼了

00:18:26.206 --> 00:18:28.742 
你需要做的第一件事
就是當你想要設置視圖時

00:18:28.909 --> 00:18:30.644 
你要在這裏做
幾件事

00:18:31.512 --> 00:18:32.880 
第一件關鍵的事

00:18:33.280 --> 00:18:37.150 
是把那個視圖的 “僅幀
緩存器” 屬性設置爲 “假”

00:18:37.618 --> 00:18:40.120 
這樣 “核心圖像” 就可以使用
Metal計算着色器來向

00:18:40.187 --> 00:18:42.322 
那個視圖的輸出紋理
進行渲染

00:18:44.424 --> 00:18:45.359 
你下一步要做的

00:18:45.425 --> 00:18:48.328 
就是使用一臺Metal設備
來把那個CIContext初始化

00:18:48.795 --> 00:18:51.598 
這樣做的原因是
在一個應用程序中

00:18:51.665 --> 00:18:54.268 
類似初始化一個CIContext
這種事情 你只想做一次

00:18:56.904 --> 00:18:59.439 
然後在 “繪製和視圖委託”
功能中

00:18:59.940 --> 00:19:01.875 
要通過那個視圖渲染某些
CI濾鏡

00:19:01.942 --> 00:19:03.544 
你就需要寫這樣的
代碼

00:19:03.810 --> 00:19:05.712 
讓我來帶領你們
逐句通過這個代碼

00:19:06.713 --> 00:19:08.615 
首先
你要創建一個命令緩衝區

00:19:09.049 --> 00:19:11.385 
這個緩衝區最終
會給到這個可繪製物

00:19:13.720 --> 00:19:16.190 
然後我們要用一些給定的
輸入Metal紋理

00:19:16.290 --> 00:19:18.325 
來對一個CI圖像
進行初始化

00:19:18.659 --> 00:19:22.629 
現在 這個CI圖像可以通過
其它方式出現 舉例來說

00:19:22.696 --> 00:19:25.065 
我們有的某些其它圖像類型
比如一個CGImage

00:19:25.132 --> 00:19:28.902 
不過在這個例子中 我們只是
向你們演示下如何使用新API

00:19:28.969 --> 00:19:32.105 
一旦你有了一張
CI圖像

00:19:32.206 --> 00:19:36.210 
你就可以把一系列的CI濾鏡
鏈接到它上面

00:19:36.276 --> 00:19:39.446 
在這個例子中 我們要使用
一個CI高斯模糊濾鏡

00:19:42.149 --> 00:19:44.985 
然後一旦你有了你想要渲染的
CI圖像

00:19:45.485 --> 00:19:48.555 
你就想要抓取當前綁定到
那個視圖的當前可繪製物上

00:19:48.622 --> 00:19:52.659 
的紋理
然後使用我們在這裏想用的

00:19:52.759 --> 00:19:56.230 
命令緩衝區 把CI圖像渲染到
那個紋理

00:19:58.198 --> 00:20:00.167 
最後 一旦我們編碼好了
這個渲染命令

00:20:00.234 --> 00:20:03.504 
你就還需要向命令緩衝區
插入另外的一個Metal命令

00:20:03.770 --> 00:20:05.772 
目的是爲了顯示視圖的當前
可繪製物

00:20:06.440 --> 00:20:08.342 
然後你只需要在緩衝區調用
提交即可

00:20:09.676 --> 00:20:11.044 
把一些 “核心圖像” 濾鏡

00:20:11.111 --> 00:20:13.080 
集成到
一個MetalKit應用程序

00:20:13.213 --> 00:20:14.748 
就是這麼簡單

00:20:18.652 --> 00:20:19.920 
接下來我想談一談

00:20:19.987 --> 00:20:22.422 
如何橋接 “核心圖像”
以及AV Foundation

00:20:24.992 --> 00:20:26.960 
有了我們今年在這些框架中
做的最新的變更

00:20:27.027 --> 00:20:30.597 
現在向你的AVFoundation
應用程序添加 “核心圖像”

00:20:30.664 --> 00:20:31.865 
濾鏡就很容易了

00:20:33.133 --> 00:20:34.434 
這是因爲現在 “核心圖像”

00:20:34.635 --> 00:20:37.204 
已經方便地和AVVideo
Composition類

00:20:37.271 --> 00:20:38.472 
集成到了一起

00:20:39.907 --> 00:20:42.209 
默認你會得到自動
顏色管理

00:20:42.609 --> 00:20:44.444 
但是如果你不需要
你也可以禁用它

00:20:46.380 --> 00:20:48.649 
我們來通過幾個例子
看看如何把CI濾鏡

00:20:48.715 --> 00:20:50.350 
應用到視頻上

00:20:50.918 --> 00:20:52.986 
首先是在導出視頻的語境中
其次是在實況回放

00:20:53.053 --> 00:20:54.855 
一個視頻的
語境中

00:20:55.422 --> 00:20:59.927 
要演示這些
例子

00:21:00.093 --> 00:21:01.295 
我們要使用幾年前我們在

00:21:01.361 --> 00:21:03.497 
蘋果全球開發者大會上
演示給你們的一個濾鏡

00:21:03.564 --> 00:21:08.001 
在這個濾鏡中
對於視頻圖像的每一幀

00:21:08.068 --> 00:21:12.806 
我們都會首先在它上面
應用一個棕黑色調濾鏡以及

00:21:12.873 --> 00:21:19.046 
隨機噪聲
最後是在它的頂部進行一些

00:21:19.112 --> 00:21:21.849 
垂直刮痕覆蓋

00:21:21.915 --> 00:21:27.754 
你們中如果有人記得的話
這是一個老電影濾鏡

00:21:28.355 --> 00:21:31.592 
是幾年前我們在蘋果全球
開發者大會上演示給你們的

00:21:31.725 --> 00:21:34.127 
第一個濾鏡非常
直接

00:21:34.194 --> 00:21:37.664 
它只需要一個單一的
輸入圖像

00:21:37.731 --> 00:21:39.800 
以及一個輸入時間參數
你可以用這個參數來

00:21:39.867 --> 00:21:42.669 
以可重複的方式、
可預見的結果

00:21:42.936 --> 00:21:44.171 
來向視頻應用特效

00:21:44.872 --> 00:21:49.843 
我們回來看看導出那個
視頻時 我們應該怎樣

00:21:49.910 --> 00:21:50.878 
應用這個濾鏡

00:21:52.279 --> 00:21:55.249 
你首先需要做的 就是創建
一個經過過濾的合成

00:21:55.883 --> 00:21:59.720 
賦予它你想要導出的音頻視頻
資產以及一個回調塊

00:21:59.786 --> 00:22:04.658 
你在這個回調塊中可以指定
渲染視頻的每一幀時

00:22:05.192 --> 00:22:09.596 
應用的一個
濾鏡 “配方”

00:22:10.497 --> 00:22:13.166 
從這個回調塊中 我們就可以
得到一個請求對象

00:22:13.233 --> 00:22:16.336 
這個對象就是一個輸入參數
你就可以得到把你的

00:22:16.703 --> 00:22:18.071 
CI濾鏡鏈接在一起的

00:22:18.305 --> 00:22:20.407 
合成時間
以及源圖像

00:22:22.009 --> 00:22:26.013 
一旦你有了自己的
經過過濾的CI圖像

00:22:26.380 --> 00:22:28.849 
你就可以調用請求對象上的
Finish With圖像

00:22:29.449 --> 00:22:31.818 
你可以向那個調用傳遞一個
“無” 語境

00:22:32.186 --> 00:22:34.321 
然後AVVideo
Composition

00:22:34.388 --> 00:22:36.657 
默認
就會創建一個CIContext

00:22:37.324 --> 00:22:38.425 
就像我之前提到的

00:22:38.492 --> 00:22:40.294 
CIContext會自動得到
顏色管理

00:22:40.994 --> 00:22:42.696 
如果你想禁用它
那麼你只需要創建一個

00:22:42.763 --> 00:22:44.665 
你自己的
CIContext

00:22:45.232 --> 00:22:48.669 
指定一個空顏色工作區
然後把它傳遞到那個

00:22:48.735 --> 00:22:50.437 
Finish With圖像調用中

00:22:53.240 --> 00:22:57.110 
我們剛剛向你展示的濾鏡
是一個十分簡單的濾鏡

00:22:57.678 --> 00:23:00.447 
並不涉及
卷積濾鏡

00:23:00.981 --> 00:23:03.217 
但是在這個例子中
你確實有了卷積濾鏡

00:23:03.550 --> 00:23:07.454 
你要小心的一件事是
不良的結果

00:23:08.021 --> 00:23:10.991 
即乾淨的像素
滲透進了

00:23:11.058 --> 00:23:12.793 
那副圖像的邊緣

00:23:13.827 --> 00:23:17.331 
要解決這個問題
我們有一個簡單的方法

00:23:17.564 --> 00:23:19.666 
我們在很多類中都會用到
這個方法 也包括那個類

00:23:20.400 --> 00:23:21.969 
你首先要做的

00:23:22.636 --> 00:23:25.973 
就是有了源圖像 你就想把
卷積濾鏡應用到它上面

00:23:26.039 --> 00:23:28.609 
你想通過夾緊延伸
來調用圖像

00:23:29.243 --> 00:23:32.846 
它會無限邊緣複製那個圖像的
全部像素

00:23:32.913 --> 00:23:34.248 
以及圖像的邊緣

00:23:35.082 --> 00:23:37.985 
這樣的話
當你應用這個濾鏡時

00:23:39.353 --> 00:23:42.923 
你就不會再出現清晰的像素
和圖像融合這個問題了

00:23:44.591 --> 00:23:47.427 
因爲如果那樣做 你最後得到的
就是一張無限大的圖像

00:23:47.794 --> 00:23:51.431 
濾鏡應用結束時
你想要通過剪切矩形

00:23:51.498 --> 00:23:54.101 
來增加圖像
以便把那個圖像剪切回到

00:23:54.168 --> 00:23:55.636 
源圖像的範圍

00:23:57.604 --> 00:24:01.642 
通過使用這個簡單的方法
你看到的圖像就更簡潔了

00:24:02.042 --> 00:24:04.811 
邊緣邊界也非常漂亮、
明快、敏銳

00:24:08.782 --> 00:24:09.883 
因此一旦我們有了那個

00:24:09.950 --> 00:24:11.752 
AVVideo
Composition

00:24:12.119 --> 00:24:15.556 
如果你想要創建一個
導出會話以便導出一個視頻

00:24:15.622 --> 00:24:16.723 
你就可以通過創建這個

00:24:17.491 --> 00:24:19.893 
音頻視頻導出會話
並且指定你想要導出的

00:24:20.561 --> 00:24:23.664 
一個輸出URL位置
來實現

00:24:23.730 --> 00:24:27.100 
你也可以指定我們剛剛創建的
視頻組成的導出位置

00:24:28.168 --> 00:24:30.304 
要記住的一點是
你可能想要...

00:24:31.004 --> 00:24:34.208 
你想要調用 “從URL刪除項目”
來刪除任何可能已經存在於

00:24:34.274 --> 00:24:36.376 
那個導出位置的
項目

00:24:37.211 --> 00:24:38.979 
一旦你完成後
你就可以在導出會話上

00:24:39.046 --> 00:24:41.648 
調用Export
Asynchronously

00:24:42.082 --> 00:24:43.483 
這樣就會開始一個進程
導出那個

00:24:44.218 --> 00:24:47.955 
視頻
並且把CI濾鏡應用到

00:24:48.021 --> 00:24:49.489 
你的視頻的每一個
單一的幀上

00:24:50.390 --> 00:24:53.293 
如果你想要更新你的UI上的
某些進度

00:24:53.360 --> 00:24:56.296 
以便顯示
那個導出的進度

00:24:56.530 --> 00:24:59.867 
你就可以在你的調用塊中
使用 “合成時間” 參數

00:25:00.000 --> 00:25:01.935 
來更新這樣的UI元素

00:25:06.039 --> 00:25:07.841 
現在它導出了

00:25:08.141 --> 00:25:11.044 
如果是回放一個音頻視頻資產
你需要寫的代碼

00:25:11.111 --> 00:25:12.880 
實際上
也非常類似

00:25:13.313 --> 00:25:16.750 
創建視頻組成的代碼
和我們之前看到的一模一樣

00:25:17.451 --> 00:25:19.953 
唯一的不同之處在於
你不需要再創建一個

00:25:20.020 --> 00:25:21.288 
導出會話

00:25:21.722 --> 00:25:24.491 
你需要用那個音頻視頻資產
以及我們剛剛創建的視頻組成

00:25:24.892 --> 00:25:27.461 
來創建一個
AVPlayerItem

00:25:28.395 --> 00:25:30.797 
然後再用那個播放器項目
創建一個AVPlayer

00:25:30.864 --> 00:25:33.100 
之後在你的播放器內
調用“播放”

00:25:33.734 --> 00:25:39.640 
現在我要向你們展示一個
視頻 讓你們看看我們是如何

00:25:39.706 --> 00:25:44.378 
在回放時 把那個老電影濾鏡
應用到一個音頻視頻資產的

00:25:48.148 --> 00:25:49.950 
這裏要注意的一件事是

00:25:50.017 --> 00:25:51.718 
當你清洗這個
視頻時

00:25:51.985 --> 00:25:53.921 
你可以看到同樣的特效
以可重複的方式、

00:25:53.987 --> 00:25:56.990 
可預期的結果
應用到了這個視頻上

00:25:58.025 --> 00:25:59.393 
因此 “核心圖像”

00:25:59.459 --> 00:26:02.729 
和AV Foundation高效
互操作在了一起

00:26:03.230 --> 00:26:07.201 
接下來我想請
亞歷克斯

00:26:07.267 --> 00:26:09.269 
來再給你們講講
“核心圖像” 提供程序

00:26:09.870 --> 00:26:10.737 
謝謝

00:26:15.509 --> 00:26:16.343 
謝謝 託尼

00:26:17.211 --> 00:26:19.847 
我的名字是亞歷山大·納曼
我要講講 “核心圖像”

00:26:19.913 --> 00:26:21.381 
提供程序
然後我們再講講我們的

00:26:21.448 --> 00:26:23.717 
系統上的更多的API
還有STKs

00:26:23.784 --> 00:26:26.119 
以及它們是如何
和 “核心圖像” 一起工作

00:26:26.353 --> 00:26:27.788 
創造有趣的
應用程序

00:26:29.423 --> 00:26:30.257 
我們從

00:26:30.324 --> 00:26:31.692 
CIImageProvider
開始吧

00:26:31.758 --> 00:26:33.360 
CIImageProvider是

00:26:33.427 --> 00:26:35.662 
我們在CI圖像上的一個類型
之前OS X上就有了

00:26:35.729 --> 00:26:37.865 
但是現在 作爲我們的

00:26:38.265 --> 00:26:40.267 
統一執行的一部分
現在iOS上也有了

00:26:40.334 --> 00:26:44.171 
對你來說
你就可以把輸入圖像帶入

00:26:44.238 --> 00:26:48.108 
你的系統 而如果沒有它
這就是不可能的

00:26:48.175 --> 00:26:49.743 
舉例來說
如果你有一個不被支持的

00:26:50.310 --> 00:26:52.179 
文件格式
你想要創建一個基於

00:26:52.246 --> 00:26:55.015 
那個文件格式的
CI圖像

00:26:55.682 --> 00:26:58.485 
或者說 如果你有某些
從某些站點流出的數據

00:26:58.552 --> 00:27:00.187 
而且你想創建一個CI圖像

00:27:00.254 --> 00:27:02.756 
那麼你就可以使用一個CIImage
Provider

00:27:03.323 --> 00:27:05.292 
它們是通過
回調實現的

00:27:06.159 --> 00:27:10.264 
你可以坐享其成
當我們需要填寫數據時

00:27:10.330 --> 00:27:13.433 
我們會通知你、告訴你
你就可以得到自動鑲嵌圖案

00:27:13.500 --> 00:27:15.969 
而我們就會爲你處理輕便性
以及緩存

00:27:16.970 --> 00:27:18.272 
我們來看看
它是怎樣實現的

00:27:18.939 --> 00:27:20.908 
先說重要的
你創建你自己的類

00:27:20.974 --> 00:27:23.510 
在這個例子中 我們創建
一個叫做圖塊提供程序的類

00:27:24.678 --> 00:27:27.447 
然後我們用這個圖塊提供程序
創建一個CI圖像

00:27:27.915 --> 00:27:30.450 
除了這個
我們讓它的尺寸和我們試圖

00:27:30.651 --> 00:27:33.387 
創建的圖像尺寸一致
無論我們想用什麼樣的格式

00:27:33.453 --> 00:27:37.057 
來創建這幅圖像
一個可選擇的顏色空間

00:27:37.357 --> 00:27:40.160 
在這個例子中
我們在選項字典中

00:27:40.227 --> 00:27:42.796 
給出圖塊尺寸

00:27:44.464 --> 00:27:45.866 
要把這個用起來

00:27:46.834 --> 00:27:49.937 
我們只需要實現一種叫做
“提高圖像資料” 的方法

00:27:50.003 --> 00:27:52.406 
“核心圖像” 就會通知你、
告訴你

00:27:52.472 --> 00:27:53.841 
填寫這個信息

00:27:55.075 --> 00:27:56.977 
你必須在那個
數據指針中填寫這個信息

00:27:57.211 --> 00:28:01.615 
數據指針有給定的行字節值
在X和Y軸上有確定的位置

00:28:01.715 --> 00:28:03.684 
有確定的寬度和高度
如果你願意的話

00:28:03.750 --> 00:28:05.285 
你還可以標記一些用戶信息

00:28:05.352 --> 00:28:06.854 
要實現你自己的
圖像提供程序

00:28:06.920 --> 00:28:09.857 
你要做的
就是這些

00:28:09.923 --> 00:28:15.462 
現在我們再來談談我們擁有的
各種視圖類

00:28:15.529 --> 00:28:16.964 
談談你可以在iOS和OS X上

00:28:17.030 --> 00:28:19.032 
和 “核心圖像” 一起用的
各種視圖類

00:28:20.200 --> 00:28:23.237 
我們對使用 “核心圖像”
進行渲染就有了一個廣譜

00:28:23.303 --> 00:28:25.005 
支持
所處的系統可以是

00:28:25.072 --> 00:28:29.176 
非常高級的
例如UIImageView

00:28:29.476 --> 00:28:30.677 
這樣對應用了一種

00:28:31.011 --> 00:28:32.713 
“核心圖像” 特效的
圖像進行渲染

00:28:32.779 --> 00:28:33.647 
就非常容易

00:28:34.081 --> 00:28:36.083 
也可以是
非常低級的系統

00:28:36.550 --> 00:28:40.754 
或者可能是高級性能APIs
比如GLKView

00:28:40.821 --> 00:28:45.325 
或者MTK視圖
你就可以對你所做的事情

00:28:45.392 --> 00:28:46.460 
有細粒度更高的控制

00:28:50.197 --> 00:28:52.099 
那麼讓我們來看看
UIImageView

00:28:53.267 --> 00:28:54.668 
UIImageView可能是

00:28:54.735 --> 00:28:57.538 
在iOS上展示一幅CI圖像的
最簡單的方式

00:28:57.871 --> 00:28:59.840 
你需要在你的
UIImageView上

00:28:59.907 --> 00:29:03.377 
做的 就是把圖像屬性
設置成一個UI圖像...

00:29:03.944 --> 00:29:06.213 
在這個例子中
是一個基於CI的圖像

00:29:07.514 --> 00:29:10.184 
問題在於
雖然使用這個方法非常簡單

00:29:10.817 --> 00:29:13.387 
它並不是展示一幅CI圖像的
性能最高的方法

00:29:13.987 --> 00:29:15.923 
那麼最後我們不得不做的

00:29:16.657 --> 00:29:18.759 
就是把它渲染回CPU

00:29:18.825 --> 00:29:21.128 
然後把它
發送回GPU

00:29:21.195 --> 00:29:22.763 
效率不是
儘可能地高

00:29:22.829 --> 00:29:24.698 
如果我們看一個
簡單的示例

00:29:24.765 --> 00:29:25.832 
在這個例子中

00:29:25.899 --> 00:29:27.868 
我們通過使用一個
UIImageView

00:29:28.101 --> 00:29:29.536 
來運行一個像素化濾鏡

00:29:29.970 --> 00:29:32.906 
我們可以看到
應用了這種特性後

00:29:32.973 --> 00:29:38.178 
我們在視網膜尺寸圖像上
得到了大約每秒二十幀

00:29:40.347 --> 00:29:44.952 
如果我們改用
OpenGL ES-based視圖

00:29:45.719 --> 00:29:48.255 
並且應用同樣的濾鏡

00:29:49.256 --> 00:29:52.426 
我們就可以看到
我們現在是每秒四十八幀

00:29:54.561 --> 00:29:57.064 
如果我們再進一步

00:29:57.531 --> 00:29:58.932 
進行一次基於Metal的查看

00:30:01.268 --> 00:30:02.903 
我們在這裏還有些許提升

00:30:02.970 --> 00:30:04.304 
我們就是每秒五十二幀

00:30:04.671 --> 00:30:07.975 
雖然這並不特別了不起
但是我們僅僅應用了一個濾鏡

00:30:08.609 --> 00:30:11.011 
因此我們得到的優勢
並不那麼明顯

00:30:11.078 --> 00:30:14.114 
不像我們應用多個濾鏡
或者我們有一堆較小的

00:30:14.781 --> 00:30:17.117 
渲染時
我們得到的優勢那麼明顯

00:30:18.185 --> 00:30:19.286 
但是基本理念就是這個

00:30:20.921 --> 00:30:23.724 
現在讓我們看看 “核心圖像”
以及 “核心動畫”

00:30:23.790 --> 00:30:25.425 
看看我們怎樣可以讓它們
一起工作

00:30:27.661 --> 00:30:29.296 
這是一個我們在iOS以及OS X上

00:30:29.363 --> 00:30:31.532 
有所不同的例子
非常少見

00:30:31.665 --> 00:30:36.136 
在OS X上 我們只需要
應用即可 要讓 “核心圖像”

00:30:36.570 --> 00:30:39.273 
以及 “核心動畫” 一起工作
我們只需要做兩件事

00:30:39.673 --> 00:30:40.774 
先說重要的

00:30:41.708 --> 00:30:44.178 
在你的NSview
你只需要說view.layer

00:30:44.244 --> 00:30:48.215 
使用 “核心圖像” 濾鏡
把它設爲

00:30:48.282 --> 00:30:51.585 
“真” 然後可選擇地
指定你想要應用到

00:30:51.652 --> 00:30:53.587 
你有的無論哪個層的
濾鏡

00:30:54.121 --> 00:30:55.088 
陣列

00:30:55.656 --> 00:30:56.990 
你需要做的
就這些

00:30:59.893 --> 00:31:01.328 
而在iOS上

00:31:02.196 --> 00:31:04.097 
我們就沒有這種支持了

00:31:04.164 --> 00:31:06.133 
因此
你可以做的就是直接OpenGL

00:31:07.634 --> 00:31:10.737 
你可以通過衍生於GLKView
來這麼做

00:31:11.138 --> 00:31:14.942 
或者通過創建一個UIView
確保你覆寫了層類方法

00:31:15.008 --> 00:31:17.010 
並且返回了
CA鷹layer.self

00:31:17.244 --> 00:31:19.646 
來
這麼做

00:31:19.713 --> 00:31:22.850 
當你這麼做的時候
你就會得到一個GL基於ES的對象

00:31:23.984 --> 00:31:26.320 
然後你就可以用它創建
你自己的CIContext

00:31:26.587 --> 00:31:28.422 
那樣就可以確保
你獲得最優性能

00:31:28.922 --> 00:31:31.391 
這些都很棒
不過你需要牢記一件事

00:31:31.458 --> 00:31:33.760 
如果你想要獲得
很棒的性能

00:31:33.827 --> 00:31:35.829 
那麼這就不僅僅是
使用最好的API這麼簡單

00:31:35.896 --> 00:31:37.364 
更是要有效地使用最好的API

00:31:37.431 --> 00:31:39.466 
在這個例子中
你要記住的第一件事就是

00:31:39.533 --> 00:31:42.269 
僅僅創建你的CIContext一次
因爲緩存就發生在那裏

00:31:42.336 --> 00:31:43.470 
那裏也保持了

00:31:43.937 --> 00:31:46.139 
一大堆的狀態

00:31:46.707 --> 00:31:47.875 
因此

00:31:47.941 --> 00:31:51.044 
當你使用低層APIs時
要記住這點

00:31:54.147 --> 00:31:55.516 
現在 我想談談

00:31:55.582 --> 00:31:57.284 
IOSurface上的
“核心圖像”

00:31:58.185 --> 00:32:01.655 
我們在 “核心圖像” 執行的
內部

00:32:01.722 --> 00:32:03.223 
大量使用IOSurface

00:32:03.724 --> 00:32:06.159 
作爲一個API 我們超愛它
因爲它給我們提供了

00:32:06.226 --> 00:32:08.195 
一堆系統中
其它API不存在的

00:32:09.730 --> 00:32:10.931 
功能性

00:32:10.998 --> 00:32:13.400 
因此大體上
我們就有了很棒的輕便性

00:32:13.767 --> 00:32:15.836 
一些鎖定語義
因此我們就可以讓數據在

00:32:15.903 --> 00:32:19.239 
IOSurfaces上進進出出
非常適合用來把數據從CPU

00:32:19.306 --> 00:32:20.908 
搬到GPU
或者從GPU搬到CPU

00:32:21.408 --> 00:32:24.211 
我們對不同格式的支持
廣譜

00:32:24.278 --> 00:32:26.380 
令人難以置信
我們認爲可能有些是

00:32:26.446 --> 00:32:27.581 
整個系統上
最棒的

00:32:27.648 --> 00:32:29.783 
舉例來說 我們有420、444、

00:32:29.850 --> 00:32:32.386 
RGBA半浮動
以及很多其它的支持

00:32:34.288 --> 00:32:37.324 
現在在iOS上
作爲一個開發者

00:32:37.391 --> 00:32:40.727 
要直接使用IOSurface就比較
難了 但是你可以通知 “核心圖像”

00:32:40.794 --> 00:32:42.529 
你想要通過創建
“像素緩衝區” 的方式

00:32:42.963 --> 00:32:44.398 
來使用IOSurface

00:32:45.766 --> 00:32:48.035 
IOSurface上
KCV像素緩衝區

00:32:48.101 --> 00:32:49.970 
IOSurface屬性鍵
是指定了的

00:32:50.838 --> 00:32:52.973 
當你那樣做的時候
如果你從一個CV像素緩衝區

00:32:53.273 --> 00:32:55.809 
創建了一個CV圖像
並且圖像有這個鍵

00:32:56.710 --> 00:32:58.045 
那麼內部結束時
就是

00:32:58.312 --> 00:32:59.880 
“核心圖像” 知道它是一個

00:32:59.947 --> 00:33:02.115 
IOSurface支持的CV像素緩
衝區

00:33:02.182 --> 00:33:04.251 
我們就可以儘可能高效地
進行渲染

00:33:04.952 --> 00:33:06.920 
因此如果你想在iOS上
享受IOSurface的全部好處

00:33:06.987 --> 00:33:09.022 
那麼你就需要
記住這個

00:33:11.425 --> 00:33:13.460 
接下來我想再談
幾個其他的APIs

00:33:13.527 --> 00:33:16.230 
我們會仔細看幾個例子 看看
我們可以怎樣實際一起使用

00:33:16.630 --> 00:33:21.168 
“核心圖像” 以及STKs、非常
容易地創建示例應用程序

00:33:21.235 --> 00:33:23.370 
那麼我們從SpriteKit
開始吧

00:33:24.438 --> 00:33:29.810 
如果我們在XCode中開始
創建一個新的應用程序

00:33:30.177 --> 00:33:34.214 
我們選擇 “遊戲”
然後選擇一種

00:33:34.281 --> 00:33:36.517 
遊戲技術SpriteKit

00:33:36.950 --> 00:33:41.922 
然後我們構建、運行
我們就得到了這個應用程序

00:33:41.989 --> 00:33:46.393 
這樣當你點擊屏幕時
新的飛船就會顯示出來

00:33:46.793 --> 00:33:51.632 
你可以看到我們是
每秒六十幀

00:33:51.698 --> 00:33:54.568 
我們現在可以用少量的代碼
把 “核心圖像”

00:33:54.635 --> 00:33:58.305 
添加到
這個應用程序

00:33:58.639 --> 00:33:59.473 
在這個例子中

00:33:59.540 --> 00:34:01.742 
我們會在Game
Scene.swift中修改

00:34:01.808 --> 00:34:03.710 
Touches Began方法
那麼一開始

00:34:04.845 --> 00:34:06.079 
每次點擊後會發生的事情

00:34:06.380 --> 00:34:09.616 
就是會把那個子畫面
添加到根節點

00:34:10.484 --> 00:34:12.018 
我們再修改下

00:34:12.853 --> 00:34:15.489 
我們要使用一個SK特效節點

00:34:15.556 --> 00:34:18.859 
一個SK特效節點會把整個環境
渲染進一個緩衝區

00:34:19.393 --> 00:34:21.828 
然後你就可以向它應用
一系列的濾鏡

00:34:23.230 --> 00:34:24.731 
因此我們添加一個SK特效節點

00:34:25.065 --> 00:34:27.234 
我們就不像之前那樣
把子畫面增加到根

00:34:27.301 --> 00:34:28.668 
我們會把子畫面添加到特效

00:34:29.735 --> 00:34:31.672 
我們說 我們想啓用
某些特效

00:34:33.273 --> 00:34:35.475 
我們要創建一個濾鏡
在這裏例子中

00:34:35.542 --> 00:34:36.743 
我們要使用一個像素化濾鏡

00:34:37.311 --> 00:34:39.012 
它和我們之前看到的濾鏡
是一模一樣的

00:34:40.813 --> 00:34:41.982 
然後我們把那個特效

00:34:42.649 --> 00:34:43.650 
添加到
根

00:34:43.717 --> 00:34:44.784 
我們需要做的就這些

00:34:45.252 --> 00:34:48.188 
如果你想要添加 “核心圖像”
到一個SpriteKit應用程序

00:34:48.589 --> 00:34:51.491 
那麼你需要寫的代碼
正是這個

00:34:51.859 --> 00:34:54.228 
如果我們現在運行
我們有的同樣的示例

00:34:54.862 --> 00:34:56.163 
並且開始點擊

00:34:57.063 --> 00:34:59.700 
我們就在
我們的應用程序內得到了

00:34:59.867 --> 00:35:00.834 
美麗的像素化子畫面

00:35:01.401 --> 00:35:03.470 
而且運行的幀率
也一樣

00:35:05.906 --> 00:35:06.840 
現在

00:35:06.907 --> 00:35:08.308 
我們再談談SceneKit

00:35:11.545 --> 00:35:13.847 
理念是相同的我們通過 “開始”
來創建一個應用程序

00:35:14.581 --> 00:35:16.617 
我們選擇SceneKit
作爲一個遊戲技術

00:35:16.917 --> 00:35:18.619 
如果我們直接構建、運行
這個app

00:35:19.786 --> 00:35:20.654 
我們就得到了

00:35:20.721 --> 00:35:22.122 
這艘以交互速度旋轉的
宇宙飛船

00:35:23.624 --> 00:35:24.925 
以及駛離我們方向的宇宙飛船

00:35:26.293 --> 00:35:28.562 
如果我們想要向這個應用程序
添加 “核心圖像”

00:35:28.629 --> 00:35:30.397 
那麼我們需要做的

00:35:30.731 --> 00:35:33.734 
就是到GameView
Controllerswift中的

00:35:35.135 --> 00:35:36.503 
View Did
Load方法找到飛船

00:35:36.570 --> 00:35:39.439 
飛船在示例代碼中
是對齊的

00:35:41.909 --> 00:35:44.645 
然後我們就再次創建
像素化濾鏡

00:35:45.612 --> 00:35:48.549 
給飛船指定一個
濾鏡可選陣列

00:35:49.483 --> 00:35:52.085 
如果我們這麼做了後運行app

00:35:52.486 --> 00:35:54.788 
就得到一艘美麗的像素化飛船

00:35:55.622 --> 00:35:57.624 
你可以把它應用到你的場景中
的任何節點 並且

00:35:59.092 --> 00:36:00.360 
我們再次得到了很棒的幀率

00:36:02.095 --> 00:36:05.132 
同時使用SceneKit以及
“核心 圖像” 的一大優勢在於

00:36:05.199 --> 00:36:07.701 
你可以使用 “核心動畫”

00:36:08.202 --> 00:36:10.170 
來動畫繪製屬性

00:36:11.505 --> 00:36:13.106 
在這裏例子中
我們要創建一個

00:36:13.173 --> 00:36:15.742 
CA基礎動畫
我們要動畫繪製

00:36:15.809 --> 00:36:17.444 
輸入規模
因此我們會得到一個

00:36:17.511 --> 00:36:21.615 
變化的規模像素化特效
隨着時間推移

00:36:21.682 --> 00:36:23.917 
這個特效會被應用一個
零到五十的值

00:36:24.585 --> 00:36:28.121 
在兩秒內
它會悄悄地來、悄悄地走

00:36:28.655 --> 00:36:30.290 
如果我們添加這個代碼

00:36:32.492 --> 00:36:33.493 
我們的飛船就會有一個

00:36:34.761 --> 00:36:37.698 
美麗的

00:36:40.167 --> 00:36:41.201 
動畫繪製像素化特效

00:36:42.736 --> 00:36:44.538 
並且 幀率仍然很棒

00:36:46.840 --> 00:36:49.810 
這個並不是一定需要
應用到一個節點上

00:36:49.877 --> 00:36:51.745 
你可以把它應用到你的
整個場景上

00:36:51.812 --> 00:36:53.113 
這裏我們推出了一個
示例

00:36:53.580 --> 00:36:55.716 
你可以下載它
它叫 “香蕉”

00:36:56.450 --> 00:36:59.019 
和動畫一起 我們應用了
相同的特效

00:37:00.320 --> 00:37:04.057 
並且我們會在這裏實時改變
像素化規模

00:37:04.925 --> 00:37:07.327 
當它像素化後
我可以比全分辨率更好地

00:37:07.394 --> 00:37:12.232 
玩這個遊戲了
這讓我有點吃驚

00:37:12.399 --> 00:37:15.035 
不過除了創建遊戲外
你可以用這個

00:37:15.102 --> 00:37:18.272 
在遊戲結尾添加一個
特效

00:37:18.338 --> 00:37:23.277 
舉例來說
如果你想讓你的資產的不同

00:37:23.343 --> 00:37:24.478 
版本被不同的

00:37:24.845 --> 00:37:26.246 
圖像處理特效
渲染

00:37:26.313 --> 00:37:28.315 
你就可以和這些APIs一起

00:37:28.382 --> 00:37:30.284 
來使用 “核心圖像”
完全沒問題的

00:37:32.452 --> 00:37:36.256 
到現在爲止 我們今天看了
很多東西

00:37:36.323 --> 00:37:37.858 
看了怎樣一起使用 “核心圖像”

00:37:37.925 --> 00:37:39.927 
以及Metal和AV
Foundation

00:37:39.993 --> 00:37:42.429 
爲什麼IOSurface對我們
如此重要

00:37:43.096 --> 00:37:46.099 
我們還看了如果你僅僅創建了
一幅圖像一次

00:37:46.733 --> 00:37:47.701 
並且不需要頻繁更新

00:37:47.768 --> 00:37:50.337 
那麼使用UIImageView的
最簡單的方法是什麼

00:37:50.404 --> 00:37:52.306 
僅僅應用一個特效一次
是一種很棒的方法

00:37:52.873 --> 00:37:54.908 
我們也向你演示瞭如何使用
“核心動畫”

00:37:55.242 --> 00:37:58.078 
如何CIImageProvider
帶入定製數據

00:37:58.145 --> 00:38:01.815 
以及如何在遊戲語境或者
其他應用程序語境中使用它

00:38:02.115 --> 00:38:05.419 
你如何可以用SceneKit或者S
priteKit非常簡單地創建它

00:38:07.955 --> 00:38:08.889 
要獲取更多信息

00:38:09.156 --> 00:38:12.326 
我們在developer.
apple.com有很多的資源

00:38:12.392 --> 00:38:14.261 
可以在線獲取

00:38:15.128 --> 00:38:17.431 
如何你有任何其它諮詢

00:38:17.831 --> 00:38:19.433 
你可以通過
chick@apple.com

00:38:19.499 --> 00:38:20.667 
聯繫斯蒂芬·奇克

00:38:22.369 --> 00:38:25.639 
你可能想要參加其它會議

00:38:25.706 --> 00:38:27.941 
包括 “在AV
Foundation 中編輯電影”

00:38:28.342 --> 00:38:31.345 
這場會議幾天前已經舉行過了
不過你可以在線觀看視頻

00:38:31.545 --> 00:38:35.482 
還有昨天舉行的
“Metal中有什麼新料第二部分”

00:38:38.218 --> 00:38:40.454 
如上所述
謝謝你們來參會

00:38:40.521 --> 00:38:43.123 
希望你們會愛上在你們的
應用程序中使用 “核心圖像”

00:38:43.190 --> 00:38:45.259 
祝你們在會議剩餘的
時間裏過得愉快  謝謝！