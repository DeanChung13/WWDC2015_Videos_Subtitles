Swift性能优化
早上好 欢迎来到“Swift性能优化”演讲现场 
我的名字是那達夫我将与我的同事迈克尔
和乔一起向大家展示如何
优化你的Swift程序
现在我们编译器团队的工程师热衷于让代码运行得快
我们相信如果你的app得到高度优化
你可以创造出令人叹为观止的作品
如果你有同样的看法那么这个演讲适合你听
今天我首先要讲一讲在过去的几年中
我们对编译器所做的一些新的优化
之后迈克尔将描述Swift语言的底层实现
并就如何编写高性能的
Swift代码给大家一些建议
最后乔将演示如何使用工具来识别
和分析你的Swift代码中的性能瓶颈
Swift是一个灵活并且安全的编程语言
有很多的功能包括闭环 协议 泛化
当然还有自动引用计数
现在你们中有些人可能把这些特性与运行缓慢联系在一起
因为程序必须做更多的工作来实现这些高级功能
但Swift是一种非常快速的编程语言
可以编译为高度优化的本地代码
那么我们如何让Swift迅速运行呢?
好 我们将编译器优化的
目标设定为所有的这些高级功能实现了这些目标
就可以确保那些高级功能造成的负担是最小的
现在 我们有很多编译器优化
但是我们没有足够的时间去逐一回顾
所以我决定给你们举一个编译器优化的例子
这种优化称为消除边界检查
在屏幕上你们可以看到一个非常简单的循环
这个循环用数字13对阵列中的所有
元素进行扫描从而对阵列的内容进行加密
这种加密方式并不好
在阵列边界以外进行读写
是一个严重的错误
也可能有安全隐患
而Swift则可以对你的程序进行保护它添加了一些代码
能够检查阻止程序在阵列边界以外进行读写
现在 问题是这种检查会拖慢代码的运行速度
另一个问题是它会阻挡其他优化
例如在运行这种检查时
我们就不能将这段代码向量化
所以我们已经实现了一个编译器优化
以便将这种检查置于循环之外使检查的代价
可以忽略不计因为我们并不是对阵列边界以内遇到的
循环中的每次迭代都进行检查
我们只在进入阵列时进行一次检查
所以这是一个非常强大的优化
它使得数字代码运行得更快
好吧 这是一个优化的一个例子
而我们有很多优化
我们知道这些优化起到了作用
而且非常有效因为我们正在跟踪数以百计的程序
和基准测试程序在过去的一年里
我们注意到这些程序的运行速度显著加快
每次我们添加一个新的优化
每次我们对现有的优化进行改进
我们都会注意到这些程序变得更快
现在大家不会有兴趣逐一了解
这些程序所以我决定介绍其中的五个
现在大家在我身后的屏幕上看到的程序来自多个领域
一个是面向对象的程序
另一个是数字型的 另一个是函数型的
我相信这些程序代表了
如今用户以Swift语言编写的代码类型
正如大家所见在过去的一年
这些程序明显运行得更快
加快了两到八倍之间这非常了不起
现在这些程序在发布模式下进行了优化
但我知道你们也关心未优化的
程序的性能因为你们花费大量的时间
编写代码进行调试并将其在模拟器运行
所以你们关心未优化程序的性能
所以这五个项目是相同的均处在调试模式
他们都未经优化
所以你们可能会问自己 等等
对优化器的改进是如何提高未优化代码的性能的
对吧 我们做了两件事使未优化的代码运行得更快
首先 我们改进了Swift的运行时组件
运行时组件负责分配内存
访问元数据以及类似这样的事情
所以我们对它进行了优化
我们做的第二件事是现在我们能够
更好地优化Swift标准库
标准库是含有阵列实现代码词典和设置的组件
所以通过更好地优化标准库
我们能够提升未优化程序的性能
我们知道在过去的一年经过优化
和未经优化的程序的性能都显著增强
但是为了了解全部的情况我想给大家做一个
Swift与Objective-C语言的比较
现在在屏幕上你可以看到两个非常著名的基准测试程序
这是Richards和DeltaBlue
都是以面向对象的风格编写的
根据这两个程序的测试
Swift要比Objective-C快得多
在演讲的这个阶段
我不会告诉你们为什么Swift要比Objective-C快
但是我向诸位保证我们还会回到这张幻灯片
而且我们将谈到为什么Swift更快
好 现在我要讲些不一样的东西
我想谈谈一个新的编译器优化模式
叫做“模块整体优化” 
它可以让你的程序运行速度明显加快
但在那之前我想谈谈Xcode编译文件的方式
Xcode是单独编译每个文件的
这是一个很好的理念
因为它可以在计算机的多个核心中并行编译很多文件
这样很好
它也可以重新编译需要更新的只读文件
所以很好
但问题是这种优化器的处理范围仅限于一个文件
有了模块整体优化模式编译器能够
一次优化整个模块这样的优势很明显
因为它可以分析所有数据
并进行积极的优化
现在 构建整体优化模式需要更长的时间
但生成的二进制代码通常运行得更快
在Swift 2中我们对模块整体优化模式
进行了两个主要的改进
首先们添加了新的依靠模块整体
优化模式的优化
所以你们的程序有可能运行得更快
第二我们能够实现编译管道某些部分并行
所以在模块整体优化模式中的编译组件应该使用更短的时间
在我身后的屏幕上你可以看到两个程序
它们在模块整体优化模式下运行得更快
因为编译器能够做出更好的决策
它能分析整个模块的信息并据此做出更积极的优化
在Xcode 7中我们对优化级别菜单进行了一些更改
现在模块整体优化是你们可以选择的选项之一
所以我鼓励你们在你们的程序中尝试
模块整体优化模式
说到这一点我想邀请迈克尔上台
给大家讲解Swift代码的底层实现
并给大家一些关于编写高性能Swift代码的建议
谢谢大家
谢谢 那達夫
今天我想跟大家谈谈
Swift编程语言及其性能特征的三个不同方面
对于每个方面我都会给出具体的技术大家可以用它们
来提高你们的app的性能
让我们首先说说引用计数
一般来说编译器可以消除大部分引用计数的负担不需要任何帮助
但是有时候你还是会发现由于引用计数的负担造成的代码减速
今天我将展示两种技术 你们可以利用
它们来减少甚至消除这种负担
让我们首先看看引用计数和类的关系
从而了解引用计数的基础知识
这里有一个代码块
它包含一个C类一个包含一个
可选C的函数和几个变量定义
让我们逐行看看代码执行情况
首先我们从分配C类的新实例开始
并将其分配给变量X
注意在类别实例的顶部有一个包含数字1的框
它代表了类实例的引用计数
当然这是1 因为目前只有一个类实例的引用 即x
然后我们将X分配给变量y
这将创建一个新的类实例的引用
导致我们增加类实例的引用计数给我们一个引用计数 2
然后我们中止了y并打开了foo
但是实际上我们并没有中止y本身
相反我们创建了一个临时的C并把y赋值到C
它可以充当类别实例的第三个引用
这可以导致我们再一次增加类别实例的引用计数
然后当foo退出时C被摧毁导致我们减少类别实例的引用计数
使引用计数为2
最后我们赋值零到y和x
使类别实例的引用计数为零
然后它被收回
注意每次我们做了一个任务
我们必须执行引用计数操作
来保持类别实例的引用计数
这是很重要的因为我们必须一直保持记忆安全
现在对于熟知Objective-C的你们来说
当然没有什么新的情况发生
减量和增量被谨慎的保留
和解除
但是现在我想告诉你
一些也许更独特更新奇的事情
也就是说结构是如何引用计数相互影响的
我要开始了...让我们开始讨论先观察一个不包含引用的类别
这里有一个类别点
当然 它不包含任何引用
但是它有两个特性x和y都是浮点数
如果我存储其中一个点在一个数组中
当然因为它是一个类别所以我不会把它直接存储在数组中
相反我把参照点存储在数组中
所以当我对该数组进行迭代
并初始化循环变量p的时候
我实际上创建了一个到类别实例的新的引用
这意味着我必须执行引用计数的增加
然后,当P在循环变量的最后被摧毁的时候
我必须减少引用计数
在Objective-C中我们必须时常地
做简单的数据结构比如点
一个你可以使用来自Foundation像NSRA数据结构的类别
然后无论你何时操作简单的数据结构
你将会使类别产生负荷
在Swift里我们可以使用结构...
在这种情况下我们可以使用结构解决问题
而不是一个类别
所以让我们把点做成结构
现在我们能够将各个点直接存储到这个数组中
因为Swift数组能够直接存储结构组
更重要的是因为一个结构本身不需要引用计数 而且这个结构的属性
也不需要引用计数
所以我们可以直接舍弃之前所有引用的计数在循环中
现在让我们思考一个更加复杂的例子
假设一个结构中包含一个引用的参数
虽然一个结构其本身在任务中并不需要引用计数变量
就像我之前提到的但是它确实需要这种变量
如果一个结构中包含了一个引用参数
这是因为分配一个结构
和独立分配每一个属性是等价的
所以考虑到我们之前看到的关于结构的点
它能够很有效的被复制当我们分配它的时候就没有引用的计数
假设有一天我在我的app上工作
我决定... 好吧我想要使每一个点
都能被画成不同的颜色
所以我在我的结构中添加了一个UI颜色属性
当然 Ui颜色是一个类这实际上是在我的结构中添加了一个参数
现在这就意味着在任何时刻我要分配这个结构
和独立分配这个结构中的UI颜色
都是等价的这就意味着我必须执行一个对计数参数的修改
现在虽然使用一个包含计数参数的结构的代价并不高
我的意思是 我们通常使用类并且类也有相同的特性
现在我想给你们展示一个更加极端的例子
即一个包含很多计数字段参数的结构
这里我有一个结构用户我将使用它来模拟用户在一个我写的app中
并且每个用户都有一些跟它相关联的数据 即
三个字符串 一个作为用户的名字
一个作为用户的姓氏
一个作为用户的地址
我也有一个空间来存储数组和一个字典
来存储与用户相关的特定的app数据
即使这些所有的参数都是数值类型的
在其内部 包含一个类
这个类用来管理内部数据的生命周期
这就意味着每次我分配这些结构中的一个参数
每次我都要将这个参数推送到一个函数中
事实上我不得不进行五次计数参数的修改工作
好 我们可以使用包装函式类来操作
这里我再次使用用户结构
但是这次不是只依靠它自己
它包含在一个包装函式类中
我还可以使用类引用来操作这个结构
更重要的是如果我把这个引用当作一个函数
或我声明-或我签名-
用这个引用来初始化一个变量
我只是在做一个引用计数增量
现在 重要的是要注意到
这里语义有了变化
我们已经从使用真值语义
改变为引用语义
这样就会导致意想不到的数据共享可能会导致
不可思议的结果或你没想到的事情
但是有一种方式
你可以具有真值语义并且从这个最优化中受益
如果你想了解更多
请进入用值类型来构建更好的应用程序的讲座
在Swift明天的任务中
在下午2:30它将是一场精彩的讲座
我真的建议你去
现在我们已经谈论了引用计数
我想继续讨论有关通用型的内容
这里我有一个通用函数min
它是通过类型T的通用性 符合Swift标准库的比较协议
从源程序的角度来看
这看起来不那么大我的意思是它只有三行
但是实际上 幕后要比想的多的多
例如这里实际发出的代码
这里我还是使用伪-Swift来代表编译器发出的代码
编译器发出的代码不是这三行 而是这
首先要注意编译器在使用间接法来比较X和Y
这是因为我们可以输入两个整数
到min函数或者我们可以输入两个浮点数
或是两个字符串或我们可以输入任何可比较类型
这样编译器在所有的情况下都是正确的
并且能够处理它们中的任何一个
另外因为编译器不知道
是否T要求引用计数更改
它必须插入另外的间接法
这样min T函数就能处理两种类型T
要求引用计数和不要求引用计数的类型T
例如 对于整数而言Swift运行时内仅未进行上行调用
在这两种情况下编译器都处于保守模式
因为在这种模式下编译器须能处理任一T类系统数据
幸运的是编译器优化能够帮助我们消除重载
编译器优化也称为泛型特殊化
本文中的函数foo将两个整数传递给泛型函数min-T
执行泛型特殊化时
编译器首先调用了函数min和foo
并且发现两个整数被传递给了本文中的泛型函数min-T
编译器可以查看
泛型函数min-T的定义因此其能够克隆函数min-T
并且将克隆的函数进行特殊化处理
方法是将泛型类型T替换为特殊化类型Int
随后针对函数Int优化特殊函数
并消除与这个函数相关的所有重载
因此这样会删除所有引用计数即不必要的引用计数调用
并且我们可以直接对这两个整数进行比较
最后 编译器将泛型函数min-T的调用替换为
特殊函数min Int的调用
以便进行进一步的优化
泛型特殊化是一个非常强大的优化方法
但其也有一个不足之处 即泛型定义的可见性
这类例子包括本文中函数min-T的泛型定义
这里我们对包含两个整数的泛型函数min-T进行计算
在这种情况下我们可以执行泛型特殊化吗？
即使由于我们分别对文件1.Swift和文件2.Swift
进行编译编译器可以看到两个整数被传递给了
泛型函数min-T
但当编译器编译文件1时
文件2中函数的定义
对编译器来说不可见
因此当编译文件1时
编译器不能查看泛型函数min-T的定义
因此我们必须调用泛型函数min-T
但是如果我们启用了全模块优化情况会是怎样的呢？
如果我们启用了全模块优化
就会同时对文件1.Swift和文件2.Swift进行编译
这意味着当同时编译文件1或文件2时
文件1和文件2中的定义都是可见的
所以基本上这就意味着即使min-T泛型函数在文件2中
我们编译文件1的时候可以看到它
因此我们能够将min-T泛型函数具体化为Min int
并用min int替换调用min-T的命令
这是能较为明显地体现出模块优选的整体作用的第二个案例
这个案例中编译器能进行类属指明的唯一
原因是启动整个模块优化时
编译器能得到附加信息
既然已经讲过了泛型那我想再讲讲
动态调度技术以作总结
这里我有一个宠物类的类层次结构
可以注意到宠物类具有方法噪声 属类型
以及一个方法噪声处理法用以处理方法噪声
还可以注意到宠物类的一个子类狗类可以覆盖噪声
现在再考虑产生噪声的函数
这是一个很简单的函数
它带有一个参数p这是宠物类的一个特征
即使这个大括号里牵涉的信源不多
但后台的运行却比我们想象得要多
比如下面的Swift伪码并不是编译器发出的
名称和噪声不是直接被调用的
而是通过编译器发出代码
注意此处调用
名称getter方法和方法噪声的间接性
编译器必须插入这一间接性
因为它不知道在当前的类层次结构下
属类名和方法噪声是否应该被子类覆盖
这一案例中的编译器只会发出--
如果能够证明没有名称或者噪声的子类的覆盖的话
只会发出直接调用命令
在噪声的案例中这恰恰就是我们想要的
我们想要噪声能够被这个应用程序编程接口中的子类覆盖
我们想形成这种效果就是在一个宠物类的案例中真的
有子类狗类的话如果我调用噪声这只狗会叫
而在一个真正的宠物类的案例中
如果我调用噪声我们会听到猫叫
这完全是合理的
但在名称的案例中这实际上是不合需要的
这是因为在这个应用程序编程接口中
名称不是...永远不是被覆盖的
对名称进行覆盖是不必要的
我们可以通过约束这个应用程序编程接口的类层次结构来建立模型
我今天要向你们介绍
可以用来约束你们的API类层次结构的两种Swift 语言特征
其一是对继承的约束
其二是通过存取控制约束存取
让我们先谈谈继承约束也就是最后一个关键词
当某API包含的一项声明上
有最后一个关键词时
该API即传递着一个信息该声明在任何时候都不会被子类覆写
举一个声音制作的例子
默认情况下编译程序一定会采用间接法
调用getter 以给出名称
因为如果没有更多信息则无法知道
名称是否被子类覆写
但是我们知道在该API中名称在任何时候都不会被覆写
我们也知道在该API中
并不是要名称能够被覆写
那么我们就可以通过对名称附上最后一个关键词
对此进行执行和传达
之后编译程序会看名称并意识到 哦
这个在任何时候都不会被子类覆写
而动态分配即间接法可被删除
既然我们已经讲了继承约束
我就要稍微介绍一下存取控制
该API中证明pet和dog均在单独的文件中
即在pet.Swift和dog.Swift中但是属于相同的模块 即模块A
除此之外还有一个叫做Cat的pet子类
它属于另一个模块但是在文件cat.Swift中
我要问的问题是
编译程序能够向noiseimpl发出直接调用指令吗？
默认情况下不能
这是因为在默认情况下编译程序必须假定
该API是要noiseimpl
在Cat 和Dog这样的子类中被覆写
但是我们知道事实上并非如此
我们知道noiseimpl是pet.Swift私有实现详细信息
在pet.swift以外不应可见
我们可以通过在noiseimpl上附上这个私有关键词
从而实现该目的
一旦我们在noiseimpl上附上这个私有关键词
noiseimpl在pet.Swift以外不再可见
这意味着编译程序可立即知道
在cat或者dog中不会出现任何覆写情况
因为它们均不在pet.Swift中
并且在pet.Swift中只有一个执行noiseimpl的分类即Pet
此时编译程序可向noiseimpl发出直接调用的指令
我们已经讨论过private
下面来讨论全模块优化与访问控制间的交互作用
Pet类我们已谈论很多接下来我们将谈论dog子类
谨记Dog类是Pet类的子类
它包含内部访问但不含公共访问
如果我们调用Dog类中的noise函数
没有更多信息编译器必须间接嵌入
因为编译器不知道模A不同文档中是否存在Dog子类
当全模块优化生效时
编译器了获得了模宽的可视度
可以看到模型中所有文档
当然编译器也能看到dog类没有子类
因此编译器可以直接调用
Dog类实例中的noise函数
需要特别关注的是你必须开启全模型优化模式
却不用改变任何代码
通过给编译器提供更多的信息
使编译器理解类层次体系
更多的信息实现了免费优化
却不增加我的工作量
现在让我们回顾那達夫之前介绍的图表
在面向对象基准测试中
为什么Swift比Objective-C快很多？
为什么Objective-C中
的编译器不能通过Ob-C信息发送消除动态分配
不能通过它进行内联 不能进行分析
编译器必须假设
Ob-C另一侧存在信息发送
但在Swift中 编译器有更多信息
它可以看到另一侧的确定信息
能够消除大量实例中的动态分配
这类实例中
显著快速的代码
带来更多运行结果
因此请使用final关键字
与API's intent进行通讯
这有助于编译器理解你的类层次体系
并实现额外优化
但是应谨记根据变化情况
对现有客户进行更新
并在已发布版本中试用全模型优化
这一工具可以优化编译器性能
比如让它变得更加强劲和专业化
通过让编译器能更好得理解你的应用程序接口中的类继承体系
你不需要做什么
就可以体会到更及时的动态内存清空的好处
现在有请乔来做介绍
他将为你们展示该如何使用这些技术和工具
来让你们的应用程序
获得更好的性能体验
谢谢你 迈克尔
我叫乔是这个工具团队里的一名工程师
今天我将要给你们演示这一工具通过一个运行起来有些慢的程序
来 让我们开始吧
好 现在我们的快速应用程序正在缓缓得启动
我要做的就是接着继续点击运行按钮
在其下拉列表中选择Profile
这会使我们的应用在发布模式下运行
然后再以模板选择器的形式启动工具
以便于我们可以好好的描述一下它
鉴于它还在缓缓运行让我们从时间分析模板开始
在工具界面中只需点击 录制
当你的应用开始启动本工具会自动在后台开始录制记录它的动作
在这里可以看到我们所运行的程序在我做任何目标操作之前
它正以60帧每秒的速率运行
一旦我把这些粒子加入屏幕中
它们四处扩散 彼此躲避
正如我想要的那样这时我们的程序运行速度
变成了每秒38帧
我们失去了接近三分之一的效率
现在我们正视这一问题
退出原来的应用 回到本工具中
让我们来放大一下以便看清发生了什么
只需要拖动这个 向这边拖动
就可以非常便捷得进入视图快速跟踪模式把你的数据加入水平时间轨
然后呢？
在跟踪视图中可以看到我们这个应用的CPU使用情况
在我做任何操作之前我们看左边CPU使用率非常低
当我加入这些粒子CPU变得很高
你们可以看到通过移动你的鼠标
并停悬在这个ruler视图以内这些取值是什么
你们可以看到我们先是大约10%左右没有做更多
随后大约100%所以我们的CPU达到饱和
为了提升我们的性能
我们需要将目前的工作量减少多少
那么我们正在做哪些工作？
下面的该详细信息面板由此进入
所以这是我们所有的线程
继续将此再开启一点
你们可能从调试程序中的Xcode内侧看到起就熟悉这个调用栈
Start、calls main、calls NSapplication main等等
但是Instruments要告诉你们的是你在该功能内
包括其子功能内 要花费多少时间
即第一栏的Running Time
我们可以看到有11,220毫秒或者说我们99%的时间
花在了NSApplicationMain或者其调用的程序上
第二栏 即Self是从功能本身取instrument的时间
因此不包括其子功能
所以我要做的是看看self数在哪里变大
即该功能实际在哪里进行大量工作
你可以继续逐一开启 搜寻
但是需要花点时间
我们倒是建议你由此向右
这样放大了详细信息视图
而Instruments将在你的应用程序中显示最重的那一个堆栈踪迹
在这里所取次数最多
在此你可以再次看到我们的主线程用了11,229毫秒
从Start开始灰色符号为系统框架
黑色符号如Main是你的代码
我要做的只是向下看这个列表
看它是否有大一些的跳跃即大约此时有我们感兴趣的事情发生
如果我向下扫过该列表数字慢慢变小
但是在我到这里看到从大约9000到大约4000的跳跃之前
没有出现大的跳跃
那么那里有事情发生我打算继续进行点击我的代码
而Instruments已经自动扩展了左侧调用树
这样你就能看到你刚刚点击了什么
让我将此框起来
这里在发生什么？
好,让我往回来一点
这是NSFiretimer调用驱动我的仿真速率是60帧/s
这是我的粒子Sim.app代理更新程序
驱动仿真的Swift程序
在它们之间是个古怪的类似objc的东西
这只是个thunk本质上,它是嵌入式函数的解释器
可以使我的代码在SWIFT
的NSFiretime中进入Objective-C
这就是它的作用 另外我们可以忽略它
现在我们看到更新程序占有89%系统时间
所以我们需要继续优化这个程序
其它东西我不关心
接下来我将会把它隐藏起来专注于这个更新程序
通过点击右边的这个箭头
你看 这个周围的东西都隐藏了
运行时间已重置为100%
只是帮你做些心理数学
仔细看看这个函数做了哪些工作
更新Phase Avoid调用找到最近的邻居
这里进入到非常有意思的部分了
看Swift release占用40%系统时间
Swift retain占用35%系统时间
只是这两个函数 我们就占用了3/4的系统时间
仅仅是个管理引用计数的更新程序
差的远
接下来干啥？
恩 如果我双击寻找最近的邻居程序
这调用了那些retains和release
Instruments将显示源代码
然而Swift是自动引用计数语言
所以你不会直接看到这些release和retain
但你能如果你翻到反编译视图
点击按钮
Instruments将会显示编译器实际产生的代码
你可以在这找找这里有很多的调用
这个release占用了23%时间
这里有更多的retain和release
这是另一个release
它们到处都是对于这我们该怎么做？
让我们回到代码找到粒子文件
这是类粒子
所以它是一个默认的内部类
它符合协作协议
好的
下面是...这是寻找最近的邻居程序之前它会占用所有的时间
现在我知道当更新时间器启动时
代码会在屏幕上每一个粒子上去调用寻找最近的邻居程序
那么这个内部循环开始
遍历屏幕上的每一个粒子
这里我们有一个N2算法
循环的工作是产生非常巨量的时间值
我们所做的优化工作将有很大作用
看，发生了什么？
在我们访问这些粒子时
我们有循环了有一些retain和release的开销
这是正在调用的属性getter这个.ID属性
前面迈克尔说过的
既然这是一个内部类
这里应该有一些
跨越这些属性getter的Swift文件
我们执行这些属性getter
的动态调度这些属性getter都有retain/release开销
接下来是一个求距离平方的函数调用
事实上它有十几个源代码行
我们再一次去做动态调用程序
所有的开销和retain release开销都一样
对这个代码我们能做点什么
恩 这是个完整代码
这是我写的 我完了
我的粒子类是完整的 不需要子类
我应该通过把这个类标记为final
把我的意图告诉编译器
就是这么一点改变让我们继续 再次配置应用 看看
现在编译器能够编译这个文件了
也知道这个粒子文件
没有其它的子类了 抱歉
这意味着它能够进行其它的优化了
可以直接调用这些函数
甚至让它们内部联结或者其它的优化
这可以减少我们之前的开销
打开记录 这次加载这些粒子
看看这次它们以60帧/s的速度运行
让我们回到优化前的每秒20帧
不错
然而你可能会猜到
第二节是冲突当我们换一个算法
现在它们相互冲突了
帧速率下降了25%回到了45帧/s
我们再次面临性能问题回到Instruments
看看 发生了什么
我们将把之前做的再做一遍把这个放大一点
点击Snap Track to Fit现在怎么样？
看左边 这是回避阶段
变好了 提升了大约30%到40%
这是我们每秒60帧的原因
看右边这是冲突阶段
现在这会占有100%的CPU性能
帧速率又下来了
再做一次刚才做的事调用数据树
仔细看看这个窗口中有
回避阶段的数据运行良好
也有冲突数据这是需要我真正去关注解决的
回避阶段的样本会平滑我们的结果
所以我将设置一个时间过滤器让我能只看冲突阶段
很简单
只需要在时间线中点击和拖拽就行
现在我们的细节窗格更新了
只显示我们的冲突阶段了
现在我们再做一次
从头回到我们的扩展细节视图
向下看这个列表看有跳跃的地方
有趣的事情发生了从8000毫秒
到2000毫秒
所以我去点这里的冲突检测类
Instruments再次自动展开了调用树
让我们看看这里发生了什么
88%的时间花在了这里的运行时间步进程序很好的挖掘点
再来一次 点右边这个关注箭头
现在我们只看运行时间步进程序
看看它在做什么
好 25%的时间用在了
Swift.array.underscore返回元素节点这个项目上
当你看这个三角括号里的A时
意味之你正在调用函数的通用格式和所有需要的开销
你会再次在Swift数组的三角括号里的A这个位置看到
这是个有效的子脚本
当你把三角括号换成方括号也是一样的
所以我们正在调用的是通用属性getter
在这三个通用函数之间
我们看到大约50%的时间用在了这三个通用函数
我们怎么做才能消除这些开销呢
好 回到Xcode
这是我的冲突检测文件
这是冲突协议我的粒子会服从这些协议
这是通用类 类检测
T类型会符合一个冲突协议
它做的是它的冲突数组这是通用的T类型
下面的是我们的运行时间步进程序
这是我们开销的地方
这个函数做了什么
恩 它遍历了我们所有的冲突从一个数组访问了一个冲突
调用了大量的属性getter
这里更多
这是个内部循环调用像前面我们做的一样
我们把另一个冲突从数组中拉出来
然后是所有的属性getter
我们做了很多的通用操作我们应该把这些都干掉我们怎么做呢？
这次你可以看我的冲突检测类就在Swift文件里
然而这个用户在用这个类的App代理
程序中这个Swift文件的粒子它在这个模型的另一部分
我们要转到 Whole Module Optimization
很简单点工程
在build设置参数中
确定是所有的在build设置参数找到优化
这是优化参数那達夫之前演示过的
你只要把你的release生成参数切换到全模型优化
现在当我们配置的时候
编译器正在查看所有的文件创建一个更优的二进制文件
但是让我们看看会发生什么
我们将第三次运行时间分析器
开始记录 60帧/s
添加粒子冲突的阶段仍在运行以60帧/s的速率
好 我希望这没什么变化一直很好
然后我们转到冲突阶段
现在它仍运行在60帧/s
所有的配置只需几分钟
和一些小的调整
我们让程序变得快多了
好的 归纳一下我们今天看到的
我们知道Swift是一种灵活的编程语言
使用安全的自动引用计数完成内存管理
这些强大的功能让人
愉悦的编写代码虽然这带来一些额外i的开销
我们想做的是让你专注于你的APIs和代码
当你在编写它们时保持高效思维
你怎么确定额外开销呢
在Instruments分析你的应用程序
在开发代码的全生命周期里
当你发现问题时都需要这样做
你会更快更准更容易的定位问题的原因
尤其是你的APIs发生变化时
有些在线文档当然你可以去Developer Forums
得到Swift问题的答案和解决方案
说到解决方案今天3:30在Mission有一个深度案例分析
专门讨论时间分析器比我们今天讲的更深入
像之前迈克尔提到过的使用Swift的数值类型可以建立更好的应用
如你今天所看到的谢谢你们