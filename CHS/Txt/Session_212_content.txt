大家好
我的名字是布蕾特妮·佩因
接下来你们将和乔恩·德拉蒙德见面
我们是SpringBoard团队的工程师
今天我们主要想和你们聊聊怎么调整你的app 
以运用iPad和iOS 9上多任务处理功能
这是多任务处理系列中的第三个讲座
很可惜前面两个已经结束了
如果你们还没来得及收看的话 应该去看一下
那么我今天有很多话要说乔恩也是
我们会讲得很快
请注意听
所以这就是你的app
在iOS 8中你的app 支配了你的整台仪器
它可以尽量使用仪器上所应许的系统资源分量
但在iOS 9中多任务处理已经不再像往常一样了
它可以也可能在同一个屏幕里出现更多的app
而在所有屏幕上的app现在必须共享同一个系统资源
像是CPU GPU DISKI/O之类的一些系统资源
随着多个程序互相争夺CPU的容量而退化
让我们以CPU为例子
现在这个是为了我们讲座上的新开发者们
app响应性的Holy Grail在于能够将你的UI更新于
每秒显示帧数为60帧或者60帧率
这意味着你只需大概16毫秒
来完成你所有需要的工作并对用户作出反应
所以如果这是你的app
比如说它在60 帧率上渲染得很好
它可以在仅仅十秒内将所有工作完成
这其中的每一帧代表一毫秒
之后 用户将增加另一个附带的app
-这个app同样在60帧率上更新得很好
而且它在6毫秒内完成所有的工作
两个app结合在一起像你看到的 已经用了
我们所拥有的全部16毫秒
以能够在60帧率上渲染
此时用户打开一个PIP
而这个PiP也同样运行得很好
之后他需要八毫秒来渲染他的UI
这三个apps结合在一起
在屏幕上24毫秒 而这意味着
渲染过程其实是大概在40FIPS而不是
我们想要的60 FIPS
用户会意识到卡顿
同样的问题也适用于GPU
但一些系统资源比如内存会产生
一个更加不好的用户体验
当很多程序一起争取它的容量时
我们再来看一下这个例子
还是这个app
这个iPad下的系统内存占用
你可以看到在最左边 我们的系统正在使用用一些档案储存
在中间这是你的app蓝色的app
也在使用一些档案储存
然后这些剩余空间
这里有很多使用空间
你可以做各种各样的事情
之后 用户增加了一个二级app
而这个附带app也需要内存
但我们状态依然很好
我们还有一点点剩余储存空间
然后猜猜接下来会发生什么
PiP出现了
现在我们没有记忆体了
当系统无法找到空间记忆体时
它必须停止一个app运行
在这种情况下用户被活生生地从他/她 
可以说是她的当前处境中拉出来
然后我们又把它带回到SpringBoard
在我看来这是一个更糟糕的用户体验
相比之下和当多个程序为CPU或者GPU竞争UI将停顿
所以你现在可能在问自己SpringBoard是什么
以及为什么SpringBoard工程师今天会在这里和你谈多任务处理
其实SpringBoard代表很多东西
它是主屏幕
锁屏
图标 壁纸 姿态系统 通知中心
控制中心
我有点儿混乱了
好吧 除此之外还有更多
但是最重要的一点如同所有人我们是一个UI应用程序
SpringBoard最初是多任务处理app
在iOS 9和iOS 9之前
SpringBoard 一直被认为在前台操作
即使你的app可能被用户看到
因此 我们面对和你们一样关于新多任务处理环境中的挑战
应此我们一路走来学到了很多
我们想和你们分享其中一些学到的内容这样你们就不会犯同样的错误
我们开始吧
最简单的第一部分是优化你的app
第一件事用泄露工序找到并修复电脑的内存泄露问题
你们当中有多少人忘记写DIALEK了
应该有更多的人举手
好吧 我忘了
发生在我们大多数人身上
而泄露工具可以帮助你找到这些问题
然而它们通常很容易被修复
但防止内存泄露问题的最好方式是用Swift
你们应该用那个
最后 你应该用定位工具来寻找
并修复保留周期和无限内存增长
最后 你应该用实时分析工具来寻找
和修复低效的电脑算法
我不会在今天讨论这些问题
这些问题都会发生在所有的apps不仅是
多任务处理的apps而已
反之 我们会注重于
新的多任务处理环境中最重要的事情
在我们的经验里我们学到最深的一课是
良好的表现需要权衡
你是打算预期计算你的数据然后存在记忆体里
还是打算联机计算并使用CPU
你是打算把所有资源都存在本地的磁盘里
还是把它们存在cloud里然后想用的时候随时都可以取得
你想要在CPU还是GPU上运行动画
我们来看一个关于我们之前做过的一个
叫IconReel样本app的例子
所以这是我们app最开始的状态
它最初有很多图标
当用户点击某图标时 我们将图标放大
来呈现一个更详细的视图
底部有一个dock栏
用户可以在这里保存他们 喜欢的图标
当一个用户添加更多的图标时我们会添加更多的页面
这时用户可以页面之间滑动
有人觉得这个很眼熟吗
是的 是故意的
所以 我们可以保留所有的图标
内存中是因为每个图标仅为约60KB
我们会将它们全部存在一个扩展里面
结果就是滑动很棒
为什么呢 因为我们没有其它可以滑动的屏幕
所以我们部分用户喜欢添加更多的图标
所以我们向记忆体中添加更多的图标
目前为止滑动还是可以的
那么 这个动画可能看起来眼熟
那是因为有很多apps 
有像这样的一个动画
想一下在一个照片或开发视频app中的照片滑动
你的app里也许有一个类似的动画
一切都很好
一些我们很好的用户甚至下载了
更多图标
我们现在的扩展里有更多的图标
且结果是滑动依然很完美
也就是说 直到我们在某时看到IconReel死机
以及在一个多任务处理环境下我们有时能看到彼此的
前台apps死机
我们来看一看这里发生了什么
我们用一个实时分析器追踪看到CPU
和磁盘I/O在滑动时最小化了
但定位工具告诉我们我们的记忆体使用
其实是非常高的因为我们所有图标都在记忆体里
这里的情况是IconReel在快速地消耗可用的系统记忆体
而当系统内存短缺时
它试图释放一些空间
如果它找不到任何空间那么它必须终止程序
有时这意味会终止IconReel
而有的时候这意味着终止其它前台app
但上述所有的情况都是一个非常糟糕的用户体验
我们想避免这个情况
作为一个良好的多任务管理公民IconReel需要
管理好它的记忆体使用这样的话所有
屏幕上的apps可以共存并创造很好的用户体验
这也是我们用户所期望的
这就将我们带到了工作集的概念上来
你可以做的最重要的一件
优化你记忆体使用的事就是理解
并管理你的工作集
你的工作集应该只由重要的东西
和你的app目前所需资源组成
你应该让它保持小一些
来确保你的低记忆体使用
它有可能会根据环境变化
比如 你的工作集可能包含不同对象
当一个在前台的app
和一个在后台的app相比它可以改变
当你改变视图控制器时
最后 你不应该让其无限增长
我们看过当系统没有记忆体时候的情况
我们不想你成为那个app
让我们看一下IconReel的工作集
在最后一个例子的尾端
IconReel的工作集就是我们在记忆体中保留的那个图标
这是最好的工作集吗
不是
那么我们现在真正需要做什么
现在我们真正需要的是用户正在看的图标屏幕
所以这是一个更优秀的工作集
那么现在我们来试一下滑动我们
只有一页图标的工作集
噢 噢 好吧
这太糟了
而且如果你因为我站着挡住了你没有看到
那个滑动十分糟糕
有一个多秒的停留在
滑到下一页看到图标时
我们来看看发生了什么
我们用另外一个实时分析器
然后我们看到CPU而磁盘I/O 事实上在滑动中非常高
而分配显示我们的记忆体使用非常低
这个恰恰是我们刚刚发生相反的问题
就像我说的良好的运行包括进行一系列的权衡
我们如何能修复这个
答案是更好的管理我们CPU的时间
所以你能做的最重要的事
就是能够让你的app反应做的工作
在你的主流程上越少越好
主流程最优先的事情就是对用户时间做出反应
在你的主流程上做不必要的工作意味着
主流程有更少的时间来响应用户事件
因为你在分享CPU时间给所有的apps
在屏幕上你需要特别谨慎
应对你的主线程在干什么
所有在主线程上进行的没有直接
响应用户事件的工作应在别的地方进行
什么工序是我们可以用来保证我们不断地响应
用户时间但同时确保我们可以
及时地做其它工作
那么答案就是我们可以用GCD和服务质量
在WWDC2014时有一个很棒的演讲
而在来临的周五会有一个关于GC和服务质量很棒的演讲
所以我不会在这里细说
它们是非常重要的两个东西
第一件事是你的主流程正在
最高优先地运作而那个就是用户交互优先权
另外一件事是
服务质量的频率在
所有前台应用中分享
这样每个人的用户发起的队列将有相同的机会接触到CPU 
而每个前台队列也有相同的机会接触CPU
没有一个前台的app比另外的跟有优先权
如果你能适度的优先你系统的工作
那么系统就可以保证我们能够
在屏幕上有多重apps操作时得到最佳运作
所以这个和IconReel有何关系
我们会在一个不同的流程上使用GCD加载图标
在用户发起的服务质量上
我们要做的第一件事 建立调度队列
这个叫做图标生成队列
当我们在主流程时我们会异步调度
在我们的图标队列中生成在下一个界面生成每个图标队列
虽然在代码片段中并不明显
但是从主流程中异步调度工作到一个
像这样给质量服务降级的队列
到第二高的服务质量的用户发起服务质量中去
所以这个代码能够有效地在用户发起服务质量中加载所有图标
好 现在让我们再试着滑动一下 
好的 这好多了
如果你的设计行得通
这样你和你apps就能使用这个方案
比如说你可以一边展示你的占位图片
一边等待真正的内容加载出来
但IconReel的设计不允许这样
我们必须有已经加载好的图标在它已经在屏幕上滑动之前
所以我们真正需要的是找到一个方式
来暂时促进图标生成队列
在主流程中达到同样优先权
就在界面滑动图标之前
这样它可以更快地完成图标生成
还有另一种方法是
使用服务质量覆盖
当我们有这一类型的倒置时例如有个高优先权流程或队列被阻碍而
等待一个低优先权流程或列队来完成一些工作这个会非常好用
而最酷的部分是
如果你给系统提供足够的信息
服务质量覆盖便可以自动生成
你可能在想 布蕾特妮我怎样才能给系统
提供足够的信息
这里有一个好用的表格
再说一遍 去年的演讲和
这周五的演讲会更深入地讲解这个
但今天讲的是调度组等和
调度信号等不会是你们要的东西
你应该为了这些功能的使用审计你的代码
然后意识到他们不会
在优先倒置中修复这些类型
那么让我们看一下我们在IconReel上会怎么做
当在屏幕上图标滑动的 第一行之前
在主流程上我们会
同步调度这个空阻塞到我们的图标队列中区
我们需要做的是增强图标队列的优先权
来和主流程的优先权匹配
直到阻塞被执行
在图标队列的点
会回到其正常优先权
现在我们来看一下滑动以及它们是什么样的
对 很好 一个很好的慢滑
我们现在来试一下慢滑之后快滑
我的天 我们又回到最初的状况了
就是当到了下一页的时候
在屏幕上有一个停顿
现在怎么办
这里有一个规律
将工具再次拿出来我们拿出另外一个追踪
这次我们还有一个计算器
而且我们要做一点儿计算然后我们要找到我们不能加载
读取图标图片从磁盘中 解码图标图片
然后让图标变得好看且有时间
让一个快速地用户滑动到下一页
现在做什么
我想我们应该等更快的设备了
一些掌声是给它们的
开个玩笑
我们可以做得更好
我们必须更聪明
数学计算告诉我们可以达到更好
的运行如果我们让
下一页的图标已经在记忆体中运行
这个确保及时当你
在多重页面中快速滑动我们有足够的时间
让用户可以再次滑动之前加载下一页的图标
现在我们来增加我们的工作集从第一页
到第三页 你们现在所看到的
页面不是前一页也不是后一页
而我们没有一个神奇的八球
来知道用户会滑向哪一页
所以拥有前后两页会是最佳的选项
现在让我们试着滑动
很好 这看起来好多了
当用户到达下一页时
我们已经在加载下一页的图标了
但是 这其实增加了我们的记忆体使用
当我们有仅仅一页的工作集时
我们有记忆体占用
现在我们有了这个记忆体的占用
我们应该清楚这将会如何影响其它apps
现在来看当用户用IconReel在屏幕上打开某二级app时会发生什么
IconReel调整了大小只展示了三行而不是四行
这是个重新评估我们的工作集的好机会
我们依然需要同时有三页的四行图标在内存中吗
不我们仅仅需要同时有三页三行的内存
高效到它看起来有点儿像这样
现在我会手动
删除这些多余的图标行
就是我们不需要用的 但是
需要很多工作来生成它们
如果不是特别需要 我不想重新做
如果有一个地方
让我我能够摆放这些图标那该多好
如果系统需要内存 我们可以丢掉它们
如果系统不需要内存 那么它们可以留在内存中
然后我们可以再次使用它们当我们需要它们的时候
有一种方法
就是读取内存发出的警告
当系统低于内存限制时会出现内存发出的警告
说你的程序正在达到它的内存限度
我非常想给你一个数字这样你可以选择你的内存限度代码
不幸的是 没有这样一个数字
对于每台设备和每个应用上下文的限制是不同的
所以我能给出的最好建议就是
读取系统发出的警告然后采取行动
所以你应该做什么
你应该把不在工作集的东西清理出来
这包括清理缓存数据释放图片
和释放视图控制器
这是你可以用来读取内存警告的APIs
然后我想说明一点
这些都不是第一次在iOS 9中出现
它们存在一段时间了
希望你们都已经使用它们了
现在我可以检查一个内存警告
然后手动去除那些图标
我很懒而且我不想那么做
如果有一个工具可帮我管理那些玩意儿
让我不用去做就太好了
而我们也有一个这样的工具它叫做NSCache
它和NSDictionary很像
但它对于可以被快速重塑的对象来说很好
它还帮你处理内存发出的警告
自动清理东西然后它
也知道应用上下文比如前台和后台
然后在必要的时候清理东西
它还能做很多很酷的东西但我们今天没有时间展开讨论
不要忘了看NSCache上的资料
现在在拆分视图上我们可以看到IconReel
这次不把这些图标删除
我们把它们放到一个NSCache里面
实施上我们只把我们生成的每个不在工作集中的图标放进NSCache里
而当我们有一个内存发出的警告时
我们可以让NSCache做所有清除那些不在我们工作集的图标
让我们回顾一下
我们从这里开始每个图标都在内存里面
所以我们的内存使用很高 且滑动很流畅而CPU和磁盘I/O很低
但我们有时看到app崩溃
而这并不好
所以我们调整我们的工作集
到只有一页图标中然后内存使用很低
但是我们的CPU和磁盘I/O在滑动时很高
而这会产生很差劲的滑动操作
现在我们将工作集的大小变为三页图标
这会给我们的内存增加一点点
然后每一个我们生成的图标
不在工作集中我们就把它们丢到NSCache里面
我们增加了整体的内存的使用
但是大量增加内存的使用
已经使它能够适应内存的限度
对于你们很多人来说 这已经很好了
如果你的app可以在一个多任务处理的环境下运行
且在地图上交叉运行那么你的状态应该不错
我今天展示了一些你们的app可以做到的事情
来成为一个优秀而多任务处理的公民
但是有些时候只靠这些事情还是不够的
为了和你们聊聊你们接下来可以做什么
我想请出乔恩德拉蒙德
谢谢你布蕾特妮 大家好
看来你们已经掌控如何使用你的app的内存
来极大地帮助你的app和
其余系统的运行
但有些时候只靠这些知识并不足够
如果你已经做了我们说过的所有事情
并且做得很正确 但是情况还是不对
我们将谈谈一些方法
让你们的apps可以更好地管理它们的内存占用
首先 我想回到那个多任务管理的例子
假如我们有一个初级和一个二级app
而现在已经达到内存的极限了
接着系统会发出一个内存警告
身为良好多任务公民apps会管理好
并清理它们的缓存和其它不需要的东西
好的 那么现在用户引进了一个PiP
我们有足够的内存 这样不错
虽然我们还没到达内存的极限但我们已经接近了
现在用户将调整那个二级app
让其达到和初级拥有一对一的比例
因此 这将造成CPU的内存突增
这会使系统不能及时做出反应
很不幸地被逼把
初级的app终止即使它不是
内存增长的正真原因
回归到SpringBoard从来就不是一个好的体验
就像布蕾特妮刚刚展示的那样
在我继续讲或者结束之前
我想跟你们分享一句话
那就是在你程序之外的东西都应该被视为
有敌意并且会毁灭你的可能
我不是故意说不吉利的话
且我也不想让你们觉得我疯了
但身为一个良好的多任务管理公民就应该适应
你身边所有会发生的事情
有时你身边发生的事情会很离谱
你可能觉得一切都操作得很好
但是系统可能在密谋着终结你
事情虽然不是这样 但如果你有所准备
这将会帮助你生存
所以首先
内存是在iOS中最被约束的资源
这不是说其它资源不被约束
它们会被约束 只是它们降级的不同而已
当系统没有内存的时候
它就像在砸一堵墙
有些东西必须离开
它必须将内存拿回来
就像我们之前看到的例子
有时侯系统能够以比释放内存更快的速度还原内存
即使我们有时间发布一个内存警告 
并且三个apps全部都在运行
且都有时间去相应那个警告但我们不能够知道
它们是否有足够的CPU循环
来做一些有意义且
可以清除足够内存来还原内存
为了了解系统是否能够收回内存
我们需要知道内存是如何被分类
我会将其分为三个不同的组别
第一个类别我们把它叫做脏的
这是你的程序使用时活跃的内存
这些是你的对象这些是你的堆式分配
静态 球态和所有你缓存的东西
其实差不多所有的东西
而且这不能被系统召回
因为这是你在用的
第二个类别叫做可清除的
这是除了脏的内存以外被明确标注
不被app使用的
这样系统知道当有需要的时候它可以被召回
第三种我们叫干净的
这是在磁盘上备份的
系统可以召回这些内存
因为它永远可以召回因为文件已经在这儿了
回到我们的系统内存条
这看起来怎么样
我们有一个非常非常小的内存局面
但是系统不这么看
系统知道当它想释放一些内存来增长时它可以有余地使用
而不用发布内存警告
或要求apps来干预
你的app的目标和适应内存的使用
就是最小化你脏的内存
而最大化你的可清除的和干净的内存
我们从最小化脏的开始
首先 对 少用它
我知道我站在这里说的很容易
但如果你管理你的工作集
然后追溯你在定位的对象使用工具
来做所有的事情一旦你做好这些事下一
重新分类脏的内存为可清除的
如果你做了这些它可以被系统自动召回
然后这是可有可无的数据中最好的
你现在不需要的数据也许会在未来需要
所有你可能放到一个缓存里的事情 比如说
我们把这个应用到IconReel上
这个和我们中断的情况相似
我们在工作集的两旁有图标的缓存
另外 只是
对于这个例子 我将再重新把我们的数据分一下类
比起在一个每个-图标块上工作
我会将图标群分成集列
就因为它可以在这儿变得比较轻松
这并不意味着会改变我们app的动态
当用户来回滑动我们更新我们的工作集
有些被缓存了 有些被拉出了缓存
这都是一样的
我们来给这个内存使用分一下类
首先 我们正在使用的内存
应被分类为脏的
这是我们的工作集
我们所有在缓存的对象都是可以清除的
这为我们展示了一个有趣的机会
来让我们跟高级地分类内存
比如说 标记更多在用着的数据
或是脏的甚至有一些是在缓存里的
这介绍了一个另一种缓存的方式
第一个那个最外的图标
是我们最迟使用到的
我们会让系统在它需要的时候重新召回我们不在乎
但是我们想要确保有能力来控制
我们可能马上用到的图标
即使它们依然在缓存中我们会标记它们为被使用中
这样系统就不会随意拿走它们
这些是我们在应对一个内存警告的时可释放的
这就给了我们一个工作集
一个我们现在绝对会需要
但我们却无法为那个工作集做任何东西
这在多任务处理例子中是什么样的
我们回到那个出错的情况
PiP进来了
我们没有内存了
但现在系统知道初级和
二级的app是良好的多任务处理公民
它们有可以清除的内存的能力
这个系统 不用应对任何人
就可以从app中拿走
然后让系统回归到一个好的状态
但当然了 如果用户继续使用设备
内存将会重新增加
我们又收到了一个内存警告
但因为那些apps只失去了可清除的数据
它们可以自由地响应内存警告
然后清除缓存这样还系统一个好的状态
在你的apps中应该怎么用你的可清除数据
这很简单
这里有一个等级是可清除的数据
然后它是一个NS不可变数据的子类别
它没有别的性能它很简单
唯一的分别是这三个方式
第一个就是Begin Content Access
这个告诉系统你正在使用内存
不要把它拿走
第二个方式BeginContent Access
现在内存被认为是可清除的
而你可能随时都会失去它
第三个方式是断定系统是否在你不用的时候把它拿走
回到系统资源条上 这差不多是
布蕾特妮结束的部分
我没有改变任何东西
这些图形差不多一样
不同的是我们抽取了一部分自适应内存
然后重新分类为可清除的
这使得我们成为一个更好的多任务公民
因为系统可以代替我们做工作
但是有相同的本质表现性能
就是如果我失去我的可清除内存
然后我清除了我的缓存 我现在怎么办
我需要重塑所有 我需要的数据
及我曾经建造的但这很昂贵
磁盘I/O和CPU出现尖峰 这样不好
我们分析在app中使用的数据来
看是否我们可以做更多的事情
那么IconReel使用什么数据呢
它们是图标 然后第一个特性就是
它们绝对重要
我们没有图标就没有一个app
某时 用户会滑动到它们
我们需要它们 无法避免
第二个它们生成用到很多内存
从磁盘中读取它们破解它们并润色
你想干什么就干什么这样费用浩大的内存
第三点 其实它们可以被预期计算的
我们将提前知道这些图片会怎样
如果我们有多余的空间我们便可以计算它们
最后一点是它们非常静态
有很大的可能性
如果我提前生成一些东西它会和我想要用它的时候一样
因为它不怎么经常改变
这些所有的观点结合起来
使得这个数据是一个用于文件缓存的最佳选择
在我说别的之前
我想说这个依然是一个缓存即使它是一个文件
不要将这些缓存写到用户的文件夹中
在你的app的缓存文件中保存
或在系统的临时目录中保存
回到我们的系统资源
我们刚介绍了一个新的题目
那就是磁盘空间
我们可以交换一些CPU循环来生成这个数据
保存之后 当我们需要的时候我们再把它拉出来用
我们事实上完全去除了CPU的使用功能
现在你也许已经注意到I/O已经运行了
因为完全渲染的图片会比
那些资源文件大 这没关系
这些都是和权衡有关
这就直接到了被净化最大的内存
你可能会记得我之前说过被一个文件备份的内存
在磁盘上是被视为干净的
那么现在我们在磁盘上有一个文件多巧啊
这样一个文件的数据可以被内存映射
系统会定位一块内存给你
然后直接映射磁盘中文件的位置和内容
这绝对值得注意内存
在文件内容上必须完全一致
你不能内存映射一个需要更多破解文件
或者当它已经加载了的
这对于只读数据来说很理想就像我说的
它不怎么经常改变
这里最酷的地方就是
以可清除的内存
系统可以在当你需要时重新召回一些空闲的内存
但是 它没有消失
当你再次需要它时你再次取数它时
系统从磁盘中再次加载回来
就像它从没消失过一样
而且它有很大的随机存取性能
只因为你的工作集在这而你需要的一块
数据在别处并不重要
系统可以只读那块的部分文件
然后交给你 你就可以工作了
这个看起来是什么样的
我们从内存的数据开始
然后你在磁盘上写出来
系统现在把它当成 内存映射
如果你存取一部分的数据然后它
就会把它加载好 然后交给你
当你不再用它的时候 它就被拿走了
我们如何能将此功能应用到IconReel上
我们从这个工作集开始但是事实上我们是把
我们生成的每个图标去合拼工作集
创建一个大的数据文件然后写到磁盘上
现在回到我们的app中来我们再次拿出我们的工作集 三页
我们访问这三页内存
然后系统只加载文件的那一部分
到内存中然后保持其它部分干净
不管那文件是不是上百MB
它其实并不在内存中
当我们四处滑动时 一样的事情发生了
系统加载了我们需要的数据
加入我们引进一个会显示通知的功能
用于在主界面上的其它图标
我们可以把它们拉出来然后
不用担心它们在哪和它们是什么
虚拟内存系统为我们做了大部分工作
这会如何改变我们的资源条
这里我们已经将CPU中断了
但是我们现在的缓存实际上在磁盘上
那么这个也消失了
然后我们现在唯一内存占用就是工作集
其它地方都被认为是干净的
所以不算是反对我们
且值得注意的是我们有效地消除CPU
对前端和后端的需求对于我们的数据生命循环来说
我们不需要CPU来生成数据来展示给
用户或者我们也不用CPU来清理干净来应对内存警告
系统都为我们做了
你如何能用内存映射数据
在一次 它是一个在NS数据上的简单API
这里有些选择你可以
用来开始数据对象
如果你在初始化器中标注映射选项
你就会得到一个内存映射数据文件
如果我没有提到我会被看做是玩忽职守
用这个系统时有一些警告
第一个就是它不适用于
少量的数据
在页面上自己工作的虚拟内存
也就是少量数据
如果你的甚至更小你会遇到
覆盖在你原有问题上的新问题
还有从内存映射文件中
如果你的内存映射一千个图标文件比如
这其实有一个对于任何系统可以有的打开文件的限制
这样你会惹上麻烦
这是其中一个主要原因
为什么我们将数据集合成大块
使其对于VM系统更加好管理
或者你也可以只是滥用虚拟内存系统
你所创造的每个可清除的数据对象创造
在你虚拟内存中的一个区域
如果你创造了太多那些内存映射文件
你会将你整个空间碎片化
你同样会使其耗尽
如果你决定来内存映射一个10GB内存的文件
那么你会完全用光内存
不幸的是虚拟内存系统的滥用会导致
你的程序被终结
而这是我们最初想要避免的 对吗
为了提供最好的多任务处理体验
对于用户理解你的app使用的数据
和数据性能是非常重要的
你现在必须能够分辨出可有可无的数据
和你需要的重要数据
你的数据可以被预计算吗
重新建立有多贵
它长时间改变一下
了解关于你使用的数据可以帮助你找到
让你的内存变得最大适用性的正确工具
我们可以一起改善我们apps的适用性
和提供更好的多任务体验给我们的用户
在接下来的几周你会更新你的apps
为了iOS9的多任务处理
我希望你们把这些话题记住
首先用工具来识别并修复程序错误
这是简单的东西
你的内存泄露无效率的数据构造 算法
废弃的内存等
把它们都修好
其次适当优先化你的工作
然后别阻隔到主流程
我不知道你们多少人在这个系列的第一阶段记住了
就是系统会真的终端
如果你阻隔主流程太长时间
最好了解
你的工作应该在哪然后将其归位
第三点就是辨别并管理你的工作集
然后了解工作集会改变
根据应用的目前执行环境
你是前台 后台 PiP
了解你现在的位置
因为你的工作集不应该是相同的
第四个是使用缓存 然后响应内存警告
这个是作为一个多任务处理好公民的基本
请回应它们
下一个利用虚拟内存系统
也就是我们说过的
了解你的app的数据性能
然后看如果你可以利用那些工具
来让系统为你管理内存
最后就是良好的表现需要权衡
你的app是有需求的
apps在你旁边运行的有需求
系统也有局限
辨别你的app如何可以适应环境
用更约束的资源因为这是
改善所有人用户体验的关键
因为我由一句话开始那么我就由一句话结束
我在网上找到的这句话
据查尔斯·达尔文
称不是最强或者最智慧的生存
是那些最会改变的生存
多任务处理和适应有关
然后最能适应的apps将会
带来最佳的用户体验
获取更多的信息 我非常推荐你们去
看一看文件
这里有一个新的采取多任务的指南它很棒
去论坛讨论有技术支持
如果你有任何问题
找柯特卢·瑟特 联系他吧
他也是一个SpringBoard的前任工程师
所以我相信他很愿意聆听你们的想法
我们关于这个有两个之前的讲座
我建议你们也去看它们
接下来也有性能和GCD讲座
谢谢大家 今天的到来
我等不及要看你们的apps了