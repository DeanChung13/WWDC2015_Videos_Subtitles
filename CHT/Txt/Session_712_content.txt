低能耗，高性能：壓縮和加速框架
早上好
歡迎來到矢量數字組講座
我叫埃裏克·比安維爾現在就職於矢量數字組
我們組提供大家都知道的加速框架
還在系統裏的一些庫
在加速框架中你會發現圖像
是圖像操作的數百種
功能集合
你還會看到加速內部的vDSP是用於
信號處理和三層線性代數庫
在加速框架以外我們還維護Math library
LibM和字符串函數
去年 我們引入了SIMD這是一系列
頭文件和函數可提供矢量類型
可以向SSC和AVX附近的CPU矢量單元直接映射
今天 我們要介紹這些函數的三種補充
首先是壓縮這是數據壓縮庫
然後史蒂夫會介紹SIMD庫的補充內容
最後盧克會講稀疏BLAS的內容
稀疏矩陣的線性代數
我們先來看壓縮
壓縮是什麼?
壓縮是個新庫它可提供統一
和簡單的API進行無損數據壓縮
在app中想要使用壓縮時
爲什麼會需要這樣的東西呢
首先需要找到
壓縮讀取手冊編寫代碼進行測試
如果不工作就需要另選一個再編寫代碼
這會非常麻煩
有時 甚至會在你的app中
還包括壓縮曲線這對於
維護來說就是噩夢
因此要爲常見的壓縮算法
和統一的API提供包裝
以及諸如優化代碼
和算法間的輕鬆轉換類好處
我們先從放入其中的算法開始
當我們談到壓縮算法時需要考慮兩個矩陣
第一個顯然是壓縮比率
這是原始數據大小和壓縮有效
載荷大小之間的比率
我們感興趣的是編碼速度和解碼速度
爲選擇算法他們將其放在同一圖形中
在這張圖中X軸上顯示的是壓縮比率
在Y軸上則是編碼速度
在中間是參考參考壓縮器
所有的算法都要與這個參考進行比較
如果你是在右側壓縮效果較好
如果是在頂部壓縮速度較快 就是這樣
我們放入一些算法
中間的是zlib
這是最常用的
那我們做了什麼呢？
我們選擇最好的壓縮對就是LZMA
和最快的LZ4
你會看到灰線表明壓縮得越多難度就會越大
壓縮更多 意味着
速度越慢壓縮越少則速度越快呈指數關係
正如仔細來看這就是在zlib之上
的第一個點也就是速度更快 稍靠右側一點
這是說壓縮得更好這就是LZFSE
我們今天要介紹的新壓縮器
是對zlib的很好替代我稍後會談到這點
在壓縮庫中我們放了4個壓縮器
解碼是這個樣子看似是同樣內容
如果壓縮得越多也就需要更多的解壓時間
我們的4個壓縮器都在同樣的位置
這些是我們選擇放入壓縮庫的4個算法
LZMA用於高壓縮但它位置卻很低
LZ4用於快速壓縮但是它不能壓縮很多
在中間位置是zlib和LZFSE 
爲在壓縮比率和速度之間取得平衡
如果是在不同的應用情況中做比較
對於軟件分發你會使用LZMA
因爲要在服務器上壓縮一次 然後發送
這樣你會希望發送部分越小越好
那我們做了什麼呢？
我們在Apple硬件上做了部分優化
這是什麼意思呢？
像這樣例如我們優化了zlib解碼器
我們提供的zlib解碼器的性能
壓縮能力幾乎比普通的zlib快1.6倍
LZ4也是如此
因此這是另一個好處
你還會因爲無需改變代碼
就可以實現數據安全和性能升級而受益
我們簡單介紹一下新的壓縮器LZFSE
你爲什麼會需要新款壓縮器呢？
首先它很有趣
然後 爲什麼我們要優化zlib?
在zlib的熵編碼部分我們得出了結論
這裏是個瓶頸問題無法解決
除非是用其他的內容加以取代我們就是這麼做的
我們採用了新技術更精緻的狀態熵
並用它取代了zlib編碼
好消息是LZFSE可以在 
現代CPU架構上實現更好的映射
當初的設計目標是要匹配zlib的壓縮比率
使之能實現儘可能快的速度
我來給大家看看相關的數字
這是壓縮比率通過設計也是同樣的數字
這裏是能源效率編碼和解碼都有LZFSE  
如大家所見 在編碼方面 
我們快了2倍多在解碼方面我們快了2.5倍
不僅是快是更高效
這是什麼意思呢？
假設你有的電池是滿格電量並未進行壓縮
通過zlib比如說在電池沒電之前可以壓縮5千兆數據
通過LZFSE 耗費同樣的電量你可以壓縮12千兆數據
這就是高能效的意思
實際上 速度方面也不差
因爲我們在相同的壓縮比率下在編碼
速度方面快了2倍多解碼速度
則快了3倍
這就是LZFSE
我來給大家展示這個API該怎樣使用
共有兩個API在一個緩衝區中立刻出現了所有的數據
則要用到緩衝API
這是從PC中接收數據時用到的流API
緩衝API非常簡單
就像是超級的內存拷貝你提供緩衝
和字節數目的地緩衝
和容量還還可以提供
所需用到的算法
這就是LZFSE
你會看到在壓縮器之間的轉換
就是改變常數即可不需要重寫任何代碼
新代碼是壓縮解碼緩衝函數
如果出現錯誤或者目的地緩衝區
沒有足夠空間它就會將
返回目的地緩衝區的字節數變爲0
解碼也是同樣道理
你會傳遞包括壓縮有效載荷的緩衝區
和接收解碼數據的緩衝區
不同之處在於它放入輸出
緩衝區的字節數
如果出現問題它會填充緩衝區
也會截取輸出內容
我來給大家展示流API
這稍微有些複雜
因爲你需要在調用之間有些狀態
我們會用需要壓縮的新原始數據多次調用庫
這就像個糖果工廠
從這邊送入白糖輸出的就是糖果
你需要將流對象進行初始化
然後多次處理函數
最後你會調用函數釋放流對象佔用的資源
我來給大家看看代碼細節
首先我們初始化流對象你表示認可
我要編碼要使用LZFSE初始化
然後你會調用過程
在調用過程之前通常是在其他壓縮庫中
你需要告知它在哪裏壓縮字節
在哪裏放置輸出數據
然後調用過程它會和消費者端一樣
輸入或填充輸出數據
它還會爲你更新這些域
最後你會告知它好了做完了
沒有白糖原料了 
結束之後你就不得再發送需要壓縮的數據
但是你需要多次調用清空管道獲得輸出數據
此刻它會返回結束意思是說
最後你需要調用壓縮流銷燬來釋放資源
這就是編碼解碼則要更爲簡單
你需要相同的初始化代碼
這次是要解碼而不是編碼
然後你發送數據它會自行分辨
這是否爲流的結束部分
在某些點它會返回結束這意味着
你可以獲得所有數據你還要再次銷燬就這樣
我們完成了壓縮
現在來進行打包有一個新的庫
可以在幾個壓縮器上提供簡化和統一的API
LZMA LZ4 zlib和 LZFSE
哪個在zlib上更受青睞
LZFSE就是新的 高性能壓縮器
謝謝大家 有請史蒂夫他會介紹
有關SIMD庫的改進內容
謝謝
謝謝 埃裏克
我是史蒂夫·坎農 和埃裏克一起是矢量數字組的工程師
今天 我想談談SIMD 
這是個二維三維和四維的矢量數學
去年在Yosemite版本和iOS中 我們引入了SIMD
它可以用於CObjective-C
和C++它與Metal着色語言非常相似
也就是說它很容易編寫在GPU上
運行的Metal代碼使用和SIMD
相同的數據結構和相同的CPU代碼
它非常接近着色語言的傳統
以及與矢量和矩形工作的方式
那麼今年的新增
內容是我們也會支持Swift
那麼本次講座中以及我主講的部分都是與Swift有關
所有的實例都是Swift
大部分情況下 它與CObjective-C和C++中
都是完全相同
如果想在深入瞭解這些語言可以看看
我們去年的講座視頻其中有些很重要的
不同之處我會在講座中明確指出
但是 所有的實例都是Swift
我們爲什麼要引入新的矢量庫呢?
在平臺上有一系列矢量庫
我也用過相當多
爲什麼還要添加新的呢？
我給大家看看幾項實例都是用其他矢量庫
小有不便以及使用SIMD則會好了許多
BLAS是很好的矢量庫 
它是加速的一部分這是我用到的第一部分內容
這裏是用向量乘以矢量一個例子
並將之加入BLAS的另一個矢量
我們生成了兩個Swift數組
這些就我們的矢量
我們稱之爲C BLAS Saxpy函數 它會將X乘以2 
在加上Y並把結果保存在Y
我們需要傳遞的還有一些其他信息
因爲這裏是用到原始生成的API
它對於長度或步幅一無所知
我們需要提供這類信息
若是提出顯性調用來做
這項工作效率也會很低
我們來看GLKit這是另一個很棒的庫我喜歡GLKit
它有顯性矢量類型這樣你就不必
使用原始數組但是函數卻非常囉嗦
你必須要調用GLK矢量3乘以向量
來做算法這非常麻煩
使用SIMD是這樣的效果
好多了 對吧？
你可以寫下想用的算法它會發揮作用
你不必調用函數
生活真美好
那麼這樣就好多了
你還能做什麼呢？
我們有浮點矢量 雙矢量32bit整數2 3 4的長度
在C Objective-C和C++還有其他矢量類型可用
現在我們有了Swift的子集
我們選擇這個子集是因爲當你想用I/O模型
想使用圖形內容這是編寫Metal
程序最常用來與其他的庫
進行互通的部分這些就是你希望可用的類型
這些類型可以用來做什麼？
首先 你要生成它們
我們有一系列不錯的起始程序你可以生成零矢量
可以顯性規定矢量元素
可以有所有組件相等的矢量有許多不錯的初始程序
你可以完成算法
可以有元素方面的算法算子也可以用
如果我用兩個矢量相乘就會得到一個新的矢量
其中的每個元素元素的值
就是輸入矢量對應元素相乘的結果
相除也是同樣我可以用向量相乘
我可以進行向量點積向量叉積等等
我已經給大家看了一個實例我馬上給你們再看一個簡單的例子
這是個反射函數我可能會在圖像中經常使用
它用1個矢量X它通過垂直於
標準矢量N來反射N
要寫下它需要編寫數學表達式
寫下X減去2倍的X向量點積和N倍的N
你實際上不必寫下這個函數 對嗎？
應該已經有現成的可供使用
對的 我們有一系列幾何着色器數學函數可供使用
我們還有向量點積向量叉積 反射 折射
距離 等等 所有這些你都會用到
如果你之前寫過着色器程序
你就曾多次用過這些函數
這些都是在Metal或開放式CL或GLSL 
你所喜愛的着色器語言中的標準內容
我們還有浮點4類型的加速
的各類數學函數可用因此可以使用 V sign F
VCosf 用這些類型進行數學函數計算
我們還有矩陣和矢量
矩陣的類型是浮點數N乘以N 雙精度N乘以M
N是列數M是行數
如果你是個數學家就會感覺很奇怪
如果你是圖形編程人員這就很正常
所以大家會感覺輕車熟路
N和M可以是2 3或4但是不一定是正方矩形例如
浮點2乘3 是個兩列三行的矩陣
同樣 我們有各種初始程序
你可以生成零矩陣可以生成標識矩陣
可以生成對角矩陣
如果你想可以規定對角元素
如果你想還可以規定所有元素或作爲數組的一列
或作爲矢量的一列
各種很棒的內容
我給大家展示一個使用矩陣的小算法實例
我們在對角上用2s生成矩陣
這個矩陣當你相乘時可以用矢量乘以2
我們把最後一列進行調整 放入一些值
這是個變形矩形矢量乘以2
這也使用於偏差可以轉化
我們可以把這個用於所有都是1的矢量
還可以用矩陣的反向屬性
獲得相反變形這樣就可以恢復到最初的矢量從而取消變形
當我希望在兩種語言之間互通時
可以使用Objective-CAPI 如你想要
調用的I/O模型 API
Swfit矢量類型與Objective-C
矢量類型在佈局上兼容
我的意思是說它們在內存中有着完全相同的表現
編譯器瞭解它們是相同的
這樣你就不必考慮將Swift矢量類型
轉變爲Objective-C矢量類型或是將Objective-C矢量類型
轉變爲Swift矢量類型我這裏有一個返回矢量SIMD矢量的
Objective-C API我可以立即將之用於Swift
對於矩陣而言我必須從我所獲得的
Objective-C矩陣中初始化Swift矩陣
這是個成本很低的操作基本上是個拷貝
因爲佈局相同但是我需要調用初始程序
我希望將Swift類型傳遞給Objective-C時也是同理
我可以將所用
C矩陣屬性的矩陣傳遞矢量
以獲得Objective矩陣 可以將之傳遞給
Objective-C API
這就是SIMD
當配合小矢量和矩陣使用時SIMD效果很好
有時你也會需要使用更大的矢量和矩陣
我就要和大家談談LAPACK
BLAS 線性代數
這是很有意思的環節我們需要離開數學分支片刻
LAPACK和BLAS 是業界標準的數學庫
這些是平臺上部分最古老的API
也就是說看起來有些晦澀難懂
不過網上有很多文檔資料
因爲它們已經存在了近40年
很多情況下你可能會從
庫中獲取部分代碼這就需要依靠這些API
只要連上加速效果很好
用起來很簡單
線性代數是我們去年介紹的新界面
其中有更簡單的API
來完成更常見的線性代數操作
這和上一個幻燈片是完全相同的操作
它在解析線性系統 
而不是用8個參數調用晦澀的函數
你調用LA求解 你提供需要解析的矢量和矩陣
非常好
在過去幾年間 我們對LINPACK談得很少
以及在線性代數方面我們可以實現多快的速度
LINPACK基準表明 對於系統線性等式
我們可以多快地求解？
這完全是我們在上一頁幻燈片看到的操作
歷史上而言該基準共有三種變體
開始是作爲可以多快速地爲100x100系統求解？
但是隨着電腦越來越強大 速度越來越快
它不可能通過這樣的小問題
顯示自己的速度有多快 因此變成一個1000x1000的系統
如今 當人們談到LINPACK
它們實際上不再構成阻礙
你可以隨意選擇所需的大矩陣來顯示自己能實現多快的速度
當你看到超級計算機排名時
其中提供的LINPACK分數
都是百萬x百萬的量級
你儘可選擇讓你的速度可以最快的即可
幾周前 我在網上看到
有人在說iPad Air 2的速度已經相當驚人
LINPACK可以實現每秒1.8個十億次浮點運算 相當厲害
這可是每秒1.8個十億次浮點運算
我知道這個數據不高
有人編寫了簡單的程式來解決
就是用編譯器所能提供的內容
這就是實現的LINPACK分數
我在四周看了看看到有人在認真優化他們的
LINPACK程式他們編寫了矢量代碼
做了隱藏層還有多線程
結果實現了LINPACK每秒5.6個十億次浮點運算
這要快上3倍改進更多
不用再去做所有這些工作
只需要調用加速即可
在前面的幻燈片中我展示了D獲取RS和LLA解析函數
你可以編寫一行代碼
如果這麼做 就可以實現每秒25個十億次浮點運算
我們的確是想這麼做
我們就是想爲大家帶來便利
我們希望讓大家只需編寫一行代碼
而不是去着手優化每項內容
實現更好的能源利用更好的表現
而不需要做太多工作
現在有請盧克回到臺上 他會介紹
當矩陣非常巨大時你該怎麼做
謝謝 史蒂夫 我是盧克·常
是矢量數字組的工程師
今天我來談談Sparse BLAS的內容
BLAS代表基礎線性代數解析程序
稀疏BLAS是稀疏矩陣的BLAS
這是iOS 9和OS X.11的新庫
它是爲簡單的API和優良性能而設計
可以支持單精度和雙精度
我們爲什麼需要稀疏BLAS?
我可以在已經瞭解具體工作方法的
稀疏BLAS上使用緊密BLAS嗎
對的 它可以對不大的矩陣提供維數
但是使用Sparse BLAS在很多方面會更勝一籌
爲了說明這一點
我來給大家展示一個典型的Sparse矩陣
這是機器學習的典型矩陣
有着1百萬行和20萬列
這就是提供了3000億次的輸入
但是矩陣的密度僅爲0.05%
這裏是視覺化稀疏矩陣的圖片
藍色部分越深密度就會越大
正如大家所見圖片上很多區域都是白色的
這些都是零值
我們不希望把內存耗費在零值上
如果你是在常規的矩陣格式中
存儲這個稀疏矩陣
你就可以使用常規緊密的BLAS
假設這是單精度數字 則會
佔用1個太字節以上的內存這並不可行
你不會希望在手機和iPad上這麼做
這樣會節省內存此外稀疏BLAS 
還更節能速度更快
我們在MacBook Pro衡量稀疏BLAS的性能13英寸
密度爲0.5%的稀疏
BLAS的能效要比緊密BLAS高18倍
性能方面要快15倍
隨着密度的下降性能會提高
在密度爲0.05%時這是我們在之前的矩陣
看到的密度在能效和性能方面
會比使用常規密度的BLAS高100倍
這樣大家看出使用稀疏BLAS
有着許多強有力的原因節省內存能效更高速度更快
在稀疏BLAS中可以用到什麼？
我們有產品 三角解析我們可以計算範數
L1 L2 L 無窮範數等等
我們會看到跡這是對角和
它可以交換行和列爲矩陣增加新值
從矩陣中提取行和列
在我介紹操作之前
我們來看如何保存稀疏矢量
正如我之前所說我們不希望把內存浪費在零值上
我們保存非零值就像這樣
然後我們需要了解這些非零值從何而來
因此我們保存非零值的指數
最後 我們需要了解我們保存了多少
這就是非零值非零值的指數
這些是稀疏矢量需要保存的三項內容
爲了從常規密度矢量
轉化爲稀疏矢量Sparse BLAS提供了效用函數
幫助完成轉化
如果想從密度專爲稀疏則需要調用壓縮
反之 則是需要調用解壓
如果你需要了解非零值的數量
可以調用獲取矢量非零值數量
現在我們來看稀疏矩陣怎麼保存呢？
我們可以將稀疏矩陣視作行的集合
或是列的集合
如果我們壓縮稀疏行稀疏列
或是忘記了行和列這就會非常亂
我希望將矩陣視作非零值列表 
每個非零值我們都會存儲
列索引和行索引
還有許多其他保存格式 
每種都有自己的優勢和不足
對於你所要進行的具體操作
可能會有最佳的保存格式
我們決定讓事情更容易些
我們定義了稀疏矩陣數據類型
這是個不透明指針如果你想用的話
必須先用創建函數來生成
並且可以對其進行操作做完之後
必須銷燬
這麼做的好處是
我們可以爲你管理內存
想在矩陣中添加新值時
你也不必擔心分配新內存
或重新調整緩衝區或最後釋放緩衝區
我們來做這些
更好的是我們可以選擇最好的保存格式
例如如果你在稀疏矩陣中
插入一組行我們會按照稀疏行來保存
當你插入一組列時我們會按照稀疏列來保存
如果你想做特殊的操作
還有最好的保存格式我們也會自動轉化爲該格式
最後 這會讓我們在API中
隱藏維數細節讓API更爲乾淨
當你調用稀疏函數時
你不必每次傳遞稀疏矩陣的維數
這裏是個示例
首先創建稀疏矩陣
然後你會在稀疏矩陣中插入一個值
或是插入稀疏矢量作爲行或列
然後提交稀疏矩陣的更改
在下一個幻燈片中我來講詳細介紹提交函數
完成之後要調用銷燬
好的 爲什麼需要提交函數？
數據插入造價很高因爲我們以壓縮格式保存值
每次你需要在涉及數據移動的
壓縮存儲中
加入值就會涉及更多內存分配這樣造價很高
我們需要延遲所有的數據插入這樣可以分批處理
好消息是即便你忘記調用提交函數
當你在矩陣中進行操作時 
提交函數也會自動啓動
現在你可能會問爲什麼要用提交函數?
如果想要控制代碼性能
你顯然要用到提交函數
加入你在app啓動期間
讓稀疏矩陣就緒這樣app可以對
用戶的數據 儘快做出反應
那麼就要在啓動代碼中加入提交函數
這樣相當好用
好 考慮到時間問題我只介紹稀疏BLAS中
最常見的兩個操作
第一個是乘積C=AxB
我們支持矢量內積 矢量外積
矩陣矢量乘積矩陣矩陣乘積
A B C的類型是什麼？
對於內積A是稀疏B爲稀疏或緊密C爲單一值
對於外積 A爲緊密B爲稀疏
結果C是稀疏矩陣
對於矩陣矢量和矩陣矩陣乘積
A爲稀疏 B爲緊密C爲稀疏
你需要兩個稀疏矩陣乘積的情況非常罕見
因此不做支持
這裏是矩陣乘積的函數原型
稀疏函數的命名規則是先
是下劃線稀疏後面是我們要做的操作在本例中是矩陣相乘
緊密是指BC爲緊密浮點是數據類型
你將會返回成功或錯誤代碼
這個函數的參數正如常規BLAS
你規定B和C的次序是列主序或行主序
你來表示自己是否需要將A換位
B和C的列數 其餘則和BLAS一樣
下一個操作是三角解析
你來爲三角系統等式求解
T必須是上或下三角矩陣
我們支持緊密緊密矢量或B矩陣
主要注意的是上或下三角
屬性必須在進行數據插入前設置
這裏的代碼就是強調這一點
設置矩陣屬性需要在進行任何數據插入前完成
在數據插入後可以調用三角求解
參數則和BLAS一樣
總之稀疏BLAS是和簡單API一起設計
它有着非常廣的操作範圍
性能也很好
好的現在就來總結一下講座內容
我們今天介紹了三個新庫
用我們的新壓縮器LZFSE進行壓縮
現在 你可以在Swift上
使用SIMD還有稀疏BLAS庫
它們有着共同的設計目標
都是速度更快能效高便於使用
我們鼓勵大家試一試讓我們知道你們是怎麼想的
我們很希望能聽到大家的反饋
我們對開發人員的要求和反饋都認真對待
實際上 我們添加到加速框架中的許多功能
都是根據開發人員的要求進行的
如果你發現自己想用的功能沒有
請填寫功能申請
若想了解更多詳情我們還有vDSP和
壓縮的在線文檔資料
如果想了解加速框架的其他內容
可以看看我們以往的WWDC講座視頻
我們還有壓縮vDSP的簡單代碼
還可以參加論壇討論
如果是一般性諮詢可以聯繫開發顧問保羅·登博
這裏就是相關講座我們介紹過I/0模型
Metal Swift 如果想瞭解更多詳情
可以去找這些講座的視頻看看
就是這樣
感謝大家光臨 希望在實驗室見到大家
非常感謝！