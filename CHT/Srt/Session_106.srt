00:00:21.355 --> 00:00:23.056 
歡迎參加《Swift最新內容》講座

00:00:29.096 --> 00:00:31.832 
我是克里斯·拉特納
我來主講前半部分

00:00:31.899 --> 00:00:35.702 
我的同事約翰·邁克考爾
則會在下半部分介紹最新內容

00:00:36.637 --> 00:00:38.705 
在開始之前我覺得先來看看

00:00:38.772 --> 00:00:41.475 
我們想做什麼
這很有趣也許會有幫助

00:00:41.542 --> 00:00:44.444 
Swift 2的目標是什麼
以及它背後的思想是什麼？

00:00:45.412 --> 00:00:47.548 
我們主要追求三個目標

00:00:48.282 --> 00:00:49.950 
首先 基礎架構 

00:00:50.350 --> 00:00:55.155 
我們希望Swift語言的核心功能
和核心行爲以及工具都非常出色

00:00:55.856 --> 00:00:59.426 
許多內容都需要很多在座的朋友

00:00:59.793 --> 00:01:01.395 
在使用Swift過程中產生的反饋

00:01:01.461 --> 00:01:06.133 
其中很多都是...

00:01:06.700 --> 00:01:09.770 
我非常感謝大家所提供的所有反饋

00:01:10.170 --> 00:01:11.872 
大家通過實際使用產生的出色反饋

00:01:12.272 --> 00:01:14.675 
才使得Swift得以不斷完善

00:01:15.909 --> 00:01:17.277 
第二 是安全

00:01:18.712 --> 00:01:20.247 
安全性是Swift的核心價值

00:01:21.315 --> 00:01:24.451 
我們的確希望能很容易地編寫安全代碼

00:01:24.885 --> 00:01:27.287 
我們覺得錯誤處理結構的新可用性

00:01:27.821 --> 00:01:29.990 
將成爲實現這一目的的傑出方式

00:01:30.791 --> 00:01:32.092 
第三是 美觀

00:01:33.093 --> 00:01:34.528 
我們希望代碼可以非常美觀

00:01:35.028 --> 00:01:38.365 
作爲編程人員 
我們整天都在和代碼打交道

00:01:38.432 --> 00:01:40.000 
這一點對我們非常重要

00:01:40.400 --> 00:01:44.771 
我們在Swift中的新增內容使其
更容易寫出自然美觀的代碼

00:01:45.839 --> 00:01:48.709 
今天我們介紹Swift的五項新內容

00:01:50.811 --> 00:01:53.180 
在我們詳細介紹
Swift 2最新內容之前

00:01:53.247 --> 00:01:54.448 
我認爲有必要說明

00:01:54.515 --> 00:01:57.351 
Swift 1.2
已經實現了長足進步

00:01:57.518 --> 00:01:58.986 
它不過是在三個月前發佈

00:02:00.153 --> 00:02:02.756 
由於時間所限我們沒辦法
詳細介紹這個版本

00:02:02.890 --> 00:02:05.158 
但是如果你感興趣而且還沒有看到過

00:02:05.459 --> 00:02:09.530 
可以看看Swift編程語言書籍
和Xcode 6版本發佈說明

00:02:10.663 --> 00:02:12.432 
我們來詳細介紹基礎架構部分

00:02:14.134 --> 00:02:18.372 
基礎架構是關於改進Swift語言的
核心行爲以及它該如何通力配合

00:02:18.872 --> 00:02:20.574 
這裏有許多小細節

00:02:20.641 --> 00:02:23.810 
這感覺像是在漫無目的地漫步
但是要跟上思路

00:02:24.511 --> 00:02:25.579 
我們先從枚舉講起

00:02:26.780 --> 00:02:29.917 
枚舉是Swift最好的功能之一

00:02:30.284 --> 00:02:33.153 
這裏我用枚舉來
列舉一些常見的家養寵物

00:02:34.755 --> 00:02:37.658 
枚舉的出色在於它們很容易定義和使用

00:02:38.659 --> 00:02:42.596 
另一方面
如果你已將它們用於遊樂場或打印出來

00:02:43.063 --> 00:02:45.098 
你可能就會想要更多

00:02:46.300 --> 00:02:50.470 
在Swift 2枚舉可以攜帶足夠的
可以打印的反射信息且效果非常好

00:02:56.610 --> 00:02:58.111 
接下來相關值

00:02:59.046 --> 00:03:03.183 
枚舉的出色還在於
它們是差別聯合類型的理想模型

00:03:03.417 --> 00:03:04.484 
當有兩種不同類型的值

00:03:04.551 --> 00:03:08.522 
需要在同一內容中進行保存時
這就會非常有用

00:03:08.589 --> 00:03:09.423 
對嗎？

00:03:09.690 --> 00:03:11.391 
相關值非常強大

00:03:11.458 --> 00:03:13.961 
也許你會用任何一個類型
編寫明顯的內容

00:03:15.462 --> 00:03:16.964 
這是用來做模型的理想方法

00:03:17.030 --> 00:03:20.901 
但是當你使用時
會有些不快之處

00:03:22.069 --> 00:03:24.571 
這就太糟糕了
大家都不希望是這樣

00:03:24.705 --> 00:03:26.807 
有了Swift 2這就不成問題

00:03:32.579 --> 00:03:33.914 
我們再看看遞歸

00:03:34.515 --> 00:03:37.384 
Swift中的枚舉就是代數數據類型

00:03:37.651 --> 00:03:41.655 
在其他語言中
遞歸代數數據類型非常強大

00:03:41.722 --> 00:03:42.890 
可以做出相當棒的事情

00:03:43.624 --> 00:03:47.094 
問題在Swift中
這些值在枚舉中都是內聯保存

00:03:47.761 --> 00:03:49.263 
這意味着如果是遞歸枚舉

00:03:49.396 --> 00:03:53.534 
它將會無限令當前的設備很難承受

00:03:53.700 --> 00:03:58.505 
也許在明年會有這方面的變通方案

00:03:58.672 --> 00:04:02.943 
大家可能都見過箱型
可以以此作爲參考

00:04:03.010 --> 00:04:05.245 
但是要打破模式匹配
就會很難看 很可怕

00:04:07.014 --> 00:04:08.415 
在Swift 2中有更好的方法

00:04:08.615 --> 00:04:10.784 
在beta 1中還不太好

00:04:10.984 --> 00:04:13.120 
不過很快
你就可以間接標識自己的情況

00:04:13.687 --> 00:04:16.656 
可以自然地進行表達模式匹配
效果也很棒

00:04:18.291 --> 00:04:20.127 
我們來繼續介紹範圍

00:04:24.932 --> 00:04:26.967 
有些時候你想重複使用某個名稱

00:04:27.167 --> 00:04:29.770 
也許是想確定某個之前發佈的資源

00:04:30.804 --> 00:04:34.808 
我們引入了可以介紹顯性範圍的
新Do語句

00:04:35.542 --> 00:04:38.879 
在本例中 我們只想
時不時和網絡挑釁打交道

00:04:38.946 --> 00:04:41.381 
但是我們需要緊緊地約束它們

00:04:42.349 --> 00:04:46.153 
在講座稍後 我們介紹錯誤處理部分時
Do語句就會非常重要

00:04:46.753 --> 00:04:50.023 
但是把Do作爲關鍵字
會導致一些潛在歧義

00:04:50.591 --> 00:04:53.961 
這種歧義不是針對編譯器
而是在我們讀碼時會有歧義

00:04:54.895 --> 00:04:57.231 
你不會常常看太長的語句底部

00:04:57.297 --> 00:04:58.599 
我們還有Do While循環

00:04:59.867 --> 00:05:05.038 
通過語句的字符集了解它在做什麼

00:05:06.540 --> 00:05:08.041 
我們需要讓它變得非常簡單

00:05:08.408 --> 00:05:11.578 
通過看語句的字符集關鍵字就一目瞭然

00:05:11.912 --> 00:05:15.649 
所以我們把Do While
循環更名爲Repeat

00:05:16.049 --> 00:05:18.852 
一看到頂部
你就可以知道這是個循環

00:05:18.986 --> 00:05:19.953 
這樣就非常簡單

00:05:24.491 --> 00:05:25.826 
我們再看看選項集合

00:05:26.460 --> 00:05:31.198 
選項集合是輕量級超級高效的方法
來表現一組布林值

00:05:31.765 --> 00:05:34.234 
如果你們以前見過
並用過不同的Cocoa API

00:05:34.368 --> 00:05:36.870 
並且用過See Like句法
和Or句法

00:05:37.804 --> 00:05:39.773 
這類基本句法實際上非常不錯

00:05:41.141 --> 00:05:45.512 
問題在於當你使用其他句法時
就不會是這樣

00:05:45.579 --> 00:05:48.081 
你用零值生成選項集合...

00:05:48.582 --> 00:05:49.449 
這不太合理

00:05:49.516 --> 00:05:53.620 
因爲選項集合和可選類型是
完全不同的概念結果卻混爲一談

00:05:54.188 --> 00:05:56.089 
你從按位操作將之提取出來

00:05:56.156 --> 00:05:59.826 
這樣非常麻煩而且非常容易出錯
你也會很容易犯錯

00:06:00.427 --> 00:06:02.796 
有了Swift 2
我們會採用選項集合

00:06:02.863 --> 00:06:04.198 
這樣會更糟糕

00:06:04.264 --> 00:06:06.800 
因爲Swift1.2 是 
一類集合類型

00:06:07.234 --> 00:06:12.005 
上述組合使得選項集合
似乎退回到C語言

00:06:12.573 --> 00:06:13.407 
而事實就是如此

00:06:15.742 --> 00:06:18.345 
但是Swift 2解決了這個問題
它將選項集合變得像集合

00:06:18.879 --> 00:06:21.682 
這就是說選項集合和集合
現在都是帶方括號

00:06:22.216 --> 00:06:25.052 
也就是說你會獲得
帶方括號空集的空集

00:06:25.485 --> 00:06:29.089 
你也會得到整套標準集合API
來與選項集合相配合

00:06:29.223 --> 00:06:30.757 
這樣做非常容易而且效果極佳

00:06:36.563 --> 00:06:37.431 
還有一個好處是

00:06:37.497 --> 00:06:40.234 
你可以用更簡單的方式
定義自己的選項集合

00:06:40.968 --> 00:06:43.270 
你現在只需要定義自己的集合類型

00:06:43.470 --> 00:06:47.107 
或結構類型
集合的結構類型

00:06:48.075 --> 00:06:50.744 
以符合新的選項集合類型協議

00:06:51.478 --> 00:06:53.881 
找到存放位數的存儲

00:06:53.947 --> 00:06:57.217 
定義需要放入選項集合中的元素

00:06:58.318 --> 00:07:01.955 
只需要簡單進行定義
你就可以獲得我們談到的所有句法

00:07:02.589 --> 00:07:05.959 
這就是相當棒的一點
它不需要進行任何編譯器匹配

00:07:06.460 --> 00:07:08.929 
這可以通過一個新功能

00:07:08.996 --> 00:07:11.398 
名爲Default Implementations

00:07:12.065 --> 00:07:14.368 
和選項集合類型提供的
Protocols自動實現

00:07:14.434 --> 00:07:17.304 
我們實在沒時間在這裏詳細介紹

00:07:17.571 --> 00:07:19.540 
Default Implementations
和Protocols

00:07:19.606 --> 00:07:22.142 
但是我們有一場相當棒的講座
詳細介紹協議方面的內容

00:07:23.710 --> 00:07:25.579 
我們來談談函數和方法

00:07:27.414 --> 00:07:31.451 
Swift將函數和方法統到
單一的函數聲明中

00:07:31.818 --> 00:07:37.291 
將兩個完全不同的概念放在類型系統中
構成一個漂亮的函數核

00:07:37.457 --> 00:07:38.859 
這樣做非常棒

00:07:39.560 --> 00:07:42.062 
這個漂亮的函數核
就是Swift的關鍵部分

00:07:42.696 --> 00:07:45.032 
在你想要調用這些內容時
就會立刻分解

00:07:45.933 --> 00:07:47.734 
因爲它們用的是不同的參數標籤

00:07:48.435 --> 00:07:50.938 
這對很多人來講都相當麻煩

00:07:52.406 --> 00:07:53.841 
如果我們來看這是從何而來

00:07:53.974 --> 00:07:56.610 
可以看出Swift是效仿
Objective-C的先例

00:07:57.244 --> 00:07:58.812 
C語言並無參數標籤

00:07:59.079 --> 00:08:01.648 
參數標籤對Objective-C
的方法而言非常重要

00:08:01.915 --> 00:08:02.883 
Swift也是如此

00:08:04.017 --> 00:08:06.119 
在Swift 2中
我們不僅解決了個問題

00:08:06.954 --> 00:08:10.390 
現在函數和方法是同樣的聲明句法

00:08:10.958 --> 00:08:12.326 
它們按照同樣的方式發生作用

00:08:13.827 --> 00:08:17.297 
當你調用全局函數時
你在默認狀態下提供參數標籤

00:08:19.433 --> 00:08:20.834 
所有內容都是統一的

00:08:25.806 --> 00:08:29.176 
因此需要了解的關鍵內容是
這會影響到純粹的Swift代碼

00:08:29.243 --> 00:08:32.145 
如果聲明Swift中的全局函數
你就會在默認狀態獲得這個行爲

00:08:33.246 --> 00:08:37.083 
從C語言引入的函數會繼續
按照它們一貫的方法行爲

00:08:37.150 --> 00:08:41.020 
因爲在C語言函數中的參數名稱
不是API的組成部分

00:08:41.087 --> 00:08:42.256 
也不會被當做是API

00:08:42.990 --> 00:08:46.860 
但是我們希望Swift代碼可以繼續
將函數標籤包括在參數中

00:08:47.794 --> 00:08:51.732 
如果要想要深入瞭解
這裏還有更多內容

00:08:52.666 --> 00:08:55.202 
Swift函數使用參數

00:08:55.536 --> 00:08:58.972 
參數爲每個值有不同名稱

00:08:59.573 --> 00:09:01.808 
當你用句法聲明某項內容時

00:09:02.075 --> 00:09:03.644 
你會獲得默認行爲

00:09:04.678 --> 00:09:09.216 
參數獲得的兩個名稱
一個是調用者看到的外部名稱

00:09:09.483 --> 00:09:11.618 
一個是執行方看到的內部名稱

00:09:12.186 --> 00:09:17.724 
在默認狀態下第一個的參數並未
向其外部客戶端顯示標籤名稱

00:09:17.925 --> 00:09:20.327 
你可能會在
執行方法時用到

00:09:21.495 --> 00:09:26.333 
同樣 第二個和之後的參數
都是默認爲內外相同

00:09:26.400 --> 00:09:30.504 
這就是爲何你會看到
有該參數的參數標籤

00:09:31.238 --> 00:09:35.042 
這種模型最棒的一點是
當你理解這點就可以對之進行自定義

00:09:35.375 --> 00:09:39.179 
例如 在本例中可以將標籤

00:09:39.246 --> 00:09:41.415 
放在第一個參數上
這樣你會知道它是什麼

00:09:41.882 --> 00:09:44.451 
只要重複參數名稱
即可實現

00:09:44.785 --> 00:09:45.719 
這非常簡單

00:09:46.320 --> 00:09:47.821 
同樣 如果想要刪除某些內容

00:09:47.888 --> 00:09:52.292 
你可以用下劃線顯性設置該名稱
表明要刪除參數標籤

00:09:52.926 --> 00:09:56.763 
這麼做我們就犯下了
最嚴重的命名錯誤

00:09:56.830 --> 00:09:58.232 
讓布林值沒有標籤

00:09:58.966 --> 00:09:59.800 
好的!

00:10:02.336 --> 00:10:04.071 
更好的一點是

00:10:04.137 --> 00:10:07.808 
發生的整個改變會令標籤在
系統中更爲顯著

00:10:07.875 --> 00:10:10.344 
讓API如此便於使用

00:10:10.944 --> 00:10:13.914 
而且這會讓我們將複雜簡化很多

00:10:14.381 --> 00:10:16.116 
現在函數和方法都在同樣發揮作用

00:10:16.583 --> 00:10:18.919 
我們還可以取消默認函數的特殊規定

00:10:19.319 --> 00:10:20.654 
這裏還有非常奇怪的句法

00:10:20.721 --> 00:10:23.290 
誰也不記得它是什麼
現在也不見了

00:10:23.423 --> 00:10:24.258 
這樣就會好得多

00:10:25.792 --> 00:10:27.094 
我們接着會談到編譯器

00:10:27.561 --> 00:10:30.230 
談到警告和錯誤消息
是編譯器而成的

00:10:31.131 --> 00:10:33.734 
這裏的代碼是合理代碼

00:10:33.800 --> 00:10:35.235 
也許你之前寫過類似內容

00:10:35.302 --> 00:10:36.503 
我要更新一點內容

00:10:37.771 --> 00:10:41.008 
如果你使用Swift 1編譯器
它會生成這個樣子

00:10:42.476 --> 00:10:46.213 
我不瞭解大家會怎樣
這並沒有什麼用

00:10:47.247 --> 00:10:48.949 
Swift 1.2則要好很多

00:10:49.116 --> 00:10:53.053 
Swift 1.2會生成錯誤消息
並告知我出現了問題

00:10:53.153 --> 00:10:55.756 
現在我發現無法對之賦值

00:10:56.156 --> 00:10:57.624 
當然這還不夠好

00:10:57.791 --> 00:11:01.128 
我們繼續研究編譯器
生成的錯誤消息和警告

00:11:01.495 --> 00:11:05.566 
在Swift 2中 它表示
“你不能給x賦值因Self不可變”

00:11:06.099 --> 00:11:10.270 
Xcode會告知你可以把方法
標爲可變 這樣就解決了問題

00:11:11.171 --> 00:11:13.273 
這是個很棒的方法
我覺得很多人...

00:11:13.340 --> 00:11:16.343 
它會幫助很多人
更好地瞭解Swift中的可變性模型

00:11:16.643 --> 00:11:17.978 
並讓代碼更爲出色

00:11:24.818 --> 00:11:27.287 
當然這才只是一個實例
這樣的例子還有很多

00:11:27.688 --> 00:11:31.992 
我們還添加了警告的實例

00:11:32.059 --> 00:11:34.728 
如果你的變量聲明爲常數

00:11:34.795 --> 00:11:37.464 
我們就會生成警告
要使用Let來替代Are

00:11:37.931 --> 00:11:42.936 
Swift移植工具會在許多情況下
用Let替代Are自動移動許多代碼

00:11:43.804 --> 00:11:47.708 
我們都會警告如果你聲明一個值
無論是Let還是Are都不要使用

00:11:48.275 --> 00:11:51.044 
如果你使用函數方法

00:11:51.912 --> 00:11:52.913 
然後忽略結果

00:11:52.980 --> 00:11:56.283 
因爲你可能是想使用變異方法

00:11:56.450 --> 00:11:57.851 
我們會對所有這些生成警告

00:11:58.051 --> 00:11:59.653 
還有簡單的實例

00:12:00.754 --> 00:12:01.955 
我們來談談SDK

00:12:05.425 --> 00:12:08.829 
這是Swift的核心內容
它與Cocoa配合很好

00:12:09.062 --> 00:12:10.931 
有了Objective-C API

00:12:11.265 --> 00:12:16.203 
Swift編譯器不清楚指針是否應爲
零以及集合的元素類型是什麼

00:12:16.837 --> 00:12:19.139 
我們引入了若干
Objective-C的新功能

00:12:19.406 --> 00:12:21.275 
包括表達可空性的能力

00:12:21.642 --> 00:12:24.745 
Objective-C的
集合元素類型

00:12:25.412 --> 00:12:27.948 
有整系列的其他功能

00:12:28.115 --> 00:12:31.118 
爲Swift的Objective-C
代碼提供優質體驗

00:12:31.952 --> 00:12:33.387 
最棒的一點是

00:12:33.487 --> 00:12:37.057 
Apple的框架工程師
完成一項傑出的工作

00:12:37.124 --> 00:12:39.593 
他們採用了所有這些
現代Objective-C功能

00:12:39.893 --> 00:12:44.398 
在Swift的各種平臺上
Cocoa SDK整體表現都很出色

00:12:44.464 --> 00:12:45.532 
而你無需做任何工作

00:12:46.567 --> 00:12:49.169 
不過
如果你有Objective-C代碼

00:12:49.236 --> 00:12:51.872 
也許在你項目中混合並
匹配了Objective-C代碼

00:12:52.206 --> 00:12:55.776 
也許你想在Swift中擁有更美觀的
Objective-C框架

00:12:56.210 --> 00:12:59.580 
今天晚些時候
可以看看部分講座內容瞭解更多功能

00:12:59.646 --> 00:13:02.216 
這樣你就可以提供
出色的Swift體驗

00:13:02.983 --> 00:13:04.651 
你可能需要看看視頻

00:13:06.720 --> 00:13:07.788 
我們來談談單元測試

00:13:08.355 --> 00:13:11.558 
在整個工具組
測試都是非常重要的

00:13:11.625 --> 00:13:13.427 
Swift中的測試功能非常不錯

00:13:14.561 --> 00:13:16.096 
不過訪問控制則不然

00:13:16.530 --> 00:13:22.503 
問題是Swift要求你將符號
Public標爲對單元測試束可見

00:13:22.736 --> 00:13:26.373 
如果可以測試
就不應該公開大量內容

00:13:27.007 --> 00:13:29.576 
Swift 2和Xcode 7
解決了這一問題

00:13:30.277 --> 00:13:32.479 
現在你的代碼會自動搭建成特殊模式

00:13:32.779 --> 00:13:34.147 
表示這是測試中

00:13:34.381 --> 00:13:37.651 
它們默認可以訪問你的公開和內部符號

00:13:38.051 --> 00:13:40.220 
你必須要用到新的app...

00:13:45.125 --> 00:13:49.196 
更棒的一點是
這不但非常容易 而且...

00:13:49.429 --> 00:13:51.465 
你仍可以爲發佈構建
獲得正確的行爲

00:13:51.532 --> 00:13:55.102 
這樣可以獲得很好的性能
以及訪問控制的保護收益

00:13:55.602 --> 00:13:57.171 
我們有一系列關於測試的講座

00:13:57.437 --> 00:14:01.308 
我強力推薦《Xcode的UI測試》

00:14:02.075 --> 00:14:03.243 
我們來談談富批註

00:14:04.044 --> 00:14:06.413 
遊樂場非常棒

00:14:06.480 --> 00:14:09.249 
Xcode可能幫你在編輯器中
使用批註句法 富批註句法

00:14:09.416 --> 00:14:13.587 
搭建漂亮的Swift遊樂場

00:14:13.954 --> 00:14:16.056 
句法是Markdown中的一個變量

00:14:16.390 --> 00:14:19.927 
非常不錯 很出名 很流行
是很好的句法

00:14:20.260 --> 00:14:22.095 
我們也可以使用文檔評論

00:14:22.496 --> 00:14:28.202 
這是說你可以
構建漂亮的富文檔評論

00:14:28.435 --> 00:14:30.103 
並在API上爲客戶顯示

00:14:30.170 --> 00:14:32.539 
如果你在生成庫
你可以做很棒的事情

00:14:34.041 --> 00:14:35.375 
最後 Xcode的移植工具

00:14:36.043 --> 00:14:38.946 
在Xcode 7中
一打開Swift 1項目

00:14:39.012 --> 00:14:40.447 
它就會彈出信息

00:14:40.881 --> 00:14:42.482 
“我可以爲你升級到Swift 2”

00:14:42.983 --> 00:14:44.284 
這大概需要兩步驟

00:14:44.351 --> 00:14:46.720 
你可以選擇自己的目標
然後它會提供一個dif

00:14:47.221 --> 00:14:49.590 
Swift 2移植工具
實際上非常不錯

00:14:49.823 --> 00:14:52.159 
這其中包括從Swift 1

00:14:52.226 --> 00:14:55.529 
轉移到Swift 2的
大部分問題和情況

00:14:55.829 --> 00:15:00.234 
包括錯誤處理模型 
從內容到方法的轉移和SDK的改變

00:15:00.434 --> 00:15:05.639 
及諸多的選項集合改變
都搭建在移植工具之中

00:15:05.873 --> 00:15:07.007 
效果相當不錯

00:15:08.041 --> 00:15:12.613 
Swift 2中還有相當多的內容 
現在我們沒時間一一介紹

00:15:13.413 --> 00:15:14.648 
如果你們對更多詳情感興趣

00:15:14.715 --> 00:15:17.284 
建議看看Swift編程語言書籍

00:15:17.351 --> 00:15:18.352 
已經有新版本推出

00:15:19.186 --> 00:15:22.689 
Xcode 7版本發佈說明中
也詳細介紹了這方面的改變

00:15:23.690 --> 00:15:25.626 
我們來繼續講模式匹配

00:15:27.628 --> 00:15:31.832 
大家最初遇到模式匹配
也許是在if-let語句中

00:15:32.566 --> 00:15:35.936 
最好使用可選類型

00:15:37.304 --> 00:15:42.109 
有條件地打開
然後將結果捆綁到安全的名稱上

00:15:42.609 --> 00:15:43.577 
這非常棒

00:15:44.111 --> 00:15:46.346 
當然 好東西遠不止這些

00:15:46.413 --> 00:15:49.650 
我們都曾經見過“金字塔厄運”

00:15:50.150 --> 00:15:52.853 
是指太多if-let語句堆在一起

00:15:52.920 --> 00:15:55.022 
突然代碼已經有15層高

00:15:55.088 --> 00:15:56.156 
你完全搞不懂它

00:15:56.723 --> 00:16:01.762 
Swift 1.2通過在if語句中
引入複合條件解決了這個問題

00:16:02.062 --> 00:16:03.397 
這會就自然多了

00:16:03.463 --> 00:16:04.965 
你可以在內聯

00:16:05.399 --> 00:16:09.002 
查看多個可選類型和布林條件 
效果好多了

00:16:09.536 --> 00:16:11.505 
這並沒有解決提早退出的問題

00:16:12.272 --> 00:16:18.178 
我給大家看幾個也許是
最可怕的JSON處理代碼

00:16:18.712 --> 00:16:20.280 
隨着時間的推移 情況會改善

00:16:20.380 --> 00:16:21.582 
我們來看這個

00:16:22.115 --> 00:16:25.219 
我從無類型JSON字典中取出各種域

00:16:25.352 --> 00:16:28.388 
我取出名稱轉化爲字符串生成可選類型

00:16:28.555 --> 00:16:29.723 
如果不匹配 我就要想辦法

00:16:30.290 --> 00:16:32.960 
同樣 取出年信息
轉化爲In

00:16:33.026 --> 00:16:34.161 
如果不匹配 需要救助

00:16:34.695 --> 00:16:37.664 
如果取出很多值
更常見是最好能採取救助方式

00:16:37.731 --> 00:16:42.236 
而不是深埋在代碼中
這種模式更常見

00:16:43.036 --> 00:16:47.741 
這種方式的問題在於
完成時需要強迫打開可選值

00:16:49.076 --> 00:16:50.177 
這裏我只使用一次

00:16:50.244 --> 00:16:53.013 
但是如果你有一組代碼都使用它們
你就需要到處都要強迫打開

00:16:53.747 --> 00:16:55.382 
你需要做些事情來解決

00:16:55.449 --> 00:16:57.618 
打開可選類型是不錯方法

00:16:57.684 --> 00:17:02.155 
它將強迫打開放入不安全的Mecca

00:17:03.557 --> 00:17:08.762 
可能這樣做也不大對
也非常難看

00:17:09.229 --> 00:17:10.931 
我們引入了新的Guard語句

00:17:11.098 --> 00:17:13.400 
看待Guard的方法就是
它要做檢查

00:17:13.599 --> 00:17:16.203 
若是檢查不匹配
就會做救助

00:17:16.770 --> 00:17:18.739 
你可以用過很多Guard語句

00:17:18.872 --> 00:17:20.840 
現在我們來做可選檢查

00:17:20.907 --> 00:17:22.643 
我們將一個值綁在名稱上

00:17:23.109 --> 00:17:25.012 
它可以發揮作用的方式是

00:17:25.078 --> 00:17:28.949 
是確保Else退出當前的範圍

00:17:29.383 --> 00:17:31.552 
可以用兩種方式的一種來完成

00:17:31.618 --> 00:17:36.523 
返回 拋出 跳出
有很多方式可以退出範圍

00:17:37.758 --> 00:17:38.592 
很好

00:17:38.659 --> 00:17:41.261 
你還可以調用No Return函數

00:17:41.328 --> 00:17:43.197 
例如Precondition Fail
或Abort

00:17:43.263 --> 00:17:44.731 
這些都是停止的不錯方法

00:17:45.699 --> 00:17:49.336 
這還可以確保編譯器瞭解安全性和

00:17:49.403 --> 00:17:54.074 
和貫穿代碼之後可以看到的確定性

00:17:54.741 --> 00:17:57.444 
如果把這個用在我們的例子中
肯定會邊的更好

00:17:57.578 --> 00:17:58.979 
因爲我們可以用Guard校對

00:17:59.046 --> 00:18:03.584 
如我們所願
進行安全 簡潔的檢查

00:18:04.785 --> 00:18:05.953 
還有一點很棒的是

00:18:06.153 --> 00:18:11.725 
這些都構建在If語句的富複合條件中

00:18:12.226 --> 00:18:13.493 
現在可以將它們合併在一起

00:18:13.560 --> 00:18:16.330 
根據Guard語句 
檢查多個布林值和可選類型

00:18:16.396 --> 00:18:19.566 
和我們稍後介紹的其他情況

00:18:19.633 --> 00:18:20.467 
這相當棒

00:18:27.608 --> 00:18:32.813 
我們再看看模式匹配
更強大更有趣的形式 開關語句

00:18:33.680 --> 00:18:37.985 
我覺得開關語句也許是
許多人喜愛的Swift功能

00:18:38.318 --> 00:18:41.288 
因爲在開關語句中可以
實現許多模式匹配功能

00:18:41.622 --> 00:18:43.557 
你可以檢查可選類型 

00:18:43.790 --> 00:18:46.960 
可以做類分層結構檢查
可以檢查範圍

00:18:47.427 --> 00:18:49.696 
在開關語句中可以實現許多功能

00:18:50.697 --> 00:18:53.600 
當你要寫許多條件語句時
這會很棒

00:18:53.700 --> 00:18:55.569 
但是當你只想檢查一個條件時 

00:18:55.636 --> 00:18:57.204 
在語句構成方面些笨重

00:18:57.738 --> 00:19:01.041 
它們只能是表達詳盡
你必須承認這很麻煩

00:19:01.808 --> 00:19:04.244 
我們所做的是
將模式匹配和開關 條件結合

00:19:04.645 --> 00:19:08.348 
將其帶到其他控制語句中

00:19:08.782 --> 00:19:11.451 
這個實例可以寫成新的If條件 

00:19:11.785 --> 00:19:15.422 
檢查之後 可以做模式匹配
將可變名稱綁到語句中

00:19:21.228 --> 00:19:25.265 
我們又向前進了一步
Swift還有一個出色的語句 循環

00:19:26.066 --> 00:19:28.836 
在...循環中
需要完成一些過濾的情況是很常見的

00:19:29.369 --> 00:19:32.739 
有些語言甚至需要
引入全新的語言結構

00:19:32.806 --> 00:19:35.943 
例如列出對此類模式的模型理解

00:19:36.577 --> 00:19:38.178 
通過Swift 2我們完成兩項任務

00:19:38.245 --> 00:19:43.183 
我們在...語句中
添加了簡單的布林值內聯過濾器

00:19:43.917 --> 00:19:47.621 
但是大家也可以在循環中完成

00:19:48.722 --> 00:19:50.390 
全面的模式匹配爲你提供強大的條件

00:19:56.163 --> 00:19:59.399 
關於模式匹配的內容
我只能匆匆介紹這些

00:19:59.700 --> 00:20:02.703 
我們介紹了新的Guard語句
非常適合提前退出

00:20:03.003 --> 00:20:06.507 
講了將模式匹配放到語言各處

00:20:06.874 --> 00:20:08.742 
我們並未談及其他的改進內容

00:20:08.809 --> 00:20:10.611 
在你開始使用Swift時
就會發現它們

00:20:11.178 --> 00:20:12.946 
謝謝
接下來有請約翰上臺

00:20:13.013 --> 00:20:15.082 
他會告知大家
可用性檢測方面的內容

00:20:21.355 --> 00:20:22.189 
謝謝 克里斯

00:20:23.557 --> 00:20:25.392 
我們經常推出新功能

00:20:25.626 --> 00:20:28.262 
大家可能聽說過
Force Touch

00:20:30.030 --> 00:20:34.735 
Force Touch是硬件功能
當然它還有一系列API

00:20:34.935 --> 00:20:36.970 
正如NSButton中的這個

00:20:37.471 --> 00:20:42.242 
可以讓我來改變按鈕
對拖拽的反應方式

00:20:43.343 --> 00:20:46.280 
如果我想在自己的app中
採用這個功能

00:20:46.880 --> 00:20:48.081 
將非常簡單 對吧？

00:20:48.148 --> 00:20:50.517 
我得編寫一些新的事件處理代碼

00:20:50.918 --> 00:20:52.452 
然後我需要用到按鈕

00:20:52.519 --> 00:20:55.422 
設置熱加載屬性

00:20:56.223 --> 00:21:00.394 
問題是這在我的開發
設備上效果可能會不錯

00:21:00.460 --> 00:21:03.130 
但是當我把它移交到測試硬件時

00:21:04.131 --> 00:21:06.266 
幾乎肯定就會出現崩潰

00:21:07.000 --> 00:21:10.370 
這是因爲這是個新的API

00:21:10.437 --> 00:21:12.172 
是在X v10.3中引入

00:21:12.706 --> 00:21:16.944 
在這種情況下 和大多數人一樣

00:21:18.378 --> 00:21:24.685 
你仍然會需要支持較早版本的OS

00:21:25.552 --> 00:21:28.388 
我怎麼解決這個問題呢?

00:21:28.455 --> 00:21:34.661 
我以前常用的解決辦法是
我會讓方法的錯誤信息不存在

00:21:34.728 --> 00:21:36.897 
我來看看這種方法是否存在

00:21:37.831 --> 00:21:41.134 
一方面人們開發了
許多不同的慣用語法來實現這一點

00:21:41.201 --> 00:21:44.972 
這是個常見慣用語
使用Responds到Selector

00:21:46.740 --> 00:21:50.577 
問題是這是個容易出錯的模式

00:21:51.311 --> 00:21:57.584 
例如 我必須指出選擇器是什麼

00:21:57.684 --> 00:22:00.988 
從部分Swift語言功能做映射

00:22:01.054 --> 00:22:04.157 
到部分Objective-C選擇器

00:22:04.424 --> 00:22:06.760 
這些細節沒有必要全部瞭解

00:22:07.461 --> 00:22:11.265 
要知道編譯器也沒有幫我檢查

00:22:11.331 --> 00:22:15.536 
因爲我本來也不願檢查
編譯器所提供的內容

00:22:16.436 --> 00:22:19.673 
例如 在本例中我實際上忘記加冒號

00:22:19.740 --> 00:22:22.709 
意思是說檢查永遠不會爲真

00:22:23.410 --> 00:22:25.746 
有了Swift 2
我們有更好的解決方案

00:22:26.680 --> 00:22:29.650 
在默認狀態下要確保

00:22:29.716 --> 00:22:35.022 
不要使用部署目標上
最小且不可用的API

00:22:35.756 --> 00:22:37.257 
如果我做這樣的事情...

00:22:42.863 --> 00:22:45.666 
如果我做這樣的事情
我會經常進行診斷

00:22:46.099 --> 00:22:50.938 
這樣我可以有
某種安全核心假設

00:22:51.004 --> 00:22:54.508 
只要我的代碼...
只要我的項目完全編譯

00:22:54.775 --> 00:22:58.345 
它至少不會包含這種小的部署問題

00:22:58.912 --> 00:23:02.816 
當然這還不全是兼容性的問題

00:23:02.916 --> 00:23:08.155 
但這可以幫你使用新的API

00:23:09.389 --> 00:23:13.627 
我確實想要用這個
怎麼辦呢?

00:23:14.261 --> 00:23:17.731 
我們添加了新的
#available條件

00:23:18.532 --> 00:23:24.304 
在#available中
你可以列出想要測試的OS版本

00:23:24.671 --> 00:23:27.407 
最後你會用這個星號確定

00:23:27.541 --> 00:23:32.613 
是否在代碼裏沒有的新OS

00:23:32.713 --> 00:23:35.516 
你至少要在這裏診斷可用性

00:23:36.850 --> 00:23:38.519 
我已經用了If語句 

00:23:38.585 --> 00:23:42.055 
但是我可以使用克里斯剛
展示給大家的Guard語句

00:23:42.256 --> 00:23:45.592 
這是在所有的地方
都完全相同的條件邏輯

00:23:45.726 --> 00:23:46.560 
就是這樣

00:23:47.728 --> 00:23:49.630 
這是可用性檢測

00:23:49.696 --> 00:23:51.632 
我們認爲這是

00:23:51.698 --> 00:23:58.172 
讓你在項目中 自動安全使用新版OS
 新功能的不錯方法

00:23:59.072 --> 00:24:02.943 
稍後 我們會介紹更多詳情
我非常建議大家能來聽

00:24:05.712 --> 00:24:08.215 
接下來 我想談談協議擴展

00:24:09.149 --> 00:24:11.852 
擴展是Swift一大特色功能

00:24:12.486 --> 00:24:15.189 
我可以使用任意類型 如Array

00:24:15.489 --> 00:24:17.391 
並在其中加上我自己的方法

00:24:18.125 --> 00:24:23.463 
這一點很重要
但並不明顯

00:24:23.530 --> 00:24:26.033 
方法是核心內容

00:24:26.099 --> 00:24:31.338 
這就是類型原生API表達的方式

00:24:31.605 --> 00:24:33.073 
當我添加擴展時

00:24:33.140 --> 00:24:38.979 
我實際添加了感覺像第一類型新功能

00:24:39.379 --> 00:24:45.853 
正如該類型的設計人員已經
加上的API核心類型

00:24:46.486 --> 00:24:49.022 
這會有很多優勢

00:24:50.991 --> 00:24:54.461 
這裏我加上了Count If方法

00:24:54.528 --> 00:24:58.498 
這就會針對間隔的數組

00:24:58.699 --> 00:25:02.002 
和返回True的次數調用閉包

00:25:02.636 --> 00:25:08.008 
在這種方法中並沒有具體針對數組

00:25:08.275 --> 00:25:10.644 
這應該適用於任意集合

00:25:12.379 --> 00:25:17.551 
不過 在Swift 1
我無法用這方法來表達

00:25:18.118 --> 00:25:20.888 
爲將這個泛型加到任意集合中

00:25:21.221 --> 00:25:23.023 
我必須要編寫像這個樣子的編碼

00:25:24.491 --> 00:25:28.395 
正如很多人所指出的那樣
這並不絕對優化

00:25:28.896 --> 00:25:32.833 
首先 這裏有很多額外的句法

00:25:32.966 --> 00:25:36.904 
在其中所有這些尖角括號中有些盲區 

00:25:36.970 --> 00:25:40.040 
所有這些額外的外殼構成了這個泛型

00:25:41.275 --> 00:25:44.511 
其二 這不再是一種方法

00:25:45.312 --> 00:25:47.247 
因爲首先它不再是方法

00:25:47.347 --> 00:25:50.884 
它不再像使用該類型的自然部分

00:25:51.518 --> 00:25:54.121 
第二 它很難被發現

00:25:54.555 --> 00:25:58.125 
它不會出現在數組的任何功能列表中

00:25:58.492 --> 00:26:04.164 
特別是它不會出現在功能列表
被完成提供的代碼中

00:26:04.665 --> 00:26:10.704 
這意味着你寫出
這麼漂亮的Count If語句 

00:26:11.238 --> 00:26:16.043 
可是使用它的人都不知道它的存在
除非你指出來

00:26:19.179 --> 00:26:20.414 
好
那我們先回來

00:26:20.747 --> 00:26:24.151 
我們有這個擴展的數組
只要把方法加到數組中即可

00:26:24.484 --> 00:26:27.487 
爲什麼我們不能擴展...
我不知道...

00:26:27.588 --> 00:26:29.656 
執行集合類型的每項內容?

00:26:30.357 --> 00:26:33.427 
在Swift 2中 
我很高興地說你可以

00:26:34.561 --> 00:26:38.966 
你可以擴展集合類型
而不是擴展數組

00:26:39.499 --> 00:26:40.334 
當你這麼做的時候

00:26:40.400 --> 00:26:46.240 
你會自動把各處的方法
加到執行集合類型的每個類型中

00:26:46.573 --> 00:26:48.642 
不僅是從標準庫中或是任何內容中

00:26:48.809 --> 00:26:55.082 
而是就在恰好
符合要求的你自己的類型中

00:26:56.283 --> 00:26:59.453 
這不僅有利於編寫自己的泛型代碼

00:26:59.520 --> 00:27:06.360 
而且我們發現這可以讓我們修改
在Swift 1中不滿意的許多內容

00:27:07.427 --> 00:27:12.432 
在Swift 1中有很多內容
都必須是全局函數

00:27:12.733 --> 00:27:16.003 
因爲它們必須是泛型
或者因爲我們寫成了泛型

00:27:16.737 --> 00:27:21.842 
更糟糕的是 爲了製作方法
我們選擇了特殊條件的部分類型

00:27:21.909 --> 00:27:25.612 
例如
數組有許多這樣的映射和過濾方法

00:27:26.079 --> 00:27:29.049 
其他類似Set的類型也許不會有

00:27:30.284 --> 00:27:34.721 
在Swift 2會有這些功能

00:27:34.955 --> 00:27:39.860 
這類過濾和映射功能
會通過擴展表達

00:27:39.960 --> 00:27:42.829 
這意味着在每個內容上都可用

00:27:43.297 --> 00:27:44.998 
還會更容易找到

00:27:45.332 --> 00:27:48.468 
這意味着使用標準庫會更爲統一

00:27:49.036 --> 00:27:51.104 
我們的確認爲大家會喜歡它

00:27:58.378 --> 00:28:01.882 
我還沒有介紹到新功能的

00:28:01.949 --> 00:28:05.519 
複雜度的三分之一

00:28:07.254 --> 00:28:11.258 
明天我們有場專門介紹
這方面內容的精彩講座

00:28:11.725 --> 00:28:14.127 
我強烈建議大家能來聽

00:28:14.194 --> 00:28:19.399 
它是關於Swift支持的協議中
傑出的新設計模式

00:28:20.334 --> 00:28:22.369 
講座的其餘部分是關於錯誤處理

00:28:23.270 --> 00:28:26.507 
我覺得很少有人
會喜歡琢磨錯誤處理

00:28:27.374 --> 00:28:29.076 
如果大家和我一樣的話

00:28:30.344 --> 00:28:34.314 
思想深處都埋藏着這樣的想法

00:28:36.483 --> 00:28:38.719 
但它真的很重要

00:28:38.785 --> 00:28:42.422 
當我們在看可以用Swift做點什麼

00:28:42.890 --> 00:28:46.760 
使其真正成爲更穩健
更具表現力的語言

00:28:47.127 --> 00:28:51.698 
我們覺得這裏最重要的問題就是
要進行錯誤處理

00:28:53.634 --> 00:29:00.440 
當我們看其他語言Cocoa
中的解決方案

00:29:01.575 --> 00:29:03.177 
我們對這些並不滿意

00:29:03.777 --> 00:29:08.282 
其中有太多問題
我們真的不很喜歡

00:29:09.316 --> 00:29:13.854 
要知道其中有些是基於自動傳播錯誤

00:29:13.921 --> 00:29:16.323 
比如Objective-C語言中的
NSError

00:29:16.390 --> 00:29:19.793 
它生成了許多重複性的容易出錯的代碼

00:29:19.860 --> 00:29:23.730 
最後你不得不到處複製

00:29:23.997 --> 00:29:26.567 
這意味着很容易出錯

00:29:26.900 --> 00:29:31.305 
更重要的是當你在自己周圍傳播錯誤時

00:29:31.772 --> 00:29:36.543 
隱形的默認行爲就是
你在忽略錯誤

00:29:37.077 --> 00:29:39.146 
而這永遠都不是正確的默認狀態

00:29:39.413 --> 00:29:42.115 
你應該至少考慮一下錯誤

00:29:43.283 --> 00:29:48.388 
從另外一個角度而言
還有些語言可以顯示傳播錯誤

00:29:48.922 --> 00:29:50.324 
例如異常處理

00:29:50.624 --> 00:29:52.893 
但是我們也不喜歡這些的效果

00:29:52.960 --> 00:29:59.933 
很顯然在這方面
人們很容易不去考慮這些錯誤 

00:30:00.000 --> 00:30:02.069 
最後你會掉到坑裏

00:30:02.936 --> 00:30:07.274 
自己也不知道到底程序裏出現哪些問題

00:30:07.474 --> 00:30:12.045 
你不明白控制怎樣會
從一處流到另一處

00:30:12.513 --> 00:30:15.482 
而且這樣也不是
安全可靠的編程模型

00:30:19.586 --> 00:30:22.422 
其實函數有三種以不同的方式出現問題

00:30:23.790 --> 00:30:28.128 
一種是許多函數以非常簡單

00:30:28.495 --> 00:30:32.499 
而明顯的方式出問題

00:30:32.999 --> 00:30:35.002 
例如 除非你在運行編譯器

00:30:35.102 --> 00:30:39.840 
你可能並不在乎爲什麼要分析
字符串失敗的整數

00:30:39.973 --> 00:30:45.279 
這種事情報告給用戶沒什麼意思
也不會有趣

00:30:45.546 --> 00:30:48.015 
也許你想直接處理

00:30:48.782 --> 00:30:51.118 
以前我們就是
這樣看待這個問題的

00:30:51.251 --> 00:30:53.820 
現在在Swift中
它得到了很好的解決

00:30:53.887 --> 00:30:55.689 
有了可選的結果

00:30:56.256 --> 00:30:58.091 
我們覺得不需要做任何事情

00:30:58.158 --> 00:31:00.060 
我們對現在的辦法很是滿意

00:31:01.695 --> 00:31:06.800 
從另外一個角度而言
在你的程序中有許多邏輯問題

00:31:07.134 --> 00:31:12.773 
比如程序 人員的錯誤
索引越界

00:31:13.073 --> 00:31:16.977 
人們使用NSException的
主要方式等等

00:31:18.812 --> 00:31:22.316 
對於這些問題
它們實際上不應該是可恢復的

00:31:22.649 --> 00:31:24.952 
當你可以恢復這類問題時

00:31:25.018 --> 00:31:30.357 
就會導致程序整體不太穩定

00:31:30.657 --> 00:31:37.164 
如果你隨機從越界索引中恢復
你不清楚程序的狀態究竟如何

00:31:37.564 --> 00:31:40.968 
你可能甚至會在應用中
產生安全問題

00:31:43.370 --> 00:31:44.771 
在中間的

00:31:45.672 --> 00:31:51.612 
是API可能出現錯誤的
各種具體情況

00:31:52.346 --> 00:31:54.281 
這些是我們真正想關注的內容

00:31:54.581 --> 00:31:58.285 
如今在Cocoa的內容
可以使用NSError 

00:32:01.788 --> 00:32:03.490 
我想給大家舉個例子

00:32:03.957 --> 00:32:06.627 
這是個預飛方式
我有某個操作需要預飛

00:32:06.693 --> 00:32:09.062 
以確定它是否可以發揮作用

00:32:09.129 --> 00:32:11.965 
我相信 很多人之前都寫過這樣的內容

00:32:12.599 --> 00:32:15.469 
我想看看是否部分文檔可以訪問

00:32:15.536 --> 00:32:18.839 
然後我會重設與操作相關的狀態

00:32:20.674 --> 00:32:23.343 
現在來看資源是否可訪問

00:32:23.410 --> 00:32:25.712 
這個操作會發生錯誤

00:32:25.979 --> 00:32:27.981 
可以出現各種各樣的錯誤

00:32:28.048 --> 00:32:29.583 
它應該報告一些內容

00:32:29.650 --> 00:32:35.255 
因爲調用者希望知道爲什麼
有些內容不可訪問

00:32:35.489 --> 00:32:38.091 
也許會根據原因進行不同的處理

00:32:40.160 --> 00:32:43.764 
如果我想使用NSError

00:32:44.598 --> 00:32:46.834 
最後代碼就會變成這樣

00:32:47.201 --> 00:32:50.904 
我會採用這個錯誤
在調用者之外進行傳播

00:32:52.773 --> 00:32:56.143 
就是這種情況

00:32:56.210 --> 00:32:58.312 
有許多問題
我們當真不喜歡

00:32:59.346 --> 00:33:02.449 
它在我的邏輯中增添了許多模板

00:33:02.983 --> 00:33:07.387 
我原本是隻有兩行的緊湊函數

00:33:07.454 --> 00:33:09.690 
結果變成這樣...

00:33:09.756 --> 00:33:13.026 
要知道其中有If語句
額外的嵌套 額外的參數

00:33:13.227 --> 00:33:14.494 
這裏有很多內容

00:33:14.761 --> 00:33:20.400 
其目的就是爲了表達有錯誤
我們正將它向調用者傳播

00:33:22.169 --> 00:33:23.971 
更糟糕的是

00:33:26.807 --> 00:33:28.008 
這裏還有個約定

00:33:28.609 --> 00:33:30.611 
你需要了解這個約定

00:33:30.677 --> 00:33:33.413 
根據這個約定
你必須手動執行才行

00:33:34.214 --> 00:33:36.350 
編譯器無法幫到你

00:33:36.416 --> 00:33:40.521 
事實上我這裏又犯了錯

00:33:40.988 --> 00:33:44.825 
在這個約定中
當你返回False時就會有錯誤發生

00:33:44.892 --> 00:33:48.028 
我檢查的時候
方法也不對

00:33:48.395 --> 00:33:51.298 
我不知道
他們怎麼會信得過我來用編譯器

00:33:54.067 --> 00:33:57.137 
我需要加上Not才能
得到我想要的行爲

00:33:58.438 --> 00:34:01.175 
好的啊 不好意思

00:34:02.442 --> 00:34:05.946 
這就是不利因素
這也是我們喜歡它的原因

00:34:07.447 --> 00:34:10.984 
首先 可以通過讀取這個代碼

00:34:11.385 --> 00:34:14.955 
檢查資源找到出現問題的部分

00:34:15.222 --> 00:34:17.491 
在名稱上就說得很清楚
這就是在說錯誤

00:34:17.791 --> 00:34:21.594 
這是顯性的錯誤處理內容
這是顯性錯誤參數

00:34:22.728 --> 00:34:27.000 
同樣很明顯地
預飛也是很容易出有問題的操作

00:34:27.201 --> 00:34:31.438 
同樣是顯性錯誤參數 返回值 等等

00:34:32.672 --> 00:34:36.810 
其三是沒有顯性控制流

00:34:37.710 --> 00:34:43.016 
我可以看着它並瞭解其中
所有的內容

00:34:43.449 --> 00:34:48.054 
我可以像人類那樣分析
而不是像編譯器那樣靜態分析代碼

00:34:48.188 --> 00:34:50.023 
作爲人類
我可以看到這個代碼

00:34:50.324 --> 00:34:51.958 
分析它在做什麼

00:34:52.458 --> 00:34:56.563 
而不需要了解
每個我在調用的函數細節

00:34:59.733 --> 00:35:00.567 
好

00:35:00.701 --> 00:35:01.935 
我們返回這個例子中

00:35:02.069 --> 00:35:03.337 
它之前是這樣

00:35:04.304 --> 00:35:07.040 
如果我用Swift編譯
會發生什麼情況？

00:35:09.610 --> 00:35:12.379 
我會受到錯誤消息
因爲我沒有處理錯誤

00:35:13.881 --> 00:35:19.586 
在Swift中有兩個組件
可用來處理錯誤

00:35:21.221 --> 00:35:26.727 
第一個是在你調用API出現問題時
必須要用Try關鍵字

00:35:27.528 --> 00:35:29.096 
Try可以交流

00:35:29.363 --> 00:35:32.266 
它主要就是便於他人讀取代碼

00:35:32.466 --> 00:35:36.270 
它與你交流道，
“這裏就是會出現問題的部分”

00:35:36.570 --> 00:35:40.040 
這是說 當你返回時
當你以後做維護的時候

00:35:40.374 --> 00:35:42.776 
我會直接...

00:35:43.644 --> 00:35:49.249 
Reset State
但並不是每次調用都需要這個函數

00:35:49.650 --> 00:35:51.718 
這裏也許還有
很重要的內容需要我知道

00:35:52.085 --> 00:35:54.721 
當我首先編寫代碼時

00:35:55.055 --> 00:35:56.590 
這是我需要考慮的問題

00:35:56.857 --> 00:36:01.962 
Reset State在我每次
退出函數時 都需要調用嗎？

00:36:02.663 --> 00:36:04.398 
對於預飛操作呢？
也許這還不夠 

00:36:06.333 --> 00:36:10.037 
我沒有以任何方式處理造成錯誤

00:36:10.404 --> 00:36:15.108 
這是因爲在Swift中
在默認狀態下 函數不可拋出

00:36:16.109 --> 00:36:19.513 
這是我們的設計的核心內容 

00:36:20.981 --> 00:36:23.984 
因爲它意味着錯誤不可避免

00:36:24.551 --> 00:36:30.724 
你不必考慮所有內容都會
像Java或C#語言那樣拋出異常

00:36:30.824 --> 00:36:32.960 
或是基本上
每種語言都在使用異常

00:36:35.128 --> 00:36:38.966 
相反 它是相當具體的內容

00:36:39.032 --> 00:36:42.069 
你知道自己需要是否要考慮將之拋出

00:36:42.269 --> 00:36:45.372 
當你在代碼中調用它們時
它會標明Try

00:36:45.672 --> 00:36:47.674 
這一組合可以交流很多

00:36:49.276 --> 00:36:53.347 
好的 假設我先要向調用者
傳播一個錯誤

00:36:53.914 --> 00:36:57.050 
爲此 我只需告知編譯器

00:36:57.117 --> 00:37:00.020 
“可以讓它把錯誤拋出”

00:37:00.721 --> 00:37:01.889 
我就會拋出

00:37:03.457 --> 00:37:05.959 
這可能不是我想要處理的方式

00:37:06.093 --> 00:37:07.828 
這是個預飛方式

00:37:08.061 --> 00:37:11.765 
我可能想容忍錯誤

00:37:11.832 --> 00:37:15.469 
告知調用方預飛是否
成功

00:37:16.570 --> 00:37:18.005 
爲此 我只能處理它

00:37:18.238 --> 00:37:21.141 
我就編寫了Do Catch

00:37:22.509 --> 00:37:24.211 
在Do中的任何代碼

00:37:24.811 --> 00:37:30.217 
其中轉發的任何錯誤都會
像過濾所一樣被捕獲

00:37:31.251 --> 00:37:33.120 
在捕獲之後會是什麼

00:37:34.721 --> 00:37:36.423 
你在開關語句中
可以編寫的任何內容

00:37:36.757 --> 00:37:42.829 
Swift的模式匹配句法
最強大之處在於它可以捕獲

00:37:44.431 --> 00:37:47.668 
作爲非常簡單的常見句法改進

00:37:48.035 --> 00:37:54.241 
這類捕獲是捕獲的短板

00:37:54.308 --> 00:37:57.477 
並會帶入這種特殊的錯誤變量

00:37:58.312 --> 00:38:00.647 
我還可以寫出更精緻的內容

00:38:00.714 --> 00:38:04.818 
例如 我可以處理某種錯誤

00:38:05.319 --> 00:38:08.288 
作爲特殊情況
也許在我的預飛中可以接受

00:38:10.657 --> 00:38:13.627 
我不知道爲什麼不存在的文檔可以接受

00:38:13.694 --> 00:38:17.731 
也許我真想看看它是否存在

00:38:18.031 --> 00:38:21.602 
出於某些許可原因它會不會真的使用

00:38:21.969 --> 00:38:23.003 
如果我想

00:38:23.136 --> 00:38:30.077 
我可以對錯誤代碼和域名
直接做像這樣的模式匹配

00:38:34.548 --> 00:38:38.619 
另外 還有第三種“處理錯誤”的方法

00:38:39.286 --> 00:38:41.555 
經常會有這種情況

00:38:42.022 --> 00:38:44.057 
你前提設置了

00:38:44.291 --> 00:38:51.031 
不應該拋出的具體調用

00:38:51.932 --> 00:38:55.469 
例如 也許這個文件在我的app束

00:38:55.802 --> 00:39:02.743 
我知道如果我無法
在自己的app束中讀取文件

00:39:03.076 --> 00:39:04.711 
那就真的有問題了

00:39:04.912 --> 00:39:07.347 
也許沒有辦法可以恢復

00:39:08.382 --> 00:39:10.017 
在這個常見模式中

00:39:10.083 --> 00:39:14.421 
你可能會需要一個致命錯誤
因爲錯誤拋出

00:39:16.023 --> 00:39:21.061 
它有個非常精簡的關聯句法 Try!

00:39:21.795 --> 00:39:24.097 
這會生成一個斷言

00:39:24.598 --> 00:39:29.603 
其中Try中的代碼
不會真正拋出

00:39:29.937 --> 00:39:32.272 
如果拋出
你的程序就會崩潰

00:39:32.339 --> 00:39:33.807 
就像是其他斷言錯誤一樣

00:39:34.474 --> 00:39:36.810 
這類問題可以很容易地調試解決

00:39:37.811 --> 00:39:39.580 
你不會總是想要用這類內容

00:39:39.646 --> 00:39:41.582 
但是當你需要它時
這非常方便

00:39:44.885 --> 00:39:45.886 
回來看一下

00:39:47.721 --> 00:39:48.689 
我捕獲一個錯誤

00:39:49.389 --> 00:39:51.391 
錯誤是什麼類型？

00:39:52.492 --> 00:39:54.328 
我們有個協議

00:39:54.461 --> 00:39:57.764 
搭建成標準庫ErrorType

00:39:59.132 --> 00:40:05.906 
你可以拋出任何滿足
ErrorType類型的值

00:40:06.540 --> 00:40:07.875 
當你捕獲到問題時

00:40:09.042 --> 00:40:13.847 
也就是模式匹配的
ErrorType任意值

00:40:14.281 --> 00:40:15.949 
我們覺得重要的是

00:40:17.050 --> 00:40:23.390 
我們不會只跟蹤是否要拋出的錯誤

00:40:23.790 --> 00:40:28.262 
這和Java不同 
你最後會有一個詳盡的清單

00:40:28.328 --> 00:40:29.997 
列出可能會拋出的所有異常

00:40:30.130 --> 00:40:34.468 
然後每次改變錯誤時
你可能都會面對這個複雜的傳播問題

00:40:36.003 --> 00:40:39.473 
跟蹤錯誤是否拋出已經足夠

00:40:39.706 --> 00:40:41.642 
幾乎一直是如此

00:40:42.009 --> 00:40:43.243 
我們認爲這是個很好的模型

00:40:45.212 --> 00:40:47.548 
你可以讓自己的類型
符合ErrorType

00:40:47.614 --> 00:40:52.319 
這個過程要比Cocoa容易得多

00:40:54.188 --> 00:40:56.823 
枚舉是表達的不錯方法

00:40:57.424 --> 00:41:00.494 
它們可以很棒地表達一組相關問題

00:41:00.861 --> 00:41:01.929 
正如它們...

00:41:03.497 --> 00:41:04.831 
要知道的確如此

00:41:04.898 --> 00:41:09.303 
因爲在枚舉中
可以關聯每個條件的數據

00:41:09.870 --> 00:41:12.339 
如果我想報告更豐富的錯誤消息

00:41:12.573 --> 00:41:15.175 
其中包括也許關於...

00:41:15.242 --> 00:41:17.411 
也許我在查看一些無效狀態

00:41:17.477 --> 00:41:20.047 
我希望記住無效狀態是什麼

00:41:20.414 --> 00:41:26.286 
我可以將特例中的相關值
直接嵌入枚舉中

00:41:28.522 --> 00:41:32.125 
爲了讓枚舉作爲錯誤可用 
你只需要讓它

00:41:32.860 --> 00:41:35.395 
符合ErrorType即可

00:41:35.829 --> 00:41:39.499 
編譯器會自動處理合成的細節

00:41:40.000 --> 00:41:45.939 
這要勝過處理生成
新NSError域名和相關內容

00:41:46.340 --> 00:41:48.375 
我們認爲當你需要的時候

00:41:48.642 --> 00:41:53.981 
這將會對大家很有幫助
在自己的代碼中表達拋出錯誤API

00:41:58.952 --> 00:42:01.388 
我們回到克里斯之前介紹的例子中來

00:42:01.922 --> 00:42:03.223 
這個JSON處理器

00:42:04.291 --> 00:42:07.761 
我用字符串中的Either返回錯誤

00:42:09.162 --> 00:42:11.899 
我們讓它看起來
更像是Swift中的效果

00:42:12.933 --> 00:42:15.969 
首先 不是用字符串

00:42:16.236 --> 00:42:21.341 
我會用剛談過的數據錯誤枚舉

00:42:22.776 --> 00:42:23.911 
我必須拋出

00:42:24.077 --> 00:42:26.747 
爲了拋出這些值 
我使用新的拋出語句

00:42:27.080 --> 00:42:28.115 
效果不錯

00:42:29.183 --> 00:42:32.152 
另一方面是我需要修改返回類型

00:42:32.219 --> 00:42:34.121 
我不再返回Either類型

00:42:34.488 --> 00:42:39.359 
對於這類問題
每個調用者爲檢查錯誤

00:42:39.526 --> 00:42:42.129 
不會對返回值認真進行微管理

00:42:43.497 --> 00:42:49.136 
我做了修改
這樣就會返回Person即拋出方式

00:42:49.469 --> 00:42:52.773 
這樣我就不必在這些小細節上操心

00:42:54.608 --> 00:42:58.011 
我們再來一個新的例子
去除我們剛生成的方法

00:42:59.947 --> 00:43:05.352 
我們來解析JSON語句
我們解析一個人

00:43:06.220 --> 00:43:12.426 
我們用它來解析
涉及此人和一些內容的整個銷售記錄

00:43:17.664 --> 00:43:22.636 
有時候碰巧你需要知道

00:43:22.703 --> 00:43:26.206 
這是個人爲的例子

00:43:26.273 --> 00:43:31.178 
不好意思
有時候我需要觀察這類進程

00:43:31.812 --> 00:43:33.614 
我需要進行某種委託

00:43:34.648 --> 00:43:38.085 
我需要讓它知道
我開始讀取銷售數據

00:43:39.820 --> 00:43:42.456 
我現在告知它
我開始讀取

00:43:42.756 --> 00:43:45.993 
顯然 我在完成讀取時
也應該告知它

00:43:47.828 --> 00:43:49.563 
我可以把代碼加在下面

00:43:49.630 --> 00:43:55.002 
問題是我在錯誤處理方面做得不對

00:43:55.369 --> 00:43:57.404 
很容易會...

00:43:57.471 --> 00:44:01.308 
如果我的委託在銷售結束時

00:44:01.642 --> 00:44:08.048 
每次都調用Careful和
Variants設置

00:44:08.649 --> 00:44:13.453 
如果我的委託有變化
它希望在兩端調用時都保持

00:44:13.687 --> 00:44:16.290 
如果我要搞糟進程
我把這事兒弄混了

00:44:16.690 --> 00:44:22.296 
這類問題常常會出現
會使得錯誤處理看似很脆弱

00:44:23.697 --> 00:44:27.534 
好的 當然
我可以這樣解決問題

00:44:30.671 --> 00:44:34.741 
只要在這些拋出站點 
Did End Reading Sale加入調用

00:44:35.542 --> 00:44:39.813 
隨後我仍沒有處理
調用Process Person

00:44:39.880 --> 00:44:42.850 
爲了做點什麼
我必須把它加入Do Catch

00:44:43.984 --> 00:44:47.487 
這相當...相當繁瑣

00:44:47.554 --> 00:44:48.856 
但是它的確容易出錯

00:44:48.922 --> 00:44:53.427 
因爲很容易
讓我增添新的代碼 新的處理方式

00:44:53.727 --> 00:44:57.898 
如果我當真做什麼的話
它就會立刻過期

00:44:58.532 --> 00:45:00.267 
如果我忘記添加

00:45:00.334 --> 00:45:05.405 
Did End Reading Sale
到這個特殊路徑

00:45:06.373 --> 00:45:08.475 
Swift 2有着更好的選項

00:45:09.042 --> 00:45:11.478 
叫做Defer

00:45:13.947 --> 00:45:16.750 
Defer語句生成一個動作

00:45:17.651 --> 00:45:19.019 
當你執行時

00:45:20.454 --> 00:45:25.959 
無論當前的範圍
是什麼動作都會 得以執行

00:45:27.094 --> 00:45:29.630 
如果我返回
如果我出現問題

00:45:29.963 --> 00:45:32.799 
如果我拋出錯誤
無論怎樣

00:45:33.600 --> 00:45:36.270 
我都知道它會得到執行

00:45:37.437 --> 00:45:40.073 
這意味着當有人讀取代碼

00:45:40.474 --> 00:45:41.909 
維護代碼時 

00:45:42.209 --> 00:45:44.411 
我會絕對有信心

00:45:44.912 --> 00:45:47.648 
無論我怎樣結束讀取銷售數據

00:45:48.115 --> 00:45:51.418 
Did End Reading Sale都會執行

00:45:52.019 --> 00:45:54.621 
這是需要掌握的重要內容

00:46:07.467 --> 00:46:09.436 
我簡要介紹一下執行情況

00:46:10.270 --> 00:46:15.175 
如果有誰習慣進行異常處理
也許會知道

00:46:15.242 --> 00:46:19.079 
在許多語言中 異常處理的執行方式

00:46:19.313 --> 00:46:23.450 
會非常受到被拋出的錯誤的影響

00:46:24.218 --> 00:46:29.122 
拋出錯誤的函數返回

00:46:29.389 --> 00:46:33.393 
也許會比按照正常方式

00:46:33.627 --> 00:46:36.797 
返回慢3個 甚至4個數量級

00:46:37.898 --> 00:46:42.703 
出於語言設計的某些方面的需要

00:46:43.337 --> 00:46:46.507 
我們並非是想在Swift中模仿什麼

00:46:49.243 --> 00:46:50.611 
大家在這裏只需要知道

00:46:50.677 --> 00:46:54.214 
Swift執行得更爲平衡

00:46:55.315 --> 00:46:59.219 
基本上更像是調用者的If語句

00:46:59.686 --> 00:47:04.791 
這是說並非完全自由地
調用可拋出錯誤的內容 

00:47:05.225 --> 00:47:07.361 
但是這意味着你不必擔心

00:47:08.729 --> 00:47:13.233 
我們的錯誤處理功能造價太高

00:47:14.501 --> 00:47:17.704 
如果出於實際情況中

00:47:17.905 --> 00:47:21.775 
對錯誤路徑 效率的考慮
有些具體原因會令你無法使用它

00:47:25.112 --> 00:47:27.748 
最後 我要說一下Swift

00:47:28.348 --> 00:47:32.619 
Swift的錯誤處理設計
在Cocoa API中可以發揮作用

00:47:33.921 --> 00:47:38.959 
我們自動識別你在Cocoa中
見到的最常用約定

00:47:39.526 --> 00:47:44.865 
例如
具備NSError Out參數的方法

00:47:44.932 --> 00:47:45.933 
並將返回Bool值

00:47:46.567 --> 00:47:48.435 
自動變爲拋出方法

00:47:48.502 --> 00:47:50.470 
Bool的返回值也會返回

00:47:51.371 --> 00:47:52.206 
同樣地

00:47:53.106 --> 00:47:54.942 
如果它返回可選結果

00:47:55.075 --> 00:48:00.180 
我們會將模式識別爲零值
表明是無效內容

00:48:01.849 --> 00:48:04.084 
因爲是零值

00:48:04.985 --> 00:48:09.756 
它就不會再返回包括在
錯誤處理之內可選結果

00:48:15.362 --> 00:48:17.831 
有着這兩條非常簡單的規則

00:48:17.931 --> 00:48:22.603 
我們發現系統的大部分API都會輸入

00:48:22.870 --> 00:48:28.408 
並自動無縫完美配合
這些新的Swift錯誤處理模型

00:48:28.809 --> 00:48:31.645 
我認爲這是在Swift中
處理錯誤的偉大新方式

00:48:34.848 --> 00:48:37.351 
我強烈推薦大家去看看

00:48:37.451 --> 00:48:39.219 
你可能沒有太多選擇

00:48:39.286 --> 00:48:40.454 
它們到處都是

00:48:44.591 --> 00:48:47.060 
要知道
我們對這個設計非常自豪

00:48:47.394 --> 00:48:52.900 
我們認爲這將極大改善
編碼的穩健性和表達性

00:48:53.133 --> 00:48:56.570 
讓你可以設計出非常不錯的API

00:48:59.306 --> 00:49:00.274 
我來總結一下

00:49:01.475 --> 00:49:04.311 
我們一直在Swift 2方面
投入大量精力

00:49:04.378 --> 00:49:06.513 
爲大家提供新的語言

00:49:06.580 --> 00:49:08.815 
通過Swift中的工具

00:49:09.383 --> 00:49:15.322 
推出Swift的編程的核心方面

00:49:16.390 --> 00:49:19.293 
爲大家提供更安全更穩健的環境

00:49:20.227 --> 00:49:22.629 
整體提高產品水平

00:49:24.898 --> 00:49:28.068 
整個過程中
對我們而言 最珍貴的工具

00:49:28.335 --> 00:49:29.837 
就是大家的反饋

00:49:30.137 --> 00:49:31.905 
我們非常非常重視這些

00:49:32.139 --> 00:49:33.540 
我承諾一定會聽取意見

00:49:35.542 --> 00:49:37.878 
如果你要告訴我們什麼

00:49:38.245 --> 00:49:40.914 
當然 大家可以僅使用
錯誤報告工具即可實現這一點

00:49:41.281 --> 00:49:46.987 
但是大家也可以聯繫
斯蒂凡·萊瑟來開發人員論壇

00:49:47.054 --> 00:49:49.056 
我們大部分人始終都會在那裏待着

00:49:49.356 --> 00:49:51.825 
我們非常樂於對任何問題進行答覆

00:49:52.125 --> 00:49:53.527 
想聽到大家的反饋

00:49:53.861 --> 00:49:56.029 
我們非常非常重視你們

00:49:57.164 --> 00:49:59.833 
非常感謝

00:50:03.036 --> 00:50:04.605 
希望大家喜歡WWDC 2015