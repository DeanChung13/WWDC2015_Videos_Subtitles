00:00:20.053 --> 00:00:23.590 
在Metal中有什麼新內容
第二部分

00:00:23.657 --> 00:00:24.491 
謝謝

00:00:28.495 --> 00:00:31.832 
早上好 歡迎來到第二部分的講座
Metal展示中有什麼新內容

00:00:32.031 --> 00:00:33.467 
我叫丹·大町市

00:00:33.867 --> 00:00:36.603 
我是蘋果GPU軟件架構團隊的工程師

00:00:37.237 --> 00:00:40.407 
今天我的同事 安娜·吉洪諾夫
和我將會談一談

00:00:40.474 --> 00:00:42.809 
基於Metal的技術

00:00:43.143 --> 00:00:46.313 
有助於在
iOS 和OS X上向你提供令人

00:00:46.380 --> 00:00:48.448 
驚歎的渲染體驗

00:00:50.717 --> 00:00:53.520 
因此這是三個講座中的第二部分

00:00:53.587 --> 00:00:56.690 
在本年度討論Metal的WWDC上

00:00:57.524 --> 00:00:58.492 
第一個講座中

00:00:58.892 --> 00:01:03.263 
羅布·多啦夫 談論了
去年對Metal的開發

00:01:04.031 --> 00:01:08.235 
他還描述了我們剛剛
發佈的Metal的新功能

00:01:09.469 --> 00:01:14.308 
他還描述了它的瘦身功能
如何與Metal應用完美匹配

00:01:16.577 --> 00:01:19.847 
在本次講座中 我首先要談到

00:01:20.180 --> 00:01:26.687 
Metalkit方便的APIs使你
更快捷地使用Metal應用

00:01:27.487 --> 00:01:32.392 
然後 安娜 將會
談論Metal性能着色器架構

00:01:32.926 --> 00:01:36.096 
在具有A8處理器的iOS設備上

00:01:36.797 --> 00:01:39.333 
它可爲可用的公用數據並行操作

00:01:39.399 --> 00:01:42.669 
提供很好的着色器

00:01:45.205 --> 00:01:46.640 
明天你將有機會

00:01:47.040 --> 00:01:50.477 
來聽取Metal性能優化技術講座

00:01:50.878 --> 00:01:54.181 
在那裏將介紹Metal系統追蹤工具

00:01:54.915 --> 00:02:00.087 
且向你提供一些有效的
Metal應用的最好的範例

00:02:03.123 --> 00:02:05.025 
現在就開始介紹用於Metal應用的

00:02:05.225 --> 00:02:07.528 
Metalkit實用功能

00:02:09.930 --> 00:02:16.003 
因爲Metal是一個低級的API
你要做許多事情來建立和運行

00:02:17.771 --> 00:02:20.274 
MetalKit希望使用這個

00:02:20.340 --> 00:02:22.609 
來爲經常使用的場景

00:02:22.843 --> 00:02:24.945 
提供有效的實現

00:02:26.013 --> 00:02:29.149 
這樣你就可以很容易創建和渲染

00:02:29.917 --> 00:02:31.952 
並且我們對標準的庫存代碼

00:02:32.019 --> 00:02:35.689 
增強了性能和穩定性

00:02:35.856 --> 00:02:37.424 
你自己就可以實現

00:02:38.158 --> 00:02:40.327 
你需要很少的維護

00:02:40.794 --> 00:02:43.530 
因爲維護的負擔從你轉到了我們

00:02:46.033 --> 00:02:49.970 
這樣MetalKit由三部分組成

00:02:50.938 --> 00:02:53.240 
第一部分是MetalKit視圖

00:02:53.841 --> 00:02:57.644 
一個介於iOS
和OSX之間的統一的視圖類

00:02:58.212 --> 00:02:59.580 
用於渲染你的Metal場景

00:03:01.114 --> 00:03:03.083 
第二部分是紋理載入器

00:03:03.684 --> 00:03:08.989 
用於創建磁盤上的圖像文件的紋理對象

00:03:09.957 --> 00:03:13.493 
最後
Metal Kit的模塊I/O集成

00:03:13.861 --> 00:03:17.164 
上載和管理
來自Metal渲染的網格數據

00:03:20.501 --> 00:03:25.572 
MetalKit視圖是獲Metal
視頻渲染的最簡單的方法

00:03:27.407 --> 00:03:31.144 
它是iOS和OS X的統一類

00:03:32.012 --> 00:03:35.749 
它在這個兩個操作
系統上提供了幾乎相同的接口

00:03:36.149 --> 00:03:42.289 
但是它本身是iOS的UI視圖
的子類以及OSX上的NS視圖的子類

00:03:44.725 --> 00:03:48.462 
它的主要工作是
爲你管理可顯示渲染目標

00:03:49.396 --> 00:03:51.265 
並且爲這些渲染目標

00:03:51.331 --> 00:03:53.534 
自動產生渲染路徑描述符

00:03:55.936 --> 00:03:59.206 
它的超級靈活之處在於

00:03:59.273 --> 00:04:02.209 
它可以執行你的繪製代碼

00:04:03.443 --> 00:04:06.079 
你可以使用一個基於定時器的模式

00:04:06.213 --> 00:04:09.216 
該模式可以在有規律的間隔內

00:04:09.449 --> 00:04:11.618 
與顯示同步執行你的繪製代碼

00:04:12.819 --> 00:04:14.288 
或者你可以使用基於事件的模式

00:04:14.354 --> 00:04:18.158 
每當發生觸摸或UI事件時
該模式在就將觸發你的繪製代碼

00:04:18.225 --> 00:04:20.093 
這樣你就可以對那個事件做出響應

00:04:21.060 --> 00:04:22.162 
最後也許你可以在

00:04:22.229 --> 00:04:27.067 
你的幀頻率下第二線程上的開放環路下

00:04:27.701 --> 00:04:29.102 
驅動你的繪製代碼

00:04:32.072 --> 00:04:35.676 
因此有兩種
方法使用MetalKit視圖

00:04:37.144 --> 00:04:39.580 
最簡單的方法是執行一個代表

00:04:39.713 --> 00:04:42.549 
來處理你的繪製及重新調整運行的大小

00:04:43.350 --> 00:04:46.687 
在這個實例中
你可以執行在視圖中繪製方法

00:04:47.221 --> 00:04:50.390 
來處理你的包括對任何渲染命令編碼

00:04:50.724 --> 00:04:52.459 
的每幀的更新

00:04:53.861 --> 00:04:57.464 
你還可以執行按尺寸佈局視圖的方法

00:04:58.599 --> 00:05:00.834 
來處理你的視圖的尺寸的改變

00:05:01.502 --> 00:05:04.705 
在這裏你可以更新投影矩陣

00:05:05.005 --> 00:05:06.940 
或者改變紋理的大小

00:05:07.007 --> 00:05:09.376 
以更好地匹配你的顯示區域

00:05:10.844 --> 00:05:15.315 
如果你有其它的需要改寫的視圖

00:05:16.183 --> 00:05:18.552 
可將MetalKit視圖設爲子類

00:05:19.620 --> 00:05:21.321 
在iOS的這個實例中

00:05:21.655 --> 00:05:23.757 
你將要改寫繪製矩形方法

00:05:25.125 --> 00:05:26.460 
來處理你的每幀更新

00:05:27.327 --> 00:05:30.330 
以及佈局視圖方法來處理大小調整

00:05:31.164 --> 00:05:33.834 
同樣的在OSX上你要處理

00:05:34.101 --> 00:05:36.637 
你要改寫這兩種方法繪製矩形

00:05:36.703 --> 00:05:38.805 
和設置楨大小方法

00:05:44.845 --> 00:05:49.750 
在這裏有個設置視圖控制器的例子

00:05:49.950 --> 00:05:53.153 
也可以作爲我們視圖的代表

00:05:54.454 --> 00:05:59.660 
在視圖無法加載方法中
我們在接收到針對視圖的一個引用後

00:06:00.561 --> 00:06:02.963 
我們將我們自己指定爲代表

00:06:06.900 --> 00:06:11.438 
在OS上特別重要的是我們需要選擇

00:06:11.505 --> 00:06:13.373 
和設置一個Metal設備

00:06:15.375 --> 00:06:18.078 
一旦我們完成了 我們就可以配置

00:06:18.145 --> 00:06:19.980 
一些視圖的功能包括

00:06:20.314 --> 00:06:23.517 
針對色彩、深度和模板緩衝

00:06:23.584 --> 00:06:24.852 
的自定義像素格式

00:06:27.054 --> 00:06:28.655 
我們還可以通過將

00:06:28.722 --> 00:06:32.526 
採樣計數功能增加
到數值1以上來使用多重採樣

00:06:34.695 --> 00:06:37.231 
或者我們還可以
設置我們的自定義清除色彩

00:06:41.201 --> 00:06:45.639 
這裏有個實現每幀更新的

00:06:45.806 --> 00:06:48.575 
MetalKit視圖
的最基本的使用方法

00:06:49.510 --> 00:06:53.447 
在我們的繪製視圖方法中
我們叫做視圖渲染

00:06:53.714 --> 00:06:55.916 
是render
past descriptor

00:06:55.983 --> 00:06:59.653 
你首次訪問每個畫面的這個功能

00:07:00.087 --> 00:07:02.523 
該視圖就會調用核心動畫

00:07:02.823 --> 00:07:04.658 
並且獲得一個可繪製返回

00:07:05.259 --> 00:07:08.395 
在這裏你可以
對渲染命令編碼來進行渲染

00:07:10.497 --> 00:07:12.966 
這樣我們就渲染了
我們最終的render pass

00:07:13.467 --> 00:07:15.202 
就會在這個可繪製中展現出來

00:07:16.670 --> 00:07:18.939 
然後我們就將展現這個可繪製

00:07:19.006 --> 00:07:20.741 
它保存在視圖的當前的可繪製功能中

00:07:21.808 --> 00:07:23.343 
並且我們將提交我們的指令緩衝器

00:07:25.045 --> 00:07:26.914 
因爲構建你的每幀更新很重要

00:07:27.281 --> 00:07:30.384 
讓我花一分鐘

00:07:30.651 --> 00:07:33.053 
來說說管理這些可繪製

00:07:34.588 --> 00:07:36.890 
這樣這個系統中有有限的可繪製

00:07:37.424 --> 00:07:40.027 
都由核心動畫來管理

00:07:41.562 --> 00:07:44.164 
由於它們通常只有幾個 因爲

00:07:44.231 --> 00:07:45.566 
它們的大小佔用了一些空間

00:07:46.567 --> 00:07:49.269 
這些可繪製通過許多級別的

00:07:49.603 --> 00:07:52.472 
顯示管道層被同時使用

00:07:53.907 --> 00:07:55.209 
這裏大致說下它是如何工作的

00:07:55.642 --> 00:07:57.644 
首先
你的應用程序對要在可繪製上渲染的

00:07:57.711 --> 00:07:58.912 
指令進行編碼

00:08:00.013 --> 00:08:02.216 
當你的應用程序對下個幀進行編碼時

00:08:02.583 --> 00:08:05.652 
它將那個可繪製向下發送到GPU

00:08:05.886 --> 00:08:09.690 
GPU對那個畫面進行渲染 核心動畫

00:08:09.756 --> 00:08:11.592 
在這個階段可以和其他層一起

00:08:11.658 --> 00:08:15.028 
對那個可繪製進行合成

00:08:17.364 --> 00:08:19.666 
最後顯示器獲取了可繪製

00:08:19.733 --> 00:08:21.001 
把它放在屏幕上

00:08:21.969 --> 00:08:24.004 
顯示器不能用任何東西來替代它

00:08:24.071 --> 00:08:25.806 
直到可獲得另一個可繪製

00:08:26.106 --> 00:08:29.109 
如果前面的任何階段花費了很長時間

00:08:29.409 --> 00:08:31.178 
它只能等一會兒

00:08:31.612 --> 00:08:36.817 
顯示器不能將那個可繪製反向循環

00:08:36.884 --> 00:08:38.952 
直到你的幀上有它有可用的東西

00:08:42.322 --> 00:08:47.528 
讓我們來看看
你的帶有這些可繪製的應用框架

00:08:49.296 --> 00:08:51.732 
首先你調用保留有一個 可繪製的

00:08:51.798 --> 00:08:54.268 
MetalKit視圖當前渲染描述符

00:08:57.070 --> 00:09:00.107 
然後用你想要的渲染
指令對那個可繪製進行編碼

00:09:00.774 --> 00:09:06.413 
最後你呈現和提交
那個會將它發回到核心動畫中的可繪製

00:09:07.981 --> 00:09:11.985 
一切都好如果我們只是渲染一個
單獨的render pass

00:09:12.753 --> 00:09:16.256 
但是很有可能我們將做其他的操作

00:09:18.058 --> 00:09:20.994 
如一些應用邏輯對

00:09:22.196 --> 00:09:26.300 
無須可繪製 用offscreen
render pass進行編碼

00:09:27.734 --> 00:09:31.171 
或運行一些
物理計算核心程序或其他程序

00:09:33.640 --> 00:09:37.411 
在這種情況下
我們本質上是在佔用我們未來可繪製

00:09:37.811 --> 00:09:39.346 
因爲在後續幀中

00:09:39.613 --> 00:09:41.815 
我們會調用這個當前的渲染描述符

00:09:42.249 --> 00:09:43.750 
它會呆在那兒

00:09:43.851 --> 00:09:47.454 
等待成爲可用的 可能等不到

00:09:47.521 --> 00:09:50.858 
因爲我們正在做其它的操作並且將它

00:09:50.924 --> 00:09:52.526 
保留了比我們所需的更長的時間

00:09:52.593 --> 00:09:54.228 
因此要解決這個問題

00:09:54.862 --> 00:09:59.867 
讓我們在訪問當前渲染描述符之前
進行這些操作

00:10:00.434 --> 00:10:04.304 
我們注意到這不是

00:10:04.404 --> 00:10:05.839 
MetalKit特有的問題

00:10:05.906 --> 00:10:11.078 
如果你在直接訪問核心動畫的時候
滾動視圖 你會注意到這個問題

00:10:12.179 --> 00:10:17.651 
因此在任何情況下這種信息都很有用

00:10:18.519 --> 00:10:23.190 
這裏有個每幀渲染更新的更完整的例子

00:10:23.824 --> 00:10:27.327 
首先 如所述我們想要
更新我們的應用程序的渲染狀態

00:10:28.061 --> 00:10:30.097 
對任何的offscreen
passes進行編碼

00:10:30.163 --> 00:10:31.999 
做任何我們不需要 可繪製的東西

00:10:34.101 --> 00:10:36.203 
然後我們就能夠繼續像以前那樣

00:10:36.670 --> 00:10:39.206 
獲取當前渲染通道描述符

00:10:39.273 --> 00:10:42.276 
爲最終的pass的指令進行編碼
然後呈現和提交我們的指令緩衝器

00:10:43.010 --> 00:10:45.646 
關鍵點是這兩個階段

00:10:45.846 --> 00:10:48.248 
越靠近越好

00:10:49.016 --> 00:10:52.152 
它是我們保持資源的臨界區段

00:10:52.719 --> 00:10:55.055 
我們不想將它保留時間過長

00:10:57.624 --> 00:10:58.825 
關於視圖的就說這麼多

00:11:00.227 --> 00:11:01.895 
讓我們開始討論紋理載入器

00:11:04.131 --> 00:11:06.033 
紋理載入很簡單

00:11:07.100 --> 00:11:11.338 
你給一個引用
然後你就得到一個成形

00:11:11.672 --> 00:11:12.840 
的Metal紋理

00:11:14.141 --> 00:11:18.579 
它不只是簡單而且功能齊全

00:11:19.646 --> 00:11:22.216 
它異步解碼文件

00:11:22.983 --> 00:11:26.486 
並且在分別的線程上創建紋理

00:11:27.921 --> 00:11:31.325 
它支持許多通用圖像文件格式包括

00:11:31.391 --> 00:11:36.230 
JPG、TIF和PNG還支持PVR

00:11:36.330 --> 00:11:38.632 
和KTX紋理文件格式

00:11:38.999 --> 00:11:41.068 
這些格式的有趣之處

00:11:41.568 --> 00:11:43.203 
是它們以原始形式保存數據

00:11:43.270 --> 00:11:47.107 
並且可以上傳到你的Metal紋理中

00:11:47.174 --> 00:11:48.609 
不需要任何的改變

00:11:49.543 --> 00:11:53.580 
另你可以將MIT maps數據編碼

00:11:54.314 --> 00:11:57.484 
成其他類型的紋理

00:11:57.551 --> 00:12:01.355 
包括3D紋理、立體地圖
和紋理數組

00:12:06.026 --> 00:12:07.194 
它的用法很簡單

00:12:08.729 --> 00:12:10.964 
首先我們通過提供一個設備

00:12:11.431 --> 00:12:13.400 
來創建了一個紋理上載器對象

00:12:15.202 --> 00:12:20.374 
然後一旦我們有了那個紋理上載器對象
我們就能用它創建許多的紋理

00:12:21.175 --> 00:12:25.646 
首先提供一個圖像文件的URL地址

00:12:26.747 --> 00:12:28.849 
然後就可提供許多的選項 

00:12:28.916 --> 00:12:33.020 
包括 如何處理文件中的sRGB信息

00:12:33.220 --> 00:12:36.290 
或者是我們是否想
在創建這個紋理的時候

00:12:36.523 --> 00:12:37.991 
爲MIT maps分配內存

00:12:39.693 --> 00:12:42.496 
最後我們要提供一個完成處理塊

00:12:42.930 --> 00:12:44.631 
只要紋理載入器已經完成了

00:12:45.098 --> 00:12:48.969 
上載紋理並且創建了它
就會執行塊

00:12:49.169 --> 00:12:52.639 
它會將紋理處理器發回給你
你可以將它保存在以後

00:12:53.140 --> 00:12:55.676 
需要時用來渲染

00:12:57.344 --> 00:12:59.379 
紋理載入器非常簡單

00:12:59.513 --> 00:13:01.949 
讓我們繼續進行Model I/O

00:13:04.952 --> 00:13:07.154 
模型I/0是一個新的結構是與

00:13:07.221 --> 00:13:09.790 
iOS 9和OS X
El Capitan一塊引入的

00:13:11.225 --> 00:13:12.960 
它的一個關鍵特點是

00:13:13.060 --> 00:13:17.698 
它可以爲你上載許多的模型文件格式

00:13:18.999 --> 00:13:21.768 
如果你需要可以爲你專門格式創建

00:13:21.969 --> 00:13:25.005 
你自己的導入器和導出器

00:13:27.007 --> 00:13:28.242 
這裏非常酷的特點是

00:13:28.642 --> 00:13:33.013 
做offline baking操作

00:13:33.814 --> 00:13:38.018 
可創建靜態環境光遮蔽地圖生成光照圖

00:13:39.052 --> 00:13:42.055 
它還包括你的網格的立體像素化

00:13:43.457 --> 00:13:48.462 
它提供了一種集中於你的渲染代碼

00:13:48.529 --> 00:13:49.630 
和寫入你的着色器的方法

00:13:49.696 --> 00:13:52.266 
你不需要創建一些parchers

00:13:52.332 --> 00:13:53.700 
來將一些東西從磁盤中取出

00:13:53.767 --> 00:13:57.104 
你必須少和串行打交道

00:13:57.771 --> 00:14:00.607 
你只需要上載一個
帶有Model I/O的模型文件

00:14:01.642 --> 00:14:03.577 
把它放入你可用它做渲染的一些構成中

00:14:04.244 --> 00:14:06.813 
開始寫入你的着色器

00:14:09.650 --> 00:14:12.152 
MetalKit
在這種情況下提供了什麼

00:14:12.219 --> 00:14:15.455 
它的程序有效使用
Metal的Model I/O

00:14:16.790 --> 00:14:20.561 
它提供了將Model I/O
網格優化上載到Metal緩衝器中

00:14:21.695 --> 00:14:25.933 
MetalKit
對象內部的網格數據封裝

00:14:27.000 --> 00:14:29.803 
有許多函數用於爲網格數據

00:14:30.537 --> 00:14:31.672 
的Metal管道做準備

00:14:34.741 --> 00:14:38.145 
讓我來指導

00:14:38.245 --> 00:14:42.482 
如何用Model I/O
來上載一個模型文件的步驟

00:14:43.517 --> 00:14:46.019 
並且用Metal來將它渲染到屏幕上

00:14:48.388 --> 00:14:49.690 
這裏就是我們要採取的步驟

00:14:53.861 --> 00:14:58.932 
首先創建一個Metal渲染狀態管道

00:14:58.999 --> 00:15:01.869 
我們將用來創建我們的網格
來渲染我們的網格

00:15:03.604 --> 00:15:06.240 
然後通過初始化
Model I/O asset

00:15:06.340 --> 00:15:08.942 
用asset來上載模型文件

00:15:10.777 --> 00:15:14.448 
我們就可以創建MetalKit網格

00:15:14.515 --> 00:15:16.083 
以及子網格對象

00:15:17.484 --> 00:15:19.853 
最後用Metal來渲染那些對象

00:15:22.623 --> 00:15:26.159 
因此集中於創建
一個Metal渲染狀態管道

00:15:27.327 --> 00:15:29.429 
我們要特別注意

00:15:29.763 --> 00:15:31.498 
創建一個頂點描述器

00:15:31.965 --> 00:15:37.971 
該描述器將會對需要的網格
提供給管道的頂點的佈局進行描述

00:15:39.473 --> 00:15:43.210 
這裏是頂點着色器的基本內容

00:15:45.379 --> 00:15:48.248 
它使用限制符級基本上

00:15:48.315 --> 00:15:51.785 
說明瞭我們每個頂點的輸入它們的佈局

00:15:52.319 --> 00:15:55.656 
用我們的objective-C代碼
使用頂點描述符

00:15:56.757 --> 00:15:58.158 
對着色器以外進行描述

00:15:59.626 --> 00:16:02.396 
它使用了這裏所定義的

00:16:03.564 --> 00:16:04.865 
頂點輸入架構

00:16:06.099 --> 00:16:09.403 
這個頂點輸入架構的主要部分是

00:16:09.503 --> 00:16:12.973 
這些功能
我們要使用這些指數來連接

00:16:13.040 --> 00:16:16.310 
Objective-C
編碼的外部和內部

00:16:17.144 --> 00:16:23.684 
注意這些浮點矢量
類型定義了數據在着色器中的樣子

00:16:24.351 --> 00:16:27.387 
不是實際上數據從我們的

00:16:27.454 --> 00:16:29.356 
Objective-C編碼送入

00:16:29.423 --> 00:16:30.691 
着色器的樣子

00:16:38.899 --> 00:16:41.235 
對此需要創建一個頂點描述符

00:16:43.070 --> 00:16:46.240 
我將把這個頂點輸入結構

00:16:46.306 --> 00:16:49.743 
放在這作爲參考但是我要提醒你

00:16:49.810 --> 00:16:53.380 
它定義的不是被送入到着色器時

00:16:53.447 --> 00:16:54.715 
的數據的佈局

00:16:55.115 --> 00:17:01.188 
我們實際上創建的是下面
的Metal頂點描述符

00:17:01.822 --> 00:17:06.260 
我們要做的是針對屬性0

00:17:08.729 --> 00:17:15.068 
用三個浮點 三個浮點值

00:17:16.002 --> 00:17:17.271 
來定義這個位置

00:17:17.738 --> 00:17:23.210 
對於屬性1 色彩將由

00:17:23.277 --> 00:17:26.747 
四個無符號的字符組成

00:17:26.980 --> 00:17:29.650 
不是上面的四個浮點 四個無符號字符

00:17:29.917 --> 00:17:31.385 
它緊接在位置數據之後

00:17:32.519 --> 00:17:36.823 
有12個比特的相位差

00:17:41.094 --> 00:17:44.531 
對於屬性2的紋理座標

00:17:45.399 --> 00:17:49.036 
我們將定義它用了兩個半浮點

00:17:50.637 --> 00:17:55.742 
它緊跟在位置和顏色數據之後

00:17:55.843 --> 00:17:57.544 
有16比特的相位差

00:17:59.913 --> 00:18:04.384 
通過將
緩存器的stride設置設爲20

00:18:04.651 --> 00:18:05.819 
將每個頂點的大小

00:18:05.886 --> 00:18:07.654 
規定爲20比特

00:18:12.059 --> 00:18:15.729 
這樣就定義了我們的頂點陣列

00:18:15.796 --> 00:18:17.698 
內的每個頂點的佈局

00:18:21.368 --> 00:18:23.570 
這樣我們就得到了
我們的Metal頂點描述符

00:18:23.971 --> 00:18:26.106 
我們能夠將
它分配到我們的渲染狀態管道

00:18:27.641 --> 00:18:31.011 
並且用渲染
對不起 用渲染管道描述符

00:18:31.311 --> 00:18:34.248 
我們就能夠
創建一個Metal渲染狀態管道

00:18:36.617 --> 00:18:39.586 
現在我們開始上載我們的asset

00:18:41.388 --> 00:18:44.591 
用Model I/O來完成那個任務

00:18:46.326 --> 00:18:49.029 
我們實際上使用我們在

00:18:49.096 --> 00:18:50.364 
前一步創建的頂點描述符

00:18:51.331 --> 00:18:55.068 
一個MetalKit網格緩衝器對象

00:18:55.502 --> 00:18:58.005 
一個網格緩衝器分配器對象

00:18:59.339 --> 00:19:00.874 
在我們繼續向下講時

00:19:01.441 --> 00:19:03.877 
我多說幾句強調一下它的重要性

00:19:06.547 --> 00:19:11.418 
Model I/O頂點描述器

00:19:11.685 --> 00:19:14.521 
以及Metal頂點描述器非常類似

00:19:15.689 --> 00:19:18.659 
但是儘管
Model I/O頂點描述器描述了

00:19:18.725 --> 00:19:20.794 
網格內的頂點屬性的佈局

00:19:22.663 --> 00:19:24.998 
但是Metal頂點描述器描述了

00:19:25.065 --> 00:19:27.167 
作爲渲染狀態管道的輸入

00:19:27.668 --> 00:19:29.169 
的頂點屬性的佈局

00:19:30.537 --> 00:19:33.707 
它們專門設計成看起來相似

00:19:34.441 --> 00:19:38.512 
因爲它們包含屬性和緩衝器佈局對象

00:19:39.379 --> 00:19:44.952 
原因是這樣就簡化了
將一個對象翻譯成另一個的過程

00:19:47.354 --> 00:19:51.758 
在Model I/O頂點
描述器中的每個屬性

00:19:52.025 --> 00:19:53.861 
都有一個可識別的字符串庫名稱

00:19:54.828 --> 00:19:59.433 
Model I/O分配了一個
缺省的名稱 如果模型內不存在

00:19:59.499 --> 00:20:03.237 
或者是那個模型文件不支持這些名稱

00:20:03.770 --> 00:20:08.041 
這些名稱包括位置、
法向量、紋理、座標顏色等

00:20:09.376 --> 00:20:11.512 
Model I/O用
基於MDLVertex

00:20:11.578 --> 00:20:14.748 
屬性常數的字符串來定義這些

00:20:15.849 --> 00:20:19.887 
有許多文件
包括你可以自定義那些名稱的

00:20:19.953 --> 00:20:23.123 
Alembic文件格式

00:20:23.857 --> 00:20:26.960 
注意 如果你要改變名稱

00:20:27.027 --> 00:20:31.798 
你需要用那些
自定義名稱來訪問這些屬性

00:20:33.734 --> 00:20:39.072 
所以我們建議你創建一個
自定義Model I/O頂點描述器

00:20:39.139 --> 00:20:42.376 
因爲在缺省下
Model I/O上載的頂點

00:20:42.576 --> 00:20:43.810 
爲高精度

00:20:44.077 --> 00:20:47.181 
而且佔用大量內存的浮點類型

00:20:48.182 --> 00:20:52.452 
這是使用
Model I/O的優勢之一

00:20:52.920 --> 00:20:58.926 
你實際上可以上載一個模型格式

00:20:58.992 --> 00:21:03.463 
具有你所喜愛的任何形式的頂點數據

00:21:03.530 --> 00:21:06.600 
將那個數據變成你能夠實際使用的格式

00:21:07.301 --> 00:21:09.770 
在這種情況下我們想用最小的類型

00:21:10.137 --> 00:21:11.205 
提供給管道

00:21:11.605 --> 00:21:13.941 
以滿足你們的精確性要求

00:21:14.174 --> 00:21:17.678 
這將提高你們的頂點帶寬效率

00:21:18.045 --> 00:21:20.714 
當你們在將每個頂點提供給管道的時候

00:21:21.081 --> 00:21:23.083 
你實際上不想要一個膨脹的頂點

00:21:25.886 --> 00:21:28.689 
這裏就是我們前面定義的

00:21:28.755 --> 00:21:30.891 
當創建我們的
Metal頂點描述符時的佈局

00:21:33.560 --> 00:21:37.197 
現在我們通過從Metal中調用
MTKModel I/O頂點格式

00:21:37.598 --> 00:21:42.569 
來創建我們的
Model I/O頂點描述符

00:21:43.303 --> 00:21:45.439 
我們所提供
我們的Metal頂點描述符

00:21:45.706 --> 00:21:51.545 
就構建了這個Model I/O
頂點描述符的大部分

00:21:52.379 --> 00:21:55.716 
然而我們還需要
爲每個屬性標個名字

00:21:55.782 --> 00:21:59.152 
這樣Model I/O
就知道我們談論的是什麼

00:22:00.053 --> 00:22:03.590 
因此對於屬性0我們用頂點

00:22:03.657 --> 00:22:06.226 
屬性位置名稱來標記

00:22:07.461 --> 00:22:10.764 
類似地如屬性1和2 我們用

00:22:10.831 --> 00:22:13.700 
顏色和紋理座標屬性來做標記

00:22:17.371 --> 00:22:20.107 
這裏我們要做的另外的事是我們要創建

00:22:20.340 --> 00:22:24.478 
一個MetalKit
並且我們會提供一個Metal設備

00:22:25.012 --> 00:22:29.383 
這個對象所做的
就是允許Model I/O來

00:22:29.917 --> 00:22:35.122 
直接將頂點
數據上載到GPU備份內存中

00:22:35.923 --> 00:22:39.059 
你不一定要使用一個
MetalKit網格緩衝器分配器

00:22:39.860 --> 00:22:44.198 
但是它所做的是爲網格內的

00:22:44.665 --> 00:22:49.870 
這些頂點和指標緩衝器分配系統內存

00:22:50.137 --> 00:22:53.574 
當你想真的要渲染它
我們需要從系統內存拷貝到

00:22:53.640 --> 00:22:56.743 
GPU備份內存中

00:22:56.810 --> 00:23:01.615 
因此爲了更有效最好使用這些網格

00:23:01.715 --> 00:23:05.018 
緩存分配器中的一個
這裏我們要說下如何使用它

00:23:06.119 --> 00:23:08.422 
我們要上載我們的asset文件

00:23:10.090 --> 00:23:13.126 
我們將提供URL地址

00:23:15.295 --> 00:23:17.231 
將會告訴Model I/O如何對

00:23:17.297 --> 00:23:20.000 
每個頂點進行佈局的
Model I/O頂點描述符

00:23:21.368 --> 00:23:24.404 
我們還將提供該網格緩存分配器

00:23:25.005 --> 00:23:27.941 
這樣Model I/O
就能直接上載數據到

00:23:28.008 --> 00:23:29.142 
GPU備份內存中

00:23:31.712 --> 00:23:33.680 
現在我們獲得的我們的asset

00:23:35.549 --> 00:23:37.918 
讓我們真正地
來創建一些MetalKit網格

00:23:37.985 --> 00:23:39.419 
以及一些網格對象

00:23:41.421 --> 00:23:43.557 
這裏是通過Model I/O

00:23:43.624 --> 00:23:46.293 
來創建asset的一個例子

00:23:47.861 --> 00:23:51.598 
在asset的內部
我們可能會有相機對象

00:23:53.200 --> 00:23:54.368 
光照對象...

00:23:55.435 --> 00:24:00.040 
以及對我們
目前非常重要的網格對象

00:24:00.307 --> 00:24:04.044 
MetalKit首先與
這些網格對象相關

00:24:04.111 --> 00:24:08.215 
它並不直接與光線
和相機對象打交道

00:24:08.282 --> 00:24:14.021 
因爲那種數據取決於
你的自定義的着色器和你的引擎

00:24:14.655 --> 00:24:19.459 
你可以真的探究這個對象
或者向內查看這個對象

00:24:19.526 --> 00:24:23.797 
取出相機和光亮信息
插入到你的着色器中

00:24:24.064 --> 00:24:27.100 
但是MetalKit並不
直接參與到那個過程中

00:24:28.068 --> 00:24:34.708 
因此我們所能做的就是
直接將這個asset

00:24:37.611 --> 00:24:42.382 
傳到這個網格中
網格來自asset類函數

00:24:42.716 --> 00:24:46.253 
將會創建MetalKit網格的陣列

00:24:51.024 --> 00:24:53.994 
讓我們看看這個網格對象內部都有什麼

00:24:55.229 --> 00:24:57.397 
首先是這些頂點緩存器

00:24:57.464 --> 00:25:00.100 
包括位置屬性

00:25:00.367 --> 00:25:04.004 
法向量屬性 紋理屬性等等

00:25:04.404 --> 00:25:07.508 
在我們的例子中 我們只需要一個陣列

00:25:07.708 --> 00:25:09.376 
因爲我們對所有我們的數據進行交錯

00:25:09.943 --> 00:25:13.614 
然而我們用多重陣列來定義佈局

00:25:13.680 --> 00:25:16.283 
因此你就會有多重頂點緩存器

00:25:16.783 --> 00:25:21.321 
你可以定義那個屬性0可以在

00:25:21.421 --> 00:25:23.957 
一個單獨陣列的內部
這樣你就會在一個陣列

00:25:24.491 --> 00:25:28.161 
中有一陣列的位置
在下一個中有一陣列的紋理座標

00:25:28.629 --> 00:25:31.398 
下一個是色彩陣列等等

00:25:35.569 --> 00:25:37.638 
該網格還包括一個定義了這個

00:25:37.704 --> 00:25:39.339 
佈局的頂點描述符

00:25:39.439 --> 00:25:41.842 
與我們初始化我們的asset時

00:25:41.909 --> 00:25:44.478 
剛剛創建的和送入的是相同的對象

00:25:46.413 --> 00:25:49.716 
網格包含有許多的子網格對象

00:25:50.083 --> 00:25:54.021 
每個子網格對象的
主要部分是這個變址緩存器

00:25:54.621 --> 00:25:58.425 
它引用頂點緩存器內部的頂點

00:26:00.027 --> 00:26:03.063 
另外你能夠使用許多屬性

00:26:03.564 --> 00:26:05.599 
來用Metal調用一個繪製

00:26:08.702 --> 00:26:14.041 
獲得了Metal kit網格
和子網格對象

00:26:16.844 --> 00:26:18.512 
讓我們繼續來渲染它們

00:26:21.582 --> 00:26:26.053 
首先我們要循環訪問每個頂點緩衝器

00:26:27.421 --> 00:26:29.723 
可能有稀疏陣列 因此需要確定

00:26:29.790 --> 00:26:32.326 
每個緩存器裏真的有東西

00:26:33.460 --> 00:26:35.896 
但是一旦我們確定了
我們就可以繼續

00:26:35.963 --> 00:26:39.700 
並且在我們的渲染
編碼器中設置頂點緩存器

00:26:40.701 --> 00:26:43.337 
頂點緩存器實際上有兩個屬性

00:26:43.570 --> 00:26:47.140 
緩存器本身
以及緩存器內部的相位差

00:26:47.608 --> 00:26:50.244 
它是你的頂點數據駐留的地方

00:26:52.079 --> 00:26:57.050 
我們還需要提供一個緩衝索引
告訴管道

00:26:57.551 --> 00:26:59.319 
數據的精確位置

00:27:01.788 --> 00:27:03.824 
就可以真正地渲染我們的網格了

00:27:04.892 --> 00:27:06.460 
我們將循環訪問每個子網格

00:27:07.895 --> 00:27:10.163 
並且調用我們的繪製指數基元

00:27:11.131 --> 00:27:13.166 
注意這個子網格具有

00:27:13.700 --> 00:27:18.505 
這個繪製指數參數的所有參數

00:27:21.041 --> 00:27:25.412 
今天將這個MetalKit基本樣本

00:27:25.746 --> 00:27:28.682 
發佈到WWDC 2015網站上

00:27:29.383 --> 00:27:31.285 
我希望你們將它下載下來

00:27:31.351 --> 00:27:34.121 
它描述了許多我介紹的技術

00:27:34.521 --> 00:27:38.926 
它使用Model I/O來上載
這個塞入一個OBJ文件中的

00:27:38.992 --> 00:27:44.665 
小型飛機對象
並且創建一了個MetalKit網格

00:27:45.132 --> 00:27:47.234 
並且將它在屏幕上進行渲染

00:27:47.534 --> 00:27:51.171 
這樣你就能明白究竟如何去做

00:27:51.672 --> 00:27:53.640 
我鼓勵你們多看看

00:27:56.210 --> 00:27:58.545 
我的就這麼多
我叫丹·大町市

00:27:58.612 --> 00:28:02.015 
如果對我今天討論的題目有什麼問題

00:28:02.082 --> 00:28:03.684 
我明天就在Metal實驗室

00:28:03.951 --> 00:28:07.287 
我想要歡迎我的同事
安娜·吉洪諾夫

00:28:07.354 --> 00:28:13.126 
上臺來談Metal性能着色器架構
謝謝

00:28:18.832 --> 00:28:19.666 
早晨好

00:28:20.267 --> 00:28:22.669 
謝謝你 丹
謝謝你的介紹 我叫 安娜

00:28:23.203 --> 00:28:26.206 
我將和你們談談Metal性能着色器

00:28:26.273 --> 00:28:27.274 
讓我們開始

00:28:27.941 --> 00:28:29.910 
首先Metal性能着色器是什麼

00:28:30.410 --> 00:28:34.214 
它是Metal內 的用於GPU的

00:28:34.281 --> 00:28:35.916 
優化性能數據並行算法

00:28:37.050 --> 00:28:38.719 
你什麼時候和爲什麼要使用它？

00:28:39.553 --> 00:28:41.388 
如果你在寫C代碼並且你要

00:28:41.455 --> 00:28:42.923 
填加一個C代碼排序算法

00:28:42.990 --> 00:28:44.691 
到你的CPU應用中

00:28:44.958 --> 00:28:49.329 
你肯定不會抓來一個就用
除非出於你自身的利益

00:28:49.963 --> 00:28:53.066 
你更有可能使用函數庫提供給你的實現

00:28:53.400 --> 00:28:58.005 
因爲它已經經過了調試和優化

00:28:59.006 --> 00:29:01.975 
同樣如果你想要在我們的平臺上

00:29:02.042 --> 00:29:05.445 
添加一個圖像處理
操作到你的CPU應用程序中

00:29:05.512 --> 00:29:07.080 
你將會使用加速架構

00:29:07.481 --> 00:29:08.715 
因爲它使用了vlmage

00:29:09.583 --> 00:29:10.717 
它是一個強大的

00:29:10.784 --> 00:29:14.988 
高性能的調整圖像處理架構

00:29:16.256 --> 00:29:19.126 
因爲它使用了CPU的向量處理

00:29:20.194 --> 00:29:21.662 
這只是幾個例子

00:29:22.529 --> 00:29:25.566 
重要的是可以爲你的CPU應用程序

00:29:25.632 --> 00:29:26.834 
提供豐富的環境

00:29:27.868 --> 00:29:30.103 
對於GPU情況有些不同

00:29:30.871 --> 00:29:32.239 
你的選擇變少

00:29:32.973 --> 00:29:34.474 
但是我們將會改變這種情況

00:29:34.908 --> 00:29:38.145 
我們的目標是豐富
我們的Metal編程環境

00:29:40.447 --> 00:29:42.683 
我們選擇了一系列的通用過濾器

00:29:42.749 --> 00:29:45.986 
我們知道這些通用過濾器通常使用

00:29:46.053 --> 00:29:47.955 
在你的圖像處理應用和遊戲中

00:29:49.723 --> 00:29:53.660 
這些算法爲iOS進行了優化並且

00:29:53.894 --> 00:29:55.963 
可以使用於A8處理器的IOS 9中

00:29:57.798 --> 00:30:00.434 
Metal性能着色器架構有兩個目標

00:30:00.801 --> 00:30:03.103 
性能和容易使用

00:30:03.337 --> 00:30:05.405 
將它設計成容易融合到

00:30:05.506 --> 00:30:06.907 
你的Metal應用中

00:30:07.474 --> 00:30:10.143 
讓它直接在Metal資源上進行操作

00:30:10.611 --> 00:30:12.079 
它們是輸入和輸出

00:30:13.180 --> 00:30:15.148 
我們不只是給你提供一批的這些高性能

00:30:15.215 --> 00:30:19.753 
優化的極好的核心程序

00:30:19.920 --> 00:30:21.688 
我們還十分關注

00:30:21.755 --> 00:30:25.125 
啓動這些核心程序的必要的宿主代碼

00:30:25.726 --> 00:30:28.028 
我們對如何將並行計算分離

00:30:28.362 --> 00:30:30.998 
的決策流程也很重視

00:30:32.032 --> 00:30:34.401 
你所要做的工作就是將這個架構的優勢

00:30:34.468 --> 00:30:36.670 
應用到你的應用程序中

00:30:36.870 --> 00:30:38.872 
通常只需要幾行的代碼

00:30:40.440 --> 00:30:42.643 
它簡單地就像是調用一個庫函數

00:30:44.211 --> 00:30:46.180 
現在我就像你們介紹這個架構

00:30:46.380 --> 00:30:48.448 
讓我們看看可用的操作

00:30:49.750 --> 00:30:52.386 
這裏是個完整的列表 我們從頭開始

00:30:52.653 --> 00:30:54.421 
實際上我只是挑幾個說

00:30:54.488 --> 00:30:55.589 
並且我還要舉例說明

00:30:57.224 --> 00:30:59.726 
首先該架構支持直方圖過濾器

00:31:00.027 --> 00:31:02.729 
直方圖均衡和規格過濾器

00:31:03.830 --> 00:31:06.099 
均衡和規格過濾器

00:31:06.567 --> 00:31:10.537 
允許你改變你的圖像

00:31:10.604 --> 00:31:12.206 
中的色彩強度的分佈

00:31:12.840 --> 00:31:15.075 
均衡過濾器是個很特殊的例子

00:31:15.542 --> 00:31:16.944 
它將當前的分佈

00:31:17.411 --> 00:31:20.013 
改變爲統一的分佈

00:31:20.881 --> 00:31:22.983 
而規格過濾器使你能夠設置

00:31:23.050 --> 00:31:24.852 
你所選擇的任何分佈

00:31:25.219 --> 00:31:27.621 
你指定將要在過濾器中使用的直方圖

00:31:30.591 --> 00:31:34.394 
這是均衡過濾器的一個例子

00:31:37.998 --> 00:31:40.200 
它增加了圖像的整體對比度

00:31:40.367 --> 00:31:43.203 
這裏它描繪的天空中的彩虹非常美麗

00:31:43.971 --> 00:31:45.439 
我想提醒的一件事是

00:31:45.839 --> 00:31:48.609 
這些過濾器並不是其本身的結束

00:31:49.576 --> 00:31:51.612 
它們可以在一個更加複雜的算法中

00:31:52.012 --> 00:31:53.480 
用作中間步驟

00:31:53.881 --> 00:31:57.284 
直方圖過濾器可以用來實現

00:31:57.351 --> 00:31:58.886 
tune mapping的中間步驟

00:31:58.952 --> 00:32:01.655 
這種技術常用於圖形開發者來

00:32:02.089 --> 00:32:05.092 
接近高動態範圍的外觀繼續

00:32:06.159 --> 00:32:09.763 
我們還支持Lancos重採樣

00:32:10.230 --> 00:32:12.466 
它是高質量的重採樣算法

00:32:12.599 --> 00:32:16.703 
可以用來縮減 放大
壓縮和拉伸圖像

00:32:18.071 --> 00:32:21.909 
在這個例子中 我垂直地拉伸圖片

00:32:22.075 --> 00:32:24.511 
並且水平地擠壓圖片同時還保存

00:32:24.578 --> 00:32:25.512 
圖像的內容

00:32:27.748 --> 00:32:29.616 
你還可以支持閥值過濾器

00:32:30.150 --> 00:32:31.952 
如果與Sobel過濾器鏈接在一起

00:32:32.085 --> 00:32:33.487 
它還可以被用來查找圖像的邊緣

00:32:35.122 --> 00:32:36.290 
讓我們來看個例子

00:32:37.824 --> 00:32:39.693 
這是閥值過濾器的輸出

00:32:40.294 --> 00:32:44.932 
現在它進入Sobel過濾器
來給你提供圖像的邊緣

00:32:46.633 --> 00:32:50.904 
最後支持整個範圍的卷積核

00:32:50.971 --> 00:32:53.841 
包括通用卷積
在這裏你可以指定你自己的

00:32:53.907 --> 00:32:55.275 
卷積矩陣

00:32:55.742 --> 00:32:57.711 
我們還支持高斯模糊

00:32:57.945 --> 00:32:59.780 
box tent和Sobel過濾器

00:33:00.180 --> 00:33:03.150 
我最後的例子將是高斯模糊

00:33:03.750 --> 00:33:05.319 
你們都應該很熟悉

00:33:05.719 --> 00:33:07.354 
我們想在我們的UL中使用

00:33:07.821 --> 00:33:09.857 
你想要在你自己的應用程序中

00:33:09.923 --> 00:33:11.425 
使用高斯模糊會怎麼樣呢

00:33:12.526 --> 00:33:15.395 
性能着色器架構會使它非常簡單

00:33:16.730 --> 00:33:17.798 
你要問有多簡單？

00:33:18.732 --> 00:33:20.601 
我預先告訴你

00:33:20.667 --> 00:33:22.703 
只有兩行代碼

00:33:23.537 --> 00:33:28.408 
首先你必須創建一個模糊過濾器對象

00:33:28.475 --> 00:33:33.347 
然後你必須將這個
過濾器編碼到指令緩存器中

00:33:37.451 --> 00:33:38.552 
謝謝大家

00:33:41.188 --> 00:33:43.924 
有一件事我想再次指出和提醒的是

00:33:44.424 --> 00:33:47.594 
API將你的通用
Metal資源看作是輸入

00:33:48.161 --> 00:33:50.030 
你的設備、你的指令緩存器、你的紋理

00:33:51.098 --> 00:33:53.433 
這些都是你已經在你的應用程序中

00:33:53.500 --> 00:33:55.169 
創建的Metal資源

00:33:57.271 --> 00:33:59.106 
現在我已經向你展示了這兩行代碼

00:33:59.540 --> 00:34:02.075 
讓我們看看它們插入到你

00:34:02.342 --> 00:34:04.278 
當前的Metal工作流程的哪個位置

00:34:04.745 --> 00:34:07.147 
這是你的指令緩存器的圖解表示法

00:34:08.447 --> 00:34:10.617 
它包括你將要提交到

00:34:10.684 --> 00:34:12.186 
設備中的所有命令

00:34:12.719 --> 00:34:14.288 
你就像平時那樣操作就行了

00:34:15.054 --> 00:34:17.157 
你通過發送繪製調用來渲染你的屏幕

00:34:18.292 --> 00:34:21.328 
你通過發送核心程序來進行效果處理

00:34:22.129 --> 00:34:26.199 
現在你已經決定
你的處理效果之一是模糊過濾器

00:34:26.934 --> 00:34:29.770 
正好是這個地方

00:34:31.938 --> 00:34:36.310 
不要忘記你還要像平時那樣
提交你的命令到設備中

00:34:36.376 --> 00:34:37.411 
這裏什麼都沒有改變

00:34:39.279 --> 00:34:43.417 
現在如果你想要看我剛纔
完成的例子中的示例代碼

00:34:43.483 --> 00:34:46.320 
你可以上網
developer.Apple.com

00:34:46.553 --> 00:34:50.056 
下載叫做Metal性能着色器的例子
世界你好

00:34:52.226 --> 00:34:53.293 
我前面已經提到過

00:34:53.360 --> 00:34:57.731 
Metal性能着色器架構
有兩個目的性能和易於使用

00:34:58.232 --> 00:35:00.300 
我剛纔展示了它是多麼容易使用

00:35:01.168 --> 00:35:03.070 
讓我們快速地看看幕後

00:35:03.537 --> 00:35:05.472 
將要告訴你的性能的祕密

00:35:07.641 --> 00:35:09.476 
對於這些過濾器的每一個

00:35:09.543 --> 00:35:13.647 
包括高斯模糊過濾器
我們要選擇恰當的算法

00:35:14.081 --> 00:35:18.852 
恰當的這裏的意思
是正確的並且是最快的

00:35:19.319 --> 00:35:24.591 
對於輸入數據、輸入參數

00:35:24.825 --> 00:35:27.361 
設備GPU的特別組合是最快的

00:35:28.262 --> 00:35:29.496 
我這樣說是什麼意思

00:35:30.364 --> 00:35:32.633 
有許多方法可以實現高斯模糊

00:35:33.100 --> 00:35:36.270 
有constant cost
log 2 linear

00:35:36.336 --> 00:35:37.738 
以及強力運算

00:35:39.273 --> 00:35:40.841 
所有這些方法的啓動費用和

00:35:40.908 --> 00:35:42.309 
日常開支都不相同

00:35:42.676 --> 00:35:45.646 
一種方法可能對於小的核半徑

00:35:45.979 --> 00:35:48.815 
非常好但在大的核半徑上表現不佳

00:35:49.983 --> 00:35:54.321 
重要的是我們要實現每一種方法

00:35:54.421 --> 00:35:57.057 
並且通過實驗來發現哪個

00:35:57.124 --> 00:35:59.459 
對於一個特別的輸入問題、輸入參數

00:35:59.526 --> 00:36:04.097 
和設備GPU的組合是最快的

00:36:05.265 --> 00:36:06.500 
在這個過程之後

00:36:07.000 --> 00:36:11.538 
所有的核都被調整成爲你的核半徑

00:36:12.439 --> 00:36:13.841 
你的像素格式

00:36:14.408 --> 00:36:16.944 
你的基礎硬件結構的存儲層次的參數

00:36:17.311 --> 00:36:19.279 
以及每個線程的像素數目

00:36:19.346 --> 00:36:21.148 
以及線程組規模的參數

00:36:21.215 --> 00:36:23.584 
這決定了如何將你的工作並行分離

00:36:25.018 --> 00:36:26.486 
最後我將會提到

00:36:27.187 --> 00:36:30.624 
該架構還爲你做CPU優化工作

00:36:32.526 --> 00:36:35.028 
它優化了程序上載速度

00:36:36.263 --> 00:36:40.634 
它還重複使用中間紋理

00:36:41.201 --> 00:36:45.072 
它還爲你做計算編碼優化

00:36:45.472 --> 00:36:47.241 
特別的是它還能察覺

00:36:47.641 --> 00:36:51.044 
你是否是在連續使用多重計算編碼器

00:36:51.111 --> 00:36:52.412 
如果是這樣它就會將它們合併

00:36:55.048 --> 00:36:57.417 
我們爲你完成了所有的這些步驟

00:36:58.418 --> 00:37:01.021 
非常酷
但以代碼的角度來看是什麼樣子

00:37:01.088 --> 00:37:03.724 
如對於我剛剛向你們展示的

00:37:03.790 --> 00:37:04.725 
優化高斯模糊着色器

00:37:07.427 --> 00:37:08.862 
好了 你準備好了麼？

00:37:09.696 --> 00:37:11.131 
這就是代碼

00:37:12.499 --> 00:37:13.534 
現在你們都知道了

00:37:13.600 --> 00:37:15.936 
如何實現你們自己的優化高斯模糊

00:37:16.203 --> 00:37:17.337 
對麼我敢打賭 你沒想到

00:37:17.404 --> 00:37:19.573 
在這個講座中能學到這個

00:37:19.840 --> 00:37:23.010 
言歸正傳這是49 Metal
kernels

00:37:23.076 --> 00:37:25.245 
2,000行的kernel代碼

00:37:25.312 --> 00:37:29.750 
以及821個不同的
Metal高斯模糊實現

00:37:30.584 --> 00:37:35.789 
每個實現都是這些49個Metal
kernels一些組合

00:37:35.856 --> 00:37:37.424 
因此看起來我們做了很多的工作

00:37:37.691 --> 00:37:38.692 
現在不必由你來做

00:37:39.493 --> 00:37:40.894 
讓我們看看

00:37:40.961 --> 00:37:44.665 
運行中的Metal性能着色器架構

00:37:51.238 --> 00:37:53.273 
首先我將演示一個簡單的

00:37:53.373 --> 00:37:58.545 
可分離高斯模糊實現的教科書

00:37:59.947 --> 00:38:01.715 
只需要1分鐘就可寫入到Metal

00:38:01.782 --> 00:38:03.951 
這可能是你剛開始時應該使用的東西

00:38:04.017 --> 00:38:05.586 
如果你要實現你的模糊

00:38:05.652 --> 00:38:08.188 
並且你手頭沒有Metal性能着色器

00:38:08.922 --> 00:38:11.258 
現在我們非常愉快地
在每秒60幀在運行着

00:38:11.325 --> 00:38:13.193 
但是我們實際上還沒有做任何工作

00:38:13.994 --> 00:38:15.195 
sigma數值是0

00:38:15.596 --> 00:38:19.399 
讓我們改變sigma數值到6

00:38:19.466 --> 00:38:21.134 
我們就降到了每秒8幀

00:38:21.969 --> 00:38:23.303 
我們還敢繼續麼

00:38:23.370 --> 00:38:24.738 
讓我們試着sigma 20

00:38:27.307 --> 00:38:30.844 
好了 現在我們降到了每秒3幀

00:38:30.911 --> 00:38:32.179 
那樣就無法工作了

00:38:33.013 --> 00:38:34.748 
讓我們轉換到Metal性能

00:38:34.815 --> 00:38:35.949 
着色器實現

00:38:37.551 --> 00:38:39.887 
現在我們返回到了每秒60幀

00:38:39.953 --> 00:38:42.789 
沒有做任何工作sigma爲6

00:38:43.423 --> 00:38:44.858 
每秒仍然是60幀

00:38:45.592 --> 00:38:46.560 
Sigma爲20

00:38:47.127 --> 00:38:48.595 
仍然是每秒60幀

00:38:49.863 --> 00:38:53.367 
我們還得繼續 真的模糊它

00:38:53.700 --> 00:38:55.169 
仍然是每秒60幀

00:38:55.235 --> 00:38:56.470 
看起來我們贏了

00:39:13.053 --> 00:39:15.322 
這樣你的屏幕刷新速率是60赫茲

00:39:17.090 --> 00:39:20.994 
這就意味着我們以每秒60幀在運行

00:39:21.061 --> 00:39:24.898 
這樣你在演示中
所看到的優化高斯模糊着色器

00:39:24.965 --> 00:39:28.335 
的性能最高是每秒60幀

00:39:29.102 --> 00:39:33.941 
這就意味着你有
16.6毫秒來畫你的幀

00:39:34.575 --> 00:39:36.543 
這還包括你的系統可能要做的

00:39:36.610 --> 00:39:38.779 
合成工作

00:39:39.813 --> 00:39:43.584 
這個圖表顯示你在不同的sigma值

00:39:43.650 --> 00:39:47.254 
的優化高斯模糊過濾器的執行時間

00:39:47.321 --> 00:39:48.422 
你可以看到執行時間

00:39:49.656 --> 00:39:52.759 
要比16.6毫秒少得多

00:39:53.794 --> 00:39:56.363 
這就意味着你仍然有額外的時間

00:39:56.430 --> 00:39:57.965 
來做多餘的GPU工作

00:39:59.499 --> 00:40:02.769 
而且仍然能達到希望的每秒60幀

00:40:05.472 --> 00:40:07.708 
現在還有一些細節需要說明

00:40:09.476 --> 00:40:12.212 
有時候你需要在很大的圖片上工作

00:40:12.279 --> 00:40:13.380 
你需要並列式顯示

00:40:14.548 --> 00:40:15.983 
有時候你需要只在你的

00:40:16.049 --> 00:40:17.317 
圖像的一部分上工作

00:40:17.718 --> 00:40:18.986 
針對那個有個機制

00:40:19.486 --> 00:40:21.889 
它叫做源偏移和
destination剪裁矩形

00:40:23.090 --> 00:40:25.626 
剪裁矩形有起始點和大小

00:40:26.193 --> 00:40:28.795 
它決定了目的紋理的區域

00:40:28.862 --> 00:40:30.697 
將由過濾器來進行更新

00:40:31.899 --> 00:40:34.334 
源偏移只有起始點

00:40:35.135 --> 00:40:37.905 
大小是隱含的
由剪裁矩形來決定的

00:40:37.971 --> 00:40:41.542 
它只是你的目的紋理的
左上角的一個相位差

00:40:42.309 --> 00:40:45.379 
它們共同工作給你提供了最後的圖像

00:40:48.448 --> 00:40:50.651 
在Metal性能着色器架構中

00:40:50.717 --> 00:40:53.654 
你的來源和目的是相同紋理中的一個

00:40:54.621 --> 00:40:56.590 
在這種情況下剪裁矩形

00:40:56.890 --> 00:40:59.560 
以同樣的方式工作

00:41:03.463 --> 00:41:06.233 
當來源和目的是相同的

00:41:06.400 --> 00:41:08.235 
我們管它叫in-place操作

00:41:08.836 --> 00:41:10.037 
用它來節約內存

00:41:11.271 --> 00:41:14.208 
你怎樣做才能對這些in-place
過濾器進行編碼呢

00:41:15.175 --> 00:41:17.878 
你必須要使用編碼命令緩衝區方法

00:41:17.945 --> 00:41:20.614 
和一個分配器
fall by back copy

00:41:22.382 --> 00:41:25.285 
有一件事要記住的是
着色器並不總是可能

00:41:25.352 --> 00:41:27.020 
運行in place

00:41:27.087 --> 00:41:28.922 
它取決於你的過濾器

00:41:28.989 --> 00:41:30.791 
過濾器參數和性能

00:41:31.425 --> 00:41:32.893 
如果你希望這個操作永遠成功

00:41:32.960 --> 00:41:35.495 
使用一個複製分配器

00:41:36.063 --> 00:41:37.664 
它就會被自動調用

00:41:38.432 --> 00:41:41.635 
除非在in place
操作不可能的情況下

00:41:42.035 --> 00:41:44.872 
我們將爲你創建一個新的目的紋理

00:41:46.206 --> 00:41:47.674 
這樣在必要情況下操作

00:41:47.741 --> 00:41:49.276 
可在out of place 進行

00:41:50.811 --> 00:41:54.214 
有簡單fall back copy
分配器的例子

00:41:55.816 --> 00:41:58.952 
這個例子只是創建了一個
新的具有相同的像素格式和大小

00:41:59.720 --> 00:42:02.823 
的目的紋理

00:42:02.890 --> 00:42:04.625 
因爲源紋理非常簡單

00:42:05.792 --> 00:42:07.961 
之前我向你們
展示了一個in place 操作

00:42:08.028 --> 00:42:10.731 
在這個操作中 你只對目的紋理的

00:42:10.797 --> 00:42:12.099 
一部分進行了更改

00:42:12.766 --> 00:42:15.869 
在剪裁矩形之外的任何東西都沒有改變

00:42:16.236 --> 00:42:18.372 
在複製分配器中你還可以這樣做

00:42:19.339 --> 00:42:21.675 
只需要用你的源紋理的環境

00:42:21.742 --> 00:42:23.544 
來初始化你的目的紋理

00:42:26.346 --> 00:42:28.615 
我還想提到的是所有常見

00:42:28.682 --> 00:42:31.118 
的Metal資源如你的設備和

00:42:31.185 --> 00:42:32.252 
你的指令緩衝器

00:42:32.319 --> 00:42:34.288 
你都可在複製分配器中獲得

00:42:35.322 --> 00:42:37.090 
現在我對細節進行了說明

00:42:37.157 --> 00:42:38.292 
讓我們來總結一下

00:42:39.660 --> 00:42:43.363 
我想說的是請使用Metal支持架構

00:42:43.430 --> 00:42:45.499 
MetalKit和Metal性能着色器

00:42:45.766 --> 00:42:47.601 
它們非常強健
它們經過優化

00:42:47.868 --> 00:42:49.002 
正如我向你們展示的

00:42:49.069 --> 00:42:51.605 
它們很容易融入
你們的Metal的應用程序中

00:42:52.005 --> 00:42:54.641 
它們會給你的應用程序帶來更多的時間

00:42:54.908 --> 00:42:57.644 
你可以把時間用在
製作獨特的應用程序上

00:42:57.911 --> 00:43:00.047 
而不是浪費在一般的工作上

00:43:00.547 --> 00:43:02.482 
另外的好處是

00:43:02.716 --> 00:43:04.952 
你可以花更少的代碼來編寫和維護

00:43:05.886 --> 00:43:10.424 
到我們的實驗室來向我們提出反饋意見
讓我們知道如何開始或者向我們提問

00:43:10.791 --> 00:43:15.963 
讓我們知道是否想讓新的工具或着色器
添加到支持架構中

00:43:17.564 --> 00:43:19.700 
你隨時可以在網上發現更多的信息

00:43:19.766 --> 00:43:21.602 
我們可以提供文檔視頻

00:43:21.969 --> 00:43:25.205 
充分利用蘋果開發論壇和技術支持

00:43:25.706 --> 00:43:26.840 
對於一般的疑問

00:43:26.907 --> 00:43:29.843 
請聯繫我們的遊戲技術大師
阿倫·謝弗

00:43:31.879 --> 00:43:35.015 
你可以在網上觀看以前的講座

00:43:35.249 --> 00:43:38.785 
但如果你想
學習新Metal性能優化技術

00:43:39.319 --> 00:43:41.688 
明天上午11:00來聽我們的講座

00:43:41.788 --> 00:43:42.623 
謝謝