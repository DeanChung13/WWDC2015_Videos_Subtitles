00:00:26.593 --> 00:00:27.728 
下午好

00:00:29.596 --> 00:00:31.064 
大家好
感謝大家能來參加講座

00:00:31.131 --> 00:00:34.001 
我是泰德·克熱梅內克
我在Apple管理Swift團隊

00:00:34.067 --> 00:00:37.704 
阿萊克斯和我很高興也很榮幸

00:00:38.138 --> 00:00:40.741 
和大家講講在編譯時使用Swift

00:00:41.141 --> 00:00:44.444 
來發現編碼的更多問題

00:00:45.212 --> 00:00:46.613 
這是個相當寬泛的話題 所以我們

00:00:46.680 --> 00:00:48.882 
所以我們決定主要談兩個問題

00:00:49.683 --> 00:00:53.654 
首先是利用Swift 2中的
新語言術語供給

00:00:54.588 --> 00:00:58.625 
以便輕鬆允許應用利用新的API

00:00:58.725 --> 00:01:00.160 
與此同時部署更早的版本

00:01:00.594 --> 00:01:02.596 
在更早的講座中
我們簡要談過這個話題

00:01:02.663 --> 00:01:04.531 
我們馬上要深入探討設計

00:01:04.598 --> 00:01:06.867 
方法的理念所解決的問題

00:01:06.934 --> 00:01:08.535 
以及如何在代碼中實現最佳應用

00:01:09.269 --> 00:01:11.138 
然後 阿萊克斯會談談如何

00:01:11.205 --> 00:01:14.441 
使用富類型系統協議和枚舉

00:01:14.508 --> 00:01:18.312 
甚至還有協議擴展
以便在在自己的代碼中

00:01:18.378 --> 00:01:20.581 
執行應用不變性
並定義解決許多應用開發模板

00:01:23.050 --> 00:01:24.685 
我們先來看第一個話題

00:01:24.751 --> 00:01:27.087 
利用新API

00:01:28.589 --> 00:01:34.761 
這類話題已經講了很多遍
很多人對此都很熟悉

00:01:35.429 --> 00:01:37.397 
對Apple而言 我們繼續在

00:01:37.464 --> 00:01:42.836 
每個OS版本中推出豐富的API

00:01:43.270 --> 00:01:46.673 
讓大家有機會在應用中構建不錯的功能

00:01:47.174 --> 00:01:50.377 
對嗎？
這是我們這麼做的部分原因 不是嗎？

00:01:51.211 --> 00:01:55.482 
這裏的謎題是app具備已有用戶 
對麼？

00:01:55.549 --> 00:01:56.783 
他們目前...

00:01:57.618 --> 00:01:59.353 
他們不必使用最新的OS

00:01:59.419 --> 00:02:01.922 
在iOS 有較快的使用率

00:02:02.322 --> 00:02:05.225 
但是這不是說人人都會立刻採用

00:02:05.325 --> 00:02:08.529 
還有些人出於各種原因完全不會使用

00:02:09.463 --> 00:02:13.100 
那麼你會面臨一系列選擇
你會怎麼做呢？

00:02:14.568 --> 00:02:15.502 
你是否會繼續

00:02:15.569 --> 00:02:18.572 
並要求app使用最新OS？

00:02:18.639 --> 00:02:22.242 
好 那你獲得所有的新API 
可這的確成問題

00:02:22.309 --> 00:02:24.411 
因爲你會搞砸

00:02:24.478 --> 00:02:25.612 
要知道 你會損失用戶

00:02:25.679 --> 00:02:27.281 
這些是會購買你的app的人羣

00:02:29.550 --> 00:02:32.085 
你是否應該走到相反的極端

00:02:32.152 --> 00:02:34.988 
控制使用新API？

00:02:35.055 --> 00:02:37.491 
這樣就會獲得所支持的

00:02:37.558 --> 00:02:39.359 
最早版本OS的最小公分母

00:02:39.593 --> 00:02:42.963 
這樣做很糟糕因爲你會影響到

00:02:43.030 --> 00:02:45.199 
原本可以向用戶提供的豐富

00:02:45.265 --> 00:02:46.099 
功能

00:02:47.167 --> 00:02:49.570 
當然 要知道有魚和熊掌兼得的辦法

00:02:49.636 --> 00:02:54.308 
可以採用新API與此同時還

00:02:54.374 --> 00:02:55.843 
可以部署更早的版本

00:02:56.844 --> 00:03:00.380 
所以很長時間以來 我們在技術上

00:03:00.480 --> 00:03:01.582 
都支持這種做法

00:03:02.482 --> 00:03:05.219 
當然 可以在Objective-C
和Swift中均可如此

00:03:05.285 --> 00:03:08.155 
可是現實中 如今這是個非常

00:03:08.222 --> 00:03:09.590 
痛苦的體驗

00:03:16.029 --> 00:03:19.700 
在Swift 2中 我們儘可能
不讓它這麼痛苦

00:03:19.766 --> 00:03:23.437 
我們通過開發人員告知的當前問題

00:03:23.670 --> 00:03:27.074 
關於部署較早版本

00:03:27.140 --> 00:03:29.109 
並設法解決語言中的問題

00:03:29.176 --> 00:03:30.410 
來實現這一點

00:03:32.412 --> 00:03:34.848 
現在基本模型並未改變 對吧？

00:03:34.915 --> 00:03:38.919 
對於開發而言在我們的平臺上

00:03:38.986 --> 00:03:40.387 
一直希望大家使用最新SDK

00:03:40.754 --> 00:03:43.624 
對嗎？這會導致應用中所有可能

00:03:43.690 --> 00:03:45.792 
用到的API都混到了

00:03:46.260 --> 00:03:47.160 
一起

00:03:47.928 --> 00:03:50.430 
然後 可以切換app的部署目標

00:03:50.497 --> 00:03:52.533 
說明你想要退回的時間

00:03:53.901 --> 00:03:55.569 
從畫面來看這樣就非常簡單

00:03:55.669 --> 00:03:57.638 
就像是版本的滑動視窗

00:03:57.704 --> 00:03:59.506 
設置最新的基底SDK

00:03:59.907 --> 00:04:02.543 
把部署目標設置到視窗的

00:04:02.809 --> 00:04:04.011 
最早版本 對麼？

00:04:04.545 --> 00:04:05.612 
從概念來講 很簡單

00:04:07.080 --> 00:04:11.752 
那麼在談到在Swift 2中 

00:04:11.818 --> 00:04:15.689 
如何採用新功能和API之前
我們先來看

00:04:15.756 --> 00:04:17.757 
現有方法中的問題

00:04:18.257 --> 00:04:21.827 
基本上而言 你必須編寫app

00:04:21.894 --> 00:04:26.033 
以便應對更早版本的主OS中
API缺失的問題 對嗎？

00:04:26.834 --> 00:04:30.504 
還有幾個問題需要單獨考慮

00:04:30.938 --> 00:04:33.707 
整個框架的缺失類方法 

00:04:33.774 --> 00:04:37.611 
函數 甚至部分枚舉值

00:04:37.978 --> 00:04:39.112 
在更早的版本中不得使用

00:04:39.613 --> 00:04:42.349 
但是令人煩心的是你必須逐一

00:04:42.416 --> 00:04:44.451 
解釋所有這些問題

00:04:45.185 --> 00:04:47.821 
對框架而言很是麻煩 要決定

00:04:47.888 --> 00:04:50.257 
我把它連接到應用時 這個

00:04:50.557 --> 00:04:52.392 
框架是可選項

00:04:52.860 --> 00:04:56.029 
如果不這樣做app就會在啓動

00:04:56.096 --> 00:04:57.564 
較早版本的OS時 出現問題

00:04:59.766 --> 00:05:02.703 
然後是API本身實際運用

00:05:02.769 --> 00:05:05.272 
我們先來看類

00:05:06.139 --> 00:05:08.275 
基本上來說你是在編寫app

00:05:08.342 --> 00:05:09.943 
因此它會有不同表現

00:05:10.043 --> 00:05:11.645 
這將是有條件的行爲

00:05:11.712 --> 00:05:15.282 
例如當新的API
可用app就會做些不同的事情

00:05:15.782 --> 00:05:18.051 
因此條件邏輯並不是問題

00:05:18.619 --> 00:05:21.788 
問題在於怎樣爲行爲實現條件化

00:05:22.956 --> 00:05:25.192 
在這張幻燈片上是用來檢測可用性的

00:05:25.259 --> 00:05:26.593 
典型方法

00:05:26.660 --> 00:05:28.929 
你來查詢
Objective-C的運行時間

00:05:28.996 --> 00:05:32.132 
這個類會在運行時間出現麼？

00:05:33.367 --> 00:05:35.636 
問題是這有點謊言的味道

00:05:35.936 --> 00:05:38.238 
對嗎？我是說類可以有

00:05:38.705 --> 00:05:41.475 
但是這不意味着你可以使用

00:05:42.376 --> 00:05:47.214 
API會經常開始是內部API 

00:05:47.948 --> 00:05:49.283 
在OS中 

00:05:49.716 --> 00:05:52.786 
它們會在生成和演進的
地方呆上一陣在對外發布時

00:05:53.220 --> 00:05:55.923 
API的行爲

00:05:56.290 --> 00:05:58.892 
可能已經完全改變

00:05:59.359 --> 00:06:01.628 
即便這樣的檢測在運行時間成功了

00:06:02.462 --> 00:06:04.431 
這也不能說明實際使用

00:06:04.498 --> 00:06:06.900 
這款API時會絕對安全

00:06:07.634 --> 00:06:13.674 
而是說 如果在OS版本上
你使用的時間太過於早 

00:06:14.141 --> 00:06:16.710 
基本上會在應用中加上定時炸彈

00:06:16.777 --> 00:06:21.949 
原本你以爲API會按照一定方式
表現 現在會完全遭到破壞

00:06:22.115 --> 00:06:24.351 
這會令開發人員多次受到打擊

00:06:24.985 --> 00:06:27.221 
因此是個嚴重問題

00:06:29.189 --> 00:06:31.992 
另一個問題是太容易出錯

00:06:32.659 --> 00:06:34.127 
來看這個新款API

00:06:34.661 --> 00:06:36.730 
通過幾項特色功能

00:06:36.930 --> 00:06:40.834 
我的代碼完全有效結果卻出了差錯

00:06:41.435 --> 00:06:45.305 
數據在NS數據資產之前很久引入的

00:06:45.572 --> 00:06:48.342 
代碼還會編譯 若在最新的OS上檢測

00:06:48.408 --> 00:06:50.143 
它甚至會成功運行

00:06:50.410 --> 00:06:53.580 
那麼只是在更早版本的設備上

00:06:53.914 --> 00:06:55.516 
運行代碼 纔會出現問題

00:06:55.616 --> 00:06:58.986 
對嗎？這與通常的測試場景完全不符

00:06:59.419 --> 00:07:01.255 
在部分情況下

00:07:01.321 --> 00:07:03.123 
只需要用戶來發現這個問題

00:07:03.824 --> 00:07:07.528 
即將出現的情況是
當你試圖使用這個類時運行時間會崩潰

00:07:09.897 --> 00:07:15.102 
很容易因爲簡單的小錯出現問題

00:07:16.570 --> 00:07:20.174 
方法和類的問題基本一樣

00:07:20.908 --> 00:07:22.910 
可能會出現輸入錯誤

00:07:23.177 --> 00:07:25.045 
如果檢測屬性的可用性

00:07:25.112 --> 00:07:27.681 
你現在必須瞭解屬性的選擇器

00:07:27.748 --> 00:07:29.650 
同時還要拼寫正確

00:07:29.750 --> 00:07:32.519 
此外語法也完全不同 對嗎？

00:07:32.586 --> 00:07:34.888 
來檢測API但是語法不一樣

00:07:36.089 --> 00:07:37.724 
函數也有着同樣問題

00:07:37.791 --> 00:07:39.626 
你會犯同樣的錯誤不過可以有

00:07:39.693 --> 00:07:41.461 
其他方式來編寫

00:07:42.196 --> 00:07:45.299 
那麼 如果有枚舉那你就被完全騙到了

00:07:45.365 --> 00:07:47.668 
你不知道 怎樣的解決方案才合適

00:07:47.734 --> 00:07:50.237 
選擇器對映射完全沒有反應

00:07:50.637 --> 00:07:54.274 
那就要手動OS版本檢測

00:07:54.708 --> 00:07:57.778 
來看這個表格感覺就像是你希望

00:07:57.845 --> 00:07:59.079 
改正的所有簿記問題

00:07:59.146 --> 00:08:00.447 
都在這裏

00:08:01.248 --> 00:08:03.717 
這是個非常傷感的故事

00:08:07.254 --> 00:08:09.456 
現在我們看到的是的確成問題的

00:08:09.523 --> 00:08:10.390 
編程模型

00:08:10.457 --> 00:08:13.227 
對嗎？技術上可行但是很難做到

00:08:13.694 --> 00:08:15.329 
我們希望你利用新款API

00:08:15.395 --> 00:08:18.465 
與此同時繼續支持所有的用戶

00:08:19.933 --> 00:08:22.569 
我們需要解決這些問題

00:08:25.005 --> 00:08:28.108 
在Swift 2中情況有所改變

00:08:28.175 --> 00:08:29.409 
把改變構建在語言當中

00:08:30.677 --> 00:08:34.615 
要以怎樣架構app爲主 那麼

00:08:35.048 --> 00:08:37.150 
有其他方法可行時可以考慮

00:08:37.251 --> 00:08:38.684 
使用這些API

00:08:38.751 --> 00:08:40.953 
你理解 會有條件性行爲

00:08:41.355 --> 00:08:42.890 
但是你會主要關注於此

00:08:43.957 --> 00:08:45.759 
然後有編譯器作爲支持

00:08:46.326 --> 00:08:49.897 
如果用不安全的方式使用API 
就會出現錯誤

00:08:51.064 --> 00:08:53.500 
還要有統一的句法這樣就不必考慮

00:08:53.567 --> 00:08:56.436 
類 方法函數甚至映射問題

00:08:56.503 --> 00:09:00.073 
這些都在所用的句法中處理好了

00:09:00.140 --> 00:09:02.676 
編譯器瞭解你該用的句法

00:09:02.743 --> 00:09:05.546 
如果你沒有做對 它會告訴你正確做法

00:09:07.681 --> 00:09:11.151 
因爲編譯器會一直參與其中

00:09:11.218 --> 00:09:12.886 
在Swift中我們使用模型

00:09:13.420 --> 00:09:16.123 
所有可選鏈接可以幫你來處理

00:09:18.759 --> 00:09:22.362 
那麼這樣效果如何
這裏是來自核心位置的部分API

00:09:24.498 --> 00:09:26.934 
比如說 我在部署iOS 9

00:09:27.201 --> 00:09:29.469 
因此使iOS 9 SDK

00:09:29.536 --> 00:09:31.505 
並設置iOS 9的部署目標

00:09:32.773 --> 00:09:35.542 
編譯器可以在SDK中看到該信息

00:09:35.609 --> 00:09:37.411 
因此這是在
Objective-C頭文件中

00:09:37.477 --> 00:09:39.947 
還可以作爲
Swift中生成的界面來查看

00:09:40.614 --> 00:09:42.716 
因此類被引入iOS 2中

00:09:43.450 --> 00:09:45.686 
方法稍後會引入iOS 8

00:09:46.620 --> 00:09:48.121 
因爲我在運行iOS 9

00:09:48.222 --> 00:09:50.457 
可以無條件使用這款API

00:09:51.558 --> 00:09:54.795 
如果我在iOS 8
部署也仍然沒有問題

00:09:55.562 --> 00:09:58.165 
但是如果我一路退回iOS 7 

00:09:58.599 --> 00:10:01.034 
編譯器可以看到
正如我們可以在幻燈片上看到

00:10:02.002 --> 00:10:04.438 
使用這種方法並不安全

00:10:04.505 --> 00:10:06.373 
需要請求使用授權

00:10:09.109 --> 00:10:13.380 
編譯器會告訴你這是不安全代碼

00:10:14.047 --> 00:10:15.415 
是錯誤

00:10:15.482 --> 00:10:18.218 
它會禁止你構建這個代碼

00:10:19.186 --> 00:10:20.687 
並會提供不錯的安全性檢測

00:10:26.660 --> 00:10:29.363 
它會提供可以解決

00:10:29.997 --> 00:10:31.932 
這一問題的不同方法

00:10:33.100 --> 00:10:35.502 
這裏有註解 你是否需要安全檢測？

00:10:36.203 --> 00:10:38.839 
會有附上的解決辦法 如果接受

00:10:39.273 --> 00:10:40.807 
代碼就重寫 像這樣

00:10:42.142 --> 00:10:48.382 
現在有彙編組合靜態執行

00:10:48.448 --> 00:10:49.716 
和運行時間執行

00:10:51.051 --> 00:10:54.121 
這就是散列可用句法

00:10:54.821 --> 00:10:58.725 
基本上 
編譯器掃描可以看到代碼塊中的

00:10:59.092 --> 00:11:04.364 
所有內容最新的iOS 
OS X或安全執行這些API

00:11:04.431 --> 00:11:05.666 
所需的具體版本

00:11:06.099 --> 00:11:08.235 
是什麼？

00:11:09.369 --> 00:11:12.372 
然後會使用在散列可用的

00:11:12.439 --> 00:11:15.042 
所提到版本進行適當的運行時間檢測

00:11:15.108 --> 00:11:16.977 
編譯器會把它插入其中

00:11:17.044 --> 00:11:19.346 
你不必猜測如何完成 會高效完成

00:11:19.680 --> 00:11:22.583 
並做緩存
這樣就可以安全使用

00:11:23.517 --> 00:11:26.553 
在SDK中使用該信息

00:11:26.620 --> 00:11:30.324 
會實現高保真
因此會得到真正安全的模式

00:11:32.960 --> 00:11:34.228 
有些人會問

00:11:34.595 --> 00:11:37.231 
爲什麼要在OS版本中
進行檢測呢

00:11:37.297 --> 00:11:39.666 
不是提供過對以往內容

00:11:39.733 --> 00:11:41.201 
所做的指南麼？

00:11:41.935 --> 00:11:46.273 
原因是做簿記實在太難

00:11:46.673 --> 00:11:49.776 
至少當你查詢運行時間時 

00:11:50.077 --> 00:11:53.013 
你會得到部分真相 但是在很多情況下
即便是真相也會有出入

00:11:54.915 --> 00:11:58.919 
邏輯上來講 和app開發人員交談

00:11:59.887 --> 00:12:02.489 
要知道 你希望構建在app上的體驗

00:12:02.556 --> 00:12:04.424 
都發起在用戶正在

00:12:04.491 --> 00:12:07.427 
運行的主OS上 對麼？

00:12:07.995 --> 00:12:11.532 
在每個OS版本中都有一批新的API

00:12:12.599 --> 00:12:14.735 
這些基本上定義了你可以執行的

00:12:15.002 --> 00:12:18.539 
各種功能而用戶在使用

00:12:18.605 --> 00:12:21.608 
不同版本的OS 因此 他們在邏輯上

00:12:21.675 --> 00:12:25.245 
打破了你的app所具備的

00:12:25.312 --> 00:12:27.414 
行爲類別 對麼？

00:12:27.481 --> 00:12:30.951 
所有這些在邏輯一致性上都有區別

00:12:32.052 --> 00:12:35.789 
同樣 它也不會檢測某款API的存在

00:12:36.156 --> 00:12:39.193 
因爲你通常準備同時使用若干API

00:12:39.259 --> 00:12:41.128 
這其實說不過

00:12:41.195 --> 00:12:42.863 
某款API的存在並非表明其他

00:12:42.930 --> 00:12:44.565 
也會存在

00:12:44.932 --> 00:12:47.467 
信息位於SDK中編譯器可以爲你

00:12:47.534 --> 00:12:48.836 
完成簿記工作

00:12:49.770 --> 00:12:52.573 
編譯器涉及到真正的規則改變者

00:12:53.140 --> 00:12:55.742 
它使得可用性檢測非常可靠

00:12:56.310 --> 00:12:59.813 
可以假設編譯器在做着正確的事情

00:13:00.047 --> 00:13:01.715 
你儘可放心是在

00:13:01.782 --> 00:13:05.018 
通過定義解決整類問題

00:13:05.085 --> 00:13:06.920 
因爲你在用編譯執行

00:13:09.256 --> 00:13:13.026 
而且自然會進入多個平臺

00:13:13.827 --> 00:13:17.531 
比如 
我之前有這個NSData資產實例

00:13:18.098 --> 00:13:20.968 
如果
我想讓代碼以OS X和iOS爲目標

00:13:21.435 --> 00:13:23.971 
我可以簡單擴展句法稱我也在

00:13:24.037 --> 00:13:26.540 
其他平臺檢測其最小可用性

00:13:27.574 --> 00:13:30.344 
星級表明基本上在所有其他情況下

00:13:30.410 --> 00:13:32.513 
在本例中應該是Watch OS

00:13:33.313 --> 00:13:34.781 
我們把它放在那裏顯性調用

00:13:34.848 --> 00:13:36.717 
潛在的流程控制

00:13:36.783 --> 00:13:39.953 
對於其他沒有明顯提及的平臺

00:13:40.153 --> 00:13:42.489 
會執行指定條件

00:13:42.556 --> 00:13:45.158 
基本上是真和假

00:13:45.526 --> 00:13:47.828 
我們本想調用這些分支

00:13:47.895 --> 00:13:49.196 
它們仍將被採用

00:13:49.463 --> 00:13:51.031 
因此 我們想顯性調用

00:13:51.098 --> 00:13:53.100 
可讀性行爲

00:13:54.668 --> 00:13:58.105 
現在可讀性檢測會在Swift 2中

00:13:58.172 --> 00:14:00.541 
自然構成用於控制流的可供性

00:14:01.375 --> 00:14:04.845 
比如 你之前已經構建了app 希望

00:14:04.912 --> 00:14:08.582 
進行這類檢測 然後執行部分功能

00:14:08.849 --> 00:14:11.451 
否則什麼都不做只要擺脫困境即可

00:14:12.653 --> 00:14:14.855 
這與新的保安聲明相結合

00:14:16.223 --> 00:14:18.192 
可以像這樣調整編碼

00:14:18.559 --> 00:14:20.761 
保安聲明下面的的所有內容

00:14:20.827 --> 00:14:22.529 
都有散列可用標籤提供的

00:14:22.596 --> 00:14:23.830 
可用性

00:14:29.570 --> 00:14:33.340 
因此自然會找到方法

00:14:33.407 --> 00:14:34.975 
來構成應用的因素

00:14:36.944 --> 00:14:38.812 
比如 
你之前已經在iOS 7上做過部署

00:14:39.880 --> 00:14:43.517 
我會把iOS 7中
可用的API代碼染成綠色

00:14:43.917 --> 00:14:47.087 
綠色條代表代碼塊中

00:14:47.154 --> 00:14:50.057 
可以安全使用iOS 7或更早版本

00:14:50.123 --> 00:14:51.525 
因此這基本上是編譯器

00:14:52.059 --> 00:14:53.193 
對世界的看法

00:14:54.661 --> 00:14:57.197 
如果我想用iOS 8 API
我已經把它的代碼

00:14:57.264 --> 00:14:59.700 
塗成橙色 
你需要對它進行可用性檢測

00:14:59.766 --> 00:15:01.268 
否則 你會從編譯器收到一個錯誤

00:15:01.902 --> 00:15:03.937 
你可以認爲在代碼塊中

00:15:04.004 --> 00:15:05.706 
你有特權

00:15:05.772 --> 00:15:07.574 
決定什麼API可以調用

00:15:09.176 --> 00:15:11.912 
一旦我出了代碼塊特權就不復存在

00:15:12.045 --> 00:15:14.114 
就只能調用iOS 7 API

00:15:15.148 --> 00:15:17.885 
如果我想調用iOS 9 API
我可以進行不同的檢測

00:15:17.951 --> 00:15:20.254 
這會在代碼塊中提供不同範圍的特權

00:15:20.320 --> 00:15:22.256 
它是極具可組合能力和可讀性的模型

00:15:23.690 --> 00:15:25.692 
比如 我在根據

00:15:25.759 --> 00:15:29.162 
部分API是否可用構建

00:15:29.229 --> 00:15:31.532 
具備整套不同功能的app

00:15:32.099 --> 00:15:33.033 
我想對此進行分解

00:15:33.100 --> 00:15:36.270 
我不是隻把一束代碼加入條件語句

00:15:36.336 --> 00:15:38.305 
我希望把它分解放入不同的函數中

00:15:39.873 --> 00:15:40.841 
這很容易做到

00:15:41.375 --> 00:15:42.843 
可以聲明另一個函數

00:15:42.910 --> 00:15:46.513 
比如出於教學目的
我的函數使用iOS 8

00:15:46.880 --> 00:15:50.450 
我準備從條件代碼塊中調用

00:15:51.652 --> 00:15:53.987 
問題在於編譯器不知道

00:15:54.054 --> 00:15:55.122 
你要做什麼要知道

00:15:55.189 --> 00:15:59.126 
只有完成檢測才能調用這個

00:16:00.227 --> 00:16:02.196 
在默認狀態下編譯器會確認

00:16:02.763 --> 00:16:04.198 
你鎖定iOS 7

00:16:04.264 --> 00:16:06.767 
我假設你在這個函數中 只使用

00:16:07.601 --> 00:16:08.468 
iOS 7 API

00:16:09.903 --> 00:16:13.173 
如果你想用iOS 8
API那麼就要進行檢測

00:16:14.842 --> 00:16:16.076 
這不太好 對吧？

00:16:16.143 --> 00:16:18.979 
這裏並未提供方法來真正分析app

00:16:19.913 --> 00:16:21.615 
還會導致冗餘檢測

00:16:24.251 --> 00:16:26.119 
你可以告知編譯器你的意圖

00:16:27.621 --> 00:16:31.725 
這樣SDK本身會有這些方法和類的

00:16:31.792 --> 00:16:33.360 
添加可用適應

00:16:33.427 --> 00:16:36.897 
稱這是可以用於API的最小OS

00:16:36.964 --> 00:16:40.601 
在自己的代碼上
也可以使用同樣的註解

00:16:41.635 --> 00:16:44.805 
表示除非已經進行過適當的

00:16:44.872 --> 00:16:46.740 
可用性檢測
否則不得調用該函數

00:16:47.608 --> 00:16:48.842 
一旦出現這種情況

00:16:50.177 --> 00:16:52.312 
編譯器會以不同方式看待代碼

00:16:53.814 --> 00:16:56.617 
然後可以完全刪除檢測

00:16:56.683 --> 00:17:00.287 
即額外的可用性檢測
安全使用iOS 8 API

00:17:01.588 --> 00:17:02.656 
這可以組合使用

00:17:02.723 --> 00:17:05.192 
因爲其他函數也有相似註解

00:17:05.259 --> 00:17:07.227 
如果函數有着相同的API特權 

00:17:07.294 --> 00:17:10.631 
可以直接調用它們

00:17:11.431 --> 00:17:14.601 
如果在進行可用性檢測時

00:17:14.701 --> 00:17:16.737 
想通過更多特權調用API

00:17:17.771 --> 00:17:20.773 
那麼這樣很方便構成 很容易理解

00:17:20.840 --> 00:17:22.742 
代碼的構成方法

00:17:25.212 --> 00:17:27.614 
如大家的預期這也適用於方法

00:17:27.814 --> 00:17:30.150 
這樣可以標註類爲可用

00:17:30.417 --> 00:17:32.586 
但是具體方法 也許不可用

00:17:34.154 --> 00:17:37.958 
如果需要 你可以在調用更可用的

00:17:38.025 --> 00:17:40.260 
具體方法前 舉例說明該類

00:17:40.327 --> 00:17:41.195 
你需要進行檢測

00:17:43.163 --> 00:17:46.300 
在要求最小的可用性時 如果想標識

00:17:46.366 --> 00:17:48.168 
整個類的話這樣會奏效 

00:17:49.102 --> 00:17:52.639 
如果這樣做 除非進行過可用性檢測

00:17:52.706 --> 00:17:54.274 
否則甚至連舉例說明類都不可能

00:17:55.042 --> 00:17:58.612 
那你會獲得API可用性

00:17:58.879 --> 00:18:01.582 
完整的全部傳遞閉包

00:18:02.883 --> 00:18:05.652 
這會自然引發 可以使用的更多技巧

00:18:07.521 --> 00:18:14.494 
比如 
你已有較早版本中的自定義模糊視圖 

00:18:15.362 --> 00:18:21.468 
Apple會推出
更具體的UI視圖子類 

00:18:21.602 --> 00:18:22.836 
你想使用新版本

00:18:22.903 --> 00:18:25.806 
在主OS上使用它們

00:18:27.641 --> 00:18:30.377 
你想通過可用性保護實現這類

00:18:30.711 --> 00:18:34.715 
運行時間多態 那麼如果你在

00:18:34.781 --> 00:18:38.151 
運行OS 要使用原生UI

00:18:38.585 --> 00:18:41.355 
否則就要使用自定義的

00:18:42.356 --> 00:18:43.790 
這樣獲得對象的客戶端

00:18:43.857 --> 00:18:47.528 
並不需要在乎你運行的OS版本

00:18:47.861 --> 00:18:49.930 
到底是哪個

00:18:50.030 --> 00:18:52.666 
你已經完全提供了關注點的分離

00:18:54.001 --> 00:18:56.069 
當用到協議做同樣的事情

00:18:56.136 --> 00:18:58.305 
效果會很好可提供不同的執行

00:18:58.372 --> 00:19:00.941 
可以有閉包不同的函數

00:19:01.275 --> 00:19:04.745 
可以實現完全不同的新方法分析代碼

00:19:04.811 --> 00:19:06.346 
並獲得你所期待的安全性

00:19:08.248 --> 00:19:10.651 
我們覺得可用性檢測相當棒

00:19:11.251 --> 00:19:14.988 
我覺得它的確提供了具有凝結力

00:19:15.055 --> 00:19:20.460 
的安全方法來
使用新款API並部署到更早版本

00:19:21.195 --> 00:19:23.897 
統一的句法提供了真正安全的編程模型

00:19:24.665 --> 00:19:27.367 
但是更重要的是它提供了
正常分析app的方法

00:19:27.434 --> 00:19:28.635 
你可以閱讀app

00:19:28.702 --> 00:19:31.572 
可以閱讀代碼並理解

00:19:31.638 --> 00:19:33.674 
可以期待不變性

00:19:34.441 --> 00:19:36.210 
我覺得這一點 非常強大

00:19:37.578 --> 00:19:39.413 
接下來我把講臺交給阿萊克斯

00:19:39.479 --> 00:19:42.449 
他來介紹使用
Swift強大類型系統的其他方法

00:19:42.516 --> 00:19:44.885 
以便在自己的應用中執行不變性

00:19:51.491 --> 00:19:52.392 
謝謝 泰德

00:19:52.459 --> 00:19:54.494 
大家好
我是阿萊克斯•米基科夫斯基

00:19:54.561 --> 00:19:56.063 
是Apple的示例編碼員

00:19:56.797 --> 00:19:58.065 
在過去的一年半時間

00:19:58.498 --> 00:20:01.869 
我都在教開發人員如何用
Swift編寫Cocoa app

00:20:03.036 --> 00:20:08.742 
我對於Swift
和Cocoa有着清晰的夢想

00:20:09.877 --> 00:20:13.046 
怎樣才能讓二者在一起實現安全的

00:20:13.113 --> 00:20:15.749 
編譯時間 安全應用

00:20:17.150 --> 00:20:20.387 
今天我想介紹我已有部分想法 

00:20:20.787 --> 00:20:22.689 
並解釋大家可以從中使用的

00:20:22.756 --> 00:20:24.958 
部分範例並把這些概念

00:20:25.025 --> 00:20:27.661 
運用到各自的應用當中

00:20:27.761 --> 00:20:30.197 
這樣你也可以編譯時間安全代碼

00:20:31.431 --> 00:20:34.234 
現在我還沒有告知大家 
但是在這些想法中

00:20:34.568 --> 00:20:36.770 
我還想到了獨角獸

00:20:38.138 --> 00:20:40.007 
我開發了獨角獸app來看一下

00:20:40.174 --> 00:20:45.312 
我設想的不同獨角獸

00:20:47.014 --> 00:20:50.350 
首先 我想介紹我應用中的

00:20:51.018 --> 00:20:53.086 
Asset Catalog 標識符

00:20:53.153 --> 00:20:56.123 
每個人都在UIKit中用到它

00:20:57.457 --> 00:20:59.993 
我的獨角獸瀏覽app相對簡單

00:21:00.060 --> 00:21:04.398 
在Asset Catalog中
我已經加入3個獨角獸圖像

00:21:06.166 --> 00:21:09.136 
我現在想看看當我從
Asset Catalog生成圖像

00:21:09.203 --> 00:21:12.406 
代碼會是什麼樣

00:21:14.041 --> 00:21:15.776 
你會注意到

00:21:15.876 --> 00:21:18.312 
我在搭建的3個圖像

00:21:18.812 --> 00:21:20.848 
每個圖像我都向UIKit UI

00:21:20.914 --> 00:21:23.717 
圖像API傳遞一個字符串

00:21:24.885 --> 00:21:30.190 
不知道Asset Catalog 
UIKit實際上提供了怎樣的資產

00:21:30.257 --> 00:21:31.725 
所以我必須打開這些圖像

00:21:31.792 --> 00:21:34.161 
才能在應用中使用它們

00:21:35.162 --> 00:21:36.463 
非常不巧

00:21:36.530 --> 00:21:40.701 
因爲已在Asset Catalog
定義Asset Catalog標識

00:21:40.767 --> 00:21:44.304 
我不希望這裏出現重複信息

00:21:45.405 --> 00:21:49.243 
此外 這裏我只會使用3個圖像

00:21:50.177 --> 00:21:53.580 
可是在整個應用中我會用到許許多多

00:21:54.314 --> 00:21:58.085 
問題是很難找到你的代碼中

00:21:58.185 --> 00:21:59.920 
是否有輸入錯誤幻燈片上是

00:21:59.987 --> 00:22:02.890 
這些錯誤會引發的反應

00:22:02.990 --> 00:22:05.325 
基於這些 
你可能會希望進行修改我明白

00:22:05.826 --> 00:22:10.297 
但是確實很難回去把它們都找出來

00:22:10.364 --> 00:22:12.432 
那麼經典的解決方案應該是有個

00:22:12.499 --> 00:22:14.101 
全局常數

00:22:14.401 --> 00:22:16.970 
這樣可以在應用的各個地方使用

00:22:17.037 --> 00:22:17.938 
同樣的常數

00:22:19.206 --> 00:22:21.008 
如果使用正確那就可以把獨角獸

00:22:21.074 --> 00:22:23.610 
圖像按照你的想法再找回來

00:22:23.677 --> 00:22:25.579 
但還是要打開圖像 因爲編譯器

00:22:25.913 --> 00:22:27.748 
不清楚框架也不知道

00:22:27.814 --> 00:22:29.049 
你是否會

00:22:29.149 --> 00:22:31.552 
提供有效的常數名稱

00:22:32.119 --> 00:22:35.522 
此外 
可以提供隨機的爲API提供隨機流

00:22:35.589 --> 00:22:40.060 
運行時間會出現致命錯誤

00:22:41.261 --> 00:22:44.298 
因爲
NSUbiquity身份改變節點

00:22:44.364 --> 00:22:47.267 
通知還是字符串可以有效傳遞至

00:22:47.334 --> 00:22:49.469 
UI圖像指定API

00:22:50.737 --> 00:22:52.840 
我們來看看怎樣解決這個問題

00:22:54.174 --> 00:22:56.844 
我們要做的是嚴格的類型解決方案

00:22:56.910 --> 00:22:59.146 
我們在代碼中將字符串傳遞到各處

00:22:59.746 --> 00:23:02.816 
我們希望的是強大的類型解決方案

00:23:04.551 --> 00:23:07.020 
希望可以將字符串映射到

00:23:07.087 --> 00:23:08.355 
新的類型

00:23:09.857 --> 00:23:13.026 
這會讓我們編碼解決

00:23:13.093 --> 00:23:15.529 
怎樣搭建應用至

00:23:15.596 --> 00:23:17.064 
編輯器的信息

00:23:17.130 --> 00:23:20.434 
這樣可以把非選擇性UI圖像

00:23:20.701 --> 00:23:21.702 
返回到代碼的各處

00:23:23.203 --> 00:23:24.505 
解決方案就是

00:23:24.671 --> 00:23:28.141 
針對應用進行枚舉

00:23:28.208 --> 00:23:30.544 
我們在應用中定義的枚舉

00:23:31.545 --> 00:23:34.381 
如果來看之前定義的代碼

00:23:35.449 --> 00:23:38.218 
我不希望代碼是這幅樣子

00:23:38.285 --> 00:23:42.789 
我想每次生成UI圖像對象都傳遞枚舉

00:23:42.856 --> 00:23:44.558 
這樣我就不必

00:23:44.625 --> 00:23:48.095 
在代碼中打開返回值

00:23:48.862 --> 00:23:50.397 
怎麼實現呢？

00:23:51.665 --> 00:23:52.666 
首先我希望

00:23:52.733 --> 00:23:58.005 
定義UI圖像的嵌套類型 以便在

00:23:58.071 --> 00:24:00.774 
枚舉大小寫
和Asset Catalog中

00:24:01.141 --> 00:24:03.544 
定義的字符串表達之間提供

00:24:03.610 --> 00:24:04.745 
映射

00:24:05.979 --> 00:24:09.416 
我們將之定義爲嵌套類型

00:24:09.917 --> 00:24:12.853 
這樣可以存儲在Asset
Catalog的其他資產

00:24:13.120 --> 00:24:14.922 
也可以使用這種方法

00:24:16.123 --> 00:24:18.225 
一旦這麼做就非常簡單

00:24:18.292 --> 00:24:22.229 
我可以在枚舉大小寫和字符串表達之間

00:24:22.296 --> 00:24:23.664 
提供大小寫映射

00:24:24.164 --> 00:24:26.900 
對所有其他的情況也可以這樣

00:24:28.101 --> 00:24:31.905 
這種方法的真正好處在於

00:24:31.972 --> 00:24:34.908 
如果我不小心有輸入錯誤 如果

00:24:34.975 --> 00:24:37.444 
我不小心從什麼地方複製粘貼了字符串

00:24:37.744 --> 00:24:39.646 
出現了重複編譯器就會

00:24:39.713 --> 00:24:42.282 
警告或者報錯 告訴我

00:24:42.616 --> 00:24:47.955 
在枚舉中出現了重複問題

00:24:49.156 --> 00:24:52.125 
編譯器可以這樣幫忙 實在太好了

00:24:52.926 --> 00:24:54.795 
現在我們已經定義了新類型

00:24:54.862 --> 00:24:58.265 
我所需要做的就是
返回再編寫便利初始化函數

00:24:58.332 --> 00:25:01.201 
其中使用這個枚舉而不是字符串

00:25:01.502 --> 00:25:04.171 
並將枚舉的原始值轉至UIKit

00:25:04.438 --> 00:25:07.941 
定義的UI圖像命名初始化函數

00:25:09.409 --> 00:25:11.278 
如果我們回來再看代碼

00:25:11.378 --> 00:25:16.049 
可以把獨角獸放在所希望的任何地方

00:25:16.116 --> 00:25:19.419 
如果我們再來看像以前
那樣出現輸入錯誤會怎樣

00:25:19.486 --> 00:25:22.789 
現在編譯器可以告知出現了輸入錯誤

00:25:22.990 --> 00:25:24.725 
因爲我們已經把應用結構的

00:25:24.992 --> 00:25:27.794 
信息編入了代碼之中

00:25:28.729 --> 00:25:31.265 
如果修復這個問題
編譯器錯誤也不復存在

00:25:32.933 --> 00:25:35.002 
我們來談談這麼做的好處

00:25:37.671 --> 00:25:41.308 
首先是我們的常數位於中心

00:25:41.642 --> 00:25:45.078 
如果將新的
圖像加入Asset Catalog

00:25:45.145 --> 00:25:49.316 
我準確知道該在哪裏添加圖像常數

00:25:50.918 --> 00:25:53.053 
還有一個好處是這樣做不會污染

00:25:53.120 --> 00:25:54.354 
全局命名空間

00:25:54.421 --> 00:25:58.525 
我可以有在Asset 
Catalog中定義的若干對象

00:25:58.592 --> 00:26:02.095 
可以在其中運用這個辦法

00:26:03.530 --> 00:26:06.433 
最好的一點是 當構建UI圖像對象時

00:26:06.500 --> 00:26:08.802 
在應用中可以只用這些

00:26:08.869 --> 00:26:11.071 
枚舉情況中的一種

00:26:11.371 --> 00:26:13.340 
所以編譯器可以幫你實現這點

00:26:13.707 --> 00:26:16.977 
現在你可以將非選擇性圖像返回到

00:26:17.044 --> 00:26:18.445 
代碼中的任何地方 因此不必擔心

00:26:18.512 --> 00:26:20.247 
強行打開的問題

00:26:20.547 --> 00:26:26.019 
這是我們在獨角獸
瀏覽器app中所用的非常

00:26:26.086 --> 00:26:28.188 
獨特的方式但我希望你們想想

00:26:28.255 --> 00:26:30.657 
怎樣在自己的代碼中使用枚舉

00:26:30.724 --> 00:26:32.960 
以提供其他種類的富映射

00:26:33.961 --> 00:26:35.796 
你們可以不只是作爲字符串使用

00:26:35.863 --> 00:26:37.898 
還可以使用整數甚至是選擇器

00:26:38.265 --> 00:26:39.933 
有很多機會

00:26:40.000 --> 00:26:42.569 
在自己的代碼中定義這些映射

00:26:44.404 --> 00:26:49.409 
現在來深入探討枚舉 但是我想

00:26:49.476 --> 00:26:52.446 
先說說聯線標識符

00:26:52.513 --> 00:26:54.915 
因爲在代碼中始終要

00:26:54.982 --> 00:26:55.983 
使用到它

00:26:57.251 --> 00:27:00.320 
現在 我的想法越發強烈

00:27:00.387 --> 00:27:03.390 
我必須研製出一款app 
讓我真正跟蹤

00:27:03.824 --> 00:27:06.159 
獨角獸 並在運行中下載它們

00:27:07.361 --> 00:27:09.162 
我有更復雜的應用

00:27:09.563 --> 00:27:12.032 
如果來看故事板

00:27:12.432 --> 00:27:13.901 
就會變得非常簡單

00:27:14.568 --> 00:27:16.970 
我只有單獨的視圖控制器 可以

00:27:17.037 --> 00:27:18.739 
聯線其他兩個視圖控制器

00:27:19.206 --> 00:27:23.544 
對於所有這些視圖控制器而言

00:27:23.610 --> 00:27:25.312 
我定義了一個聯線標識符

00:27:26.580 --> 00:27:29.550 
我需要看看當我們覆蓋

00:27:29.616 --> 00:27:32.419 
聯線準備來配置獨角獸瀏覽器

00:27:32.486 --> 00:27:34.788 
視圖將呈現的

00:27:34.922 --> 00:27:37.724 
視圖控制器時 代碼會是什麼樣

00:27:40.327 --> 00:27:43.197 
我們覆蓋了這種方法 執行這一點的

00:27:43.263 --> 00:27:45.365 
經典辦法是打開

00:27:45.432 --> 00:27:48.502 
聯線標識符字符串

00:27:49.369 --> 00:27:53.674 
現在 在我使用完全相同的字符串之前

00:27:53.740 --> 00:27:56.810 
我是按照故事板中的聯線定義的字符串

00:27:57.344 --> 00:27:59.179 
編輯器對此還一無所知

00:27:59.513 --> 00:28:02.316 
當我只打開這兩個字符串時

00:28:02.482 --> 00:28:03.784 
編譯器會告訴我

00:28:04.418 --> 00:28:07.454 
這並非是窮盡性檢測

00:28:07.521 --> 00:28:10.891 
我必須加入默認情況
因爲編譯器不知道

00:28:11.558 --> 00:28:14.461 
我已經提供了有效映射

00:28:15.863 --> 00:28:18.332 
但是如果我加入了新的視圖控制器

00:28:19.166 --> 00:28:22.369 
必須有個全新的聯線 那會怎樣？

00:28:22.870 --> 00:28:24.271 
我怎麼才能知道在代碼中

00:28:24.338 --> 00:28:25.939 
哪裏需要改變 這個邏輯？

00:28:27.241 --> 00:28:29.810 
我們來看看再次通過枚舉

00:28:29.877 --> 00:28:31.912 
該怎麼解決這個問題

00:28:33.280 --> 00:28:36.917 
我定義了獨角獸瀏覽器
視圖控制器的嵌套類型

00:28:36.984 --> 00:28:38.485 
它將代表聯線標識符的情況

00:28:38.552 --> 00:28:41.021 
和故事板字符串表達

00:28:41.321 --> 00:28:44.825 
之間的映射

00:28:45.459 --> 00:28:48.595 
我們來看 怎麼實現用更強大的類型

00:28:48.662 --> 00:28:51.932 
聯線方法準備

00:28:53.600 --> 00:28:54.801 
首先 我要做的是

00:28:54.868 --> 00:28:57.337 
從故事板聯線對象抓取聯線

00:28:57.404 --> 00:28:59.139 
標識符字符串

00:29:00.240 --> 00:29:02.476 
並從原始值中構建聯線

00:29:02.543 --> 00:29:03.677 
識別符枚舉

00:29:05.412 --> 00:29:07.181 
我還會提供部分運行時間

00:29:07.247 --> 00:29:09.883 
檢測調試以防我並未

00:29:09.950 --> 00:29:13.353 
爲新的聯線識別符 提供有效的

00:29:13.420 --> 00:29:15.355 
枚舉情況

00:29:16.290 --> 00:29:19.660 
從這裏 
我可以打開枚舉 而不是字符串

00:29:20.394 --> 00:29:23.564 
這非常棒 因爲我必須打開

00:29:23.630 --> 00:29:27.835 
兩種情況 編譯器知道我在枚舉中

00:29:27.901 --> 00:29:31.605 
只定義了兩種情況
所以我必須在代碼中打開

00:29:33.807 --> 00:29:37.711 
如果我們在枚舉中
添加了新的聯線標識符

00:29:38.579 --> 00:29:40.747 
編譯器就會告知 我們並未

00:29:41.114 --> 00:29:45.853 
進行窮盡性轉換以便我們在枚舉中

00:29:45.919 --> 00:29:49.122 
打開的代碼各處

00:29:49.590 --> 00:29:51.291 
編譯器就會告訴我們

00:29:51.358 --> 00:29:52.826 
在哪裏更新邏輯

00:29:53.327 --> 00:29:56.763 
這對字符串解決方案來說
是個極大的好處

00:29:58.665 --> 00:30:01.602 
我們可以這樣重寫聯線準備

00:30:02.202 --> 00:30:05.305 
但是 有時需要通過標識符 

00:30:05.372 --> 00:30:06.740 
人工啓動執行聯線

00:30:08.242 --> 00:30:11.144 
在本例中 我想要引入一束獨角獸

00:30:11.211 --> 00:30:14.214 
下載它們在Web上 下載圖像

00:30:14.281 --> 00:30:15.916 
顯示新的視圖控制器

00:30:16.383 --> 00:30:18.485 
我們來看看 這些代碼是什麼樣子

00:30:20.254 --> 00:30:23.690 
那麼經典的解決方案是將字符串

00:30:23.757 --> 00:30:26.326 
傳遞至帶有標識符方式的執行聯線

00:30:27.694 --> 00:30:29.563 
我們已經定義了這種枚舉

00:30:29.630 --> 00:30:30.964 
我們只是想使用已經提供的

00:30:31.031 --> 00:30:32.099 
這種映射

00:30:32.666 --> 00:30:34.368 
相反 我們想用枚舉

00:30:35.769 --> 00:30:36.603 
怎麼做呢？

00:30:36.670 --> 00:30:38.205 
其實 非常簡單

00:30:38.272 --> 00:30:43.777 
我們可以通過標識符方法定義
UIKit定義執行聯線

00:30:44.111 --> 00:30:46.613 
的過載其中採用了枚舉
而不是字符串

00:30:47.381 --> 00:30:53.220 
然後用枚舉的原始值
調用UIKit 定義方法

00:30:53.854 --> 00:30:58.025 
如果我們返回用枚舉調用

00:30:58.825 --> 00:31:02.196 
方法的代碼
它完全是按照我們的預期運轉

00:31:03.130 --> 00:31:05.232 
這就是針對獨角獸瀏覽器視圖

00:31:05.299 --> 00:31:07.000 
控制器的絕佳解決方案

00:31:07.935 --> 00:31:09.870 
但是如果再複雜一點會怎樣？

00:31:11.171 --> 00:31:13.807 
我希望看看我們剛纔做的結構

00:31:13.874 --> 00:31:15.542 
看怎樣才能把它應用到

00:31:15.609 --> 00:31:17.911 
獨角獸瀏覽器以外的視圖控制器

00:31:20.314 --> 00:31:22.549 
我們做的是在枚舉情況

00:31:22.616 --> 00:31:25.452 
及其故事板上的字符串表達之間

00:31:25.519 --> 00:31:26.453 
提供映射

00:31:27.387 --> 00:31:30.123 
我們還增加了使用該映射的

00:31:30.257 --> 00:31:33.093 
執行 以便獲得應用中

00:31:33.160 --> 00:31:36.930 
更強大的類型系統

00:31:37.831 --> 00:31:39.299 
但如果我們增添新的視圖控制器

00:31:39.366 --> 00:31:40.801 
我們希望做同樣的事情

00:31:40.968 --> 00:31:45.339 
需要不得不復制
所有那些工作我不希望這麼做

00:31:46.840 --> 00:31:50.944 
我真正想做的是從視圖控制器提取

00:31:51.211 --> 00:31:54.982 
執行 並定義鬆散映射
因爲聯線標識符的枚舉

00:31:55.048 --> 00:31:59.253 
會具體針對視圖控制器

00:31:59.319 --> 00:32:03.090 
通過這樣做 我們可以爲多種

00:32:03.156 --> 00:32:05.058 
視圖控制器使用該執行

00:32:05.526 --> 00:32:09.830 
不論其類層次如何

00:32:09.897 --> 00:32:12.299 
通過重複使用這個執行
可以避免許多

00:32:13.100 --> 00:32:15.769 
糟糕的類層次

00:32:17.004 --> 00:32:20.007 
我們會通過協議 來實現這一點

00:32:20.974 --> 00:32:22.409 
所以我定義了一個新的協議

00:32:22.476 --> 00:32:24.211 
我們會稱之爲聯線處理類型

00:32:24.745 --> 00:32:26.280 
我們的視圖控制器需要與它

00:32:26.346 --> 00:32:27.181 
相一致

00:32:28.515 --> 00:32:31.518 
我希望定義剛提到的映射

00:32:32.085 --> 00:32:34.521 
現在它將成爲聯線標識符枚舉

00:32:35.389 --> 00:32:38.325 
我們希望確保聯線標識符和

00:32:38.392 --> 00:32:40.327 
原始可顯示協議相一致

00:32:41.261 --> 00:32:44.831 
這個協議是個關於各類型支持的

00:32:44.898 --> 00:32:48.535 
枚舉的重要執行細節

00:32:49.369 --> 00:32:52.539 
編譯器可以自動爲你合成

00:32:53.841 --> 00:32:56.543 
關於協議定義就是這些

00:32:57.711 --> 00:33:00.714 
我現在
需要用Swift 2.0的功能

00:33:00.781 --> 00:33:02.482 
受限制的協議擴展

00:33:02.916 --> 00:33:04.818 
來實際添加將成爲我們的

00:33:05.018 --> 00:33:06.920 
泛性可重用代碼的執行

00:33:07.821 --> 00:33:10.657 
我們將擴展聯線處理類型

00:33:11.325 --> 00:33:12.693 
接下來我們對之加以限制

00:33:12.759 --> 00:33:15.195 
如果這些限制條件滿足的話 
我們只想讓執行

00:33:16.830 --> 00:33:18.799 
加入其中

00:33:19.533 --> 00:33:23.070 
第一個限制條件是滿足協議的類型爲

00:33:23.136 --> 00:33:26.139 
UI視圖控制器子類

00:33:26.540 --> 00:33:27.841 
這將會讓我們在協議擴展中

00:33:27.908 --> 00:33:30.010 
調用UI視圖

00:33:30.544 --> 00:33:31.812 
控制器方法

00:33:33.013 --> 00:33:35.115 
第二點是我們想確定

00:33:35.182 --> 00:33:38.051 
聯線標識符映射是位於

00:33:38.118 --> 00:33:40.821 
映射情況和字符串之間

00:33:42.689 --> 00:33:45.425 
我們已經定義了
有限制條件的協議擴展

00:33:45.492 --> 00:33:47.494 
我們所需要做的就是添加執行

00:33:48.195 --> 00:33:51.198 
我們要通過之前定義的標識符 

00:33:51.265 --> 00:33:55.002 
採用聯線現有執行 

00:33:55.602 --> 00:33:58.872 
並將完全相同的執行加入代碼

00:34:00.807 --> 00:34:03.277 
如果我們返回
獨角獸瀏覽器視圖控制器

00:34:03.710 --> 00:34:06.947 
我們只需在新類型中加入一致性

00:34:08.014 --> 00:34:11.217 
我們已經滿足了協議的所有
相關類型限制條件

00:34:11.318 --> 00:34:15.155 
因爲我們已經識別了這個聯線

00:34:15.222 --> 00:34:16.056 
標識符枚舉

00:34:17.591 --> 00:34:21.360 
如果我們進入處理行爲方法 我們可以

00:34:21.428 --> 00:34:26.166 
用完全相同的方式調用代碼 
但我們在聯線處理類型中重用執行

00:34:27.568 --> 00:34:29.770 
我們可以這樣通過標識符方式

00:34:29.837 --> 00:34:35.007 
重用表現聯線
但是要是調用聯線準備

00:34:35.242 --> 00:34:36.510 
或聯線處理準備會怎樣？

00:34:37.811 --> 00:34:40.547 
我需要定義便捷方式

00:34:40.614 --> 00:34:42.882 
其中會採用故事板對象

00:34:43.350 --> 00:34:46.520 
並返回聯線標識符枚舉

00:34:46.587 --> 00:34:47.855 
這是在協議擴展中完成

00:34:49.188 --> 00:34:53.092 
我要再次做的是使用之前定義的執行

00:34:55.295 --> 00:34:56.964 
返回我們用代碼

00:34:57.030 --> 00:34:59.867 
生成的聯線標識符枚舉

00:35:00.901 --> 00:35:03.070 
如果來看爲聯線方式所做準備

00:35:03.136 --> 00:35:05.739 
結果就變得非常簡單

00:35:06.807 --> 00:35:10.043 
我們所需要做的就是通過聯線的

00:35:10.110 --> 00:35:13.514 
聯線識別符 打開結果返回
這是我們剛定義的方法我們只需要提供

00:35:14.248 --> 00:35:19.086 
兩種情況打開方法和之前的完全相同

00:35:19.987 --> 00:35:21.355 
但是我們有這個泛型解決方案

00:35:22.489 --> 00:35:24.558 
我們來談談這麼做的好處

00:35:27.094 --> 00:35:31.965 
當我們將之添加到 
聯線標識符枚舉中時

00:35:32.165 --> 00:35:34.201 
編譯器完全瞭解我們在故事板上

00:35:34.268 --> 00:35:36.069 
定義的聯線

00:35:37.137 --> 00:35:38.705 
可以確保我們在代碼中

00:35:38.772 --> 00:35:40.541 
處理了所有可能的情況

00:35:41.808 --> 00:35:46.113 
通過使用協議擴展
我們具有可重新使用的解決方案

00:35:46.180 --> 00:35:49.516 
我們可以在符合
新協議的任何視圖

00:35:49.583 --> 00:35:51.084 
控制器上使用這個執行

00:35:52.519 --> 00:35:54.521 
我們還有便捷句法

00:35:54.922 --> 00:35:57.958 
可以在不同的

00:35:59.826 --> 00:36:01.128 
視圖控制器上使用方法句法

00:36:01.195 --> 00:36:02.796 
不一定必須是 自由函數

00:36:04.064 --> 00:36:07.601 
這是在獨角獸瀏覽器app中
可以使用協議和

00:36:07.668 --> 00:36:10.771 
有限制方式的協議擴展的 

00:36:11.104 --> 00:36:13.574 
獨特方式但是大家都有
許多其他有趣應用

00:36:13.941 --> 00:36:14.908 
我想讓大家做的是思考一下

00:36:14.975 --> 00:36:18.846 
怎樣在自己的應用中使用協議和

00:36:19.112 --> 00:36:22.516 
相關類型限制條件來編碼部分

00:36:22.583 --> 00:36:25.552 
應用的結構到編譯器這樣它可以幫你

00:36:26.019 --> 00:36:27.387 
實現編譯時間安全性

00:36:28.488 --> 00:36:30.524 
我想讓你們想想

00:36:30.591 --> 00:36:32.259 
怎樣使用協議擴展

00:36:32.593 --> 00:36:35.462 
在自己的應用中分享執行

00:36:35.863 --> 00:36:39.066 
避免一系列糟糕的類層次問題

00:36:41.201 --> 00:36:45.272 
泰德和我今天說得夠多了
但是希望大家從中領會到

00:36:45.339 --> 00:36:47.140 
編譯器是來幫助大家的

00:36:49.142 --> 00:36:52.946 
泰德說的是如何在新API中
安全利用這一點

00:36:53.280 --> 00:36:55.649 
現在 這可以通過編譯器大部分完成

00:36:56.316 --> 00:36:59.586 
編譯器知道有什麼這不是具體針對

00:36:59.987 --> 00:37:01.522 
哪個OS的版本

00:37:02.856 --> 00:37:05.926 
我和大家介紹的是應用的強大類型

00:37:05.993 --> 00:37:07.761 
強迫應用實現不變性

00:37:08.028 --> 00:37:09.396 
並利用編譯器

00:37:09.730 --> 00:37:11.698 
讓它知道應用的限制條件

00:37:11.765 --> 00:37:15.002 
並把這些信息編入代碼

00:37:15.435 --> 00:37:17.971 
這樣編譯器可以幫你分析

00:37:18.038 --> 00:37:20.340 
編譯時間的問題而不是在運行時間

00:37:21.875 --> 00:37:23.143 
若要了解更多詳情

00:37:23.210 --> 00:37:29.149 
建議大家在線觀看
《基於協議的Swift編程》

00:37:29.983 --> 00:37:33.620 
講座 如果你自己對
Cocoa和Swift

00:37:33.687 --> 00:37:35.789 
有明晰的夢想建議你仔細看看
這兩個示例

00:37:35.856 --> 00:37:40.093 
編目示例有聯線
處理類型協議的實例

00:37:40.394 --> 00:37:41.562 
DemoBots使用了

00:37:41.628 --> 00:37:45.866 
在協議中使用
枚舉的一系列有趣方法

00:37:47.100 --> 00:37:48.402 
實現編譯時間安全性

00:37:49.269 --> 00:37:51.138 
若要了解更多詳情可以查看

00:37:51.205 --> 00:37:53.006 
Swift Language
Documentation

00:37:53.073 --> 00:37:55.676 
我們還有開發人員論壇如有任何問題 

00:37:55.742 --> 00:37:56.877 
你們也可以聯繫斯特凡

00:37:57.211 --> 00:38:00.013 
感謝大家希望能在實驗室見到大家