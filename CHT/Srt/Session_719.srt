00:00:20.354 --> 00:00:22.422 
App與新一代網絡

00:00:29.997 --> 00:00:31.632 
謝謝 上午好

00:00:32.665 --> 00:00:36.036 
歡迎參加“App與新一代網絡”講座

00:00:37.004 --> 00:00:41.175 
我是普拉巴卡爾·拉卡拉
另外還有我的同事斯圖爾特·柴歇爾

00:00:42.743 --> 00:00:44.778 
今天的講座分爲兩個部分

00:00:47.614 --> 00:00:49.950 
第一個主題關於IPv6

00:00:50.450 --> 00:00:52.886 
在第二個主題中斯圖爾特將會介紹

00:00:53.387 --> 00:00:55.956 
如何讓你的APP更快地運行

00:00:57.791 --> 00:00:59.426 
我們首先討論IPv6

00:01:02.763 --> 00:01:04.431 
IPv6有哪些新特性呢？

00:01:05.799 --> 00:01:09.837 
在大約17年以前
IPv6 RFC就已經發表

00:01:11.338 --> 00:01:15.642 
你可能會想今天我們
爲什麼要討論IPv6？

00:01:17.878 --> 00:01:23.250 
我們看到IPv6越來越多地

00:01:23.784 --> 00:01:25.118 
被部署到企業和蜂窩網絡之中

00:01:26.186 --> 00:01:27.487 
你需要確保你的APP

00:01:27.855 --> 00:01:30.724 
能夠在這些網絡中運行

00:01:33.160 --> 00:01:38.198 
因此你的APP應該強制兼容IPv6

00:01:39.466 --> 00:01:42.436 
現在我們將討論這個主題 
以及它對於開發者的意義

00:01:43.036 --> 00:01:44.371 
但是在此之前

00:01:44.972 --> 00:01:46.940 
請讓我們先回顧一下歷史

00:01:50.277 --> 00:01:53.380 
在前些年客戶端設備具有真實

00:01:53.614 --> 00:01:57.851 
唯一的IPv4 那是以前的事情了

00:01:57.918 --> 00:01:59.953 
你需要進行端對端網絡連接

00:02:01.855 --> 00:02:04.057 
但是我們很快發現

00:02:04.258 --> 00:02:06.293 
IPv4地址就快要用完了

00:02:07.261 --> 00:02:09.496 
因此我們在中間加入NAT

00:02:10.931 --> 00:02:15.169 
這個方法是可行的
但是大規模的NAT設備

00:02:15.235 --> 00:02:17.137 
不僅昂貴而且脆弱

00:02:18.672 --> 00:02:22.042 
因此現在運營商
在他們的網絡中部署IPv6

00:02:25.045 --> 00:02:28.949 
利用IPv6以繼續提供
端對端網絡連接，

00:02:29.316 --> 00:02:31.351 
不需要在數據路徑中進行轉換

00:02:33.420 --> 00:02:39.059 
現在 讓我們來看美國三個主要
蜂窩運營商的IPv6部署情況

00:02:42.196 --> 00:02:43.530 
我們可以看到兩個特點

00:02:44.264 --> 00:02:47.134 
首先所有趨勢線都是上升的

00:02:48.435 --> 00:02:51.271 
其次一半以上的用戶

00:02:51.338 --> 00:02:53.307 
現在通過IPv6連接到

00:02:53.373 --> 00:02:55.742 
蜂窩數據網絡

00:02:57.477 --> 00:02:58.378 
看起來不錯是吧

00:02:59.313 --> 00:03:01.148 
但是對於網絡運營商來說

00:03:01.215 --> 00:03:03.350 
實際情況比以前更加糟糕

00:03:04.284 --> 00:03:09.623 
原因是他們的網絡現在必須同時

00:03:10.023 --> 00:03:12.159 
支持IPv4和IPv6

00:03:13.427 --> 00:03:16.830 
他們真正需要的是消除通過IPv4

00:03:17.130 --> 00:03:18.198 
訪問他們的網絡

00:03:19.233 --> 00:03:21.735 
如果這樣做將會導致

00:03:21.802 --> 00:03:23.937 
完全依靠IPv4
連接網絡的設備和用戶流失

00:03:24.371 --> 00:03:25.606 
但 他們仍然是主流

00:03:28.041 --> 00:03:31.745 
現在運營商在他們的網絡中
部署NS64和NAT64

00:03:32.312 --> 00:03:35.148 
其實現方式是當客戶端設備上的APP

00:03:35.215 --> 00:03:37.784 
進行主機名稱查詢

00:03:38.218 --> 00:03:41.755 
以獲得IPv4-only服務器的
IPv6地址時

00:03:42.623 --> 00:03:47.194 
DNS64和網絡
將合成一個IPv6地址

00:03:47.327 --> 00:03:48.829 
並提供給客戶端設備

00:03:50.564 --> 00:03:53.967 
現在客戶端設備可以
使用這個IPv6地址

00:03:54.234 --> 00:03:56.303 
發送流量至網絡

00:03:57.638 --> 00:03:59.873 
網絡的配置方式

00:04:00.040 --> 00:04:03.710 
使搜索數據包被髮送給NAT64引擎

00:04:04.211 --> 00:04:06.880 
NAT64引擎
將IPv6流量轉換成爲IPv4流量

00:04:07.314 --> 00:04:09.983 
在客戶端設備返回流量時
NAT64引擎將進行相反的轉換

00:04:12.352 --> 00:04:14.354 
在這裏 必須注意的是

00:04:14.888 --> 00:04:17.457 
對於客戶端設備上運行的APP來說

00:04:18.559 --> 00:04:23.730 
你的IPv4-only服務器
看去就你是IPv6-only服務器

00:04:24.565 --> 00:04:25.933 
這個特性很重要

00:04:26.967 --> 00:04:29.303 
因爲你們一些人可能會認爲

00:04:30.003 --> 00:04:32.272 
我的服務器僅配置用於IPv4

00:04:32.773 --> 00:04:37.611 
因此我不需要針對通過IPv6進行
訪問的客戶端來測試我的APP

00:04:39.046 --> 00:04:40.747 
你的假設並不成立

00:04:42.416 --> 00:04:43.584 
我們很快就會轉換到

00:04:43.650 --> 00:04:46.753 
到這種類型的網絡 到那時

00:04:47.754 --> 00:04:51.325 
我們希望爲用戶提供無縫的用戶體驗

00:04:52.292 --> 00:04:58.899 
因此你的APP必須支持IPv6

00:05:00.200 --> 00:05:02.669 
APP必須符合這項要求

00:05:04.538 --> 00:05:06.640 
這是一項新的APP要求

00:05:07.007 --> 00:05:10.344 
你可能會想我應該如何針對此網絡
來測試我的APP呢?

00:05:11.011 --> 00:05:13.280 
我可以在哪裏找到這種
NAT64類型的網絡?

00:05:14.348 --> 00:05:16.583 
我有一個好消息告訴你們

00:05:19.086 --> 00:05:21.922 
你可以使用基於
IPv4連接的Mac設備

00:05:22.322 --> 00:05:26.793 
創建你自己的NAT64網絡

00:05:27.060 --> 00:05:29.396 
並可以開始測試你的APP

00:05:31.064 --> 00:05:33.367 
這項新功能供開發人員使用

00:05:33.767 --> 00:05:37.337 
它隱藏起來了
讓我們來看清楚一點你只需要

00:05:37.404 --> 00:05:44.344 
點擊“Sharing”選項
然後點擊

00:05:44.411 --> 00:05:48.549 
“Internet Sharing”
選項其他保持不變

00:05:49.449 --> 00:05:51.451 
這裏有一個新複選框顯示

00:05:51.852 --> 00:05:53.954 
“create
NAT64 network” 

00:05:55.189 --> 00:05:58.158 
選中之後 可以選擇

00:05:58.225 --> 00:06:02.095 
Internet共享接口
然後使用這個NAT64網絡

00:06:03.230 --> 00:06:04.731 
開始測試你的APP

00:06:05.866 --> 00:06:09.937 
在這裏舉例來說我有一個
IPv4 Internet連接

00:06:10.070 --> 00:06:12.339 
我想要使用NAT64/DNS64

00:06:12.573 --> 00:06:17.311 
將這個連接作爲
IPv6-only訪問網絡

00:06:17.644 --> 00:06:19.146 
在我的Wi-Fi
接口上進行共享

00:06:19.813 --> 00:06:25.285 
當我開始這樣做時我看到
Wi-Fi圖標變灰

00:06:25.586 --> 00:06:27.154 
並且變成箭頭

00:06:29.389 --> 00:06:31.225 
這表明Wi-Fi接口

00:06:31.658 --> 00:06:33.827 
轉爲接入點模式

00:06:34.528 --> 00:06:37.931 
其意義在於它成爲一個Wi-Fi熱點

00:06:38.198 --> 00:06:40.067 
你可以連接其他客戶端設備

00:06:40.200 --> 00:06:41.502 
並開始測試你的APP

00:06:42.503 --> 00:06:44.505 
典型的測試平臺是這樣的

00:06:46.673 --> 00:06:49.843 
在WAN側 IPv4
Internet連接已經完成

00:06:50.077 --> 00:06:54.381 
我的iMac已經在運行
DNS64/NAT64引擎

00:06:54.781 --> 00:06:58.852 
成爲使用Wi-Fi接口的
IPv6網絡熱點

00:07:00.087 --> 00:07:04.591 
你想要測試的APP
已經安裝在一臺客戶端機器上

00:07:05.192 --> 00:07:06.960 
你也可以在其他Mac設備上

00:07:07.060 --> 00:07:09.530 
運行的模擬器上測試你的APP

00:07:10.130 --> 00:07:12.666 
這個Mac必須是 
此Internet共享環境的客戶端

00:07:14.668 --> 00:07:17.237 
現在 你已經可以

00:07:17.938 --> 00:07:21.308 
在這種類型的網絡進行測試 
你真正想做的事情是

00:07:21.675 --> 00:07:25.212 
確保這種網絡成爲開發流程的組成部分

00:07:26.346 --> 00:07:28.815 
也就是說在任何時候
當你編寫新的APP

00:07:29.116 --> 00:07:31.385 
或者編寫APP更新版本時

00:07:31.785 --> 00:07:33.086 
你需要在提交APP之前

00:07:33.153 --> 00:07:37.591 
確保在NAT64網絡環境下
測試你的APP

00:07:39.359 --> 00:07:43.997 
現在對你們70%的人來說
這是一個好消息

00:07:44.064 --> 00:07:46.500 
你的APP運行正常

00:07:46.767 --> 00:07:47.968 
這很不錯吧

00:07:48.735 --> 00:07:50.437 
你可以放心地測試

00:07:50.737 --> 00:07:54.074 
各個版本的APP
確保不會有功能受到影響

00:07:55.676 --> 00:07:57.244 
但是有將近三分之一的人

00:07:58.178 --> 00:08:01.782 
將會看到
在NAT64MQXT網絡環境下

00:08:01.849 --> 00:08:05.752 
你的APP要麼受到嚴重的限制
或者根本無法運行

00:08:07.221 --> 00:08:09.790 
幸運的是大多數問題都容易修復

00:08:10.724 --> 00:08:11.658 
這裏是一個例子

00:08:18.932 --> 00:08:23.203 
現在如果你只使用
IPv4-only數據結構

00:08:23.437 --> 00:08:28.108 
或IPv4-only API
或者你使用同時支持

00:08:28.175 --> 00:08:30.711 
IPv4和IPv6的API

00:08:31.345 --> 00:08:34.414 
但是你傳遞一個參數

00:08:34.881 --> 00:08:38.784 
聲明你只想獲得IPv4結果

00:08:40.354 --> 00:08:43.657 
這會導致你的APP僅支持IPv4

00:08:44.324 --> 00:08:48.896 
這意味着 你的APP將無法在
IPv6-only網絡環境下運行

00:08:50.797 --> 00:08:53.567 
對於這些無法運行的APP

00:08:53.834 --> 00:08:56.203 
我們看到另外一件有意思的事情

00:08:57.771 --> 00:09:00.107 
有時候在嘗試連接之前

00:09:00.207 --> 00:09:03.877 
APP會預先選擇IPv4連接

00:09:05.045 --> 00:09:08.949 
因此有時候你會看到這樣的錯誤信息

00:09:10.851 --> 00:09:14.621 
在這種情況下我的iPhone
確實連接到我的Mac設備上

00:09:14.688 --> 00:09:17.724 
創建的NAT64網絡

00:09:18.492 --> 00:09:20.694 
我可以使用Safari 
瀏覽互聯網內容

00:09:20.761 --> 00:09:22.863 
我可以觀看視頻 聽音樂...

00:09:23.664 --> 00:09:25.132 
我的Internet連接正常

00:09:25.666 --> 00:09:30.571 
但是出於一些原因APP認爲我沒有
Internet連接

00:09:31.371 --> 00:09:34.308 
你會看到提示信息

00:09:34.374 --> 00:09:36.410 
說你的設備處於飛行模式

00:09:37.344 --> 00:09:40.647 
但是頂部信息欄卻不是這樣顯示的

00:09:42.382 --> 00:09:43.951 
那麼這是爲什麼呢？ 

00:09:44.418 --> 00:09:47.254 
這是因爲APP預先

00:09:47.321 --> 00:09:50.824 
設置成爲IPv4連接

00:09:51.291 --> 00:09:54.428 
但是在IPv6-only訪問網絡中
例如NAT64網絡

00:09:55.062 --> 00:09:57.364 
並沒有IPv4連接

00:09:57.664 --> 00:10:01.168 
整個網絡對你來說
完全是一個IPv6-only網絡

00:10:01.535 --> 00:10:05.272 
即使IPv4-only服務器
看上去像是IPv6-only服務器

00:10:05.672 --> 00:10:07.508 
因此如果選擇這樣的設置
將會發生失敗

00:10:08.375 --> 00:10:11.044 
在這種情況下APP將會提示你重試

00:10:11.144 --> 00:10:13.881 
我進行重試但是仍然會
顯示相同的錯誤信息

00:10:14.381 --> 00:10:16.617 
然後我再重試仍然顯示相同的錯誤信息

00:10:17.251 --> 00:10:20.287 
這個信息不會消失因此
無法使用APP進行其他操作

00:10:21.221 --> 00:10:22.823 
對此有什麼好方法嗎？

00:10:24.391 --> 00:10:26.593 
應該嘗試連接

00:10:27.961 --> 00:10:30.163 
如果能夠連接成功當然是好了

00:10:30.464 --> 00:10:33.400 
如果不能應該巧妙地進行處理

00:10:34.968 --> 00:10:36.603 
第二個建議是

00:10:36.670 --> 00:10:40.474 
使用更高級別的網絡框架
例如NSURLSession

00:10:41.041 --> 00:10:42.809 
或CFNetwork API

00:10:43.577 --> 00:10:50.450 
原因是像iPhone
和Mac等多址設備的

00:10:51.351 --> 00:10:54.454 
網絡連接有一點複雜

00:10:55.989 --> 00:10:57.791 
比如iPhone
不僅有Wi-Fi接口

00:10:57.858 --> 00:10:59.393 
還有蜂窩網絡接口

00:10:59.593 --> 00:11:02.029 
多於Mac設備可能有多個以太網接口

00:11:02.162 --> 00:11:04.731 
而且也有Wi-Fi接口

00:11:05.199 --> 00:11:07.467 
在特定的時間

00:11:07.568 --> 00:11:09.870 
所有這些接口可能有不同類型的連接

00:11:11.371 --> 00:11:16.009 
你需要考慮使用哪個接口
如何進行這種類型的連接

00:11:16.076 --> 00:11:18.312 
以連接到特定的目標

00:11:18.879 --> 00:11:22.082 
自已編寫代碼可能會費時費力

00:11:22.716 --> 00:11:25.552 
因此應該使用更高層次的網絡框架

00:11:25.886 --> 00:11:29.289 
這會讓你的APP代碼更加簡潔明瞭

00:11:31.291 --> 00:11:34.862 
如果出於某些原因
你不能使用更高層次的網絡框架 

00:11:35.462 --> 00:11:37.030 
而且你必須使用socket

00:11:37.965 --> 00:11:41.301 
我們建議你閱讀RFC 4038

00:11:42.202 --> 00:11:45.772 
此RFC詳細地介紹瞭如何在地址族

00:11:46.039 --> 00:11:47.908 
不可知的情況下編寫APP

00:11:50.611 --> 00:11:54.248 
我們的最後建議是儘可能使用主機名

00:11:54.314 --> 00:11:57.117 
而不是直接使用IP地址

00:11:57.284 --> 00:11:58.852 
無論IPv4或IPv6

00:11:59.786 --> 00:12:02.222 
當你編寫自己的專用協議

00:12:02.289 --> 00:12:04.491 
或者編寫APP時

00:12:04.558 --> 00:12:08.161 
應確保不要直接使用IP地址

00:12:08.562 --> 00:12:09.730 
而應該優先使用主機名

00:12:10.364 --> 00:12:11.632 
其原因是

00:12:11.999 --> 00:12:14.368 
在NAT64/DNS64網絡環境中

00:12:15.469 --> 00:12:17.871 
客戶端設備首先會發出DNS查詢請求

00:12:18.405 --> 00:12:20.440 
以獲得IPv4服務器的IPv6地址

00:12:20.641 --> 00:12:22.943 
因此你必須使用主機名

00:12:23.243 --> 00:12:25.512 
如果你需要使用IPv4地址

00:12:26.113 --> 00:12:28.415 
客戶端設備將不會進行DNS查詢

00:12:28.916 --> 00:12:32.853 
DNS64網絡將不會
爲你合成IPv6地址

00:12:35.422 --> 00:12:37.758 
我們知道有時候可能

00:12:38.725 --> 00:12:45.499 
無法避免使用IPv4
例如使用Safari進行瀏覽時

00:12:46.200 --> 00:12:48.669 
你打開一個網頁顯示正常

00:12:49.269 --> 00:12:52.139 
但是在網頁內可能有其他一些鏈接

00:12:53.841 --> 00:12:57.311 
這些鏈接可能具有嵌入的IPv4地址

00:12:59.179 --> 00:13:02.249 
在此之前在Safari瀏覽器中

00:13:02.316 --> 00:13:04.151 
如果你點擊這樣的鏈接
將不會打開網頁

00:13:06.053 --> 00:13:10.791 
從iOS 9
和OS X 10.11開始

00:13:11.225 --> 00:13:13.393 
不僅Safari而且任何

00:13:13.493 --> 00:13:18.265 
NSURLSession或
CFNetwork API用戶

00:13:18.632 --> 00:13:23.270 
將能夠在NAT64/DNS64
網絡中使用IPv4地址

00:13:24.605 --> 00:13:26.740 
其工作原理是當你使用主機名時

00:13:27.708 --> 00:13:31.111 
網絡中的DNS64將會
爲你合成IPv6 地址

00:13:32.546 --> 00:13:35.816 
但是當你直接使用IPv4地址

00:13:35.883 --> 00:13:38.118 
並且使用一個更高層次網絡API時

00:13:39.019 --> 00:13:42.823 
操作系統將會發現網絡行爲

00:13:42.890 --> 00:13:45.425 
並確定它將如何爲你

00:13:45.492 --> 00:13:47.694 
合成IPv6 地址
並在本地完成此工作

00:13:48.562 --> 00:13:51.565 
這也是你爲什麼應該使用更高層次

00:13:51.632 --> 00:13:52.999 
網絡框架的另一個原因

00:13:53.634 --> 00:13:54.468 
因此應該這樣做

00:13:56.670 --> 00:14:00.641 
希望你能夠利用這些數據點

00:14:01.275 --> 00:14:05.312 
和新工具找到並解決APP中的問題

00:14:07.748 --> 00:14:12.052 
我們希望你做的事情是
在本講座結束之後

00:14:12.419 --> 00:14:14.821 
在你們的Mac設備上
安裝seed build

00:14:15.222 --> 00:14:17.758 
開始創建自己的NAT64網絡

00:14:18.392 --> 00:14:20.160 
然後使用它們測試你的APP

00:14:21.495 --> 00:14:24.798 
請記住這是APP應該遵守的一項要求

00:14:25.732 --> 00:14:28.235 
請將這個信息傳達給

00:14:28.902 --> 00:14:31.638 
未參加本講座的其他開發人員

00:14:31.705 --> 00:14:35.909 
並且把這個消息帶回你的公司確保使用
NAT64網絡測試你的APP

00:14:38.145 --> 00:14:43.016 
現在請斯圖爾特·柴歇爾上臺

00:14:43.083 --> 00:14:45.352 
爲大家介紹其他的網絡功能

00:14:45.752 --> 00:14:48.121 
你們可以使用這些功能
更快速地開發APP

00:14:48.455 --> 00:14:50.490 
並且提高APP的響應速度

00:14:51.358 --> 00:14:52.192 
有請斯圖爾特

00:14:59.132 --> 00:14:59.967 
謝謝普拉巴卡爾

00:15:02.536 --> 00:15:07.074 
我們想要討論
如何讓APP加快運行速度

00:15:09.109 --> 00:15:10.544 
在過去的幾十年裏

00:15:10.611 --> 00:15:14.081 
我們看到網絡吞吐量飛速增長

00:15:15.048 --> 00:15:18.986 
我還記得在以前
56k調制解調器就已經

00:15:19.052 --> 00:15:21.321 
屬於尖端科技而現在

00:15:21.388 --> 00:15:24.691 
50Mb/s網速已經很常見

00:15:25.592 --> 00:15:27.761 
但是我們並沒有感覺到網速成千倍提升

00:15:28.629 --> 00:15:32.132 
我們仍然需要花大量的時間來
等待網頁打開

00:15:32.432 --> 00:15:33.267 
這是爲什麼呢？

00:15:34.701 --> 00:15:38.305 
這是因爲我們的行業專注於

00:15:38.405 --> 00:15:40.107 
提升吞吐量

00:15:41.175 --> 00:15:44.978 
但是卻忽略其他資源延遲

00:15:46.146 --> 00:15:48.148 
光速不會變得更快

00:15:48.916 --> 00:15:52.019 
對此我們無能爲力但是我們可以

00:15:52.119 --> 00:15:55.355 
消除其它方面的延遲
現在我們應該致力於這些工作

00:15:56.190 --> 00:15:58.492 
這就是我今天要討論的主題

00:15:59.560 --> 00:16:03.297 
我想要討論四種類型的資源延遲

00:16:03.897 --> 00:16:05.799 
當用戶使用APP可能會遇到這些延遲

00:16:06.967 --> 00:16:09.770 
首先是當你遇到
信號較弱的WiFi連接

00:16:10.070 --> 00:16:12.940 
而且連接不成功時

00:16:13.307 --> 00:16:14.975 
會遇到的延遲

00:16:15.976 --> 00:16:19.780 
第二個是使用“顯式擁塞通知”

00:16:19.847 --> 00:16:21.949 
即“Explicit Congestion
Notification”技術

00:16:22.015 --> 00:16:25.853 
和智能隊列功能來減少網絡延遲

00:16:27.020 --> 00:16:32.092 
TCP NOTSENT
Low-WaterMark選項

00:16:32.526 --> 00:16:35.429 
減少發送機器中的延遲

00:16:35.495 --> 00:16:36.964 
最後我們將瞭解

00:16:37.097 --> 00:16:39.900 
一種名爲TCP Fast Open的 
令人激動新的技術

00:16:40.734 --> 00:16:44.238 
我們先開始討論如何進行
可靠的網絡回退操作

00:16:45.405 --> 00:16:48.709 
我相信你們每個人都有這樣的經歷

00:16:49.076 --> 00:16:52.179 
下班之後離開辦公室

00:16:52.579 --> 00:16:55.048 
走向你的汽車拿出手機

00:16:55.749 --> 00:17:01.421 
然後想要查看地圖
天氣預報和郵件等

00:17:02.055 --> 00:17:06.859 
你盯着手機但是
沒有載入任何內容你走向汽車

00:17:06.926 --> 00:17:09.195 
但是仍然沒載入內容你感到煩躁不安

00:17:09.262 --> 00:17:11.164 
於是你進入“設置“關閉Wi-Fi

00:17:11.698 --> 00:17:13.834 
使用LTE數據連接網頁瞬間打開了

00:17:15.068 --> 00:17:17.069 
然後你忘記打開Wi-FI

00:17:17.137 --> 00:17:20.207 
一週之後你收到鉅額的數據流量賬單
這可不是你想要的

00:17:20.374 --> 00:17:22.709 
對於用戶體驗來說這是糟糕的事情

00:17:23.911 --> 00:17:28.147 
現在我們要做的事情是

00:17:28.482 --> 00:17:30.150 
設置並行連接數字邏輯

00:17:31.018 --> 00:17:33.520 
這樣如果你的iPhone
檢測到它在使用Wi-Fi

00:17:34.821 --> 00:17:38.325 
但是卻無法建立TCP連接

00:17:38.892 --> 00:17:44.598 
這時它會很快地通過蜂窩數據網絡

00:17:44.665 --> 00:17:47.367 
發起第二個並行連接

00:17:47.434 --> 00:17:49.803 
但是它不會完全中止Wi-Fi連接

00:17:49.870 --> 00:17:51.371 
並不會放棄Wi-Fi連接

00:17:51.438 --> 00:17:53.373 
它會並行嘗試Wi-Fi連接

00:17:53.907 --> 00:17:56.510 
如果連接成功

00:17:56.710 --> 00:17:58.111 
將會轉到Wi-Fi連接

00:17:58.812 --> 00:18:02.349 
如果連接不成功
蜂窩網絡連接將率先完成

00:18:02.416 --> 00:18:05.752 
這樣APP的網絡連接延將

00:18:06.954 --> 00:18:10.190 
將會很短用戶甚至不會發現

00:18:11.258 --> 00:18:13.460 
當然此功能僅用於

00:18:13.527 --> 00:18:15.462 
允許使用蜂窩網絡的APP

00:18:15.963 --> 00:18:17.631 
如果用戶進入設置

00:18:17.698 --> 00:18:20.901 
禁止APP連接數據網絡
我們將不會進行這種回退

00:18:22.069 --> 00:18:25.172 
如果我們進行回退將
會隱藏Wi-Fi圖標

00:18:25.606 --> 00:18:28.509 
讓用戶知道他們沒有使用Wi-Fi

00:18:31.545 --> 00:18:32.946 
如果你使用更高層次的API

00:18:33.347 --> 00:18:36.650 
這並不會佔用額外的資源

00:18:37.317 --> 00:18:40.921 
而且這並不會影響

00:18:40.988 --> 00:18:42.656 
用戶獲得良好的使用體驗

00:18:44.024 --> 00:18:45.893 
你還需要做另外一件事情

00:18:46.827 --> 00:18:50.631 
也就是當你在蜂窩網絡上運行時

00:18:52.099 --> 00:18:54.701 
無論你首先連接到蜂窩網絡

00:18:54.768 --> 00:18:56.537 
還是回退到蜂窩網絡

00:18:57.304 --> 00:19:01.041 
用戶最後還可能會
回到Wi-Fi範圍之內

00:19:01.275 --> 00:19:04.044 
那時，你將會看到
“Better Route”通知

00:19:04.611 --> 00:19:06.680 
然後你可以決定應該怎麼做

00:19:07.347 --> 00:19:11.418 
你可能想要斷開數據連接
重新連接到Wi-Fi

00:19:12.486 --> 00:19:15.055 
或者如果你的郵件
發送進度已經達到99%

00:19:15.122 --> 00:19:17.357 
你可能想要完成發送

00:19:17.424 --> 00:19:19.626 
但是
“Better Route”通知

00:19:19.693 --> 00:19:21.161 
讓你能夠進行

00:19:21.461 --> 00:19:23.130 
智能化的決定

00:19:23.430 --> 00:19:26.333 
從而儘量減少數據流量費用

00:19:31.205 --> 00:19:33.574 
下一個主題是網絡中的延遲

00:19:35.075 --> 00:19:39.546 
這是我在Apple TV
開發中遇到的問題

00:19:39.646 --> 00:19:43.383 
我們努力提高Apple TV的
響應速度

00:19:43.717 --> 00:19:45.686 
和理解延遲來源

00:19:46.420 --> 00:19:50.224 
我期望你們在座的每個人都聽說過
“bufferbloat”即“緩存膨脹”

00:19:51.391 --> 00:19:54.728 
我做過一些實驗並且想和你們分享

00:19:54.795 --> 00:19:56.129 
這些實驗的結果

00:19:56.396 --> 00:20:02.302 
讓你們理解對於我們的
所有APP和產品來說

00:20:02.603 --> 00:20:04.438 
消除網絡中的緩存膨脹問題是多麼重要

00:20:05.706 --> 00:20:09.209 
我測試過一個10Mb下行速度

00:20:09.676 --> 00:20:14.481 
模擬網絡環境，

00:20:14.548 --> 00:20:18.519 
這種網速對於觀看視頻來說已經足夠了

00:20:18.585 --> 00:20:24.424 
我將顯示使用代表性
網絡設置所獲得的結果

00:20:25.192 --> 00:20:28.061 
這是一種簡單的先進先出隊列

00:20:28.428 --> 00:20:30.597 
數據包被緩存直到隊列變滿

00:20:30.664 --> 00:20:34.067 
不能再容納更多數據包
新到達的數據包將被丟棄

00:20:35.002 --> 00:20:38.405 
這是現今的家用網關的典型配置

00:20:39.173 --> 00:20:42.876 
我將介紹另外一種更智能的
隊列處理方法和ECN機制並進行比較

00:20:44.545 --> 00:20:48.081 
我將介紹一些
使用tcptrace的方案

00:20:49.016 --> 00:20:52.486 
我期望你們
很多人都使用過tcptrace

00:20:52.819 --> 00:20:56.256 
如果你們沒有使用過
我強烈建議你們訪問

00:20:56.323 --> 00:20:58.892 
TCPtrace.org並下載它

00:20:59.793 --> 00:21:02.829 
如果你要編寫網絡代碼

00:21:03.363 --> 00:21:06.233 
而且不使用tcptrace
來查看你的數據包

00:21:06.567 --> 00:21:10.604 
你將沒有辦法弄清楚

00:21:10.904 --> 00:21:13.106 
運行機制或理解APP 

00:21:13.340 --> 00:21:15.375 
和協議的性能特徵

00:21:16.143 --> 00:21:19.780 
在我們編寫APP時
應該注意內存使用情況

00:21:20.480 --> 00:21:24.184 
應該分析代碼
弄清楚哪些代碼佔用CPU

00:21:24.618 --> 00:21:26.587 
然後優化代碼

00:21:26.720 --> 00:21:29.756 
以提高CPU效率
並且延長電池使用時間

00:21:31.191 --> 00:21:36.230 
爲此應該多關注CPU
和內存使用情況

00:21:36.763 --> 00:21:39.766 
但是也不能忽略網絡部分

00:21:39.900 --> 00:21:43.604 
Tcptrace是一個工具
讓你能夠方便地

00:21:43.737 --> 00:21:46.106 
進行網絡分析分析網絡流量

00:21:48.141 --> 00:21:51.845 
這是一個流媒體視頻的

00:21:52.112 --> 00:21:53.480 
前10秒的TCPtrace

00:21:53.947 --> 00:21:56.183 
如果你們一些人
以前沒有見過tcptrace

00:21:56.250 --> 00:21:58.252 
讓我來簡要介紹一下

00:21:58.952 --> 00:22:01.755 
這些白色的短線條表示數據包

00:22:02.823 --> 00:22:08.929 
白色線條所處的位置
表示數據包被捕獲的時間

00:22:10.364 --> 00:22:15.002 
白色線條的高度告訴我們

00:22:15.068 --> 00:22:18.305 
數據包有多少字節線條的垂直位置

00:22:18.372 --> 00:22:21.808 
告訴我們在整個邏輯TCP序列，
數字空間內的哪些位置

00:22:22.176 --> 00:22:25.946 
收到這些數據包

00:22:26.980 --> 00:22:30.450 
在這裏我們可以看到
正在按順序向外發送數據包流

00:22:30.951 --> 00:22:33.287 
其間隔爲數毫秒

00:22:34.655 --> 00:22:37.357 
在返回數據時
我們看到接收端的應答消息

00:22:37.424 --> 00:22:39.159 
聲稱它已經收到數據

00:22:40.360 --> 00:22:44.031 
綠色線條表示累積應答線條

00:22:44.498 --> 00:22:48.802 
所有數據包括綠色線條
都得到接收端的確認

00:22:49.636 --> 00:22:53.774 
因此沒有任何白色數據包
位於綠色線條之下

00:22:54.408 --> 00:22:55.542 
那將表示存在bug

00:22:56.343 --> 00:22:59.680 
我們看到沒有白色數據包
位於綠色線條之下這說明一切正常

00:23:01.381 --> 00:23:04.585 
黃色線條表示接收窗口

00:23:05.285 --> 00:23:10.390 
當你打開TCP連接時
接收端將指示它分配多少內存

00:23:11.592 --> 00:23:17.898 
來接收你的數據
不應該超過這個分配給你的內存量限值

00:23:18.532 --> 00:23:22.035 
如果你看到白色數據包位於黃色線之上

00:23:22.336 --> 00:23:24.171 
表示存在bug我們沒有看到這種情況

00:23:24.371 --> 00:23:25.205 
這說明一切正常

00:23:28.041 --> 00:23:30.911 
數據傳輸看起來

00:23:30.978 --> 00:23:33.413 
顯示爲一條直線

00:23:33.480 --> 00:23:37.084 
這條曲線的斜率是10Mb/s

00:23:37.818 --> 00:23:41.989 
這正是我們所期望的但是每隔幾秒

00:23:42.089 --> 00:23:43.690 
我們看到這種情況

00:23:44.358 --> 00:23:48.562 
讓我們來放大仔細觀察

00:23:48.795 --> 00:23:50.330 
發生了什麼

00:23:52.933 --> 00:23:56.203 
這些TCPtrace
圖形提供豐富的信息

00:23:56.737 --> 00:23:59.640 
我可以花上一個小時的時間
來講解這些幻燈片

00:23:59.973 --> 00:24:01.675 
但是我們並沒有時間這樣做

00:24:02.042 --> 00:24:07.781 
我會講解這個圖形中的一些重要信息

00:24:09.283 --> 00:24:14.421 
首先白色數據包線看起來正在

00:24:15.455 --> 00:24:16.990 
偏離綠色應答線條

00:24:17.724 --> 00:24:20.861 
這意味着我們將數據發送到

00:24:20.928 --> 00:24:25.699 
網絡的速度快於數據從另一側被輸出

00:24:25.799 --> 00:24:27.601 
和被應答的數據

00:24:28.068 --> 00:24:29.970 
如果數據被輸入的速度

00:24:30.470 --> 00:24:31.872 
快於被輸出的速度

00:24:33.540 --> 00:24:34.875 
情況就會變得不一樣

00:24:35.409 --> 00:24:40.514 
數據將會進入緩存網絡緩存中的

00:24:40.681 --> 00:24:44.618 
舊數據將會增大

00:24:45.252 --> 00:24:47.421 
由於緩存數據量增大

00:24:47.855 --> 00:24:51.692 
意味着數據包發送與

00:24:51.758 --> 00:24:54.461 
接收端應答之間的往返延遲增大

00:24:56.597 --> 00:24:58.298 
當緩存數據量達到一定程度時

00:24:58.599 --> 00:25:01.001 
網關將無法緩存更多數據

00:25:01.301 --> 00:25:02.669 
將開始出現丟包現象

00:25:04.404 --> 00:25:08.141 
將會發生混亂而且是非常嚴重的混亂

00:25:08.442 --> 00:25:13.180 
因此數據包進入隊列末尾的速度

00:25:13.247 --> 00:25:18.218 
將會快於數據包出列的速度
我們收到數據包但是會丟失它們

00:25:18.719 --> 00:25:20.120 
其他數據包也會被丟失

00:25:20.387 --> 00:25:22.923 
隊列被清空一點
我們獲得一個數據包接受它

00:25:23.490 --> 00:25:27.294 
在隊列的末尾是一片混亂

00:25:27.361 --> 00:25:30.664 
它獲得一個數據包就會丟失一個數據包

00:25:31.832 --> 00:25:33.233 
但是在隊列前部

00:25:33.700 --> 00:25:38.005 
有200個數據包依次排列等待
它們需要有序地

00:25:38.071 --> 00:25:40.207 
經過10Mb瓶頸鍊路

00:25:40.340 --> 00:25:42.776 
不能有間隔不能發生問題

00:25:43.177 --> 00:25:45.946 
只有在整個隊列的數據

00:25:46.380 --> 00:25:48.282 
發送完之後我們纔會看到

00:25:48.348 --> 00:25:50.984 
反映在發送端選擇性應答消息中的

00:25:51.785 --> 00:25:54.988 
接收端的數據包丟失情況

00:25:55.322 --> 00:25:56.623 
然後開始進行補包

00:25:57.057 --> 00:25:58.992 
因此這是嚴重的混亂現象

00:26:01.795 --> 00:26:04.231 
由於網絡傳輸API的工作方式

00:26:04.865 --> 00:26:06.266 
數據必須依次傳輸

00:26:07.634 --> 00:26:10.771 
如果一個數據包丟擋住

00:26:10.838 --> 00:26:12.806 
其後抵達的所有數據包
在內核中將被延遲

00:26:13.040 --> 00:26:14.608 
直到間隙被填滿

00:26:15.075 --> 00:26:17.911 
這是有道理的

00:26:18.145 --> 00:26:21.114 
很多人曾經建議使用無序傳輸方法

00:26:21.515 --> 00:26:24.284 
但是結果發現幾乎所有APP都很難

00:26:24.351 --> 00:26:25.619 
使用無序數據

00:26:25.919 --> 00:26:29.890 
如果你要解碼H.264視頻

00:26:29.957 --> 00:26:33.193 
只獲得數據幀而無法獲得它們
所依賴的I-Frame將不會有意義

00:26:33.560 --> 00:26:38.866 
因此順序數據傳輸確實是
APP所需的傳輸模式

00:26:40.767 --> 00:26:42.336 
順序數據傳輸導致

00:26:42.803 --> 00:26:45.405 
我們看到這些長時間的空白期
在此期間沒有數據傳輸

00:26:46.173 --> 00:26:49.543 
對於Apple TV
視頻回放流程來說

00:26:50.043 --> 00:26:52.846 
這相當於一個無信號時間段

00:26:53.013 --> 00:26:54.181 
在此期間將接收不到數據

00:26:54.815 --> 00:26:58.085 
我們不想要視頻卡住

00:26:58.819 --> 00:27:02.422 
因此所有流媒體視頻
都需要一個回放緩衝區

00:27:03.457 --> 00:27:06.627 
較大的回放緩衝區意味着

00:27:06.727 --> 00:27:08.262 
當你觀看流媒體視頻時

00:27:08.595 --> 00:27:11.532 
你會看到不斷旋轉的圖標提示正在緩衝

00:27:12.032 --> 00:27:14.134 
因爲緩衝區還有填滿

00:27:14.401 --> 00:27:19.239 
因此當長時間沒有數據到達時
可能會始終顯示這個圖標

00:27:20.240 --> 00:27:23.277 
當丟失的數據包到達時
我們開始填滿間隙

00:27:23.477 --> 00:27:24.745 
並且立即播放視頻

00:27:26.580 --> 00:27:30.884 
這將會給網絡接收線程帶來額外的負擔

00:27:31.518 --> 00:27:36.089 
它需要將CPU時間分配給
視頻播放線程之外的其他線程

00:27:36.690 --> 00:27:40.327 
從而造成視頻播放卡頓

00:27:40.427 --> 00:27:41.261 
這不是我們想要的

00:27:43.730 --> 00:27:48.735 
這種不均衡的網絡數據傳輸
給Apple TV等設備

00:27:48.836 --> 00:27:51.471 
造成不佳的用戶體驗在我們努力降低

00:27:52.005 --> 00:27:54.741 
設備的成本時

00:27:55.542 --> 00:27:59.112 
這種長時間的數據空白期

00:27:59.346 --> 00:28:02.549 
相當於我們需要增大設備內存
來緩存更多數據

00:28:03.217 --> 00:28:07.421 
並且推遲視頻開始時間和降低用戶體驗

00:28:08.789 --> 00:28:12.993 
這種傳輸不均衡現象

00:28:13.060 --> 00:28:15.562 
還會導致設備需要更快的CPU

00:28:15.829 --> 00:28:16.930 
從而擡升設備價格

00:28:17.431 --> 00:28:24.304 
因此對於流媒體視頻來說
這種不均衡的傳輸是十分有害的

00:28:25.672 --> 00:28:27.741 
一個有意思的事情是

00:28:28.175 --> 00:28:33.981 
如果你跟蹤觀察
黃色應答線條的斜率...

00:28:34.381 --> 00:28:37.117 
黃色窗口線和和綠色應答線條

00:28:37.651 --> 00:28:41.088 
你會發現如果不發生丟包在軌跡末端

00:28:41.288 --> 00:28:44.258 
線條會回到它們原本應該所在的位置

00:28:44.758 --> 00:28:47.494 
因爲TCP協議能夠高效率地

00:28:47.561 --> 00:28:51.164 
一次性填充需要重新傳輸的數據包

00:28:51.698 --> 00:28:54.735 
而不會傳輸其他不需要重新傳輸的數據

00:28:55.202 --> 00:28:56.937 
因此它將會返回原本應該所處的位置

00:28:57.905 --> 00:29:00.674 
如果使用Iperf測量網絡速度

00:29:00.741 --> 00:29:01.909 
並且查看測量值

00:29:02.509 --> 00:29:04.211 
你將會看到它顯示爲10Mb/s

00:29:04.545 --> 00:29:07.347 
你會說很好我的網絡一切正常

00:29:08.415 --> 00:29:10.984 
但是如果你探究這些信息

00:29:11.051 --> 00:29:15.422 
分析具體的數據

00:29:15.622 --> 00:29:17.224 
你就會發現實際的網絡情況

00:29:22.162 --> 00:29:25.799 
現在我們知道是什麼原因

00:29:25.966 --> 00:29:27.935 
造成網絡性能下降

00:29:28.669 --> 00:29:31.004 
我決定使用智能網絡進行實驗

00:29:31.572 --> 00:29:35.142 
對於這個實驗我使用
一種名爲CoDel的智能隊列算法

00:29:35.209 --> 00:29:38.045 
它是Controlled
Delay的簡稱

00:29:39.313 --> 00:29:42.015 
其工作原理不是填充隊列

00:29:42.082 --> 00:29:47.754 
直到隊列溢出並丟失數據
相反它監測隊列的狀態

00:29:48.388 --> 00:29:51.925 
當隊列快要變滿時

00:29:51.992 --> 00:29:56.864 
將會把它視爲一個擁塞信號

00:29:57.764 --> 00:29:59.199 
對於擁塞很多人認爲

00:30:00.267 --> 00:30:03.370 
我說的是高峯時間出現的情況

00:30:03.437 --> 00:30:05.506 
實際上不是這樣的

00:30:05.572 --> 00:30:09.109 
必須理解的是在網絡數據傳輸中

00:30:09.610 --> 00:30:12.312 
擁塞始終存在

00:30:12.846 --> 00:30:14.515 
它是一種穩定的網絡狀態

00:30:14.581 --> 00:30:17.584 
TCP等傳輸協議的任務是

00:30:18.085 --> 00:30:20.821 
最大限度地利用網絡

00:30:21.321 --> 00:30:23.857 
以確定網絡的最大承載能力

00:30:24.324 --> 00:30:25.626 
並且最高效地利用網絡

00:30:26.560 --> 00:30:28.295 
傳輸協議的工作原理是

00:30:28.362 --> 00:30:32.900 
它越來越快地傳輸數據

00:30:32.966 --> 00:30:35.502 
同時始終進行偵測
它嘗試不斷髮送更多的數據

00:30:36.069 --> 00:30:39.573 
直到發生丟包這時它將
知道負載過大並開始削減流量

00:30:40.040 --> 00:30:42.609 
它始終進行這種嘗試
以找到合適的傳輸速率

00:30:42.943 --> 00:30:44.478 
這意味着它始終在嘗試

00:30:44.778 --> 00:30:47.381 
使網絡進入擁塞狀態

00:30:47.447 --> 00:30:51.618 
然後降低傳輸負載從而減少擁塞

00:30:52.452 --> 00:30:56.723 
CoDel的工作原理並不是
等待網絡進入擁塞狀態

00:30:57.391 --> 00:30:58.625 
然後發出擁塞信息

00:30:59.326 --> 00:31:04.298 
在發現第一個擁塞信號之後
它就會通知發送端

00:31:06.466 --> 00:31:09.403 
在這個實驗中我做的另一事情

00:31:09.469 --> 00:31:12.105 
不是通過丟包來指示擁塞

00:31:12.172 --> 00:31:13.674 
這需要重新傳輸

00:31:14.274 --> 00:31:17.411 
相反我使用一種名爲“顯式擁塞通知”
即Explicit Congestion 

00:31:17.878 --> 00:31:22.482 
Notification的新技術
智能隊列算法不會丟棄數據包

00:31:22.850 --> 00:31:26.220 
它設置IP標頭中的一個位
聲明遇到擁塞

00:31:26.854 --> 00:31:29.923 
這個消息被傳回給發送端
發送端作出響應

00:31:29.990 --> 00:31:33.894 
降低傳輸速度
而不會造成破壞性的丟包後果

00:31:37.831 --> 00:31:41.869 
這是使用CoDel和ECN的

00:31:42.069 --> 00:31:46.173 
數據傳輸示意圖如果我放大

00:31:46.240 --> 00:31:50.511 
前面看過的相同部分
你可以看到非常明顯的差別

00:31:51.111 --> 00:31:52.646 
在我進行這些實驗時

00:31:52.946 --> 00:31:56.216 
我計劃用一週的時間
來完成這些工作和收集數據

00:31:56.917 --> 00:31:59.419 
結果只用了兩個小時就全部完成了

00:31:59.753 --> 00:32:03.590 
一個方案使用標準配置來執行
一個方案使用CoDel來執行

00:32:03.790 --> 00:32:06.693 
這是我的第一個實驗

00:32:06.760 --> 00:32:11.498 
我預計需要調整參數重試並返回實驗

00:32:12.165 --> 00:32:16.436 
但是沒有發生這種情況 差別很明顯

00:32:16.570 --> 00:32:18.405 
只需進行一次試驗就夠了

00:32:18.972 --> 00:32:20.274 
好像有人在鼓掌 謝謝

00:32:26.380 --> 00:32:28.882 
我們沒有看到傳輸中斷現象

00:32:28.949 --> 00:32:31.385 
也沒有出現高峯擁塞

00:32:32.052 --> 00:32:35.389 
每次出現輕微的隊列擁塞時

00:32:35.956 --> 00:32:37.991 
CoDel算法就會發出信號

00:32:38.058 --> 00:32:40.327 
要求降低傳輸速度

00:32:40.794 --> 00:32:44.531 
這個方案的CWR標記
的含義是“減少擁塞窗口期”

00:32:44.598 --> 00:32:47.201 
這是TCP的應答消息
意思是消息已經被接收和理解

00:32:47.267 --> 00:32:48.836 
我已經降低傳輸速率

00:32:49.636 --> 00:32:50.704 
這確實很不錯

00:32:53.507 --> 00:32:56.076 
總的來說CoDel

00:32:56.143 --> 00:32:58.512 
和其他隊列算法非常有效

00:32:58.846 --> 00:32:59.847 
ECN十分有效

00:33:00.614 --> 00:33:02.449 
將它們組合在一起將會功效倍增

00:33:05.519 --> 00:33:07.621 
那麼如果這麼有效
應該在哪裏使用它們？

00:33:08.222 --> 00:33:11.758 
從歷史來看對於傳統的網絡應用來說

00:33:11.825 --> 00:33:14.728 
例如文件傳輸和發送電子郵件等

00:33:14.795 --> 00:33:19.166 
丟包和重新傳輸並不會造成嚴重的問題

00:33:21.635 --> 00:33:24.905 
當你傳輸文件時原則上傳輸層將會

00:33:24.972 --> 00:33:28.242 
最後發送第一個數據包

00:33:28.308 --> 00:33:31.111 
而且最先發送最後一個數據包
其間的所有數據包

00:33:31.178 --> 00:33:33.580 
將會隨機發送 在數據包全部到達之後

00:33:33.647 --> 00:33:37.317 
將會按照文件的正確順序重新進行組裝
這就是你需要關注的所有事情

00:33:38.519 --> 00:33:40.721 
但是當你觀看流媒體視頻時

00:33:41.255 --> 00:33:45.792 
你並不想先看到結尾最後看到開頭

00:33:46.293 --> 00:33:47.494 
你希望按順序觀看

00:33:47.961 --> 00:33:51.565 
這時按順序發送數據
就成爲一個更緊迫的問題

00:33:52.032 --> 00:33:54.301 
現在我們通過
Internet傳輸流媒體視頻

00:33:57.538 --> 00:33:59.773 
這裏的一個特點是在以前的應用中

00:33:59.840 --> 00:34:03.110 
例如點擊發送電子郵件等

00:34:03.710 --> 00:34:06.246 
需要發送的數據量是預先確定的

00:34:07.114 --> 00:34:09.315 
而發送所需要的時間是可變的

00:34:10.250 --> 00:34:13.387 
基本上網絡發送電子郵件

00:34:13.453 --> 00:34:16.389 
所需要的時間是越少越好

00:34:17.024 --> 00:34:19.193 
我們並沒有郵件發送過快這樣的說法

00:34:20.060 --> 00:34:23.130 
發送時間是可變的你希望它越快越好

00:34:23.463 --> 00:34:25.532 
現在的應用則有不同

00:34:26.833 --> 00:34:29.136 
比如你通過Internet

00:34:29.402 --> 00:34:31.103 
觀看兩個小時的電影

00:34:32.172 --> 00:34:35.542 
我們不應該半個小時
或八個小時內看完成

00:34:35.742 --> 00:34:37.210 
而必須是兩個小時

00:34:38.045 --> 00:34:40.013 
現在我們的應用必須具有適應能力

00:34:40.080 --> 00:34:42.549 
時間是固定的但是必須調整

00:34:42.616 --> 00:34:45.118 
這段時間內發送的數據量

00:34:45.219 --> 00:34:47.020 
以適應網絡狀況

00:34:50.591 --> 00:34:51.592 
現在的情況是怎樣的？

00:34:52.125 --> 00:34:55.161 
讓人驚奇的是
Linux已經支持此功能

00:34:55.228 --> 00:34:59.433 
而且在世界性能最強的
一百萬臺Web服務器中

00:34:59.499 --> 00:35:01.502 
一半以上默認支持ECN

00:35:02.169 --> 00:35:04.505 
對於一項無人使用的技術來說

00:35:04.571 --> 00:35:06.240 
這種應用廣泛性是驚人的

00:35:10.043 --> 00:35:14.748 
客戶端並不請求ECN連接

00:35:14.815 --> 00:35:16.984 
它們不請求ECN在很大程度上

00:35:17.417 --> 00:35:20.721 
是因爲Internet
不支持ECN標記

00:35:21.021 --> 00:35:24.691 
如果你啓用這個選項

00:35:24.758 --> 00:35:27.661 
可能會帶來暴露bug的風險
而且沒有直接好處

00:35:29.630 --> 00:35:30.697 
那麼路由器在做什麼？ 

00:35:30.764 --> 00:35:33.600 
沒有路由器進行標記

00:35:33.667 --> 00:35:36.737 
因爲沒有客戶端請求它們
那麼爲什麼要設計

00:35:36.803 --> 00:35:39.072 
這樣具有風險而且無人使用的功能呢？

00:35:39.339 --> 00:35:43.310 
今天我高興地宣佈
Apple將首開先河

00:35:43.610 --> 00:35:44.745 
打破這個僵局

00:35:45.212 --> 00:35:50.250 
在所有的基本應用中默認情況下

00:35:50.617 --> 00:35:54.888 
所有應用的所有
TCP連接將支持ECN

00:36:01.895 --> 00:36:05.432 
我們將不會看到任何問題

00:36:05.933 --> 00:36:07.234 
在我們的測試中一切運行正常

00:36:07.701 --> 00:36:10.537 
我已經在我自己的
筆記本電腦上運行很長時間

00:36:11.672 --> 00:36:14.808 
當然我們希望傾聽你們的體會

00:36:14.975 --> 00:36:19.379 
請接受這些基本應用在你的家庭網絡

00:36:20.047 --> 00:36:22.816 
工作單位酒店和機場使用它們

00:36:23.350 --> 00:36:26.620 
和以前一樣如果發現任何bug
請報告給Apple

00:36:27.421 --> 00:36:30.357 
如果我們取得成功幾個月之後

00:36:30.424 --> 00:36:32.659 
將會有數百萬設備運行ECN

00:36:33.527 --> 00:36:37.231 
這樣ISP將有足夠的動力
來提供這項服務

00:36:39.466 --> 00:36:43.036 
現在我們將主題從網絡延遲

00:36:43.337 --> 00:36:45.339 
轉移到終端系統延遲

00:36:46.306 --> 00:36:50.410 
許多技術進步的出發點是爲了

00:36:50.477 --> 00:36:53.447 
克服我們自己遇到的不便之處
這裏也同樣如此

00:36:54.681 --> 00:36:59.319 
我使用屏幕共享功能
連接到我家裏的Mac計算機

00:36:59.920 --> 00:37:01.221 
這種功能真不錯

00:37:01.855 --> 00:37:05.359 
我能夠遠程控制計算機
能夠訪問計算機上的數據

00:37:06.026 --> 00:37:11.164 
能夠開始費時的視頻轉碼

00:37:11.231 --> 00:37:13.100 
在我到家時就已經完成轉碼

00:37:13.734 --> 00:37:14.935 
這些確實不錯

00:37:16.003 --> 00:37:18.405 
在我進行這些實驗時

00:37:19.907 --> 00:37:23.143 
我使用的是很慢的DSL線路

00:37:24.011 --> 00:37:27.247 
當然DSL是非對稱的

00:37:27.648 --> 00:37:31.919 
一般來說下行速度比上行速度快十倍

00:37:32.753 --> 00:37:34.755 
當你進行屏幕共享時

00:37:35.189 --> 00:37:37.391 
數據傳輸方向是上行方向

00:37:37.558 --> 00:37:41.662 
因此速度會比較慢

00:37:42.563 --> 00:37:45.065 
這有一點像那個衆人皆知的
關於熊跳舞的笑話

00:37:45.399 --> 00:37:47.334 
當你看到熊跳舞時

00:37:47.401 --> 00:37:49.203 
你不應該驚訝於熊跳舞跳得很好

00:37:49.303 --> 00:37:51.405 
而應該驚訝於熊會跳舞

00:37:52.172 --> 00:37:58.178 
多年人與很多人一樣
我被這個讓人難受的

00:37:58.245 --> 00:38:04.618 
勉強可用的功能所困擾
我發現當我點擊一個菜單時

00:38:04.685 --> 00:38:08.288 
要花費三到四秒的時間

00:38:08.355 --> 00:38:10.791 
菜單纔會顯示出來
這樣使用計算機幾分鐘之後

00:38:10.858 --> 00:38:14.394 
讓人感到非常不舒服

00:38:14.461 --> 00:38:16.430 
有時候恨不得快點開車回家

00:38:16.496 --> 00:38:17.764 
親自在計算機上操作

00:38:19.800 --> 00:38:22.636 
我曾經研究過
“bufferbloat”

00:38:23.270 --> 00:38:25.606 
和網絡中的過度隊列

00:38:25.973 --> 00:38:30.644 
很自然地我首先感到不滿

00:38:30.911 --> 00:38:32.412 
並且開始研究

00:38:32.713 --> 00:38:35.349 
我最初認爲罪魁禍首

00:38:35.415 --> 00:38:37.851 
應該是這個愚蠢的DSL調制解調器

00:38:37.918 --> 00:38:39.520 
產生過度的緩存膨脹

00:38:40.153 --> 00:38:41.455 
於是我ping計算機

00:38:42.189 --> 00:38:44.391 
ping時間爲35ms

00:38:45.292 --> 00:38:48.729 
當我點擊鼠標時
卻需要3秒才能顯示鼠標

00:38:49.796 --> 00:38:52.866 
我意識到情況可能
與我當初設想的不一樣

00:38:53.700 --> 00:38:55.169 
那麼延遲來自於哪裏呢？

00:38:56.003 --> 00:38:59.139 
對此我進行了一些研究

00:39:00.641 --> 00:39:04.211 
當時默認socket發送的
緩存數據是120KB

00:39:04.645 --> 00:39:08.248 
我的網速率大約是50KB/s

00:39:08.415 --> 00:39:10.250 
用時約爲2.5秒

00:39:10.450 --> 00:39:12.119 
這與我看到的延遲時間差不多

00:39:14.054 --> 00:39:17.257 
發送緩衝數據的socket 
具有十分重要的意義

00:39:18.492 --> 00:39:21.762 
當我們使用TCP等協議時

00:39:22.262 --> 00:39:25.666 
它會發送一個數據包等待應答

00:39:25.732 --> 00:39:27.801 
然後再發送一個數據包再等待應答

00:39:28.135 --> 00:39:29.503 
這樣的性能十分低下

00:39:29.903 --> 00:39:32.906 
我們需要一次發送多個數據包
我們需要足夠多的數據包

00:39:32.973 --> 00:39:37.110 
以充分利目的地往返傳輸路徑的帶寬

00:39:37.778 --> 00:39:40.881 
而且必須緩存這些數據包

00:39:40.948 --> 00:39:44.585 
這樣當它們丟失時可以重新進行傳輸。

00:39:45.085 --> 00:39:47.254 
最大限度利用連接吐吞率

00:39:47.588 --> 00:39:50.290 
是一個很好有用而且必要的方法

00:39:51.091 --> 00:39:53.460 
但於超過需求的緩存

00:39:53.527 --> 00:39:57.865 
僅僅會增加延遲而不會帶來好處

00:39:58.065 --> 00:39:59.366 
它不會幫助提高吞吐率

00:39:59.867 --> 00:40:00.767 
而只會增大延遲

00:40:01.635 --> 00:40:04.371 
最終我們只會得到這樣的結果

00:40:05.205 --> 00:40:08.742 
我們一次僅傳輸少量的數據
而且這些數據進入緩存

00:40:08.976 --> 00:40:10.544 
以備在需要時重新傳輸

00:40:11.211 --> 00:40:15.816 
而另一方面有大量的數據
在內核中等待被髮送出去

00:40:20.287 --> 00:40:22.356 
這讓我明白

00:40:23.824 --> 00:40:27.761 
不僅網絡上存在延遲
而且主機之中存大量延遲

00:40:29.796 --> 00:40:33.066 
屏幕共享程序會抓取
一個畫面幀將它送入緩存

00:40:33.267 --> 00:40:36.370 
再抓取一個畫面幀將它送入緩存
內核將會讓這些幀

00:40:36.770 --> 00:40:43.410 
像葡萄酒那樣長時間陳釀然後纔會在
特定時間將它們通過網絡發送出去

00:40:45.679 --> 00:40:51.185 
爲此我們引入了
TCP_NOTSENT-LOWAT

00:40:51.251 --> 00:40:52.286 
套接字選項

00:40:53.120 --> 00:40:54.488 
發送這個選項時

00:40:55.622 --> 00:40:58.625 
Socket_Send_Buffer
保持不變

00:40:59.693 --> 00:41:02.763 
區別在於kevent

00:41:03.330 --> 00:41:07.768 
或你的run loop不會報告
Socket正在被寫入

00:41:08.135 --> 00:41:10.637 
直到未發送的數據量

00:41:10.804 --> 00:41:13.040 
達到很低的閥值

00:41:13.106 --> 00:41:14.808 
通常爲8或16KB

00:41:15.809 --> 00:41:17.477 
當socket轉爲可寫入狀態時

00:41:18.045 --> 00:41:23.217 
你可以將單個有用的
基本數據塊寫入緩存

00:41:23.951 --> 00:41:27.621 
不需要循環操作中
內核中也不會積累過多的數據

00:41:27.688 --> 00:41:30.490 
因爲現在內存已經很便宜
它可以容納大量的數據

00:41:31.525 --> 00:41:33.360 
你只需寫入一個感應單元

00:41:33.627 --> 00:41:36.363 
在屏幕共享程序中它是一個幀

00:41:37.231 --> 00:41:38.932 
現在的情況是這樣的

00:41:40.033 --> 00:41:42.102 
有數據在等待發送它們位於緩存中

00:41:42.436 --> 00:41:44.671 
需要等待較短的時間讓它們發送出去

00:41:45.739 --> 00:41:48.208 
在發送完畢之後中達到閥值

00:41:49.142 --> 00:41:50.444 
Socket轉爲可寫入狀態

00:41:51.178 --> 00:41:52.479 
我們寫入一個數據塊

00:41:52.846 --> 00:41:54.781 
在它發送完畢之後再寫入更多數據塊

00:41:55.482 --> 00:41:58.285 
現在我爲你們演示這個過程

00:42:07.094 --> 00:42:08.495 
在這裏我將要在這臺計算機上

00:42:08.862 --> 00:42:11.498 
使用屏幕共享程序連接到這臺計算機

00:42:12.432 --> 00:42:15.736 
我將使用一個運行
sarawert[猜測寫法]的網關

00:42:15.903 --> 00:42:18.372 
來模擬DSL連接

00:42:20.307 --> 00:42:25.312 
讓我們調出終端窗口

00:42:32.252 --> 00:42:33.086 
看到了

00:42:34.988 --> 00:42:36.657 
我將移動這個窗口

00:42:37.791 --> 00:42:40.694 
你可以看到鼠標指針在移動

00:42:40.961 --> 00:42:42.429 
因爲它是本地生成的

00:42:42.829 --> 00:42:45.766 
實際的圖形更新是由遠程計算機生成的

00:42:46.200 --> 00:42:48.702 
讓我們窗口移動這裏

00:42:48.936 --> 00:42:50.237 
不 不是這裏

00:42:50.304 --> 00:42:53.240 
讓我們移動它 不
我想讓它回到原來的地方

00:42:53.307 --> 00:42:54.308 
雙手離開鍵盤

00:43:02.182 --> 00:43:04.451 
讓我們調出菜單：Shell

00:43:09.122 --> 00:43:11.191 
它出現了
讓我們打開“Edit”

00:43:11.425 --> 00:43:12.659 
或者“View”

00:43:18.565 --> 00:43:21.568 
這個演示讓人感覺很着急

00:43:21.802 --> 00:43:24.905 
看起來遠程使用我的計算機
是非常費勁的事情

00:43:25.439 --> 00:43:28.842 
這需要很好的耐心

00:43:31.078 --> 00:43:35.282 
現在我一個新的方法

00:43:36.383 --> 00:43:41.188 
我啓用
TCP_NOTSENT-LOWAT選項

00:43:49.296 --> 00:43:52.432 
然後重新進行連接
我可以隨意拖動這個窗口

00:44:05.445 --> 00:44:06.280 
謝謝

00:44:06.446 --> 00:44:13.387 
多年來 在BSD網絡應用中

00:44:13.453 --> 00:44:18.959 
我們一直忍受着這種極其
糟糕的屏幕共享連接

00:44:20.093 --> 00:44:26.400 
好消息是我們已經解決這個問題

00:44:27.234 --> 00:44:28.836 
現在此技術已經在

00:44:33.707 --> 00:44:39.680 
10.10.3最新版本中得到應用

00:44:39.746 --> 00:44:42.115 
如果發現屏幕共享得到越來越多的運用

00:44:42.649 --> 00:44:44.451 
背後的原因就在這裏

00:44:44.985 --> 00:44:49.590 
此技術已經被AirPlay使用
而且也可以在Linux中使用

00:44:50.157 --> 00:44:54.161 
因爲此選項應用於發送端數據源

00:44:54.628 --> 00:44:57.364 
因此如果你運行Linux服務器

00:44:57.698 --> 00:44:59.800 
此選項也可以用於你的服務器

00:45:03.170 --> 00:45:08.242 
對於實時應用來說
這種降低延遲的好處很明顯的

00:45:09.843 --> 00:45:13.881 
在製作本講座的幻燈片時

00:45:14.014 --> 00:45:15.048 
我將APP分爲兩類

00:45:15.115 --> 00:45:18.352 
一類APP應該使用
tcp_notsent-lowat選項

00:45:18.418 --> 00:45:19.586 
另一類APP不應該使用

00:45:20.287 --> 00:45:23.590 
但是我想不出任何APP
應歸入不應該使用此選項的類別

00:45:24.391 --> 00:45:28.595 
每次我們想到哪些傳統應用
可能不需要使用此選項例如文件傳輸

00:45:29.129 --> 00:45:31.899 
我們發現你們曾經有這樣的經歷

00:45:31.965 --> 00:45:33.767 
你想要取消文件傳輸

00:45:33.834 --> 00:45:37.104 
你按下Control-C
但是需要大約30秒的時間才能取消

00:45:37.971 --> 00:45:40.507 
這是因爲程序將所有數據

00:45:40.574 --> 00:45:42.609 
過量載入內核而必須等待數據被清空

00:45:43.010 --> 00:45:44.511 
因爲並沒有方法來改變此操作

00:45:45.012 --> 00:45:48.148 
事實上文件傳輸

00:45:48.215 --> 00:45:51.885 
並不會受益於過量載入數據

00:45:51.952 --> 00:45:53.820 
我們想不出會任何APP

00:45:53.887 --> 00:45:55.622 
會受益內核中的過量數據堆積

00:45:55.956 --> 00:45:59.993 
在認識到這種情況之後

00:46:00.460 --> 00:46:04.698 
我們決定在下一個版本中

00:46:05.566 --> 00:46:09.670 
使用更高層次的SURLSession
和CFNetwork API

00:46:09.736 --> 00:46:11.538 
自動爲所有連接啓用此選項

00:46:12.806 --> 00:46:15.242 
爲了最有效地利它需要做的事情是

00:46:15.642 --> 00:46:20.581 
當socket變爲可寫入狀態時
在看到EWOULDBLOCK錯誤碼之前

00:46:20.647 --> 00:46:22.950 
不要循環寫入大量的數據

00:46:23.450 --> 00:46:25.552 
只需要寫入合適大小的數據塊

00:46:26.253 --> 00:46:28.422 
然後等待被告知可以寫入更多數據塊

00:46:28.822 --> 00:46:31.558 
這樣如果用戶改變主意

00:46:31.625 --> 00:46:33.794 
或者網絡環境發生變化

00:46:33.994 --> 00:46:36.930 
下次socket變爲可寫入狀態時

00:46:37.264 --> 00:46:39.466 
你可以做出明智的決定

00:46:40.467 --> 00:46:42.870 
你可以即進生成數據

00:46:43.203 --> 00:46:48.642 
根據當前的信息
而不是5或10秒前的信息

00:46:49.042 --> 00:46:51.912 
生成最新的數據

00:46:53.814 --> 00:46:58.418 
現在進入本講座的最後一部分

00:46:59.319 --> 00:47:01.421 
讓我們來窺探

00:47:02.089 --> 00:47:05.759 
一項名爲TCP Fast Open的
全新技術

00:47:07.528 --> 00:47:14.501 
傳統TCP工作原理是這樣的
我們通過發送消息和獲得應答

00:47:15.068 --> 00:47:16.503 
設置TCP連接

00:47:17.371 --> 00:47:18.972 
然後我們第二次發送消息和獲得應答

00:47:19.406 --> 00:47:21.675 
以發送請求和獲得響應

00:47:22.776 --> 00:47:26.947 
TCP Fast Open
將連接設置

00:47:27.014 --> 00:47:30.050 
與數據交換合併成爲一個數據包交換

00:47:31.218 --> 00:47:34.454 
所有APP並不會默認啓用此選項

00:47:34.555 --> 00:47:35.756 
而這是有原因的

00:47:37.624 --> 00:47:39.593 
你需要注意這個警告信息

00:47:40.027 --> 00:47:43.497 
提示說此功能僅對
冪等數據來說是安全的

00:47:43.797 --> 00:47:45.032 
我將解釋這其中的含義

00:47:47.901 --> 00:47:50.070 
當你使用TFO操作時
握手與數據組合在一起

00:47:51.939 --> 00:47:57.945 
服務器將收到消息服務器
作出反應發送響應信息

00:47:58.345 --> 00:47:59.580 
然後你關閉連接

00:48:00.681 --> 00:48:05.552 
Internet的工作模式並不保證

00:48:05.919 --> 00:48:08.522 
不會重複發送數據包

00:48:09.356 --> 00:48:11.258 
Internet的成功得益於

00:48:12.092 --> 00:48:14.461 
其非常簡單的工作模式

00:48:14.728 --> 00:48:18.365 
即快速低成本地發送數據包

00:48:19.132 --> 00:48:21.502 
你不需要考慮數據包的發送順序

00:48:21.935 --> 00:48:24.304 
不需要擔心數據包是否損壞或丟失

00:48:24.371 --> 00:48:26.907 
或者重複發送數據包
只需實現快速和低成本就可以了

00:48:27.774 --> 00:48:31.879 
終端系統非常智能化
能夠適應這種網絡模型

00:48:33.447 --> 00:48:35.549 
重複發送數據包的原因是多少方面的

00:48:35.616 --> 00:48:37.451 
可能是因爲路由器有bug

00:48:37.985 --> 00:48:40.721 
也可能是因爲Wi-Fi鏈路層

00:48:41.622 --> 00:48:43.891 
意外地發送數據包兩次

00:48:44.291 --> 00:48:46.693 
終端系統可能重複發送：

00:48:46.760 --> 00:48:50.397 
如果你發送數據包

00:48:50.964 --> 00:48:52.900 
但是應答消息丟失

00:48:53.300 --> 00:48:54.801 
你將需要重新發送數據包

00:48:55.302 --> 00:48:58.272 
這樣網絡中就會出現兩個相同的數據包

00:48:58.772 --> 00:49:02.943 
如果其中一個數據包發生延遲
並且在很久以後出現

00:49:03.710 --> 00:49:06.380 
對於服務器來說

00:49:06.446 --> 00:49:09.750 
這是一個完全有效的TFO請求

00:49:10.150 --> 00:49:12.786 
無論操作是什麼都會再次執行此操作

00:49:13.654 --> 00:49:16.990 
如果操作是向你發送一幅JPEG圖片

00:49:17.324 --> 00:49:19.259 
進行兩次這樣的操作
並不會帶來嚴重的後果

00:49:20.060 --> 00:49:23.730 
但是如果操作是
發送一雙Zappos鞋子

00:49:24.164 --> 00:49:25.999 
兩次進行這樣的操作可不是你想的

00:49:26.466 --> 00:49:31.205 
對於這種情況你必須做出明智的決定

00:49:31.305 --> 00:49:32.739 
哪些操作是合適和安全的

00:49:33.073 --> 00:49:35.409 
哪些對你的APP來說不合適

00:49:37.377 --> 00:49:41.415 
你可以通過connectx
系統調用來這樣做

00:49:42.349 --> 00:49:48.088 
這是早期適配器的簡要技術預覽

00:49:49.122 --> 00:49:52.759 
讓我們來看如何通過更高層API
來展示這個技術

00:49:52.826 --> 00:49:55.629 
但是目前還不能
使用connectx來實現

00:49:56.463 --> 00:49:59.666 
與你進行對話的服務器必須支持TFO

00:49:59.733 --> 00:50:01.335 
APP必須選擇加入對話

00:50:03.270 --> 00:50:06.507 
如果你運行Linux服務器
你必須具有幾個星期以前

00:50:06.573 --> 00:50:09.676 
發佈的最新Linux內核

00:50:10.110 --> 00:50:15.582 
此內核支持標準ITF、TFO、

00:50:16.116 --> 00:50:18.685 
TCP選項代碼
OS X操作系統也同樣如此

00:50:22.055 --> 00:50:25.125 
最後作爲總結我希望你們
記住今天講座的要點

00:50:27.694 --> 00:50:28.595 
即 你應該儘可能地

00:50:29.263 --> 00:50:32.366 
使用最高層次的網絡API

00:50:32.900 --> 00:50:38.005 
這樣你將能夠獲得
這些API所能提供的全部功能

00:50:39.573 --> 00:50:44.578 
你絕對必須在NAT64網絡上
測試你的APP

00:50:45.212 --> 00:50:48.348 
幸運的是我們進行了大量的簡化工作

00:50:48.482 --> 00:50:50.484 
你只需要點擊“選項”就可以了

00:50:52.586 --> 00:50:59.293 
可靠的網絡回退機制
能夠讓你的APP提供更好的用戶體驗

00:51:00.527 --> 00:51:04.231 
你需要做的是注意
“Better Route”通知

00:51:04.498 --> 00:51:07.201 
這樣當Wi-Fi重新可用時
你可以返回到Wi-Fi連接

00:51:09.169 --> 00:51:13.106 
“顯式擁塞通知”
是一項新的基本功能

00:51:14.474 --> 00:51:19.746 
它通過降低隊列等待和減少丟包

00:51:20.314 --> 00:51:24.751 
大幅提高網絡數據傳輸的響應速度

00:51:25.419 --> 00:51:28.121 
我希望你們測試這些功能
並且報告任何問題

00:51:29.489 --> 00:51:31.425 
利用
CPNOTSENT-LOWAT選項

00:51:31.859 --> 00:51:34.528 
你可以爲自己設置一個
socket選項

00:51:35.229 --> 00:51:37.564 
在下一個版本中你將可以免費使用它

00:51:38.398 --> 00:51:41.735 
從而大幅減少發送機中
緩存的遲滯數據量

00:51:43.003 --> 00:51:46.707 
最後對於喜歡
TCP Fast Open的開發者

00:51:46.773 --> 00:51:48.075 
我們已經提供此功能

00:51:49.910 --> 00:51:53.013 
有很多不錯的文檔資源可供你查看

00:51:53.614 --> 00:51:55.782 
你們並不需要記下這些URL

00:51:55.849 --> 00:51:57.818 
可以點擊PDF文檔中的鏈接

00:51:59.052 --> 00:52:04.191 
還有一些不錯的論壇
你可以提問並且討論

00:52:04.658 --> 00:52:06.593 
與網絡應用相關的問題

00:52:09.596 --> 00:52:11.598 
我鼓勵你們觀看

00:52:12.232 --> 00:52:14.968 
NSURLSession講座

00:52:15.335 --> 00:52:19.640 
和Network 
Extensions講座

00:52:20.340 --> 00:52:23.610 
在網絡實驗室午餐休息之後
也可以與我們討論

00:52:23.777 --> 00:52:25.279 
我們將會回答你的所有問題

00:52:26.079 --> 00:52:26.914 
謝謝