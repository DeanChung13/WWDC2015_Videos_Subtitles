和DemoBots一起深入GameplayKit
大家好歡迎來到“和DemoBots一起深入GameplayKit”
今年我們創建了一個新的遊戲示例名字叫DemoBots
如果你想在家玩那麼今天你就可以
從developer.apple.com/spritekit把這個示例下載回來
這個遊戲利用了大量你們在“SpriteKit會話中有什麼新料”
以及“GameplayKit簡介”中
學到的東西如果你不會的話就去看看吧
如果不給你們演示我們就無法完成
這個叫做DemoBots的遊戲
我們來看一下這個遊戲該怎麼玩
我們開始一個新遊戲 你就是PlayerBot就是這裏的這個人
你的任務是在時間用完之前找到並幹掉每個關卡內的
壞的TaskBots
我們這裏還有兩個好的TaskBots 因爲它們的臉是綠色的
所以你可以知道是好的TaskBots
如果我在這個角落這裏溜達一圈就可以找到第一個壞TaskBots
在這個例子中他是一個GroundBot
當他發現我的時候他就會朝我衝過來並且攻擊我
我損失了一些電量
沒關係 我要用一道射線搞定他
我用射線照射了它幾秒鐘後就搞定了 他就成了綠色
我們看看他要去哪兒
我們又找到了一個壞的TaskBots
我來把他也搞定
時間走完之前我在這個關卡內還有兩個壞的TaskBots需要搞定 
不幸的是 它們也會互相攻擊 
把對方變成壞的TaskBots 
那裏就出現了這種情況 
把它們全部搞定後
這一關就算完成了 
這是第二關
第二關中增加了一種新的角色 FlyingBot
那裏就掛着一臺FlyingBot他正在自娛自樂
當你找到一臺壞的FlyingBot時
它們有不同的攻擊方式 當我們撞到他的時候 
他發起了爆炸攻擊 影響到了一定半徑範圍內的全部角色 
好消息是 如果你搞定一臺FlyingBot 那麼它們的攻擊
就成了善意的攻擊 可以搞定射程內的其它壞的FlyingBot
跟着他到這兒 
他肯定要撞上另外一臺壞的FlyingBot了 
他躲開了他 好吧 我可以自己搞定他
他肯定要犯個大錯了
他正朝着角落那裏的一個大巢穴走去了
肯定是這樣的
當他被轉變成壞的FlyingBot時我們可以利用他的爆炸攻擊
他把一個兩個壞的FlyingBot轉變成好的了
就剩一個了 還剩一個
啊 不好！這可不妙 
又搞定一個 
這一關也完成了 
這就是DemoBots 
我想看看我們使用了哪些工具
和技術來實現這款遊戲
你可以看到當TaskBots走動時它們有大量的動畫狀態 
我們努力做的一件事 就是把我們需要的紋理 圖像
保持在最低程度 從而讓app的大小不太誇張 
我們決定讓SpriteKit中的新的動作編輯器
把動作創建爲...把動畫創建爲動作而不是把動畫創建爲紋理
你們看到的攻擊動畫 那個攻擊射線 
是我們製作並應用到GroundBot以及FlyingBot
上面的參考動作 
如果我們點擊進到那個動作 我們就可以看到它是由
很多的微小的移動動作一個接一個組成的 
因爲它是一個參考動作 我們創建一次後 
就可以不考慮TaskBots的方位 把它應用到
所有的TaskBots上 
因爲它是一個參考動作 我們創建一次後 
還可以對它進行修改對源進行修改 
我們可以看到變更在各個地方都生效了 我們就無需
在多個地方對它進行修改 
我們使用動作編輯器來生成射線動畫 
這個射線持續了這樣長的幾秒鐘 我們還想讓這個射線
隨着時間衰減 我們也在編輯器中創建了那些動作 
這樣我們就能直觀地看到它 並且把它用到遊戲中 
遊戲中所有的資產都是在資產目錄中創建的這些資產目錄在Xcode 7
之外 替我們轉換成了紋理地圖集 
這就意味着當我們把它們用在遊戲中時
我們就可以獲得儘可能好的繪製性能 
我們有很多這樣的圖像 
它還使得我們可以指定在不同的設備上
使用的正確的圖像 
它還可以幫助我們進一步優化圖像的尺寸 
當我們設計我們的關卡時 我們使用七百六十八點的參考標高 
那邊的那個黃色框那是我們想在屏幕上
顯示多少個關卡的參考 
以那個尺寸計算我們的PlayerBot是一百二十個點 而如果我們
在一臺iPad上使用那個關卡 那臺iPad就也是七百六十八點 
這樣我們就知道了PlayerBot在屏幕上的尺寸他是一百二十個點
我們就可以計算出要想在屏幕上得到他的清晰圖像 
他的尺寸應該是多少 
如果我們把那個關卡按比例縮小到一部
比如三百二十個點高度的iPhone上 他就會變小 
他的高度就會成爲五十個點 
在iPad上我們不需要這麼高分辨率的紋理 
我們就可以節省空間 
如果我們觀察下我們的DemoBots支持的設備 
iPad iPhone以及Mac隨着場景高度的變化
我們就可以計算出對應的玩家的高度 
iPhone 6比4S到5S都略微大一點 
我們使用的也是同樣的資產它太小了 你沒注意到
這就意味着你可以計算出我們需要的1X 2X 3X資產 
讓圖像看起來清晰 同時又避免了使用超出我們需要的更多的像素 
爲了簡單起見我們把iPhone 6 Plus向下取整爲了一百八十像素 
我們可以爲每種設備設置我們想要的資產 
遊戲中我們有很多這樣的資產 
我意思是它們的數量非常多數以千計 
實際上所有的這些角色資產都是在一個3D渲染輸出上生成的 
我們也可以連接那個渲染輸出 
我們也讓那個資產目錄的生成實現了自動化 
這裏的這個JSON文件 這是PlayerBot
行走動畫的一幀 
我們同樣也可以自動生成這些文件這就是Xcode使用資產目錄生成的
我們也可以讓爲每種設備拾取正確的圖像這一過程
自動化 我們以後也會公佈資產目錄
格式參考 以便讓你可以更加容易地
自己創建這些文件我們還在遊戲中使用了另外SpriteKit的一項特性 
即SKCameraNode 在那之前 如果我們想要
在關卡內移動視圖 我們就需要實際移動
整個場景 我們就必須把關卡自身移動到視圖下面 
而有了SKCameraNode 事情就變得簡單多了 
攝像機就是場景中的一個節點它有自己的位置
因爲它有自己的位置 我們就可以通過改變它的位置 
來移動攝像機就像移動其他節點一樣 
改變當前視圖看到的位置就更加容易了 
因爲它是一個節點 我們還可以用它來做節點能做的事 
舉例來說 我們可以向那個節點應用約束 
我們可以用這個把節點的攝像機位置約束到
一個PlayerBot位置 當他朝着屏幕角落跑去時 
我們在他四周就有很多黑色空間 
而不是我們想在屏幕上看到的儘可能多的關卡 
我們還可以使用第二個約束來對它進行改進 
這個約束可以確保我們不會太過於靠近關卡的邊緣 
看起來就是這樣的 
一般來說 我們會跟隨PlayerBot 
但是如果他靠近了邊緣 我們就會停止跟隨他 
讓更多的關卡顯示在屏幕上 
當敵方bots攻擊你的時候 這就更容易看出來了 
那麼我們是怎樣實現的？
我們首先計算出整個關卡的封邊矩形 
然後我們根據它們看到的遊戲屏幕的
寬度和高度得到一個較小的矩形 
我們再確保攝像機不能移動到這個框以外 
我們把它約束到那個矩形 
這樣當攝像機跟隨玩家四處移動時它就不會太過於靠近
關卡的邊緣 
因爲攝像機是一個節點了 我們還可以向它添加子節點 
這就非常有利於警告信息的顯示比如我們在遊戲中的計時器標籤
我們不想讓計時器標籤移動 我們想讓它頂部居中顯示 
因此我們就把它添加爲攝像機的一個子節點 
而不是場景的一個子節點這樣的話當攝像機四處移動時
標籤也會隨之移動在屏幕的適當位置保持這個固定特效就更加容易了 
這些就是我們在遊戲中用到的部分SpriteKit特性 
我們再來看看如果我們用的是GameplayKit的某些特性會怎樣 
首先是GKStateMachine
你應該已經在GameplayKit會議上
見到過它了那場會議講的是你如何使用狀態機追蹤你的遊戲內的
角色 關卡以及其他元素發生了什麼情況 
我們把這個以及其他一些東西用在了PlayerBot上 
這是他的狀態 
他首先是處於“出現”階段 
也就是說他剛被“傳送”到了遊戲中 
爲此使用定製狀態很棒的一點就在於
它們可以確保不會發生意外 
當他們啓動後 就激活了一個計時器 過了一定時間後 
它就會直接移動到玩家控制狀態 
然後打開輸入使用這樣你就可以控制它了
當他命中一個目標後 我們就把他的狀態改爲“命中”
當我們被命中後 我們就輸入一個不同的動畫 就是那個
跳躍動畫 當玩家被命中後 就不能再控制玩家了 
輸入就會關掉 並且繼續跟蹤狀態 
當時間過完後再把他移回玩家控制狀態 
如果我們被命中的次數足夠多 我們就必須重新充電 
我們就到了“重新充電”狀態 而不是“命中”狀態 
那個會追蹤我們重新充電了多長時間 
那個狀態也會真的
給玩家添加更多的電量 
最後重新充電結束後它就會回到PlayerControlled狀態 
這就是玩家可以擁有的一套合理的複雜的行爲 
使用一臺狀態機來對狀態進行編碼 
引起狀態的發生定義要發生的正確的事
從一個狀態移動到另一個狀態 這樣要確保遊戲內僅僅會
發生正確的事就更加容易了 
我們的PlayerBot不會做出我們不想讓他做的事
我們同樣也把它用到遊戲本身上面 
當你玩一個關卡時 我們就處於一個活動狀態 
如果我們點擊“暫停”那麼我們就會進入暫停狀態
這就會通過在你退出暫停狀態時刪除那個
覆蓋 從而對覆蓋進行處理 
如果我通關了一個關卡 我們就處於一個成功狀態
同樣地 當我們成功時 它就會處理所有的
顯示按鈕、進行覆蓋這些任務 
在這些情況中狀態知道應該做什麼事情 
我們還用到了GameplayKit的另一個方面 
即實體和元件 
新的元件是對自含式功能性在遊戲的不同實體上
分享的功能性進行打包的一種相當不錯的方式 
我們有三個實體我們有PlayerBot
GroundBot以及FlyingBot 
它們有一些共同之處 
它們都需要被渲染進場景中 
它們都需要一個陰影 
所以要完成這些事情我們就有了一個渲染元件以及一個陰影元件 
它們也都有動畫 物理現象和智能 
這些名稱就是我們給予狀態機 讓它跟蹤的名稱 
此時你可能會以爲它們看起來很像 
爲什麼不用一個基本Bot類來給這三個實體
提供全部功能性呢？
別忘了 它們實際上並不是相似的 
需要對PlayerBot進行輸入 我們可以通過一個遊戲控制器
鍵盤或者通過觸模控制對它進行控制 
GroundBot以及FlyingBot並不需要進行輸入你無法控制這些角色
它們是由一個代理驅動的 
稍後你會看到我們是怎樣使用代理來在關卡中驅動這些角色的 
PlayerBot並不需要一個代理 
它的動力來自你的輸入 
同樣地GroundBot以及FlyingBot
也需要遵循一些規則 這些規則會告訴它們在某個指定
情景下 它們應該怎麼做 稍後我們也會看看這個 
PlayerBot就不需要這些規則你會告訴他他該怎麼做 
PlayerBot和GroundBot確實有一件共同之處 
它們都有一個運動元件 
這個元件的作用就是說 舉個例子 我在這裏 
我需要以某個角度 移動這個距離 
在場景中把我移過去吧 
PlayerBot會使用那個輸入在場景中渲染它讓他四處運動 
而GroundBot則會用它來進行衝鋒攻擊 
他從這裏開始移動 然後發起衝鋒 
FlyingBot則不需要那項能力 
他不會移動 因此他沒有那個元件 
這些元件是對功能性進行分解
並且僅僅把它們分配給需要它們的實體的好方法 
這些就是我們在遊戲中使用GameplayKit功能性的一些方法 
我想邀請戴夫到臺上來 再給你們講講我們是如何
使用GameplayKit來創建我們的
遊戲 “邏輯與玩法” 
謝謝 戴夫 當我們想到玩法中的邏輯
當我想到玩法中的邏輯那麼最先浮現在我的腦海中的
就是我的對手的實際智能
關於智能其中非常重要的一點
就是在那個空間內 我到底能做什麼？
就像我們之前在演示中看到的 如果我是一個好Bot 
我會在關卡內四處走動沿着線路巡邏維持秩序 
而如果我是一個壞的Bot 我就想要攻擊PlayerBot 
這次逮到他了 
我可能也不會把其它TaskBots變成壞的TaskBots 
因此當它逮到PlayerBot時我也可以出點力
又逮到一個 
最後 我可能會在關卡內以相反的方向四周走動 
幹擾線路上的感應 電流 引發問題 
這就不那麼有趣了
但是既然我們知道了我們能做什麼 那麼問題就變成了我們怎樣
來決定我們應該做什麼 
DemoBots中 我們選擇使用
GKRuleSystem實現了一個模糊邏輯系統 
它的優點在於 我們仍然可以接受與關卡的當前狀態相關的大量信息 
發生了什麼事情並且讓我們的角色對那個信息做出反應 
我們無需使用綿延數百行代碼的if else樹
就可以實現這一點 
我們有一些簡單的規則 我們也依賴這些簡單的規則
和他人進行互動允許出現複雜有趣的行爲 
如果你不熟悉模糊邏輯 那麼我再給你
講一講我們在這裏談的是什麼 
我們提到的“模糊”指的是這樣一個事實
所有的事情並不是非黑即白 非真即假
我們的規則並不是互相排斥的
我們的規則是以自然概念爲模型的 你可以嘗試
把它們當做你會對一位同事說的句子
PlayerBot就類似這個...
...在模糊TaskBots規則類中實現的就是這些 
它是GKRule的一個子類 
實際上 我們把規則事實綁定到了這裏的等級上 
只有當等級大於零時 我們纔會斷言事實 
這很有趣 因爲我們會對那個等級中能夠獲得的信息的
實際狀態函數進行分級 
而不是某種當你在創建GKRule時
設置的東西 
看看這些
看看鄰近規則是什麼樣的 
它考慮的是遠近 
讓我們來實際通過一個圖表看看這個 
看看這些函數的工作原理
在上面的起點附近你可以看到我們有一臺PlayerBot 
外面遠處 我們能夠到的地方 我們還有一臺TaskBot 
如果我拿出一個遠處規則的圖解表示 
那麼看出遠處規則的分級就是這個類的分級 
這就非常容易了
如果我把中等距離規則以及近處規則拉進來 
那麼很明顯 它們在這種情況下的分級就是零 
雖然這個陣式看起來不是那麼有趣 
它看起來也確實是某種程度的非黑即白 非真即假 
如果我們把我們的TaskBot移近一點 那麼你就可以更清楚地
看到我說的是什麼 
這是遠處規則的分級 
七十五 而中等距離規則大約是
二十五 如果我們繼續讓他靠近 那麼事情就發生變化了 
就同時屬於鄰近規則中等距離規則了 
既然你已經看過了我們會計算
我們的分級的函數是什麼樣的 
那麼讓我們再來看看 一旦我們爲我們的每一條規則
計算出來那些規則我們又該怎樣做出決定
這是我們在DemoBots上用的規則 
我們的第一步就像我說過的 
就是對它們進行評估計算值是什麼 
我們接下來要做的事情 就是把它們中的幾個組合起來 
判定它們是否屬於當我們在獵捕PlayerBot時
我們需要注意的影響因素 
它讀起來就像一個句子 你也就可以看 它的工作原理
就類似講一個故事那樣 
如果壞的TaskBots的百分比較高 
PlayerBot離它的距離是一箇中等距離 
而好的TaskBot離它的距離也是一箇中等距離 
那麼我會想要獵捕這個PlayerBot 
在這個例子中我想這樣做的原因是
我的思維方式是 如果這一關卡中已經有了很多
壞的TaskBots 那麼我就不需要去改造它們 
此時我就可以獵捕玩家 
麻煩在於我有三個不同的等級
來表示現在獵捕PlayerBot這個概念 
因此我們要使用GKRuleSystems 來把事實的分級最小化 
要抓取我們想要組合的每個事實的最小分級 
我們選擇最小分級的原因在於我們獵捕PlayerBot的
指令所基於的信息強度僅僅
與起作用的最弱的事實一樣 
我們可以以任何方式對這些規則進行組合
然後得到幾個不同的指示符指示到底是應該
獵捕PlayerBot 還是應該獵捕TaskBots 
在這個階段我們實際上
就需要規則清晰下來得到一個能夠表示獵捕
PlayerBot這一理念的簡單的數字 
在這個例子中我們把我們的事實取出來
使用Swift的歸約函數
以及最大函數來把事情組合到一起 
在這個例子中我們實際上就需要獵捕PlayerBot
或者獵捕TaskBots通過我們所有的
最強大的分級來表示 
看看這些數字很明顯 我們應該獵捕PlayerBot 
既然我們知道了我們想要獵捕PlayerBot那麼我們的第一個問題
就是我到底怎樣才能接觸到PlayerBot？
一般來說這是非常直接的 
只需要直線移動 然後你最終就會接觸到它 
但是障礙物是一個挑戰 
這裏你可以看到 FlyingBot就懸掛在那裏 
你回憶起了幾年前的一個示例“冒險” 
那個示例中的哥布林 也非常喜歡錶現出這種行爲 
我們決定要採取一些行動
在GameplayKit中我們讓你對某個場景中尋路的利用
變得非常容易了這樣你就可以非常容易地
讓你的Bots或者你的敵人像這樣進行移動 
當你把SpriteKit用在一款遊戲上時配合其它事情
就非常方便了把事情設置好 運行起來
也就非常容易了 
只需要幾行代碼即可 
我們來看看這些代碼是什麼樣的 
你要做的第一件事實際上
就是獲得組成關卡的多邊形障礙物
在我們的例子中 我們首先要在場景中搜索我們的節點 
它們都被命名爲障礙物 
當我們有了一個那些節點的陣列後 我們就把它傳遞到
SKNodes在iOS 9上的一個便利函數 
節點物理實體障礙物 
拿出你定義使用的實際物理實體 
對障礙物進行定義 
有了這些障礙物當我們有了這些障礙物
我們就要用它們來構造一個障礙物圖表
並且構造一個緩衝區半徑參數
這個參數就是圍繞實際障礙物的
一些附加空格
要想理解這一點你可以想想
當你朝着一個門口走去當你穿過門口
你並沒有真的走到門框的某個角落
你要瞄準的是門口中間的某個點
當你穿過門口的時候你的身體的任何部位並不會真的接觸到門
半徑可以幫助設置圍繞障礙物的空格 
接下來我們要取出TaskBot和PlayerBot的位置 
然後把它們連接到圖表上 
最後我們會讓圖表給我們一條從起始節點
終端節點的路徑 
我們得到的就是單獨的節點的陣列 
而這些節點對於從A點到B點來說是必須的 
把事情從走路轉變成存儲器片 
同時實際跟着它們走動就是這麼簡單
我們有了一條路徑有了點 
但是我怎樣才能真的去到那裏？
我怎樣才能真的優雅地去到那裏？
GameplayKit再一次給我們提供了一個答覆 
這次是GKAgent 2D 
這個類是我最喜歡的GameplayKit類之一 
這是一個GKComponent 它和戴夫之前談到的實體/元件
系統配合的天衣無縫 
把事情設置好非常簡單
你有一個GKBehavior 它描述了你想要這個代理去做的事情 
它就好比是GKGoals的一個容器
GKGoal 我們很幸運 這個例子中實際上就有幾個
不同的構造這些構造允許我們兼容路徑
因爲代理的世界GameplayKit的世界
不同於SpriteKit的世界 
這裏的委託就使得把它們兩個集成到一起
非常容易 
我們來看看 實際上...你懂得看看代碼實際是什麼樣的 
我們把我們之前獲得的路徑節點陣列拿出來 
我們要對它們進行初始化 
我們要把它傳遞到一個初始化程序來創建我們的路徑
這裏還有一個參數它就是半徑 
我想讓你們在這裏思考下你想讓這個路徑怎樣爲你的代理下定義
太小的值會讓你的代理把你的路徑當成類似一根繃緊的繩索來對待 
而較大的值 你懂得 就會讓它們把它當成類似一條
八車道高速公路來對待 把它們都移動到這個地方 
你可能想要調整下看看哪種最適合你的遊戲
接下來我們要創建一個行爲 
這只是一個空的行爲 並沒有真的發生什麼事情 
然後我們向它添加目標 
這些是兩個路徑相關的目標我之前已經談到過了 
屏幕上的第一個目標 我們跟隨路徑的目標將會
確立我們移動我們的陣列的方向 
在這個例子中我們會從起始位置
向前移動 把我們的TaskBots移動到終點位置 
也就是我們的PlayerBot的位置 
停留在路徑上這個目標會促使我們的代理
保持在我們之前定義的路徑的邊界內 
既然我們有了一個工作行爲我們把它指定給我們的代理讓它開始移動 
代理工作的方式
和GameplayKit上許多其他元件的工作方式類似 
它會在一個循環上進行更新 
當你把它添加進你的更新循環時
它就會在變更前後通知到你 
這個變更前後的委託通知就是讓事情運行起來
同SpriteKit連接起來的理想場所
在WillUpdate中這個位置就是你想從你的SpriteKit節點中
取出信息的位置
這些節點表示場景中你的代理
把那個信息撤回並且更新代理 
因爲我們是在SpriteKit更新循環前面
這樣做的 最後一個SpriteKit更新循環
就會涉及到
對物理現象進行模擬對你的節點應用約束
這就可能導致它的位置從代理最後一次思考時
代理本以爲它在的位置上移開 
在AgentDidUpdate中我們會把信息從代理那裏拿出來 
它的位置它的旋轉類似此類的事情 
然後把它們撤回SpriteKit世界 
並且在它此時進入物理現象模擬 約束應用
之前對你的節點進行更新 
此時我們用DemoBots
得到的就是這個 
一個工作乾的漂亮輕而易舉就可以圍繞屏幕進行移動
同你的交互非常平滑的智能 
我猜這是附加的東西我們把調製繪圖放到
示例中了你可以去下載 
你可以通過點擊斜線鍵來啓用它 
關於這個很棒的一件事是 它可以幫助你想象出
我們之前談到的一些參數 
黃色框是圍繞障礙物的緩衝區半徑 
你可以看到玩家放射出粗線
TaskBots表示的是
我們之前談到的路徑那裏的路徑半徑 
既然我們有了一款遊戲 
我想邀請我的同事邁克爾上臺來 
他會和你們討論一下怎樣才能讓你的用戶以更快的運行速度玩你的遊戲
邁克爾 
謝謝 我們來談談怎麼製作一個有趣的遊戲 
怎樣給你的用戶提供一個很棒的整體體驗 
我會把它濃縮成一個短語 也就是 當然就是找樂子時間到了 
你的用戶需要多久才能真正開始
享受你的遊戲？
第一個要邁過的障礙 實際上就是初始下載 
如果你提供的app太大了 有些用戶就不能通過
蜂窩網數據來下載它 
即使通過Wi-Fi下載 可能也需要好一陣 
你的用戶在App Store中找到
app以及決定下載這個app之間最大的潛在因素就是這個 
但是我們知道對於遊戲來說 很難保持在這個一百萬下載限制以內 
我們再回到DemoBots看看我們是如何處理這個問題的
如果你仔細看PlayerBot 你就會注意到 我們並不是絕對
自上而下地看這個角色的 
這不是一個帶有等距感覺的2D遊戲
我們是通過賦予這個角色多個朝向而實現的 
當你讓這個角色在地圖上四處走動時 
我們就會換出代表這個角色的紋理
得到這個透視圖 
當你在那裏添加各個附加幀的時候 它們會佔據空間 
它只有六兆字節 對於一個遊戲來說不大 
當你認爲它是六兆字節的時候 要乘以三個bots 
我們還要乘以它們可以執行的不同動作
當PlayerBot閒置 攻擊四處走動時我們還需要定向幀
因此這個數字就開始積少成多了 
從傳統意義上來說 這就意味着所有的資產再加上
各自的1X 2X 3X版本 都打包進了app 
現在我們對此有了一個更好的解決方法
本週早些時候你可以已經聽說過了
如果你用的是資產目錄的話 你可以利用一項叫做
“app分割”的新的特性 
“app分割”所做的 就是爲資產實際運行的設備
1X、2X、3X分類 
只要使用資產目錄讓AppStore爲你分割你的app 
就可以節省我們大量的空間
它不僅僅意味着我們現在可以節省大量的空間
它還意味着我們可以用我們的app內多餘的存儲空間來幹什麼 
我現在看到的是圖表這是個空的圖表 
在DemoBots中這是有實踐含義的
我們一開始有八個朝向 我在這裏給你們看一個視頻仔細看 
看起來PlayerBot是面朝正前方的 
你會注意到 仔細看這個動作 看看你能不能注意到什麼事情 
具體來說 就是當角色朝着地圖頂部那裏向後移動時 
我們把那個動作叫做“滑冰” 
雖然我們只有八個朝向來表示角色的運動 
玩家提供的卻是三百六十度的輸入我們可以稍微傾斜下
那個朝向 但並不觸發下一個朝向 
然後你就得到了這個轟炸行爲 
使用八個朝向更令人沮喪的是 
你可能最後會出現類似這樣的情況 
PlayerBot面朝正前方 看起來它應該
很容易就可以攻擊到那個TaskBot實際上並沒有攻擊到 
因爲調試繪製你可以看到玩家瞄準的是側面
但是玩家卻無法看到這個 
有了我們通過“app分割”獲得的多餘的空間 我們就可以增加一個缺口
我們增加到十六個朝向 
這樣遊戲內的運動就感覺更平滑了 
你可以看到我們在這裏有了更多的動畫幀來進行表示 
然後當進行瞄準時粒度就更多了 
角色朝向的位置基本上精確對應到了
射線將要集中的方向 
你在那裏點擊下用戶就可以更容易地知道遊戲內的情況了
“app分割” 我們可以在DemoBots中簡單地通過
把我們的紋理地圖冊放進資產目錄中來實現
它可以幫助我們大幅度降低app的整體大小 
不僅如此 我們現在還可以實際提高可玩性這是因爲我們有了多餘空間
這項特性和你在遊戲中時刻需要的資產
配合的非常默契 
除非我們有PlayerBot 否則DemoBots就不太像一個遊戲了 
但是還有一些其他資產這些資產並不是我們時刻都必須用到的 
針對這點 我們還有一項技術 
你本週早些時候在“點播資源”那裏可能已經聽說過了 
簡單描述下 你可以通過一個簡單的字符串 
對你的資源進行標記標記爲稍後再下載
我來談談我們是怎樣在DemoBots上把這個用起來的 
第一個地方就是可能已經很明顯了 
我們有多個關卡我們可以把這些標記爲關卡一 關卡二 關卡三 
好處在於 我們現在已經用輸出數據寄存器把這些標記出來了
我們就可以說如果用戶初始下載遊戲 我們知道他們回到關卡一 
我們就沒有理由把另外兩個關卡也包括到那裏去 
隨着遊戲進展事情就更有趣了 
因爲我們可以用這個線性流進行預測 
用戶將會繼續到達關卡三 
我們就能提前下載那個關卡 用戶不大可能會重玩關卡一 
因此我們就可以回收一些資源 
我們來再進一步 
如果我們仔細看關卡二你會在這個演示
這個小照片上注意到 
FlyingBot只會出現在這個關卡中 
然後在關卡三中又出現了 
把它和出現在關卡一以及關卡三中的GroundBot相對照
但我們單獨標記角色時 我們就可以對我們的資源做進一步分類
如果我們知道用戶是第一次下載app
我們就只把GroundBot弄到關卡一中 我們可以稍後再
把FlyingBot弄過去 
如果你允許的某臺設備存儲空間不太富餘
那麼當用戶正在玩第二關的時候你就可以洗淨GroundBot
然後把它們都弄回關卡三 
你可以看到我們是怎樣在“項目導航器”中的
資源標籤下佈置標籤的 
你可以看到關卡一的資產被標記爲了“預取” 
這些資產是app安裝完畢之後很短一段時間內取得的 
但是這些資產並沒有包括在安裝包中 
而其他的資源就可以被標記爲
當我們需要時再下載 
這就是點播資源 
我們把它用在DemoBots 用來標記稍後下載的資源 
這樣我們的初始下載速度就更快了 
我們可以把我們不是立即需要的很多東西刪去 
總的來說 它也有助於我們保持一個小的存儲覆蓋區 
這就是傳達的更重要信息你可以製作一個更豐富的遊戲可以有更多的資產
因爲你可以通過點播訪問所有其它的東西
你就仍然可以在設備上保持同樣的覆蓋區
我們認爲這確實會增加複雜性 
當你提到顯示下一個場景時 從傳統意義上來說 
你知道它們位於本地存儲器內 你就可以準備這些資源 
然後當用戶請求資源時 向他們展示這些資源 
現在我們增加了一項額外的複雜狀態 
你可能需要下載這些資源
當然如果網絡連接不佳下載就可能失敗
如果你想要節省空間那麼在某個時間點
你就需要清除這些資源把它們沖洗掉 
然後重複整個週期 
這可能會比較複雜 我想看看我們在DemoBots中
是怎麼解決這個問題的 
具體來說 這就回到了戴夫在會議開始提到的一項
技術即GKStateMachine
如果我們把它用到這樣的模型上 我們就把它成爲我們的SceneLoader 
它有六個相關的狀態 
你會注意到 只有兩類狀態 
正在下載資源狀態以及下載失敗狀態 
實際上 它們都與輸出數據寄存器相關
因爲對於模型來說這完全是一個流水線
把你的資源送到內存 無論是來自本地存儲 
還是需要首先下載 
使用狀態機 我們真正能夠獲得的優勢在於我們怎樣對狀態變遷進行模仿
如果我們仔細看正在準備資源狀態我們就可以通過在我們的
GKState子類中覆寫IsValidNextState決定什麼
是有效的下一個狀態 
我們可以說如果場景確實加載過了 那麼狀態機
只會轉移到準備狀態 
或者說 如果用戶取消這個請求的話 
我們就可以移回到可用的狀態 
當試圖準備我們的資源時我們不會回到
下載狀態因爲我們可以在IsValidNextState中
決定它這樣就會導致更多的確定性的行爲 
好了 總結一下 
最後我再和你們分享下我們在開發它時學到的一些竅門 
第一如果你用的是點播資源 
提前提出下載請求 
如果你在遊戲中有一個可預測的進展 
你就可以在玩家一開始玩關卡一就開始
下載關卡二 
不要忘記Xcode內用於輸出數據寄存器的工具 
你可以看一下磁盤報告工具 尤其是看看點播資源
下面那裏看看你的標籤是否已經
被下載了還是當前正在使用中 
亦或是已經被清理掉了這真的很有用 
此外如果玩家到了一個接合點 
他們需要額外的資源 
但是你尚未下載這些資源 尚未準備好這些資源 
你就可以修改你的請求的優先級 
這就意味着你可以在打包資源請求上提升
載入的優先級它的比例是從零到一 
如果用戶被阻塞了 而你又試圖進行下載的話 這裏甚至
還有一個供急用的常數 
我們使用一個NSOperation隊列來模仿準備的你可以在那裏提升服務質量
總的來說 我們在DemoBots上想做的事情很多 
我們十分希望提供一個示例 向你們展示開發遊戲的各種不同的方面
我們認爲你們都會對這個感興趣的 
戴夫一開始就說過了要針對每種設備
對你的資產進行微調 也包括針對Mac的特殊資產 
我們也講過了優雅的角色導航 
而無需由你自己寫一大堆的運動代碼 
最後 添加額外的資產來提高可玩性 
因爲我們現在對我們的app進行了切割 
我萬分激動地告訴大家 GamePlayKit有一堆很棒的特性 
總的來說iOS 9會幫助你實現這些事情 
如果你想看看怎麼用它們 
你可以通過這個鏈接來下載這個示例 
我鼓勵你們這麼做 
這裏還有一些額外的資料鏈接 
你也可以聯繫我們的福音傳道者艾倫 
相關的會議 我們在本次會議中已經提到過了 
它們已經結束了你可以在線觀看視頻 
謝謝 