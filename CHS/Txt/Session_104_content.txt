肯奥尔：早上好
Xcode 7是我们下一步推出的主要工具
是为了开发 Mac、iPhone、iPad
和 AppleWatch app准备的
今天上午让我们来看一看
Xcode 加了哪些新料
今年最大的变化是我们添加了
第三方平台Watch OS的支持 当然了
你仍然可以用Xcode这款你已经熟悉的
同样工具来开发 AppleWatch应用
Xcode 7同样也包括Swift 2
后者是基于去年我们介绍的
新的编程语言
从整体上说 Swift 2速度更快
不仅是指你的app在Xcode中
运行和调试速度更快 
此外app在用户的设备上也更快
Swift 2还有一些新的语言功能
比如错误处理 引入了显式语法
这样处理Swift中的错误就更快了
可及性 现在Swift对某些API的最低
OS需求有了深刻理解这样采纳新API
继续支持现有的OS也都更加容易
可测试性
现在测试丛就可参阅内部API
你的测试覆盖更广而无需公开
任何其它源信息
协议扩展使得你能够为任何类添加方法，
以便实现某一协议
你可以借助Xcode 7的Migrator
把所有的Swift代码 转换成Swift 2
它既适合项目 也适合playgrounds
我们还向Objective-C中添
加了新语言功能
这样它和Swift就配合的更好
比如Generics让你可以指定收集的...
类型信息
NullabilityAnnotations
能让你指定你
何时期待零值 何时期待非零
这样Objective-C
和Swift之间就真正实现了
无缝交互 这很棒
我们已经先行一步，在我们的SDK中
采用了这些特性
因此你现在就可以看到好处
如果你想用Swift 2
或者你昨天看到的新的API
在playground中做就再好不过了
去年 我们引入了playground
从那时起它们的进展很大
现在你不仅能探索摆弄代码
还可以从一个playground中
解释一个想法 一个概念
我们引入了像RichComments这样的特性
你就可以用一个标示语法 
来解释环境代码中发生了什么
它们的格式和字体都很漂亮
非常显眼
你可以在这些评论中添加网页链接列表
甚至添加图像
我们还允许拉取结果并显示在
快速浏览窗中 你可以把它们
拉取到源代码中对应的那一行代码下面
这对定位因果关系的作用非常大
这很棒
通过向新支持源文件夹中添加Swift代码
你几乎可以向playground
无限添加功能
这有助于帮助你
保持playground的整洁专注
同时 你也有地方去放支持功能
这里 还有一项性能
因为是配套代码 
运行时不是交互式的就能对它们进行编译
它们只是对playground
提供支持
所以可以运行的很快
我们最新的playground
特性是 Pages
这使你可以为某一话题编写内容
例如 如果你想制作一个与排序相关的
playground 你就可以添加
一个与排序原则相关的介绍页
然后你可以添加涵盖特定
排序算法、快速排序、
冒泡排序等事情的后续页面
之后 如果你想添加页面导航
你可以添加一些我们之前介绍的标示语法
Playgrounds是进行教导的得力方式
去年 我们把教程做成了playground
今年 我们又升级成了Pages
这就是Swift 2 和新playgrounds
除了iOS 9和OS 10El Capitan
我们还向Watch OS 2中 添加了新运动
新的WatchKit能帮助使你的app更具响应性
并且增强你作为开发者的
控制能力和灵活性
如果你还没看
“Watch OS 2中有什么新料”
我建议你看看
有些东西很棒。
当然 你也可以使用Xcode中的故事板
来开发完整的watchapp 你还能快速展示
你的app如何在屏幕间转换
你可以设计并完成glances
甚至新WatchKitcomplications
也可以
对于iOS来说使用新StackView等
事物来开发
改变屏幕方向适配不同屏幕
尺寸的app从未如此的简单
有了新iPad多任务处理功能
你在界面构建器中定义的大小类
比以往任何时候都要重要
和iOS 9一起， 我们还引入了一项叫
App Thinning的新横切特性
App Store可以量身定制你的app
为每台用户设备
推送最佳、最小版本
这样你就可以集中精力开发优秀的app
而不用担心app的大小 
因为你知道客户不会下载到无用内容
当然 Xcode也会帮助你配置你的app
让你的app瘦身
App Thinning由三个不同的部分组成
第一个部分就是Bitcode
当你存档提交时Xcode会把你的app
编译到一个叫做Bitcode的中间表述
然后再发送到store
稍后App Store会重新优化你的代码 
帮助你进一步校对编译器更新
新处理器性能等事情
你不需要做任何事情
就可以坐享Bitcode的益处
Xcode会替你搞定一切
其次就是Slicing
当App Store向用户设备推送你的app时
它会只推送那台需要的设备美术资源
举例来说 如果你的app中有为iPhone6
和iPhone6s准备的2x和3x的资源
那么iPhone6只会收到2x资源
而iPhone6s只会收到3x资源
要利用Slicing 你只需要使用
Xcode中的 AssetCatalogs即可
最后是点播资源你可以控制
何时下载资源
例如 你可以在用户通关
你的游戏第4关时才开始下载第5关
你可以控制很多东西
这很棒
约翰会给大家演示一下Watch OS 2
和 AppThinning
乔恩·赫斯：早上好
今天我会演示Xcode7中我最爱的两项特色
即 nativewatch 扩展功能
和应用瘦身
让我们通过一个小游戏来展示
我们的小游戏 已经为WatchKit 1 
做好准备了
现在我想升级成Watch OS 2
Xcode好像和我心有灵犀
我在导航这里看到一个现代项目的化序列已经放在队列中了
我会选中它
开始把我的项目设置迁移到Watch OS 2
面板这里 Xcode给了我一个总览
让我知道接下来会发生什么
我想多向你们谈谈细节
像Watch OS 1一样 Watch OS 2
应用是由一个app扩展功能和一个应用组成
你的代码会进入app扩展功能
然后远程驱动app
Watch OS 2就不一样了
app扩展功能和app都会直接运行在watch上
这样应用的响应性和独立性都更好
听起来很棒
我来试一下
发生了什么？
Xcode帮我搞定了
所有迁移项目设置到Watch OS 2的细节
昨天它帮我配置了构建
我们发布的新WatchOS SDK的
Watch目标
它帮我设置了WatchOS 2 最低部署目标
为它还帮我配置Watchapp扩展功能
Watch app内部复制这样当在Watch上安装时
它们会一起移过去
好的 这就是升级项目设置到Watch OS 2的
全部内容
我们的Watch应用都很美观、很轻便
但是我们的iOS应用却比较笨重
这主要是因为我的资源目录中的图片太多
我想让资源变小但又不想去除任何内容
这就是新App Slicing特性
大显身手的时候了
大家看到这些图像有1，2，3x的不同表达了吧？
有了App SlicingXcode 7
就能和AppStore一起
确保每台设备
仅仅获取最最适合的单张图像
这样就可以降低30%到40%的应用大小
最妙的是这基本上是自动的
我只需在工作资源目录中使用
Xcode 7就行了
但是如果你想把某些资源推送给全体设备怎么办？
我们扩展了Xcode 7的资源目录
以便支持任意数据
你可以把任何数据放到这里
我在目录下面这里
有一个天际线文件夹
里面是世界各地城市的3D模型
我们把这些模型展示给用户
让他们猜是哪座城市
我想把旧金山的高质量模型
加到游戏中
但是只推送给最高端的设备
没问题
图像可以按照比例因子和尺寸变动
数据资产也可以根据设备的性能特征变动，
比如设备的内存大小
GPU性能。
我想给2G内存的设备增加专用资源
那么我只需要把高端资源
拖动到这里来 就万事大吉了
每台设备都能得到最佳资源
而不用重付费
好的
现在我想向你展示点播资源
它使得我们可以在App Store中
远程管理应用内容
通过用字符串做标记
我们把资源加进了点播资源中
字符串可以是任何内容
例如 如果我们是在开发游戏
我们就可以根据关卡名称标记构成某一个关卡的资源
运行时 我们使用NS Bundle
ResourceRequest 类
就可以把整个标签的资源提取到游戏中
<br/> 供本地快速访问
我给你们展示一下如何使用点播资源
我先从目录中选择一个文件夹
与游戏类型相关的问题都在这里了
我要在监视窗中
使用新的点播资源标记
把问题部分给标记出来
我只需勾选它们为点播资源托管即可
那么你可以勾选目录中的哪些东西呢？
你可以像我一样标记整个文件夹
你也可以直接标记图像和数据
你还可以标记资源目录中的...
SpriteAtlases
Sprite Atlases是...
Xcode 7资源目录中的一个新组件
把你的Sprite Atlases放到目录中
就激活了我之前提到的Splicing 这一功能
你还可以在Xcode项目中标记松散文件
我可以通过监视窗对某一文件中的所有标签进行总览
如果我想看到某个标签中的文件
或者所有标签中的全部文件，该怎么办？
我可以到 ProjectEditor
选择我们的
ApplicationTarget
然后再到 NewResource 标签中
就可以看到我的全部标签了
如你所见之前我标记了很多内容
这里可以进行总览 确保一致性不出问题
例如 我发现这个标签和其它格式不一致
缺少问号后缀
没问题
我一下子就编辑 更新好了
我们的内容在点播资源中有标签
现在我演示下如何在代码中调用
现在是新NS Bundle资源请求类大显身手的时候了
游戏分类中有两个回调非常适合这种情景
启用类和终止类
它们非常适用于点播资源 
有两个原因 第一 它们会适时归类， 
第二 它们发生在用户启动游戏前
但是我们一知道用户要玩游戏
我们就可以对点播资源进行预取
我用一个实例变量来延迟
一个 NS Bundle资源请求
NS Bundle资源请求是由标签证实的
别忘了 标签就是简单的字符串
我在类名后面附加批问题来构成标签
然后我就可以通过标签创建丛资源请求
最后 我要使用新的开始获取资源
来完成处理程序方法来调用请求
这是一种在后台运行的异步方法
它会从store中下载全部内容
下载完后会激发完成处理程序
只要它开始运行我不说资源请求不用了
所有内容的本地访问一直会很快
我爱死这个了
我已经在用的相同API的内容都有了
NS Bundle、Path of
Resource、 UI Image、
Image Name、 Texture Name
这些方法的用法都和之前一模一样
我的应用中其它的资源了望码都没有变
现在 所有的内容都可用
直到我说不用 NS Bundle资源请求
我是怎样做的？
在终止类这一方法中
我会调用结束访问 NSBundle 资源请求
我读取到缓存中的内容都删掉了
以后可以继续访问
并且当系统空间不足时
这里会标记为“可清除”
这样我们就搞定了点播资源所需的代码
我想构建并运行我们的游戏
开始新游戏
我要演示使用点播资源时的
一些调试功能
调试导航器这里我要选择磁盘
得到磁盘报告 了解应用在磁盘上的使用情况
我们已经在Xcode 7这里添加了点播资源标签
在“我的标签”内 你可以看到它们的大小和当前状态
现在标记为“未下载”状态的
都由Xcode扮演了app store的角色
我所有的资源都在Xcode还没有到模拟器
但是 我点击其中的一个类
我们在后台运行的代码就会下载内容
现在 “我的标签”的状态成了“使用中”
我换一个类
你就可以看到第一个内容从缓存中删除了
“已下载”标记还在
现在正在使用的是“技术问题”
这就是Slicing 和点播资源
有了应用 Slicing 我们就能把iPhone 6
应用的大小从140多MB降到不足100MB
有了点播资源我们还能进一步
把初始安装包的大小降到30MB
现在用户启动游戏就更快了
又轮到你了 肯
肯奥尔：谢谢 乔恩
今年 为了直接增强你的app品质
我们引入了很多新的特性
我们先来谈谈调试和剖析
Xcode 7我们给iOSapp引入了电量刻度
IOS 9会对比每进程消耗的电量
会在右边的电量报告这里显示
Xcode中的量规能让你
预期情况和现实情况...
进行对比
如果你发现电量使用中
有尖峰而应用又处于空闲状态
这就提示你可能有问题了
当你遇到此类问题时
你就知道到底应该看哪处代码
或者 你可以跳转到Xcode 的各个报表的
Instruments那里
从电量报告那里我们可以跳转到New Location
仪表那里然后就可以知道
是否有效利用了核心位置API
我们可以知道是否过多请求了用户位置？
是否请求的用户位置的精度过高？
这些请求很耗电
我们就可以检查一下
iOS中还有一个新...
Metal System Trace 工具
你可以了解你的代码是如何影响帧频的
硬件渲染显卡驱动能让你了解
整个 Graphic Stack 功能很强大
你或许还注意到Instruments
这里有一个重新设计了的轨迹视图
更清晰了 
并且用起来也更加顺手
通过双指缩放等手势
在数据中导航也很容易
新Instruments 就介绍到这里
我敢说
这里的每个开发人员
都遇到过客户报告崩溃了
但你就是没法重现的问题
好的
总有那么一两次吧？
Xcode 7中的
AddressSanitizer
能助你一臂之力
AddressSanitizer
会把你的Objective-C
编译成C代码 
并捕获类似缓冲区溢出的事件
一发生这种事件就可以捕获
Xcode会停在造成这个问题的那行代码那里
这个新调试特性很厉害
凯特 会给大家演示一下
AddressSanitizer
凯特·斯通：谢谢 肯
我们的小游戏很适合和朋友一起玩
但是有时启动游戏时会崩溃
崩溃很难预测这种故障也很难重现
很难弄清楚原因
你肯定遇到过类似情况 
因为我听说有人会使用指针来明确地管理内存
这个游戏很美
我们可以开始新游戏
选择一个类
再选择一些用户好了
看起来很不错 突然...
现在在关卡中 正好重现问题
故障不好找
我们看看这个
是在哪里崩溃的呢？
我怎么调试？
是主类崩溃了
我在那里根本就没写代码
Stack Trace里面也没有任何提示
这种故障最难处理了
幸亏Address Sanitizer能帮上忙
在Xcode中我们有很多此类诊断工具
你只需要在SchemeEditor中
运行你的app即可
当我在Scheme Editor中点击Run时
<c.color000000><u> </u>我会按下选项这个快捷键
我可以对应用的运行方式进行配置
其中Diagnostics标记
能让你选择一些旧工具
以及AddressSanitizer这新工具
Address Sanitizer
会重新编译应用 添加许多新工具
告诉我哪里失效了
以及为什么失效了
这一点与众不同
我们重新运行一下应用看看
现在我发现 当我选择一个类
并移动到下个页面时应用马上停止了
就是这里发生了内存崩溃
这样我在应用急刹车之前
就能找到问题所在
此时我就知道具体
是停在了哪个堆栈上 是我调用的某个
Objective-C代码有问题
并不是每个人都能全部用Swift写代码
事实上 这个游戏就是用Objective-C
框架封装C代码写成
我们的问题就出在这里
我不熟悉这种代码。
是我要看看调用的代码
用Swift写的
我正在调用一些登录API
它告诉我到底哪里出故障了
但没说原因
再往侦错导航栏下面看
我发现Address Sanitizer 
还告诉我我使用了已经释放的内存
这就是问题的根源所在
我可以从侦错导航栏中看到具体是哪个内存
我正在读取一个50字节热区的首个字节
而这里已经分配出去了
我还可以再点击下实际看下内存
它之前是用来保存日志消息的
Address Sanitizer
用灰色告诉我 这个内存无效
我不应该再继续读取这个内存
它还给了我
内存初始分配调用堆栈
我就知道是我在创建有意义的使用日志时
产生的更重要的是 告诉我当时内存分配到了哪里
我能看出来 是我调用
终止登录那个设计欠佳的API时发生的
我本来以为它只会清除登录
但它却搞坏了关键资源
让我们快速解决这个问题
我把这行代码拿掉
每次录入消息时不再调用它
而改成仅在销毁时调用
连同工具 AddressSanitizer
重构了应用
仍然很好用 仍然能交互使用
但我还能更进一步
现在一切正常了除非再有问题
Address Sanitizer
不仅仅能提示已释放的内存
它还能告诉我缓冲区溢出
并告诉我正在溢出的流
和堆栈内存
这是件非常强大的工具
你现在就应该把这件工具用在你的应用上 
找出所有潜藏的内存问题
我们尽量让它容易上手
因为Address Sanitizer不仅能以
这种交互方式运行，
你还能把它用在Xcode服务器中
这样你就能用它做一系列测试
代码出现问题时及时发现问题
你想尽量减少崩溃次数
但老实说 彻底杜绝崩溃是不可能的
所以我请板井给大家讲讲Xcode
如何能帮助你分析得到的
崩溃日志
板井·罗姆：谢谢 凯特
大家早上好
Apple开发者项目成员可以读取
Xcode中的新崩溃日志
当你通过App Store
或者TestFlight分发你的app 
并把符号信息包含在内时
我们会从用户那里收集崩溃日志
这些日志会聚合成崩溃报告
下载到Xcode中 你就可以在配置窗口中
查看并分析这些日志
这种集成是无缝的你可以很容易地
找出并修复关键问题
我来告诉你如何使用
去年 我们引入了TestFlight
TestFlight是一项便捷的服务
能够分发你的apps测试版本
和Xcode中的崩溃日志配合的很好
昨天我们刚刚分发了游戏的一个测试版
用户报告了一些崩溃
我想找出并修复
我先启动Xcode
我已经在Xcode的Account
Preferences面板中输入了
我的Apple ID 所以我只需要打开配置窗口
查看崩溃日志就可以了
窗口左边是Xcode下载的我的研发团队通过
iTunes Connect 上传到
App Store或TestFlight的
与apps相关的全部信息
我选择好游戏
我可以从右边选择想要的版本
列表最上面的55号版本
是昨天通过TestFlight分发的
我点击它
Xcode会在下面下载全部最近的崩溃信息
它们会按照出现频率排序 列表最上面的
当然就是测试者遇到最多的问题
在右边我能看到崩溃的回溯跟踪
Xcode会很贴心地以美丽的浅澄色
高亮其中的一个Stack框架 
这样我就知道app 可能有问题
尤其是使用日志和登录方法中
app发生崩溃的地方
这与凯特刚才使用Address 
Sanitizer捕获并修复的崩溃很相似
我最喜欢这种故障报告因为会自动修复
我看着就行
我会点击窗口上面的这个按钮
把它标记为“已解决”。
通过点击窗口下方的过滤器
我还能让Xcode 过滤已经解决的崩溃
我可以集中精力解决尚未修复的崩溃
我们刚才已经小试身手了
让我们再来看看下个崩溃
这次是在启动画面视图控制器内部崩溃的
即app漂亮的着陆页那里你可以在那里看到
由你的朋友的图像组成的网格
我们想编一个阵列索引
但是我们的索引可能超过了阵列界限
我想修复这个崩溃
我会点击Open和Project按钮
先点击后者再点击前者 回到代码中
现在Xcode不仅打开了我的项目 
还神奇地把我刚刚在右边整理器中
查看的崩溃报告传送到了
侦错导航器那里我就可以点击
Stack Frames，
并导航崩溃报告和源代码
我们好像遇到了下一影像法
这看起来像是乔恩昨天
到我办公室谈到的他遇到的崩溃
我们正在给朋友图像阵列
编索引并增加一个计数器
我们到达阵列边缘时我们把计数器设回零
这里有一个容易忽略的错误
这里应该相等或者更大
我来修复它
如果你的朋友数量不是很多
你就很容易遇到这个崩溃
看来乔恩能发现这个问题不是没有原因的
现在我回到整理器中修复更多崩溃
Xcode中的新崩溃日志功能
和TestFlight配合的很好
能在你推送给客户之前
帮助你发现并修复大多数关键问题
肯 ̆轮到你了
肯奥尔：谢谢你 板井
测试 过去几年来 我们一直在向Xcode中
添加测试支持
让你能测试应用中越来越多的部分
Xcode 5中我们添加了一个Test导航器
把这个和助理编辑器结合起来
我们的测试驱动开发工作流程就很完美了
我们已经介绍了XC Test单元测试框架
再加上Bots 你就可以自动在Xcode
服务器上跑单元测试实现持续集成
Xcode 6中我们引入了性能测试
让你很快找出性能回归
并为异步API添加测试
在Xcode 7中 我们还引入了用户界面测试
UI测试使你能够试app中用户真正看到
触摸的那一部分
此类测试非常重要因为它们能够帮助你
确保app运行时始终
和初始目的保持一致
即使你稍后做出变动改进也不影响
和我们添加到Xcode中的其它测试功能一样
UI Tests也和code 服务器配合的很好
这对UI Test来说十分重要
因为运行它们耗时比较久
在Xcode服务器上你还能使用
比你自己办公桌上多的多设备
这样你的测试覆盖范围更广
频率更高
说到覆盖范围为了完善Xcode 7 
我们还添加了测试 CodeCoverage
你可以在Schemes Test action这里
打开 CodeCoverage
当你打开后Xcode在编译你的app时
会使用特殊工具
轻松跟踪执行的各行代码
你运行一系列测试后
你会注意到源代码编辑器右边这里
有一个 New CodeCoverage 栏
你可以很快对调用的代码
有一个直观感受
更重要的是 你可以知道 哪行代码未被调用
琼会给大家演示下Xcode 7的UI测试
琼威·福尔：谢谢 肯
使用Xcode中的UITesting 真的很容易
像这样 你添加一个新UI Testing目标
如果你之前用过单元测试
你可以把它当做一个为你创建的
测试用例子类别和方法
如果这是一个单元测试
你就需要徒手写出测试方法
但现在 我们通过记录应用
为你写好了测试方法
我们来看一下
我把光标放到TestMethod这里
点击窗口底部的
Record按钮 开始记录
记录过程中我的应用收到的任何事件
都会把源代码投射到我的Test Method中
我要配置一个新游戏进行测试
我会点击开始新游戏按钮
注意 我点击按钮后对应的那行代码
就立即在源码编辑器中显示了出来
我要选一个类
这次测试我选择sci-fi。
点击下一步 我会邀请几个玩家
爱丽丝 布兰登 
我搜索一下史黛西
找到了
我点击下
点击下一步 最后点击开关标记游戏为“准备就绪”
这样我就搞定了想要记录的内容
我们看看最后得到了什么
第一行代码中包含了
一条寻找标记为开始新游戏的按钮的查询
然后返回了一个元素
这个元素是应用中实际按钮的代理
经由这个元素我现在就可以读取按钮属性
并发送事件即一次屏幕触摸
下面几行代码包含了选择sci-fi类
点击“下一步”按钮的源代码
UI Testing APIs设计的非常易读
你能看到写很容易
因此能帮你进行鲁棒测试
既然是测试， 那就需要真的测试某些东西，
它也确实这么做了
如果我原样运行测试，它会隐性验证
我交互的所有控件
同时 我还能继续记录
并且如果通不过测试就让其失败
除了这一隐性验证
我还非常希望在测试中
在不同的点上
对我的应用的其它方面进行显性验证
在这个测试中 我选择了一个特定类
并邀请了一组特定的玩家
我们再向测试中添加几组声明
确保我们得得到想要的结果
这些声明验证了应用中上一个屏幕中
UI有包含类名
以及玩家名称的元素
有了这些声明，我就可以运行测试
确保它如期工作
没问题
测试通过了
琼威·福尔：这是对Xcode 7中
测试的快速概览
建议你们都试试
你会爱上它的
最重要的是你们的客户会爱上它
又轮到你了 肯
肯奥尔：很好 谢谢你 琼
今天上午
我们仅仅看了少数几项特性
但愿它们激起了你的兴趣
本周你还会看到更多不错的会话
让你能够更加深入了解
Xcode 7的细节内容
如果你还没有下载新 Xcode 
我建议你去下载 并且告诉我你的意见
非常感谢