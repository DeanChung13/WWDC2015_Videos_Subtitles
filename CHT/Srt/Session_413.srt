00:00:19.319 --> 00:00:23.957 
高級調試和地址消毒劑

00:00:27.794 --> 00:00:28.629 
早上好

00:00:29.296 --> 00:00:32.064 
歡迎來參加《高級調試和
地址消毒劑》講座

00:00:32.566 --> 00:00:34.501 
我是麥克...
大家怎麼樣呢？

00:00:35.035 --> 00:00:36.503 
好嗎？準備好啦？

00:00:36.870 --> 00:00:37.704 
激動嗎？

00:00:38.105 --> 00:00:39.039 
好 現在就開始

00:00:42.309 --> 00:00:45.412 
那我先來介紹
Xcode中加入的新功能

00:00:45.479 --> 00:00:47.414 
還有一些大家

00:00:47.481 --> 00:00:49.283 
可能不知道的
新舊技巧和訣竅

00:00:50.184 --> 00:00:51.552 
先來說說視圖調試器

00:00:51.785 --> 00:00:53.820 
來看怎樣才能
獲得更多洞察力

00:00:53.887 --> 00:00:55.722 
關於你的app UI及其用戶...

00:00:57.391 --> 00:01:00.127 
界面元素 以及它們
在運行時間如何表現

00:01:00.727 --> 00:01:02.996 
我們會調試
AutoLayout Constraint問題

00:01:03.063 --> 00:01:05.364 
至少對我而言
我需要一些幫助

00:01:05.432 --> 00:01:07.868 
理解AutoLayout在
運行時間做些什麼

00:01:08.969 --> 00:01:10.838 
接下來 我們將詳細分析用

00:01:10.904 --> 00:01:12.606 
Advanced Breakpoints
調試代碼

00:01:13.106 --> 00:01:16.276 
我想給大家看看
如何設置自定義操作和條件

00:01:16.577 --> 00:01:18.245 
快速分析例外情況

00:01:18.478 --> 00:01:19.947 
在一定條件下打印值

00:01:20.180 --> 00:01:22.916 
而不會因NSLogs和
打印把代碼搞亂

00:01:23.917 --> 00:01:26.987 
之後 我的同事安娜
會來介紹

00:01:27.054 --> 00:01:29.356 
最新最興奮的調試功能
這就是我們新加入

00:01:29.423 --> 00:01:32.559 
Xcodes調試工具箱的
Address Sanitizer

00:01:33.460 --> 00:01:35.395 
她會詳細介紹
其工作方式

00:01:35.462 --> 00:01:36.997 
可以捕捉到哪些問題

00:01:37.064 --> 00:01:40.634 
以及今天就用它
來整理代碼

00:01:41.134 --> 00:01:44.037 
爲了這兩個話題
我覺得先用

00:01:44.304 --> 00:01:46.773 
演示設備
給大家看看

00:01:55.849 --> 00:01:58.785 
這裏是個應用
名爲Jogr

00:02:00.087 --> 00:02:03.490 
這個健身應用
可以爲跑步計時

00:02:03.557 --> 00:02:07.127 
記錄跑步路線
沿途會爲照片加標籤

00:02:07.828 --> 00:02:10.497 
幾年來我們都用Jogr
來做示範app

00:02:10.564 --> 00:02:13.800 
今年我們添加了
一些使用Swift的新功能

00:02:14.101 --> 00:02:17.437 
並轉換了Objective-C
的若干類

00:02:17.671 --> 00:02:19.206 
這是個非常混合的應用

00:02:19.940 --> 00:02:22.643 
在故事板中也用了尺寸類

00:02:22.709 --> 00:02:24.378 
並完全採用了AutoLayout

00:02:25.379 --> 00:02:27.915 
因爲今年我們改變並增加了
所有這些新代碼

00:02:28.215 --> 00:02:30.117 
可想而知其中會有程序錯誤

00:02:30.384 --> 00:02:31.552 
來找找看

00:02:32.452 --> 00:02:35.889 
先來點擊這裏的計時器

00:02:36.523 --> 00:02:40.127 
第一個非常明顯的問題是

00:02:40.194 --> 00:02:43.630 
計時器周圍的圓環
不是很整齊

00:02:44.131 --> 00:02:48.101 
在我提供的最初設計中
並不是這樣

00:02:49.036 --> 00:02:50.904 
這可能是Jogr是在iPhone5

00:02:50.971 --> 00:02:53.740 
的屏幕上運行有關的

00:02:54.474 --> 00:02:56.410 
而當初是在
iPhone 6上開發的

00:02:56.510 --> 00:02:58.145 
可能是我沒有完全測試

00:02:58.212 --> 00:03:01.315 
來看佈局是否在小號的
屏幕上也適用

00:03:01.648 --> 00:03:05.352 
爲了想了解
到底出了什麼問題

00:03:05.686 --> 00:03:08.522 
我在下面的Debug條上

00:03:08.589 --> 00:03:12.192 
點擊了DebugView
Hierarchy按鈕

00:03:12.993 --> 00:03:16.196 
現在 獲得了所有
視圖的快照

00:03:16.263 --> 00:03:19.399 
並在Xcode中裝載了
關於視圖

00:03:19.466 --> 00:03:21.702 
會如何互動的運行時間信息

00:03:23.203 --> 00:03:26.406 
我點擊並拖動畫布

00:03:26.773 --> 00:03:29.409 
你會看到我可以
怎樣扭動場景

00:03:29.476 --> 00:03:31.545 
顯示所有的不同視圖
以及它們如何在

00:03:31.612 --> 00:03:32.646 
彼此上方分層

00:03:32.713 --> 00:03:35.382 
我甚至還點擊具體視圖來選擇

00:03:36.083 --> 00:03:39.219 
我們可以在對象檢測器中看到

00:03:39.286 --> 00:03:40.487 
所有細節

00:03:41.688 --> 00:03:43.557 
現在有許多內容在繼續

00:03:43.891 --> 00:03:47.294 
有導航條和背景所有這些

00:03:47.361 --> 00:03:49.463 
可我只想關注大家在意的一點

00:03:49.530 --> 00:03:52.299 
也就是我放在中心的內容部分

00:03:53.400 --> 00:03:56.970 
只要雙擊視圖就可以做到

00:03:57.337 --> 00:04:00.641 
萬一你忘記了
我給大家看看怎麼失焦

00:04:00.707 --> 00:04:02.409 
就是在畫布上雙擊即可

00:04:03.110 --> 00:04:06.446 
這裏可以繼續只關注這一點

00:04:07.648 --> 00:04:11.451 
你會注意到在這裏
在Debug Navigator

00:04:11.618 --> 00:04:13.654 
UI堆棧視圖上的

00:04:15.222 --> 00:04:18.225 
所有層次都已經省略

00:04:18.291 --> 00:04:20.928 
因爲我們最近
在關注UI堆棧視圖

00:04:24.765 --> 00:04:30.237 
如果我點擊修剪後的圖像

00:04:30.804 --> 00:04:34.041 
我可以用這裏的尺寸檢測器

00:04:34.141 --> 00:04:39.112 
檢測平衡和約束條件

00:04:39.780 --> 00:04:43.183 
尺寸檢測器不僅是顯示x y

00:04:43.250 --> 00:04:47.120 
和這個的矩形座標
還顯示了

00:04:47.187 --> 00:04:49.423 
影響視圖運行時間的約束

00:04:49.957 --> 00:04:53.560 
約束並非是現在在發揮作用

00:04:53.627 --> 00:04:56.930 
它影響了大小 邊界
或是x y

00:04:57.331 --> 00:04:58.999 
在這裏用灰色顯示

00:04:59.833 --> 00:05:01.869 
那麼這就有點奇怪

00:05:02.135 --> 00:05:05.706 
我看到高度約束是249點

00:05:05.806 --> 00:05:07.941 
這實際是這個
圖像內容的實際尺寸

00:05:08.041 --> 00:05:09.843 
在運行時間
卻沒有真正運行

00:05:10.177 --> 00:05:11.345 
如果我來看約束

00:05:11.411 --> 00:05:15.649 
表示父視圖應該和
圖像同等大小

00:05:15.916 --> 00:05:17.184 
我們看到它在運行

00:05:17.618 --> 00:05:20.020 
看似是有其他部分在約束

00:05:20.087 --> 00:05:21.455 
父視圖的大小

00:05:22.122 --> 00:05:25.092 
我們來看視圖層次

00:05:25.192 --> 00:05:26.660 
瞭解一下父視圖發生了些什麼

00:05:29.429 --> 00:05:32.399 
這裏
我們看到與其他視圖

00:05:33.300 --> 00:05:38.272 
是四分之三
或.75的關係

00:05:38.539 --> 00:05:40.274 
我知道另一個視圖

00:05:40.340 --> 00:05:42.643 
包括下面的起始按鈕

00:05:43.443 --> 00:05:45.479 
在調試導航器上
我們還看到

00:05:45.546 --> 00:05:46.980 
所有的同樣約束

00:05:47.247 --> 00:05:49.716 
可以像這樣 打開

00:05:51.652 --> 00:05:54.388 
我們看到
約束按鈕的視圖上

00:05:54.621 --> 00:05:56.456 
有着相同的
四分之三約束

00:05:56.890 --> 00:05:58.725 
所有這些
看上去都很正常

00:05:58.792 --> 00:06:01.328 
上下關係
都是有條理的

00:06:01.395 --> 00:06:02.930 
頂部高於底部

00:06:02.996 --> 00:06:06.300 
底部和父視圖底部相連
沒別的了

00:06:06.500 --> 00:06:09.803 
爲什麼我們
不能把視圖層次再提高一層

00:06:11.839 --> 00:06:16.577 
我們可以看出 這裏有些奇怪

00:06:17.277 --> 00:06:19.947 
我們有個中心 y-約束

00:06:20.013 --> 00:06:23.217 
它想把整個堆棧視圖中心

00:06:23.283 --> 00:06:25.352 
垂直於容器中

00:06:25.419 --> 00:06:28.722 
但是我們把這個自身頂部

00:06:28.789 --> 00:06:31.692 
與父視圖頂部相連
在50點

00:06:32.192 --> 00:06:33.961 
這也有些奇怪

00:06:36.530 --> 00:06:38.699 
我覺得50點的
約束不應該在這裏

00:06:39.066 --> 00:06:40.367 
我覺得在我開始

00:06:40.434 --> 00:06:42.903 
打開視圖到尺寸類時
它可能就已經加上了

00:06:42.970 --> 00:06:45.639 
我告知IB
加入所有丟掉的約束

00:06:46.073 --> 00:06:47.941 
之後我設置了垂直中心對齊

00:06:48.008 --> 00:06:49.910 
我可能是忘記刪除了

00:06:49.977 --> 00:06:53.580 
我們在故事板上做修改

00:06:55.182 --> 00:06:56.517 
來看是不是問題所在

00:06:57.518 --> 00:07:01.388 
我可以選擇堆棧視圖
就在這裏

00:07:01.455 --> 00:07:03.090 
這是50點約束

00:07:03.156 --> 00:07:04.258 
我會刪掉它

00:07:04.992 --> 00:07:06.059 
重新運行

00:07:09.396 --> 00:07:10.230 
不錯！

00:07:10.297 --> 00:07:13.300 
現在圓形沒問題了

00:07:13.433 --> 00:07:16.370 
沒有缺失
視圖也完全可以修改

00:07:17.571 --> 00:07:20.407 
我們再來運行計時器

00:07:22.876 --> 00:07:24.811 
好的看似有異常

00:07:25.846 --> 00:07:28.448 
我會打開
Debug Navigator

00:07:28.515 --> 00:07:31.852 
查看異常的線程

00:07:32.452 --> 00:07:34.488 
但是看似不是很有用

00:07:34.988 --> 00:07:37.124 
應該是主函數出了問題

00:07:37.658 --> 00:07:41.628 
如果從控制檯來看

00:07:41.695 --> 00:07:45.732 
可以看到
是拋出了部分異常

00:07:46.033 --> 00:07:48.302 
但是現在對我來說幫助不大

00:07:48.368 --> 00:07:51.271 
因爲我想停止程序

00:07:51.338 --> 00:07:52.172 
在拋出異常的時刻

00:07:52.239 --> 00:07:53.941 
對它進行調試

00:07:55.075 --> 00:07:59.079 
爲此 我可以進入
Breakpoint Navigator

00:07:59.680 --> 00:08:04.451 
點擊下面的加號
添加異常斷點

00:08:05.052 --> 00:08:06.820 
我接下來要配置這個斷點

00:08:06.887 --> 00:08:09.289 
來停止Objective-C異常

00:08:12.993 --> 00:08:13.827 
像這樣

00:08:14.361 --> 00:08:17.164 
我們從新運行應用

00:08:19.333 --> 00:08:21.869 
希望我們在問題發生時

00:08:22.503 --> 00:08:25.105 
能準確找到問題

00:08:26.306 --> 00:08:28.075 
非常好 但是...

00:08:29.076 --> 00:08:32.379 
如果我去看控制檯
卻什麼都看不到

00:08:32.513 --> 00:08:36.416 
沒有信息描述
異常是什麼

00:08:37.116 --> 00:08:38.552 
這裏有個技巧

00:08:38.619 --> 00:08:40.953 
是我從LLVM團隊的
朋友那裏學來的

00:08:41.355 --> 00:08:42.422 
導航進入

00:08:42.556 --> 00:08:44.758 
Ob-C Exception
Throw函數

00:08:44.825 --> 00:08:46.460 
在Ob-C的運行時間中

00:08:46.527 --> 00:08:49.563 
打印函數的首個參數

00:08:49.997 --> 00:08:52.366 
實際上是異常對象本身

00:08:52.799 --> 00:08:55.135 
我說 打印對象

00:08:55.903 --> 00:08:56.737 
arg1

00:08:57.271 --> 00:09:01.275 
這就是 異常信息本身

00:09:02.109 --> 00:09:03.844 
因此我會調整異常斷點

00:09:03.911 --> 00:09:08.315 
爲所出現的異常
始終這麼做

00:09:08.382 --> 00:09:09.716 
這樣會很有幫助

00:09:10.317 --> 00:09:12.653 
我可以在這裏添加一個操作

00:09:13.320 --> 00:09:16.456 
輸入的內容和
輸入控制檯的完全一樣

00:09:17.157 --> 00:09:19.660 
打印對象 arg1

00:09:21.161 --> 00:09:24.464 
現在
如果我再次運行應用

00:09:27.334 --> 00:09:28.402 
運行計時器

00:09:29.469 --> 00:09:31.738 
現在我仍然停在

00:09:31.805 --> 00:09:35.642 
異常被拋出的準確時刻

00:09:36.210 --> 00:09:40.214 
我實際上在控制檯
有異常信息本身

00:09:41.181 --> 00:09:43.884 
現在
當我看着異常

00:09:44.184 --> 00:09:46.753 
被拋出的代碼行

00:09:47.020 --> 00:09:49.656 
可以看到我構建的範圍

00:09:50.591 --> 00:09:54.795 
範圍超出了邊界
估計是用了

00:09:54.962 --> 00:09:57.798 
索引1開頭
而不是索引0

00:09:57.865 --> 00:09:59.766 
並且在設定字體屬性時

00:09:59.833 --> 00:10:01.835 
執行了
字符串的全長

00:10:02.569 --> 00:10:05.272 
我們重新運行

00:10:06.840 --> 00:10:09.176 
再看看效果

00:10:09.543 --> 00:10:13.847 
看似計時器
現在工作正常

00:10:14.882 --> 00:10:18.418 
我們成功發現了
兩處程序錯誤

00:10:18.519 --> 00:10:20.187 
我再看第三個

00:10:21.088 --> 00:10:24.691 
現在來看
來這裏之前

00:10:24.791 --> 00:10:28.362 
我今天早上跑步的路線

00:10:29.296 --> 00:10:31.999 
看似沒問題

00:10:33.367 --> 00:10:36.537 
但如果我們返回

00:10:36.670 --> 00:10:39.940 
則有些不對勁
我不是從莫斯科尼出發

00:10:40.007 --> 00:10:41.408 
跑到碼頭大街

00:10:41.475 --> 00:10:44.678 
然後跳到了水裏
這是在太蠢了

00:10:44.811 --> 00:10:47.581 
我們再試一遍

00:10:48.815 --> 00:10:50.684 
這裏出現了異常

00:10:50.751 --> 00:10:56.456 
我不知道
看似是數據模型出現了問題

00:10:56.757 --> 00:10:59.560 
所以我想找出
放在地圖上的各點

00:11:00.360 --> 00:11:02.529 
出現覆蓋時

00:11:02.863 --> 00:11:04.398 
我們在做什麼

00:11:06.567 --> 00:11:10.771 
現在進入類
是這裏

00:11:10.904 --> 00:11:14.575 
使路線出現了覆蓋

00:11:15.175 --> 00:11:18.011 
我們在這裏
用了一束數據點

00:11:18.512 --> 00:11:20.514 
從字典裏拿出

00:11:20.747 --> 00:11:23.083 
生成並構造了代表我的...

00:11:24.618 --> 00:11:28.288 
跑步路線的多段線

00:11:29.489 --> 00:11:32.593 
我會設置一個斷點

00:11:32.693 --> 00:11:34.761 
來看獲得的數據值是什麼

00:11:35.896 --> 00:11:39.166 
我會打開
Debug Console

00:11:39.533 --> 00:11:44.304 
來看變量視圖
在下面 可以看到

00:11:44.571 --> 00:11:45.906 
我所感興趣的點

00:11:46.440 --> 00:11:47.875 
它有着這些值

00:11:47.941 --> 00:11:50.844 
我會向前推進

00:11:51.245 --> 00:11:54.681 
這很有趣
但是有些麻煩

00:11:54.748 --> 00:11:56.650 
這些值看似相似

00:11:56.850 --> 00:11:59.219 
我在這裏的處理
會讓進程快些

00:11:59.286 --> 00:12:01.021 
來看所有這些值

00:12:01.088 --> 00:12:02.556 
我會編輯這個斷點

00:12:03.156 --> 00:12:06.527 
打印出Struct點

00:12:07.861 --> 00:12:12.366 
實際上在變量視圖上
我檢測過這裏

00:12:12.566 --> 00:12:14.868 
然後我會說
評價過操作後

00:12:15.202 --> 00:12:16.503 
自動繼續

00:12:16.570 --> 00:12:18.672 
其實
這不是條件

00:12:18.739 --> 00:12:20.574 
是個操作
就這樣

00:12:22.009 --> 00:12:24.912 
我們繼續運行

00:12:25.746 --> 00:12:30.884 
我們可以看到
所有的點都看似一樣

00:12:31.385 --> 00:12:34.087 
但是還會在
不知什麼地方

00:12:34.154 --> 00:12:35.489 
會出現瞬移

00:12:36.223 --> 00:12:39.693 
但是所有的值看似合理

00:12:40.093 --> 00:12:42.396 
我不太確定問題是什麼

00:12:42.462 --> 00:12:45.866 
也許從別人那裏...

00:12:47.267 --> 00:12:49.469 
能得到更多幫助

00:12:51.338 --> 00:12:53.373 
我們回到幻燈片

00:13:00.514 --> 00:13:02.015 
總結一下看到的內容

00:13:02.449 --> 00:13:05.085 
首先在Jogr的計時器視圖

00:13:05.152 --> 00:13:07.020 
深入瞭解
約束問題

00:13:07.254 --> 00:13:10.357 
我想給大家看看
怎樣雙擊視圖

00:13:10.424 --> 00:13:11.725 
關注具體部件

00:13:12.092 --> 00:13:14.294 
我們檢測部分約束

00:13:14.361 --> 00:13:17.464 
發現當我們在其他屏幕
尺寸上運行時

00:13:17.531 --> 00:13:19.233 
需要將之刪除

00:13:20.200 --> 00:13:23.203 
然後 我們在運行
計時器時 出現異常

00:13:23.370 --> 00:13:25.339 
並使用異常斷點 來停在

00:13:25.405 --> 00:13:27.007 
出現異常的準確時刻

00:13:27.107 --> 00:13:28.709 
並打印異常信息

00:13:29.343 --> 00:13:32.679 
最後 我們可以
添加打印並繼續添加了

00:13:32.980 --> 00:13:35.449 
日誌的斷點
所有這些都不會因NSLogs

00:13:35.516 --> 00:13:37.251 
或打印語句搞亂代碼

00:13:37.918 --> 00:13:40.320 
現在來解決下一個謎題
爲什麼今天早上的

00:13:40.387 --> 00:13:43.290 
跑步會有那麼
奇怪的結果

00:13:43.557 --> 00:13:45.192 
有請安娜

00:13:53.267 --> 00:13:54.101 
謝謝 麥克

00:13:54.334 --> 00:13:57.204 
大家好 那麼回到
麥克剛剛在演示中

00:13:57.271 --> 00:13:59.239 
給大家看的那條路線

00:14:00.107 --> 00:14:02.943 
在測試演示app時
大家會看到

00:14:03.010 --> 00:14:05.479 
所有的路線
而且包括正確路線

00:14:06.280 --> 00:14:08.515 
我們非常希望麥克剛剛沒有

00:14:08.582 --> 00:14:11.718 
找出正確的跑步路線
因爲這樣的話

00:14:11.785 --> 00:14:14.755 
我們的講座
就沒什麼可說的了

00:14:15.956 --> 00:14:19.293 
這種不可預見的行爲通常是
內存出錯而導致

00:14:19.393 --> 00:14:21.028 
例如 分配給一個對象的內存

00:14:21.094 --> 00:14:23.964 
可能被其他對象所重寫

00:14:24.765 --> 00:14:27.367 
或者也許由於某些計算錯誤

00:14:27.434 --> 00:14:29.236 
你用了並不屬於你的內存

00:14:30.871 --> 00:14:34.541 
相信大家之前也遇過類似情況

00:14:34.842 --> 00:14:37.244 
代碼中出現隨機異常

00:14:37.611 --> 00:14:40.581 
也許在測試app的
某個側面時

00:14:40.647 --> 00:14:42.115 
每次會出現這個問題

00:14:42.182 --> 00:14:45.085 
或者只是當你週五晚上

00:14:45.219 --> 00:14:47.254 
準備回家時出現這個問題！

00:14:49.389 --> 00:14:50.724 
最糟糕的用例場景

00:14:50.791 --> 00:14:53.927 
是用戶看到這些
不穩定性或隨機異常

00:14:53.994 --> 00:14:55.762 
而你卻無法把它們重現眼前

00:14:57.364 --> 00:15:00.400 
內存出錯是出了名的很難

00:15:00.467 --> 00:15:03.337 
一致性復現 那麼也就很難

00:15:03.403 --> 00:15:05.906 
發現這一異常的根本原因

00:15:06.974 --> 00:15:07.875 
那該怎麼辦呢？

00:15:08.642 --> 00:15:11.512 
最好的辦法就是儘量減少
面對內存出錯的情況

00:15:11.845 --> 00:15:14.615 
要避免內存操控

00:15:15.249 --> 00:15:18.085 
例如使用Swift這類
語言勾選並

00:15:18.151 --> 00:15:21.555 
自動參考計數
這纔會長久

00:15:22.723 --> 00:15:26.293 
即便內存出錯
在技術上仍然可能

00:15:26.360 --> 00:15:29.129 
由於編碼而產生這類問題
則較爲不可能

00:15:30.264 --> 00:15:34.334 
另一方面
如果代碼會直接操控內存

00:15:34.401 --> 00:15:37.104 
通過調用動態分配[unintell
igible]運算

00:15:37.171 --> 00:15:41.842 
或者代碼可以
與C和C++ API可以互操作

00:15:42.309 --> 00:15:45.579 
你所在的風險組
會非常需要幫助

00:15:47.814 --> 00:15:51.685 
Address Sanitizer
是基於C語言的LLVM工具

00:15:51.752 --> 00:15:55.622 
這與Guard Malloc
起到相同的作用

00:15:55.689 --> 00:15:58.792 
因爲它可以在運行時間
發現內存錯誤

00:15:58.859 --> 00:16:02.362 
並且較其他工具
有更多好處

00:16:03.063 --> 00:16:05.365 
它的運行時間
開銷會少的很多

00:16:05.599 --> 00:16:09.203 
還會產生
綜合詳細的診斷分析

00:16:09.269 --> 00:16:11.972 
可以直接
整合到Xcode UI

00:16:12.372 --> 00:16:15.742 
還有一點很重要
只有這種工具

00:16:15.809 --> 00:16:17.477 
可以在iOS設備上運行

00:16:18.312 --> 00:16:22.282 
這些是Address Sanitizer
可以捕捉到的常見錯誤清單

00:16:23.050 --> 00:16:29.089 
例如 它可以很好地
捕捉到緩衝區溢出

00:16:29.756 --> 00:16:31.859 
這是個很常見的錯誤

00:16:32.426 --> 00:16:35.562 
因爲與安全性攻擊的關聯
而臭名昭著

00:16:36.997 --> 00:16:38.765 
正如大家所見
它發現了部分工具

00:16:38.832 --> 00:16:41.034 
通過 Valgrind 和
Guard Malloc

00:16:41.101 --> 00:16:42.135 
發現的錯誤

00:16:42.202 --> 00:16:44.738 
但是它也發現了
新種類的程序錯誤

00:16:44.972 --> 00:16:47.174 
是其他工具沒有注意的

00:16:48.408 --> 00:16:49.776 
我們回到演示

00:16:49.843 --> 00:16:52.646 
來看怎樣才能
把這些用於項目中

00:17:03.190 --> 00:17:06.260 
我接着麥克講到的內容繼續

00:17:06.326 --> 00:17:08.962 
來看我們看看是否
Address Sanitizer

00:17:09.029 --> 00:17:10.696 
可以幫我們找出路線問題

00:17:11.431 --> 00:17:13.634 
爲了啓動
Address Sanitizer

00:17:13.934 --> 00:17:15.469 
進入Edit Scheme

00:17:18.438 --> 00:17:20.207 
進入Diagnostics選項卡

00:17:21.108 --> 00:17:23.242 
勾選 Enable
Address Sanitizer

00:17:23.644 --> 00:17:25.945 
與其他內存管理工具不同

00:17:26.012 --> 00:17:28.248 
Address Sanitizer
需要重新編譯

00:17:28.315 --> 00:17:32.219 
選中複選框後
Xcode就會知道

00:17:32.286 --> 00:17:35.355 
要打開 Address
Sanitizer 重建應用

00:17:35.656 --> 00:17:37.457 
它會啓動特殊模式

00:17:37.524 --> 00:17:39.326 
允許Address
Sanitizer

00:17:39.393 --> 00:17:41.728 
在運行時間更多地
幹預進程

00:17:43.263 --> 00:17:46.400 
我們繼續重建
並重新運行app

00:17:48.001 --> 00:17:50.470 
來看像剛纔的路線會怎樣

00:17:51.905 --> 00:17:54.741 
現在Address Sanitizer
發現了問題

00:17:54.975 --> 00:17:57.444 
它的診斷直接整合到了

00:17:57.511 --> 00:17:59.713 
Xcode Debugger UI

00:17:59.980 --> 00:18:03.317 
這與出現異常時
情況非常相似

00:18:03.650 --> 00:18:05.786 
但是與使用Sec的
情況不同

00:18:05.853 --> 00:18:07.988 
這次可以對情況有更好的診斷

00:18:08.555 --> 00:18:12.426 
這裏它告訴我們
查出堆緩衝區溢出

00:18:13.360 --> 00:18:15.162 
還可以看到堆棧軌跡

00:18:15.262 --> 00:18:17.998 
在這裏出現了內存錯誤

00:18:19.800 --> 00:18:22.703 
如大家所見 我們稱之爲
Poly Line With Points

00:18:22.769 --> 00:18:24.071 
和Map Kit的常用方法

00:18:24.137 --> 00:18:28.242 
我們在緩衝區做測試
通過緩衝區的長度

00:18:28.308 --> 00:18:30.611 
來進行
計算點的數量

00:18:30.677 --> 00:18:33.947 
再用每個點的大小
來相除

00:18:34.414 --> 00:18:36.250 
看上去可以

00:18:36.316 --> 00:18:39.987 
隨着應用在 Address
Sanitizer 中執行

00:18:40.053 --> 00:18:42.055 
它會收集過程中

00:18:42.122 --> 00:18:44.725 
堆對象的重要信息

00:18:44.825 --> 00:18:47.027 
例如 分配
堆分配

00:18:47.094 --> 00:18:48.395 
和取消分配事件

00:18:48.962 --> 00:18:53.267 
當發現內存出錯
它會使用啓發法

00:18:53.333 --> 00:18:56.837 
來關聯錯誤地址
到有效的堆對象

00:18:57.404 --> 00:19:00.307 
在內存項下信息都呈現在這裏

00:19:00.841 --> 00:19:03.877 
這裏它告訴我們
錯誤地址是在

00:19:03.944 --> 00:19:08.148 
在2240字節堆區域後的
一個字節

00:19:08.615 --> 00:19:12.553 
還告訴我們堆區域
所分配的位置

00:19:13.554 --> 00:19:15.756 
即使這不是激活線程

00:19:15.923 --> 00:19:21.395 
而是在分配事件發生時
進程執行的歷史快照

00:19:21.461 --> 00:19:22.930 
我們可以把流

00:19:23.764 --> 00:19:25.432 
視作激活線程

00:19:26.600 --> 00:19:30.504 
它會把我們帶到
內存分配的點的位置

00:19:31.338 --> 00:19:34.274 
好的
我們來看緩衝區的大小

00:19:34.341 --> 00:19:38.478 
是用每個點的大小
乘以點的數量得出

00:19:39.446 --> 00:19:42.749 
我們使用
MK Map Point

00:19:43.450 --> 00:19:45.352 
作爲點的代表

00:19:45.419 --> 00:19:46.854 
這是帶雙精度的Struct

00:19:48.055 --> 00:19:49.423 
那麼問題是什麼？

00:19:50.090 --> 00:19:52.326 
我們回到Use站點

00:19:53.861 --> 00:19:57.497 
你傳遞到這裏的類型是不同的

00:19:58.131 --> 00:20:01.368 
我們傳遞了MK Map Point星級

00:20:02.402 --> 00:20:06.139 
但是我們知道
剛分配了Struct的緩衝區

00:20:06.206 --> 00:20:07.641 
而不是指針的緩衝區

00:20:08.642 --> 00:20:12.279 
因爲每個
指針的大小小於

00:20:12.346 --> 00:20:14.414 
結構體的大小
包括兩個雙精度

00:20:15.015 --> 00:20:17.918 
這裏獲得的計數
要大於緩衝區

00:20:17.985 --> 00:20:20.020 
包括的元素數量

00:20:20.654 --> 00:20:22.890 
這就會解釋
爲什麼在地圖上

00:20:22.956 --> 00:20:25.058 
我們會有那些額外的點

00:20:26.627 --> 00:20:29.196 
爲解決問題
我們需要刪掉星級

00:20:29.263 --> 00:20:30.731 
如大家所見

00:20:30.797 --> 00:20:33.667 
這是個人們非常容易犯的錯誤

00:20:33.800 --> 00:20:38.071 
只看代碼是非常難發現的

00:20:39.039 --> 00:20:42.309 
在本例中
這個信息已經

00:20:42.376 --> 00:20:44.578 
足以診斷和解決問題

00:20:45.112 --> 00:20:50.517 
不過 如果覺得
想更多地看看這個報告

00:20:50.584 --> 00:20:53.053 
可以前往Memory View

00:20:53.120 --> 00:20:54.955 
來看哪個內存是有效的

00:20:55.122 --> 00:20:57.057 
哪個內存是被視爲無效

00:20:57.124 --> 00:20:59.326 
從Address Sanitizer
的視角來看

00:20:59.660 --> 00:21:03.297 
前往Memory View
可以點擊這個地址

00:21:03.864 --> 00:21:07.801 
這裏可以看到所有變灰的內容
都是無效內存

00:21:08.068 --> 00:21:12.873 
所有黑色內存都被視爲有效

00:21:14.441 --> 00:21:17.644 
我們返回並重新運行app

00:21:17.711 --> 00:21:20.547 
來看刪掉星號
是否可以解決問題

00:21:23.317 --> 00:21:25.252 
我來繼續返回Route視圖

00:21:27.487 --> 00:21:31.592 
啊 這就是麥克
今天早上的跑步路線

00:21:31.859 --> 00:21:33.427 
還有早上
Bash之後的部分

00:21:33.994 --> 00:21:35.095 
我很受感動

00:21:35.429 --> 00:21:36.930 
我們返回
打開幻燈片

00:21:37.831 --> 00:21:40.701 
大家已經看到
打開Address Sanitizer很容易

00:21:40.767 --> 00:21:44.271 
進入Scheme Editor
打開Diagnostics選項卡

00:21:44.638 --> 00:21:47.441 
勾選Enable
Address Sanitizer複選框

00:21:47.941 --> 00:21:50.210 
接着可以構建
並運行自己的項目

00:21:52.513 --> 00:21:55.082 
同樣
正如大家在演示app所見

00:21:55.148 --> 00:21:58.118 
使用Address Sanitizer的
開銷幾乎很難注意到

00:21:58.619 --> 00:22:01.788 
較低的運行時間開銷
允許你使用Address Sanitizer

00:22:02.122 --> 00:22:06.126 
不僅是在調試
部分內存出錯問題的時候

00:22:06.360 --> 00:22:09.463 
而且是在進行UI驅動的測試

00:22:09.530 --> 00:22:12.533 
這裏要手動測試
app的不同方面

00:22:13.500 --> 00:22:15.769 
再進一步 我們推薦

00:22:15.836 --> 00:22:18.572 
在連續整合過程中
使用Address Sanitizer

00:22:19.273 --> 00:22:21.708 
因爲這是運行時間
程序錯誤發現工具

00:22:21.775 --> 00:22:25.045 
它僅會捕捉已執行
代碼中的程序錯誤

00:22:25.712 --> 00:22:27.748 
那麼應該提供儘可能多的覆蓋

00:22:27.814 --> 00:22:29.449 
以實現最好結果

00:22:30.651 --> 00:22:36.723 
在Xcode或Xcode Server
的任務中啓動

00:22:36.790 --> 00:22:40.227 
Address Sanitizer
進入Edit Scheme選擇Task

00:22:40.460 --> 00:22:42.829 
然後再次進入
Diagnostics選項卡

00:22:42.896 --> 00:22:45.699 
勾選Enable
Address Sanitizer複選框

00:22:45.766 --> 00:22:46.767 
構建並測試你的app

00:22:47.501 --> 00:22:49.236 
還可以用命令行啓動

00:22:49.303 --> 00:22:52.039 
通過向Xcode Build
傳遞額外的參數

00:22:54.808 --> 00:22:56.476 
我們建議在Debug構建

00:22:56.543 --> 00:22:58.378 
使用Address
Sanitizer

00:22:58.445 --> 00:22:59.680 
並將編譯器優化關閉

00:23:00.414 --> 00:23:03.917 
但是它也得到
Fast優化水平的支持

00:23:05.052 --> 00:23:07.521 
是與01編輯器旗標相對應

00:23:08.488 --> 00:23:10.157 
需要牢記一點

00:23:10.224 --> 00:23:13.260 
當在這兩個優化水平之間
進行決定時

00:23:14.361 --> 00:23:17.030 
如果有任何編譯優化
是啓動狀態

00:23:17.164 --> 00:23:20.467 
調試體驗就不會十分流暢

00:23:23.036 --> 00:23:26.607 
現在我們進入
講座的最激動環節

00:23:26.740 --> 00:23:28.075 
我會告訴大家一個

00:23:28.141 --> 00:23:30.410 
驅動這個工具的很酷的技術

00:23:32.646 --> 00:23:36.049 
傳統而言Xcode
使用clang編譯器來

00:23:36.116 --> 00:23:40.053 
編譯源代碼
可以生成可執行的二進制代碼

00:23:41.221 --> 00:23:43.223 
爲使用
Address Sanitizer

00:23:43.290 --> 00:23:45.359 
Xcode將特殊的旗標
傳遞給clang

00:23:45.592 --> 00:23:47.294 
它會生成工具二進制代碼

00:23:47.361 --> 00:23:48.996 
其中包括
更多的內存檢測

00:23:50.130 --> 00:23:55.569 
在運行時間 這個二進制代碼
與asan運行時間dylib連接

00:23:55.636 --> 00:23:57.437 
其中包括更多檢測

00:23:57.504 --> 00:24:00.174 
而且dylib是工具所要求的

00:24:02.042 --> 00:24:03.877 
但是這些內存檢測
如何發揮作用？

00:24:04.278 --> 00:24:07.381 
Address Sanitizer
檢測進程中的所有位置

00:24:07.447 --> 00:24:09.416 
如果這是進程內存

00:24:11.218 --> 00:24:14.154 
Address Sanitizer會成爲
所謂的影子內存

00:24:14.521 --> 00:24:17.424 
可以跟蹤真實內存中的
每個字節

00:24:18.492 --> 00:24:22.896 
它有着字節是否爲可訪問
地址的相關信息

00:24:24.131 --> 00:24:26.700 
無效內存的字節就是紅區

00:24:26.767 --> 00:24:28.702 
或者說內存中毒

00:24:30.737 --> 00:24:33.140 
當使用Address Sanitizer
編譯程序時

00:24:33.207 --> 00:24:35.242 
它會影響每個內存訪問

00:24:35.409 --> 00:24:37.010 
並在前綴加上檢測

00:24:37.811 --> 00:24:38.946 
如果內存中毒

00:24:39.012 --> 00:24:41.215 
Address Sanitizer
就會跟蹤程序

00:24:41.582 --> 00:24:43.750 
並生成診斷報告

00:24:44.151 --> 00:24:46.053 
否則 它會允許你繼續

00:24:47.721 --> 00:24:49.122 
我們再來仔細看看

00:24:49.256 --> 00:24:50.524 
假設p爲指針

00:24:50.958 --> 00:24:55.395 
然後IsPoisoned函數會
檢測影子內存中的相關字節

00:24:56.129 --> 00:24:57.764 
在本例中 內存是有效的

00:24:57.831 --> 00:25:01.435 
因此程序可以編寫那個
內存位置

00:25:04.738 --> 00:25:06.940 
不過 如果它並未指向有效內存

00:25:07.207 --> 00:25:08.509 
條件將會爲真

00:25:09.142 --> 00:25:11.612 
程序將卡在無效內存

00:25:11.845 --> 00:25:14.448 
就是訪問可能要發生的地方

00:25:15.249 --> 00:25:18.051 
這就是Address
Sanitizer生成報告的方法

00:25:18.118 --> 00:25:20.087 
並將這個問題報告給用戶

00:25:21.922 --> 00:25:25.158 
查找影子內存需要非常快才行

00:25:26.260 --> 00:25:28.729 
爲實現這點
我們保留了查找表

00:25:28.795 --> 00:25:33.700 
在影子內存中每8個字節
就會有1個字節被跟蹤

00:25:35.002 --> 00:25:36.970 
這是個很大的查找表

00:25:37.037 --> 00:25:38.939 
我們並未真正分配 而是在

00:25:39.239 --> 00:25:42.910 
進程啓動的時候保存
在需要的時候使用

00:25:44.344 --> 00:25:46.113 
這樣我們就可以查找地址

00:25:46.180 --> 00:25:50.717 
通過將原始指針的值除以8

00:25:50.784 --> 00:25:52.653 
再添加常數補償

00:25:52.719 --> 00:25:55.822 
就是在內存影子的
位置上添加

00:25:56.390 --> 00:25:58.859 
即便計算地址的字節爲非零

00:25:59.126 --> 00:26:00.527 
我們知道內存中毒了

00:26:03.130 --> 00:26:05.165 
現在 我們聊聊堆的內容

00:26:06.099 --> 00:26:08.802 
捕獲溢出和
堆中的其他程序錯誤

00:26:09.369 --> 00:26:12.206 
Address Sanitizer會提供
自定義分配器

00:26:12.272 --> 00:26:15.209 
以替代默認的Malloc執行

00:26:16.710 --> 00:26:19.713 
默認分配器
可以用不同方式組織對象

00:26:20.347 --> 00:26:23.984 
例如
它可以逐個排布對象

00:26:24.718 --> 00:26:27.921 
這對於優化內存消耗十分有利

00:26:28.655 --> 00:26:30.691 
但是這對捕捉程序錯誤不太好

00:26:30.757 --> 00:26:33.260 
因爲一個對象的溢出會落到

00:26:33.327 --> 00:26:34.661 
另一個對象上

00:26:34.728 --> 00:26:38.232 
因此無法與有效的內存訪問區別開來

00:26:39.900 --> 00:26:42.402 
爲解決這個問題
ASan的分配器

00:26:42.469 --> 00:26:45.239 
會讓對象彼此間距更大

00:26:46.006 --> 00:26:48.742 
這些對象之間未用的內存

00:26:49.176 --> 00:26:51.011 
在影子部分會標記爲中毒

00:26:53.280 --> 00:26:54.848 
當對象被取消分配

00:26:54.915 --> 00:26:57.050 
我們將對象在影子部分
標記爲中毒

00:26:59.319 --> 00:27:03.790 
總之 自定Malloc執行
在有效的分配周圍

00:27:03.857 --> 00:27:06.560 
插入中毒的紅區

00:27:06.860 --> 00:27:09.263 
以捕捉堆下溢和溢出

00:27:10.464 --> 00:27:12.666 
這會延遲用戶釋放的內存

00:27:12.799 --> 00:27:16.236 
使得Address
Sanitizer更有效地捕捉

00:27:16.303 --> 00:27:18.238 
用戶釋放的和雙重釋放的錯誤

00:27:19.306 --> 00:27:23.343 
它還會爲分配和解除分配
蒐集Sect痕跡

00:27:23.544 --> 00:27:26.713 
允許它提供這些綜合詳細的診斷

00:27:27.014 --> 00:27:28.415 
這些我們在演示中都見過

00:27:28.615 --> 00:27:30.217 
能立即明白問題在何處

00:27:30.584 --> 00:27:32.186 
和花費大量時間去調試

00:27:32.452 --> 00:27:34.788 
再找出具體發生了什麼

00:27:35.689 --> 00:27:37.191 
這二者是完全不同的效果

00:27:38.759 --> 00:27:41.562 
現在 我們來談談堆棧

00:27:43.630 --> 00:27:45.699 
與之相似 對於堆內存而言

00:27:45.766 --> 00:27:47.801 
紅區是放在獨立的
堆棧變量之間

00:27:48.902 --> 00:27:52.206 
假設我們有個數組和整數
作爲本地變量

00:27:52.739 --> 00:27:55.509 
那麼在Address Sanitizer
編譯時

00:27:56.009 --> 00:27:59.346 
這些變量之間
會插入額外的紅區

00:27:59.413 --> 00:28:03.483 
這樣我們可以發現
堆棧變量的任何溢出

00:28:05.085 --> 00:28:07.287 
在運行時間進入函數時

00:28:07.354 --> 00:28:09.790 
堆棧紅區會中毒在運行時間

00:28:09.857 --> 00:28:13.026 
退出函數時它們會解毒

00:28:16.697 --> 00:28:19.600 
處理全局變量也非常相似

00:28:19.666 --> 00:28:24.204 
在編譯期間
檢測全局變量

00:28:24.671 --> 00:28:27.241 
額外的紅區會插入它們四周

00:28:29.376 --> 00:28:32.246 
現在堆棧和全局編譯器檢測

00:28:32.312 --> 00:28:34.848 
是Address Sanitizer
非常有用的功能

00:28:35.249 --> 00:28:37.784 
這會允許它發現其他工具

00:28:37.851 --> 00:28:39.453 
無法捕獲的程序錯誤

00:28:41.588 --> 00:28:44.925 
Address Sanitizer
還能找到其他類型的獨特程序錯誤

00:28:45.158 --> 00:28:49.530 
在座的Avid C++開發
人員會對此特別感興趣

00:28:50.864 --> 00:28:53.066 
我們有個C++容器矢量

00:28:53.667 --> 00:28:55.969 
即便所有的內存
都給了v.begin

00:28:56.036 --> 00:28:58.472 
v.begin加容量
都已經分配

00:28:59.173 --> 00:29:02.476 
訪問內存過去
v.end是個錯誤

00:29:03.944 --> 00:29:06.947 
檢測Leap C++
向Address Sanitizer

00:29:07.014 --> 00:29:10.017 
提供更多信息
這樣就會像這裏一樣

00:29:10.384 --> 00:29:11.251 
發現錯誤

00:29:16.089 --> 00:29:20.160 
正如我們所見
我們談到的所有檢測

00:29:20.227 --> 00:29:21.995 
都需要編譯器檢測

00:29:22.062 --> 00:29:25.032 
但是
我們知道部分錯誤會出現在

00:29:25.799 --> 00:29:29.469 
即便代碼沒有
重新編譯的時候也會觸發

00:29:29.636 --> 00:29:31.738 
例如我們調用
內存拷貝函數的時候

00:29:32.973 --> 00:29:37.411 
Address Sanitizer
會使用一個技術名爲BYOD函數

00:29:37.978 --> 00:29:40.647 
插補用運行時間的自身版本

00:29:41.081 --> 00:29:43.450 
來替代數十種標準庫函數

00:29:44.218 --> 00:29:46.019 
因爲這是一個運行技術

00:29:46.119 --> 00:29:47.855 
這些檢測甚至會觸發

00:29:47.921 --> 00:29:49.823 
未經重新編譯的代碼

00:29:50.991 --> 00:29:54.061 
這裏是個內存拷貝包裹示例

00:29:54.228 --> 00:29:58.899 
正如你所預期
在轉發原始內存拷貝執行前

00:29:59.166 --> 00:30:03.270 
首先會檢查源和目的地
緩衝區是否有效

00:30:06.673 --> 00:30:10.077 
所有這些額外檢查意味着
會有運行時間開銷

00:30:10.143 --> 00:30:11.478 
而且你可能會考慮這是什麼

00:30:13.180 --> 00:30:16.483 
這些細節很大程度上
取決於各自的程序

00:30:16.550 --> 00:30:20.354 
Address Sanitizer
通常會導致CPU減速2倍左右

00:30:20.954 --> 00:30:24.758 
但是我們看到在一些邊緣情況下
曾高達5倍

00:30:25.592 --> 00:30:28.095 
而內存開銷從2倍到3倍

00:30:29.429 --> 00:30:30.797 
需要注意的一點是

00:30:30.864 --> 00:30:32.966 
這些開銷要比

00:30:33.033 --> 00:30:36.703 
可以找到相似問題的
其他工具要小很多

00:30:37.971 --> 00:30:40.741 
通過運行時間技術
編譯編譯器檢測

00:30:40.807 --> 00:30:43.410 
是令Address Sanitizer
更爲有效和

00:30:43.477 --> 00:30:46.880 
可擴展的關鍵所在

00:30:47.781 --> 00:30:52.152 
例如 我們在Address Sanitizer
運行並測試Safari

00:30:53.053 --> 00:30:53.921 
這是個大app

00:30:56.657 --> 00:30:59.793 
這是Xcode 7
新增的Address Sanitizer

00:31:01.862 --> 00:31:02.729 
謝謝

00:31:09.603 --> 00:31:12.272 
我們調整一下關注點
來仔細看看

00:31:12.339 --> 00:31:16.310 
我們平臺上可用的
其他內存管理工具

00:31:16.376 --> 00:31:18.912 
它們可以做什麼
你何時應該使用

00:31:20.214 --> 00:31:22.082 
那我們先從
Guard Malloc開始

00:31:22.149 --> 00:31:25.052 
像Address Sanitizer一樣
它也可以發現同樣問題

00:31:25.252 --> 00:31:27.221 
使用Guard Malloc的
主要優勢是

00:31:27.287 --> 00:31:29.523 
它不需要進行重新編譯

00:31:30.624 --> 00:31:32.960 
另一方面
它還有其他侷限性

00:31:33.627 --> 00:31:35.896 
Guard Malloc不能在
iOS設備上運行

00:31:36.063 --> 00:31:38.165 
而且不能發現
Address Sanitizer

00:31:38.232 --> 00:31:39.666 
發現的所有問題

00:31:40.267 --> 00:31:42.903 
例如 因爲它使用保護頁面

00:31:43.604 --> 00:31:47.107 
它將無法捕捉到
所有的單字節緩衝區溢出

00:31:47.207 --> 00:31:49.243 
這是個常見錯誤

00:31:50.410 --> 00:31:54.081 
再選擇兩者間該使用哪個時
要考慮其他的權衡因素

00:31:55.282 --> 00:31:57.751 
可供大家考慮的
還有NSZombie

00:31:58.285 --> 00:32:01.755 
它善於捕捉Objective-C
對象過度釋放

00:32:02.623 --> 00:32:05.526 
可以通過發送信息時
困住的殭屍對象

00:32:05.926 --> 00:32:09.329 
替代取消分配對象
以發揮作用

00:32:10.330 --> 00:32:12.432 
這個基本功能
可以從Xcode中的

00:32:12.666 --> 00:32:15.469 
相同Diagnostics選項卡
來啓動

00:32:15.802 --> 00:32:18.739 
但是 如果希望
獲得該功能的全部效用

00:32:18.805 --> 00:32:20.774 
還是要使用
Zombies Instrument

00:32:22.376 --> 00:32:27.114 
Malloc Scribble會幫助
調查未初始化的內存問題

00:32:27.481 --> 00:32:29.716 
它可以通過預設常數
填入分配和

00:32:29.983 --> 00:32:34.087 
取消分配的內存
更能預見這些錯誤的出現

00:32:35.556 --> 00:32:37.624 
最後
泄露Instrument會幫助你

00:32:37.691 --> 00:32:41.562 
發現保留週期
以及導致更高內存

00:32:41.628 --> 00:32:43.096 
消耗的放棄內存

00:32:45.999 --> 00:32:47.968 
總之
我們見識了三種不同的技術

00:32:48.035 --> 00:32:51.805 
可以幫助我們
更深入地理解程序

00:32:52.306 --> 00:32:54.842 
首先 使用View
Debugger來發現

00:32:54.908 --> 00:32:57.277 
並解決佈局的約束問題

00:32:58.245 --> 00:33:00.080 
第二 設置斷點操作

00:33:00.147 --> 00:33:03.917 
以便自動評估和
打印任何LLVD表達式

00:33:04.351 --> 00:33:05.786 
並使用異常斷點

00:33:05.853 --> 00:33:10.390 
讓程序調試恰好停在
異常出現的位置

00:33:11.024 --> 00:33:12.359 
最後 第三

00:33:12.793 --> 00:33:15.863 
使用Address Sanitizer
整理應用

00:33:16.230 --> 00:33:18.932 
清除那些難以捉摸的
內存出錯問題

00:33:20.467 --> 00:33:23.170 
關於今天談到的問題
還有其他的資源

00:33:23.237 --> 00:33:24.771 
幫助大家瞭解更多內容

00:33:25.739 --> 00:33:28.275 
本週早些時候
有幾次講座介紹了

00:33:28.342 --> 00:33:31.345 
LLDB連續整合和測試問題

00:33:31.645 --> 00:33:34.214 
大會結束後
大家就可以立即觀看

00:33:34.681 --> 00:33:36.750 
非常感謝
祝大家今天過得愉快