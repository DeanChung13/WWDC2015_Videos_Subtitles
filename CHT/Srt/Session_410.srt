00:00:19.820 --> 00:00:25.025 
Xcode中的持續集成和代碼覆蓋

00:00:33.600 --> 00:00:34.434 
早上好

00:00:35.402 --> 00:00:38.472 
歡迎參加“Xcode中的
持續集成和代碼覆蓋”

00:00:38.939 --> 00:00:41.842 
我的名字是馬特·莫里亞蒂
我是Xcode團隊的一名工程師

00:00:42.242 --> 00:00:44.978 
今天 能在這裏給大家講講
我們在Xcode中推出的一些工具

00:00:45.045 --> 00:00:47.014 
我感到激動萬分這些工具可以幫助你們

00:00:47.080 --> 00:00:49.850 
從測試中受益更多我們也希望
它們可以激勵你寫更多的測試

00:00:53.153 --> 00:00:54.922 
今天 我們先來講講

00:00:54.988 --> 00:00:56.256 
Xcode Server

00:00:56.590 --> 00:00:58.859 
Xcode Server是我們
捆綁到Xcode上的一項

00:00:58.959 --> 00:01:00.093 
持續集成產品

00:01:01.595 --> 00:01:03.497 
然後我們再來講講
XcodeServer

00:01:03.564 --> 00:01:04.864 
和Xcode 7中有什麼新料

00:01:05.165 --> 00:01:09.036 
並且重點關注下我們
今年引入的新的代碼覆蓋特性

00:01:10.804 --> 00:01:12.439 
會議的下半程我們會來講一些

00:01:12.673 --> 00:01:14.975 
Xcode Server更多的
高級特性

00:01:15.242 --> 00:01:16.677 
這些特性可以允許你把它集成到

00:01:16.743 --> 00:01:18.812 
你的團隊的獨特的工作流程上

00:01:19.613 --> 00:01:20.714 
當然了 在會議整個過程中

00:01:20.781 --> 00:01:23.116 
我們都會通過演示向你們
展示這些東西是如何實現的

00:01:24.418 --> 00:01:25.285 
讓我們開始吧

00:01:27.754 --> 00:01:30.157 
Xcode Server是我們
通過Xcode 5

00:01:30.224 --> 00:01:31.458 
引入Xcode的一項特性

00:01:31.825 --> 00:01:35.596 
它是關於對一個叫做
“持續集成”的進程提供支持的

00:01:36.830 --> 00:01:40.200 
持續集成的目的 是爲了
提高你們團隊的協作效率

00:01:40.634 --> 00:01:42.169 
讓你們得以打造更好的軟件

00:01:43.237 --> 00:01:44.171 
那麼這意味着什麼？

00:01:44.404 --> 00:01:47.708 
這意味着定期把你的全部代碼取下來

00:01:48.008 --> 00:01:52.446 
然後進行構建、測試
讓構建錯誤、測試失敗等問題

00:01:52.679 --> 00:01:53.680 
儘快浮出水面

00:01:53.947 --> 00:01:55.516 
這樣你就可以立即修復它們

00:01:58.218 --> 00:02:00.721 
你們實現持續集成的方式有很多

00:02:00.921 --> 00:02:03.690 
但是我們認爲Xcode 
Server更加適合像你們一樣的

00:02:03.757 --> 00:02:04.858 
app開發者原因有兩個

00:02:06.360 --> 00:02:08.294 
第一個原因設置它很容易

00:02:08.662 --> 00:02:10.497 
因爲與OS X Server
進行了集成

00:02:10.663 --> 00:02:13.133 
如果你已經在你的Mac上安裝了
OS X Server和Xcode

00:02:13.200 --> 00:02:15.802 
那麼你離讓一個持續集成
服務器定期測試你的項目

00:02:16.003 --> 00:02:17.371 
就很近了

00:02:19.773 --> 00:02:23.343 
第二個原因Xcode
Server和Xcode有深度集成

00:02:23.544 --> 00:02:25.812 
我們深諳如何構建Xcode項目

00:02:26.180 --> 00:02:28.515 
深諳如何兼容設備等等此類的事情

00:02:28.682 --> 00:02:30.751 
這樣我們就可以儘量少地問你們問題

00:02:30.817 --> 00:02:34.154 
就可以設置完畢定期檢查你的代碼

00:02:36.990 --> 00:02:39.726 
在我們展開講之前
我想先講幾個我們在談起

00:02:39.793 --> 00:02:42.129 
Xcode Server
時要提到的概念

00:02:42.829 --> 00:02:44.498 
第一個概念你可能已經熟悉了

00:02:44.865 --> 00:02:47.000 
哪怕你之前從沒有
用過Xcode Server

00:02:47.501 --> 00:02:48.702 
這個概念就是Scheme

00:02:49.269 --> 00:02:52.139 
每次你在Xcode中運行
你的項目或者測試時

00:02:52.206 --> 00:02:53.707 
你運行的就是一個Scheme

00:02:53.774 --> 00:02:55.409 
一般來說會自動爲你創建Scheme

00:02:55.475 --> 00:02:57.377 
不過你也可以創建你自己的
定製Scheme

00:02:57.444 --> 00:02:59.913 
它們基本上就構成了
構建你的項目的“食譜”

00:03:00.314 --> 00:03:03.550 
告訴你構建的目標是什麼
運行的測試包是什麼

00:03:03.750 --> 00:03:06.153 
傳遞給你執行的自變量
是什麼 諸如此類的事情

00:03:07.120 --> 00:03:09.256 
當需要設置Bot時
對Xcode Server來說

00:03:09.323 --> 00:03:11.091 
Scheme就非常重要了

00:03:12.626 --> 00:03:17.231 
Bot是我們傾向於把它
當成你的團隊的一員

00:03:18.398 --> 00:03:20.567 
它其實就是採取某種特定的方案構建好

00:03:20.868 --> 00:03:22.936 
然後根據你定義的日程表運行

00:03:23.203 --> 00:03:25.205 
並完全遵照你的說明執行某些操作

00:03:25.706 --> 00:03:27.274 
然後把結果彙報給你

00:03:29.910 --> 00:03:32.513 
每當我們按照日程表運行你的項目時

00:03:32.646 --> 00:03:34.181 
我們就稱之爲集成

00:03:34.248 --> 00:03:37.885 
它就好比是把你的團隊
每個成員所做的變更集成到一起

00:03:38.151 --> 00:03:40.554 
然後看看結果如何

00:03:43.790 --> 00:03:45.092 
既然我們都已經達成共識了

00:03:45.158 --> 00:03:46.660 
那麼就讓我們來談談Xcode 7

00:03:46.727 --> 00:03:48.529 
和Xcode Server中
有什麼新料

00:03:49.596 --> 00:03:52.933 
如果在Xcode 6之前你就用過
Xcode Server的話

00:03:53.233 --> 00:03:55.035 
你就知道每次你對
一個Bot進行編輯時

00:03:55.169 --> 00:03:58.438 
我們會讓你重新走一遍
生成Bot的整個工作流程

00:03:58.505 --> 00:04:00.340 
不過提前填寫好了很多值

00:04:01.041 --> 00:04:03.877 
如果你只是想做一些簡單的變更
比如添加一個觸發器

00:04:03.944 --> 00:04:06.046 
修改你的方案諸如此類的事情

00:04:06.113 --> 00:04:07.714 
那麼這就有點單調乏味了

00:04:08.081 --> 00:04:09.750 
現在我們有了這個選項卡式的界面 

00:04:09.816 --> 00:04:12.920 
你就可以進去完成你
想要的更改然後退出

00:04:19.026 --> 00:04:20.894 
看來大家都是選項卡式工作流程的粉絲

00:04:22.462 --> 00:04:24.998 
我們還對Xcode 7中的
源代碼管理做了多項改進

00:04:25.599 --> 00:04:27.467 
而我們之前則是會試圖自動處理

00:04:28.235 --> 00:04:32.673 
你的源代碼管理並且向你隱藏了
細節不過我們現在讓你看到了

00:04:32.739 --> 00:04:36.610 
更多 這樣你就可以清晰地看到
你的Bot將要校驗的儲存庫是哪個

00:04:37.244 --> 00:04:39.847 
並且你還可以選擇不要校驗某些儲存庫

00:04:40.180 --> 00:04:42.950 
對於你要校驗的儲存庫來說
現在你可以看到並且選擇

00:04:43.016 --> 00:04:45.986 
你要校驗的分支是哪個而不是...

00:04:47.754 --> 00:04:48.589 
謝謝

00:04:51.191 --> 00:04:53.427 
而不是寄希望於Xcode
希望它自行正確搞明白

00:04:57.231 --> 00:04:59.666 
我們還改進了源代碼管理的安全性

00:04:59.933 --> 00:05:02.870 
具體來說指的就是SSH指紋對比

00:05:03.170 --> 00:05:05.005 
以及自簽名證書

00:05:05.372 --> 00:05:09.710 
這兩項都不會自動成爲安全的輸送方式

00:05:09.776 --> 00:05:12.379 
它們要求你信任你連接的服務器

00:05:12.713 --> 00:05:16.116 
這樣如果服務器之後發生了變更

00:05:16.450 --> 00:05:20.387 
你就知道它們有了新的指紋它們
可能在冒充你以爲你正在連接的服務器

00:05:20.787 --> 00:05:24.258 
之前Xcode會自動信任這些服務器

00:05:24.591 --> 00:05:26.994 
而不做任何驗證

00:05:27.227 --> 00:05:29.897 
現在我們要求你明確
信任這些中的哪些服務器

00:05:30.163 --> 00:05:33.166 
然後我們會把指紋儲存起來
這樣如果之後它發生了變更

00:05:33.400 --> 00:05:35.502 
我們就不會從錯誤的服務器上進行校驗

00:05:38.772 --> 00:05:41.742 
我們同樣也更新了你在你的
集成中看到的多個報告

00:05:42.242 --> 00:05:44.511 
所以說測試報告也整理過了更緊湊了

00:05:45.646 --> 00:05:48.849 
現在在你的測試中
看出斷言故障就更加容易了

00:05:52.553 --> 00:05:55.689 
日誌視圖的性能提升也得到了大幅提升

00:05:55.923 --> 00:05:58.859 
之前我們試圖向你展示你的
全部日誌的堆疊視圖

00:05:59.259 --> 00:06:01.562 
但是當你視圖展開某項日誌時

00:06:01.628 --> 00:06:04.064 
這就出現了明顯的性能代償

00:06:04.131 --> 00:06:06.166 
現在我們一次只向你展示一條日誌 

00:06:06.233 --> 00:06:08.068 
你可以通過左上角的
彈出按鈕來選擇日誌

00:06:08.168 --> 00:06:11.438 
現在查看大的日誌文件也非常快了

00:06:20.280 --> 00:06:23.584 
提到持續集成讓Xcode 
Server脫穎而出的一件事情

00:06:23.650 --> 00:06:25.686 
是它知道Xcode項目會產生

00:06:25.953 --> 00:06:28.488 
什麼類型的問題它還知道

00:06:28.555 --> 00:06:31.458 
構建錯誤是什麼樣的
知道測試失敗是什麼樣的

00:06:31.725 --> 00:06:35.229 
它不會僅僅向你顯示一些
原始的純文本日誌文件

00:06:35.462 --> 00:06:38.365 
讓你自己仔細查看然後
找出發生了什麼問題

00:06:39.399 --> 00:06:41.969 
說到此類問題我們做了很多巧妙的事情

00:06:42.035 --> 00:06:44.104 
就是爲了讓這些問題
浮出水面 對你有所裨益

00:06:45.639 --> 00:06:46.740 
當你運行集成時...

00:06:46.907 --> 00:06:48.509 
Xcode 6中同樣也是如此...

00:06:48.642 --> 00:06:52.913 
我們會向你展示這個漂亮的報告
告訴你在你的構建中出了什麼問題

00:06:53.914 --> 00:06:56.216 
因爲我們會把這次集成
和之前的集成進行對比

00:06:56.283 --> 00:06:59.219 
我們就能讓新問題浮現出來
這樣我們就可以精確定位出

00:06:59.286 --> 00:07:02.856 
是哪次集成出了問題是哪次提交
把某個特定的問題帶進來了

00:07:03.290 --> 00:07:08.795 
這樣的話找到原因查出問題所在
修復問題就非常容易了

00:07:12.799 --> 00:07:15.335 
圍繞“問題” 我們在Xcode 7
中還添加了一些新東西

00:07:15.636 --> 00:07:17.137 
假如說你現在看到發生了一個問題

00:07:17.371 --> 00:07:20.274 
你要麼可以看到是不是
你的錯 這樣你好修復

00:07:20.407 --> 00:07:22.376 
它要麼你可以看到問題的原因

00:07:22.442 --> 00:07:24.378 
比如我就知道那裏錯了我就可以

00:07:24.444 --> 00:07:26.380 
進去快速修復它把這個搞定

00:07:26.813 --> 00:07:28.849 
然後你可以認領問題
這樣你的名字就放上去了

00:07:28.916 --> 00:07:30.617 
這樣當你的團隊中的每個人查看報告時

00:07:30.817 --> 00:07:32.853 
他們就可以看到這個這
樣他們就知道自己不用

00:07:32.920 --> 00:07:34.688 
操心這個事了因爲你已經在處理了

00:07:37.057 --> 00:07:38.926 
如果問題是間歇性的或者是你知道

00:07:38.992 --> 00:07:41.929 
已經修復了的問題你就可以

00:07:42.095 --> 00:07:43.230 
把它們“消音”一段時間

00:07:43.430 --> 00:07:44.932 
它們就會從報告中消失

00:07:46.400 --> 00:07:48.802 
這樣的話你可以集中精神關注那些

00:07:48.869 --> 00:07:50.437 
確實需要你關注的事而不用和你知道

00:07:50.504 --> 00:07:52.873 
已經解決了的事情攪和到一起

00:07:58.278 --> 00:08:01.648 
不過關於Xcode Server
最棒的一點是我們能在多大程度上

00:08:01.715 --> 00:08:04.117 
和Xcode引入的
其它各項特性進行交互

00:08:04.351 --> 00:08:06.520 
因爲我們在Xcode 7上
有一些很棒的新特性

00:08:06.787 --> 00:08:09.623 
我們也專門拿出時間
把這些特性集成到了

00:08:09.690 --> 00:08:10.858 
Xcode Server

00:08:11.358 --> 00:08:12.693 
我想看看其中的幾項特性

00:08:14.895 --> 00:08:17.564 
用戶界面測試是
Xcode 7上的新特性

00:08:19.032 --> 00:08:21.034 
我們專門對此進行了處理

00:08:21.101 --> 00:08:23.136 
確保了它能完美兼容
Xcode Server

00:08:23.871 --> 00:08:26.473 
當你運行Mac測試或者
iOS模擬器測試時

00:08:26.807 --> 00:08:28.308 
我們會在你的服務器後臺

00:08:28.375 --> 00:08:29.610 
創建一個全屏會話

00:08:29.877 --> 00:08:31.144 
你的全部測試都是在那裏

00:08:31.378 --> 00:08:33.013 
運行的這就意味着你無需擔心啓動

00:08:33.212 --> 00:08:36.817 
你的應用程序時 是否處於
適用於Xcode 2的正確環境中

00:08:37.017 --> 00:08:38.150 
我們會替你搞定它

00:08:38.519 --> 00:08:40.220 
如果你用的是真實的iOS設備

00:08:40.453 --> 00:08:42.422 
那麼你就可以看到UI測試在設備上

00:08:42.489 --> 00:08:44.224 
逐句通過應用程序

00:08:50.864 --> 00:08:52.566 
用戶界面測試是以一個高水平的標準

00:08:52.699 --> 00:08:54.801 
對你的應用程序進行測試的絕佳方式

00:08:54.868 --> 00:08:56.470 
測試的方式和你的用戶看到的一致

00:08:56.537 --> 00:08:58.772 
並且會對所有的不同
層在一起的相互交互進行測試

00:08:59.006 --> 00:09:03.744 
如果你同時還有一個服務器
在各種設備上運行這些測試那就更棒了

00:09:05.345 --> 00:09:06.246 
對於一項方案來說

00:09:09.750 --> 00:09:12.519 
“點播資源”是iOS 9上
的一項新特性

00:09:12.786 --> 00:09:16.657 
通過避免在你的包中存儲太多的資源

00:09:16.723 --> 00:09:18.158 
它就可以讓你的apps包更小

00:09:18.392 --> 00:09:20.394 
如果你的app已經上
架了App Store

00:09:20.460 --> 00:09:22.095 
App Store就會替你充當主機

00:09:23.063 --> 00:09:25.132 
這樣 當需要的時候
你的應用程序就可以下載

00:09:25.332 --> 00:09:28.035 
這些資源而當你不用的時候
就可以從磁盤上刪除

00:09:29.703 --> 00:09:31.905 
那麼當你在發佈之前
需要做內部產品質量測試

00:09:31.972 --> 00:09:35.342 
需要測試你的應用程序的構建

00:09:35.709 --> 00:09:38.245 
並且你的app
已經上架App Store了

00:09:38.779 --> 00:09:40.280 
對於資源來說那時候會發生什麼？

00:09:40.347 --> 00:09:42.382 
那時候 App Store就不會
再爲這些資源充當主機了

00:09:42.449 --> 00:09:45.652 
你做的變更太快
App Store沒法再充當主機了

00:09:46.820 --> 00:09:48.555 
但是如果你是從Xcode 
Server上

00:09:48.622 --> 00:09:49.923 
獲取的內部產品質量構建

00:09:49.990 --> 00:09:52.693 
並且你是讓你的集成
爲你生成了你安裝到

00:09:53.293 --> 00:09:55.863 
你的設備上的IPAS
那麼這就會自動爲你進行處理

00:09:56.196 --> 00:09:59.099 
你不需要勾選選項框你什麼也
不用做Xcode Server

00:09:59.166 --> 00:10:01.702 
會自行知道在你的
應用程序內有了點播資源

00:10:01.768 --> 00:10:03.770 
它就會在自己的服務器上
爲這些資源充當主機

00:10:03.837 --> 00:10:05.706 
如何找到這些資源

00:10:13.180 --> 00:10:15.582 
最後 我還想再講講
Xcode 7上的另外一項

00:10:15.649 --> 00:10:17.718 
新的特性這項特性
和Xcode Server

00:10:17.784 --> 00:10:19.453 
以及持續集成都配合的天衣無縫

00:10:19.653 --> 00:10:20.621 
這就是“代碼覆蓋”

00:10:23.557 --> 00:10:28.061 
“代碼覆蓋”就是一種對你的
 測試的值進行度量的工具具體來說

00:10:28.262 --> 00:10:30.330 
當我們運行測試時
我們想知道實際運行的

00:10:30.631 --> 00:10:31.532 
代碼是什麼

00:10:32.466 --> 00:10:35.969 
因爲你很容易就會出現你的
應用程序上有一大堆

00:10:36.036 --> 00:10:39.072 
測試套件你很難進行變更

00:10:39.139 --> 00:10:41.608 
你不注意的話就不會出現迴歸這種情況

00:10:42.609 --> 00:10:45.512 
但是你怎麼知道你到底
需要多少項測試纔算足夠？

00:10:45.879 --> 00:10:48.715 
假如說我有一個應用程序
並且有二百項單元測試

00:10:49.116 --> 00:10:53.220 
但是這些測試卻僅僅覆蓋了
我的應用程序的20%？

00:10:53.921 --> 00:10:56.690 
要是這樣的話
它們可不像我想的那樣有用

00:10:57.024 --> 00:10:59.593 
因此代碼覆蓋爲的就是
把這些信息呈現給你

00:10:59.793 --> 00:11:01.261 
這樣你就可以做出明智的決策

00:11:01.895 --> 00:11:05.465 
它可以讓你運行你的測試
並且正確度量運行的代碼

00:11:05.766 --> 00:11:08.869 
是哪個更重要的是度量出完全
未經測試的代碼是哪個

00:11:09.169 --> 00:11:11.738 
這個代碼就是當你繼續添加新的特性時

00:11:11.805 --> 00:11:14.875 
可能出現迴歸的代碼而你之前
是不會從你的測試中知道的

00:11:17.177 --> 00:11:19.713 
因此我們認爲對於那些
真的在意測試的團隊來說

00:11:19.780 --> 00:11:20.848 
代碼覆蓋真的很重要

00:11:21.148 --> 00:11:23.917 
這也是我們把代碼覆蓋集成到
Xcode的原因

00:11:25.519 --> 00:11:27.154 
像其它很棒的Xcode特性一樣

00:11:27.321 --> 00:11:29.923 
代碼覆蓋在構建時就和
LLVM有着緊密集成

00:11:30.724 --> 00:11:33.760 
因此當你在你的方案中收集
啓用的代碼覆蓋時

00:11:33.894 --> 00:11:35.629 
編譯器就會對你的代碼進行指導

00:11:35.896 --> 00:11:38.599 
我們就可以計算每個表達的執行頻率

00:11:39.166 --> 00:11:41.568 
然後我們就會在IDE中
把這個信息呈現給你

00:11:43.003 --> 00:11:44.671 
我們現在有兩種方式可以實現這一點

00:11:45.405 --> 00:11:48.575 
第一種是當你進到你的
測試的報告導航器中

00:11:48.742 --> 00:11:51.445 
你之前在Xcode 6中
就可以這麼做 不過現在在

00:11:51.512 --> 00:11:53.881 
Xcode 7中有了一個貼有
“覆蓋”標籤的新標籤

00:11:55.415 --> 00:11:59.119 
如果你查看這個報告
你就可以根據目標 文件

00:11:59.186 --> 00:12:01.555 
以及方式進行查看
這樣就可以知道你的應用程序

00:12:01.622 --> 00:12:02.990 
的各個不同部分的覆蓋情況

00:12:04.391 --> 00:12:07.361 
這樣你就可以從一個較高的
層面來查看你的應用程序

00:12:07.594 --> 00:12:10.130 
然後向下挖掘下 看看
值得你注意的部分是哪個

00:12:11.932 --> 00:12:16.336 
如果我發現某種方法的覆蓋率是75%

00:12:17.037 --> 00:12:18.038 
這也算是個好消息

00:12:18.105 --> 00:12:20.941 
但是我並沒有獲得
怎樣才能進行修復的信息

00:12:21.008 --> 00:12:24.411 
我不知道我的代碼的哪些
分支測試到了哪些分支沒有測試到

00:12:25.679 --> 00:12:28.582 
當你懸停在這些方法或者文件上時

00:12:28.649 --> 00:12:31.752 
我就可以點擊彈出的箭頭
這些就會顯示出源代碼編輯器

00:12:31.919 --> 00:12:34.421 
我們就可以在那裏通過
內聯註釋 高亮顯示你的

00:12:34.488 --> 00:12:36.290 
應用程序中未被覆蓋的部分

00:12:36.557 --> 00:12:38.625 
對於那些已被覆蓋的
部分來說 我們則會告訴你

00:12:38.692 --> 00:12:40.160 
它們在測試中被執行的次數

00:12:48.001 --> 00:12:51.271 
代碼覆蓋在Xcode IDE中
本身就已經很棒了

00:12:51.605 --> 00:12:54.408 
不過我想當你把它放到Xcode
Server上時 它會更棒

00:12:54.641 --> 00:12:56.810 
你在那裏有一個Bot在各種設備上

00:12:56.877 --> 00:12:58.212 
運行你的項目

00:13:00.214 --> 00:13:02.049 
集成和Bot的一個特別之處在於

00:13:02.115 --> 00:13:04.418 
你可以設置它們在一系列的設備上運行

00:13:04.484 --> 00:13:06.453 
而不是一次僅能運行在一臺設備上

00:13:06.520 --> 00:13:08.021 
就像你在Xcode中所做的那樣

00:13:08.956 --> 00:13:11.291 
當你這麼做的時候
我們會集中向你展示你全部

00:13:11.358 --> 00:13:13.527 
設備的覆蓋數據
並且我們以橙色高亮顯示

00:13:13.594 --> 00:13:19.032 
在你的設備上有着不同的
覆蓋的方法 目標 或者文件

00:13:19.333 --> 00:13:21.935 
這樣你就可以看看這些不一樣的地方

00:13:22.069 --> 00:13:25.172 
看看它是否屬於bug
還是屬於某種預期行爲

00:13:26.073 --> 00:13:29.309 
你在不同的設備上有不同的代碼覆蓋

00:13:29.510 --> 00:13:32.112 
這相當普遍尤其是在用戶界面代碼中

00:13:32.312 --> 00:13:33.947 
你在不同的設備上可能有不同的代碼

00:13:34.014 --> 00:13:35.983 
比如一臺iPad和一部
iPhone就不同

00:13:38.452 --> 00:13:41.555 
Xcode Server還可以爲你
提供的一件事情

00:13:41.722 --> 00:13:44.157 
是一份存儲追蹤你的項目的
存在期的檔案

00:13:44.658 --> 00:13:46.994 
這樣當你查看某個集成的代碼覆蓋時

00:13:47.060 --> 00:13:49.830 
我們就可以高亮顯示變更發生的時間 

00:13:50.030 --> 00:13:53.967 
這些變更在代碼覆蓋中的方法以及文件

00:13:54.201 --> 00:13:57.070 
這樣你就可以精確定位到
某次具體的提交集合

00:13:59.840 --> 00:14:03.243 
檔案還使得我們可以顯示
趨勢 之前在Xcode 6中

00:14:03.310 --> 00:14:05.846 
我們有構建歷史圖表以及你的
Bot的測試歷史圖表

00:14:06.313 --> 00:14:09.183 
這樣當你添加更多的測試的時候
你就可以看到圖表發生變動

00:14:09.449 --> 00:14:11.818 
你就可以看到事情進展如何

00:14:12.252 --> 00:14:13.520 
你的Bot的穩定性如何

00:14:13.854 --> 00:14:15.822 
不過現在我們又有了一項
新的代碼覆蓋圖

00:14:16.089 --> 00:14:19.193 
可以表明隨着時間的變化
你的項目的整體覆蓋趨勢

00:14:20.294 --> 00:14:23.163 
這樣的話 你就可以知道
舉例來說是否有所提升

00:14:23.230 --> 00:14:25.199 
這樣你就可以知道當你添加特性時

00:14:25.365 --> 00:14:27.100 
你是否需要給這些特性添加測試

00:14:27.467 --> 00:14:30.437 
或者你是否需要給
之前沒有覆蓋到的特性添加測試

00:14:31.071 --> 00:14:33.740 
或者也可能出現向下的趨勢
這是因爲你進展太快了

00:14:33.807 --> 00:14:35.542 
沒有對你剛加的特性進行測試

00:14:35.776 --> 00:14:37.945 
這樣 就可以幫助你做出明智的決策

00:14:38.078 --> 00:14:40.480 
決定下一步該怎麼辦
決定如何分配你的開發時間

00:14:44.318 --> 00:14:46.887 
當然了 如果你在你的工作區
使用大屏幕來顯示你的

00:14:46.954 --> 00:14:50.123 
Bot的整體狀況
那麼在你的項目的測試數量

00:14:50.190 --> 00:14:53.961 
下面我們還會向你顯示你的整體
覆蓋百分比這樣你就可以密切注視它

00:14:56.930 --> 00:14:57.764 
好的

00:14:57.831 --> 00:14:59.633 
現在我想請我的同事埃裏克上來

00:14:59.700 --> 00:15:02.202 
請他給大家演示一些Xcode
以及Xcode Server上的

00:15:02.269 --> 00:15:03.103 
代碼覆蓋特性

00:15:10.844 --> 00:15:11.712 
謝謝 馬特

00:15:12.880 --> 00:15:15.482 
我要向你們演示一個
我們開發的供內部使用的

00:15:15.682 --> 00:15:17.684 
應用程序我們用它來跟蹤大家互相

00:15:17.751 --> 00:15:18.819 
欠下的請喝咖啡的次數

00:15:19.219 --> 00:15:21.088 
去年你可能已經看過這個應用程序了

00:15:21.154 --> 00:15:22.890 
自那之後我們又做了一些改進

00:15:24.057 --> 00:15:26.960 
它的基本規則是
如果有人替你修復了一個bug

00:15:27.027 --> 00:15:29.363 
或者你欠了別人一個人情
那麼你就需要請對方喝咖啡

00:15:29.563 --> 00:15:31.398 
我們專門有一個應用程序對此進行跟蹤

00:15:32.199 --> 00:15:34.201 
和其它優秀的應用程序一樣
我們也有單元測試

00:15:34.268 --> 00:15:36.036 
來確保當我們添加新的特性時

00:15:36.103 --> 00:15:38.138 
不會影響到已有的工作代碼

00:15:39.973 --> 00:15:42.743 
對這些進行測試只算成功的一半

00:15:42.809 --> 00:15:45.746 
當對應用程序進行實際的全面測試時

00:15:45.946 --> 00:15:49.216 
我不知道我能坦然面對的
單元測試有多少個

00:15:49.283 --> 00:15:51.785 
我想看看覆蓋情況看看情況如何

00:15:53.220 --> 00:15:55.088 
不過也許我們沒有那麼多的測試

00:15:55.355 --> 00:15:56.190 
讓我們來看看

00:15:56.423 --> 00:15:58.859 
實際上 在我來這兒之前
我已經運行過了測試

00:15:59.860 --> 00:16:01.495 
我們可以直接在設備上看看測試結果

00:16:01.562 --> 00:16:02.396 
我們只有七項測試

00:16:02.563 --> 00:16:04.164 
這可很不妙

00:16:05.032 --> 00:16:07.768 
不過這是一個小的應用程序

00:16:07.835 --> 00:16:09.903 
也許這已經足以覆蓋所有的事情了

00:16:10.003 --> 00:16:11.839 
最起碼這些測試都通過了所以開局不錯

00:16:11.905 --> 00:16:12.873 
我們來看看覆蓋情況

00:16:15.309 --> 00:16:16.710 
如果我們來看看這裏的覆蓋報告

00:16:16.777 --> 00:16:19.112 
我們就可以看到這個應用程序
被分解成了兩個目標

00:16:19.179 --> 00:16:22.382 
我們有一個UI層面的應用程序即
coffeeboard.app

00:16:22.716 --> 00:16:24.451 
測試覆蓋情況不太好

00:16:25.419 --> 00:16:28.188 
不過沒關係 這是一個UI應用程序
我應該給它寫一些UI測試

00:16:28.255 --> 00:16:30.791 
我更關心這個基礎水平的框架

00:16:31.024 --> 00:16:32.926 
我們可以在這裏看到
只有50%測試覆蓋

00:16:32.993 --> 00:16:37.130 
這可不太妙因爲如果我們努力的話
就可以實現100%覆蓋

00:16:38.165 --> 00:16:42.369 
看起來真正落後的類是這個事務類

00:16:43.604 --> 00:16:45.339 
如果我們看看這個事務類

00:16:46.039 --> 00:16:47.508 
我們就可以看到這裏有一堆的類

00:16:47.574 --> 00:16:49.476 
在我們的各項單元測試中
並沒有被調用到

00:16:50.043 --> 00:16:52.145 
我們創建了一些事務
我們可以看到它們在

00:16:52.212 --> 00:16:53.714 
初始化程序中被調用了

00:16:54.414 --> 00:16:56.350 
但是我們並沒有實際用它們來做什麼事

00:16:56.817 --> 00:16:58.385 
我再來解釋下我們的app

00:16:58.452 --> 00:16:59.720 
它有一項很棒的特性

00:17:00.220 --> 00:17:02.623 
使用了我們的一個專屬算法

00:17:02.723 --> 00:17:05.526 
如果我欠馬特兩杯咖啡
而他又欠我一杯咖啡

00:17:05.893 --> 00:17:08.729 
那麼我們就會把這兩個數字合併
就成了我欠馬特一杯咖啡

00:17:09.997 --> 00:17:11.397 
因爲算法是祕密的我就想確保

00:17:11.464 --> 00:17:14.101 
這個算法經過了仔細測試因爲數學

00:17:14.167 --> 00:17:16.970 
不是我的強項我就更得確保不出問題

00:17:17.938 --> 00:17:20.540 
我們來看看它的源文件

00:17:20.607 --> 00:17:22.776 
就像馬特說過的那樣
我要使用那個懸停後

00:17:23.010 --> 00:17:27.013 
顯示出來的箭頭
直接進到我的源碼編輯器

00:17:28.147 --> 00:17:32.019 
這裏我們可以看到一大堆
深色的高亮顯示區域

00:17:32.319 --> 00:17:35.189 
在我的源碼編輯器中
使用了默認的背景色的

00:17:35.255 --> 00:17:37.090 
代碼在這裏背景色是白色

00:17:37.391 --> 00:17:40.527 
就是已經在測試中覆蓋了的代碼
所以我並不太需要擔心它們

00:17:40.694 --> 00:17:44.398 
我更關心的是那些
以灰色背景顯示的代碼

00:17:44.998 --> 00:17:47.768 
我可以確認它們未被覆蓋到
因爲在右邊這裏

00:17:48.135 --> 00:17:49.403 
我們可以看到一堆“零”

00:17:49.603 --> 00:17:53.740 
表明這個代碼從未通過
我的任何單元測試

00:17:54.675 --> 00:17:55.509 
這可不好

00:17:56.810 --> 00:17:59.479 
現在讓我們在這個單元
測試中導航下 然後再來看看這個

00:18:00.180 --> 00:18:01.949 
如果我到事務測試那裏

00:18:03.684 --> 00:18:05.185 
我就可以發現我並沒有任何測試

00:18:05.252 --> 00:18:06.820 
這就出問題了

00:18:07.120 --> 00:18:08.789 
讓我們現在把它修復

00:18:09.156 --> 00:18:11.325 
我要在這裏創建一個小的空白區

00:18:12.025 --> 00:18:13.293 
寫一些Swift代碼

00:18:14.461 --> 00:18:16.597 
當然了 我假設
你們都有神奇的宏命令

00:18:16.663 --> 00:18:18.165 
可以爲你們添加各種單元測試

00:18:18.465 --> 00:18:20.033 
我們就是這樣開發程序的不是嗎？

00:18:26.440 --> 00:18:28.075 
我要在設備上運行下測試

00:18:28.141 --> 00:18:29.309 
這需要一點時間

00:18:29.376 --> 00:18:31.979 
就像馬特說過的那樣當你的代碼運行時

00:18:32.045 --> 00:18:34.715 
我們會用LLVM對你的代碼
進行指導 這樣我們就可以

00:18:34.781 --> 00:18:36.216 
看到到底運行的是哪個表達式

00:18:36.783 --> 00:18:40.354 
趁着它在我的設備上運行
我要去看看方案

00:18:40.621 --> 00:18:43.190 
要記住既然它是LLVM的一項特性

00:18:43.257 --> 00:18:44.892 
那麼它在Xcode上也是可選項

00:18:44.958 --> 00:18:47.594 
打開它的方式是進到方案編輯器

00:18:48.061 --> 00:18:49.329 
然後選擇測試操作

00:18:49.763 --> 00:18:52.833 
然後確保“收集數據覆蓋”
那個勾選框已經勾選了

00:18:53.901 --> 00:18:55.502 
這樣就可以確保我得到覆蓋數據

00:18:56.270 --> 00:18:57.838 
時間正好我的所有測試都成功了

00:18:58.205 --> 00:19:00.374 
太好了 只要我用神奇的
宏命令來構建 就總會成功

00:19:01.542 --> 00:19:03.710 
如果我現在看看
測試報告 我可以看到

00:19:04.478 --> 00:19:05.779 
我有更多的單元測試

00:19:05.979 --> 00:19:07.214 
但這並不是故事的全部

00:19:07.281 --> 00:19:08.649 
我們再看一次覆蓋報告

00:19:10.884 --> 00:19:12.519 
這裏 我們能看到一張更漂亮的圖片

00:19:12.786 --> 00:19:15.656 
如果我在上面放大下我們
就可以看到我現在覆蓋了76%

00:19:15.856 --> 00:19:18.592 
雖然不是100%覆蓋
但是已經比我們之前的情況好得多了

00:19:20.160 --> 00:19:22.896 
我要把事務類再次顯露出來

00:19:22.963 --> 00:19:25.132 
這裏我們可以看到
更多的這些類現在得到了覆蓋

00:19:25.199 --> 00:19:27.701 
我現在測試的是合併代碼
之前我一直很擔心這些代碼

00:19:28.001 --> 00:19:29.403 
害我損失了好多睡眠時間

00:19:30.370 --> 00:19:33.073 
這裏有件有趣的事
如果我們返回源編輯器

00:19:34.374 --> 00:19:36.443 
然後看看等效方法

00:19:36.510 --> 00:19:38.745 
如果你之前注意的話
當時它只是被部分覆蓋了

00:19:38.812 --> 00:19:41.181 
我們在這裏就可以看到原因所在

00:19:41.682 --> 00:19:42.749 
我們看看這個等效方法

00:19:42.816 --> 00:19:46.420 
我們並沒有把我們的事務類
同某個不是事務類的類進行對比

00:19:46.887 --> 00:19:50.257 
因此這個返回的假值永遠不會
在任何我們的單元測試中被調用到

00:19:50.991 --> 00:19:53.260 
當你查看不同的分支時
能夠看到這個覆蓋情況

00:19:53.327 --> 00:19:55.529 
用處會很大
尤其是當你的代碼中有很多

00:19:55.596 --> 00:19:58.332 
分支邏輯
你知道會出現邊界情況

00:19:58.765 --> 00:20:02.135 
這樣的話你就可以確保當你寫你的
單元測試時每種邊界情況都能覆蓋到

00:20:02.970 --> 00:20:04.972 
我們還可以看到
這個代碼被覆蓋了多次

00:20:05.038 --> 00:20:08.175 
因此你是否知道你的代碼中
有這種多個實例到底同一路徑

00:20:08.242 --> 00:20:10.844 
但是最終卻並不相同的情況就非常重要

00:20:10.911 --> 00:20:12.346 
你需要全部覆蓋它們

00:20:14.648 --> 00:20:16.850 
剛纔我做的事情都非常單獨枯燥

00:20:16.917 --> 00:20:19.553 
因此我希望有人能替我整天跑這些測試

00:20:19.620 --> 00:20:23.156 
我就不需要擔心這個
不需要對它們進行對比

00:20:23.223 --> 00:20:25.526 
但是有人告訴我
預算表中沒有僱傭一名

00:20:25.592 --> 00:20:26.760 
實習生來做這件事的錢

00:20:27.594 --> 00:20:29.263 
我們來看看Xcode Server

00:20:29.530 --> 00:20:31.965 
我已經爲此設置了一個
Bot 跑在一個已經

00:20:32.032 --> 00:20:34.401 
有了這個提交的不同分支
我們來看看這個Bot

00:20:36.370 --> 00:20:38.172 
就像剛纔馬特在幻燈片中演示的那樣

00:20:38.238 --> 00:20:41.508 
當Bot運行了二十四小時後

00:20:41.575 --> 00:20:44.044 
當它運行了一段時間後
我們就可以從更高層面

00:20:44.378 --> 00:20:46.046 
對我的項目進行一次總覽

00:20:46.914 --> 00:20:48.882 
頂部這裏 我們爲你顯示了
高階統計數字

00:20:49.483 --> 00:20:53.387 
你可以看到任何時間
任一週、時、月、年

00:20:53.820 --> 00:20:55.656 
或者自從你的Bot
運行以來的統計數字

00:20:56.957 --> 00:20:58.158 
然後我們可以看到構建歷史

00:20:58.225 --> 00:21:01.361 
在這裏 我們會爲你顯示隨着時間
變化的錯誤報警以及問題分析

00:21:01.528 --> 00:21:03.263 
在這個實例中我之前有一些報警

00:21:03.330 --> 00:21:04.498 
不過我已經修復了它們

00:21:04.898 --> 00:21:06.200 
所以現在我們顯示沒有問題

00:21:06.834 --> 00:21:09.136 
對於持續集成來說接下來的兩個圖表

00:21:09.203 --> 00:21:11.872 
可能是最重要的前提是假設
你的項目構建的很乾淨

00:21:11.939 --> 00:21:13.073 
沒有報警或者錯誤

00:21:13.640 --> 00:21:14.708 
那就是你的測試

00:21:15.209 --> 00:21:17.411 
在這個例子中我們可以看到
我之前有幾個測試失敗

00:21:17.477 --> 00:21:18.946 
不過我還是在持續添加測試

00:21:19.580 --> 00:21:22.816 
這很棒 不過我們真正想看到
的是 順利通過的測試數量

00:21:22.883 --> 00:21:27.688 
持續增長並且這些測試也讓
代碼覆蓋持續增長

00:21:27.888 --> 00:21:29.923 
如果你的測試增加了
但是覆蓋情況卻沒有增加

00:21:30.457 --> 00:21:32.492 
那麼你實際增加的價值
就沒有你想象的大

00:21:33.694 --> 00:21:35.996 
如果我看下上次集成的覆蓋情況

00:21:36.063 --> 00:21:38.265 
這是我剛剛進行的提交你們沒有看到

00:21:38.332 --> 00:21:39.433 
但是我保證我確實提交了

00:21:39.833 --> 00:21:41.902 
我們就可以直接進到覆蓋報告

00:21:43.303 --> 00:21:45.339 
當我本地跑我的測試時這個看起來

00:21:45.405 --> 00:21:47.040 
就和我們在Xcode中看到的很像

00:21:47.708 --> 00:21:49.710 
和Xcode中的類似
我們也是按照目標

00:21:50.077 --> 00:21:51.712 
按照不同的類進行了劃分

00:21:51.945 --> 00:21:53.514 
我可以展開那個事務類

00:21:54.348 --> 00:21:56.683 
看到相同的方法覆蓋層次
也一模一樣

00:21:57.384 --> 00:21:58.652 
不過有兩個不同之處

00:21:58.785 --> 00:22:00.654 
在這個例子中
我就可以在報告中看到

00:22:00.721 --> 00:22:02.222 
隨着時間推移發生的變化

00:22:02.289 --> 00:22:04.024 
這樣我就不用再查看兩份報告

00:22:04.091 --> 00:22:06.293 
看看覆蓋是否有所增加了

00:22:06.360 --> 00:22:07.961 
尤其是在改動不大的情況下

00:22:08.028 --> 00:22:10.864 
我們就可以讓它顯示在這裏了

00:22:11.431 --> 00:22:13.901 
現在 在CB 
foundation.framework

00:22:13.967 --> 00:22:16.003 
我的覆蓋率比之前提高了22%

00:22:16.870 --> 00:22:20.607 
尤其是事務類的覆蓋率也增加了48%

00:22:22.042 --> 00:22:24.444 
下面這裏我們用橙色高亮顯示了一件

00:22:24.511 --> 00:22:26.813 
有趣的事即設備的差異之處

00:22:27.281 --> 00:22:30.017 
實際上
在Xcode Server報告內

00:22:30.083 --> 00:22:33.287 
我可以點擊這個複選框
讓設備的差異之處立即

00:22:33.787 --> 00:22:34.855 
顯示出來

00:22:35.389 --> 00:22:37.724 
在這個例子中看起來
這個詳細視圖控制器

00:22:38.258 --> 00:22:40.093 
並沒有在我的iPhone上顯示出來

00:22:40.327 --> 00:22:42.062 
這實際上並不意外

00:22:42.129 --> 00:22:44.264 
在這個例子中 我們的
應用程序用的是分割視圖

00:22:44.798 --> 00:22:46.733 
除非有人點一下
否則第二個視圖控制器

00:22:46.800 --> 00:22:48.569 
並不會在iPhone上顯示出來

00:22:48.669 --> 00:22:50.604 
我們的單元測試並沒有執行那個代碼

00:22:50.971 --> 00:22:53.507 
這並沒有什麼特別不尋常不過你要確保

00:22:53.574 --> 00:22:54.942 
如果出現此類事情

00:22:55.209 --> 00:22:56.410 
那麼它們不會出乎你的意料

00:22:56.476 --> 00:22:58.745 
這也就是我們爲什麼讓你們
可以在Xcode Server中

00:22:58.812 --> 00:23:01.114 
很容易看到不同種類的設備的
差異之處的原因所在

00:23:01.849 --> 00:23:04.418 
這樣就可以很容易找出
本來應該被覆蓋的代碼

00:23:04.484 --> 00:23:05.652 
實際上沒有覆蓋到

00:23:07.120 --> 00:23:09.923 
這個就是顯示了代碼覆蓋的持續集成

00:23:09.990 --> 00:23:11.558 
那麼我要再請馬特來給大家談一些

00:23:11.625 --> 00:23:13.560 
Xcode Server
更多的高級特性

00:23:20.834 --> 00:23:21.668 
謝謝 埃裏克

00:23:22.803 --> 00:23:24.872 
就像埃裏克剛剛說過的
我要來給大家談一些

00:23:24.938 --> 00:23:26.773 
Xcode Server
更多的高級特性

00:23:27.474 --> 00:23:30.911 
我知道你們很多開發者
都對擴展Xcode Server

00:23:31.211 --> 00:23:34.715 
把它和你們團隊的工作
流程的一部分集成起來很感興趣

00:23:35.048 --> 00:23:39.052 
我們知道你們並不能
僅僅靠Xcode Server

00:23:39.119 --> 00:23:41.889 
這個工具就能搞定一切
因此我們想給你們提供

00:23:41.955 --> 00:23:43.524 
讓Xcode Server
和你們手上的所有

00:23:43.590 --> 00:23:45.225 
工具兼容完全擬合你們團隊的方式

00:23:46.693 --> 00:23:49.429 
我們有兩種方式今天我要
就如何把Xcode Server

00:23:49.963 --> 00:23:52.132 
集成到你使用的所有工具上談一談

00:23:52.699 --> 00:23:54.201 
首先是觸發器

00:23:55.702 --> 00:23:58.071 
觸發器是在Xcode 6中
引入的引入觸發器的目的

00:23:58.939 --> 00:24:02.643 
是爲了在你的Bot
以及你的集成的生命週期內

00:24:02.776 --> 00:24:04.311 
把定製操作集成到上面

00:24:05.245 --> 00:24:07.381 
觸發器可以是郵件通知
提供關於你的集成

00:24:07.447 --> 00:24:09.583 
集成運行情況出現了什麼問題

00:24:09.650 --> 00:24:12.586 
提交者是誰等等此類事情的細節

00:24:12.653 --> 00:24:18.058 
以及配置信息或者
你也可以選擇某種程序語言

00:24:18.725 --> 00:24:20.561 
把觸發器寫成任意腳本

00:24:21.962 --> 00:24:24.164 
我們默認使用Bash來跑這些腳本

00:24:24.231 --> 00:24:27.134 
因此你可以向你的觸發器中
輸入任何老的shell命令

00:24:27.201 --> 00:24:28.035 
照樣可以生效

00:24:28.502 --> 00:24:30.771 
但是如果你照着寫命令行工具那樣

00:24:30.838 --> 00:24:33.607 
在你的腳本頂部包含了
一個hash bang

00:24:33.941 --> 00:24:36.410 
我們就會用它
你也可以使用任何你喜歡的解釋器

00:24:36.944 --> 00:24:39.546 
如果你願意的話 你甚至還可以
用Swift來寫你的觸發器

00:24:40.647 --> 00:24:41.882 
埃裏克稍後會給你們演示下

00:24:44.284 --> 00:24:49.523 
觸發器可以在你的集成運行
之前或者之後運行

00:24:49.890 --> 00:24:52.092 
每一段代碼都能讓你的Bot

00:24:52.159 --> 00:24:53.660 
做一些很酷的事

00:24:54.361 --> 00:24:56.330 
在你的源代碼之後集成運行之前

00:24:56.530 --> 00:24:58.465 
運行的觸發器會進行檢驗

00:24:58.532 --> 00:25:00.667 
這點很重要
因爲這就意味着你可以訪問

00:25:00.734 --> 00:25:04.838 
你的項目 並且在構建之前
進行任何你想要的自動變更

00:25:06.573 --> 00:25:10.477 
集成之後運行的觸發器
可以根據集成的結果進行控制

00:25:10.544 --> 00:25:14.281 
這樣觸發器就可以僅在
集成成功時或者僅在測試失敗時運行

00:25:14.681 --> 00:25:17.518 
它們也可以訪問很多
關於你的集成中發生了

00:25:17.718 --> 00:25:19.319 
什麼事情的信息

00:25:21.288 --> 00:25:23.524 
我們提供訪問這些信息的
一種方式是通過

00:25:23.590 --> 00:25:24.925 
環境變量來訪問

00:25:25.959 --> 00:25:29.997 
這個僅僅是當你的腳本運行時
定義的某些變量的樣本

00:25:30.264 --> 00:25:32.866 
任何值得你用的腳本語言
都能讓你很容易地理解

00:25:32.933 --> 00:25:34.868 
這些環境變量讓你可以把它們用起來

00:25:36.336 --> 00:25:38.071 
我們舉個例子看看你能用它們做什麼

00:25:38.305 --> 00:25:42.176 
去年我們演示了一個觸發器
每當完成一項集成的時候

00:25:42.242 --> 00:25:44.511 
觸發器就會在一個逾限聊天室
內貼出一條消息

00:25:44.811 --> 00:25:46.613 
我們是使用了Bot的名稱集成的數量

00:25:46.680 --> 00:25:48.081 
以及結果來實現的

00:25:49.183 --> 00:25:51.552 
把它設置起來很容易很快

00:25:53.587 --> 00:25:56.657 
這裏我想請你們注意兩件事

00:25:56.723 --> 00:25:58.392 
因爲它們看起來比較怪看起來不協調

00:25:59.026 --> 00:26:01.028 
對於運行的集成以及相應的Bot來說

00:26:01.094 --> 00:26:03.463 
我們有一個BotID和一個集成ID

00:26:03.830 --> 00:26:06.166 
如果我們只給你這些那就有點怪了

00:26:06.366 --> 00:26:07.901 
你用一個ID做不了什麼事

00:26:07.968 --> 00:26:09.536 
這個ID是一個任意的字符串

00:26:10.204 --> 00:26:12.472 
那這個字符串有什麼好處？
沒有用戶想看這個字符串

00:26:13.540 --> 00:26:16.009 
這個字符串本身做不了
什麼事 但是當這個字符串

00:26:16.076 --> 00:26:18.345 
和Xcode Server API
結合起來後事情就非常有趣了

00:26:20.113 --> 00:26:22.482 
Xcode Server
API構成了

00:26:22.549 --> 00:26:24.685 
Xcode ID
和Xcode Server

00:26:24.751 --> 00:26:25.586 
通信的基礎

00:26:25.886 --> 00:26:28.455 
你也可以控制這個API爲你自己所用

00:26:28.622 --> 00:26:30.123 
用它來做一些很有趣的事

00:26:31.992 --> 00:26:34.761 
和大多數網絡服務APIs一樣
這個API構造時遵循的也是

00:26:34.862 --> 00:26:36.129 
開源的 相沿成習的標準

00:26:37.531 --> 00:26:41.668 
我們在服務器和客戶端之間
使用HTTPS來進行來回的安全通信

00:26:41.869 --> 00:26:46.039 
通過那個加密渠道
我們使用基本認證來進行認證

00:26:49.009 --> 00:26:51.512 
我們的API遵循的是一個REST

00:26:51.578 --> 00:26:54.047 
模式像Bot和集成一樣
與資源進行交互

00:26:54.248 --> 00:26:57.818 
使用標準的HTTP謂詞
比如獲取、發佈、打補丁、

00:26:57.885 --> 00:27:02.990 
刪除等等 在這些資源上執行操作

00:27:04.558 --> 00:27:07.561 
當然了 我們還使用了JSON
來對數據進行來回通信

00:27:07.794 --> 00:27:09.596 
JSON用起來很簡單
解析起來也很簡單

00:27:09.663 --> 00:27:11.298 
它是網絡服務的通用語

00:27:11.498 --> 00:27:12.332 
大家都在用它

00:27:15.269 --> 00:27:18.405 
對你來說Xcode
Server這個雄心勃勃的擴展器

00:27:18.805 --> 00:27:22.109 
是個好消息因爲這意味着無論你偏好
什麼樣的編程語言 什麼樣的環境

00:27:22.309 --> 00:27:25.145 
你肯定都能找到表達
HTTPS以及JSON的方法

00:27:25.212 --> 00:27:28.382 
也就意味着你能夠讓幾乎所有的東西
同Xcode Server進行交談

00:27:29.883 --> 00:27:33.120 
我們來看看我們都能怎樣
使用這個API

00:27:34.721 --> 00:27:37.090 
我們能問我們的服務器的
最簡單的問題是什麼？

00:27:37.791 --> 00:27:40.661 
我們從這個問題開始
我的服務器上有什麼Bot？

00:27:41.328 --> 00:27:42.362 
這個很簡單

00:27:42.496 --> 00:27:44.665 
我們向Bot資源發一個get請求

00:27:45.432 --> 00:27:48.035 
如果你看看那裏的URI
你就可以看到我們是通過端口

00:27:48.101 --> 00:27:52.773 
20,343進行通信的 我們所有的
API請求都有一個API前綴

00:27:53.407 --> 00:27:56.777 
這個並不重要但是當你們在
你們自己的服務器上

00:27:57.010 --> 00:27:59.880 
嘗試這個API的時候
我希望你們記住這一點

00:28:01.582 --> 00:28:04.418 
當我們發送完那個請求後
我們就得到了一個JSON對象

00:28:04.484 --> 00:28:05.986 
告訴我們得到的結果的數量

00:28:06.220 --> 00:28:08.055 
給我們提供一個與結果自身相關的陣列

00:28:09.223 --> 00:28:13.427 
每個JSON對象都代表一個在我們的
服務器上設置 配置的Bot

00:28:14.061 --> 00:28:17.431 
和大多數Bot一樣
Bot也有一個ID它們也有一個名字

00:28:17.564 --> 00:28:19.733 
和你在創建
它們時在Xcode中給的一樣

00:28:20.100 --> 00:28:22.069 
它們也有各個配置參數
和你在設置Bot時

00:28:22.669 --> 00:28:24.471 
設置的配置參數一樣

00:28:26.607 --> 00:28:28.775 
好的 那麼我們還能做什麼？
既然有了一個Bot

00:28:29.042 --> 00:28:31.211 
我們來看看這個Bot
運行了什麼樣的集成

00:28:32.646 --> 00:28:36.116 
現在我們可以訪問那個
Bot的集成子資源了

00:28:39.086 --> 00:28:40.954 
這樣做我們就可以得到一個和我們之前

00:28:41.221 --> 00:28:43.891 
看到的非常相似的結果
除了現在的結果...

00:28:44.091 --> 00:28:46.293 
代表集成而不是代表Bot

00:28:47.461 --> 00:28:50.130 
但是集成也同樣屬於資源
它們也有自己的ID

00:28:50.531 --> 00:28:53.700 
一件有趣的事是我們也保存了

00:28:53.967 --> 00:28:56.837 
集成上的Bot的快照這很重要

00:28:56.937 --> 00:28:58.839 
因爲隨着時間推移你的項目會發生變更

00:28:58.906 --> 00:29:01.141 
你可能採用新的
Xcode特性 類似這樣的事

00:29:01.441 --> 00:29:03.644 
當你編輯的時候 機器人
程序的配置也可能發生變更

00:29:03.944 --> 00:29:05.812 
因此我們存儲了一張集成的快照

00:29:05.879 --> 00:29:07.781 
這樣當集成運行時
你就可以知道到底你的

00:29:07.981 --> 00:29:09.283 
Bot是怎樣配置的

00:29:11.885 --> 00:29:15.322 
我們同樣會跟蹤你的集成的
構造過程的步驟

00:29:15.455 --> 00:29:17.224 
完成後你可以在那裏看到一個結果

00:29:17.558 --> 00:29:20.460 
你還可以看到你的集成發生的
各種不同的問題的分類

00:29:20.727 --> 00:29:24.731 
之前的集成的變更的分類

00:29:26.800 --> 00:29:29.102 
這些都是之前我向
你們展示的get請求

00:29:29.203 --> 00:29:31.772 
非常適合收集信息

00:29:32.172 --> 00:29:35.209 
不過如果你在用API的話
你可能想用它做些事情

00:29:36.176 --> 00:29:38.812 
那麼我們到底可以做什麼事 
來對我們的服務器產生影響呢？

00:29:39.246 --> 00:29:41.081 
我們可以手動觸發一個集成

00:29:41.648 --> 00:29:44.418 
也許我們有某種不屬於Xcode
 Server內置調度

00:29:44.484 --> 00:29:46.486 
程序的自動化流程
我們就希望使用這個流程

00:29:46.553 --> 00:29:48.355 
來爲某些Bot觸發集成

00:29:50.057 --> 00:29:52.526 
這個實現起來也很容易
我們可以使用相同的URL

00:29:52.726 --> 00:29:55.295 
把我們的HTTP方法
改成一個post

00:29:57.831 --> 00:30:01.268 
這樣的話我們就從“我想列出這個
Bot的集成”變成了

00:30:01.335 --> 00:30:03.337 
“我想爲這個bot
創建一個新的集成 ”

00:30:05.439 --> 00:30:06.540 
如果我們發出這個請求

00:30:07.074 --> 00:30:08.976 
我們就可以得到一個代表
一項集成的對象

00:30:09.042 --> 00:30:11.211 
和你們之前看到的很相似
不過這個對象輕了很多

00:30:11.512 --> 00:30:15.482 
在構造過程中集成上面
設置了許多項屬性

00:30:15.782 --> 00:30:17.484 
不過這個集成會僅僅處於掛起狀態

00:30:17.718 --> 00:30:20.521 
直到構造程序在隊列中撿起它
開始實際運行它

00:30:22.890 --> 00:30:26.460 
在我們的API中
大部分的post終點都要求你

00:30:26.693 --> 00:30:27.995 
在主體中放置一些JSON

00:30:28.061 --> 00:30:31.265 
然後說明這是這個資源的屬性

00:30:31.331 --> 00:30:34.568 
這是我正在創建的事物的屬性

00:30:35.169 --> 00:30:37.004 
在這裏集成屬於某種特例

00:30:37.371 --> 00:30:41.108 
因爲Bot在本質上已經成了那個樣子

00:30:41.241 --> 00:30:43.777 
它們已經成了每個新的集成的模板

00:30:44.044 --> 00:30:46.647 
因此它們知道創建一個新的集成
它們需要知道的一切

00:30:47.781 --> 00:30:50.150 
或者說 它們最起碼知道
一般情況下需要知道的一切

00:30:50.384 --> 00:30:52.619 
你也可以對你的集成有某種影響

00:30:52.686 --> 00:30:54.988 
舉例來說如果你想要一個運行時非常

00:30:55.055 --> 00:30:56.390 
乾淨、沒有殘餘物構造塊效應

00:30:56.690 --> 00:30:58.859 
的集成那麼你就可以通過向主體中

00:30:59.226 --> 00:31:02.296 
傳遞某些JSON 告訴主體這個
集成在運行之前應該先進行

00:31:02.429 --> 00:31:04.631 
清理這種方式來實現

00:31:06.700 --> 00:31:09.303 
這裏有一個例子是你能用
我們的API做什麼事情的例子

00:31:09.436 --> 00:31:12.039 
現在我想把埃裏克請回來
請他給你們做一個

00:31:12.105 --> 00:31:13.540 
Xcode某些高級特性的演示

00:31:20.814 --> 00:31:21.648 
再次感謝 馬特

00:31:22.749 --> 00:31:24.751 
就像馬特所說的我們要通過這個項目

00:31:24.818 --> 00:31:27.154 
向你們演示一些
Xcode Server的高級特性

00:31:27.988 --> 00:31:30.157 
和你們中的許多人一樣

00:31:30.824 --> 00:31:33.260 
我們這個app也是內部開發的

00:31:33.327 --> 00:31:37.364 
不過我們也想把它分發出去我想要
非常容易地就能區分我的內部構建

00:31:37.698 --> 00:31:38.732 
以及我的外部構建

00:31:39.533 --> 00:31:42.169 
對此 最常見的一個策略是
如果我們看看我們的“資產目錄”

00:31:42.236 --> 00:31:43.737 
我們就可以看到兩張不同的圖片

00:31:43.904 --> 00:31:46.240 
在第一個例子中
我們可以看到標準app圖標

00:31:46.306 --> 00:31:48.408 
就是這個白色的咖啡杯

00:31:49.810 --> 00:31:51.712 
對於我們的內部構建來說

00:31:51.845 --> 00:31:55.249 
我們想要始終顯示一個
黑色的咖啡杯圖標

00:31:55.315 --> 00:31:56.450 
把它作爲一個內部標記

00:31:56.917 --> 00:31:59.620 
這樣的話 當我們在我們的
設備上運行內部構建時

00:32:00.354 --> 00:32:01.588 
我們就知道它們是內部構建

00:32:01.655 --> 00:32:04.758 
而不是我們可能上架App 
Store或者通過我們的正常通道

00:32:04.825 --> 00:32:05.759 
分發出去的外部構建

00:32:06.627 --> 00:32:08.795 
這就非常有用
當我們發現一個bug時

00:32:09.429 --> 00:32:11.365 
我們就知道就希望只
有我們能看到這個bug

00:32:12.900 --> 00:32:15.602 
還有一種方式我們可以
用來區分我們的內部app

00:32:16.103 --> 00:32:17.938 
就是當我們運行內部構建時

00:32:18.472 --> 00:32:20.240 
我們通常都有一個設置包

00:32:20.307 --> 00:32:23.076 
在那個設置包中像很多應用程序一樣

00:32:23.143 --> 00:32:25.379 
我們會定義一個版本
在這裏就是版本2.0

00:32:25.445 --> 00:32:27.347 
因爲我們剛剛做了一些很大的變更

00:32:28.048 --> 00:32:30.918 
2.0對於我們內部用戶來說
已經足夠完美了

00:32:30.984 --> 00:32:33.587 
不過向App Store提交時
我們不會提交這個版本

00:32:34.388 --> 00:32:37.391 
不過對於內部使用來說
我們可能還想要一些更多的細粒度信息

00:32:37.558 --> 00:32:40.427 
再進一步具體來說 我們想讓
構建有某種唯一標識符

00:32:41.662 --> 00:32:44.131 
在這個例子中我想用
Xcode Server來區分

00:32:44.331 --> 00:32:48.735 
構建是來自在我的服務器上的哪個集成

00:32:49.703 --> 00:32:51.271 
我到Bot那裏看看

00:32:52.739 --> 00:32:54.174 
這個Bot和我之前用的一樣

00:32:54.241 --> 00:32:55.876 
我要編輯下這個工作流程

00:32:57.377 --> 00:32:59.646 
正如馬特說的那樣
現在這是完全非線性的

00:33:00.013 --> 00:33:02.516 
因爲我對觸發器最感興趣
我就直接到那裏了

00:33:04.117 --> 00:33:05.652 
讓我們開始第一...

00:33:05.819 --> 00:33:07.688 
開始我們的第一步 變更圖標

00:33:08.188 --> 00:33:10.424 
我要打開一個我已經寫好的觸發器腳本

00:33:10.891 --> 00:33:12.893 
在這個例子中
這是一個簡單的批處理腳本

00:33:12.960 --> 00:33:14.795 
因爲我們要做的都是簡單的文件操作

00:33:15.028 --> 00:33:18.966 
我們要使用XES源目錄環境變量

00:33:19.032 --> 00:33:22.603 
來找出那個app圖標的路徑

00:33:23.770 --> 00:33:25.506 
然後我們要把它刪掉

00:33:26.139 --> 00:33:28.242 
然後我們要把我們的服務器版本取出來

00:33:28.308 --> 00:33:29.510 
把它移動到這個位置

00:33:30.143 --> 00:33:32.112 
那麼這就會成爲一個集成前觸發器

00:33:32.279 --> 00:33:34.581 
因爲我們想讓它在我們的
源代碼檢查完畢

00:33:34.648 --> 00:33:37.150 
準備構建但是並沒有真的
進行構建時運行

00:33:38.185 --> 00:33:41.121 
我要把它當成一個
運行腳本觸發器來複制

00:33:42.656 --> 00:33:46.493 
現在對設置包進行設置就會有點棘手了

00:33:46.560 --> 00:33:48.929 
我可以使用一個批處理腳本
來設置 但是那就需要手動

00:33:48.996 --> 00:33:51.698 
編輯大量的批處理腳本
或者在一個批處理腳本中

00:33:51.765 --> 00:33:53.400 
放大量的plist代碼會很痛苦

00:33:54.168 --> 00:33:57.070 
那麼我要啓用一個Swift觸發器

00:33:57.738 --> 00:34:00.440 
在這個例子中和bash觸發器類似

00:34:00.507 --> 00:34:03.277 
我要給用戶賓·斯威夫特
設置爲使用hash bang

00:34:04.645 --> 00:34:07.814 
我還沒有寫完所以請等我一下

00:34:08.748 --> 00:34:11.051 
我要獲取導入基礎 我在那裏就可以

00:34:11.485 --> 00:34:13.920 
獲得我想從Swift獲得的
其它額外的權限

00:34:14.721 --> 00:34:17.090 
導入基礎後
我要使用NSProcess信息

00:34:17.157 --> 00:34:20.226 
來獲得我在bash中其它腳本上
使用的

00:34:20.393 --> 00:34:22.362 
那些環境變量

00:34:22.462 --> 00:34:24.898 
在這個例子中就是XCS源目錄

00:34:27.935 --> 00:34:30.504 
然後我要找到我所有的設置包

00:34:30.571 --> 00:34:32.873 
這裏 有了Swift事情就更有趣了

00:34:32.940 --> 00:34:37.043 
我可以在Swift中
把plist當成一本字典載入

00:34:37.110 --> 00:34:40.380 
我並不需要親自手動對plist文件
進行任何編輯

00:34:40.947 --> 00:34:44.083 
當我想往上面添加什麼
東西時 這就非常有用

00:34:44.685 --> 00:34:47.521 
我只需要在swift中
創建一個新的字典常量

00:34:48.188 --> 00:34:50.456 
然後把它塞進我的字典中

00:34:51.558 --> 00:34:57.130 
這裏我們把集成編號的
環境變量設置成這個構建編號標題

00:34:58.131 --> 00:35:01.001 
最後在完成腳本之前

00:35:01.068 --> 00:35:02.803 
我要把它寫出到磁盤

00:35:02.870 --> 00:35:07.307 
這樣 當我們實際構建時
它就可以在我的設置包中被拾取到

00:35:08.542 --> 00:35:10.310 
爲此 我只需要在下面
添加另一個觸發器

00:35:11.512 --> 00:35:12.346 
好的

00:35:14.081 --> 00:35:15.382 
現在我有了兩個觸發器

00:35:17.317 --> 00:35:19.586 
現在 我就可以在這裏推送
“現在開始集成”按鈕

00:35:19.653 --> 00:35:21.488 
得到一個新的集成但是我想在服務器上

00:35:21.855 --> 00:35:24.992 
用一些馬特提到的API來實現這個

00:35:26.460 --> 00:35:28.395 
我要再啓用一個我擁有的應用程序

00:35:29.196 --> 00:35:32.833 
如果我們看這裏
我們就能看到一個應用程序

00:35:32.900 --> 00:35:36.003 
它已經連接到了插入我的
電腦的一個串行設備上

00:35:37.070 --> 00:35:40.941 
它使用了示例代碼的某些
輸入/輸出套件

00:35:41.008 --> 00:35:42.910 
那麼我們就要來讀取那個緩衝器

00:35:43.277 --> 00:35:46.613 
無論我們什麼時候在那個緩衝器上看到
有內容我們就要運行這一代碼塊

00:35:47.281 --> 00:35:52.286 
我要打開一個NSURL會話我要調用
能夠獲得所有的Bot的API

00:35:52.886 --> 00:35:54.221 
這只不過是本地主機

00:35:54.288 --> 00:35:57.024 
馬特之前提到過的端口API/Bot

00:35:57.191 --> 00:35:58.692 
就會成爲get方法

00:35:59.560 --> 00:36:04.298 
我要調用它使用NS JSON序列化
API然後在各個Bot中

00:36:04.565 --> 00:36:09.236 
進行讀取 找出咖啡板Bot的ID

00:36:10.003 --> 00:36:11.205 
我想集成的就是那個Bot

00:36:12.539 --> 00:36:15.042 
有了那個ID 我就可以
像馬特之前展示的那樣

00:36:15.108 --> 00:36:16.543 
使用Bot/我的

00:36:16.844 --> 00:36:22.349 
通用唯一標識符/集成
創建一個新的URL

00:36:22.416 --> 00:36:24.651 
把那個請求切換成一個post請求

00:36:25.018 --> 00:36:26.620 
這樣就會創建一個新集成

00:36:26.887 --> 00:36:29.556 
爲此我們並不真的在意集成要做什麼事

00:36:30.457 --> 00:36:31.992 
要觸發這個

00:36:32.759 --> 00:36:35.162 
我設法繞過安全機制
取得了這個有趣的小按鈕

00:36:35.863 --> 00:36:38.265 
我要把它插入我的Mac

00:36:41.101 --> 00:36:43.237 
然後我要運行這個應用程序

00:36:46.039 --> 00:36:47.107 
我們要再試試

00:36:53.046 --> 00:36:54.748 
在我運行之前確保它完全連接好了

00:36:55.349 --> 00:36:56.783 
不想操之過急 好的

00:36:58.051 --> 00:37:00.420 
很好 現在應用程序開始運行了
拾取了調制解調器

00:37:00.854 --> 00:37:04.491 
我要在我的Bot這裏放大下

00:37:04.558 --> 00:37:07.094 
然後等一會兒就是用這個按鈕

00:37:08.629 --> 00:37:09.463 
創建一個新的集成

00:37:17.037 --> 00:37:19.072 
就是完全用我們的API中的這個按鈕

00:37:19.239 --> 00:37:21.108 
我不想等待集成完畢
我要直接向你們展示

00:37:21.175 --> 00:37:24.378 
發生了什麼 在這裏我們可以看到集成

00:37:24.444 --> 00:37:27.881 
我可以把它安裝到我之前
使用的本地設備上進行測試

00:37:29.283 --> 00:37:34.454 
安裝 如果我打開QuickTime

00:37:35.756 --> 00:37:36.990 
你們就可以看到我看到的
東西...好的

00:37:42.396 --> 00:37:43.230 
這是我的設備

00:37:44.364 --> 00:37:46.433 
你可以看到我們在設備上有了內部圖標

00:37:46.500 --> 00:37:47.968 
儘管我從來沒有把它切換成本地

00:37:48.035 --> 00:37:50.470 
我們是從服務器上下載的
現在我們的app

00:37:51.271 --> 00:37:52.472 
我們知道 是一個內部構建

00:37:53.640 --> 00:37:56.376 
這些就是Xcode Server
上面的一些更多的高級特性

00:37:56.543 --> 00:38:00.147 
我要請馬特再講講你們可以
在實驗室的什麼位置找到我們

00:38:00.214 --> 00:38:01.348 
諸如此類的事情

00:38:02.382 --> 00:38:03.217 
馬特？

00:38:09.523 --> 00:38:10.490 
好的 謝謝 埃裏克

00:38:10.557 --> 00:38:11.692 
太棒了

00:38:11.959 --> 00:38:14.528 
我最喜歡按下大大的
紅色按鈕 進行集成了

00:38:17.531 --> 00:38:20.868 
這裏還有一些更多的你們可以
在我們的API中使用的端點

00:38:20.934 --> 00:38:24.605 
或者最起碼說對於你們這些
開發者來說是這樣的

00:38:24.972 --> 00:38:29.676 
這些還有很多的端點
但是它們是被鎖定的僅限內部使用

00:38:29.743 --> 00:38:34.982 
我們想要的是真正的安全確保當集成在
運行時不會和太多的東西混雜在一起

00:38:36.483 --> 00:38:38.585 
尤其與客戶端服務器之間的交互

00:38:38.785 --> 00:38:40.988 
你可能會在更多的地方
而不僅僅是你的網絡上

00:38:41.522 --> 00:38:42.656 
把你的服務器公開出去

00:38:43.590 --> 00:38:46.126 
不過當我們稍後上傳了
這個開發視頻以及幻燈片後

00:38:46.627 --> 00:38:51.598 
我建議你引用這個幻燈片
在你們自己的服務器上嘗試這些端點

00:38:51.832 --> 00:38:52.999 
然後看看你們會得到什麼

00:38:53.200 --> 00:38:54.902 
看看對於你們團隊來說有什麼有趣的事

00:38:57.404 --> 00:39:00.674 
今天我們看了我們在Xcode上對
Xcode Server所在的改進

00:39:00.741 --> 00:39:02.809 
無論是從質量方面來說

00:39:02.876 --> 00:39:06.013 
還是從採用添加到Xcode 7
中的新測試特性

00:39:06.079 --> 00:39:08.849 
來說 尤其是新的代碼覆蓋特性

00:39:09.149 --> 00:39:11.552 
用來度量你的應用程序
代碼在你的測試中

00:39:11.618 --> 00:39:14.488 
實際被用到的情況真是再合適不過了

00:39:15.522 --> 00:39:17.324 
當然了我們也向你們演示了擴展

00:39:17.591 --> 00:39:20.928 
Xcode Server通過觸發器
以及Xcode Server API把它

00:39:20.994 --> 00:39:23.430 
更好地與你們的
團隊進行集成的兩種方法

00:39:25.933 --> 00:39:27.634 
要獲取更多信息我們有一個

00:39:27.701 --> 00:39:30.771 
開發者庫有一個“持續集成指導”

00:39:31.271 --> 00:39:33.240 
當然了你也可以在開發者論壇上

00:39:33.307 --> 00:39:34.241 
貼出任何問題

00:39:36.310 --> 00:39:37.845 
有幾場會議與此相關

00:39:38.111 --> 00:39:40.380 
它們都已經結束了

00:39:40.547 --> 00:39:42.049 
有些是剛剛結束的

00:39:42.716 --> 00:39:46.954 
昨天結束的是“Xcode中的UI
測試”不過我建議你們去看看視屏

00:39:47.020 --> 00:39:49.089 
今天我們也談及了UI測試
但是我們並沒有向你們演示

00:39:49.156 --> 00:39:50.390 
它在Server中是如何運作的

00:39:50.490 --> 00:39:53.527 
它的自動化程度很高
不過UI測試特性真的很棒

00:39:53.594 --> 00:39:54.661 
我建議你們去試試

00:39:55.429 --> 00:39:58.165 
如果關於如何使用Xcode
Server你想了解更多信息

00:39:58.232 --> 00:40:00.934 
那麼去年我們在Xcode 6會議中
演示瞭如何從頭開始

00:40:01.001 --> 00:40:03.470 
設置你的服務器
如何在“持續集成”中

00:40:03.537 --> 00:40:07.207 
初始設置你的Bot

00:40:09.376 --> 00:40:12.079 
謝謝大家 祝你們在蘋果全球開發者
大會剩餘的時間內過得愉快