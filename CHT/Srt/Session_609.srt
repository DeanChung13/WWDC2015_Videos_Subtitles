00:00:19.686 --> 00:00:24.258 
和DemoBots一起深入GameplayKit

00:00:28.662 --> 00:00:32.064 
大家好歡迎來到“和DemoBots
一起深入GameplayKit”

00:00:32.933 --> 00:00:36.336 
今年我們創建了一個新的
遊戲示例名字叫DemoBots

00:00:36.870 --> 00:00:38.405 
如果你想在家玩那麼今天你就可以

00:00:38.605 --> 00:00:42.776 
從developer.apple.com/spritekit
把這個示例下載回來

00:00:44.044 --> 00:00:46.547 
這個遊戲利用了大量你們在
“SpriteKit會話中有什麼新料”

00:00:46.613 --> 00:00:48.815 
以及
“GameplayKit簡介”中

00:00:49.183 --> 00:00:53.654 
學到的東西如果你不會的話就去看看吧

00:00:55.289 --> 00:00:57.491 
如果不給你們演示我們就無法完成

00:00:58.292 --> 00:00:59.860 
這個叫做DemoBots的遊戲

00:00:59.927 --> 00:01:02.196 
我們來看一下這個遊戲該怎麼玩

00:01:07.968 --> 00:01:12.940 
我們開始一個新遊戲 你就是
PlayerBot就是這裏的這個人

00:01:13.574 --> 00:01:17.211 
你的任務是在時間用完之前
找到並幹掉每個關卡內的

00:01:17.411 --> 00:01:19.179 
壞的TaskBots

00:01:20.080 --> 00:01:22.249 
我們這裏還有兩個好的TaskBots 
因爲它們的臉是綠色的

00:01:22.316 --> 00:01:24.117 
所以你可以知道
是好的TaskBots

00:01:24.551 --> 00:01:27.654 
如果我在這個角落這裏溜達一圈
就可以找到第一個壞TaskBots

00:01:27.721 --> 00:01:29.356 
在這個例子中他是一個
GroundBot

00:01:29.723 --> 00:01:32.459 
當他發現我的時候他就會朝我
衝過來並且攻擊我

00:01:33.260 --> 00:01:34.094 
我損失了一些電量

00:01:34.795 --> 00:01:37.097 
沒關係 我要用一道射線搞定他

00:01:37.598 --> 00:01:40.634 
我用射線照射了它幾秒鐘後
就搞定了 他就成了綠色

00:01:41.401 --> 00:01:42.302 
我們看看他要去哪兒

00:01:44.104 --> 00:01:46.139 
我們又找到了一個
壞的TaskBots

00:01:46.206 --> 00:01:48.175 
我來把他也搞定

00:01:49.710 --> 00:01:52.913 
時間走完之前我在這個關卡內還有
兩個壞的TaskBots需要搞定 

00:01:53.380 --> 00:01:56.517 
不幸的是 它們也會互相攻擊 

00:01:57.150 --> 00:01:58.652 
把對方變成壞的TaskBots 

00:02:00.721 --> 00:02:01.855 
那裏就出現了這種情況 

00:02:02.589 --> 00:02:04.157 
把它們全部搞定後

00:02:08.461 --> 00:02:09.429 
這一關就算完成了 

00:02:13.867 --> 00:02:14.835 
這是第二關

00:02:17.271 --> 00:02:20.240 
第二關中增加了一種新的
角色 FlyingBot

00:02:20.541 --> 00:02:23.110 
那裏就掛着一臺FlyingBot
他正在自娛自樂

00:02:23.744 --> 00:02:25.546 
當你找到一臺壞的FlyingBot時

00:02:25.612 --> 00:02:29.850 
它們有不同的攻擊方式 
當我們撞到他的時候 

00:02:30.217 --> 00:02:33.487 
他發起了爆炸攻擊 
影響到了一定半徑範圍內的全部角色 

00:02:34.321 --> 00:02:37.491 
好消息是 如果你搞定一臺
FlyingBot 那麼它們的攻擊

00:02:37.558 --> 00:02:40.460 
就成了善意的攻擊 可以搞定
射程內的其它壞的FlyingBot

00:02:40.861 --> 00:02:41.862 
跟着他到這兒 

00:02:43.096 --> 00:02:45.332 
他肯定要撞上另外一臺
壞的FlyingBot了 

00:02:47.701 --> 00:02:50.137 
他躲開了他 好吧 我可以自己搞定他

00:02:50.838 --> 00:02:53.674 
他肯定要犯個大錯了

00:02:54.107 --> 00:02:57.511 
他正朝着角落那裏的一個大巢穴走去了

00:02:58.378 --> 00:02:59.479 
肯定是這樣的

00:03:01.815 --> 00:03:04.751 
當他被轉變成壞的FlyingBot時
我們可以利用他的爆炸攻擊

00:03:04.818 --> 00:03:09.890 
他把一個兩個壞的FlyingBot
轉變成好的了

00:03:11.825 --> 00:03:17.998 
就剩一個了 還剩一個

00:03:20.534 --> 00:03:21.735 
啊 不好！這可不妙 

00:03:25.138 --> 00:03:26.006 
又搞定一個 

00:03:27.841 --> 00:03:28.709 
這一關也完成了 

00:03:35.415 --> 00:03:36.517 
這就是DemoBots 

00:03:37.651 --> 00:03:39.486 
我想看看我們使用了哪些工具

00:03:39.553 --> 00:03:42.322 
和技術來實現這款遊戲

00:03:43.123 --> 00:03:47.294 
你可以看到當TaskBots
走動時它們有大量的動畫狀態 

00:03:48.095 --> 00:03:52.766 
我們努力做的一件事 
就是把我們需要的紋理 圖像

00:03:52.833 --> 00:03:55.536 
保持在最低程度 
從而讓app的大小不太誇張 

00:03:56.570 --> 00:03:59.873 
我們決定讓SpriteKit中的
新的動作編輯器

00:04:00.274 --> 00:04:03.243 
把動作創建爲...把動畫創建爲
動作而不是把動畫創建爲紋理

00:04:03.710 --> 00:04:07.181 
你們看到的攻擊動畫 那個攻擊射線 

00:04:07.648 --> 00:04:10.617 
是我們製作並應用到GroundBot
以及FlyingBot

00:04:10.684 --> 00:04:12.052 
上面的參考動作 

00:04:12.486 --> 00:04:15.355 
如果我們點擊進到那個動作 
我們就可以看到它是由

00:04:15.422 --> 00:04:17.491 
很多的微小的移動動作
一個接一個組成的 

00:04:19.293 --> 00:04:22.829 
因爲它是一個參考動作 
我們創建一次後 

00:04:23.096 --> 00:04:25.632 
就可以不考慮TaskBots的
方位 把它應用到

00:04:25.699 --> 00:04:27.501 
所有的TaskBots上 

00:04:28.402 --> 00:04:31.805 
因爲它是一個參考動作 
我們創建一次後 

00:04:32.172 --> 00:04:34.675 
還可以對它進行修改對源進行修改 

00:04:34.741 --> 00:04:36.844 
我們可以看到變更在各個地方
都生效了 我們就無需

00:04:36.910 --> 00:04:39.046 
在多個地方對它進行修改 

00:04:40.848 --> 00:04:43.951 
我們使用動作編輯器來生成射線動畫 

00:04:44.484 --> 00:04:47.521 
這個射線持續了這樣長的
幾秒鐘 我們還想讓這個射線

00:04:47.588 --> 00:04:51.291 
隨着時間衰減 我們也在
編輯器中創建了那些動作 

00:04:51.525 --> 00:04:53.861 
這樣我們就能直觀地看到它 
並且把它用到遊戲中 

00:04:55.629 --> 00:04:59.399 
遊戲中所有的資產都是在資產目錄中
創建的這些資產目錄在Xcode 7

00:04:59.766 --> 00:05:04.605 
之外 替我們轉換成了紋理地圖集 

00:05:05.339 --> 00:05:07.174 
這就意味着當我們把它們用在遊戲中時

00:05:07.241 --> 00:05:08.876 
我們就可以獲得儘可能好的繪製性能 

00:05:09.810 --> 00:05:11.144 
我們有很多這樣的圖像 

00:05:11.411 --> 00:05:14.615 
它還使得我們可以指定在不同的設備上

00:05:14.815 --> 00:05:15.816 
使用的正確的圖像 

00:05:16.917 --> 00:05:18.785 
它還可以幫助我們
進一步優化圖像的尺寸 

00:05:19.887 --> 00:05:22.856 
當我們設計我們的關卡時 
我們使用七百六十八點的參考標高 

00:05:22.923 --> 00:05:26.660 
那邊的那個黃色框那是我們想在屏幕上

00:05:26.727 --> 00:05:29.463 
顯示多少個關卡的參考 

00:05:30.197 --> 00:05:33.300 
以那個尺寸計算我們的PlayerBot
是一百二十個點 而如果我們

00:05:34.668 --> 00:05:39.840 
在一臺iPad上使用那個關卡 
那臺iPad就也是七百六十八點 

00:05:39.973 --> 00:05:42.910 
這樣我們就知道了PlayerBot
在屏幕上的尺寸他是一百二十個點

00:05:42.976 --> 00:05:45.579 
我們就可以計算出要想在
屏幕上得到他的清晰圖像 

00:05:45.646 --> 00:05:47.614 
他的尺寸應該是多少 

00:05:48.715 --> 00:05:52.186 
如果我們把那個關卡按比例縮小到一部

00:05:52.452 --> 00:05:55.956 
比如三百二十個點高度的
iPhone上 他就會變小 

00:05:56.123 --> 00:05:57.457 
他的高度就會成爲五十個點 

00:05:58.258 --> 00:06:00.494 
在iPad上我們不需要這麼高
分辨率的紋理 

00:06:00.727 --> 00:06:02.529 
我們就可以節省空間 

00:06:03.997 --> 00:06:07.167 
如果我們觀察下我們的
DemoBots支持的設備 

00:06:07.467 --> 00:06:11.905 
iPad iPhone以及Mac
隨着場景高度的變化

00:06:12.372 --> 00:06:14.441 
我們就可以計算出對應的玩家的高度 

00:06:15.609 --> 00:06:20.914 
iPhone 6比4S到5S
都略微大一點 

00:06:20.981 --> 00:06:24.518 
我們使用的也是同樣的
資產它太小了 你沒注意到

00:06:26.119 --> 00:06:31.191 
這就意味着你可以計算出
我們需要的1X 2X 3X資產 

00:06:31.558 --> 00:06:34.862 
讓圖像看起來清晰 同時又避免了
使用超出我們需要的更多的像素 

00:06:35.162 --> 00:06:38.966 
爲了簡單起見我們把iPhone 6 Plus
向下取整爲了一百八十像素 

00:06:40.968 --> 00:06:44.238 
我們可以爲每種設備設置
我們想要的資產 

00:06:44.872 --> 00:06:46.240 
遊戲中我們有很多這樣的資產 

00:06:46.773 --> 00:06:49.943 
我意思是它們的數量非常多數以千計 

00:06:51.411 --> 00:06:56.283 
實際上所有的這些角色資產都是在
一個3D渲染輸出上生成的 

00:06:56.850 --> 00:06:58.151 
我們也可以連接那個渲染輸出 

00:06:58.585 --> 00:07:02.189 
我們也讓那個資產目錄的
生成實現了自動化 

00:07:02.823 --> 00:07:05.459 
這裏的這個JSON文件 
這是PlayerBot

00:07:05.526 --> 00:07:07.761 
行走動畫的一幀 

00:07:08.395 --> 00:07:12.900 
我們同樣也可以自動生成這些文件
這就是Xcode使用資產目錄生成的

00:07:13.467 --> 00:07:17.104 
我們也可以讓爲每種設備拾取
正確的圖像這一過程

00:07:18.071 --> 00:07:20.374 
自動化 我們以後也會公佈資產目錄

00:07:20.440 --> 00:07:23.844 
格式參考 以便讓你可以更加容易地

00:07:27.147 --> 00:07:29.850 
自己創建這些文件我們還在遊戲中
使用了另外SpriteKit的一項特性 

00:07:29.917 --> 00:07:33.620 
即SKCameraNode 
在那之前 如果我們想要

00:07:34.054 --> 00:07:36.190 
在關卡內移動視圖 
我們就需要實際移動

00:07:36.590 --> 00:07:39.760 
整個場景 我們就必須
把關卡自身移動到視圖下面 

00:07:41.828 --> 00:07:44.431 
而有了SKCameraNode 
事情就變得簡單多了 

00:07:45.098 --> 00:07:47.634 
攝像機就是場景中的一個節點
它有自己的位置

00:07:48.202 --> 00:07:50.704 
因爲它有自己的位置 
我們就可以通過改變它的位置 

00:07:50.771 --> 00:07:52.873 
來移動攝像機
就像移動其他節點一樣 

00:07:53.440 --> 00:07:55.742 
改變當前視圖看到的
位置就更加容易了 

00:07:57.978 --> 00:08:01.048 
因爲它是一個節點 我們還可以
用它來做節點能做的事 

00:08:01.515 --> 00:08:03.550 
舉例來說 我們可以向
那個節點應用約束 

00:08:04.151 --> 00:08:06.820 
我們可以用這個把節點的
攝像機位置約束到

00:08:07.120 --> 00:08:10.524 
一個PlayerBot位置 
當他朝着屏幕角落跑去時 

00:08:11.992 --> 00:08:16.864 
我們在他四周就有很多黑色空間 

00:08:16.930 --> 00:08:19.933 
而不是我們想在屏幕上看到的
儘可能多的關卡 

00:08:21.001 --> 00:08:23.971 
我們還可以使用第二個約束
來對它進行改進 

00:08:24.738 --> 00:08:27.741 
這個約束可以確保我們不會
太過於靠近關卡的邊緣 

00:08:28.141 --> 00:08:29.042 
看起來就是這樣的 

00:08:30.210 --> 00:08:32.513 
一般來說 
我們會跟隨PlayerBot 

00:08:33.145 --> 00:08:35.716 
但是如果他靠近了邊緣 
我們就會停止跟隨他 

00:08:35.782 --> 00:08:37.183 
讓更多的關卡顯示在屏幕上 

00:08:37.683 --> 00:08:41.922 
當敵方bots攻擊你的時候 
這就更容易看出來了 

00:08:43.756 --> 00:08:44.858 
那麼我們是怎樣實現的？

00:08:45.692 --> 00:08:49.396 
我們首先計算出整個關卡的封邊矩形 

00:08:50.597 --> 00:08:53.233 
然後我們根據它們看到的遊戲屏幕的

00:08:53.534 --> 00:08:56.403 
寬度和高度得到一個較小的矩形 

00:08:57.171 --> 00:09:00.641 
我們再確保攝像機不能
移動到這個框以外 

00:09:00.707 --> 00:09:02.209 
我們把它約束到那個矩形 

00:09:03.210 --> 00:09:07.114 
這樣當攝像機跟隨玩家
四處移動時它就不會太過於靠近

00:09:07.314 --> 00:09:08.148 
關卡的邊緣 

00:09:11.051 --> 00:09:14.855 
因爲攝像機是一個節點了 
我們還可以向它添加子節點 

00:09:15.389 --> 00:09:19.560 
這就非常有利於警告信息的顯示
比如我們在遊戲中的計時器標籤

00:09:20.694 --> 00:09:23.297 
我們不想讓計時器標籤移動 
我們想讓它頂部居中顯示 

00:09:23.897 --> 00:09:27.100 
因此我們就把它添加爲
攝像機的一個子節點 

00:09:27.734 --> 00:09:30.170 
而不是場景的一個子節點
這樣的話當攝像機四處移動時

00:09:30.838 --> 00:09:34.208 
標籤也會隨之移動在屏幕的適當位置
保持這個固定特效就更加容易了 

00:09:37.311 --> 00:09:40.447 
這些就是我們在遊戲中用到的
部分SpriteKit特性 

00:09:41.114 --> 00:09:43.717 
我們再來看看如果我們用的是
GameplayKit的某些特性會怎樣 

00:09:43.917 --> 00:09:45.619 
首先是
GKStateMachine

00:09:45.686 --> 00:09:47.955 
你應該已經在
GameplayKit會議上

00:09:48.455 --> 00:09:51.892 
見到過它了那場會議講的是
你如何使用狀態機追蹤你的遊戲內的

00:09:51.959 --> 00:09:54.261 
角色 關卡以及其他元素
發生了什麼情況 

00:09:55.095 --> 00:09:57.698 
我們把這個以及其他一些東西
用在了PlayerBot上 

00:09:57.898 --> 00:09:59.066 
這是他的狀態 

00:09:59.333 --> 00:10:00.934 
他首先是處於“出現”階段 

00:10:01.435 --> 00:10:03.036 
也就是說他剛被“傳送”到了遊戲中 

00:10:03.937 --> 00:10:06.874 
爲此使用定製狀態很棒的一點就在於

00:10:07.307 --> 00:10:09.309 
它們可以確保不會發生意外 

00:10:09.743 --> 00:10:15.015 
當他們啓動後 就激活了一個
計時器 過了一定時間後 

00:10:15.649 --> 00:10:18.418 
它就會直接移動到玩家控制狀態 

00:10:18.485 --> 00:10:22.890 
然後打開輸入使用
這樣你就可以控制它了

00:10:24.391 --> 00:10:29.096 
當他命中一個目標後 我們
就把他的狀態改爲“命中”

00:10:29.162 --> 00:10:32.199 
當我們被命中後 我們就輸入
一個不同的動畫 就是那個

00:10:32.266 --> 00:10:36.203 
跳躍動畫 當玩家被命中後 
就不能再控制玩家了 

00:10:36.637 --> 00:10:39.306 
輸入就會關掉 並且繼續跟蹤狀態 

00:10:39.740 --> 00:10:42.709 
當時間過完後再把他移回
玩家控制狀態 

00:10:44.378 --> 00:10:47.748 
如果我們被命中的次數足夠多 
我們就必須重新充電 

00:10:48.048 --> 00:10:50.817 
我們就到了“重新充電”狀態 
而不是“命中”狀態 

00:10:51.618 --> 00:10:53.453 
那個會追蹤我們重新充電了多長時間 

00:10:53.921 --> 00:10:55.255 
那個狀態也會真的

00:10:55.489 --> 00:10:57.191 
給玩家添加更多的電量 

00:10:57.858 --> 00:11:01.328 
最後重新充電結束後它就會回到
PlayerControlled狀態 

00:11:03.430 --> 00:11:06.433 
這就是玩家可以擁有的
一套合理的複雜的行爲 

00:11:07.201 --> 00:11:10.938 
使用一臺狀態機來對狀態進行編碼 

00:11:11.004 --> 00:11:13.841 
引起狀態的發生定義要發生的正確的事

00:11:14.107 --> 00:11:17.277 
從一個狀態移動到另一個狀態 
這樣要確保遊戲內僅僅會

00:11:17.344 --> 00:11:19.146 
發生正確的事就更加容易了 

00:11:19.213 --> 00:11:21.715 
我們的PlayerBot不會做出
我們不想讓他做的事

00:11:23.584 --> 00:11:27.821 
我們同樣也把它用到遊戲本身上面 

00:11:28.355 --> 00:11:30.657 
當你玩一個關卡時 
我們就處於一個活動狀態 

00:11:31.525 --> 00:11:33.760 
如果我們點擊“暫停”
那麼我們就會進入暫停狀態

00:11:34.127 --> 00:11:37.197 
這就會通過在你退出
暫停狀態時刪除那個

00:11:37.431 --> 00:11:38.599 
覆蓋 從而對覆蓋進行處理 

00:11:39.566 --> 00:11:41.969 
如果我通關了一個關卡 
我們就處於一個成功狀態

00:11:42.503 --> 00:11:45.405 
同樣地 當我們成功時 
它就會處理所有的

00:11:45.572 --> 00:11:47.274 
顯示按鈕、進行覆蓋這些任務 

00:11:47.541 --> 00:11:49.510 
在這些情況中
狀態知道應該做什麼事情 

00:11:52.279 --> 00:11:55.048 
我們還用到了GameplayKit
的另一個方面 

00:11:55.115 --> 00:11:55.949 
即實體和元件 

00:11:56.783 --> 00:11:59.319 
新的元件是對自含式功能性
在遊戲的不同實體上

00:11:59.386 --> 00:12:03.891 
分享的功能性進行打包的
一種相當不錯的方式 

00:12:04.591 --> 00:12:06.960 
我們有三個實體
我們有PlayerBot

00:12:07.461 --> 00:12:09.463 
GroundBot
以及FlyingBot 

00:12:10.364 --> 00:12:11.765 
它們有一些共同之處 

00:12:12.432 --> 00:12:14.168 
它們都需要被渲染進場景中 

00:12:14.368 --> 00:12:15.335 
它們都需要一個陰影 

00:12:15.669 --> 00:12:18.705 
所以要完成這些事情我們就有了
一個渲染元件以及一個陰影元件 

00:12:19.506 --> 00:12:22.776 
它們也都有動畫 物理現象和智能 

00:12:22.843 --> 00:12:25.112 
這些名稱就是我們給予
狀態機 讓它跟蹤的名稱 

00:12:26.747 --> 00:12:29.416 
此時你可能會以爲它們看起來很像 

00:12:30.150 --> 00:12:33.320 
爲什麼不用一個基本
Bot類來給這三個實體

00:12:33.387 --> 00:12:35.289 
提供全部功能性呢？

00:12:36.490 --> 00:12:38.258 
別忘了 它們實際上並不是相似的 

00:12:39.193 --> 00:12:42.663 
需要對PlayerBot進行輸入 
我們可以通過一個遊戲控制器

00:12:42.963 --> 00:12:46.500 
鍵盤或者通過觸模控制對它進行控制 

00:12:47.467 --> 00:12:51.038 
GroundBot以及FlyingBot
並不需要進行輸入你無法控制這些角色

00:12:51.104 --> 00:12:53.340 
它們是由一個代理驅動的 

00:12:53.707 --> 00:12:57.044 
稍後你會看到我們是怎樣使用代理
來在關卡中驅動這些角色的 

00:12:57.611 --> 00:12:59.112 
PlayerBot
並不需要一個代理 

00:12:59.179 --> 00:13:00.581 
它的動力來自你的輸入 

00:13:01.748 --> 00:13:03.817 
同樣地GroundBot
以及FlyingBot

00:13:03.884 --> 00:13:06.286 
也需要遵循一些規則 這些
規則會告訴它們在某個指定

00:13:06.353 --> 00:13:08.589 
情景下 它們應該怎麼做 
稍後我們也會看看這個 

00:13:09.423 --> 00:13:12.125 
PlayerBot就不需要這些規則
你會告訴他他該怎麼做 

00:13:12.926 --> 00:13:16.029 
PlayerBot和GroundBot
確實有一件共同之處 

00:13:16.530 --> 00:13:18.599 
它們都有一個運動元件 

00:13:19.633 --> 00:13:21.869 
這個元件的作用就是說 
舉個例子 我在這裏 

00:13:22.402 --> 00:13:24.771 
我需要以某個角度 移動這個距離 

00:13:25.105 --> 00:13:26.707 
在場景中把我移過去吧 

00:13:27.274 --> 00:13:31.512 
PlayerBot會使用那個輸入
在場景中渲染它讓他四處運動 

00:13:32.379 --> 00:13:34.481 
而GroundBot則會用它
來進行衝鋒攻擊 

00:13:34.781 --> 00:13:37.150 
他從這裏開始移動 然後發起衝鋒 

00:13:37.951 --> 00:13:39.686 
FlyingBot
則不需要那項能力 

00:13:39.753 --> 00:13:42.623 
他不會移動 因此他沒有那個元件 

00:13:43.757 --> 00:13:46.627 
這些元件是對功能性進行分解

00:13:46.693 --> 00:13:49.630 
並且僅僅把它們分配給
需要它們的實體的好方法 

00:13:51.965 --> 00:13:56.170 
這些就是我們在遊戲中使用
GameplayKit功能性的一些方法 

00:13:56.904 --> 00:13:59.806 
我想邀請戴夫到臺上來 
再給你們講講我們是如何

00:13:59.873 --> 00:14:01.441 
使用GameplayKit
來創建我們的

00:14:01.508 --> 00:14:03.610 
遊戲 “邏輯與玩法” 

00:14:09.816 --> 00:14:14.154 
謝謝 戴夫 當我們想到玩法中的邏輯

00:14:14.321 --> 00:14:18.058 
當我想到玩法中的邏輯
那麼最先浮現在我的腦海中的

00:14:18.458 --> 00:14:20.928 
就是我的對手的實際智能

00:14:22.329 --> 00:14:25.799 
關於智能其中非常重要的一點

00:14:25.866 --> 00:14:30.904 
就是在那個空間內 我到底能做什麼？

00:14:31.872 --> 00:14:34.775 
就像我們之前在演示中
看到的 如果我是一個好Bot 

00:14:34.842 --> 00:14:37.945 
我會在關卡內四處走動沿着
線路巡邏維持秩序 

00:14:38.979 --> 00:14:42.115 
而如果我是一個壞的Bot 
我就想要攻擊PlayerBot 

00:14:44.318 --> 00:14:45.485 
這次逮到他了 

00:14:46.753 --> 00:14:50.991 
我可能也不會把其它TaskBots
變成壞的TaskBots 

00:14:51.625 --> 00:14:53.360 
因此當它逮到PlayerBot時
我也可以出點力

00:14:53.527 --> 00:14:54.361 
又逮到一個 

00:14:55.829 --> 00:15:01.935 
最後 我可能會在關卡內
以相反的方向四周走動 

00:15:02.002 --> 00:15:05.439 
幹擾線路上的感應 電流 引發問題 

00:15:06.940 --> 00:15:08.775 
這就不那麼有趣了

00:15:09.476 --> 00:15:13.847 
但是既然我們知道了我們能做什麼 
那麼問題就變成了我們怎樣

00:15:13.914 --> 00:15:16.750 
來決定我們應該做什麼 

00:15:17.818 --> 00:15:19.586 
DemoBots中 我們選擇使用

00:15:19.653 --> 00:15:24.825 
GKRuleSystem實現了一個
模糊邏輯系統 

00:15:25.526 --> 00:15:31.565 
它的優點在於 我們仍然可以接受
與關卡的當前狀態相關的大量信息 

00:15:32.032 --> 00:15:36.603 
發生了什麼事情並且讓我們的角色
對那個信息做出反應 

00:15:37.471 --> 00:15:40.741 
我們無需使用綿延數百行
代碼的if else樹

00:15:40.807 --> 00:15:42.943 
就可以實現這一點 

00:15:43.277 --> 00:15:47.414 
我們有一些簡單的規則 
我們也依賴這些簡單的規則

00:15:47.481 --> 00:15:51.185 
和他人進行互動允許
出現複雜有趣的行爲 

00:15:52.452 --> 00:15:57.491 
如果你不熟悉模糊邏輯 那麼我再給你

00:15:57.558 --> 00:15:59.726 
講一講我們在這裏談的是什麼 

00:16:00.260 --> 00:16:04.364 
我們提到的“模糊”
指的是這樣一個事實

00:16:04.431 --> 00:16:07.868 
所有的事情並不是非黑即白 非真即假

00:16:08.235 --> 00:16:10.337 
我們的規則並不是互相排斥的

00:16:12.706 --> 00:16:17.211 
我們的規則是以自然概念
爲模型的 你可以嘗試

00:16:17.277 --> 00:16:20.214 
把它們當做你會對一位同事說的句子

00:16:20.781 --> 00:16:22.549 
PlayerBot就類似這個...

00:16:23.917 --> 00:16:27.955 
...在模糊TaskBots
規則類中實現的就是這些 

00:16:29.289 --> 00:16:30.991 
它是GKRule的一個子類 

00:16:31.892 --> 00:16:37.164 
實際上 我們把規則事實
綁定到了這裏的等級上 

00:16:38.165 --> 00:16:41.268 
只有當等級大於零時 
我們纔會斷言事實 

00:16:42.870 --> 00:16:46.340 
這很有趣 因爲我們會對
那個等級中能夠獲得的信息的

00:16:46.406 --> 00:16:49.076 
實際狀態函數進行分級 

00:16:51.345 --> 00:16:53.914 
而不是某種當你在創建GKRule時

00:16:53.981 --> 00:16:55.349 
設置的東西 

00:16:56.450 --> 00:16:58.051 
看看這些

00:16:58.619 --> 00:17:04.358 
看看鄰近規則是什麼樣的 

00:17:04.758 --> 00:17:07.594 
它考慮的是遠近 

00:17:08.462 --> 00:17:11.531 
讓我們來實際通過一個圖表看看這個 

00:17:11.665 --> 00:17:13.267 
看看這些函數的工作原理

00:17:14.001 --> 00:17:17.436 
在上面的起點附近你可以看到
我們有一臺PlayerBot 

00:17:18.005 --> 00:17:21.208 
外面遠處 我們能夠到的地方 
我們還有一臺TaskBot 

00:17:21.808 --> 00:17:24.511 
如果我拿出一個遠處規則的圖解表示 

00:17:24.645 --> 00:17:29.783 
那麼看出遠處規則的分級
就是這個類的分級 

00:17:29.850 --> 00:17:31.952 
這就非常容易了

00:17:32.920 --> 00:17:35.489 
如果我把中等距離規則
以及近處規則拉進來 

00:17:35.989 --> 00:17:39.693 
那麼很明顯 它們在這種
情況下的分級就是零 

00:17:40.494 --> 00:17:43.630 
雖然這個陣式看起來不是那麼有趣 

00:17:43.797 --> 00:17:48.268 
它看起來也確實是某種程度的
非黑即白 非真即假 

00:17:49.236 --> 00:17:54.074 
如果我們把我們的TaskBot移近
一點 那麼你就可以更清楚地

00:17:54.208 --> 00:17:55.609 
看到我說的是什麼 

00:17:55.876 --> 00:17:57.778 
這是遠處規則的分級 

00:17:58.145 --> 00:18:01.849 
七十五 而中等距離規則大約是

00:18:02.216 --> 00:18:06.253 
二十五 如果我們繼續讓他靠近 
那麼事情就發生變化了 

00:18:07.354 --> 00:18:11.491 
就同時屬於鄰近規則中等距離規則了 

00:18:13.727 --> 00:18:16.029 
既然你已經看過了我們會計算

00:18:16.096 --> 00:18:18.699 
我們的分級的函數是什麼樣的 

00:18:19.967 --> 00:18:24.438 
那麼讓我們再來看看 一旦
我們爲我們的每一條規則

00:18:24.505 --> 00:18:27.274 
計算出來那些規則
我們又該怎樣做出決定

00:18:27.841 --> 00:18:30.878 
這是我們在
DemoBots上用的規則 

00:18:32.412 --> 00:18:34.815 
我們的第一步就像我說過的 

00:18:34.882 --> 00:18:36.984 
就是對它們進行評估計算值是什麼 

00:18:37.985 --> 00:18:41.922 
我們接下來要做的事情 
就是把它們中的幾個組合起來 

00:18:42.689 --> 00:18:47.127 
判定它們是否屬於當我們在
獵捕PlayerBot時

00:18:47.794 --> 00:18:50.964 
我們需要注意的影響因素 

00:18:51.665 --> 00:18:54.701 
它讀起來就像一個句子 
你也就可以看 它的工作原理

00:18:54.768 --> 00:18:56.570 
就類似講一個故事那樣 

00:18:57.504 --> 00:19:00.340 
如果壞的TaskBots的
百分比較高 

00:19:00.874 --> 00:19:03.377 
PlayerBot離它的
距離是一箇中等距離 

00:19:04.044 --> 00:19:07.614 
而好的TaskBot
離它的距離也是一箇中等距離 

00:19:09.750 --> 00:19:11.785 
那麼我會想要獵捕這個
PlayerBot 

00:19:12.586 --> 00:19:14.721 
在這個例子中我想這樣做的原因是

00:19:14.922 --> 00:19:18.792 
我的思維方式是 
如果這一關卡中已經有了很多

00:19:18.859 --> 00:19:22.162 
壞的TaskBots 
那麼我就不需要去改造它們 

00:19:22.462 --> 00:19:24.698 
此時我就可以獵捕玩家 

00:19:25.866 --> 00:19:30.304 
麻煩在於我有三個不同的等級

00:19:30.671 --> 00:19:33.707 
來表示現在獵捕
PlayerBot這個概念 

00:19:34.942 --> 00:19:39.880 
因此我們要使用GKRuleSystems 
來把事實的分級最小化 

00:19:40.347 --> 00:19:45.853 
要抓取我們想要組合的
每個事實的最小分級 

00:19:47.354 --> 00:19:52.993 
我們選擇最小分級的原因在於
我們獵捕PlayerBot的

00:19:53.393 --> 00:19:56.563 
指令所基於的信息強度僅僅

00:19:56.630 --> 00:19:59.600 
與起作用的最弱的事實一樣 

00:20:01.301 --> 00:20:06.807 
我們可以以任何方式
對這些規則進行組合

00:20:06.907 --> 00:20:10.878 
然後得到幾個不同的
指示符指示到底是應該

00:20:10.944 --> 00:20:13.780 
獵捕PlayerBot 
還是應該獵捕TaskBots 

00:20:14.815 --> 00:20:16.416 
在這個階段我們實際上

00:20:17.251 --> 00:20:22.890 
就需要規則清晰下來
得到一個能夠表示獵捕

00:20:23.290 --> 00:20:26.660 
PlayerBot這一理念的
簡單的數字 

00:20:28.161 --> 00:20:30.130 
在這個例子中我們把我們的事實取出來

00:20:30.831 --> 00:20:32.799 
使用Swift的歸約函數

00:20:33.567 --> 00:20:36.036 
以及最大函數來把事情組合到一起 

00:20:36.436 --> 00:20:40.407 
在這個例子中我們實際上
就需要獵捕PlayerBot

00:20:40.474 --> 00:20:42.709 
或者獵捕TaskBots
通過我們所有的

00:20:43.043 --> 00:20:46.480 
最強大的分級來表示 

00:20:47.181 --> 00:20:50.851 
看看這些數字很明顯 
我們應該獵捕PlayerBot 

00:20:53.153 --> 00:20:56.423 
既然我們知道了我們想要獵捕
PlayerBot那麼我們的第一個問題

00:21:02.196 --> 00:21:07.501 
就是我到底怎樣
才能接觸到PlayerBot？

00:21:08.202 --> 00:21:10.037 
一般來說這是非常直接的 

00:21:11.205 --> 00:21:14.141 
只需要直線移動 
然後你最終就會接觸到它 

00:21:16.376 --> 00:21:18.612 
但是障礙物是一個挑戰 

00:21:18.745 --> 00:21:22.115 
這裏你可以看到 
FlyingBot就懸掛在那裏 

00:21:22.716 --> 00:21:26.386 
你回憶起了幾年前的
一個示例“冒險” 

00:21:26.753 --> 00:21:31.024 
那個示例中的哥布林 
也非常喜歡錶現出這種行爲 

00:21:32.292 --> 00:21:34.461 
我們決定要採取一些行動

00:21:34.962 --> 00:21:38.699 
在GameplayKit中我們讓你
對某個場景中尋路的利用

00:21:39.099 --> 00:21:43.904 
變得非常容易了這樣
你就可以非常容易地

00:21:44.404 --> 00:21:47.140 
讓你的Bots或者你的敵人
像這樣進行移動 

00:21:47.774 --> 00:21:50.577 
當你把SpriteKit用在一款
遊戲上時配合其它事情

00:21:50.644 --> 00:21:54.381 
就非常方便了把事情設置好 運行起來

00:21:54.815 --> 00:21:56.283 
也就非常容易了 

00:21:56.950 --> 00:21:58.819 
只需要幾行代碼即可 

00:21:59.019 --> 00:22:01.522 
我們來看看這些代碼是什麼樣的 

00:22:04.491 --> 00:22:07.394 
你要做的第一件事實際上

00:22:08.061 --> 00:22:11.798 
就是獲得組成關卡的多邊形障礙物

00:22:12.099 --> 00:22:18.272 
在我們的例子中 我們首先
要在場景中搜索我們的節點 

00:22:18.505 --> 00:22:20.073 
它們都被命名爲障礙物 

00:22:20.174 --> 00:22:23.243 
當我們有了一個那些節點的
陣列後 我們就把它傳遞到

00:22:23.443 --> 00:22:27.347 
SKNodes在iOS 9上
的一個便利函數 

00:22:27.781 --> 00:22:29.516 
節點物理實體障礙物 

00:22:30.417 --> 00:22:34.755 
拿出你定義使用的實際物理實體 

00:22:34.821 --> 00:22:37.157 
對障礙物進行定義 

00:22:38.091 --> 00:22:40.561 
有了這些障礙物當我們有了這些障礙物

00:22:41.495 --> 00:22:45.399 
我們就要用它們來構造一個障礙物圖表

00:22:45.866 --> 00:22:48.001 
並且構造一個緩衝區半徑參數

00:22:48.602 --> 00:22:52.940 
這個參數就是圍繞實際障礙物的

00:22:53.307 --> 00:22:55.175 
一些附加空格

00:22:55.876 --> 00:22:58.278 
要想理解這一點你可以想想

00:22:58.879 --> 00:23:01.715 
當你朝着一個門口走去當你穿過門口

00:23:01.849 --> 00:23:06.687 
你並沒有真的走到門框的某個角落

00:23:07.221 --> 00:23:10.157 
你要瞄準的是門口中間的某個點

00:23:10.424 --> 00:23:14.061 
當你穿過門口的時候你的身體的
任何部位並不會真的接觸到門

00:23:14.728 --> 00:23:19.032 
半徑可以幫助設置圍繞障礙物的空格 

00:23:20.267 --> 00:23:26.173 
接下來我們要取出TaskBot
和PlayerBot的位置 

00:23:26.673 --> 00:23:28.408 
然後把它們連接到圖表上 

00:23:29.510 --> 00:23:35.148 
最後我們會讓圖表
給我們一條從起始節點

00:23:35.883 --> 00:23:37.484 
終端節點的路徑 

00:23:38.118 --> 00:23:40.888 
我們得到的就是單獨的節點的陣列 

00:23:41.321 --> 00:23:44.658 
而這些節點對於從A點
到B點來說是必須的 

00:23:45.392 --> 00:23:49.329 
把事情從走路轉變成存儲器片 

00:23:49.396 --> 00:23:52.432 
同時實際跟着它們走動就是這麼簡單

00:23:53.767 --> 00:23:57.704 
我們有了一條路徑有了點 

00:23:58.071 --> 00:23:59.806 
但是我怎樣才能真的去到那裏？

00:24:00.274 --> 00:24:03.110 
我怎樣才能真的優雅地去到那裏？

00:24:04.077 --> 00:24:07.981 
GameplayKit再一次給我們
提供了一個答覆 

00:24:08.549 --> 00:24:11.385 
這次是GKAgent 2D 

00:24:12.019 --> 00:24:15.689 
這個類是我最喜歡的
GameplayKit類之一 

00:24:16.690 --> 00:24:20.027 
這是一個GKComponent 
它和戴夫之前談到的實體/元件

00:24:20.093 --> 00:24:22.829 
系統配合的天衣無縫 

00:24:24.731 --> 00:24:27.401 
把事情設置好非常簡單

00:24:28.268 --> 00:24:32.206 
你有一個GKBehavior 
它描述了你想要這個代理去做的事情 

00:24:32.506 --> 00:24:35.175 
它就好比是GKGoals的一個容器

00:24:35.976 --> 00:24:40.714 
GKGoal 我們很幸運 
這個例子中實際上就有幾個

00:24:40.781 --> 00:24:46.553 
不同的構造這些構造允許我們兼容路徑

00:24:47.020 --> 00:24:49.289 
因爲代理的世界
GameplayKit的世界

00:24:49.356 --> 00:24:51.525 
不同於SpriteKit的世界 

00:24:52.526 --> 00:24:55.762 
這裏的委託就使得
把它們兩個集成到一起

00:24:56.029 --> 00:24:57.164 
非常容易 

00:24:59.199 --> 00:25:03.203 
我們來看看 實際上...
你懂得看看代碼實際是什麼樣的 

00:25:04.271 --> 00:25:07.641 
我們把我們之前獲得的
路徑節點陣列拿出來 

00:25:10.944 --> 00:25:13.180 
我們要對它們進行初始化 

00:25:15.115 --> 00:25:19.286 
我們要把它傳遞到一個初始化
程序來創建我們的路徑

00:25:19.853 --> 00:25:22.723 
這裏還有一個參數它就是半徑 

00:25:22.789 --> 00:25:28.562 
我想讓你們在這裏思考下
你想讓這個路徑怎樣爲你的代理下定義

00:25:28.896 --> 00:25:33.367 
太小的值會讓你的代理把你的
路徑當成類似一根繃緊的繩索來對待 

00:25:34.101 --> 00:25:37.938 
而較大的值 你懂得 
就會讓它們把它當成類似一條

00:25:38.005 --> 00:25:40.774 
八車道高速公路來對待 
把它們都移動到這個地方 

00:25:41.275 --> 00:25:44.411 
你可能想要調整下看看
哪種最適合你的遊戲

00:25:46.380 --> 00:25:47.981 
接下來我們要創建一個行爲 

00:25:48.549 --> 00:25:51.485 
這只是一個空的行爲 
並沒有真的發生什麼事情 

00:25:52.452 --> 00:25:54.888 
然後我們向它添加目標 

00:25:55.822 --> 00:25:59.092 
這些是兩個路徑相關的目標
我之前已經談到過了 

00:25:59.726 --> 00:26:04.064 
屏幕上的第一個目標 
我們跟隨路徑的目標將會

00:26:05.232 --> 00:26:09.136 
確立我們移動我們的陣列的方向 

00:26:09.536 --> 00:26:11.572 
在這個例子中我們會從起始位置

00:26:11.738 --> 00:26:15.475 
向前移動 把我們的
TaskBots移動到終點位置 

00:26:15.542 --> 00:26:17.344 
也就是我們的
PlayerBot的位置 

00:26:18.111 --> 00:26:23.650 
停留在路徑上這個目標
會促使我們的代理

00:26:23.984 --> 00:26:30.624 
保持在我們之前定義的路徑的邊界內 

00:26:32.326 --> 00:26:37.464 
既然我們有了一個工作行爲我們把它
指定給我們的代理讓它開始移動 

00:26:39.733 --> 00:26:42.769 
代理工作的方式

00:26:43.470 --> 00:26:46.707 
和GameplayKit上
許多其他元件的工作方式類似 

00:26:47.207 --> 00:26:48.809 
它會在一個循環上進行更新 

00:26:49.409 --> 00:26:52.179 
當你把它添加進你的更新循環時

00:26:53.280 --> 00:26:57.751 
它就會在變更前後通知到你 

00:26:57.818 --> 00:27:00.888 
這個變更前後的委託通知
就是讓事情運行起來

00:27:01.321 --> 00:27:05.559 
同SpriteKit
連接起來的理想場所

00:27:06.894 --> 00:27:12.833 
在WillUpdate中這個位置就是
你想從你的SpriteKit節點中

00:27:14.334 --> 00:27:17.571 
取出信息的位置

00:27:17.738 --> 00:27:20.040 
這些節點表示場景中你的代理

00:27:20.874 --> 00:27:24.311 
把那個信息撤回並且更新代理 

00:27:25.279 --> 00:27:27.548 
因爲我們是在
SpriteKit更新循環前面

00:27:28.215 --> 00:27:31.552 
這樣做的 
最後一個SpriteKit更新循環

00:27:31.919 --> 00:27:34.755 
就會涉及到

00:27:35.022 --> 00:27:38.625 
對物理現象進行模擬
對你的節點應用約束

00:27:38.859 --> 00:27:41.028 
這就可能導致它的位置
從代理最後一次思考時

00:27:41.094 --> 00:27:44.064 
代理本以爲它在的位置上移開 

00:27:46.466 --> 00:27:50.304 
在AgentDidUpdate中
我們會把信息從代理那裏拿出來 

00:27:51.305 --> 00:27:54.141 
它的位置它的旋轉類似此類的事情 

00:27:55.008 --> 00:27:57.911 
然後把它們撤回
SpriteKit世界 

00:27:57.978 --> 00:28:01.949 
並且在它此時進入
物理現象模擬 約束應用

00:28:02.349 --> 00:28:04.918 
之前對你的節點進行更新 

00:28:07.221 --> 00:28:11.558 
此時我們用DemoBots

00:28:12.292 --> 00:28:14.394 
得到的就是這個 

00:28:15.229 --> 00:28:18.232 
一個工作乾的漂亮
輕而易舉就可以圍繞屏幕進行移動

00:28:18.298 --> 00:28:21.568 
同你的交互非常平滑的智能 

00:28:22.469 --> 00:28:27.241 
我猜這是附加的東西
我們把調製繪圖放到

00:28:27.941 --> 00:28:30.210 
示例中了你可以去下載 

00:28:31.211 --> 00:28:33.947 
你可以通過點擊斜線鍵來啓用它 

00:28:35.816 --> 00:28:38.418 
關於這個很棒的一件事是 
它可以幫助你想象出

00:28:38.485 --> 00:28:40.053 
我們之前談到的一些參數 

00:28:40.420 --> 00:28:44.892 
黃色框是圍繞障礙物的緩衝區半徑 

00:28:46.393 --> 00:28:51.698 
你可以看到玩家放射出粗線

00:28:51.765 --> 00:28:54.735 
TaskBots表示的是

00:28:55.235 --> 00:28:59.973 
我們之前談到的路徑那裏的路徑半徑 

00:29:01.375 --> 00:29:02.943 
既然我們有了一款遊戲 

00:29:03.944 --> 00:29:07.047 
我想邀請我的同事邁克爾上臺來 

00:29:07.414 --> 00:29:12.452 
他會和你們討論一下怎樣才能讓
你的用戶以更快的運行速度玩你的遊戲

00:29:13.086 --> 00:29:13.921 
邁克爾 

00:29:19.359 --> 00:29:23.864 
謝謝 我們來談談
怎麼製作一個有趣的遊戲 

00:29:23.931 --> 00:29:27.301 
怎樣給你的用戶提供一個
很棒的整體體驗 

00:29:27.367 --> 00:29:31.638 
我會把它濃縮成一個短語 也就是 
當然就是找樂子時間到了 

00:29:31.705 --> 00:29:33.841 
你的用戶需要多久才能真正開始

00:29:33.907 --> 00:29:35.442 
享受你的遊戲？

00:29:36.376 --> 00:29:39.580 
第一個要邁過的障礙 
實際上就是初始下載 

00:29:40.013 --> 00:29:43.951 
如果你提供的app太大了 
有些用戶就不能通過

00:29:44.017 --> 00:29:45.752 
蜂窩網數據來下載它 

00:29:46.086 --> 00:29:47.988 
即使通過Wi-Fi下載 
可能也需要好一陣 

00:29:48.989 --> 00:29:50.624 
你的用戶在App Store中找到

00:29:50.924 --> 00:29:56.597 
app以及決定下載這個app之間
最大的潛在因素就是這個 

00:29:57.531 --> 00:30:01.368 
但是我們知道對於遊戲來說 
很難保持在這個一百萬下載限制以內 

00:30:01.702 --> 00:30:05.472 
我們再回到DemoBots看看
我們是如何處理這個問題的

00:30:06.440 --> 00:30:09.243 
如果你仔細看PlayerBot 
你就會注意到 我們並不是絕對

00:30:09.309 --> 00:30:10.777 
自上而下地看這個角色的 

00:30:11.378 --> 00:30:14.281 
這不是一個帶有等距感覺的2D遊戲

00:30:14.948 --> 00:30:18.852 
我們是通過賦予這個
角色多個朝向而實現的 

00:30:19.753 --> 00:30:22.456 
當你讓這個角色在地圖上四處走動時 

00:30:22.789 --> 00:30:25.492 
我們就會換出代表這個角色的紋理

00:30:25.726 --> 00:30:27.427 
得到這個透視圖 

00:30:28.328 --> 00:30:32.432 
當你在那裏添加各個附加幀的
時候 它們會佔據空間 

00:30:32.499 --> 00:30:34.968 
它只有六兆字節 
對於一個遊戲來說不大 

00:30:35.035 --> 00:30:38.105 
當你認爲它是六兆字節的
時候 要乘以三個bots 

00:30:38.172 --> 00:30:41.575 
我們還要乘以它們可以執行的不同動作

00:30:41.875 --> 00:30:45.412 
當PlayerBot閒置 攻擊
四處走動時我們還需要定向幀

00:30:45.479 --> 00:30:49.249 
因此這個數字就開始積少成多了 

00:30:50.450 --> 00:30:54.221 
從傳統意義上來說 
這就意味着所有的資產再加上

00:30:54.288 --> 00:30:56.823 
各自的1X 2X 3X版本 
都打包進了app 

00:30:58.392 --> 00:31:00.294 
現在我們對此有了一個更好的解決方法

00:31:00.694 --> 00:31:02.229 
本週早些時候你可以已經聽說過了

00:31:02.729 --> 00:31:06.366 
如果你用的是資產目錄的話 
你可以利用一項叫做

00:31:06.433 --> 00:31:07.901 
“app分割”的新的特性 

00:31:08.402 --> 00:31:12.906 
“app分割”所做的 
就是爲資產實際運行的設備

00:31:14.408 --> 00:31:16.476 
1X、2X、3X分類 

00:31:17.211 --> 00:31:19.880 
只要使用資產目錄讓App
Store爲你分割你的app 

00:31:20.247 --> 00:31:23.550 
就可以節省我們大量的空間

00:31:24.284 --> 00:31:26.620 
它不僅僅意味着我們現在可以
節省大量的空間

00:31:26.687 --> 00:31:29.423 
它還意味着我們可以用我們的app內
多餘的存儲空間來幹什麼 

00:31:29.489 --> 00:31:31.124 
我現在看到的是圖表這是個空的圖表 

00:31:31.892 --> 00:31:34.962 
在DemoBots中
這是有實踐含義的

00:31:36.597 --> 00:31:41.134 
我們一開始有八個朝向 
我在這裏給你們看一個視頻仔細看 

00:31:41.201 --> 00:31:44.137 
看起來PlayerBot
是面朝正前方的 

00:31:44.738 --> 00:31:47.574 
你會注意到 仔細看這個動作 
看看你能不能注意到什麼事情 

00:31:58.785 --> 00:32:01.488 
具體來說 就是當角色朝着
地圖頂部那裏向後移動時 

00:32:01.555 --> 00:32:04.658 
我們把那個動作叫做“滑冰” 

00:32:05.025 --> 00:32:08.862 
雖然我們只有八個朝向
來表示角色的運動 

00:32:09.029 --> 00:32:13.233 
玩家提供的卻是三百六十度的
輸入我們可以稍微傾斜下

00:32:13.300 --> 00:32:16.503 
那個朝向 但並不觸發下一個朝向 

00:32:16.803 --> 00:32:19.139 
然後你就得到了這個轟炸行爲 

00:32:19.973 --> 00:32:22.876 
使用八個朝向更令人沮喪的是 

00:32:23.410 --> 00:32:27.181 
你可能最後會出現類似這樣的情況 

00:32:27.347 --> 00:32:29.483 
PlayerBot
面朝正前方 看起來它應該

00:32:29.716 --> 00:32:33.086 
很容易就可以攻擊到那個
TaskBot實際上並沒有攻擊到 

00:32:33.153 --> 00:32:36.456 
因爲調試繪製你可以
看到玩家瞄準的是側面

00:32:36.523 --> 00:32:39.560 
但是玩家卻無法看到這個 

00:32:40.227 --> 00:32:43.730 
有了我們通過“app分割”獲得的
多餘的空間 我們就可以增加一個缺口

00:32:44.198 --> 00:32:45.999 
我們增加到十六個朝向 

00:32:46.500 --> 00:32:49.603 
這樣遊戲內的運動就感覺更平滑了 

00:32:50.871 --> 00:32:54.541 
你可以看到我們在這裏有了
更多的動畫幀來進行表示 

00:32:56.810 --> 00:33:00.180 
然後當進行瞄準時粒度就更多了 

00:33:00.380 --> 00:33:02.683 
角色朝向的位置基本上精確對應到了

00:33:02.749 --> 00:33:05.319 
射線將要集中的方向 

00:33:06.119 --> 00:33:10.991 
你在那裏點擊下用戶就可以
更容易地知道遊戲內的情況了

00:33:12.726 --> 00:33:15.462 
“app分割” 我們可以在
DemoBots中簡單地通過

00:33:15.529 --> 00:33:18.232 
把我們的紋理地圖冊
放進資產目錄中來實現

00:33:18.632 --> 00:33:21.568 
它可以幫助我們大幅度降低
app的整體大小 

00:33:22.102 --> 00:33:26.373 
不僅如此 我們現在還可以實際提高
可玩性這是因爲我們有了多餘空間

00:33:27.307 --> 00:33:30.777 
這項特性和你在遊戲中時刻需要的資產

00:33:30.844 --> 00:33:32.012 
配合的非常默契 

00:33:32.446 --> 00:33:36.149 
除非我們有PlayerBot 
否則DemoBots就不太像一個遊戲了 

00:33:36.683 --> 00:33:40.420 
但是還有一些其他資產這些資產並
不是我們時刻都必須用到的 

00:33:40.521 --> 00:33:42.556 
針對這點 我們還有一項技術 

00:33:42.623 --> 00:33:45.759 
你本週早些時候在“點播資源”
那裏可能已經聽說過了 

00:33:46.159 --> 00:33:49.229 
簡單描述下 
你可以通過一個簡單的字符串 

00:33:49.296 --> 00:33:51.532 
對你的資源進行標記標記爲稍後再下載

00:33:52.232 --> 00:33:54.501 
我來談談我們是怎樣在
DemoBots上把這個用起來的 

00:33:54.568 --> 00:33:56.236 
第一個地方就是可能已經很明顯了 

00:33:56.303 --> 00:34:00.707 
我們有多個關卡我們可以把這些標記爲
關卡一 關卡二 關卡三 

00:34:02.376 --> 00:34:05.312 
好處在於 我們現在已經用
輸出數據寄存器把這些標記出來了

00:34:05.679 --> 00:34:09.917 
我們就可以說如果用戶初始下載遊戲 
我們知道他們回到關卡一 

00:34:09.983 --> 00:34:13.587 
我們就沒有理由把另外
兩個關卡也包括到那裏去 

00:34:14.821 --> 00:34:18.158 
隨着遊戲進展事情就更有趣了 

00:34:18.692 --> 00:34:21.728 
因爲我們可以用這個線性流進行預測 

00:34:21.795 --> 00:34:24.063 
用戶將會繼續到達關卡三 

00:34:24.431 --> 00:34:30.103 
我們就能提前下載那個關卡 
用戶不大可能會重玩關卡一 

00:34:30.469 --> 00:34:32.539 
因此我們就可以回收一些資源 

00:34:34.574 --> 00:34:35.842 
我們來再進一步 

00:34:36.310 --> 00:34:40.147 
如果我們仔細看關卡二你會在這個演示

00:34:40.214 --> 00:34:42.349 
這個小照片上注意到 

00:34:42.416 --> 00:34:44.751 
FlyingBot只會出現在
這個關卡中 

00:34:45.185 --> 00:34:46.553 
然後在關卡三中又出現了 

00:34:47.286 --> 00:34:51.425 
把它和出現在關卡一以及
關卡三中的GroundBot相對照

00:34:52.726 --> 00:34:57.631 
但我們單獨標記角色時 
我們就可以對我們的資源做進一步分類

00:34:57.764 --> 00:34:59.700 
如果我們知道用戶是第一次下載app

00:34:59.766 --> 00:35:02.803 
我們就只把GroundBot弄到
關卡一中 我們可以稍後再

00:35:03.003 --> 00:35:04.872 
把FlyingBot弄過去 

00:35:05.606 --> 00:35:07.541 
如果你允許的某臺
設備存儲空間不太富餘

00:35:07.608 --> 00:35:10.777 
那麼當用戶正在玩第二關的
時候你就可以洗淨GroundBot

00:35:11.111 --> 00:35:13.180 
然後把它們都弄回關卡三 

00:35:14.047 --> 00:35:16.116 
你可以看到我們是怎樣在
“項目導航器”中的

00:35:16.450 --> 00:35:19.453 
資源標籤下佈置標籤的 

00:35:20.287 --> 00:35:22.956 
你可以看到關卡一的資產
被標記爲了“預取” 

00:35:23.023 --> 00:35:25.692 
這些資產是app安裝完畢之後
很短一段時間內取得的 

00:35:25.759 --> 00:35:28.495 
但是這些資產並沒有包括在安裝包中 

00:35:28.562 --> 00:35:31.798 
而其他的資源就可以被標記爲

00:35:31.865 --> 00:35:33.367 
當我們需要時再下載 

00:35:34.635 --> 00:35:36.603 
這就是點播資源 

00:35:36.837 --> 00:35:40.641 
我們把它用在DemoBots 
用來標記稍後下載的資源 

00:35:40.741 --> 00:35:43.076 
這樣我們的初始下載速度就更快了 

00:35:43.143 --> 00:35:45.612 
我們可以把我們不是
立即需要的很多東西刪去 

00:35:46.246 --> 00:35:49.082 
總的來說 它也有助於我們
保持一個小的存儲覆蓋區 

00:35:49.349 --> 00:35:54.521 
這就是傳達的更重要信息你可以製作
一個更豐富的遊戲可以有更多的資產

00:35:54.855 --> 00:35:57.291 
因爲你可以通過點播訪問
所有其它的東西

00:35:57.491 --> 00:35:59.660 
你就仍然可以在設備上
保持同樣的覆蓋區

00:36:01.028 --> 00:36:04.198 
我們認爲這確實會增加複雜性 

00:36:04.998 --> 00:36:08.669 
當你提到顯示下一個場景時 
從傳統意義上來說 

00:36:08.969 --> 00:36:12.306 
你知道它們位於本地存儲器內 
你就可以準備這些資源 

00:36:12.372 --> 00:36:14.308 
然後當用戶請求資源時 
向他們展示這些資源 

00:36:15.342 --> 00:36:17.144 
現在我們增加了一項額外的複雜狀態 

00:36:17.211 --> 00:36:19.780 
你可能需要下載這些資源

00:36:20.113 --> 00:36:23.450 
當然如果網絡連接不佳下載就可能失敗

00:36:24.551 --> 00:36:26.486 
如果你想要節省空間那麼在某個時間點

00:36:26.787 --> 00:36:28.388 
你就需要清除這些資源把它們沖洗掉 

00:36:28.989 --> 00:36:30.691 
然後重複整個週期 

00:36:32.159 --> 00:36:35.128 
這可能會比較複雜 
我想看看我們在DemoBots中

00:36:35.195 --> 00:36:36.730 
是怎麼解決這個問題的 

00:36:37.164 --> 00:36:39.867 
具體來說 這就回到了
戴夫在會議開始提到的一項

00:36:39.933 --> 00:36:42.169 
技術即GKStateMachine

00:36:43.270 --> 00:36:46.907 
如果我們把它用到這樣的模型上 
我們就把它成爲我們的SceneLoader 

00:36:46.974 --> 00:36:48.842 
它有六個相關的狀態 

00:36:49.510 --> 00:36:51.178 
你會注意到 只有兩類狀態 

00:36:51.245 --> 00:36:53.447 
正在下載資源狀態以及下載失敗狀態 

00:36:53.514 --> 00:36:55.115 
實際上 它們都與輸出數據寄存器相關

00:36:55.215 --> 00:36:58.118 
因爲對於模型來說這完全是一個流水線

00:36:58.185 --> 00:37:00.387 
把你的資源送到內存 
無論是來自本地存儲 

00:37:00.654 --> 00:37:01.955 
還是需要首先下載 

00:37:02.923 --> 00:37:08.428 
使用狀態機 我們真正能夠獲得的
優勢在於我們怎樣對狀態變遷進行模仿

00:37:08.662 --> 00:37:14.601 
如果我們仔細看正在準備
資源狀態我們就可以通過在我們的

00:37:14.668 --> 00:37:18.238 
GKState子類中覆寫
IsValidNextState決定什麼

00:37:18.305 --> 00:37:20.307 
是有效的下一個狀態 

00:37:21.275 --> 00:37:24.244 
我們可以說如果場景確實
加載過了 那麼狀態機

00:37:24.311 --> 00:37:27.414 
只會轉移到準備狀態 

00:37:28.282 --> 00:37:30.284 
或者說 如果用戶取消這個請求的話 

00:37:30.350 --> 00:37:31.885 
我們就可以移回到可用的狀態 

00:37:32.352 --> 00:37:34.488 
當試圖準備我們的資源時我們不會回到

00:37:34.555 --> 00:37:37.658 
下載狀態因爲我們可以在
IsValidNextState中

00:37:37.724 --> 00:37:41.094 
決定它這樣就會導致更多的
確定性的行爲 

00:37:42.729 --> 00:37:44.264 
好了 總結一下 

00:37:44.698 --> 00:37:48.302 
最後我再和你們分享下我們
在開發它時學到的一些竅門 

00:37:48.869 --> 00:37:51.171 
第一如果你用的是點播資源 

00:37:51.238 --> 00:37:53.307 
提前提出下載請求 

00:37:53.640 --> 00:37:56.410 
如果你在遊戲中有一個可預測的進展 

00:37:56.610 --> 00:37:58.445 
你就可以在玩家一開始玩關卡一就開始

00:37:58.512 --> 00:38:01.048 
下載關卡二 

00:38:02.516 --> 00:38:06.186 
不要忘記Xcode內用於
輸出數據寄存器的工具 

00:38:06.520 --> 00:38:09.790 
你可以看一下磁盤報告工具 
尤其是看看點播資源

00:38:09.857 --> 00:38:11.291 
下面那裏看看你的標籤是否已經

00:38:11.358 --> 00:38:14.094 
被下載了還是當前正在使用中 

00:38:14.161 --> 00:38:17.097 
亦或是已經被清理掉了這真的很有用 

00:38:18.899 --> 00:38:21.869 
此外如果玩家到了一個接合點 

00:38:22.402 --> 00:38:24.404 
他們需要額外的資源 

00:38:24.471 --> 00:38:26.540 
但是你尚未下載這些資源 
尚未準備好這些資源 

00:38:26.607 --> 00:38:28.575 
你就可以修改你的請求的優先級 

00:38:29.443 --> 00:38:31.512 
這就意味着你可以在
打包資源請求上提升

00:38:31.578 --> 00:38:35.349 
載入的優先級它的比例是從零到一 

00:38:35.415 --> 00:38:38.352 
如果用戶被阻塞了 而你又
試圖進行下載的話 這裏甚至

00:38:38.418 --> 00:38:39.653 
還有一個供急用的常數 

00:38:40.254 --> 00:38:45.325 
我們使用一個NSOperation隊列來模仿
準備的你可以在那裏提升服務質量

00:38:48.362 --> 00:38:51.899 
總的來說 我們在DemoBots上
想做的事情很多 

00:38:51.965 --> 00:38:57.304 
我們十分希望提供一個示例 
向你們展示開發遊戲的各種不同的方面

00:38:57.504 --> 00:38:59.039 
我們認爲你們都會對這個感興趣的 

00:38:59.540 --> 00:39:02.943 
戴夫一開始就說過了要針對每種設備

00:39:03.010 --> 00:39:05.412 
對你的資產進行微調 
也包括針對Mac的特殊資產 

00:39:06.446 --> 00:39:08.582 
我們也講過了優雅的角色導航 

00:39:08.649 --> 00:39:10.784 
而無需由你自己寫一大堆的運動代碼 

00:39:11.385 --> 00:39:14.922 
最後 添加額外的資產來提高可玩性 

00:39:14.988 --> 00:39:17.024 
因爲我們現在對我們的
app進行了切割 

00:39:17.691 --> 00:39:21.161 
我萬分激動地告訴大家 
GamePlayKit有一堆很棒的特性 

00:39:21.228 --> 00:39:23.630 
總的來說
iOS 9會幫助你實現這些事情 

00:39:24.531 --> 00:39:25.699 
如果你想看看怎麼用它們 

00:39:26.033 --> 00:39:29.870 
你可以通過這個鏈接來下載這個示例 

00:39:30.037 --> 00:39:31.338 
我鼓勵你們這麼做 

00:39:32.673 --> 00:39:35.676 
這裏還有一些額外的資料鏈接 

00:39:35.742 --> 00:39:37.477 
你也可以聯繫我們的福音傳道者艾倫 

00:39:39.179 --> 00:39:42.015 
相關的會議 我們在本次會議中
已經提到過了 

00:39:42.082 --> 00:39:44.852 
它們已經結束了你可以在線觀看視頻 

00:39:46.887 --> 00:39:47.721 
謝謝 