欢迎参加《Swift最新内容》讲座
我是克里斯·拉特纳我来主讲前半部分
我的同事约翰·迈克考尔则会在下半部分介绍最新内容
在开始之前我觉得先来看看
我们想做什么这很有趣也许会有帮助
Swift 2的目标是什么以及它背后的思想是什么？
我们主要追求三个目标
首先 基础架构 
我们希望Swift语言的核心功能和核心行为以及工具都非常出色
许多内容都需要很多在座的朋友
在使用Swift过程中产生的反馈
其中很多都是...
我非常感谢大家所提供的所有反馈
大家通过实际使用产生的出色反馈
才使得Swift得以不断完善
第二 是安全
安全性是Swift的核心价值
我们的确希望能很容易地编写安全代码
我们觉得错误处理结构的新可用性
将成为实现这一目的的杰出方式
第三是 美观
我们希望代码可以非常美观
作为编程人员 我们整天都在和代码打交道
这一点对我们非常重要
我们在Swift中的新增内容使其更容易写出自然美观的代码
今天我们介绍Swift的五项新内容
在我们详细介绍Swift 2最新内容之前
我认为有必要说明
Swift 1.2已经实现了长足进步
它不过是在三个月前发布
由于时间所限我们没办法详细介绍这个版本
但是如果你感兴趣而且还没有看到过
可以看看Swift编程语言书籍和Xcode 6版本发布说明
我们来详细介绍基础架构部分
基础架构是关于改进Swift语言的核心行为以及它该如何通力配合
这里有许多小细节
这感觉像是在漫无目的地漫步但是要跟上思路
我们先从枚举讲起
枚举是Swift最好的功能之一
这里我用枚举来列举一些常见的家养宠物
枚举的出色在于它们很容易定义和使用
另一方面如果你已将它们用于游乐场或打印出来
你可能就会想要更多
在Swift 2枚举可以携带足够的可以打印的反射信息且效果非常好
接下来相关值
枚举的出色还在于它们是差别联合类型的理想模型
当有两种不同类型的值
需要在同一内容中进行保存时这就会非常有用
对吗？
相关值非常强大
也许你会用任何一个类型编写明显的内容
这是用来做模型的理想方法
但是当你使用时会有些不快之处
这就太糟糕了大家都不希望是这样
有了Swift 2这就不成问题
我们再看看递归
Swift中的枚举就是代数数据类型
在其他语言中递归代数数据类型非常强大
可以做出相当棒的事情
问题在Swift中这些值在枚举中都是内联保存
这意味着如果是递归枚举
它将会无限令当前的设备很难承受
也许在明年会有这方面的变通方案
大家可能都见过箱型可以以此作为参考
但是要打破模式匹配就会很难看 很可怕
在Swift 2中有更好的方法
在beta 1中还不太好
不过很快你就可以间接标识自己的情况
可以自然地进行表达模式匹配效果也很棒
我们来继续介绍范围
有些时候你想重复使用某个名称
也许是想确定某个之前发布的资源
我们引入了可以介绍显性范围的新Do语句
在本例中 我们只想时不时和网络挑衅打交道
但是我们需要紧紧地约束它们
在讲座稍后 我们介绍错误处理部分时Do语句就会非常重要
但是把Do作为关键字会导致一些潜在歧义
这种歧义不是针对编译器而是在我们读码时会有歧义
你不会常常看太长的语句底部
我们还有Do While循环
通过语句的字符集了解它在做什么
我们需要让它变得非常简单
通过看语句的字符集关键字就一目了然
所以我们把Do While循环更名为Repeat
一看到顶部你就可以知道这是个循环
这样就非常简单
我们再看看选项集合
选项集合是轻量级超级高效的方法来表现一组布林值
如果你们以前见过并用过不同的Cocoa API
并且用过See Like句法和Or句法
这类基本句法实际上非常不错
问题在于当你使用其他句法时就不会是这样
你用零值生成选项集合...
这不太合理
因为选项集合和可选类型是完全不同的概念结果却混为一谈
你从按位操作将之提取出来
这样非常麻烦而且非常容易出错你也会很容易犯错
有了Swift 2我们会采用选项集合
这样会更糟糕
因为Swift1.2 是 一类集合类型
上述组合使得选项集合似乎退回到C语言
而事实就是如此
但是Swift 2解决了这个问题它将选项集合变得像集合
这就是说选项集合和集合现在都是带方括号
也就是说你会获得带方括号空集的空集
你也会得到整套标准集合API来与选项集合相配合
这样做非常容易而且效果极佳
还有一个好处是
你可以用更简单的方式定义自己的选项集合
你现在只需要定义自己的集合类型
或结构类型集合的结构类型
以符合新的选项集合类型协议
找到存放位数的存储
定义需要放入选项集合中的元素
只需要简单进行定义你就可以获得我们谈到的所有句法
这就是相当棒的一点它不需要进行任何编译器匹配
这可以通过一个新功能
名为Default Implementations
和选项集合类型提供的Protocols自动实现
我们实在没时间在这里详细介绍
Default Implementations和Protocols
但是我们有一场相当棒的讲座详细介绍协议方面的内容
我们来谈谈函数和方法
Swift将函数和方法统到单一的函数声明中
将两个完全不同的概念放在类型系统中构成一个漂亮的函数核
这样做非常棒
这个漂亮的函数核就是Swift的关键部分
在你想要调用这些内容时就会立刻分解
因为它们用的是不同的参数标签
这对很多人来讲都相当麻烦
如果我们来看这是从何而来
可以看出Swift是效仿Objective-C的先例
C语言并无参数标签
参数标签对Objective-C的方法而言非常重要
Swift也是如此
在Swift 2中我们不仅解决了个问题
现在函数和方法是同样的声明句法
它们按照同样的方式发生作用
当你调用全局函数时你在默认状态下提供参数标签
所有内容都是统一的
因此需要了解的关键内容是这会影响到纯粹的Swift代码
如果声明Swift中的全局函数你就会在默认状态获得这个行为
从C语言引入的函数会继续按照它们一贯的方法行为
因为在C语言函数中的参数名称不是API的组成部分
也不会被当做是API
但是我们希望Swift代码可以继续将函数标签包括在参数中
如果要想要深入了解这里还有更多内容
Swift函数使用参数
参数为每个值有不同名称
当你用句法声明某项内容时
你会获得默认行为
参数获得的两个名称一个是调用者看到的外部名称
一个是执行方看到的内部名称
在默认状态下第一个的参数并未向其外部客户端显示标签名称
你可能会在执行方法时用到
同样 第二个和之后的参数都是默认为内外相同
这就是为何你会看到有该参数的参数标签
这种模型最棒的一点是当你理解这点就可以对之进行自定义
例如 在本例中可以将标签
放在第一个参数上这样你会知道它是什么
只要重复参数名称即可实现
这非常简单
同样 如果想要删除某些内容
你可以用下划线显性设置该名称表明要删除参数标签
这么做我们就犯下了最严重的命名错误
让布林值没有标签
好的!
更好的一点是
发生的整个改变会令标签在系统中更为显著
让API如此便于使用
而且这会让我们将复杂简化很多
现在函数和方法都在同样发挥作用
我们还可以取消默认函数的特殊规定
这里还有非常奇怪的句法
谁也不记得它是什么现在也不见了
这样就会好得多
我们接着会谈到编译器
谈到警告和错误消息是编译器而成的
这里的代码是合理代码
也许你之前写过类似内容
我要更新一点内容
如果你使用Swift 1编译器它会生成这个样子
我不了解大家会怎样这并没有什么用
Swift 1.2则要好很多
Swift 1.2会生成错误消息并告知我出现了问题
现在我发现无法对之赋值
当然这还不够好
我们继续研究编译器生成的错误消息和警告
在Swift 2中 它表示“你不能给x赋值因Self不可变”
Xcode会告知你可以把方法标为可变 这样就解决了问题
这是个很棒的方法我觉得很多人...
它会帮助很多人更好地了解Swift中的可变性模型
并让代码更为出色
当然这才只是一个实例这样的例子还有很多
我们还添加了警告的实例
如果你的变量声明为常数
我们就会生成警告要使用Let来替代Are
Swift移植工具会在许多情况下用Let替代Are自动移动许多代码
我们都会警告如果你声明一个值无论是Let还是Are都不要使用
如果你使用函数方法
然后忽略结果
因为你可能是想使用变异方法
我们会对所有这些生成警告
还有简单的实例
我们来谈谈SDK
这是Swift的核心内容它与Cocoa配合很好
有了Objective-C API
Swift编译器不清楚指针是否应为零以及集合的元素类型是什么
我们引入了若干Objective-C的新功能
包括表达可空性的能力
Objective-C的集合元素类型
有整系列的其他功能
为Swift的Objective-C代码提供优质体验
最棒的一点是
Apple的框架工程师完成一项杰出的工作
他们采用了所有这些现代Objective-C功能
在Swift的各种平台上Cocoa SDK整体表现都很出色
而你无需做任何工作
不过如果你有Objective-C代码
也许在你项目中混合并匹配了Objective-C代码
也许你想在Swift中拥有更美观的Objective-C框架
今天晚些时候可以看看部分讲座内容了解更多功能
这样你就可以提供出色的Swift体验
你可能需要看看视频
我们来谈谈单元测试
在整个工具组测试都是非常重要的
Swift中的测试功能非常不错
不过访问控制则不然
问题是Swift要求你将符号Public标为对单元测试束可见
如果可以测试就不应该公开大量内容
Swift 2和Xcode 7解决了这一问题
现在你的代码会自动搭建成特殊模式
表示这是测试中
它们默认可以访问你的公开和内部符号
你必须要用到新的app...
更棒的一点是这不但非常容易 而且...
你仍可以为发布构建获得正确的行为
这样可以获得很好的性能以及访问控制的保护收益
我们有一系列关于测试的讲座
我强力推荐《Xcode的UI测试》
我们来谈谈富批注
游乐场非常棒
Xcode可能帮你在编辑器中使用批注句法 富批注句法
搭建漂亮的Swift游乐场
句法是Markdown中的一个变量
非常不错 很出名 很流行是很好的句法
我们也可以使用文档评论
这是说你可以构建漂亮的富文档评论
并在API上为客户显示
如果你在生成库你可以做很棒的事情
最后 Xcode的移植工具
在Xcode 7中一打开Swift 1项目
它就会弹出信息
“我可以为你升级到Swift 2”
这大概需要两步骤
你可以选择自己的目标然后它会提供一个dif
Swift 2移植工具实际上非常不错
这其中包括从Swift 1
转移到Swift 2的大部分问题和情况
包括错误处理模型 从内容到方法的转移和SDK的改变
及诸多的选项集合改变都搭建在移植工具之中
效果相当不错
Swift 2中还有相当多的内容 现在我们没时间一一介绍
如果你们对更多详情感兴趣
建议看看Swift编程语言书籍
已经有新版本推出
Xcode 7版本发布说明中也详细介绍了这方面的改变
我们来继续讲模式匹配
大家最初遇到模式匹配也许是在if-let语句中
最好使用可选类型
有条件地打开然后将结果捆绑到安全的名称上
这非常棒
当然 好东西远不止这些
我们都曾经见过“金字塔厄运”
是指太多if-let语句堆在一起
突然代码已经有15层高
你完全搞不懂它
Swift 1.2通过在if语句中引入复合条件解决了这个问题
这会就自然多了
你可以在内联
查看多个可选类型和布林条件 效果好多了
这并没有解决提早退出的问题
我给大家看几个也许是最可怕的JSON处理代码
随着时间的推移 情况会改善
我们来看这个
我从无类型JSON字典中取出各种域
我取出名称转化为字符串生成可选类型
如果不匹配 我就要想办法
同样 取出年信息转化为In
如果不匹配 需要救助
如果取出很多值更常见是最好能采取救助方式
而不是深埋在代码中这种模式更常见
这种方式的问题在于完成时需要强迫打开可选值
这里我只使用一次
但是如果你有一组代码都使用它们你就需要到处都要强迫打开
你需要做些事情来解决
打开可选类型是不错方法
它将强迫打开放入不安全的Mecca
可能这样做也不大对也非常难看
我们引入了新的Guard语句
看待Guard的方法就是它要做检查
若是检查不匹配就会做救助
你可以用过很多Guard语句
现在我们来做可选检查
我们将一个值绑在名称上
它可以发挥作用的方式是
是确保Else退出当前的范围
可以用两种方式的一种来完成
返回 抛出 跳出有很多方式可以退出范围
很好
你还可以调用No Return函数
例如Precondition Fail或Abort
这些都是停止的不错方法
这还可以确保编译器了解安全性和
和贯穿代码之后可以看到的确定性
如果把这个用在我们的例子中肯定会边的更好
因为我们可以用Guard校对
如我们所愿进行安全 简洁的检查
还有一点很棒的是
这些都构建在If语句的富复合条件中
现在可以将它们合并在一起
根据Guard语句 检查多个布林值和可选类型
和我们稍后介绍的其他情况
这相当棒
我们再看看模式匹配更强大更有趣的形式 开关语句
我觉得开关语句也许是许多人喜爱的Swift功能
因为在开关语句中可以实现许多模式匹配功能
你可以检查可选类型 
可以做类分层结构检查可以检查范围
在开关语句中可以实现许多功能
当你要写许多条件语句时这会很棒
但是当你只想检查一个条件时 
在语句构成方面些笨重
它们只能是表达详尽你必须承认这很麻烦
我们所做的是将模式匹配和开关 条件结合
将其带到其他控制语句中
这个实例可以写成新的If条件 
检查之后 可以做模式匹配将可变名称绑到语句中
我们又向前进了一步Swift还有一个出色的语句 循环
在...循环中需要完成一些过滤的情况是很常见的
有些语言甚至需要引入全新的语言结构
例如列出对此类模式的模型理解
通过Swift 2我们完成两项任务
我们在...语句中添加了简单的布林值内联过滤器
但是大家也可以在循环中完成
全面的模式匹配为你提供强大的条件
关于模式匹配的内容我只能匆匆介绍这些
我们介绍了新的Guard语句非常适合提前退出
讲了将模式匹配放到语言各处
我们并未谈及其他的改进内容
在你开始使用Swift时就会发现它们
谢谢接下来有请约翰上台
他会告知大家可用性检测方面的内容
谢谢 克里斯
我们经常推出新功能
大家可能听说过Force Touch
Force Touch是硬件功能当然它还有一系列API
正如NSButton中的这个
可以让我来改变按钮对拖拽的反应方式
如果我想在自己的app中采用这个功能
将非常简单 对吧？
我得编写一些新的事件处理代码
然后我需要用到按钮
设置热加载属性
问题是这在我的开发设备上效果可能会不错
但是当我把它移交到测试硬件时
几乎肯定就会出现崩溃
这是因为这是个新的API
是在X v10.3中引入
在这种情况下 和大多数人一样
你仍然会需要支持较早版本的OS
我怎么解决这个问题呢?
我以前常用的解决办法是我会让方法的错误信息不存在
我来看看这种方法是否存在
一方面人们开发了许多不同的惯用语法来实现这一点
这是个常见惯用语使用Responds到Selector
问题是这是个容易出错的模式
例如 我必须指出选择器是什么
从部分Swift语言功能做映射
到部分Objective-C选择器
这些细节没有必要全部了解
要知道编译器也没有帮我检查
因为我本来也不愿检查编译器所提供的内容
例如 在本例中我实际上忘记加冒号
意思是说检查永远不会为真
有了Swift 2我们有更好的解决方案
在默认状态下要确保
不要使用部署目标上最小且不可用的API
如果我做这样的事情...
如果我做这样的事情我会经常进行诊断
这样我可以有某种安全核心假设
只要我的代码...只要我的项目完全编译
它至少不会包含这种小的部署问题
当然这还不全是兼容性的问题
但这可以帮你使用新的API
我确实想要用这个怎么办呢?
我们添加了新的#available条件
在#available中你可以列出想要测试的OS版本
最后你会用这个星号确定
是否在代码里没有的新OS
你至少要在这里诊断可用性
我已经用了If语句 
但是我可以使用克里斯刚展示给大家的Guard语句
这是在所有的地方都完全相同的条件逻辑
就是这样
这是可用性检测
我们认为这是
让你在项目中 自动安全使用新版OS 新功能的不错方法
稍后 我们会介绍更多详情我非常建议大家能来听
接下来 我想谈谈协议扩展
扩展是Swift一大特色功能
我可以使用任意类型 如Array
并在其中加上我自己的方法
这一点很重要但并不明显
方法是核心内容
这就是类型原生API表达的方式
当我添加扩展时
我实际添加了感觉像第一类型新功能
正如该类型的设计人员已经加上的API核心类型
这会有很多优势
这里我加上了Count If方法
这就会针对间隔的数组
和返回True的次数调用闭包
在这种方法中并没有具体针对数组
这应该适用于任意集合
不过 在Swift 1我无法用这方法来表达
为将这个泛型加到任意集合中
我必须要编写像这个样子的编码
正如很多人所指出的那样这并不绝对优化
首先 这里有很多额外的句法
在其中所有这些尖角括号中有些盲区 
所有这些额外的外壳构成了这个泛型
其二 这不再是一种方法
因为首先它不再是方法
它不再像使用该类型的自然部分
第二 它很难被发现
它不会出现在数组的任何功能列表中
特别是它不会出现在功能列表被完成提供的代码中
这意味着你写出这么漂亮的Count If语句 
可是使用它的人都不知道它的存在除非你指出来
好那我们先回来
我们有这个扩展的数组只要把方法加到数组中即可
为什么我们不能扩展...我不知道...
执行集合类型的每项内容?
在Swift 2中 我很高兴地说你可以
你可以扩展集合类型而不是扩展数组
当你这么做的时候
你会自动把各处的方法加到执行集合类型的每个类型中
不仅是从标准库中或是任何内容中
而是就在恰好符合要求的你自己的类型中
这不仅有利于编写自己的泛型代码
而且我们发现这可以让我们修改在Swift 1中不满意的许多内容
在Swift 1中有很多内容都必须是全局函数
因为它们必须是泛型或者因为我们写成了泛型
更糟糕的是 为了制作方法我们选择了特殊条件的部分类型
例如数组有许多这样的映射和过滤方法
其他类似Set的类型也许不会有
在Swift 2会有这些功能
这类过滤和映射功能会通过扩展表达
这意味着在每个内容上都可用
还会更容易找到
这意味着使用标准库会更为统一
我们的确认为大家会喜欢它
我还没有介绍到新功能的
复杂度的三分之一
明天我们有场专门介绍这方面内容的精彩讲座
我强烈建议大家能来听
它是关于Swift支持的协议中杰出的新设计模式
讲座的其余部分是关于错误处理
我觉得很少有人会喜欢琢磨错误处理
如果大家和我一样的话
思想深处都埋藏着这样的想法
但它真的很重要
当我们在看可以用Swift做点什么
使其真正成为更稳健更具表现力的语言
我们觉得这里最重要的问题就是要进行错误处理
当我们看其他语言Cocoa中的解决方案
我们对这些并不满意
其中有太多问题我们真的不很喜欢
要知道其中有些是基于自动传播错误
比如Objective-C语言中的NSError
它生成了许多重复性的容易出错的代码
最后你不得不到处复制
这意味着很容易出错
更重要的是当你在自己周围传播错误时
隐形的默认行为就是你在忽略错误
而这永远都不是正确的默认状态
你应该至少考虑一下错误
从另外一个角度而言还有些语言可以显示传播错误
例如异常处理
但是我们也不喜欢这些的效果
很显然在这方面人们很容易不去考虑这些错误 
最后你会掉到坑里
自己也不知道到底程序里出现哪些问题
你不明白控制怎样会从一处流到另一处
而且这样也不是安全可靠的编程模型
其实函数有三种以不同的方式出现问题
一种是许多函数以非常简单
而明显的方式出问题
例如 除非你在运行编译器
你可能并不在乎为什么要分析字符串失败的整数
这种事情报告给用户没什么意思也不会有趣
也许你想直接处理
以前我们就是这样看待这个问题的
现在在Swift中它得到了很好的解决
有了可选的结果
我们觉得不需要做任何事情
我们对现在的办法很是满意
从另外一个角度而言在你的程序中有许多逻辑问题
比如程序 人员的错误索引越界
人们使用NSException的主要方式等等
对于这些问题它们实际上不应该是可恢复的
当你可以恢复这类问题时
就会导致程序整体不太稳定
如果你随机从越界索引中恢复你不清楚程序的状态究竟如何
你可能甚至会在应用中产生安全问题
在中间的
是API可能出现错误的各种具体情况
这些是我们真正想关注的内容
如今在Cocoa的内容可以使用NSError 
我想给大家举个例子
这是个预飞方式我有某个操作需要预飞
以确定它是否可以发挥作用
我相信 很多人之前都写过这样的内容
我想看看是否部分文档可以访问
然后我会重设与操作相关的状态
现在来看资源是否可访问
这个操作会发生错误
可以出现各种各样的错误
它应该报告一些内容
因为调用者希望知道为什么有些内容不可访问
也许会根据原因进行不同的处理
如果我想使用NSError
最后代码就会变成这样
我会采用这个错误在调用者之外进行传播
就是这种情况
有许多问题我们当真不喜欢
它在我的逻辑中增添了许多模板
我原本是只有两行的紧凑函数
结果变成这样...
要知道其中有If语句额外的嵌套 额外的参数
这里有很多内容
其目的就是为了表达有错误我们正将它向调用者传播
更糟糕的是
这里还有个约定
你需要了解这个约定
根据这个约定你必须手动执行才行
编译器无法帮到你
事实上我这里又犯了错
在这个约定中当你返回False时就会有错误发生
我检查的时候方法也不对
我不知道他们怎么会信得过我来用编译器
我需要加上Not才能得到我想要的行为
好的啊 不好意思
这就是不利因素这也是我们喜欢它的原因
首先 可以通过读取这个代码
检查资源找到出现问题的部分
在名称上就说得很清楚这就是在说错误
这是显性的错误处理内容这是显性错误参数
同样很明显地预飞也是很容易出有问题的操作
同样是显性错误参数 返回值 等等
其三是没有显性控制流
我可以看着它并了解其中所有的内容
我可以像人类那样分析而不是像编译器那样静态分析代码
作为人类我可以看到这个代码
分析它在做什么
而不需要了解每个我在调用的函数细节
好
我们返回这个例子中
它之前是这样
如果我用Swift编译会发生什么情况？
我会受到错误消息因为我没有处理错误
在Swift中有两个组件可用来处理错误
第一个是在你调用API出现问题时必须要用Try关键字
Try可以交流
它主要就是便于他人读取代码
它与你交流道，“这里就是会出现问题的部分”
这是说 当你返回时当你以后做维护的时候
我会直接...
Reset State但并不是每次调用都需要这个函数
这里也许还有很重要的内容需要我知道
当我首先编写代码时
这是我需要考虑的问题
Reset State在我每次退出函数时 都需要调用吗？
对于预飞操作呢？也许这还不够 
我没有以任何方式处理造成错误
这是因为在Swift中在默认状态下 函数不可抛出
这是我们的设计的核心内容 
因为它意味着错误不可避免
你不必考虑所有内容都会像Java或C#语言那样抛出异常
或是基本上每种语言都在使用异常
相反 它是相当具体的内容
你知道自己需要是否要考虑将之抛出
当你在代码中调用它们时它会标明Try
这一组合可以交流很多
好的 假设我先要向调用者传播一个错误
为此 我只需告知编译器
“可以让它把错误抛出”
我就会抛出
这可能不是我想要处理的方式
这是个预飞方式
我可能想容忍错误
告知调用方预飞是否成功
为此 我只能处理它
我就编写了Do Catch
在Do中的任何代码
其中转发的任何错误都会像过滤所一样被捕获
在捕获之后会是什么
你在开关语句中可以编写的任何内容
Swift的模式匹配句法最强大之处在于它可以捕获
作为非常简单的常见句法改进
这类捕获是捕获的短板
并会带入这种特殊的错误变量
我还可以写出更精致的内容
例如 我可以处理某种错误
作为特殊情况也许在我的预飞中可以接受
我不知道为什么不存在的文档可以接受
也许我真想看看它是否存在
出于某些许可原因它会不会真的使用
如果我想
我可以对错误代码和域名直接做像这样的模式匹配
另外 还有第三种“处理错误”的方法
经常会有这种情况
你前提设置了
不应该抛出的具体调用
例如 也许这个文件在我的app束
我知道如果我无法在自己的app束中读取文件
那就真的有问题了
也许没有办法可以恢复
在这个常见模式中
你可能会需要一个致命错误因为错误抛出
它有个非常精简的关联句法 Try!
这会生成一个断言
其中Try中的代码不会真正抛出
如果抛出你的程序就会崩溃
就像是其他断言错误一样
这类问题可以很容易地调试解决
你不会总是想要用这类内容
但是当你需要它时这非常方便
回来看一下
我捕获一个错误
错误是什么类型？
我们有个协议
搭建成标准库ErrorType
你可以抛出任何满足ErrorType类型的值
当你捕获到问题时
也就是模式匹配的ErrorType任意值
我们觉得重要的是
我们不会只跟踪是否要抛出的错误
这和Java不同 你最后会有一个详尽的清单
列出可能会抛出的所有异常
然后每次改变错误时你可能都会面对这个复杂的传播问题
跟踪错误是否抛出已经足够
几乎一直是如此
我们认为这是个很好的模型
你可以让自己的类型符合ErrorType
这个过程要比Cocoa容易得多
枚举是表达的不错方法
它们可以很棒地表达一组相关问题
正如它们...
要知道的确如此
因为在枚举中可以关联每个条件的数据
如果我想报告更丰富的错误消息
其中包括也许关于...
也许我在查看一些无效状态
我希望记住无效状态是什么
我可以将特例中的相关值直接嵌入枚举中
为了让枚举作为错误可用 你只需要让它
符合ErrorType即可
编译器会自动处理合成的细节
这要胜过处理生成新NSError域名和相关内容
我们认为当你需要的时候
这将会对大家很有帮助在自己的代码中表达抛出错误API
我们回到克里斯之前介绍的例子中来
这个JSON处理器
我用字符串中的Either返回错误
我们让它看起来更像是Swift中的效果
首先 不是用字符串
我会用刚谈过的数据错误枚举
我必须抛出
为了抛出这些值 我使用新的抛出语句
效果不错
另一方面是我需要修改返回类型
我不再返回Either类型
对于这类问题每个调用者为检查错误
不会对返回值认真进行微管理
我做了修改这样就会返回Person即抛出方式
这样我就不必在这些小细节上操心
我们再来一个新的例子去除我们刚生成的方法
我们来解析JSON语句我们解析一个人
我们用它来解析涉及此人和一些内容的整个销售记录
有时候碰巧你需要知道
这是个人为的例子
不好意思有时候我需要观察这类进程
我需要进行某种委托
我需要让它知道我开始读取销售数据
我现在告知它我开始读取
显然 我在完成读取时也应该告知它
我可以把代码加在下面
问题是我在错误处理方面做得不对
很容易会...
如果我的委托在销售结束时
每次都调用Careful和Variants设置
如果我的委托有变化它希望在两端调用时都保持
如果我要搞糟进程我把这事儿弄混了
这类问题常常会出现会使得错误处理看似很脆弱
好的 当然我可以这样解决问题
只要在这些抛出站点 Did End Reading Sale加入调用
随后我仍没有处理调用Process Person
为了做点什么我必须把它加入Do Catch
这相当...相当繁琐
但是它的确容易出错
因为很容易让我增添新的代码 新的处理方式
如果我当真做什么的话它就会立刻过期
如果我忘记添加
Did End Reading Sale到这个特殊路径
Swift 2有着更好的选项
叫做Defer
Defer语句生成一个动作
当你执行时
无论当前的范围是什么动作都会 得以执行
如果我返回如果我出现问题
如果我抛出错误无论怎样
我都知道它会得到执行
这意味着当有人读取代码
维护代码时 
我会绝对有信心
无论我怎样结束读取销售数据
Did End Reading Sale都会执行
这是需要掌握的重要内容
我简要介绍一下执行情况
如果有谁习惯进行异常处理也许会知道
在许多语言中 异常处理的执行方式
会非常受到被抛出的错误的影响
抛出错误的函数返回
也许会比按照正常方式
返回慢3个 甚至4个数量级
出于语言设计的某些方面的需要
我们并非是想在Swift中模仿什么
大家在这里只需要知道
Swift执行得更为平衡
基本上更像是调用者的If语句
这是说并非完全自由地调用可抛出错误的内容 
但是这意味着你不必担心
我们的错误处理功能造价太高
如果出于实际情况中
对错误路径 效率的考虑有些具体原因会令你无法使用它
最后 我要说一下Swift
Swift的错误处理设计在Cocoa API中可以发挥作用
我们自动识别你在Cocoa中见到的最常用约定
例如具备NSError Out参数的方法
并将返回Bool值
自动变为抛出方法
Bool的返回值也会返回
同样地
如果它返回可选结果
我们会将模式识别为零值表明是无效内容
因为是零值
它就不会再返回包括在错误处理之内可选结果
有着这两条非常简单的规则
我们发现系统的大部分API都会输入
并自动无缝完美配合这些新的Swift错误处理模型
我认为这是在Swift中处理错误的伟大新方式
我强烈推荐大家去看看
你可能没有太多选择
它们到处都是
要知道我们对这个设计非常自豪
我们认为这将极大改善编码的稳健性和表达性
让你可以设计出非常不错的API
我来总结一下
我们一直在Swift 2方面投入大量精力
为大家提供新的语言
通过Swift中的工具
推出Swift的编程的核心方面
为大家提供更安全更稳健的环境
整体提高产品水平
整个过程中对我们而言 最珍贵的工具
就是大家的反馈
我们非常非常重视这些
我承诺一定会听取意见
如果你要告诉我们什么
当然 大家可以仅使用错误报告工具即可实现这一点
但是大家也可以联系斯蒂凡·莱瑟来开发人员论坛
我们大部分人始终都会在那里待着
我们非常乐于对任何问题进行答复
想听到大家的反馈
我们非常非常重视你们
非常感谢
希望大家喜欢WWDC 2015