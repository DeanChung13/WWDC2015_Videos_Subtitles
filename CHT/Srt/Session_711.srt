00:00:26.326 --> 00:00:29.730 
《網絡與NSURL會話》

00:00:32.299 --> 00:00:33.133 
早上好！

00:00:34.101 --> 00:00:37.204 
感謝您來到
《網絡與NSURL會話》會議

00:00:37.704 --> 00:00:40.274 
我是盧克·卡斯
我是一個CF網絡組的工程師

00:00:40.641 --> 00:00:42.809 
今天早上我爲與
會的各位羅列了一些很棒的東西

00:00:44.578 --> 00:00:47.514 
首先
我們要講一些應用程序傳輸安全問題

00:00:48.148 --> 00:00:52.219 
接着我們會講在NSURL會話中
添加了哪些新的協議

00:00:54.121 --> 00:00:56.123 
週一我們看到了WatchOS的發佈

00:00:56.557 --> 00:01:01.662 
我們將會介紹爲WatchOS
添加的NSURL會話功能

00:01:02.029 --> 00:01:05.632 
之後我們會梳理一下API有哪些變化

00:01:05.632 --> 00:01:07.534 
以及我們在NSURL會話中
添加了哪些新功能

00:01:09.636 --> 00:01:15.475 
首先我想要講一下NSURL會話
和HTTP協議的背景

00:01:16.176 --> 00:01:18.779 
NSURL會話是一個網絡API

00:01:18.846 --> 00:01:23.650 
主要用於從網站
下載內容或者HTTP內容

00:01:25.052 --> 00:01:27.154 
它包含很多委託方法

00:01:27.387 --> 00:01:32.025 
可以用來認證或者
處理一些其他的重要事情

00:01:32.626 --> 00:01:35.362 
NSURL會話有一個非常強大的功能

00:01:35.662 --> 00:01:38.298 
那就是它允許你的程序

00:01:38.365 --> 00:01:44.438 
在沒有後臺下載API的情況下
做網絡層任務

00:01:46.106 --> 00:01:48.709 
如果你對NSURL會話不熟悉的話

00:01:49.042 --> 00:01:51.612 
建議你可以回顧一下

00:01:51.945 --> 00:01:55.983 
幾年前的WWDC會議中
對NSURL會話的介紹

00:01:58.252 --> 00:02:01.522 
現在讓我們討論一下超文本傳輸協議

00:02:01.755 --> 00:02:05.659 
這是一個非常有名的協議
你們中的很多人可能都很熟悉

00:02:06.860 --> 00:02:11.365 
基本上其核心就是
你向服務器發送請求

00:02:11.565 --> 00:02:14.401 
然後你會拉回一個數據包作爲迴應

00:02:15.202 --> 00:02:18.338 
現在HTTP其本身

00:02:19.540 --> 00:02:23.577 
你們中間有些人可能知道發送的是明碼
所以其從根本上來講就不安全

00:02:24.912 --> 00:02:26.146 
在今天的網絡環境中

00:02:26.680 --> 00:02:32.653 
有很多攻擊團體追蹤你的APP數據
並將其發佈到網絡上

00:02:38.492 --> 00:02:42.362 
曾經有一段時間單獨使用明碼HTTP
這是完全合理的

00:02:42.729 --> 00:02:44.598 
但是這段時間已經過去

00:02:45.232 --> 00:02:46.600 
現在我們所有人都是幸運的

00:02:46.667 --> 00:02:50.904 
這個問題在多年以前就被解決

00:02:51.104 --> 00:02:52.873 
就是HTTPS

00:02:56.343 --> 00:03:01.048 
但HTTPS本質上
是HTTPS的上一層協議

00:03:01.114 --> 00:03:02.749 
屬於傳輸層安全協議

00:03:03.417 --> 00:03:06.653 
傳輸層安全協議會通過公鑰密碼學方式

00:03:07.120 --> 00:03:09.857 
進行一個多點的信號交換之後

00:03:10.257 --> 00:03:11.792 
會創建一個安全的連接

00:03:12.726 --> 00:03:16.797 
這種連接的安全性
是基於三個屬性來講

00:03:17.564 --> 00:03:21.134 
第一 從你的APP發出

00:03:21.568 --> 00:03:24.271 
並在網絡上傳輸的數據是加密過的
所以其不可讀

00:03:25.138 --> 00:03:28.041 
第二 其提供了消息完整性參數

00:03:28.675 --> 00:03:31.111 
所以消息在檢測之前是不可以修改的

00:03:31.912 --> 00:03:34.815 
最後第三點 它支持身份驗證

00:03:35.082 --> 00:03:38.552 
所以你可以驗證
到底是誰在和你會話

00:03:43.023 --> 00:03:47.528 
現在NSURL會話
有非常好的HTTPS嵌入性支持

00:03:48.061 --> 00:03:51.098 
通常在你的客戶端代碼中

00:03:51.398 --> 00:03:54.034 
這就像使用HTTPS
代替HTTP一樣簡單

00:03:54.935 --> 00:03:58.038 
現在請注意
需要一些額外的服務器支持

00:03:58.605 --> 00:04:02.075 
但HTTPS是大多數服務器
供應商都支持的

00:04:04.211 --> 00:04:05.412 
還請記住

00:04:06.880 --> 00:04:09.550 
大多數數據都應該被標記爲敏感數據

00:04:10.551 --> 00:04:13.287 
那是因爲即使你認爲

00:04:13.921 --> 00:04:17.991 
你在網絡上傳輸的數據
並不屬於敏感數據

00:04:18.825 --> 00:04:21.728 
但是事實上
你的客戶可能認爲它是敏感數據

00:04:21.995 --> 00:04:24.631 
假如你有一個TV流APP

00:04:26.099 --> 00:04:27.968 
你可能認爲這只是一個電視

00:04:28.101 --> 00:04:30.404 
你知道嗎？他只是看電視

00:04:30.771 --> 00:04:34.141 
他或她僅僅是看電視
但是對他們來說...

00:04:36.610 --> 00:04:39.179 
他們事實上並不想
讓人們知道他們在看什麼電視

00:04:39.246 --> 00:04:40.247 
讓我們用這種方式解釋

00:04:42.950 --> 00:04:46.587 
現在爲什麼說
使用HPPTS如此重要？

00:04:46.954 --> 00:04:49.089 
事實上從本質上來講

00:04:49.423 --> 00:04:52.359 
你的客戶相信你
能夠保證他們的數據和個人隱私

00:04:53.527 --> 00:04:56.597 
在Apple
我們非常想要和你們一起努力

00:04:56.597 --> 00:04:59.867 
並確保我們能夠
建立並維持這種信任關係

00:05:00.234 --> 00:05:03.570 
所以今天我非常自豪能夠介紹
App Transport Security

00:05:05.239 --> 00:05:07.941 
App Transport Security

00:05:08.208 --> 00:05:12.012 
是Apple在IOS 9和OS X
和EI旗艦版中的一個新功能

00:05:12.846 --> 00:05:19.720 
從本質上來講其核心是防止
用戶的個人隱私數據被意外泄露

00:05:22.122 --> 00:05:26.193 
現在ATS也加強了
NSURL會話的默認方法

00:05:27.327 --> 00:05:29.863 
可以在默認設置下
最重要的增強的方面

00:05:30.831 --> 00:05:33.433 
就是現在的NSURL會話

00:05:33.734 --> 00:05:36.270 
它不允許明碼HTTP進行加載

00:05:36.637 --> 00:05:38.772 
它將只使用HPPTS連接

00:05:39.439 --> 00:05:42.509 
現在這種連接方式
確實是當下最可靠且最好的實現方法

00:05:43.210 --> 00:05:46.213 
所以ATS對TLS的版本進行了限制

00:05:47.014 --> 00:05:52.753 
密碼組合 信任證書 證書密鑰的大小
等都是被作爲限制條件

00:05:54.555 --> 00:05:58.825 
現在ATS能很容易地通過應用程序的
Info.plist進行配置

00:05:59.693 --> 00:06:00.961 
這裏有一個例子

00:06:02.162 --> 00:06:07.601 
事實上我們讓你做的就是
聲明你在應用程序中有目的的網絡行爲

00:06:10.838 --> 00:06:16.376 
核心上來講
ATS希望你能描述使用網絡做什麼

00:06:16.710 --> 00:06:21.648 
我們真心希望你能夠放心
你的應用程序安全問題

00:06:21.982 --> 00:06:23.617 
並且做事情的時候更加信賴這個系統

00:06:23.917 --> 00:06:28.822 
當網絡交易是安全的時候
這些都是最簡單的事情

00:06:30.757 --> 00:06:34.962 
所以 如果你的程序只使用安全的連接

00:06:35.162 --> 00:06:37.264 
並且其只使用最佳安全屬性

00:06:37.931 --> 00:06:40.968 
那麼你就不需要做任何事情
來爲你的應用程序配置ATS

00:06:42.936 --> 00:06:46.406 
因此 如果你在編寫一個新的應用程序
這就是我們想要你做的事情

00:06:47.241 --> 00:06:50.043 
如果你有一個現成的應用程序
或者有一段遺留代碼

00:06:50.511 --> 00:06:52.579 
這就是你應該注意的地方

00:06:55.048 --> 00:07:00.554 
現在我們明白實際情況
可能並不總是這樣

00:07:00.554 --> 00:07:06.493 
假如你有一個服務器可以遵守
這些TLS版本或者密碼套件的新限制

00:07:06.960 --> 00:07:11.131 
所以我們允許例外情況的出現

00:07:11.532 --> 00:07:14.968 
事實上你可以通過ATS聲明異常原因

00:07:16.003 --> 00:07:18.605 
讓我們知道你想
使用什麼版本的TLS

00:07:18.605 --> 00:07:21.675 
或者你也可以選擇正向保密
或者其他的選項

00:07:24.011 --> 00:07:27.881 
我們理解現存的程序可能有不同的限制

00:07:29.783 --> 00:07:32.686 
假設大多數情況下你都使用安全連接

00:07:33.387 --> 00:07:35.322 
但是特殊情況下

00:07:36.523 --> 00:07:41.228 
你可能會使用一些並不支持HTTPS
或者最佳實踐的服務器

00:07:42.095 --> 00:07:44.298 
假如你有一個多媒體服務器

00:07:44.598 --> 00:07:47.367 
它並不支持HTTPS
只支持HTTP

00:07:47.801 --> 00:07:52.039 
你能夠很方便地用異常來描述這種情況

00:07:53.273 --> 00:07:57.811 
基本上所有你需要做的事情就是
聲明哪些域名需要加載HTTP

00:07:58.145 --> 00:08:01.248 
NSURL仍然允許明碼加載

00:08:05.452 --> 00:08:09.122 
現在我們瞭解到你們中一些人
可能會支持使用一個通用的網頁瀏覽器

00:08:09.189 --> 00:08:12.993 
或者一個基於
動態用戶輸入加載URL的程序

00:08:13.527 --> 00:08:14.962 
現在我們已經允許了這種情況

00:08:15.395 --> 00:08:21.134 
在這種情況下
你不可能提前描述的安全連接的種類

00:08:21.602 --> 00:08:25.606 
所以你可以簡單地
選擇聲明允許所有的方法

00:08:26.740 --> 00:08:28.709 
現在這個允許所有的方法

00:08:29.576 --> 00:08:35.381 
能夠允許NSURL會話加載
任何的HTTP或者HTTPS資源

00:08:36.616 --> 00:08:40.087 
我相信這是目前互聯網上現有的工具中

00:08:40.520 --> 00:08:42.222 
一個非常有用的調試工具

00:08:42.655 --> 00:08:44.725 
所以我們希望

00:08:44.858 --> 00:08:48.829 
如果你用它做調試
可以對顯而易見的原因進行臨時調試

00:08:51.498 --> 00:08:52.833 
現在即使你就處於這種狀態

00:08:52.833 --> 00:08:56.470 
你仍然能夠保護特定的服務器和域

00:08:57.771 --> 00:08:59.673 
如果你的設置的是允許所有

00:08:59.907 --> 00:09:04.511 
但是如果你有一個
用來拉取配置數據和元數據的服務器

00:09:05.179 --> 00:09:08.649 
並且用ATS來做調試
這種情況是個例外

00:09:09.616 --> 00:09:13.153 
當你對一種例外情況
進行允許所有的設置時

00:09:13.754 --> 00:09:16.056 
只需要簡單地聲明
想要保護的域就行了

00:09:16.657 --> 00:09:23.030 
這樣允許NSURL會話 繼續通過
只加載HTTPS或者最優方法

00:09:23.730 --> 00:09:25.265 
來保護這些資源

00:09:29.069 --> 00:09:29.903 
現在

00:09:30.771 --> 00:09:32.539 
從週一開始
這個SDK已經發布了

00:09:33.807 --> 00:09:37.211 
可能有一部分人
已經在這個糟糕的時間醒了

00:09:37.578 --> 00:09:41.415 
僅僅就是想知道ATS是幹什麼用的
以及爲什麼你的網絡會加載失敗

00:09:42.282 --> 00:09:43.550 
我們明白

00:09:43.617 --> 00:09:46.253 
我們只是想和你一起工作
所以才把你叫起來

00:09:49.356 --> 00:09:53.994 
所以請注意 ATS只有在你構建
當前SDK時是活躍的

00:09:54.828 --> 00:09:56.630 
如果你針對的是之前的版本

00:09:57.064 --> 00:09:58.665 
ATS規則不適用

00:10:00.934 --> 00:10:05.005 
NSURL會話會將HTTP資源

00:10:05.472 --> 00:10:08.942 
或者URL自動轉換成HTTPS

00:10:11.879 --> 00:10:15.716 
就像我之前說的
你們中有人已經對這個開關有所瞭解

00:10:16.683 --> 00:10:18.452 
我們允許你暫時使用這個功能

00:10:18.685 --> 00:10:21.922 
來判斷你的程序中新發生的網絡錯誤

00:10:22.155 --> 00:10:23.790 
是不是因爲ATS

00:10:24.358 --> 00:10:26.093 
這能夠幫助你將範圍縮小

00:10:28.562 --> 00:10:32.332 
接下來
如果你打開了允許所有的ATS

00:10:32.599 --> 00:10:33.867 
允許所有開始加載

00:10:35.435 --> 00:10:37.571 
那麼你就能夠確定問題出在ATS

00:10:38.438 --> 00:10:42.409 
接下來就是
查找你看到的NSURL會話的錯誤

00:10:42.709 --> 00:10:44.344 
所以你可以試着確定並縮小範圍

00:10:44.344 --> 00:10:46.079 
到底哪個加載過程失敗了

00:10:46.413 --> 00:10:47.681 
以及潛在的錯誤是什麼

00:10:50.784 --> 00:10:53.554 
還有一個很棒的調試工具

00:10:54.421 --> 00:10:57.057 
是一個被叫做CF網絡診斷的環境變量

00:10:58.692 --> 00:11:01.195 
如果你將CF網絡診斷設置爲一級

00:11:01.929 --> 00:11:04.031 
所有失敗的URL開始加載

00:11:04.164 --> 00:11:07.201 
所有加載失敗的任務
都能被確定是URL錯誤

00:11:07.568 --> 00:11:09.436 
或者是底層TLS錯誤

00:11:10.270 --> 00:11:11.705 
這樣接下來你能做的就是

00:11:12.005 --> 00:11:16.410 
查找底層TLS錯誤並
確認transport.h的安全性

00:11:16.910 --> 00:11:19.746 
確定究竟是什麼底層問題

00:11:21.014 --> 00:11:26.153 
通常是客戶端和服務器端
在TLS層的協商失敗

00:11:31.124 --> 00:11:35.863 
所以現在弄明白這是一個新的API
它仍然在發展

00:11:36.463 --> 00:11:43.070 
所以我們強烈建議你們
關注種子筆記和發行說明

00:11:43.170 --> 00:11:48.342 
請將文件廣播出來
這樣方便我們跟蹤你們碰到了什麼問題

00:11:49.543 --> 00:11:51.612 
幫助你們解決並運行起來

00:11:55.782 --> 00:11:58.652 
所以我希望這是一個網絡安全的時代

00:11:59.353 --> 00:12:03.056 
並且我們非常希望能夠與你合作
一起來保護客戶的數據安全

00:12:04.391 --> 00:12:05.225 
再說一遍

00:12:05.993 --> 00:12:10.163 
如果你正在開發一個新程序
請使用HTTPS作爲開頭

00:12:10.631 --> 00:12:14.801 
並儘可能地使你的服務器運行最優方法

00:12:16.737 --> 00:12:20.040 
現在如果你使用的是現有的軟件

00:12:20.174 --> 00:12:24.344 
我們希望
你能先把能夠移動的移動到HTTPS

00:12:24.611 --> 00:12:25.879 
那些你不能夠移動的地方

00:12:26.613 --> 00:12:31.118 
可以通過使用例外情況和
你的Info.plist移動

00:12:32.286 --> 00:12:35.322 
現在請牢記
你的客戶相信你能夠保護好其數據

00:12:35.956 --> 00:12:39.493 
並且這些數據在任何時候都是敏感的

00:12:40.327 --> 00:12:42.262 
所以Apple希望與你合作

00:12:43.230 --> 00:12:45.899 
共同爲你的客戶創造
一個更加安全的網絡環境

00:12:46.400 --> 00:12:47.234 
所以再說一遍

00:12:48.836 --> 00:12:50.537 
請通過雷達給我們反饋

00:12:51.171 --> 00:12:54.007 
在這個會之後
明天就可以過來實驗室拜訪我們

00:12:54.541 --> 00:12:57.311 
我們真的非常希望
與你一起保護我們客戶的數據

00:12:58.178 --> 00:13:01.348 
謝謝所有人的到來
接下來有請安德魯

00:13:01.348 --> 00:13:03.951 
他將會講新的協議和NSURL會話

00:13:04.251 --> 00:13:05.285 
祝你有一個愉快的會議

00:13:11.425 --> 00:13:12.326 
謝謝 盧克

00:13:14.928 --> 00:13:16.063 
早上好各位

00:13:16.330 --> 00:13:17.364 
我叫安德魯

00:13:17.431 --> 00:13:21.201 
接下來我將介紹NSURL會話中
新的協議支持方法

00:13:23.737 --> 00:13:30.444 
是的
NSURL會話支持HTTP/2協議

00:13:31.912 --> 00:13:35.048 
你的程序
可以使用HTTP/2進行通信

00:13:35.182 --> 00:13:36.950 
並且在適配上非常容易

00:13:37.651 --> 00:13:38.986 
讓我來演示一次

00:13:41.188 --> 00:13:42.022 
好的

00:13:42.823 --> 00:13:45.659 
如果在你的代碼中
已經使用了NSURL會話

00:13:46.159 --> 00:13:48.729 
你自動地就已經是其中的一部分了

00:13:49.229 --> 00:13:52.533 
在網絡的未來
網絡革命中的重大里程碑中

00:13:52.933 --> 00:13:54.601 
你的程序已經走在了前列

00:13:55.035 --> 00:13:56.770 
你不需要修改你的源代碼

00:13:57.070 --> 00:13:58.772 
所有事情都是自動完成的

00:14:01.375 --> 00:14:04.244 
所以今天我準備講三件事情

00:14:05.612 --> 00:14:12.419 
爲什麼我們需要一個新協議
HTTP/1.1協議有什麼問題

00:14:13.554 --> 00:14:17.791 
我們將要學習一下
HTTP/2最重要的功能

00:14:18.692 --> 00:14:23.997 
最後我會講一下HTTP/2協議
在你的程序中的適配性

00:14:27.935 --> 00:14:29.870 
爲什麼需要一個新的協議？

00:14:32.739 --> 00:14:36.810 
我們已經有很多協議
用於各種類型的通信

00:14:37.644 --> 00:14:44.284 
原因是大多數協議都是在很多年前
響應那個時代的需要設計出來的

00:14:45.052 --> 00:14:47.754 
看一下Apple的第一個網站

00:14:51.225 --> 00:14:56.597 
今天需要的和十五年前
看起來是明顯不同的

00:14:57.231 --> 00:14:58.765 
所以是時候進行一次升級了

00:15:00.801 --> 00:15:03.303 
HTTP從網絡的最開始就已經存在了

00:15:03.871 --> 00:15:06.740 
大家都知道它有很多問題

00:15:07.808 --> 00:15:09.877 
最有名的HTTP的問題是

00:15:10.277 --> 00:15:14.515 
每一個TCP連接只有一個優先請求

00:15:16.550 --> 00:15:19.152 
這個問題的解決辦法就是HTTP管道

00:15:19.820 --> 00:15:24.124 
但是HTTP管道並不適用於
所有的服務器或網絡

00:15:24.791 --> 00:15:29.329 
事實上 大多數桌面主流網頁瀏覽器上
它是被禁用的

00:15:31.665 --> 00:15:34.868 
另一個解決辦法
就是給一個主機開多個連接

00:15:35.802 --> 00:15:39.173 
這樣能夠更快的得到多種資源

00:15:39.606 --> 00:15:43.610 
綜合其他情況例如文本協議開銷

00:15:44.444 --> 00:15:45.979 
缺乏頭壓縮

00:15:46.647 --> 00:15:47.814 
它只是意味着

00:15:48.081 --> 00:15:54.521 
對客戶端和服務器
更高的系統需求和更低的性能

00:15:58.392 --> 00:16:01.562 
去年我們在NSURL會話中
加入了SPDY支持

00:16:02.596 --> 00:16:04.865 
SPDY是使網絡更快的一種嘗試

00:16:05.465 --> 00:16:07.234 
它是一種實驗性協議

00:16:07.534 --> 00:16:13.106 
但是它被選作
新版HTTP協議的基礎之一

00:16:14.208 --> 00:16:20.681 
新協議的標準版本在上個月
通過了IETF標準

00:16:20.948 --> 00:16:24.551 
並正式分配到了一個RFC編號

00:16:25.619 --> 00:16:27.688 
所以今天
就像你已經知道的那樣

00:16:28.589 --> 00:16:33.660 
NSURL會話
擴展支持HTTP/2協議

00:16:36.063 --> 00:16:37.731 
讓我們看一下

00:16:37.731 --> 00:16:40.534 
HTTP/1.1
和HTTP/2的主要區別

00:16:41.869 --> 00:16:43.770 
與HTTP/1.1相對

00:16:44.171 --> 00:16:48.141 
HTTP/2僅支持
一臺主機開放一個TCP連接

00:16:49.476 --> 00:16:55.249 
它是網絡友好的
並且對客戶端和主機要更少的系統資源

00:16:57.784 --> 00:17:00.254 
HTTP/2完全多路複用

00:17:00.988 --> 00:17:01.822 
這就意味着

00:17:01.889 --> 00:17:08.060 
一個新的請求不需要等到服務器
對前一個請求回覆之後

00:17:09.863 --> 00:17:12.833 
HTTP/2有請求優先級

00:17:13.400 --> 00:17:18.939 
所以更多重要的資源可以優先提供給
擁有更高權限的客戶端

00:17:24.411 --> 00:17:25.279 
讓我們看一下

00:17:25.345 --> 00:17:30.684 
HTTP/2多路複用
如何解決隊首阻塞問題

00:17:32.085 --> 00:17:35.422 
在一個服務器上
我們有三個對資源的請求

00:17:36.990 --> 00:17:40.861 
我們發出第一個請求
並得到一個回覆

00:17:41.995 --> 00:17:47.401 
這之後我們發送第二個請求
並得到第二個回覆

00:17:47.901 --> 00:17:51.004 
對第三個請求也是一樣

00:17:53.907 --> 00:17:55.709 
現在啓用通道

00:17:56.610 --> 00:17:58.579 
我們同時發送所有的請求

00:17:59.213 --> 00:18:03.517 
一個接一個
不需要等到收到之前的回覆

00:18:05.285 --> 00:18:09.623 
但是我們仍然按順序得到了回覆

00:18:10.724 --> 00:18:13.794 
你能夠看到
藍色的圖片是第一個回覆

00:18:15.229 --> 00:18:17.097 
阻塞了緊隨其後的兩個回覆

00:18:20.667 --> 00:18:25.572 
通過HTTP/2
我們給三個請求賦予不同的優先級

00:18:27.007 --> 00:18:30.844 
我們仍然在開始的時候
同時發送所以的請求

00:18:32.246 --> 00:18:35.415 
但是我們同時得到了回覆

00:18:38.151 --> 00:18:42.089 
此外 優先級更高的請求

00:18:43.490 --> 00:18:45.659 
我得到以及發送給客戶端的速度更快

00:18:46.860 --> 00:18:52.833 
你可以看到第二個回覆的是中等優先級

00:18:52.833 --> 00:18:56.603 
並且第三個回覆的是高優先級的請求

00:18:57.304 --> 00:19:02.209 
到達得比第一個回覆更早
即使他們在時間表中更靠後

00:19:02.910 --> 00:19:05.245 
圖片也不再阻塞他們

00:19:05.412 --> 00:19:08.782 
這非常棒
且對你的程序和性能來說也非常棒

00:19:10.617 --> 00:19:12.719 
讓我們來繼續對比

00:19:15.689 --> 00:19:18.192 
HTTP/2是一個二進制協議

00:19:20.460 --> 00:19:24.398 
這使得數據的處理和解析速度更快

00:19:25.599 --> 00:19:30.003 
HTTP/1.1不使用頭壓縮

00:19:30.671 --> 00:19:35.409 
因爲安全漏洞的原因
SPDY同樣也不能使用頭壓縮

00:19:36.243 --> 00:19:41.381 
HTTP/2使用HPACK
這是一種更加安全的頭壓縮機制

00:19:43.851 --> 00:19:45.118 
讓我來介紹一下HPACk

00:19:48.021 --> 00:19:50.657 
HPACK頭壓縮基於兩個表

00:19:51.325 --> 00:19:53.760 
一個靜態表
一個動態表

00:19:55.329 --> 00:20:00.767 
靜態表包括最常用的HTTP信息頭
並且不可修改

00:20:03.070 --> 00:20:08.876 
包含在靜態表中的信息頭
可以添加到動態表中

00:20:10.210 --> 00:20:13.680 
表中的信息頭可以通過指針進行引用

00:20:15.582 --> 00:20:19.486 
例如你可以看到
一個簡單的HTTP/1.1請求

00:20:20.921 --> 00:20:23.991 
突出顯示的部分
是要發送到服務器的數據

00:20:26.460 --> 00:20:31.164 
這裏是一個基於
HTTP/2的相同的請求

00:20:32.232 --> 00:20:33.901 
接下來讓我們將這個請求編碼

00:20:36.370 --> 00:20:42.209 
僞信息頭 方法 計劃以及路徑

00:20:43.377 --> 00:20:46.013 
都可以通過靜態表進行引用

00:20:47.748 --> 00:20:52.653 
主信息頭包括在靜態表中
但是並不包含其值

00:20:53.687 --> 00:20:55.255 
所以要編碼這個請求

00:20:55.989 --> 00:21:01.094 
我們需要三個字節用來存放第一組三頭

00:21:01.328 --> 00:21:05.465 
加上一個告訴你我們想要將主信息頭

00:21:05.532 --> 00:21:08.669 
添加到動態表中的字節

00:21:09.169 --> 00:21:13.006 
以及主信息頭的值和長度

00:21:16.677 --> 00:21:20.214 
這就是要發送到服務器

00:21:20.614 --> 00:21:24.151 
添加了額外開銷的信息頭框架

00:21:26.720 --> 00:21:28.055 
現在對於第二個請求

00:21:30.290 --> 00:21:33.327 
你可以看到主信息頭存儲在
動態表中

00:21:33.961 --> 00:21:35.195 
所以對於第二個請求

00:21:35.395 --> 00:21:41.335 
HTTP/1.1將會
一遍又一遍地發送相同的信息頭

00:21:43.570 --> 00:21:46.974 
但是在HTTP/2中
在通常情況下

00:21:47.241 --> 00:21:49.309 
我們可以通過靜態表和動態表

00:21:50.244 --> 00:21:53.213 
引用所有的信息頭

00:21:53.380 --> 00:21:55.582 
我們只需要一個字節來存放一個信息頭

00:21:56.149 --> 00:21:57.918 
這相當節約帶寬

00:21:58.285 --> 00:22:00.921 
這隻需要如此少的字節

00:22:01.355 --> 00:22:05.526 
就能夠使用HTTP/2編碼
一個請求或者回覆信息頭

00:22:10.230 --> 00:22:11.365 
接下來讓我講一下

00:22:11.431 --> 00:22:14.601 
要爲你的程序
適配HTTP/2協議需要做些什麼

00:22:16.270 --> 00:22:17.738 
其工作量並不大

00:22:18.772 --> 00:22:24.077 
HTTP/2被無縫集成到了
NSURL會話的API中

00:22:25.345 --> 00:22:27.881 
如果你已經在你的代碼中
使用了NSURL會話

00:22:29.550 --> 00:22:34.521 
你的程序和OS X程序
將會自動獲得這種功能

00:22:35.756 --> 00:22:38.091 
你不需要寫另外的代碼

00:22:38.358 --> 00:22:43.797 
或者添加其他的結構來啓動它

00:22:44.398 --> 00:22:46.400 
讓我們來看一下源代碼實例

00:22:46.967 --> 00:22:51.638 
這段源代碼和你已經在程序中
使用的代碼看起來非常相像

00:22:52.139 --> 00:22:55.943 
可以看到
沒有任何不同也沒有新的結構標誌

00:22:56.176 --> 00:22:57.311 
這樣就可以使用

00:23:06.053 --> 00:23:09.990 
是的
你只需要一個HTTP/2服務器

00:23:11.725 --> 00:23:12.593 
但是這不是問題

00:23:17.030 --> 00:23:22.135 
你的應用程序已經準備好了
使用HTTP/2協議來進行通信

00:23:22.569 --> 00:23:25.639 
如果你還沒有
部署一個HTTP/2服務器

00:23:26.673 --> 00:23:30.777 
那麼你的應用程序
將會直接使用HTTP/1.1

00:23:31.512 --> 00:23:36.483 
或者會自動選擇最優的可選的協議
用來進行網絡通信

00:23:37.284 --> 00:23:41.054 
一旦你開始使用
支持HTTP/2的網絡服務器

00:23:41.755 --> 00:23:43.924 
你就不再需要做額外的工作

00:23:44.725 --> 00:23:48.061 
你的應用程序將會
自動使用HTTP/2協議

00:23:56.503 --> 00:23:57.371 
請記住

00:23:57.905 --> 00:24:03.577 
NSURL會話只在加密連接上
支持HTTP/2協議

00:24:04.845 --> 00:24:07.414 
這樣你的HTTP/2服務器

00:24:07.748 --> 00:24:12.352 
需要支持ALPN或者NPN
用來進行協議對接

00:24:16.990 --> 00:24:18.025 
目前在Apple

00:24:18.292 --> 00:24:20.761 
通過iCloud
遠程訪問HomeKit

00:24:20.827 --> 00:24:23.964 
就是在HomeKit配件
和iCloud之間

00:24:23.964 --> 00:24:27.801 
使用HTTP/2協議進行通信

00:24:29.036 --> 00:24:32.172 
很多大公司已經
開始使用HTTP/2協議了

00:24:32.673 --> 00:24:35.175 
Google爲其服務
也配置了HTTP/2

00:24:35.909 --> 00:24:38.278 
Twitter也使用了HTTP/2

00:24:39.413 --> 00:24:43.450 
有非常多的HTTP/2
開放資源網絡服務器

00:24:44.318 --> 00:24:51.024 
最後一些CDN服務提供商
也在逐步提供HTTP/2協議支持

00:24:55.062 --> 00:24:59.132 
我們努力使
HTTP/2能夠支持NSURL會話

00:24:59.366 --> 00:25:03.270 
這樣你們就可以非常容易地配置
使用HTTP/2協議

00:25:04.137 --> 00:25:07.674 
HTTP/2今天在
WWDC種子中也是可選的

00:25:08.208 --> 00:25:12.246 
它無縫集成在NSURL會話API中

00:25:12.746 --> 00:25:17.818 
並能夠在OS X 10.11和
iOS 9中的Safari上使用

00:25:19.553 --> 00:25:20.387 
謝謝

00:25:21.188 --> 00:25:24.091 
現在我想邀請丹上臺

00:25:24.591 --> 00:25:25.425 
丹？

00:25:31.598 --> 00:25:32.432 
早上好各位

00:25:32.733 --> 00:25:33.767 
我叫丹

00:25:33.767 --> 00:25:36.303 
我是一個軟件工程師
在蘋果公司CF網絡項目組工作

00:25:36.637 --> 00:25:38.472 
我想講的第一件事情是

00:25:38.539 --> 00:25:41.041 
今天已經可以在WatchOS上
使用NSURL會話了

00:25:42.276 --> 00:25:43.677 
通過本週前幾天

00:25:43.744 --> 00:25:47.281 
與WatchOS 2測試版
一起發佈的WatchKit SDK

00:25:47.614 --> 00:25:48.649 
我很高興能告訴大家

00:25:48.715 --> 00:25:51.518 
WatchOS
完全支持HTTPS加載

00:25:52.686 --> 00:25:54.988 
這就意味着
我們今天已經講的所有的東西

00:25:55.055 --> 00:25:58.825 
例如App Transport Security
和HTTP/2都支持HTTPS

00:26:00.661 --> 00:26:04.198 
在WatchOS使用NSURL會話

00:26:04.264 --> 00:26:07.301 
和在其他平臺上使用的
主要區別是在後臺運行

00:26:07.301 --> 00:26:11.271 
事實上我們會選擇所有選項中
最好的連接機制

00:26:12.005 --> 00:26:14.041 
這就意味着
在大多數情況下

00:26:14.408 --> 00:26:17.778 
如果用戶的手錶
靠近了配對的iPhone設備

00:26:18.212 --> 00:26:21.315 
我們會利用他們之間的藍牙連接

00:26:21.481 --> 00:26:27.187 
通過手機本身的HTTP加載
並將結果通過藍牙回傳給手錶

00:26:28.288 --> 00:26:34.394 
如果帶着手錶的用戶碰巧斷開了
或者遠離了他們的手機

00:26:34.661 --> 00:26:37.664 
手錶將會連接到已知的Wi-Fi網絡
這樣我們可以直接使用網絡了

00:26:38.332 --> 00:26:42.369 
好消息是
這些所有的工作都是脫離API進行的

00:26:42.369 --> 00:26:45.072 
當你在其他平臺上的時候
你可以使用API

00:26:45.072 --> 00:26:46.773 
你不需要關心我們是如何連接的

00:26:47.040 --> 00:26:48.375 
它就像魔法一樣

00:26:50.444 --> 00:26:53.247 
就如之前所說 在WatchOS
上使用NSURL會話時

00:26:53.247 --> 00:26:55.983 
只需要關注
少數幾個最佳方法和事情即可

00:26:56.717 --> 00:27:00.721 
首先你應該儘可能的
只下載最小的安裝包

00:27:00.721 --> 00:27:02.756 
這其實是你的程序的功能的要求

00:27:03.390 --> 00:27:06.827 
請注意 手錶只有一個非常小的屏幕

00:27:07.160 --> 00:27:08.495 
所以如果你要下載圖片

00:27:08.562 --> 00:27:13.467 
不需下載在iPhone6 Plus
或配有Retina顯示屏的Mac上

00:27:13.534 --> 00:27:15.335 
顯示的完全分辨率圖片

00:27:15.702 --> 00:27:18.272 
它的屏幕太小了
你可以下載小一點的圖片

00:27:18.939 --> 00:27:20.507 
另外請記住

00:27:20.707 --> 00:27:26.046 
手錶比手機或電腦的處理能力要小很多

00:27:26.580 --> 00:27:31.785 
並且會經常受到帶寬
和與你手機的藍牙連接的延遲的限制

00:27:32.019 --> 00:27:34.321 
所以你並不能夠真正
如同在其他平臺上一樣

00:27:34.321 --> 00:27:35.923 
快速地下載字節到手錶上

00:27:35.923 --> 00:27:37.124 
所以也請記住這一點

00:27:38.859 --> 00:27:40.294 
另一個需要注意的是

00:27:40.561 --> 00:27:44.431 
手錶上的程序運行時間

00:27:44.498 --> 00:27:46.800 
比iPhone或Mac上的程序
運行時間短很多

00:27:47.201 --> 00:27:49.269 
用戶會受到嚴重的時間限制

00:27:49.269 --> 00:27:52.940 
如果他想要坐着或者站着
並舉起手腕盯着手錶和它互動

00:27:54.408 --> 00:27:58.645 
所以如果你使用的是默認會話配置
或者臨時會話配置

00:27:59.112 --> 00:28:04.651 
請記住這些網絡傳輸
只會在你的程序真正運行的時候進行

00:28:05.352 --> 00:28:08.121 
所以如果你要發送少量的數據
是完全沒問題

00:28:08.121 --> 00:28:10.557 
例如股票報價或者天氣數據

00:28:10.924 --> 00:28:12.593 
亦或者社交網絡狀態更新

00:28:13.093 --> 00:28:16.029 
但是對於任何比較大的內容
例如視頻

00:28:16.029 --> 00:28:18.165 
你會想用後臺上傳或者下載

00:28:18.498 --> 00:28:22.035 
這樣就能在過程結束時繼續

00:28:22.302 --> 00:28:24.171 
要了解更多有關後臺上傳下載的信息

00:28:24.238 --> 00:28:29.309 
我強烈建議你看看
前幾年基礎網絡大會上的WWDC會話

00:28:33.347 --> 00:28:37.484 
接下來我想講一下
我們在今年發佈的API中做的修改

00:28:38.585 --> 00:28:40.954 
我要講的第一件事情是NSURL連接

00:28:40.954 --> 00:28:42.890 
這個東西我們到現在爲止都還沒有講過

00:28:43.457 --> 00:28:44.291 
所以今年

00:28:44.358 --> 00:28:49.196 
我宣佈OS X EI旗艦版及
IOS9將放棄使用NSURL連接

00:28:50.163 --> 00:28:52.599 
讓我們花一點時間
來想一下這意味着什麼

00:28:52.666 --> 00:28:56.703 
放棄使用並不意味着
NSURL連接將會被完全放棄

00:28:56.770 --> 00:29:00.040 
我知道有很多程序
都在使用NSURL連接

00:29:00.240 --> 00:29:01.542 
我們並不會損壞它們

00:29:01.942 --> 00:29:04.077 
所以它仍然可以運行
這些傳輸方法仍然可以使用

00:29:04.945 --> 00:29:09.850 
但是請記住
新功能只會添加到NSURL會話中

00:29:11.552 --> 00:29:14.855 
我們強烈建議你
將現存的NSURL連接代碼

00:29:15.155 --> 00:29:18.158 
轉換成NSURL會話代碼
如果你還沒有轉換的話

00:29:19.393 --> 00:29:20.928 
如果你正在寫一段新代碼

00:29:21.528 --> 00:29:24.364 
我們真心希望你只使用NSURL會話
而不是NSURL連接

00:29:25.699 --> 00:29:26.834 
另一件需要注意的事情是

00:29:26.834 --> 00:29:29.937 
在WatchOS上
完全不支持NSURL連接

00:29:30.070 --> 00:29:33.073 
所以如果你要從WatchKit
擴展程序上加載HTTP內容

00:29:33.140 --> 00:29:34.708 
你只能使用NSURL會話

00:29:35.409 --> 00:29:37.544 
但如果你還沒有完成
那你是幸運的

00:29:37.544 --> 00:29:39.947 
從NSURL連接到
NSURL會話的轉換

00:29:39.947 --> 00:29:40.914 
會非常簡單

00:29:41.248 --> 00:29:43.083 
現在我想通過一個例子向你們展示一下

00:29:44.618 --> 00:29:47.020 
這是NSURL連接的一個簡單使用

00:29:47.087 --> 00:29:49.256 
<br/> 
用來實現一個異步的HTTP請求

00:29:49.256 --> 00:29:52.359 
它可能和你的程序中
經常使用的方法有點相似

00:29:52.960 --> 00:29:57.931 
現在我們通過HTTPS連接
www.example.com

00:29:57.965 --> 00:30:00.367 
我們通過一個NSURL對象來表示

00:30:01.168 --> 00:30:04.805 
然後我們構造一個
NSURLRequest對URL進行打包

00:30:05.672 --> 00:30:09.142 
我們通過NSURL連接的
“發送異步請求”方法

00:30:09.510 --> 00:30:11.979 
來出發這個異步請求

00:30:12.546 --> 00:30:15.949 
之後我們以一個閉包的形式接收到結果

00:30:16.817 --> 00:30:21.889 
接收到的結果包含一個NSURL
響應對象作爲HTTP響應信息頭

00:30:22.422 --> 00:30:26.360 
這個相應對象作爲HTTP響應信息頭
和NSData對象作爲響應的主體數據

00:30:26.560 --> 00:30:28.195 
如果傳輸發生錯誤則接收到一個報錯

00:30:29.263 --> 00:30:32.232 
看一下如果使用NSURL會話
實現起來會是什麼樣子

00:30:33.634 --> 00:30:34.568 
它非常相似

00:30:34.735 --> 00:30:38.972 
你會注意到
NSURL和NSURL請求對象仍然在使用

00:30:38.972 --> 00:30:42.743 
這對於很多其他的NSURL家族對象
來講是正確的

00:30:42.743 --> 00:30:47.181 
例如NSURL Credential Storage
和NSHTTP Cookie Storage

00:30:47.447 --> 00:30:48.582 
其主要區別是

00:30:48.582 --> 00:30:51.885 
我們不使用NSURL連接
來發送異步請求這種方法

00:30:52.252 --> 00:30:58.392 
我們使用NSURL會話共享會話中的
 “數據任務請求”方法

00:30:59.560 --> 00:31:00.928 
一旦我們恢復任務

00:31:01.028 --> 00:31:05.065 
我們就能夠再次接收到
異步地接收到事務處理的結果

00:31:05.432 --> 00:31:08.635 
以回覆數據的格式
回覆信息頭

00:31:08.635 --> 00:31:11.171 
如果傳輸發生錯誤則接收到一個報錯

00:31:12.272 --> 00:31:14.341 
在你的程序中

00:31:14.408 --> 00:31:17.177 
將NSURL連接轉換成NSURL會話
非常簡單

00:31:19.279 --> 00:31:20.514 
接下來我想換個話題

00:31:20.514 --> 00:31:24.952 
講一下我們在API的
NSURL會話家族中添加的新功能

00:31:26.153 --> 00:31:29.022 
我要講的第一件
就是對cookie的處理

00:31:30.324 --> 00:31:31.859 
在去年的WWDC上

00:31:31.925 --> 00:31:34.795 
我們介紹了一個新的功能
叫做應用程序擴展

00:31:35.062 --> 00:31:38.599 
它允許你在系統的其他地方
嵌入你應用程序的部分功能

00:31:38.599 --> 00:31:39.933 
例如通知中心

00:31:41.602 --> 00:31:47.174 
但是應用程序和他們的擴展
在默認情況下擁有不同的數據存儲器

00:31:47.241 --> 00:31:49.476 
這就意味着即使你使用NSURL會話

00:31:49.476 --> 00:31:53.213 
且已經使用了
我們內置的cookie進行支持處理

00:31:53.480 --> 00:31:55.849 
這些cookie實際上仍然被存儲在
不同的地方

00:31:57.751 --> 00:32:00.087 
但是你可以使用應用程序組

00:32:00.254 --> 00:32:03.090 
來訪問共享數據存儲器

00:32:03.090 --> 00:32:05.692 
這個存儲器無論是你的應用程序
還是其擴展部分都可以訪問

00:32:06.059 --> 00:32:08.328 
今年我們發佈了新的API

00:32:08.562 --> 00:32:11.632 
你能夠創建一個與組存儲器
相關聯的cookie存儲

00:32:12.432 --> 00:32:14.034 
我將要向你們展示一下怎樣實現它

00:32:14.601 --> 00:32:19.173 
這裏你需要用到的
是NSHTTP cookie存儲中

00:32:19.173 --> 00:32:22.009 
新增的“共享cookie組存儲器
標識符”方法

00:32:22.576 --> 00:32:24.778 
你只需要簡單地
創建一個cookie存儲

00:32:24.845 --> 00:32:28.215 
並輸入你的應用程序組的名字

00:32:28.749 --> 00:32:33.086 
在你用Xcode編輯工程的
編譯設置選項和打開功能選項卡時

00:32:33.086 --> 00:32:34.188 
程序組就已經被配置好了

00:32:35.622 --> 00:32:37.224 
當你創建好cookie存儲的時候

00:32:37.457 --> 00:32:43.330 
你只需像設置NSURL會話配置對象中的
HTTP cookie存儲屬性一樣設置它

00:32:43.964 --> 00:32:46.500 
從配置中創建一個NSURL會話

00:32:46.533 --> 00:32:49.903 
之後你在這個會話中進行的任何任務

00:32:50.070 --> 00:32:52.306 
都會使用組存儲器中的
cookie存儲

00:32:56.476 --> 00:32:58.779 
所以對於今天演示的所有內容

00:32:58.779 --> 00:33:03.183 
我們講解了
使用NSURL加載HTTP內容

00:33:04.218 --> 00:33:08.121 
但是仍然有一些情況需要你使用一個
除了HTTP或者HTTPS之外的

00:33:08.188 --> 00:33:10.023 
其他的協議

00:33:10.557 --> 00:33:13.594 
所以如果你正在開發一個聊天軟件

00:33:14.728 --> 00:33:20.434 
一個視頻調用軟件
或一切這一類的其他軟件

00:33:20.434 --> 00:33:23.637 
你真的需要...
你可能需要一個非HTTP的協議

00:33:23.637 --> 00:33:28.242 
你想要直接在
TCP/IP網絡上做一些事情

00:33:28.775 --> 00:33:31.845 
所以今年發佈了一個新的API
叫做NSURL會話工作流

00:33:32.012 --> 00:33:35.449 
這是一個底層提取文件
直接在TCP連接層上

00:33:36.550 --> 00:33:39.753 
在過去你可能
直接使用NSInput流

00:33:39.753 --> 00:33:42.656 
或者NSOutput
留來做一些相似的事情

00:33:42.890 --> 00:33:48.061 
但是我們認爲NSURL會話工作流
有在NSStream API的優點

00:33:48.662 --> 00:33:53.033 
首先它提供了一個
非常簡單方便的異步讀寫接口

00:33:53.767 --> 00:33:55.169 
通過NSStream

00:33:55.235 --> 00:33:59.640 
你需要設置一個委託來監聽事件
或者何時讀入或者何時屏蔽讀寫

00:33:59.640 --> 00:34:02.509 
從前這樣做會有點亂
但是現在變得簡單清晰了很多

00:34:03.677 --> 00:34:04.511 
第二

00:34:05.078 --> 00:34:09.449 
NSURL會話內置了強大的支持功能
能夠自動通過HTTP代理

00:34:09.850 --> 00:34:12.418 
NSURL會話工作流
可以利用這種支持

00:34:12.418 --> 00:34:14.788 
這樣你就能夠連接一個遠程的服務器

00:34:15.022 --> 00:34:18.525 
即使在這之間有一個HTTP代理
但是NSStream不能夠這樣做

00:34:19.359 --> 00:34:21.428 
API還有一些其他的新的升級

00:34:21.428 --> 00:34:23.030 
這些我也將隨後進行介紹

00:34:24.498 --> 00:34:26.900 
我們都知道NSStream
是一個非常流行的API

00:34:26.900 --> 00:34:32.306 
也有很多其他的構架和API中
兼容並使用了NSStream對象

00:34:32.806 --> 00:34:35.809 
所以我們也有一些與
NSStream相兼容的支撐部分

00:34:35.809 --> 00:34:37.411 
這些我也將在之後爲你們呈現

00:34:39.513 --> 00:34:43.650 
所以就像我說的
MNSURL會話工作流支持TCP/IP連接

00:34:43.951 --> 00:34:47.020 
你可以明確地通過一個主機名稱和端口
創建一個連接

00:34:47.321 --> 00:34:50.157 
或者你可以使用
NSNetService的API

00:34:51.291 --> 00:34:53.193 
在你的應用程序中
查找Bonjour服務

00:34:53.527 --> 00:34:57.097 
之後我們能夠接受
NSNetService爲你自動解決問題

00:34:58.632 --> 00:35:02.503 
工作流使用了
現存的NSURL會話配置選項

00:35:02.503 --> 00:35:05.839 
和委託方法來向你傳達事件

00:35:07.374 --> 00:35:10.410 
當然我們支持TLS安全連接

00:35:10.410 --> 00:35:14.214 
一旦你確實與服務器建立了一個連接
你甚至能夠進行動態修改

00:35:16.416 --> 00:35:20.287 
所以讓我們看一下
你怎樣使用工作流來實現一個讀取操作

00:35:20.854 --> 00:35:22.222 
首先創建一個工作流

00:35:22.289 --> 00:35:26.493 
這樣你就能夠簡單地使用
“帶有主機地址和端口的工作流”

00:35:26.627 --> 00:35:29.363 
你只需要輸入你想要連接的
主機名和端口號

00:35:30.330 --> 00:35:31.999 
然後恢復任務後

00:35:32.432 --> 00:35:36.336 
你可以使用“讀取最短長度
最長長度、或者超時”等方法

00:35:37.137 --> 00:35:41.241 
你需要做的就是
輸入一個你要讀取的字節範圍

00:35:41.441 --> 00:35:42.943 
或者操作超時的時限

00:35:43.343 --> 00:35:45.579 
所以如果我們準備
讀取範圍內的東西

00:35:45.579 --> 00:35:49.416 
或者我們遇到了一個EOF
或者發生了傳輸錯誤或者超時

00:35:49.416 --> 00:35:52.052 
我們將會調用存儲結果的閉包

00:35:53.253 --> 00:35:54.521 
寫入操作非常相似

00:35:55.556 --> 00:35:58.992 
我們不像...通過NSStream
我們可以直接操作NSData

00:35:58.992 --> 00:36:01.195 
你只需要輸入
你想要我們寫入的NSData對象

00:36:01.195 --> 00:36:03.263 
以及再次輸入一個超時門限

00:36:03.530 --> 00:36:05.732 
在出現錯誤時
這個內容爲零的閉包將會被調用

00:36:05.732 --> 00:36:09.870 
當這個操作成功或者發生了超時錯誤
或者發生了傳輸錯誤

00:36:11.371 --> 00:36:16.276 
啓用TLS和對這個任務調用
“打開安全連接”的思想一樣簡單

00:36:19.112 --> 00:36:19.947 
我之前提到了

00:36:20.013 --> 00:36:25.152 
我們有配合NSStream工作的
內置支持NSURL會話工作流

00:36:25.586 --> 00:36:27.487 
我們這樣做的原因是

00:36:27.487 --> 00:36:30.591 
有非常多的API已經
使用了NSStream對象

00:36:30.591 --> 00:36:33.360 
我們希望爲你提供一些東西
能夠和這些API兼容

00:36:34.027 --> 00:36:38.065 
事實上你可以將NSURL會話工作流
轉換成NSStream

00:36:38.131 --> 00:36:40.834 
在下一張幻燈片上我會用
非常簡單的代碼來爲你們演示一下

00:36:41.335 --> 00:36:42.903 
只需要記住當你做這些的時候

00:36:42.970 --> 00:36:48.041 
任何你使用工作流加入隊列中
掛起的異步讀寫任務

00:36:48.308 --> 00:36:50.210 
都將在我們給
你NSStream之前完成

00:36:50.644 --> 00:36:53.647 
這樣的操作也會從會話中分離出任務

00:36:54.014 --> 00:36:55.082 
所以這個鏈接

00:36:55.315 --> 00:36:58.619 
底層鏈接將不再計入限制

00:36:58.619 --> 00:37:02.022 
你可以爲你的主機
設置一個會話鏈接的最大數量

00:37:03.056 --> 00:37:07.728 
它也不再在會話設置中突出任務選項

00:37:08.729 --> 00:37:10.697 
所以要將一個工作流轉換成流

00:37:10.697 --> 00:37:13.800 
你只需要在任務中簡單地
調用‘Capture Streams’方法

00:37:14.168 --> 00:37:19.873 
之後這些輸入和輸出流將會
給你的委託發送一個新的委託消息

00:37:22.042 --> 00:37:26.780 
我們同樣有許多已經添加到
工作流中的其他委託消息

00:37:26.847 --> 00:37:27.981 
第一個很有意思

00:37:27.981 --> 00:37:30.517 
這是一個爲工作流尋找更優路徑的方法

00:37:31.118 --> 00:37:36.023 
所以如果你有一個工作流
通過蜂窩數據網絡連接到了你的服務器

00:37:36.423 --> 00:37:39.259 
如果用戶新加入一個Wi-Fi網絡

00:37:39.426 --> 00:37:43.163 
之後我們會發送這個通知到你的程序
告訴你可能會有更好的連接路徑

00:37:43.830 --> 00:37:46.099 
在這種情況下你可能想要做的

00:37:46.300 --> 00:37:49.303 
如果你想要做的話
就是清除你現存的工作流

00:37:49.369 --> 00:37:52.806 
並創建一個新的工作流
到那臺主機和端口

00:37:54.508 --> 00:37:56.610 
並嘗試通過更好的鏈接進行連接

00:37:56.877 --> 00:37:59.613 
我們將這個決定權
留給你決定是否要這麼做

00:38:00.280 --> 00:38:03.350 
如果你在傳輸一個很大的數據
並已經完成了99%

00:38:03.417 --> 00:38:07.054 
就沒有必要清除現存的連接
並創建一個新的連接

00:38:08.021 --> 00:38:10.724 
當讀寫雙方的後臺TCP連接
已經被關閉時

00:38:10.791 --> 00:38:13.861 
我們也要告訴你一些信息委託方法

00:38:16.763 --> 00:38:21.468 
我之前也提到了
通過工作流對HTTP代理的自動處理

00:38:21.902 --> 00:38:24.004 
針對這種情況
你能夠做的就是

00:38:24.304 --> 00:38:28.809 
打開一個正在處理HTTP內容的
NSURL會話數據工作

00:38:29.109 --> 00:38:30.711 
並將其轉換成一個工作流

00:38:31.612 --> 00:38:35.015 
當接收到數據工作的回覆時
你可以做這些

00:38:36.216 --> 00:38:38.519 
所以要將一個數據工作轉換成工作流

00:38:38.519 --> 00:38:42.256 
讓你能不通過HTTP構架
直接在HTTP連接層直接通信

00:38:42.689 --> 00:38:46.126 
通過“確實接到回覆”委託方法

00:38:46.126 --> 00:38:48.161 
你能夠簡單地
對這個完成處理器進行回覆

00:38:48.161 --> 00:38:50.264 
利用最新的“成爲流”設置

00:38:50.931 --> 00:38:52.866 
然後你會通知你的委託

00:38:53.166 --> 00:38:55.736 
通過使用“URL會話數據任務
確實成爲了工作流”方法

00:38:55.802 --> 00:38:59.206 
數據任務已經轉換成爲工作流

00:39:02.009 --> 00:39:03.110 
在結束今天的演講前

00:39:03.177 --> 00:39:06.446 
我想要回顧一下
今天早上討論的幾件事情

00:39:07.347 --> 00:39:11.018 
第一件事情是怎樣使用
App Transport Security

00:39:11.318 --> 00:39:14.555 
來保證你的應用程序
能夠只建立安全連接

00:39:14.555 --> 00:39:17.457 
以及在需要的時候怎樣申報異常情況

00:39:18.058 --> 00:39:20.127 
之後我們講了
通過服務器上支持HTTP/2

00:39:20.127 --> 00:39:22.029 
怎樣讓你的應用程序能夠更快

00:39:22.262 --> 00:39:25.599 
其不需要對客戶端進行額外的修改

00:39:26.433 --> 00:39:29.970 
我們講了在手錶應用程序上
使用NSURL會話的最優方法

00:39:30.404 --> 00:39:33.941 
以及這次發佈的新API做了哪些修改

00:39:34.007 --> 00:39:37.144 
NSURL連接的棄用
和如何遷移到會話

00:39:37.711 --> 00:39:40.280 
怎樣在應用程序
和擴展之間共享cookie

00:39:40.681 --> 00:39:44.151 
以及如何獲得一個很好的基礎級別提取

00:39:44.151 --> 00:39:47.254 
如果你需要一個沒有HTTP的服務器

00:39:47.287 --> 00:39:49.122 
使用TCP連接進行通信

00:39:51.758 --> 00:39:52.726 
像往常一樣

00:39:52.793 --> 00:39:57.364 
我想提醒你們我們在
網站開放有參考文檔

00:39:57.731 --> 00:40:00.801 
並提醒你參加開發者論壇

00:40:00.801 --> 00:40:03.937 
以及在這周的WWDC大會上
如果你有任何問題

00:40:04.104 --> 00:40:06.707 
你可以向我們的傳播者
Paul Danbold請教

00:40:07.508 --> 00:40:10.978 
如果你想參加其他的相關會議的話

00:40:10.978 --> 00:40:12.546 
我強烈建議你參加明天的

00:40:12.713 --> 00:40:15.215 
“你的應用程序和下一代網絡會議”

00:40:15.215 --> 00:40:17.584 
這是一個低層次的關於網絡的討論會

00:40:18.118 --> 00:40:21.321 
這周也將開放網絡實驗室

00:40:21.321 --> 00:40:23.357 
如果你有任何問題
你都可以直接和我們討論

00:40:23.824 --> 00:40:25.559 
謝謝你們今天能夠到來

00:40:25.993 --> 00:40:27.494 
我們希望看到

00:40:27.561 --> 00:40:29.363 
你們在IOS 9和OS X
和EI旗艦版和WatchOS 2上

00:40:29.429 --> 00:40:32.032 
能夠開發一些驚豔的應用程序

00:40:32.232 --> 00:40:33.066 
謝謝