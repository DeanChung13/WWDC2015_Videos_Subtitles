CloudKit技術講座
<br/> 大家下午好 歡迎參加
CloudKit技術講座 
我是尼哈 沙爾曼 
是CloudKit團隊的工程師 
我知道 你們一些人可能對我們的平臺十分陌生 
而且是首次遇到CloudKit框架 
而其他一些人可能已經開發一些APP並且在應用商店中上架 
在本講座 我們將介紹一些對所有人都適用的技術 
現在讓我們開始 
什麼是CloudKit？
去年我們推出了CloudKit
<br/>這是一種全新的方法 
讓你能夠與Apple的iCloud數據庫服務器對話 
利用此功能
我們爲你提供一系列的內置技術 
例如大文件存儲等 
我們提供隱私保護標識符
讓你能夠有效地管理
任何擁有iCloud帳戶的用戶 
首先也是最重要的
這是一個公開的開發者API 
因爲我們想希望你利用這個平臺的強大功能 
爲你的用戶開發有用的APP 
最後但並非不重要的事情是
<br/>Apple大力投資 
開發這項技術 
僅在去年當我們首次發佈此項技術時 
我們就去推出
一系列重要的客戶端
包括iCloud drive
和iCloudphoto library
今年我們增加了一些新客戶端 
例如 Notes APP News APP
和WWDC APP 本週你們很多人使用過這些APP
而且你們的手機上還有這些APP 
如果你不熟悉這些應用 
我請你回顧一下
去年的開發大會上的
CloudKit講座
和AdvancedCloudKit講座 
這些講座詳細地介紹了新API 
我強烈建議你去看看 
我們來先講重要的事情 
你們很多人一直在使用
令人稱道的Swift 2新功能 
我很高興宣佈對於iOS 9操作系統 
在Swift中使用CloudKit將會更加容易 
讓我們來通過一些例子
來深入瞭解 
直到現在 當你在CK記錄中設置和獲取值時 你還必須
使用陳舊的鍵值對象設置語法使用對像語法設置鍵值
這些工作將由CloudKit API來完成 
但是在iOS 9中  在處理CK記錄時 
你可以使用更爲熟悉和
現代的字典訂閱語法 
除此之外 我們還利用庫標識符和輕量級泛型
讓你在Swift中編寫的CloudKit代碼
和Objective-C代碼
更不容易發生類型錯誤 
以前你可能需要爲記錄設置一組任意類型的對象
來確保安全和正確的CKRecords運算 
現在利用iOS 9中的最新工具 
當你做這些工作時 編譯器會發出提醒 讓你及早發現錯誤 
編寫更可靠的代碼 
對此 請我簡要回顧
CloudKit存儲架構 
CloudKit的最頂層稱爲CloudKit容器 
它分爲兩個數據庫 
一個公用數據庫
它是你的所有用戶共享的
龐大APP數據 
另一個私人數據庫  
僅供用戶的iCloud帳戶使用 
這個數據庫包含
特定iCloud帳戶跨越所有用戶設備
所共享的數據 
在每個數據庫內 我們還有一個分層離  
用於存儲記錄 
它們稱爲記錄區 
CloudKit使用這些數據庫
爲你存儲在其中的記錄提供更多的功能
公用數據庫有一個稱爲默認區域的存儲區域
用於存儲所有記錄 
私有數據庫也有一個默認區域 
利用這一特性  你能夠創建
多個自定義區域 
這些區域可以爲你的記錄提供更多的功能 
讓我來介紹
我們將在今天的講座中所要探討的內容 
你可能還記得 在去年我們討論了schema 
我們介紹了一個APP的示例schema 
這個APP通過雲端將內容提供給各方 
這裏有一個簡單的schema其中有一個party記錄類型
和clown記錄類型 這兩個類型的記錄
存儲在公用數據庫之中讓我們來運行這個示例APP
並且爲它開發更多的功能
我們將這個示例APP稱爲clown central 
因爲它是關於小丑的  
我們將使用一個示例來介紹
當你使用CloudKit進行開發時 
可以運用的經驗和技巧 
我們的APP有一個簡單的UI
在這個UI中
我們顯示派對列表 在這個講座中 
我們將會介紹一系列的功能 
現在
通過示例我將會討論四個主要方面的內容 
第一個方面是錯誤處理 
去年 我們曾經講到過
CloudKit APP
是否處理錯誤
不僅關係到APP的好壞
甚至還決定APP是否
正常運行或者完全崩潰 
的確是這樣的  
當你使用API時 
你會遇到一組特殊的錯誤代碼 我會講解這些代碼 
併爲你提供一些一般性指導原則 
告訴你如處理錯誤 
對此
我們將會介紹一系列的技術 
你需要記住這些技術
當你維護本地緩存 
進行CloudKit開發工作時 可以使用這些技術 
然後我們將會討論如何設置訂閱 
以不斷地更新緩存 
最後我將介紹一系列的
通用性能技術你應該記住它們
並用於你的APP開發 
因此我們將會講解許多內容 
現在讓我們講解錯誤處理 
我首先要討論的事項是關於帳戶的 
CloudKit並不需要
你具有一個iCloud帳戶 
我們允許匿名只讀訪問公用數據庫 
比如說 爲了便於演示 
clown central APP將需要一個iCloud賬戶 
我們將討論一系列的功能 
這些功能使用私有數據庫 
根據定義 將需要一個通過身份驗證的帳戶 
默認情況下 數據庫寫訪問
需要一個帳戶 
需要注意的是 檢查當前用戶的
帳戶狀態的方法是使用CK容器內可用的
完成處理API進行檢查 
在進行CloudKit開發時 由於身份驗證而造成的錯誤
將會導致失敗 
並返回CKError身份未驗證錯誤代碼 
處理這種錯誤的一般性做法是
重新檢查帳戶狀態 
例如 缺少iCloud帳戶 
當你檢查賬戶狀態時 
你會收到“無帳戶” CKAccount狀態 
在以前
你沒有辦法知道
因爲帳戶缺失而失敗的請求
是否會繼續 
正因爲如此
在iOS 9和OS X El Capitan中 
我們添加了CKAccount變更通知 
當用戶帳戶發生變更時 
例如無登錄或退出 
或者iCloud drive功能開關
被開啓或關閉 將會發送此通知 
爲此 我想介紹一些最佳實踐方法 
以處理APP中的賬戶缺失錯誤 
一種看上去不錯的方法是
<br/>當遇到這種情況時 
拋出一個警告
告訴用戶他們沒有登錄iCloud
<br/>因此不能繼續 
但是這對用戶來說沒有幫助作用 
因爲他們可能會忽略警告
重新嘗試操作 
從而會繼續看到警告 
我們建議的方法是
巧妙地設置你的UI 
禁用需要帳戶的功能 
爲此你可以使用
CKAccount變更通知 
當你收到此通知時
<br/>應重新檢查用戶狀態 
查看帳戶是否可用
如果可用 則重新啓用UI 
帳戶缺失僅僅是
操作臨時發生故障的的原因之一 
但是它可能在未來的某個時間點發生 
例如 在較差的網絡條件下 
你可能遇到這種錯誤 CKError網絡故障 
或者CloudKit服務器忙時 也會發生這種錯誤 
你可能會看到以下錯誤之一：
CKError服務不可用
或CKError區域忙 
遇到這種錯誤時
你應該在稍後重試操作 
但是你可能會想 
我應該在何時重試這些操作？
你不需要猜想這個時間值 
發生這些錯誤時 在我們發送給你的用戶信息字典中 
在“CKError retry after key.”鍵值中
<br/>有一個專用的值 
這個值就是在重新嘗試操作之前 
需要等待的時間 單位爲秒 
現在讓我們來看一個類似的例子
在這個例中 我們的APP有一個bug 
可能導致APP 
在極短的時間內 向服務器發送大量更新 
如果這個APP始終這樣做
而且許多用戶觸發這個bug
將會導致iCloud服務器崩潰 
爲了避免這種問題 
我們需要使用一個
名爲CKErrorRequestRateLimited的
專用錯誤代碼 
CloudKit利用這種方法
避免APP bug造成
iCloud服務器崩潰 
如果請求數量達到限值 
在一定的時間期限內
將不發送請求給服務器
那麼這個時間期限是多少呢？
系統通過“CKErrorretryafterkey”
來告知這個時間期限 
因此 當你遇到這種錯誤時
請在用戶錯誤信息字典中查找這個鍵值 
請等待一定時間 然後重試你的請求 
現在我想介紹你可能會遇到的
另一種不同類別的錯誤 
這類錯誤是由於schema設計方式造成的 
具體地說
如果你的schema 允許多個用戶更新
Cloud數據庫中的同一條記錄 就可能發生這類錯誤 
假設我們想要爲APP增加一項功能 
從而允許用戶
將他們自己添加到派對之中 
但是不幸的是
在設計此APP的schema之前
我們並沒有參加去年的關於高級CloudKit的講座 
這是我們設計的schema 
對於派對記錄本身
我們決定存儲
一個引用數組 它指向想要
參加派對的人員記錄 
現在你可以看到 每當我想要添加一個參加者
到一個特定的派對時 
我們都會修改同一個派對記錄
讓我們通過一個例子來瞭解 當兩個不同的用戶
想要將他們添加到派對時 將會發生什麼 
由於WWDC bash晚會即將開始 
因此讓我們將這個記錄
保存到CloudKit 
在我們瞭解當兩個用戶下載此記錄時
將會發生什麼之前
我想介紹一下
記錄變更標記(record change tags)是什麼  
你可以認爲它們是一個字符串
<br/>服務器使用它
來標識特定的記錄版本 
保存在服務器上的記錄版本
通過變更標記A表示 
它是CKRecords的只讀屬性 
但是隻有已經保存的記錄纔會有這個標記 
假設兩個用戶John和Alice都下載
這個特定的記錄版本 
你可以看到他們接收相同的變更標記A 
現在 John首先將他自己作爲參加者添加到派對 
然後嘗試將他的記錄添加到服務器 
現在這條記錄被保存  我們將John的變更標記  
也就是A 發送到服務器 
服務器發現變更標記匹配 
因此接受John的更改 
由於服務器記錄版本已發生變化 
服務器將生成新的變更標記 在本例中 此標記爲B 
並通過記錄保存響應消息 將它發回給John 
現在Alice上線了 她決定參加派對 
她嘗試相同的操作 將她自己添加到數組中 
並嘗試保存她的記錄版本 
這時你會看到
她發送舊的變更標記A
服務器將會提醒 
她正在嘗試修改已經不存在的
服務器記錄版本 
她遇到了衝突 
在她的設備上
CloudKit
通過“CKerror:server record changed” 
專用代碼向她告知這種衝突 
其背後的機制並不神祕 
我們不必想辦法
來解決這種衝突 
你自己就可以解決 
因此我們會爲你提供
儘可能多的有用信息 
讓你能夠自己解決衝突 
當更新請求被拒絕時  我們爲你提供的最早
也是最重要的信息是
服務器中的記錄版本信息 
在哪裏可以找到這些信息呢？
同樣地 你可以在用戶錯誤字典中找到它 
在本例中其值是CKRecordchanged
errorServerRecordKey鍵值 
在本例中 當我們將它
用戶錯誤信息字典中提取出來時 
我們會發現服務器中的記錄
已經記錄John將會參加派對 而且會發新的變更標記B 
現在 除了服務器記錄之外 
我們還會爲你返回更多的信息 
這些包括在Alice對記錄進行任何修改之前的
原始記錄鍵值 
以及客戶端記錄鍵值 此鍵值包含
Alice嘗試保存到服務器的記錄 
現在 我想強調的是  
在大多數情況下在解決衝突時
最重要的事情 也是你需要做的事情是 
在發生錯誤之前 及早保存你所做的修改 
而不是等待錯誤響消息
向你返回服務器記錄 
在本例中 你獲取服務器記錄 
我們將對想要保存的這條記錄進行相同的修改 
也就是把Alice作爲參加者
添加到派對 包括她和John
<br/>並將這個記錄版本
保存到服務器 
你會發現服務器中的變更標記爲B 
當我們保存記錄時 這些變更標記將匹配 
服務器將接受保存操作 
在這裏 我們應該知道
如果我們爲這項功能設計更好的schema,
我們可以避免這類錯誤 
稍後我將會討論schema 
你會發現 在嘗試修改相同記錄時 
每次不同的用戶都要進行這種修改 
這並不是最好的方法 
讓我們來瞭解一種新的schema 
讓我們來看CloudKit操作 
我想爲APP添加一個新功能 
以允許用戶存儲派對照片 
這次 我們需要在派對與照片之間
建立一對多的關係
照片將擁有它們自己的記錄類型 
但是我們不想將它們存儲到照片記錄 
我們應該怎麼做呢？
我們可以通過反向引用照片所屬的派對
來保存照片記錄 
你可以看到
當我們保存照片記錄時 
不需要更改照片所屬的派對記錄 
讓我們來瞭解如何保存這些記錄 
在我們的APP中
<br/>我們使用便利性API
利用完成處理操作保存記錄 
每次保存一個照片記錄 
但是
用戶可能一次存儲多張照片 
對於這種情況
目前我們使用便利性API
通過不間斷循環來保存多條記錄 
讓我們來看這些操作的
背後機制 
APP多次調用便利性API
來保存多張照片  
在系統中 必須通過一組默認值  
將它們封裝在CK操作中
當我們嘗試將記錄保存到服務器時  
這些操作中的每個操作至少發出一次網絡請求 
我們不希望所有這些請求導致服務器崩潰 
但是我們造成了系統瓶頸 
系統一次發送多個請求 
以保存這些記錄 
現在 除了這個瓶頸之外 
還需要考慮另外一件事情 
這些操作中的每個操作都請求一次保存一條記錄 
在本例中 
將會產生大量的網絡請求 
從CloudKit APP開發人員的角度來看 
這顯然不是一個好主意 
我們希望通過一次網絡請求
批處理這些記錄更新操作 或者 至少應該
使用最少的網絡請求來處理它們 
我們應該怎麼做呢？
我們使用與便利性API
相對應的CK操作 
幾乎每個一次處理一個項目的
便利性API都有對應的CK操作 
這些CK操作能夠批處理記錄更新 
在本例中 我們想要使用CKModifyRecords操作
將多個記錄作爲一個數組提供給記錄保存資產
以一次保存多個記錄 
讓我們來看此操作的背後原理 
現在我們可以將組合所有記錄
通過一次操作來保存它們 
此操作進入系統隊列 
系統能夠使用最少的請求數量 
保存這些記錄到服務器 
我們就消除了瓶頸 
同時 我們最大限度地
減少了請求數量 
我希望你們所有人在你的APP中
使用便利性API時 使用這項技術 
如果你考慮將它用於
在多個位置或同一個類型的循環中 處理同一種類型的請求 
應考慮使用CKOperation API
以批處理這些請求 
這將會減少請求數量 
同時提高系統的效率
好的 現在我們來討論批處理 
這是我們需要考慮的
另外一件事情 
服務器限制一次可以設置
的批處理數量 
這些限制包括
每個請求中的項目數量
和請求總數量 
請求總數量是
在隸屬於該請求的記錄中
設置的鍵值數據之和 
必須注意的一點是
<br/>通過CKAsset API
作爲批量存儲的組成部分存儲的數據量
並不會計入
這個鍵值數據 
但是 如果你的請求想要繞過任何此類限制 
你將會收到一個名爲
CKErrorLimitExceeded的專用錯誤代碼 
對於這種錯誤的處理方法 
我們通常建議開發人員將將項目對半拆拆分
成爲批處理 進行兩次操作而不是一次操作 
如果再次遇到相同的錯誤 
則應該進行同樣的拆分 
如果僅有批處理中的部分項目發生錯誤 應該怎麼辦呢？
由於批處理包括很多項目 
但是隻會返回一個錯誤 但是我們仍然希望向你
告知其中每一項錯誤 
爲此
我們使用一個名爲
CKError partial failure的專用錯誤代碼 
這是一個頂層錯誤代碼
你並不希望直接處理它 
但是與前面一樣 
在用戶錯誤字典中 
如果你按項目ID鍵值查找 CKPartial錯誤鍵值 
我們將會提供
與你的批處理錯誤相應對應的
項目ID字典 
例如 在本例中 有一個項目ID 
發生CKRecord無效參數錯誤
另外 批處理中的其他項目
可能發生錯誤 也可能沒有錯誤 
你需要打開這個字典 在字典中進行查看 
單獨處理該錯誤 
如果考慮自定義區域中的原子更新(atomic update) 
情況會略微發生變化 
需要注意的是 自定義區域
具有CKModify記錄操作功能 
能夠發送原子更新 
在這種情況下 服務器將整個批處理作爲一個操作予以接受 
或者拒絕整個批處理 
如果批處理中的一個項目
發生CKError無效參數錯誤（與本例相同） 
其餘項目ID將包含錯誤信息
和CKRecords批處理請求失敗專用錯誤代碼 
在處理原子更新時 
必須檢索字典內容 
處理未包含在
批處理請求失敗中的所有錯誤
關於如何通過優化方式將我們的照片記錄存儲到
Cloud服務器 我們就講到這裏 
下面我們來討論另外一半
<br/>即如何下載 
我們使用CloudKit查詢來進行下載 
現在 利用我們設計的schema  
下載特定派對的照片變得十分簡單 
在這種schema中 
照片記錄引用它們所屬的派對 
我們只需要創建一個CK查詢 
這個嘗試匹配將這個引用
與已知派對記錄ID進行匹配 
現在 如果我們發出查詢 以下載一個派對的照片 
一些派對可能有大量的照片 
我們是否需要全部下載它們呢？
讓我們來看如何使用CKQuery操作
發出特定派對照片
優化下載查詢 
首先需要解決的問題是：
我們並不知道有多少張照片隸屬於一個特定的派對 
我們應該下載多少張照片呢？
下載全部照片並沒有意義 
對於我們的UI來說 
應該回答這個問題 
如果你看一下我們這裏的示例UI 
你可以看到 當我們調出一個特定的派對時 
我們看到20張照片 
正確的做法是 
當我們首次發出查詢時 
查詢應僅返回20張照片給我們
我們可以使用CKQuery操作的結果限值屬性
來做到這一點 
當你不知道總共會返回多少個項目時  
這個屬性能夠幫助你
管理特定批處理中的項目數量 
因此 這個屬性也可以用於
CKFetch記錄變更操作 
此操作可能會返回大量的變更 
而你並不知道自定義區域
和CKFetch通知變更操作會返回多少個變更 
其原因與前面一樣 
好的 現在我們只想下載20個記錄 
這樣更簡單一些 
但是 我們可以做得更好嗎嗎？
讓我們來看我們的下載 
我們再次來讓UI爲我們回答這個問題
當我們查看一個特定派對時 
我們看到的是特定派對的經過裁剪和
縮小的縮略圖
但是我們存儲在照片記錄上
而且默認情況下將會完全下載的
可能是我們使用iOS設備
高畫質相機拍攝的
照片的高分辨率版本 
如果我們能夠將該信息添加到
我們的照片記錄
讓我們能夠調出部分記錄 將會很有幫助作用 
但是 我們如何調出部分記錄呢嗎？
我們通過對CKQuery操作
使用desiredKeys屬性來完成此任務 
在本例中
desiredKeys屬性接收一個鍵值屬性數組 
這些鍵值是符合查詢條件的
所有記錄的鍵值 
因此 如果我們將它設置爲thumbnail 
你可以看到 當查詢返回時 
載入的數據量大幅減少了 
這也可以用於CKFetchRecords操作 
在這種操作 你可能已經提前知道你想要獲取記錄的ID 
但是你的UI
或者因其他原因 你只想要
下載部分記錄 
另外 也可以用於CKFetch記錄變更操作 
默認情況下 此操作下載任何已經變更的記錄的
全部記錄內容 
現在 如果我們只想顯示20張照片 當我們首次向用戶
顯示這些照片時 
照片應該以特定的順序顯示 
假設我們想要按照
照片在iCloud上的存儲順序
顯示這些照片 
我們可以對CKQuery設置sortDescriptor 
並使用這些描述符初始化CKQuery操作 
你可以看到 在這裏我們將sortDescriptor
設置爲創建日期鍵值 這是一個系統字段 
保存在服務器上的所有CKRecord都有這個字段 
我們將它設置爲降序 
在這裏 需要注意的是 由於它是一個系統字段 
因此你需要可以在服務器上使用此字段進行排序 
你可以通過iCloud Dashboard進行此設置 
應該在保存記錄之前
進行此項設置 
否則 在設置之前保存的記錄
將不會有此項索引值 
我們想要獲取所有記錄中的小部分記錄 
你可能會想 
如何向用戶顯示其餘記錄？
假設用戶開始向下滾動 
想要查看下一批照片 
在這種情況下 我們如何實現分頁顯示？
我們通過分析查詢處理語句返回的結果
來處理這個問題 
當查詢完成時 
我們不僅獲得查詢返回的所有結果 
還獲得一個CKQueryCursor 
這是一個不透明的標記符 
顯示你在整個查詢結果中所處的位置 
因此你應該存儲
首次查詢操作返回給你的QueryCursor
當你想要
獲取下一批結果時 
你可以始使用先前存儲的Cursor初始值 
傳遞這個值 來初始化
另一個CKQuery操作 
當我們通過這種方式優化CKQuery操作時 
應確保對新查詢操作設置相同的必要鍵值 
和結果返回數量限值 
這將優化下一批照片查詢結果 
關於下載記錄就是這些 
現在我想要切換主題 
介紹一些在使用CloudKit時
維護本地緩存方面的技術 
讓我們首先來討論一項新功能 
假設我們希望用戶能夠爲派對添加一些
簡短的個人評論 
假設這些評論是個人化的 
我們想要將它存儲到用戶的私人數據庫之中 
我們不想要在用戶每次查看或修改這些評論時 
獲取這些評論 
我們希望提供
提供某種離線訪問功能 
你可以看到 在這種情況下 
我們需要的是在特定的設備用戶上
提供少量的數據 
在這情況下使用CloudKit時 
維護本地緩存是不錯的做法  
讓我們先來看如何從私人數據庫
下載內容 
前面講過 我們能夠將記錄存儲到私人數據庫中的
自定義區域 此區域爲我們提供一些附加功能
讓我們來進行這些操作 
我們在私人數據庫中創建一個新區域 
其名稱爲NotesZone 
我們可以通過兩種方法 獲取此區域中的數據 
與前面一樣 我們可以使用CKQuery操作 
並對它進行優化 方法與前面一樣 
我們還可以通過CKRecordsFetch操作
使用delta下載 讓我們僅獲取
區域中僅發生變更的記錄 
我們說過 此操作只適於
具有獲取變更功能的區域
目前 私人數據庫中的所有自定義區域
都具有此功能 
如果你想要更詳細地
瞭解delta下載的工作原理 
我建議你
回顧去年的高級CloudKit講座 
這個講座詳細地介紹這種操作是如何工作的 
假設我們想要使用這項功能 
我們開始獲取變更記錄 
我們將APP對象存儲在
一個本地數據庫之中 它可能是核心數據 
或你選擇的其它數據庫 
在這個位置我們編碼APP對象 
這裏有一個party對象 
我們爲它添加了一個notes鍵值
對應於用戶爲這個派對添加的評論 
我們將APP編碼到本地存儲 
當處理相應的CKRecords時 
我們想要將記錄存儲在Cloud之中 
我們可能考慮編碼整個CKRecord 
因此我們緩存這些記錄和我們的APP對象 
讓我們來看會發生什麼 
你可以看到 CKRecord還具有爲其設置的
所有APP對象鍵值 
當然 在我們編碼時
我們會複製所有的APP鍵值 
當我們編碼APP對象之後 
以及當我們編碼CKRecord時 
這就是我們想要的 
你看到 CKRecord對象中的橙色字段
屬於CKRecord 
服務器通過這些字段
來識別記錄的特定版本 
它們稱爲系統字段 
在本例中 你真正的想要是的
記錄的系統字段的編碼方法 
你可以使用編碼系統字段和
編碼器API對CKRecord進行編碼 
你需要使用這些代碼
對這些系統字段進行編碼 
我們強烈建議你使用這種方法 
如果遇到這樣的情況 你需要回顧以往的講座 
現在讓我們來看當我們開始編碼系統字段時將會發生什麼 
我們想要高效地存儲
CKRecord的重要信息和相應的party對象 
現在 讓我們來看 嘗試修改一個party對象時  
將會發生什麼 
我們已經使用前面所述的方法存儲這個對象的系統字段 
爲此 我們使用CKRecord的編碼器初始化函數 
你可以看到 當我們調用它時 
我們獲得先前存儲的所有系統字段 
爲了簡潔起見 我僅顯示記錄ID和我們已經看到的
變更標記 
對於這個CKRecord 你完全可以設置
此記錄發生變更的鍵值 
比如說 我們想要變更派對名稱 
將派對名稱更改爲WWDC bash 
我們爲這個鍵值設置爲新的值 
並在服務器上保存新記錄 
必須指出的是 當存儲記錄的變更值時  
你不必設置記錄的
所有鍵值 
我們正式地維護和存儲
本地緩存 讓我們來看如何從自定義區域
獲取變更值 以使緩存保持爲最新 
與前面一樣 我們使用
CKFetchRecordChanges操作
來完成這個任務 
此操作提供區域中所有已經發生變更的記錄 
真正的問題是 應該在何時使用此操作？
因爲 單獨使用此操作並不會告訴我們 
存儲區域在何時已經發生變更 
爲此 我們需要
通過CKSubscription API來使用通知 
更具體地說 由於區域中的變更
並不是你想通知給用戶的變更 
因此在這裏我們應該使用靜默通知 
在下一節中 我將介紹
始何啓用並運行訂閱 
尤其是當你想要使用靜默訂閱時 
讓我們簡要回顧
什麼是訂閱?
訂閱內容是根據
用戶存儲在服務器上的定期內容查詢請求而提供的
你或你的APP通過這種方法
接收相關內容變更遠程通知 
有兩種類型的訂閱 它們的不同之處在於
你如何定義哪些變更是你需要關注的
第一種是查詢訂閱
允許你存儲一個預設條件 
如果變更符合預設條件時 
就是你所需要的變更 
第二種是區域訂閱 在這種方法中 
區域中的每次記錄修改
都被計爲一個相關變更 
因此 很明顯 在本例中 我們需要靜默通知 
當我們的區域發生變更時 將會發送此通知 
但是 我們首先需要了解當你處理各種CloudKit訂閱時
所需要的常規設置 
對這個設置 我想強調的是 
如果遠程通知並非來自於CloudKit. 
你仍然需要
設置遠程通知 
讓我來闡明其含義 
首先 你仍然需要在開發者門戶中 
爲這個APP ID 開啓APS功能 
當你開啓CloudKit功能時 
將會自動爲你開啓此功能 
第二 在測試你的APP而且預計會收到遠程通知時  
你需要在你的APP中將APS環境鍵值
設置到P列表之中以用於開發工作 
第三 你仍然需要
通過UI應用API進行註冊 
如果你計劃在你的App中顯示用戶通知
至少 你需要調用遠程通知註冊  
並且提醒用戶 
註冊用戶通知設置
由於我們需要靜默通知 
而且會通過CloudKit服務器
向我們發送通知 我們應該如何告訴服務器 
此通知應該是靜默通知呢？
我們通過與CK訂閱相對應的
CKNotification信息來完成這個任務 
我們將它作爲入口點
告訴CloudKit服務器應該發送哪種類型的
推送內容和以哪種優先級進行發送 
讓我們來說說優先級 
如前所述 我們配置CKNotification信息 
以告訴CloudKit服務器
這是一個靜默通知 
它需要以低優先級發送 
如果你爲CKNotification
信息設置這些鍵值 
服務器將爲你發送高優先級推送內容 
無論它是提醒正文 徽標或聲音名稱 
我們將它們稱爲訂閱使用的UI鍵值 
如果你發送其中任何一項 
服務器將發送高優先級推送內容 
這意味着 需要立即發送 
所有其他推送內容將會以中優先級發送 
並計入靜默通知數量 
讓我們來看你需要
什麼樣的靜默通知設置 
首先 你需要爲你的APP
開啓遠程通知後臺模式 
你可以通過Xcode中的功能窗格來啓用它 
你應該記得選中該選項 
第二 你應該確保
你實現的APP
接收遠程通知 
獲取應用委派的API
完成處理通知
將會在後臺調用其他版本 
在計劃使用靜默通知時 
請確保已經實現這個版本 
第三 我們需要再一次告訴CloudKit服務器 
通知是靜默推送通知 
我們如何配置CKNotification信息呢？
首先也是最重要的 
你應該將
shouldSendContentAvailablent屬性
設置爲true.
這個屬性告訴CloudKit服務器 
在你的推送內容中 應該包含
可用內容鍵值 
其次 你應該爲CNotification信息
設置我們前面所述的UI鍵值 
目前並不支持同時設置這些屬性和
shouldSendContentAvailable屬性 
這將會導致服務器錯誤 
現在 讓我們探討靜默推送內容送達 
我們已經配置與推送相關的所有設置 
我們將於何時獲得推送內容呢？
由於這些通知的目的並不是爲了提醒用戶 
因此係統將會在適當的時機
發送這些通知 
在決定何時發送這些通知時  
系統將會考慮各種因素 
通常來說 推送是盡力而爲的 
也就是說 推送可能會被合併
甚至被丟棄 具體視設備狀況而定 
例如 如果在需要接收緊急通知時  
設備處於飛行模式 當設備退出飛行模式時 
Apple推送通知服務器僅會向設備發送
確實需要接收的最後一條推送通知 
現在 我們有辦法來解決這個問題 
因爲我們可以使用CloudKit通知 
具體來說
CloudKit服務器存儲需要發送到你的設備的
所有通知 
我們將它稱爲通知集合 
因此當你接收靜默通知時 
應該確保從這個通知集合中
獲取變更通知 
你可以通過CK
FetchNotificationChanges操作來完成 
因此 當我們獲取靜默通知時 我們檢查
是否有任何丟失的通知 
而且我們知道我們的區域已經發生變更 
這也是我們獲得通知的原因 
在這種情況下 我們使用
CKFetchRecordChanges操作
來查看我們的區域內發生了哪些變更 
和前面討論的一樣 
我們並不知道區域內發生了多少變更 
因此這可能一個長時間運行的操作 
如果操作需要較長的時間來完成 
我建議你考慮使用
針對UI應用的後臺任務API 
這將允許你分配更多的時間
給你的操作 直到操作完成 
現在 在我們開始討論通知之前 我需要告訴你們 
在iOS 8中 我們引入了一個全新的通知類別 
稱爲交互式通知 
它允許用戶在信息條 
提醒界面或通知中心處理推送通知 
利用CloudKit 你可以將大量的請求
配置爲交互式通知 
我很高興地告訴你們 在iOS 9中你只需要很少的設置 
就可以完成此操作 
同樣地如果CKNotification信息
設置新的類型屬性 
當註冊用戶通知設置時  
這個屬性將對應於
你使用UIMutable
NotificationCategories註冊的標識符
只需要進行這些設置 
就可以通過CloudKit運行交互式通知 
<br/> 謝謝 
結合這些功能 我想介紹一些
你應該掌握的一些常用性能技術 
在使用CloudKit開發APP時 
你應該使用這些技術 
CloudKit是高度異步API 
大多操作在網絡上進行 你經常會遇到
許多具有依賴關係的任務 
而且你需要保持特定的任務完成順序 
當針對這些任務實施任務管理時 
需要實現一些目標 
你們需要記住一些重要的目標 
首先 很明顯 
無論你使用什麼樣的技術 你都需要
爲每個CloudKit任務
實施良好的錯誤處理方法 
其次 由於這些操作是異步操作 
你應該確保在任何情況下 
避免阻止主線程
和降低它們的UI性能 
最後但非不重要的是 作爲開發人員 
你應該確保你的任務管理方案能夠保持良好的代碼可維護性
當你爲APP添加新功能時 代碼應該便於分析 
調試和擴展 
讓我們來看一些方法 
並且瞭解一些技巧和缺點 
第一點是不要嵌套便利性API調用 
讓我們來看一個簡單的例子 
在前面所述的schema中 如果我們想要修改
一個派對參加者記錄 請不要在實際中編程中 
使用這個schema 
但是 當你使用便利性API時 
如果你想要修改派對參加者記錄 你就必須這樣做 
你首先需要使用ID獲取記錄 
然後嘗試獲取
參加者想要參加的派對的記錄 
然後從參加者數組中
找到參加者記錄ID 然後對參加者記錄進行修改 
然後嘗試保存記錄 
當需要修改一條具有很多依存關係的字段的記錄時 
你必須執行這些操作 
你會看到一大堆
雜亂無章的代碼 
你不知道在哪裏處理哪些錯誤 
以及如何最合理地重試這些操作 
除此之外 還需要
考慮另外一件事情 
假設用戶的某些APP操作
導致我們需要進行這些操作 
如果一個用戶後續操作
而導致不再需要這些任務 
由於這些任務已經進入隊列 
你將無法取消這些任務 
如果它們的運行時間很長 當它們運行時 
你將無法進行其它操作 你必須等待它們完成 
當你管理相關依賴的任務時 尤其是在你需要
對批量記錄進行相同的修改時 
我們建議你不要使用這種方法  
另一種方法是消除API的異步性質 
這可以使用信號燈
並且等待信號燈來實現 
在一些情況下 這也會變得十分複雜 
你不應該嘗試這樣做 
如果你這樣做 你應該知道 
尤其是在你的長時間等待操作完成時 
你很容易遇到
循環式的依賴關係 
而導致APP陷入死循環 
或者 如果你想對主線程使用這種方法 
在網絡上等待被處理的操作
將會導致UI停止響應  
從而嚴重影響用戶體驗 
因此我們不建議這樣做 
我們建議你查看
NSOperation 提供的依賴關係管理API 
就是這個API 
NSOperation讓你能夠輕鬆添加
和消除其他NSOperations之間的依賴關係 
讓我們來看如何使用
CKOperations實現這一點 
CKOperations是NSOperations的子類 
如果有兩個互相依賴的獲取記錄操作 
而且第二個操作應該在第一個操作完成之後開始 
你只需設置這兩個操作 
將第一個獲取操作設置爲第二操作的先決條件 
然後將這兩個操作送入隊列 
這將保證在第一個獲取操作完成之前 
第二個獲取操作不會啓動 
你會看到 這提供一個符合邏輯的方法 
讓你能夠發現特定操作的錯誤 
並且能夠方便地
管理它們的依賴關係 
現在 當我們從性能的角度
考慮NSOperations時 
我希望你們思考
另外一個不同之處 
並非所有NSOperations都是同等的 
有些NSOperations 可能是因爲用戶在APP中的
顯式操作而產生的 
其他一些NSOperations示操作
則可能是一些低優先級的後臺任務 
爲了向系統告知
這些NSOperations的相對重要性 
在iOS 8中 我們爲NSOperations.
引入了服務質量屬性  
你可以用這個屬性指定NSOperation封裝的
作業的性質和重要性 
可以將這個屬性
設置爲不同的服務質量級別 我建議你們
查看相關文檔 來瞭解各個服務質量等級
以及它們的重要性 
在這裏 需要記住的一點是 
這個服務質量值直接影響NSOperation的
資源分配優先級 
例如CPU時間、磁盤資源和網絡資源 
現在結合去年推出的CloudKit
<br/> 我們想要爲你提供類似的方法  
讓你能夠將低優先級CKOperations
優化成爲自主性網絡行爲 
我的意思是
優化非用戶發起的任務 
預取用戶內容 就像我們在前面
使用CKRecords獲取記錄變更操作
來響應靜默通知所作的那樣 
你需要將這些任務優化成爲自主性行爲 
使系統在合適的時機
執行這些網絡請求 
在決定何時執行這些請求時 
系統會考慮很多因素 
例如蜂窩網絡連通性等 
系統可能會等待網絡連通性改善之後 
再發送這些請求
另外還會考慮電量等 
如果用戶設備電量過低 
或者設備未在充電 系統將會等待
電量增加之後 再發送這些請求 
我們通過使用
CKOperations的
userBackgroundSession屬性來實現這一點 
在iOS 9中
我們可以
極大地簡化和統一這些功能
這兩個概念
我們通過服務質量來推測你的網絡行爲 
同時應用特定服務等級參數
向系統發送的所有其他設置 
這就是我們使用的方法 
我們不建議用戶使用後臺會話屬性 
而建議你爲所有CKOperation操作
設置服務級別 
現在 對於網絡行爲  
可以設置將服務級別設置爲
UserInteractive
或UserInitiated 
來優化這些自主性行爲
對於自主性行爲 
你可以設置utility值 
在這種情況下 
系統將推測 是否根據發送請求的APP
在前臺或在後臺運行來優化自主性行爲 
從而始終會產生自主性網絡行爲 
請記住中 如果你在iOS 9
和OS X El Capitan或後續版本中開發APP 
默認情況下 所有新CKOperations
將具有後臺服務質量級別 
你應該確保審查所有CKOperations,
查看它們所代表的
作業的重要性 
應該保持良好的系統性能 
爲這些操作合適的QS值 
NSOperation是功能強大的API 
你可以使用它實現很多功能  
如果你想了解更多信息 我強烈建議你們
參加明天上午在Presidio舉行的高級NSOperation講座 
作爲總結
我想重新強調
CloudKit代碼中的錯誤處理方法很重要 
它與功能一樣重要 
我希望你們反覆檢查你的代碼 
查看你的所有操作 
弄清楚你遇到哪些類型的錯誤 
以及你是否遵守了今在我們所講述的
關於錯誤處理的一般性指導原則 
第二 應該批處理你的請求 
當你發現你的APP使用便利性API,
一次處理一個項目
而且在多個位置進行這樣的處理時 
你應該考慮使用該API的CKOperation版本 
並且批處理這些請求 
你不僅會全面提升
系統的操作執行效率 
而且會減少網絡請求數量 
應考慮優化schema 
我們看到兩種情況
需要我們優化schema...
讓我們能夠獲得優化的好處 
例如 當我們爲照片記錄
添加縮略鍵值時
<br/>我們可以僅下載需要的數據
從而能夠優化下載性能 
在另一種情況下 當我們避免
某些派對照片被修改時
<br/>當我們爲派對存儲照片時 
可以避免發生整個類別的錯誤 
因此 在設計功能時  
請認真思考你的schema 
最後並非不重要的是
應該配置你的CKOperations 
它們是功能非常強大的API 
它們提供大量的優化特性讓你能夠優化
發送至CloudKit服務器的
網絡請求 
要想獲取更多信息 請訪問我們的文檔地址是
developer.Apple.com/CloudKit.
關於其他所有問題和解答 
可以諮詢技術支持部門 論壇和CK支持網站 
對於一般性諮詢
請發送郵件至CloudKit@Apple.com 
這周我們舉行了一些很不錯的講座 
我希望你們回去後觀看這些講座視頻 
瞭解Web服務新功能
和CloudKit其他新功能 
明天上午9點 
我們還會在Frameworks lab D
舉行另外一場講座 
請準備好你們的問題 我們將樂意爲你解答 
謝謝 