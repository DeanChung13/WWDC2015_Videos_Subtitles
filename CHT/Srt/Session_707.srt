00:00:19.319 --> 00:00:24.558 
全天電池續航的會議

00:00:24.725 --> 00:00:25.626 
早上好

00:00:30.297 --> 00:00:33.500 
感謝您來觀看關於
實現全天電池續航的會議

00:00:34.101 --> 00:00:36.737 
很興奮能夠和您討論這個領域

00:00:37.204 --> 00:00:39.139 
我是來自於Core OS
的 強·安德魯斯

00:00:39.206 --> 00:00:41.408 
同時我的同事
桑仁·斯碧絲也將加入我們

00:00:42.910 --> 00:00:46.413 
我希望你們所有人
昨天晚上都把手機充滿電了

00:00:46.480 --> 00:00:48.248 
而且在這個早晨不要看它

00:00:49.316 --> 00:00:51.218 
我們希望你能在當天晚些時候再去看

00:00:52.085 --> 00:00:55.189 
事實上 我們想讓你看到
它比你已經看到它的時間要晚

00:00:56.190 --> 00:00:57.357 
我們將會討論

00:00:57.891 --> 00:01:01.128 
在iOS的環境下如何去實現
全天電池續航的一些具體內容

00:01:03.263 --> 00:01:06.166 
我們將會談到
用戶對於全天電池續航的期待

00:01:07.434 --> 00:01:14.074 
計算做出改進後的大致功耗

00:01:14.975 --> 00:01:19.112 
你在幫助我們實現
全天電池續航中的任務

00:01:19.780 --> 00:01:22.249 
之後 桑仁 也將會更深入的

00:01:22.316 --> 00:01:26.019 
指導你們怎樣改進程序
從而實現這些目的

00:01:27.855 --> 00:01:30.057 
先讓我們瞭解一下
究竟什麼是電池全天續航

00:01:31.925 --> 00:01:36.096 
用戶在一天中不是一直使用他們的手機
8或者10個小時

00:01:36.997 --> 00:01:39.600 
他們實際上只是在某個密集的時間
纔會使用它

00:01:39.666 --> 00:01:42.603 
可能是他們在早上上班的時候

00:01:43.103 --> 00:01:45.906 
然後手機就會被閒置

00:01:46.373 --> 00:01:47.975 
那麼它就可以做一些後臺工作

00:01:48.041 --> 00:01:51.578 
比如維護工作和網絡通信
或下載郵件等

00:01:53.013 --> 00:01:56.049 
這種模式將會持續一整天
伴隨着工作負載的激增

00:01:56.950 --> 00:01:58.552 
隨後出現了一段空閒階段

00:02:00.020 --> 00:02:04.124 
爲了實現全天續航
需要保持一個較低的功耗

00:02:06.293 --> 00:02:10.531 
因此在一天中平均的功耗都很低

00:02:12.900 --> 00:02:17.804 
而那就是我們在關注操作系統的過程中
一直去努力追求的目標

00:02:20.407 --> 00:02:24.912 
因此讓我們看一下
計算功耗的基本原理

00:02:25.879 --> 00:02:29.082 
首先功耗有兩個要素 功率和時間

00:02:29.883 --> 00:02:32.219 
而時間因素經常被忽略

00:02:33.820 --> 00:02:39.293 
你可以做些耗費很多功率的密集操作

00:02:39.893 --> 00:02:41.762 
但你需要知道它工作多長時間

00:02:43.430 --> 00:02:47.167 
如果在待機的狀態下
它並不會消耗過多的功率

00:02:48.101 --> 00:02:50.704 
但是你可以在很長的一段時間內
保持在待機狀態

00:02:51.638 --> 00:02:55.475 
對於我們的設備來說
播放音頻是另一項低功率的應用

00:02:55.742 --> 00:02:58.045 
因此可以提供很長的播放時間

00:02:59.112 --> 00:03:02.583 
但是當你進一步加強工作負載時

00:03:03.116 --> 00:03:07.521 
消耗的功率也會隨之增加
所以我們才希望你能減少使用設備時間

00:03:09.356 --> 00:03:14.161 
如果工作負載像空閒狀態那樣
實現全天續航將會變得非常簡單

00:03:15.729 --> 00:03:18.265 
只要在平均功耗很低的情況下

00:03:18.332 --> 00:03:23.337 
意味着也可以產生
比較高的功率脈衝

00:03:25.138 --> 00:03:27.808 
現在我們的設備正在增加動態範圍

00:03:29.042 --> 00:03:32.279 
我們正在開始接近MacBook領域

00:03:32.346 --> 00:03:34.815 
在這裏你可以從系統中獲取可觀的性能

00:03:34.882 --> 00:03:36.416 
所以你需要非常小心的去使用它

00:03:37.618 --> 00:03:38.685 
其它要記住的事情就是

00:03:38.752 --> 00:03:40.754 
隨着我們不斷的增加動態範圍

00:03:41.255 --> 00:03:45.425 
每一代的硬件效率也變得更好

00:03:45.926 --> 00:03:50.764 
因此我們將會給你更好的能力
去實現這些低功耗的操作

00:03:51.431 --> 00:03:54.801 
但是你也可以爲了
實現密集操作或者超爽的用戶體驗

00:03:55.269 --> 00:03:58.238 
去使用更高的峯值性能

00:04:00.107 --> 00:04:03.310 
因此讓我們從一個應用程序
生命循環週期的角度去審視它

00:04:05.345 --> 00:04:08.982 
這幅圖中的區域
表示被應用程序所使用的功耗

00:04:10.450 --> 00:04:13.253 
你啓動應用程序時
有些需要進行的工作

00:04:14.688 --> 00:04:18.358 
比如去初始化應用程序
可能在開始的時候有一些動畫

00:04:19.091 --> 00:04:23.697 
當你的用戶與應用程序進行交互時
可以會有一些活動的爆發

00:04:24.965 --> 00:04:27.835 
你需要記住的是
那樣可能需要一些固定的消耗

00:04:28.335 --> 00:04:32.840 
而且那些功耗正是
被系統和功耗所正使用的

00:04:33.340 --> 00:04:35.776 
而那時用戶的工作負載是最重要的

00:04:37.377 --> 00:04:40.214 
當用戶結束使用應用程序之後

00:04:40.380 --> 00:04:44.218 
你希望在應用程序
進入後臺時可以進行一些操作

00:04:44.718 --> 00:04:46.954 
然而最終應用程序被暫停了

00:04:48.288 --> 00:04:52.759 
在這兒我們可以看到
有着固定和動態損耗的時間因素

00:04:54.628 --> 00:04:59.099 
現在我們也只需要
從一個系統的角度來考慮

00:05:00.300 --> 00:05:03.337 
那麼就讓我們看看
系統在待機狀態中的情況

00:05:05.706 --> 00:05:08.275 
在這裏絕大部分的組件
都處於睡眠狀態的形式下

00:05:09.543 --> 00:05:14.214 
屏幕是關閉的
內存也處於一種低功耗的

00:05:14.982 --> 00:05:17.117 
刷新模式下

00:05:17.918 --> 00:05:23.056 
只有一些無線電在開着
僅允許接收傳入的流量或者喚醒系統

00:05:24.157 --> 00:05:25.859 
這種模式的功耗非常低

00:05:27.794 --> 00:05:32.332 
然後我們討論一下用戶閒置的情況
在這兒有更多系統的組件被喚醒

00:05:34.034 --> 00:05:39.640 
你也可看到顯示屏處於開啓運行狀態
這帶來了一些伴隨着的的軟系統

00:05:41.508 --> 00:05:45.279 
其他的組件
例如CPU 和GPU等

00:05:45.946 --> 00:05:49.583 
絕大多數是不活躍的並且閒置時間短

00:05:49.950 --> 00:05:51.652 
因此這個週期也很低

00:05:52.586 --> 00:05:56.890 
如果我們把它做成動畫
並且展示功耗可能會是什麼樣子的話

00:05:57.090 --> 00:06:01.195 
那麼在一天當中
用戶的電池消耗將會得到很好的減緩

00:06:01.595 --> 00:06:05.832 
希望在進入夜晚
你準備睡覺時爲手機充電

00:06:08.302 --> 00:06:13.207 
然而假如你想運行
大功耗的程序比如3D遊戲

00:06:13.774 --> 00:06:16.310 
這將會使用系統的絕大部分

00:06:17.077 --> 00:06:19.746 
你已經讓所有的組件都處於運行狀態

00:06:19.813 --> 00:06:26.486 
爲了讓GPU複雜的渲染跑起來
你可能正在使用大量的CPU

00:06:27.020 --> 00:06:31.992 
播放遊戲音頻會導致音頻系統啓動

00:06:32.926 --> 00:06:39.900 
因此預期的使用功率稍高
電池持續的時間相應的也會比較短

00:06:45.572 --> 00:06:51.311 
對於這三個組件
我們有一個非常簡單的策略去優化功耗

00:06:52.346 --> 00:06:53.780 
你想做更少的工作

00:06:55.582 --> 00:07:00.187 
就需要考慮一下工作
是否需要現在去做或者隨後再做

00:07:02.689 --> 00:07:06.593 
最終進行那項工作的時候
需要設法儘可能高效率地完成

00:07:09.329 --> 00:07:12.900 
桑仁 將會在下次討論的部分
涉及到更多的細節問題

00:07:15.302 --> 00:07:17.137 
那麼讓我們討論一下
在iOS 9下的情況

00:07:18.438 --> 00:07:21.475 
我們的已經有了一流的電池續航能力

00:07:22.342 --> 00:07:24.011 
然而我們確實認爲我們能夠做的更好

00:07:24.912 --> 00:07:26.847 
除此之外我們的顧客
也希望我們做的更好

00:07:27.314 --> 00:07:28.415 
你也希望我們做的更好

00:07:29.550 --> 00:07:32.853 
我們開始通過優化
操作系統和集成的應用程序

00:07:33.654 --> 00:07:35.789 
從而在現存的硬件中促進電池續航

00:07:37.024 --> 00:07:41.395 
去增加電池的額外一個小時的壽命

00:07:42.963 --> 00:07:45.999 
現在我們的做法
對於你們中的一些人可能很熟悉

00:07:46.066 --> 00:07:48.936 
因爲我們在OS X Mavericks中
曾有過相似的努力

00:07:50.137 --> 00:07:53.373 
我們取消了應用程序
框架和驅動程序的輪詢

00:07:53.440 --> 00:07:54.508 
我們優化了內核

00:07:56.276 --> 00:08:00.180 
同時把我們的服務質量
應用到我們的線程中

00:08:00.948 --> 00:08:03.016 
採用了更多的NS操作

00:08:03.750 --> 00:08:06.153 
以及用更加正確的服務質量
去安排輸入輸出

00:08:08.021 --> 00:08:13.093 
我們結合定時器去減少CPU

00:08:13.594 --> 00:08:16.029 
以及像午睡app這樣速率限制的
應用程序的喚醒次數

00:08:17.364 --> 00:08:21.502 
從系統的角度來看
重新執行我們的CPU電源管理單元

00:08:22.002 --> 00:08:24.538 
功耗將會得到顯著的降低

00:08:25.439 --> 00:08:29.710 
然後我們添加了個非常受歡迎的特性

00:08:29.977 --> 00:08:34.181 
即爲電池目錄添加“重大能源”標示

00:08:34.414 --> 00:08:38.217 
從而使得你能夠看到哪個應用程序
正在從電池中消耗比較大的能量

00:08:40.687 --> 00:08:43.657 
因此現在回到iOS中
看一下我們怎樣應用這些措施的

00:08:44.191 --> 00:08:45.726 
我們之所以專注於iPhone

00:08:46.360 --> 00:08:50.931 
是因爲我們得到很多人的反饋說
希望提高iphone的電池續航能力

00:08:52.199 --> 00:08:56.236 
然而從某種程度上來說這些提高措施
已經應用到我們所有的iOS設備中

00:08:58.172 --> 00:09:01.208 
現在讓我們通過這三個組件的策略

00:09:02.643 --> 00:09:03.510 
以減少工作量

00:09:05.646 --> 00:09:11.285 
我們希望進一步優化閒置負載
以及特別關注睡眠定時器

00:09:11.919 --> 00:09:15.923 
在用戶完成交互之後
系統的絕大部分時間都用在睡眠上

00:09:16.323 --> 00:09:20.394 
現在是基於用戶在設備上的
操作基礎上去優化

00:09:21.094 --> 00:09:25.465 
他們與推送的交互究竟是否進行

00:09:27.267 --> 00:09:29.503 
我們減少CPU在空閒時刻
被喚醒的次數

00:09:29.837 --> 00:09:33.240 
我們已經給它添加了
關於屏幕檢測的一個很酷的特性

00:09:34.007 --> 00:09:37.878 
因此當手機屏幕面向桌面時

00:09:39.847 --> 00:09:41.215 
收到一條通知

00:09:42.082 --> 00:09:44.451 
屏幕不會爲處理那個通知而去亮起來

00:09:44.651 --> 00:09:48.088 
我們讓系統儘可能少的做準備工作

00:09:48.155 --> 00:09:51.525 
這樣 只有當用戶接電話的時候
通知才被提供給他們

00:09:54.027 --> 00:09:55.596 
現在開始後續的一些工作

00:09:58.031 --> 00:10:00.300 
我們做了很多努力去將工作推遲到

00:10:00.667 --> 00:10:02.669 
設備被充電時

00:10:03.504 --> 00:10:09.276 
進行用戶不需要的後臺和維持工作
是沒有意義的

00:10:09.676 --> 00:10:12.946 
他們可能是一個日常的活動
所以當給手機充電時可以完成一些操作

00:10:13.013 --> 00:10:16.650 
因爲我們知道用戶只會
在一天的某些時候給手機充電

00:10:18.151 --> 00:10:21.722 
因爲人們需要對Wi-Fi付費

00:10:21.855 --> 00:10:24.458 
所以連接Wi-Fi時
我們同樣也可以推遲網絡

00:10:25.626 --> 00:10:28.362 
然後我們甚至更多的
持續利用應用程序接口

00:10:28.695 --> 00:10:31.765 
使得當接收器開啓時

00:10:31.832 --> 00:10:36.537 
即使接收器在做一些後臺工作
我們也可以完成一些相應的工作

00:10:38.839 --> 00:10:42.743 
現在對於那項工作來說一切都很好
但我們想能更有效率的去完成那項工作

00:10:44.011 --> 00:10:45.179 
因此讓我們做一些改變

00:10:45.612 --> 00:10:47.714 
我們優化我們的iOS和網絡堆棧

00:10:48.182 --> 00:10:52.786 
去讓4G網絡
特別是4G接收器工作的更好

00:10:53.887 --> 00:10:55.689 
我們再一次優化我們的電源管理單元

00:10:55.989 --> 00:10:59.493 
去減少維持系統
在低功耗狀態而產生的消耗

00:11:00.661 --> 00:11:03.330 
我們已經降低了日誌記錄機制的消耗

00:11:03.830 --> 00:11:07.201 
以至於它們不能和系統進行交互

00:11:07.901 --> 00:11:12.706 
當然我們繼續優化
我們的numerics庫

00:11:13.173 --> 00:11:15.309 
使他們更好去優化每一個硬件

00:11:16.043 --> 00:11:18.846 
我認爲明天可能會有
關於那個話題的會議

00:11:22.082 --> 00:11:26.119 
所以我們談論一下用戶反饋
及怎樣添加進Mavericks中

00:11:26.620 --> 00:11:32.626 
我們已經設置好了電池
使其能夠顯示你的應用程序的使用方法

00:11:33.760 --> 00:11:38.632 
或允許給你提供
一些周圍環境因素的信息

00:11:38.699 --> 00:11:42.202 
以及給想提高電池續航的用戶一些建議

00:11:43.237 --> 00:11:44.838 
在這兒已經進入到更進一步的階段

00:11:45.205 --> 00:11:49.877 
添加每一個應用屏幕或後臺時間...

00:11:51.111 --> 00:11:52.312 
到這個設置面板上

00:11:53.080 --> 00:11:55.082 
所以你在角落裏可以看到一個控制

00:11:55.349 --> 00:11:56.850 
讓我們回過頭繼續向前走

00:11:57.417 --> 00:11:59.953 
你可以看到一個小的控制
可以讓您切換模式

00:12:04.992 --> 00:12:07.060 
然後我們已經添加了低功耗的模式

00:12:09.196 --> 00:12:13.500 
而用戶的偏好也將會影響電池的壽命

00:12:14.568 --> 00:12:17.571 
它將限制CPU以及後臺操作

00:12:17.638 --> 00:12:19.840 
導致以前我們引入的
後臺應用程序刷新機制

00:12:19.907 --> 00:12:21.808 
在這個模式下失效了

00:12:23.377 --> 00:12:26.747 
我們關掉自由裁量和後臺工作

00:12:27.114 --> 00:12:31.485 
所以如果你想在後臺完成預定的下載
在用戶退出前這些行爲是不被允許的

00:12:32.853 --> 00:12:34.488 
郵件獲取也被禁用了

00:12:35.122 --> 00:12:38.358 
是因爲如果收發太多的郵件
將會讓系統產生一個較大的功耗

00:12:41.161 --> 00:12:43.130 
我們已經討論了
關於操作系統的內容

00:12:43.530 --> 00:12:47.034 
現在讓我們談論一些將會幫助你
提高電池續航能力的事情

00:12:49.069 --> 00:12:53.340 
我們已經使用了一個相當周到的方式

00:12:54.875 --> 00:12:57.211 
把OS X上能量計移植到iOS中

00:12:57.277 --> 00:13:02.282 
從而能量計對iOS產生最顯著的影響

00:13:02.349 --> 00:13:08.388 
系統除了其它的儀器
我們又添加了定位儀

00:13:09.489 --> 00:13:13.193 
除了改善OS X的能源指南

00:13:13.894 --> 00:13:17.564 
我們還在網站上寫了個
全新的iOS能源指南

00:13:20.200 --> 00:13:22.236 
現在你能用這個指南做些什麼事情呢？

00:13:23.770 --> 00:13:27.107 
我們希望你能夠優化應用程序的功耗

00:13:27.908 --> 00:13:29.643 
給你一個簡單的例子吧

00:13:32.012 --> 00:13:33.547 
比如你正在全屏播放一個視頻

00:13:33.881 --> 00:13:37.084 
現在讓我們做一個優化
很可能像家裏的電視那樣

00:13:37.351 --> 00:13:38.986 
減少backlight
調整伽瑪補償

00:13:39.286 --> 00:13:42.856 
從而給出同樣視覺圖像

00:13:43.857 --> 00:13:44.691 
現在

00:13:46.260 --> 00:13:48.362 
這些措施將會使得功耗少量減少

00:13:48.662 --> 00:13:52.699 
但是因爲時間的因素
節省的功耗是相當可觀的

00:13:53.467 --> 00:13:56.003 
因此你在觀看全屏視頻的時候

00:13:56.136 --> 00:13:58.972 
我們也可以得到額外的續航時間
只是在這個機制非常簡單

00:13:59.673 --> 00:14:05.345 
一旦你想在屏幕上放置任何用戶界面
這個機制就會失效

00:14:06.013 --> 00:14:12.352 
我們也可以看到全透明用戶界面層的
全屏應用程序會完全禁用這個機制

00:14:12.419 --> 00:14:14.021 
這對於用戶沒有任何好處

00:14:18.892 --> 00:14:22.029 
在討論過OS X後
現在讓我們說說iOS

00:14:23.096 --> 00:14:25.232 
在早些時候我們推出了
的MacBook

00:14:25.532 --> 00:14:27.568 
因爲那是我們
第一個fanless系統

00:14:27.868 --> 00:14:30.137 
所以它會有點散熱的約束

00:14:30.637 --> 00:14:34.575 
而MacBook被設計爲
可以很好的應對突發性的工作負載

00:14:35.209 --> 00:14:39.279 
我們也已經對操作系統進行優化
讓它能與那些機器一起工作

00:14:40.180 --> 00:14:45.219 
你也應當用適當的線程服務質量去
去標記所有的工作

00:14:46.553 --> 00:14:50.190 
使用我們已經預裝在OS X上
可用的儀表和儀器

00:14:50.557 --> 00:14:52.826 
可以確保你
利用NSOperation和GCD

00:14:53.727 --> 00:14:55.629 
來對你的工作進行優先級的考慮

00:14:56.129 --> 00:14:59.566 
如果現在有用戶啓動的操作
確保它被儘可能的標記

00:14:59.633 --> 00:15:02.002 
但是如果它後臺工作的話
仍像那樣去標記它

00:15:02.669 --> 00:15:08.108 
而操作系統在爲這些任務
提供更強性能的同時

00:15:08.442 --> 00:15:13.113 
還會管理
該設備的電源和散熱

00:15:17.818 --> 00:15:21.321 
最後總結一下
我們知道了功耗是功率乘以時間

00:15:21.722 --> 00:15:25.092 
當你爲提高電池續航的能力
在思考怎樣優化應用程序的時候

00:15:25.759 --> 00:15:27.895 
一定要記住時間的因素是非常重要的

00:15:29.062 --> 00:15:30.964 
硬件的動態範圍正在變得更大

00:15:31.231 --> 00:15:36.470 
因此當你正在操作的時候
必須認真的考慮怎樣有效率的完成

00:15:36.737 --> 00:15:40.340 
進行這些工作時認真考慮
是否這些工作全部需要完成

00:15:41.675 --> 00:15:44.912 
爲了實現全天電池續航

00:15:45.579 --> 00:15:48.715 
你需要讓平均功耗盡可能的低

00:15:49.983 --> 00:15:53.287 
現在我將會把這個任務交給我的同事
桑仁 去更詳細的討論

00:16:01.862 --> 00:16:03.030 
早上好
謝謝

00:16:03.397 --> 00:16:05.732 
真的很高興看到
你們在這兒學習能量效率的知識

00:16:06.099 --> 00:16:11.438 
也很希望自己能夠幫助你們理解
代碼在電池續航中心是怎樣工作的

00:16:14.074 --> 00:16:16.410 
我們將討論兩大類事情

00:16:17.811 --> 00:16:21.582 
但是首先我們要從一些
強 已經討論過的原則開始

00:16:21.648 --> 00:16:22.883 
我們將把這個原則和用戶

00:16:22.950 --> 00:16:26.920 
及用戶爲何是在你的應用程序上
獲取正確的時間關鍵因素相互聯繫起來

00:16:27.654 --> 00:16:29.356 
我們也準備討論一下能量究竟去了哪裏

00:16:29.423 --> 00:16:33.126 
特別是CPU以及GPU對OS X
和iOS來說都是非常重要的

00:16:35.062 --> 00:16:38.298 
通過這一部分的討論
我將會詳細的向你們解釋

00:16:39.066 --> 00:16:44.371 
怎樣實現較低的平均功耗
從而最終實現全天的電池續航

00:16:45.038 --> 00:16:46.807 
此外我們也特別的討論一下iOS

00:16:46.874 --> 00:16:50.143 
在我們的iOS設備上
你可以利用的許多硬件組件

00:16:50.210 --> 00:16:53.413 
爲了讓電池能夠全天續航

00:16:53.480 --> 00:16:57.451 
需要同時注意功率和時間

00:16:57.751 --> 00:17:02.589 
最後我們談一下
怎樣把這些理論融入在你的開發過程中

00:17:02.689 --> 00:17:06.226 
以便每天你都能思考
一點關於功耗的東西

00:17:09.563 --> 00:17:12.398 
在更進一步討論之前
我們並不能看到太好的一面

00:17:12.766 --> 00:17:15.435 
但是如果你家的某個地方有個LED燈
請舉起你的手

00:17:16.670 --> 00:17:19.039 
好的 你們應該知道什麼是LED燈
很好

00:17:19.373 --> 00:17:21.775 
你們家裏可能還會留着一些白熾燈
我家確實還留着一些

00:17:21.842 --> 00:17:23.644 
最近我把冰箱中的白熾燈換掉了

00:17:23.710 --> 00:17:25.679 
而如果在冰箱中放LED燈泡
則很有意思

00:17:29.183 --> 00:17:31.585 
請不在家時仍然讓燈
一直開的人舉起你的手

00:17:33.353 --> 00:17:34.922 
好的 有一個人是那樣做的

00:17:34.988 --> 00:17:37.758 
他是我的辦公室同事
我準備給他一個艱難的時刻

00:17:38.392 --> 00:17:40.894 
他在辦公室時並不是讓燈一直開的人

00:17:42.863 --> 00:17:47.000 
關鍵是當我們換了LED燈的時候
功率可以明顯的降下來

00:17:47.601 --> 00:17:50.070 
而且我們也不會讓它們整天運行
不用的時候也會把它關掉

00:17:50.137 --> 00:17:51.271 
這樣的話時間也降下來了

00:17:52.339 --> 00:17:54.174 
在你的屋子裏可能有很多的設備

00:17:54.408 --> 00:17:57.578 
網絡 DVR甚至計算機和服務器

00:17:58.212 --> 00:17:59.646 
而這些設備都將會整天運行

00:17:59.713 --> 00:18:02.249 
因爲它們並不像燈泡那樣點着
或許你並不會關注它們

00:18:02.349 --> 00:18:05.552 
而我準備幫助你們
在軟件的角度去思考這些問題

00:18:05.686 --> 00:18:10.057 
因爲最終是軟件來控制硬件上
所有燈的開關

00:18:10.290 --> 00:18:13.026 
所以爲了實現電池的全天續航
我們必須讓燈的開關

00:18:13.093 --> 00:18:14.795 
在絕大部分的時間中都處於關閉的狀態

00:18:15.062 --> 00:18:17.097 
那麼讓我們談論一下具體的措施

00:18:17.831 --> 00:18:20.734 
因爲最終我們的目的
就是完成用戶驅動的工作

00:18:21.134 --> 00:18:23.837 
所以我們也希望用戶
能從電池的能量中獲益

00:18:23.904 --> 00:18:24.738 
他們已經實現了

00:18:25.472 --> 00:18:29.176 
軟件在很多時候都是很相似的

00:18:29.309 --> 00:18:30.878 
我現在有一些事情去處理
我能去做嗎？

00:18:30.944 --> 00:18:32.880 
哦 是的 可以
讓我們再一次完成它

00:18:33.580 --> 00:18:34.548 
不 不 不

00:18:35.249 --> 00:18:37.651 
我們必須消除
任何類型的輪詢或者計時器

00:18:37.918 --> 00:18:41.355 
計算機操作的比人類更加的快

00:18:41.655 --> 00:18:43.290 
確切的說在鍵擊之間

00:18:43.590 --> 00:18:45.692 
即使你是一個超快的打字
一分鐘可以打一百個字

00:18:45.759 --> 00:18:48.262 
在微秒時間尺度的鍵擊之間

00:18:48.662 --> 00:18:52.866 
我們仍然可以閒置部分系統
處理器將會在按鍵間隙處於休眠狀態

00:18:53.267 --> 00:18:55.636 
而當用戶利用鍵盤 鼠標
和計算機進行交互的間隙

00:18:56.403 --> 00:18:59.540 
對計算機來說仍有很多的運行時間

00:18:59.606 --> 00:19:03.510 
所以你希望你的軟件不要
按照計算機運行的速度運行

00:19:04.011 --> 00:19:06.380 
除非它直接爲用戶工作

00:19:08.015 --> 00:19:10.050 
你迴應用戶
那樣很棒

00:19:10.284 --> 00:19:13.320 
使用我們超強的硬件
然後回到空閒狀態

00:19:13.921 --> 00:19:15.455 
變得完全平坦
最後歸零

00:19:17.958 --> 00:19:19.560 
強 已經討論過延時工作了

00:19:19.793 --> 00:19:22.196 
很多時候你可以無限期的延時工作

00:19:22.262 --> 00:19:23.163 
我現在需要延時嗎？

00:19:23.230 --> 00:19:25.532 
並不需要
稍後或許會用到

00:19:26.600 --> 00:19:28.235 
但總的來說結果就是我們不需要延時

00:19:28.535 --> 00:19:29.636 
如果現在有少量的任務

00:19:30.137 --> 00:19:32.072 
而現在用戶不需要它

00:19:32.139 --> 00:19:35.642 
那麼最好將其推遲
可以說

00:19:36.210 --> 00:19:40.013 
“嗨 系統 請完成這個
如果有計時器的話”

00:19:40.080 --> 00:19:41.548 
在下個小時的任何時刻

00:19:41.615 --> 00:19:44.651 
希望你能給出十分鐘
或者其它有餘量的時間

00:19:45.786 --> 00:19:47.554 
如果沒有計時器的話
那麼只能完成上傳和下載了

00:19:47.621 --> 00:19:49.690 
因爲系統在隨後可能會安排其他

00:19:50.123 --> 00:19:51.658 
可能發生的工作

00:19:52.059 --> 00:19:53.794 
你也可以把所有的任務集中在一起

00:19:54.695 --> 00:19:58.465 
因爲批處理是獲得效率的重要途徑

00:19:58.665 --> 00:20:01.001 
你想打開那個硬件
但是把它打開需要一些功耗

00:20:01.068 --> 00:20:04.738 
而你希望在它被關閉之前去使用它

00:20:04.805 --> 00:20:07.708 
需要在硬件開啓狀態下
儘可能多的完成工作

00:20:08.208 --> 00:20:13.947 
我們能再一次降低功耗
節省時間是很重要的因素

00:20:14.715 --> 00:20:18.519 
這是我特別指出的有趣的關鍵信息

00:20:18.585 --> 00:20:22.122 
我們有所有的可用能源
但是你不能在電池上整天的運行

00:20:22.322 --> 00:20:24.858 
否則設備會變得很熱
而且電池也不能持續運行

00:20:25.425 --> 00:20:31.031 
我們真正想讓你考慮的是
佔用整個系統10%的負載

00:20:31.131 --> 00:20:34.101 
這些負載不僅是軟件
還包括你所做的其它操作

00:20:34.535 --> 00:20:38.038 
那麼你怎樣才能利用你可以實現的措施

00:20:38.305 --> 00:20:42.009 
把負載降到1/10或1/100呢

00:20:42.376 --> 00:20:44.978 
這是當你在屏幕上的情況
當你後臺的時候 我們需要的更少

00:20:46.180 --> 00:20:47.614 
這裏我要說一個比較壞的消息

00:20:48.081 --> 00:20:50.918 
我也對我們所有的硬件
做過一些這方面的研究

00:20:50.984 --> 00:20:52.819 
人們表現出就像...
哦不對

00:20:52.886 --> 00:20:55.689 
這也不是談話的要點
關鍵在於讓你去思考這個問題

00:20:56.623 --> 00:21:00.761 
大概百分之十到百分之五的負載之間
是僅在打開顯示器時產生的

00:21:01.828 --> 00:21:03.297 
現在顯示器打開之後的狀態良好

00:21:03.363 --> 00:21:07.201 
因爲用戶正在從系統中得到更多的好處
所以這有很大的希望不僅僅是一個通知

00:21:09.503 --> 00:21:11.038 
然後有百分之十的目標

00:21:11.672 --> 00:21:13.307 
這就是平均水平

00:21:13.373 --> 00:21:14.942 
這聽起來就像只實現了5%

00:21:15.275 --> 00:21:17.244 
在長週期下的確如此

00:21:17.578 --> 00:21:20.013 
但在短時間內爭取100%

00:21:20.180 --> 00:21:22.883 
將你完成的工作優先呈現出來

00:21:22.983 --> 00:21:25.452 
我們將會安排它

00:21:26.353 --> 00:21:29.523 
這部分就是這樣 你必須讓它
處於百分之5到百分之10之間

00:21:30.824 --> 00:21:34.094 
現在讓我們討論一下CPU和GPU

00:21:34.161 --> 00:21:38.198 
在OS X中CPU和GPU
會消耗大部分的能量

00:21:39.199 --> 00:21:40.133 
它們也是最具活力的

00:21:40.200 --> 00:21:46.640 
我們有非常強大的多核CPU
和大規模並行GPU完成各樣任務

00:21:47.241 --> 00:21:49.209 
然而如果你把設備插入電源的話

00:21:49.776 --> 00:21:52.212 
CPU和GPU一般來說
確實會消耗電池很多能量

00:21:52.779 --> 00:21:55.182 
在這兒你已經可以看到
我們已經完成了大部分工作

00:21:55.249 --> 00:21:58.018 
我們已經讓CPU開始運行了
同時也讓GPU運行一會兒

00:21:58.218 --> 00:22:00.921 
而事實上這並不會持續一整天

00:22:01.121 --> 00:22:05.225 
但如果這個對於
你工作方式非常重要的模式

00:22:05.626 --> 00:22:08.262 
如果這個模式持續的話
將會使得我們不能實現全天續航

00:22:08.328 --> 00:22:10.197 
因爲平均功耗太高了

00:22:14.034 --> 00:22:16.236 
那麼我們僅喚醒CPU又會怎麼樣呢？

00:22:16.503 --> 00:22:18.172 
是否有工作要做？
是否有工作要做？

00:22:18.238 --> 00:22:19.640 
是否有郵件？
用戶是否點擊過？

00:22:19.706 --> 00:22:20.741 
有沒有什麼事情發生？

00:22:21.542 --> 00:22:22.376 
嗨 服務器

00:22:23.210 --> 00:22:24.044 
不要那樣做

00:22:24.111 --> 00:22:25.679 
當喚醒CPU或者GPU時

00:22:26.513 --> 00:22:29.483 
我們需要大量的能量去讓他們加速

00:22:32.419 --> 00:22:33.353 
有工作要做麼？

00:22:35.722 --> 00:22:36.557 
沒有收到任何工作

00:22:38.458 --> 00:22:41.495 
所有你能看到的這些三角形
即使是iOS的三角形

00:22:41.562 --> 00:22:44.731 
也在5%到10%的範圍中
佔據了很重要的一部分

00:22:46.300 --> 00:22:47.901 
不要嘗試不必要的喚醒

00:22:48.502 --> 00:22:50.237 
在OS X上如果你整天喚醒CPU

00:22:50.304 --> 00:22:52.139 
那麼事實上你的電池
根本不能實現全天續航

00:22:52.206 --> 00:22:54.641 
即使你不運行
甚至只是做一些檢查工作

00:22:55.108 --> 00:22:55.943 
不要那樣做

00:22:56.009 --> 00:22:59.546 
GPU是一個時間尺度略有不同的怪物

00:23:00.848 --> 00:23:03.116 
它工作的頻率比
你需要喚醒GPU的頻率更高

00:23:03.183 --> 00:23:05.953 
甚至對於一些漂亮的圖形

00:23:06.019 --> 00:23:09.389 
在下一幀之前需要15ms

00:23:09.456 --> 00:23:12.860 
然而在1ms之內
GPU已經可以完成大量的工作了

00:23:15.562 --> 00:23:16.797 
現在讓我們討論一下性能

00:23:17.564 --> 00:23:19.666 
你來到這裏的目的是關注能源性能

00:23:20.100 --> 00:23:22.336 
而且你做事的時間效率也更高
完成任務的時間更快

00:23:22.402 --> 00:23:26.139 
這些對用戶是有好處的
對能源的效率也是一個關鍵因素

00:23:26.306 --> 00:23:27.207 
現在讓我解釋其原因

00:23:29.142 --> 00:23:31.144 
這裏是一個工作負載
而是一個固定的工作負載

00:23:31.211 --> 00:23:32.779 
它的狀態也不能持續下去

00:23:32.846 --> 00:23:34.548 
我只需要完成這個工作

00:23:35.949 --> 00:23:37.050 
但是它的工作負載很大

00:23:37.451 --> 00:23:38.952 
因此我可能需要優化我的代碼

00:23:39.019 --> 00:23:41.622 
可以訪問代碼的內部循環

00:23:41.688 --> 00:23:44.791 
做更少的內存訪問和傳統的性能工作

00:23:45.592 --> 00:23:47.227 
這樣就會使得執行更加的有效率

00:23:47.895 --> 00:23:48.962 
但功率增加了

00:23:49.496 --> 00:23:52.065 
然而時間卻又變短了

00:23:52.399 --> 00:23:54.034 
從而功耗可以大幅的降低

00:23:54.468 --> 00:23:56.570 
前面的工作做的非常好
但是我們能做的更好

00:23:56.670 --> 00:24:00.174 
可以將工作並行化
並使用多核

00:24:00.607 --> 00:24:03.610 
最後我們可以更瘋狂一點
讓GPU跑起來

00:24:04.344 --> 00:24:07.881 
現在的好消息就是
通常你並不需要寫優化代碼

00:24:07.948 --> 00:24:09.750 
但是你卻需要找到這個優化代碼

00:24:09.816 --> 00:24:12.152 
你需要找到這些優化的數字庫

00:24:12.653 --> 00:24:15.722 
在後面我們有一個
關於會議和能源文件的鏈接

00:24:16.356 --> 00:24:20.694 
你必須找到正確的數據結構
然後審視一下你的應用程序

00:24:21.028 --> 00:24:25.499 
最後談一下爲什麼我一直在攪動
及在規則的舊時間中我又能夠優化什麼

00:24:27.968 --> 00:24:29.403 
這幅圖片中的東西是很重要的

00:24:30.304 --> 00:24:33.607 
那是直接執行的低功耗解決方案

00:24:33.674 --> 00:24:35.475 
在這個方案中系統就像開始工作一樣

00:24:35.542 --> 00:24:37.344 
而你只需要一等等待存儲和加載

00:24:37.411 --> 00:24:38.846 
你已經讓一個核心運行了

00:24:39.279 --> 00:24:41.148 
如果我們讓多核都運行的話

00:24:41.281 --> 00:24:44.084 
那我們纔是真正的在使用該系統
但如果只有單核情況會怎麼樣呢？

00:24:44.318 --> 00:24:48.155 
因爲時間的因素只會導致
雖然功率很低但是功耗卻很大

00:24:50.424 --> 00:24:53.594 
現在讓我們研究一下爲什麼會這樣

00:24:53.961 --> 00:24:57.898 
在運行系統的其他部分的時候

00:24:57.965 --> 00:24:59.933 
無論CPU GPU
或是系統的其它部分

00:25:00.868 --> 00:25:03.003 
固定功耗都會慢慢增加

00:25:03.403 --> 00:25:06.106 
你越快把這些固定消耗關掉
效果自然就越好

00:25:06.807 --> 00:25:09.943 
我自己也爲GPU增加以下額外的功耗

00:25:10.010 --> 00:25:12.913 
因爲事實上在使用GPU的過程中
會產生更多的功耗

00:25:12.980 --> 00:25:15.782 
觀察綠色的部分我們看出

00:25:16.383 --> 00:25:19.453 
當我們節省時間之後
是否使用了更少的能量

00:25:21.655 --> 00:25:24.725 
關鍵課程
高速也是能源效率

00:25:25.759 --> 00:25:27.394 
我們在看這些在線下是否滿足的時候

00:25:27.728 --> 00:25:29.830 
請謹記按照重要性排列

00:25:31.031 --> 00:25:32.833 
這是最直接的一個措施

00:25:33.233 --> 00:25:36.937 
因爲任何一個熟悉高中幾何的
都很清楚那並不滿足

00:25:37.638 --> 00:25:39.072 
我們會把它拉到平均水平

00:25:39.139 --> 00:25:40.507 
在這裏不再是功率乘以時間

00:25:40.574 --> 00:25:41.408 
這只是平均水平

00:25:42.109 --> 00:25:42.943 
將不再適合

00:25:43.477 --> 00:25:44.545 
至於其他的

00:25:44.878 --> 00:25:47.414 
注意
效率有所提高

00:25:48.315 --> 00:25:49.316 
但是依然不夠

00:25:50.150 --> 00:25:53.520 
可以看到除了CPU/GPU
平行線幾乎都在線下

00:25:53.720 --> 00:25:56.490 
因爲時間很短
所以確實滿足條件

00:25:56.557 --> 00:25:59.126 
同時雖然功率很高
但時間很短

00:25:59.193 --> 00:26:00.794 
這些就是你在設計程序
要遵從的方法

00:26:00.861 --> 00:26:03.864 
但是不要重複的使用這些措施

00:26:04.431 --> 00:26:06.166 
在你做這些之前請稍等一下你的用戶

00:26:09.436 --> 00:26:10.671 
現在讓我們調整一下

00:26:10.971 --> 00:26:13.640 
這些是應用在OS X和iOS的
所有CPU和GPU

00:26:13.774 --> 00:26:16.643 
而它們對OS X尤其重要

00:26:16.743 --> 00:26:18.812 
此外我們在衡量能量
對OS X的影響時

00:26:18.879 --> 00:26:20.614 
除了系統可以處理的CPU指令

00:26:20.814 --> 00:26:23.283 
還可以通過人們可以喚醒系統的次數

00:26:24.051 --> 00:26:28.021 
現在讓我們切換到iOS

00:26:28.555 --> 00:26:31.625 
我們知道iOS設備
不僅有CPU和GPU性能非常強悍

00:26:32.159 --> 00:26:37.197 
而且iOS的網絡定位
和後臺運行的能力也很強大

00:26:43.036 --> 00:26:47.975 
其中網絡的功率很大
大量的硬件網絡

00:26:48.642 --> 00:26:52.012 
此外還涉及到很重要的時間組件
也需要詳細考慮

00:26:53.013 --> 00:26:56.049 
定位是一個很好的功能
用起來很棒

00:26:56.383 --> 00:26:57.718 
但是它主要的設計目的

00:26:58.118 --> 00:26:59.586 
比如我正在觀察地圖上的一個點

00:26:59.653 --> 00:27:01.722 
此時我準備穿過舞臺
而小點也相應的跟着移動

00:27:01.788 --> 00:27:05.192 
我很喜歡這個功能讓人印象非常深刻
可以告訴我自己正在穿過舞臺

00:27:07.261 --> 00:27:10.130 
不幸的是這個應用程序的接口
很容易被留下繼續運行

00:27:10.531 --> 00:27:11.765 
甚至當我不在看地圖的時候

00:27:12.299 --> 00:27:16.270 
因此我需要除了改進應用程序的接口

00:27:16.670 --> 00:27:20.407 
我們也需要你在自己需要的最短
時間之內去使用定位

00:27:21.074 --> 00:27:23.677 
最終任何時刻都在後臺運行

00:27:24.378 --> 00:27:27.414 
那就會使得設備

00:27:29.249 --> 00:27:32.286 
增加了保持喚醒的時間

00:27:32.486 --> 00:27:34.888 
每次我按屏幕上的home鍵
離開你的應用程序的時候

00:27:35.189 --> 00:27:37.658 
你都在後臺運行
可能時間很短也許時間會很長

00:27:38.692 --> 00:27:40.827 
我們希望儘可能的消除這種情況

00:27:40.894 --> 00:27:43.597 
因爲我們希望設備
能保持在良好的待機狀態

00:27:44.031 --> 00:27:47.201 
從而使得設備的隨機存儲器和接收器
可以保持在一個低功耗的模式下

00:27:48.769 --> 00:27:50.470 
讓我們討論一下網絡

00:27:51.939 --> 00:27:54.041 
幻燈片橘色的部分狀態不好

00:27:54.575 --> 00:27:55.642 
因爲它代表的是消耗

00:27:56.577 --> 00:28:01.014 
思考一下
當你想向網絡上特別是蜂窩設備

00:28:01.081 --> 00:28:03.817 
發送一些數據的時候會發生什麼

00:28:04.651 --> 00:28:08.522 
系統可能會說“我現在必須發送數據
因爲應用程序告訴我的”

00:28:09.489 --> 00:28:12.893 
不要把它標記爲後臺任務
它不可延遲 必須立即完成

00:28:13.894 --> 00:28:17.865 
我們之間沒有連接起來
只是通過入站連接與蜂窩系統聯繫

00:28:18.131 --> 00:28:19.366 
但是我們沒有出站

00:28:20.300 --> 00:28:21.201 
所以舉起來

00:28:21.735 --> 00:28:24.404 
找到一個基站
已經找到基站

00:28:24.471 --> 00:28:26.106 
但是總體情況並不太好
嘗試另一個

00:28:26.540 --> 00:28:28.442 
這個基站非常好

00:28:28.809 --> 00:28:29.910 
我們連上了

00:28:29.977 --> 00:28:32.279 
好的 我發送一些數據
好的 數據發送了

00:28:34.681 --> 00:28:36.517 
沒有數據發送了 但是仍然連接着

00:28:36.750 --> 00:28:38.519 
連接時的代價很高
當我把設備打開時

00:28:39.152 --> 00:28:40.988 
按照蜂窩網絡的工作方式

00:28:41.054 --> 00:28:43.724 
我必須讓它運行一到兩秒

00:28:44.424 --> 00:28:47.828 
它可能只需要幾毫秒時間去發送數據

00:28:47.995 --> 00:28:50.697 
但它可能需要停留長達10秒
去連接到網絡

00:28:51.031 --> 00:28:52.699 
顯然不是高功率模式

00:28:52.766 --> 00:28:56.170 
但是功率仍遠高於輸入連接的閒置等待

00:28:56.870 --> 00:28:59.540 
因此消耗是一個重要的能源影響

00:29:00.207 --> 00:29:02.876 
正在運行的網絡工作量大小並不重要

00:29:03.210 --> 00:29:06.647 
在某些情況下如果接收機關閉的話
必須重啓後運行

00:29:07.047 --> 00:29:11.385 
耗費的時間比你實際上
需要發送數據的時間長一千倍

00:29:12.486 --> 00:29:16.056 
而且沒有任何方法能降低功率至預期值

00:29:16.223 --> 00:29:19.359 
收音機不能一直開啓
去實現全天續航的目標

00:29:20.694 --> 00:29:22.129 
這對聊天應用程序是一個壞消息

00:29:22.863 --> 00:29:27.034 
好消息是人們並不會在他們的手機上
點擊聊天應用程序長達10個小時

00:29:27.100 --> 00:29:27.935 
他們不會這樣的

00:29:28.168 --> 00:29:30.037 
因此只要你能夠明白

00:29:30.103 --> 00:29:33.941 
如果沒有實時聊天讓網絡繼續下去

00:29:35.175 --> 00:29:36.810 
那麼你就可以讓電池實現全天續航

00:29:38.378 --> 00:29:40.347 
我們如何解決這個問題
我們怎樣讓它更好

00:29:40.714 --> 00:29:42.683 
因爲它們不是一天可以解決的事情
難度很高

00:29:44.151 --> 00:29:48.021 
我們必須通過合併把它們組合在一起
通過批處理的方式去解決它

00:29:48.622 --> 00:29:50.824 
所以在這個特殊的例子裏

00:29:50.891 --> 00:29:53.360 
我們將會把未來的工作
納入到舊的工作中

00:29:53.427 --> 00:29:55.963 
如今將來的工作更加的重要

00:29:56.029 --> 00:29:58.665 
所以你應當推遲以前的工作
那樣可能更容易去完成目標

00:29:58.765 --> 00:30:01.568 
但是如果你想了解那兩項工作
究竟哪一個更重要

00:30:01.969 --> 00:30:05.205 
對於你的應用程序來說目標就是
現在你可以實現哪一個

00:30:05.272 --> 00:30:07.107 
現在我們將這些很棒的工具展示給你

00:30:07.274 --> 00:30:12.579 
基本上在Xcode上的這些圖形
圖形表示的新工具都將裝在你的軟件上

00:30:12.846 --> 00:30:13.680 
它非常好

00:30:14.414 --> 00:30:17.885 
你可以看一下再談談爲什麼我要去做
這些沒有必要 也許沒有必要的事情

00:30:18.785 --> 00:30:21.388 
爲什麼我的網絡模式沒有一點效率

00:30:21.555 --> 00:30:23.490 
爲什麼它時分散的？
我怎樣才能通力合作？

00:30:23.891 --> 00:30:27.828 
然後我們才能真正達到這個目標
平均低功耗

00:30:28.195 --> 00:30:29.363 
那就意味着全天的續航

00:30:30.130 --> 00:30:32.132 
因此對網絡進行總結

00:30:32.566 --> 00:30:35.035 
如果你想在網絡上做更少的工作

00:30:35.769 --> 00:30:37.971 
就必須正確的設計你的系統

00:30:39.239 --> 00:30:42.809 
即使你有一分鐘的網絡
這隻增加了幾秒鐘的消耗

00:30:43.177 --> 00:30:47.981 
此外 除非用戶請求你現在訪問網絡

00:30:48.615 --> 00:30:52.419 
否則直到確實重要的事情
請不要訪問網絡

00:30:53.253 --> 00:30:56.857 
就設計來說 對於卸載系統

00:30:56.924 --> 00:30:59.026 
以及讓系統決定什麼時候

00:30:59.092 --> 00:31:03.463 
在接下來的十分鐘內
下一個小時 下一個二十四小時

00:31:04.264 --> 00:31:07.201 
怎樣變化來說你所能做的就是對允許
我們對任務進行批量處理

00:31:07.267 --> 00:31:08.869 
使得你卸載網絡

00:31:08.936 --> 00:31:12.673 
當工作完成的時候
我們將會給你打電話叫醒你

00:31:15.442 --> 00:31:17.778 
很多時候 你可以在工作的時候等待

00:31:18.612 --> 00:31:21.748 
背景更新 NSURLSession
都有這個特性

00:31:22.015 --> 00:31:23.417 
只要等着 推遲它

00:31:24.051 --> 00:31:25.452 
去排隊吧 這很好

00:31:26.086 --> 00:31:27.788 
但不要強迫它馬上發生

00:31:29.356 --> 00:31:33.393 
這些通知很棒

00:31:33.927 --> 00:31:36.496 
但是它們有時候也會脫離控制

00:31:36.563 --> 00:31:37.865 
比如在服務器端

00:31:37.931 --> 00:31:41.535 
記得我曾提到過我們總是和
進站連接服務器相連接麼

00:31:41.602 --> 00:31:42.603 
強 也提到過

00:31:44.071 --> 00:31:45.172 
入站連接很便宜

00:31:45.239 --> 00:31:46.673 
它們基本上都是可靠的

00:31:46.974 --> 00:31:51.278 
所以繼續發送一些信息而不是輪詢

00:31:51.578 --> 00:31:55.148 
最好把一些信息發送出去
而且把這些通知標記爲PushKit

00:31:55.582 --> 00:31:58.552 
有了一個適當的優先級
這樣我們就可以批量處理了

00:31:58.619 --> 00:32:02.022 
而當我得到一個即時消息的時候
迅速地完成是最重要的

00:32:02.089 --> 00:32:05.692 
也可能是把
帶有新內容的通知下載到你的

00:32:05.759 --> 00:32:07.394 
新應用程序或者其他類似的東西上

00:32:08.962 --> 00:32:10.664 
現在讓我們討論一下定位

00:32:12.799 --> 00:32:17.171 
定位也有兩個要素
好消息是定位的功率相對較低

00:32:17.638 --> 00:32:19.640 
如果你讓定位一直運行

00:32:19.706 --> 00:32:22.109 
那麼只會有很少的空間去做其他的事情

00:32:22.176 --> 00:32:24.311 
因此不要讓精確定位一直運行

00:32:24.778 --> 00:32:26.580 
事實上 最好不要一直運行定位

00:32:26.647 --> 00:32:33.520 
除非用戶確實希望在生活中
一直運行定位程序

00:32:33.587 --> 00:32:36.023 
他們會看你的電池目錄

00:32:36.089 --> 00:32:38.325 
從而知道 後臺定位會佔用...

00:32:39.526 --> 00:32:40.594 
25%的電池

00:32:40.794 --> 00:32:41.628 
那樣並不好

00:32:41.828 --> 00:32:43.363 
除非你的應用程序就是那樣

00:32:43.664 --> 00:32:44.631 
那很好

00:32:46.900 --> 00:32:48.936 
如此精確的定位是很昂貴的

00:32:49.002 --> 00:32:50.971 
我們必須打開更多的硬件
與衛星對話

00:32:51.038 --> 00:32:52.773 
聯繫所有的衛星

00:32:52.840 --> 00:32:53.740 
完成

00:32:56.410 --> 00:32:58.712 
不精確的定位便宜很多
我們只能說

00:32:58.779 --> 00:33:01.215 
我已連接哪個Wi-Fi網絡
我附近的基站是什麼

00:33:01.748 --> 00:33:02.716 
然後我們才能真正

00:33:02.783 --> 00:33:06.353 
你看到的綠色正是系統運行的地方
顯示正在運行

00:33:06.420 --> 00:33:08.822 
雖然我們的系統大部分是關閉的

00:33:09.156 --> 00:33:11.458 
但是仍然在跟蹤你的位置
甚至精確定位

00:33:11.525 --> 00:33:12.359 
它不是免費的

00:33:12.426 --> 00:33:14.695 
不會一直運行
這些是漏洞

00:33:14.761 --> 00:33:16.797 
從而使得我可以確定你在家裏

00:33:17.197 --> 00:33:18.765 
特別是加利福利亞居民

00:33:20.834 --> 00:33:22.102 
定位只不過是滴、滴、滴

00:33:22.603 --> 00:33:24.805 
因此我們可以優化它

00:33:25.906 --> 00:33:26.740 
儘量少用它

00:33:26.874 --> 00:33:28.976 
你知道 如果你準備去申請更新定位

00:33:29.176 --> 00:33:30.143 
請不要馬上申請

00:33:30.210 --> 00:33:32.679 
那有一些應用程序
當我啓動時我想知道我的位置

00:33:32.746 --> 00:33:34.681 
我想知道公交車什麼時候來

00:33:35.682 --> 00:33:36.517 
那很好

00:33:36.583 --> 00:33:39.219 
我周圍的食物網絡應用程序 很棒

00:33:39.453 --> 00:33:40.821 
啓動 獲取位置

00:33:41.154 --> 00:33:44.591 
否則等待用戶去搜索
或者無論你需要什麼

00:33:45.125 --> 00:33:48.996 
然後儘快爲用戶完成設置
你已經得到了你想要的精確定位

00:33:49.263 --> 00:33:50.097 
然後去申請停止

00:33:51.331 --> 00:33:54.801 
對iOS 9來說 我們已經引入了
新的應用程序接口來完成這些任務

00:33:54.868 --> 00:33:56.170 
這被稱爲請求定位

00:33:56.937 --> 00:33:58.338 
它通過啓動和停止

00:33:58.405 --> 00:34:00.474 
確保你得到適當的精度

00:34:00.741 --> 00:34:04.745 
你也不必管理開始和停止
這種情況只對iOS 9種適用

00:34:04.811 --> 00:34:07.181 
對老版的操作系統仍然要按照
以前的方法去操作

00:34:07.481 --> 00:34:09.616 
在幻燈片的結尾有關於定位討論的鏈接

00:34:10.684 --> 00:34:15.121 
我們改變了系統中後臺定位的行爲方式

00:34:15.188 --> 00:34:17.958 
因此你的應用程序可以請求
使用後臺定位

00:34:18.192 --> 00:34:21.628 
但在請求被允許之前
可能會和用戶有更多的交互

00:34:22.029 --> 00:34:25.232 
如果不想再後臺使用的話
你必須對你的應用程序謹慎一點

00:34:25.866 --> 00:34:28.835 
保持允許後臺定位更新的屬性

00:34:29.136 --> 00:34:32.940 
除非當你在後臺中積極的完成它
否則就把它設置爲假

00:34:33.739 --> 00:34:36.310 
當你打開硬件定位的時候
要能夠意識到

00:34:36.376 --> 00:34:38.779 
就像打開電燈開關一樣
你實際上在給它供電

00:34:38.846 --> 00:34:40.848 
切換狀態也是非常容易的

00:34:42.416 --> 00:34:44.985 
當你實際使用它的時候
想把功耗降下來

00:34:45.052 --> 00:34:46.920 
當我們討論到時間的時說到要節省時間

00:34:47.353 --> 00:34:48.388 
當涉及把功率降下來

00:34:48.922 --> 00:34:50.657 
我提到過我們實際上可以卸載

00:34:50.724 --> 00:34:53.025 
所以讓我們說一下我們正在做的
我喜歡自行車

00:34:53.260 --> 00:34:56.996 
我可以跟蹤我的自行車
你知道 非常準確

00:34:57.297 --> 00:34:59.466 
但那是硬件而不是軟件

00:34:59.533 --> 00:35:04.538 
所以推遲那些更新
所以每15分鐘就會打電話給你

00:35:04.605 --> 00:35:07.207 
嘿 看 這裏是所有的跟蹤信息

00:35:07.508 --> 00:35:10.477 
但是大多數系統和你的軟件都在休眠

00:35:10.544 --> 00:35:12.646 
只有定位芯片在運行

00:35:14.414 --> 00:35:16.783 
最後 我們第三個因素
對調試軟件來說

00:35:16.850 --> 00:35:19.653 
這確實是我們希望你做的三件事

00:35:20.454 --> 00:35:23.056 
你知道 減少網絡 減少定位

00:35:23.490 --> 00:35:24.892 
和後臺運行

00:35:27.127 --> 00:35:31.598 
這些只是用戶通常看不到的功耗
當他們推出這個應用程序的時候

00:35:31.665 --> 00:35:33.634 
用戶可能會喜歡
這個實時更新的應用程序

00:35:33.700 --> 00:35:35.936 
但是嘗試使用後臺應用程序刷新

00:35:36.003 --> 00:35:37.838 
儘量呈現優質
大量的leeways

00:35:38.472 --> 00:35:40.707 
如果你發送通知隨後被忽略

00:35:41.141 --> 00:35:44.011 
會點亮屏幕
它正在發射網絡 這只是

00:35:44.711 --> 00:35:47.581 
不僅是這個消耗

00:35:47.648 --> 00:35:49.850 
如果你一直運行的話
將會很快的消耗你的電池

00:35:49.917 --> 00:35:51.952 
但是這是一個...

00:35:53.153 --> 00:35:55.556 
這基本上只是去掉了

00:35:56.256 --> 00:35:58.292 
適用於其它事物的能量

00:35:58.358 --> 00:36:00.694 
它正在減少基本上
如果我降低了障礙

00:36:00.761 --> 00:36:04.298 
那麼就是說你已經實現了...
9%以下而不是10%

00:36:04.765 --> 00:36:05.866 
我們需要避免...

00:36:06.333 --> 00:36:07.968 
而這20%更糟

00:36:08.502 --> 00:36:11.138 
因爲平均下來你只有5%

00:36:11.939 --> 00:36:14.241 
只要確定你不在後臺運行
怎樣去實現這一目的呢

00:36:15.209 --> 00:36:17.377 
調用後臺任務時

00:36:17.444 --> 00:36:19.713 
我們將讓設備保持幾分鐘的喚醒狀態

00:36:20.647 --> 00:36:23.417 
這樣你可以儘快的
終止後臺任務

00:36:23.851 --> 00:36:27.688 
除了能量指南之外
還有一個很好的應用程序指南

00:36:27.754 --> 00:36:29.857 
那還有一個應用程序生命週期指南

00:36:29.923 --> 00:36:34.361 
這個消息會通知你
你將進入後臺

00:36:35.462 --> 00:36:38.398 
你的用戶界面狀態保存在那兒

00:36:38.465 --> 00:36:40.234 
和用戶界面對話 保持當前狀態

00:36:40.601 --> 00:36:42.870 
如果你有需要保存的重要數據

00:36:44.371 --> 00:36:46.974 
去開一個後臺操作

00:36:48.308 --> 00:36:50.978 
但是確定
所有的代碼申請終止後臺任務

00:36:51.044 --> 00:36:52.613 
不要泄露後臺任務

00:36:53.814 --> 00:36:55.449 
如果你有網絡

00:36:55.516 --> 00:36:58.719 
也許像保存到磁盤那樣
這也可能會發生

00:36:59.119 --> 00:37:00.387 
網絡活動...

00:37:00.654 --> 00:37:04.925 
這是把網絡從操作系統中卸載的好機會

00:37:04.992 --> 00:37:06.627 
嗨 我有這個網絡 它需要發生

00:37:06.693 --> 00:37:09.363 
但它不是時間的關鍵
只要在一定的時間範圍內

00:37:09.963 --> 00:37:11.265 
有機會就一定需要完成它

00:37:11.598 --> 00:37:14.468 
給系統一個機會去優化

00:37:15.669 --> 00:37:17.504 
這也是很好的一個設計時間

00:37:17.905 --> 00:37:21.441 
在這方面可以讓你
在設計應用程序的時候更靈活

00:37:23.110 --> 00:37:24.211 
這是我理想的應用程序

00:37:24.411 --> 00:37:25.712 
強 展示了一個很好的幻燈片

00:37:25.846 --> 00:37:28.248 
典型的應用程序
在你啓動它的時候會有很多工作

00:37:28.916 --> 00:37:31.818 
我理想的應用程序
是在你退出的時候幾乎沒有任何工作

00:37:31.952 --> 00:37:33.253 
它不做任何工作

00:37:33.754 --> 00:37:35.255 
直到用戶實際交互

00:37:35.556 --> 00:37:36.857 
這很瘋狂！

00:37:37.558 --> 00:37:39.793 
很多工作 需要我們完成
這是所有的工作

00:37:39.860 --> 00:37:41.228 
請優先考慮

00:37:41.728 --> 00:37:44.131 
然後 在它完成之後再返回

00:37:44.498 --> 00:37:45.599 
它是好的而且是空閒的

00:37:45.766 --> 00:37:49.670 
那樣你就可以推翻泛美金字塔

00:37:50.070 --> 00:37:51.872 
這達到了預期要求

00:37:54.741 --> 00:37:56.376 
那麼你的應用程序是怎樣運行的呢

00:37:56.510 --> 00:37:58.645 
我們真的很希望你們回家的
時候運行一下這個工具

00:37:58.712 --> 00:38:01.081 
完整的運行一遍來檢查你的應用程序

00:38:01.148 --> 00:38:03.717 
之後這些工具將會告訴
你對應用程序的操作是什麼

00:38:04.184 --> 00:38:07.020 
確定應用程序正在做的事情
對功耗產生的影響

00:38:07.354 --> 00:38:09.990 
就相當於用戶被交付的利益

00:38:10.490 --> 00:38:14.561 
除了OS X 對於iOS來說Xcode
現在也有了一個能量計

00:38:14.995 --> 00:38:17.064 
它突出我剛纔討論到的事情

00:38:17.130 --> 00:38:19.666 
比如有中央處理器
網絡 定位以及後臺

00:38:20.300 --> 00:38:23.036 
把所有的網絡融合然後
控制所有的定位

00:38:23.403 --> 00:38:25.339 
最後再取消後臺任務

00:38:25.939 --> 00:38:27.941 
那麼就來到我們下一個話題
瞭解一下它

00:38:28.675 --> 00:38:31.512 
首先當你設計你的下一個特徵

00:38:31.812 --> 00:38:34.848 
設計你的下一個應用程序的時候
請思考一下這些消耗

00:38:35.148 --> 00:38:38.719 
比如原處理器功率
CPU和GPU的模式

00:38:38.785 --> 00:38:40.387 
我是正在醒來或是準備去休息

00:38:40.454 --> 00:38:42.589 
我能對它做出更多的約束麼

00:38:43.390 --> 00:38:45.325 
任何像那樣的閃爍

00:38:45.526 --> 00:38:48.595 
你們中的一些人可能還記得
早些時候網頁上閃爍的標籤

00:38:48.829 --> 00:38:51.265 
沒有閃爍 特別是在高頻下

00:38:52.499 --> 00:38:55.636 
比用戶交互更快的任何東西
都是高頻率的

00:38:56.770 --> 00:38:58.705 
嘗試着給自己設定一個期望值

00:38:58.772 --> 00:39:01.175 
因爲如果你準備寫一個聊天應用程序

00:39:01.408 --> 00:39:03.343 
全天下來
你自己本身可能都變成流媒體了

00:39:03.410 --> 00:39:05.812 
你應當把程序安裝
在一個新的硬件設備上

00:39:06.480 --> 00:39:09.149 
這樣的話用戶就很有可能在你的
應用程序中實現全天續航

00:39:09.216 --> 00:39:11.852 
他們必須買一個單獨的手機
事實上是三部手機

00:39:11.919 --> 00:39:13.387 
以確保可以整天運行

00:39:15.689 --> 00:39:17.391 
但很遺憾 那個應用程序賣的並不好

00:39:19.493 --> 00:39:21.662 
在你的商業模式中這種計劃

00:39:21.728 --> 00:39:23.931 
是否與這個應用程序的電池續航能力
表現的一樣呢

00:39:24.364 --> 00:39:28.769 
我正在使用很多的定位以及很多的網絡
我在後臺去完成這些任務

00:39:29.102 --> 00:39:30.270 
主要是因爲它們很昂貴

00:39:31.772 --> 00:39:34.074 
看一下執行效果
可以通過查閱能源指南

00:39:34.141 --> 00:39:36.844 
確保你可以給應用程序接口
傳遞最佳參數

00:39:37.244 --> 00:39:39.079 
看一下你自己的代碼
再看一下我們的代碼

00:39:39.146 --> 00:39:41.582 
如果我們的代碼在做一些奇怪的事情
比如提交一個錯誤

00:39:41.648 --> 00:39:43.984 
最後看一下你可能使用的第三方代碼

00:39:44.751 --> 00:39:48.455 
你有一個廣告框架 廣告本身很好
因爲它可以支持我們的平臺

00:39:49.990 --> 00:39:53.360 
但是 如果他們像其它廣告那樣
做很多的下載

00:39:53.427 --> 00:39:55.629 
下載顯示 下載顯示 下載顯示

00:39:56.063 --> 00:39:58.398 
在很長一段時間之間
我們必須保持網絡開啓

00:39:58.799 --> 00:40:00.701 
那樣並不好
必須要注意到這一點

00:40:01.335 --> 00:40:02.302 
在最後 進行測試

00:40:02.369 --> 00:40:04.071 
可以通過定期運行這些工具

00:40:04.137 --> 00:40:07.808 
去確保你的應用程序
可以按照你期望的方式去運行

00:40:09.743 --> 00:40:13.614 
如果你已經把這些事情都完成了
我懷疑你沒有 但也許你有

00:40:13.680 --> 00:40:14.982 
在這項任務中 最重要的工作

00:40:15.682 --> 00:40:19.119 
就是繼續進行
檢查你的後臺更新間隔

00:40:19.186 --> 00:40:22.689 
你能夠減少或者給你的系統
更大的自由度麼

00:40:23.657 --> 00:40:25.592 
你能夠更加謹慎的使用聲明麼

00:40:25.659 --> 00:40:29.263 
特別是當你開發VoIP應用程序的時候
我們給應用程序的接口做了一些改變

00:40:29.396 --> 00:40:31.231 
請記住 這些傳入連接是很便宜的

00:40:31.532 --> 00:40:34.034 
但並不是免費的
他們會讓你回電話

00:40:34.101 --> 00:40:35.602 
但不要退出

00:40:36.603 --> 00:40:38.172 
不要弄混顯示屏的亮度

00:40:38.839 --> 00:40:41.041 
繪畫可能是下一個過度的前奏...

00:40:41.375 --> 00:40:44.077 
我討論到閃爍的知識
那仍有很多繪畫的事情你可以去完成

00:40:44.144 --> 00:40:46.680 
去年談論到這個話題
在末尾的鏈接中

00:40:46.947 --> 00:40:48.715 
可以知道相關的主題圖是正確的

00:40:49.016 --> 00:40:49.983 
也獲得了一些工具

00:40:50.250 --> 00:40:51.084 
最後...

00:40:51.919 --> 00:40:54.755 
對於OS X和iOS來說
我們現在已經有一些能量指南

00:40:54.821 --> 00:40:57.591 
我只是提出把所有的這些信息
都記錄下來

00:40:57.658 --> 00:40:59.693 
我將會繼續
在developer.Apple.com中

00:40:59.760 --> 00:41:01.328 
更新這些信息

00:41:01.929 --> 00:41:04.131 
所以總結我們所講過的內容

00:41:05.032 --> 00:41:06.233 
就是功耗是功率

00:41:07.034 --> 00:41:09.236 
乘以時間
如果你想減少功耗

00:41:09.570 --> 00:41:13.607 
那麼相對於你運行的時間來說
功率是很重要的

00:41:14.208 --> 00:41:16.143 
我們希望你能夠降低功率

00:41:16.210 --> 00:41:19.313 
當然我們的工具本身就是低功率的
我們的工具在低功率方面表現的不錯

00:41:19.379 --> 00:41:20.681 
你也將會在下一次討論中涉及到它

00:41:20.747 --> 00:41:23.350 
這些可以支持用戶實現
電池提供全天續航

00:41:24.418 --> 00:41:26.119 
做更少的工作

00:41:26.587 --> 00:41:28.622 
或者延遲工作
以及提高完成工作的效率

00:41:29.756 --> 00:41:31.291 
這裏是我談論到的鏈接

00:41:31.792 --> 00:41:36.330 
文檔、視頻、指南 以及去年的談話

00:41:37.865 --> 00:41:39.766 
我們有我們的標準論壇

00:41:39.833 --> 00:41:42.769 
你可以和其他人交流
你能夠聯繫我或者DTS的人

00:41:43.170 --> 00:41:44.171 
他們有我的手機號碼

00:41:44.371 --> 00:41:48.008 
你不必要我的手機號碼 他們有
和他們談一下 他們可能會幫助你

00:41:48.075 --> 00:41:50.978 
如果他們不能的話 他們可以聯繫我
或者我的一個出色的隊友

00:41:51.879 --> 00:41:54.248 
保羅 也在這裏
他的電子郵箱附在這張幻燈片中

00:41:56.850 --> 00:41:57.851 
參加相關會議

00:41:58.952 --> 00:42:00.687 
或下一屆會議的人請留下來

00:42:00.921 --> 00:42:03.190 
我們有一些網絡的參數性能

00:42:03.724 --> 00:42:05.893 
可以看一下 他們將會幫助你

00:42:05.959 --> 00:42:08.362 
去思考怎樣優化
我剛纔所談論到的所有事情

00:42:08.762 --> 00:42:11.632 
請繼續爲了節能優化你的應用程序