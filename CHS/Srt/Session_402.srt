00:00:19.720 --> 00:00:22.990 
《LLDB最新内容》
以自己的方式调试达至名利双收

00:00:23.056 --> 00:00:23.891 
下午好

00:00:23.991 --> 00:00:26.026 
欢迎参加
《LLDB最新内容》讲座

00:00:26.326 --> 00:00:27.361 
我是凯特

00:00:34.001 --> 00:00:36.436 
我负责管理Xcode
的运行时间分析工具

00:00:36.503 --> 00:00:37.771 
也包括LLDB

00:00:38.071 --> 00:00:40.040 
今天我来为大家介绍
但我还带来

00:00:40.107 --> 00:00:41.074 
两位工程师

00:00:41.475 --> 00:00:42.509 
西恩和恩里科

00:00:42.576 --> 00:00:44.611 
他们会更深入
介绍部分内容

00:00:45.345 --> 00:00:47.814 
但是开始之前
我想谈谈

00:00:47.881 --> 00:00:49.449 
自上次WWDC以来  

00:00:49.516 --> 00:00:51.885 
今年的亮点有些或大

00:00:52.152 --> 00:00:53.487 
或小的改变

00:00:54.354 --> 00:00:55.189 
最著名的是...

00:00:56.423 --> 00:00:58.559 
我们推出首个Swift调试器

00:00:58.926 --> 00:01:01.461 
显然这是向前迈出了一步
可以编写和开发

00:01:01.595 --> 00:01:04.298 
Swift代码 大家一定会
逐渐熟悉并喜爱

00:01:05.666 --> 00:01:08.035 
但更重要的是
不会就此为止

00:01:08.302 --> 00:01:10.137 
我们会进一步
改善调试器

00:01:10.204 --> 00:01:12.206 
希望大家继续反馈

00:01:12.272 --> 00:01:13.674 
帮我们实现尽善尽美

00:01:14.208 --> 00:01:15.175 
与此同时

00:01:15.409 --> 00:01:17.110 
我们还
推出了Swift REPL

00:01:17.244 --> 00:01:21.281 
它稍稍不同于标准请求回复
REPL环境

00:01:21.548 --> 00:01:24.985 
实际上是伪装的LLDB

00:01:25.219 --> 00:01:28.856 
大家不仅可以通过REPL 
在Swift中提出问题

00:01:28.922 --> 00:01:31.358 
还可以通过它
来调试那些问题

00:01:31.425 --> 00:01:33.126 
你实际上是在REPL中
设置断点

00:01:33.327 --> 00:01:34.394 
实现想在调试环境下

00:01:34.494 --> 00:01:35.662 
完成的任何事情

00:01:35.829 --> 00:01:37.531 
因为它是LLDB

00:01:37.898 --> 00:01:39.199 
如果还没有
这么深入研究

00:01:39.333 --> 00:01:41.902 
我建议大家看看看
这一问题的相关博客

00:01:43.003 --> 00:01:44.605 
但是 这不是...
最终结果

00:01:44.671 --> 00:01:47.140 
之后 我们做了
无数的改进

00:01:47.207 --> 00:01:48.675 
自从首次推出产品以来

00:01:48.742 --> 00:01:50.244 
我们已经在Swift

00:01:50.310 --> 00:01:51.979 
调试体验方面
进行了百余项改进

00:01:52.045 --> 00:01:55.816 
而且我们还在继续提高
Objective-C的调试体验

00:01:56.116 --> 00:01:57.518 
我们今天也会
提到部分内容

00:01:57.851 --> 00:02:00.988 
不过只会介绍
自去年起做出的改进

00:02:02.322 --> 00:02:04.291 
Swift类型
起初并未显示出

00:02:04.358 --> 00:02:05.993 
继承了Objective-C域

00:02:06.159 --> 00:02:07.294 
我们后来对此作了更正

00:02:07.995 --> 00:02:10.631 
Help现在
包括了指令别名

00:02:10.697 --> 00:02:12.299 
需要理解的是

00:02:12.366 --> 00:02:16.170 
因为当LLDB看似语法
比较冗长

00:02:16.570 --> 00:02:17.971 
我们可能会让你输入help

00:02:18.405 --> 00:02:20.140 
实际上有许多快捷方式

00:02:20.207 --> 00:02:23.677 
在这次讲座中
我们会使用下列符号来描述它们

00:02:24.311 --> 00:02:28.382 
Help实际上可以
缩写为第一个独特序列

00:02:28.715 --> 00:02:31.084 
在这种情况下
H就足以调出帮助

00:02:31.852 --> 00:02:34.354 
更重要的是
对于更复杂的例子而言

00:02:34.421 --> 00:02:39.293 
如表达式-O--
是指评价表达式

00:02:39.693 --> 00:02:41.962 
告知结果
就像它是通过发送方法

00:02:42.062 --> 00:02:44.231 
来描述自己的
一个对象

00:02:45.098 --> 00:02:46.667 
随后在该表达之后

00:02:46.800 --> 00:02:48.268 
并无其他选项

00:02:48.902 --> 00:02:50.170 
但你可以输入PO

00:02:50.571 --> 00:02:52.739 
PO是个方便的别名
可以对左边的

00:02:52.806 --> 00:02:54.274 
所有内容进行速记

00:02:54.675 --> 00:02:56.643 
那么如果你习惯于
用帮助

00:02:56.710 --> 00:02:58.212 
应该学习使用这些别名

00:02:58.278 --> 00:02:59.947 
因为它们可以最快捷地

00:03:00.013 --> 00:03:03.050 
帮你获得LLDB中的
部分强大功能

00:03:04.184 --> 00:03:05.786 
我们还改善了
数据格式

00:03:05.986 --> 00:03:08.488 
因为告知你相关的数据情况

00:03:08.555 --> 00:03:10.257 
对于调试体验而言
是非常重要的

00:03:10.724 --> 00:03:12.626 
那么设置

00:03:12.826 --> 00:03:14.261 
和NSNS Index Path

00:03:14.328 --> 00:03:15.729 
目前就有了默认格式

00:03:15.796 --> 00:03:17.364 
可以帮助理解数据

00:03:17.464 --> 00:03:18.966 
而不是仅仅展示

00:03:19.032 --> 00:03:20.801 
底层结构的回收机制

00:03:21.802 --> 00:03:23.670 
表达式的Printf原型

00:03:24.171 --> 00:03:27.608 
如果曾尝试以Printf对它
进行计算 可能会发现

00:03:27.941 --> 00:03:30.043 
有一些稍微可疑的结果

00:03:30.544 --> 00:03:32.813 
这是因为调试器对它

00:03:32.880 --> 00:03:34.414 
不了解的表达式

00:03:34.481 --> 00:03:36.450 
声明做了很多假设

00:03:36.650 --> 00:03:39.319 
而之前它在很多情况下
也不了解printf

00:03:39.786 --> 00:03:42.022 
因此之前不知道
它是个可变参数函数

00:03:42.089 --> 00:03:44.525 
也就是可以采取
可变数量的特殊参数

00:03:44.825 --> 00:03:47.728 
也不了解特别是在
64位设备上

00:03:47.794 --> 00:03:49.530 
如何正确传递
这些特殊参数

00:03:49.897 --> 00:03:51.465 
这些都已得到改正
这样所有的

00:03:51.532 --> 00:03:55.068 
涉及C和Objective-C
的printf表达式

00:03:55.135 --> 00:03:56.970 
都应该另行执行

00:03:57.538 --> 00:03:59.640 
那么最后
这次是真的最后

00:03:59.873 --> 00:04:01.508 
我们改善了分解格式

00:04:01.575 --> 00:04:03.310 
使其更方便阅读

00:04:05.412 --> 00:04:07.981 
来深入了解
部分更有趣的改进

00:04:08.715 --> 00:04:10.851 
今年春天实现了
断点改进

00:04:10.918 --> 00:04:12.686 
大家可能还没有意识到

00:04:12.819 --> 00:04:15.322 
具体而言 大家现在
可以命名断点了

00:04:15.956 --> 00:04:18.024 
命名的断点可能
会比其他断点

00:04:18.091 --> 00:04:20.360 
更易于使用
这可能开始并不明显

00:04:20.427 --> 00:04:23.063 
不过 这些命名不一定
具备独特性

00:04:23.163 --> 00:04:25.732 
可以对单个断点
使用多个名称 这就很不简单

00:04:25.999 --> 00:04:28.168 
可以把它们想象成标签

00:04:29.570 --> 00:04:32.506 
所有的断点指令
都使用这些名称

00:04:32.606 --> 00:04:35.843 
那么设置断点时
可以提供断点设置

00:04:36.210 --> 00:04:38.145 
短线N 大写N

00:04:38.412 --> 00:04:39.613 
加上名称

00:04:39.680 --> 00:04:41.715 
还可以加上另一个短线大写N

00:04:41.782 --> 00:04:43.317 
和额外的名称等等

00:04:44.151 --> 00:04:46.720 
但更重要的是
一旦为断点

00:04:46.787 --> 00:04:48.789 
或多个断点命名

00:04:48.856 --> 00:04:50.390 
我就可以对它们

00:04:50.457 --> 00:04:51.825 
通过所有其他的指令来操作

00:04:51.892 --> 00:04:55.028 
断点可以命名
这会使得所有断点

00:04:55.262 --> 00:04:58.632 
都是可以共享命名
或者就把它当作是标签

00:05:00.033 --> 00:05:02.469 
这其实非常有趣
因为我们现在可以

00:05:02.536 --> 00:05:05.839 
实现在LLDBinit中
设置断点

00:05:06.273 --> 00:05:08.008 
如果你还不熟悉
LLDBinit

00:05:08.208 --> 00:05:09.276 
这是一种文件...

00:05:09.676 --> 00:05:11.979 
名前缀有个句号

00:05:12.045 --> 00:05:13.780 
会进入主目录

00:05:13.847 --> 00:05:16.183 
告知LLDB 这里有一束指令

00:05:16.250 --> 00:05:19.553 
每次打开LLDB会话都需要执行

00:05:20.254 --> 00:05:22.823 
如果这么使用
则会在LLDB启动时

00:05:22.890 --> 00:05:24.992 
生成一组 默认断点

00:05:25.158 --> 00:05:28.762 
所有设置的断点
在实际生成目标之前

00:05:29.129 --> 00:05:31.532 
都会被
所生成的每个目标所继承

00:05:32.633 --> 00:05:33.901 
那么结合两方面因素

00:05:34.201 --> 00:05:37.037 
我可以在这些
代码行编写LLDBinit

00:05:37.571 --> 00:05:39.540 
一组断点 -n
都命名为malloc

00:05:39.706 --> 00:05:41.441 
一个断点 -n
都命名为free

00:05:41.642 --> 00:05:43.844 
把所有断点命名为
memory

00:05:44.077 --> 00:05:45.245 
然后再关闭

00:05:45.479 --> 00:05:48.015 
这就可以很方便的
获得所有处理断点的内存

00:05:48.081 --> 00:05:49.650 
只要在我之后用到的

00:05:49.716 --> 00:05:50.884 
任何会话中输入

00:05:50.951 --> 00:05:54.988 
"breakpoint
enablememory"即可

00:05:55.422 --> 00:05:58.225 
这样就有了自己的
一组非常方便的断点

00:05:58.292 --> 00:05:59.793 
我肯定大家会经常使用

00:06:00.027 --> 00:06:02.262 
现在可以给它们
一些好记的名称

00:06:05.098 --> 00:06:07.601 
但是 当然大家在这里
不仅是来学习

00:06:07.668 --> 00:06:09.102 
我们已经完成
并推出的内容

00:06:09.369 --> 00:06:11.705 
还有我们刚开始
预览的内容

00:06:11.772 --> 00:06:12.873 
Xcode 7

00:06:13.273 --> 00:06:14.775 
是个很重要的版本

00:06:15.108 --> 00:06:16.510 
包括许多改进

00:06:16.643 --> 00:06:18.512 
最重要的是表达式求值

00:06:18.612 --> 00:06:21.348 
西恩会为大家
详细介绍这方面内容

00:06:21.682 --> 00:06:23.483 
Swift 2支持...
当然...

00:06:23.550 --> 00:06:26.453 
语言会不断发展
以及Objective-C 

00:06:26.520 --> 00:06:29.590 
支持模块的高级处理

00:06:30.657 --> 00:06:32.292 
这些内容
我们也会深入讲解

00:06:32.559 --> 00:06:34.728 
但是部分内容
其实就在后台

00:06:34.795 --> 00:06:36.463 
如果继续深入研究
你可能会注意到

00:06:36.530 --> 00:06:37.998 
例如在Xcode 7中

00:06:38.398 --> 00:06:40.267 
大家都知道模块

00:06:40.734 --> 00:06:44.238 
我们实际上可以
在为模块构建调试信息一次后

00:06:44.371 --> 00:06:46.573 
再不必在其他位置重复进行

00:06:46.840 --> 00:06:50.577 
这可以大幅减少调试信息的

00:06:50.744 --> 00:06:54.181 
数量 并提高汇编的
性能表现

00:06:54.681 --> 00:06:56.717 
一旦进入
实际的.dSYM文件 

00:06:56.783 --> 00:06:58.452 
这个.dSYM文件就会

00:06:58.519 --> 00:07:00.053 
将你所需的
所有内容都包括在内

00:07:00.687 --> 00:07:03.023 
但是其中还包括
部分其它优化

00:07:03.090 --> 00:07:06.126 
例如 不为C++类型
复制信息

00:07:06.360 --> 00:07:07.895 
这多亏了定义法则的规定

00:07:08.128 --> 00:07:10.464 
否则我们会有多个副本

00:07:10.797 --> 00:07:13.033 
实际上 我们看到
调试信息

00:07:13.233 --> 00:07:17.104 
要比Xcode 6中
少了1/6

00:07:18.238 --> 00:07:20.107 
特别是对C++项目更是如此

00:07:20.807 --> 00:07:23.577 
我们还在多方面
改进了数据格式

00:07:23.710 --> 00:07:26.980 
在Objective-C和
Swift中矢量类型有着

00:07:27.047 --> 00:07:28.482 
独特的自动数据格式

00:07:29.049 --> 00:07:30.651 
也许更重要的是

00:07:30.717 --> 00:07:32.819 
如果有Swift自定义类型

00:07:33.120 --> 00:07:35.088 
现在可以自定义它们的
表现方式

00:07:35.155 --> 00:07:37.057 
只要编写Swift代码即可

00:07:37.291 --> 00:07:38.992 
恩里科会介绍更多详情

00:07:40.260 --> 00:07:43.664 
我们还在LLDB中整合了
地址消毒剂支持

00:07:43.730 --> 00:07:45.999 
那么地址消毒剂
不只会在

00:07:46.066 --> 00:07:47.701 
参考内存无效时会告知

00:07:47.801 --> 00:07:49.636 
你还可以
针对内存提出问题

00:07:49.837 --> 00:07:52.639 
比如可以问
例如 内存历史

00:07:52.706 --> 00:07:55.576 
从LLDB控制台
了解它分配到哪里

00:07:55.776 --> 00:07:57.678 
以及何时释放

00:07:57.911 --> 00:07:59.780 
那么你可能想了解更多

00:07:59.980 --> 00:08:02.382 
指令的内存系列
并想知道相关帮助

00:08:03.917 --> 00:08:06.620 
我们还增加了
类型查找指令

00:08:06.820 --> 00:08:08.889 
类型查找指令
可以获取

00:08:08.956 --> 00:08:10.991 
系统的任何类型信息

00:08:11.425 --> 00:08:13.660 
基本上 
这就是个类似头文件的表示

00:08:13.727 --> 00:08:15.495 
可以在调试器中获得

00:08:15.629 --> 00:08:17.798 
以便提醒你类型的内容

00:08:19.132 --> 00:08:20.734 
因此 从LLDB提示中

00:08:21.101 --> 00:08:24.605 
我只需要把类型变为
"type lookup"随后加上

00:08:24.838 --> 00:08:26.807 
类型名称 然后我会
获得类型快速说明

00:08:26.974 --> 00:08:29.076 
本例中 新的错误类型

00:08:29.142 --> 00:08:31.178 
用于Swift错误处理机制

00:08:31.345 --> 00:08:33.046 
我知道 在幕后

00:08:33.113 --> 00:08:34.615 
通常会执行一对

00:08:34.748 --> 00:08:38.018 
一般已执行了的属性
只要使用EDAM类型即可

00:08:38.217 --> 00:08:40.721 
但是不管怎样 
都可以从控制台看到细节详情

00:08:41.221 --> 00:08:44.124 
同理 如果我感兴趣
"Comparable"类型

00:08:44.191 --> 00:08:45.025 
是个协议

00:08:45.225 --> 00:08:47.995 
它会告诉这个协议
实际上是来自另外两个

00:08:48.295 --> 00:08:50.264 
这样你会看到
我们从Equatable

00:08:50.330 --> 00:08:51.765 
<br/> 
得到了等号运算符

00:08:52.065 --> 00:08:54.935 
下划线Comparable 
可以提供小于比较

00:08:55.102 --> 00:08:58.438 
而导出运算符是
Comparable协议的一部分

00:08:58.772 --> 00:09:01.341 
这里还可获取许多
便捷信息

00:09:01.508 --> 00:09:02.843 
和所有内容一样

00:09:03.644 --> 00:09:06.680 
提醒你不必输入完整命令
"type lookup"

00:09:06.847 --> 00:09:10.217 
TY空格L
便足以使用这个指令

00:09:11.251 --> 00:09:12.786 
但是要想知道更多详情

00:09:12.886 --> 00:09:15.856 
特别是谈到
怎样计算表达式

00:09:15.989 --> 00:09:18.258 
我想有请
西恩•卡拉南[

00:09:19.426 --> 00:09:20.260 
大家好

00:09:21.595 --> 00:09:24.631 
我来讲讲
LLDB中的LLDB

00:09:25.666 --> 00:09:27.067 
大家可能会觉得

00:09:27.267 --> 00:09:29.036 
有那么多编译器会话

00:09:29.303 --> 00:09:30.804 
为什么要在乎编译器？

00:09:31.572 --> 00:09:34.541 
编译器是
LLDB的关键内容

00:09:35.309 --> 00:09:37.945 
会使得LLDB功能强大

00:09:38.345 --> 00:09:40.647 
会令LLDB简单易用

00:09:41.481 --> 00:09:42.916 
它的强大是

00:09:43.116 --> 00:09:45.719 
因为编译器对程序运行

00:09:46.019 --> 00:09:47.955 
对配置数据的方法

00:09:48.388 --> 00:09:49.957 
以及当你说想看看

00:09:51.692 --> 00:09:53.861 
这个变量或调用函数时等 

00:09:53.927 --> 00:09:55.462 
有着独特的理解

00:09:56.964 --> 00:10:00.067 
编译器很重要
还有一个原因是

00:10:00.133 --> 00:10:03.070 
它们可以与调试器
轻松配合使用

00:10:03.904 --> 00:10:05.372 
如果想要打印

00:10:05.839 --> 00:10:07.774 
只要使用你熟悉

00:10:07.841 --> 00:10:09.109 
输入的代码

00:10:10.110 --> 00:10:11.778 
交给表达式指令

00:10:12.646 --> 00:10:14.915 
编译器就会从中拿到指令

00:10:17.784 --> 00:10:18.619 
今天

00:10:18.719 --> 00:10:20.153 
我来讲讲在编译器整合方面

00:10:20.220 --> 00:10:21.421 
有两个重要

00:10:21.822 --> 00:10:23.490 
相关领域

00:10:23.690 --> 00:10:25.259 
获得了的改进

00:10:27.094 --> 00:10:27.961 
首先

00:10:28.095 --> 00:10:29.396 
有个好消息要告诉各位

00:10:29.463 --> 00:10:31.665 
长期从事Objective-C 
的开发人员

00:10:32.499 --> 00:10:33.333 
接下来

00:10:33.467 --> 00:10:34.301 
我要告诉...

00:10:34.801 --> 00:10:36.336 
Swift开发人员

00:10:36.670 --> 00:10:38.338 
希望现在各位都是

00:10:39.439 --> 00:10:40.274 
聊聊...

00:10:40.407 --> 00:10:42.042 
我们所做的这些改进

00:10:43.777 --> 00:10:45.679 
现在就开始
讲讲Objective-C

00:10:48.749 --> 00:10:49.716 
LLDB

00:10:49.850 --> 00:10:50.684 
包括...

00:10:50.784 --> 00:10:52.519 
两个独立的编译器

00:10:54.288 --> 00:10:55.122 
Clang

00:10:55.255 --> 00:10:57.057 
强大的Objective-C
编译器

00:10:58.025 --> 00:10:59.626 
当然 从去年起

00:10:59.993 --> 00:11:01.128 
是Swift编译器

00:11:02.596 --> 00:11:04.698 
我们的Objective-C
编译器支持

00:11:05.365 --> 00:11:06.900 
多年来一直在改进

00:11:07.434 --> 00:11:09.570 
我们加入了非常出色的新功能

00:11:10.771 --> 00:11:11.605 
比如

00:11:11.939 --> 00:11:14.007 
Objective-C
运行时间整合

00:11:14.842 --> 00:11:18.111 
那么 如果Objective-C
运行时间有部分信息

00:11:18.312 --> 00:11:20.380 
并未显示在
调试信息中

00:11:21.048 --> 00:11:23.317 
我们知道该向编译器提供

00:11:23.383 --> 00:11:25.319 
这样可以使用很多类

00:11:25.619 --> 00:11:27.221 
而不必特别做些什么

00:11:28.755 --> 00:11:29.723 
当然 去年

00:11:29.923 --> 00:11:31.892 
我们在LLDB中

00:11:32.226 --> 00:11:33.427 
引入了Swift编译器

00:11:34.294 --> 00:11:36.163 
Swift编译器已经是

00:11:36.430 --> 00:11:37.831 
是很强的工具

00:11:39.499 --> 00:11:41.101 
我们把从Swift编译器中

00:11:41.368 --> 00:11:43.570 
整合所学内容都用到其中

00:11:44.505 --> 00:11:46.273 
我们对二者都做了改进

00:11:47.641 --> 00:11:48.509 
我们来谈谈

00:11:48.575 --> 00:11:50.644 
表达式剖析器与Swift

00:11:51.578 --> 00:11:52.412 
怎么配合

00:11:52.846 --> 00:11:54.781 
从Objective-C的角度

00:11:57.551 --> 00:11:59.953 
我们现在来看
简单的打印指令

00:12:00.687 --> 00:12:03.557 
这里说到打印 
因为我用了p快捷方式

00:12:04.491 --> 00:12:05.659 
实际上是指

00:12:05.926 --> 00:12:07.327 
表达式

00:12:08.228 --> 00:12:09.530 
注意短线 

00:12:10.330 --> 00:12:11.164 
这是指

00:12:11.231 --> 00:12:14.168 
在p指令编码后的
所有内容

00:12:14.468 --> 00:12:17.838 
不能这样把额外的选项
交给指令

00:12:18.405 --> 00:12:20.240 
这里有其他方法
恩里科会给大家介绍

00:12:20.307 --> 00:12:21.608 
而且凯特刚刚给大家看过

00:12:22.676 --> 00:12:25.712 
这里是些循环运行的
简单代码

00:12:25.879 --> 00:12:27.481 
并会每次打印出
循环计数

00:12:28.048 --> 00:12:29.483 
的确 如果运行它

00:12:30.117 --> 00:12:32.019 
你会得到自己预期的数字

00:12:33.287 --> 00:12:34.254 
这个功能好在哪里？

00:12:36.523 --> 00:12:39.826 
LLDB和程序
是单独的进程

00:12:40.761 --> 00:12:43.197 
LLDB内部有
swift编译器

00:12:44.231 --> 00:12:45.999 
程序已经在运行

00:12:46.633 --> 00:12:48.435 
但是有了LLDB的帮助

00:12:48.869 --> 00:12:52.406 
Swift编译器可以
把你刚输入程序运行的

00:12:52.606 --> 00:12:54.041 
代码添加进来

00:12:55.709 --> 00:12:56.844 
如果喜欢打印...

00:12:57.211 --> 00:12:58.846 
循环计数器 这就相当棒

00:12:59.446 --> 00:13:01.315 
但是还有
要调试的内容

00:13:03.517 --> 00:13:06.086 
Swift可以和
变量配合

00:13:07.721 --> 00:13:09.056 
输入一些代码

00:13:10.724 --> 00:13:13.293 
数组的内容就打印出来

00:13:14.628 --> 00:13:15.963 
现在 这里的数组

00:13:16.363 --> 00:13:18.432 
正好有一些
在程序中的代码

00:13:19.433 --> 00:13:21.969 
LLDB安排在编译器上...

00:13:22.436 --> 00:13:23.403 
显示数据 

00:13:23.637 --> 00:13:25.939 
这样可以生成
你所需的代码

00:13:28.242 --> 00:13:31.445 
我还想简单...介绍一下

00:13:31.745 --> 00:13:34.348 
就是Swift怎么和SDK配合

00:13:35.415 --> 00:13:39.353 
当你输入
NSApplication.sharedApplication

00:13:40.621 --> 00:13:41.588 
这样的表达式时 

00:13:42.556 --> 00:13:44.024 
首先 你会看到

00:13:44.091 --> 00:13:46.460 
NSApplication.sharedApplication

00:13:46.527 --> 00:13:47.394 
是按照预期的方式

00:13:48.395 --> 00:13:50.130 
但是LLDB要去

00:13:50.697 --> 00:13:54.168 
发现包括它的SDK模块

00:13:55.369 --> 00:13:56.970 
让编译器可以访问它

00:13:57.571 --> 00:14:00.007 
然后编译器找到
NSApplication

00:14:00.240 --> 00:14:02.543 
并想出如何使用
sharedApplication

00:14:04.244 --> 00:14:05.078 
这非常好

00:14:05.345 --> 00:14:06.780 
而且都是在Swift中...

00:14:06.914 --> 00:14:07.748 
自动完成

00:14:08.682 --> 00:14:09.983 
在Objective-C

00:14:10.851 --> 00:14:11.919 
它并非总是工作

00:14:13.887 --> 00:14:16.957 
让我们在Objective-C
尝试所有这些

00:14:17.658 --> 00:14:20.928 
有些人此刻可能有些担心

00:14:21.595 --> 00:14:24.831 
因为你知道 
NSLog有时并不像

00:14:24.898 --> 00:14:26.934 
调试器中那么简单

00:14:30.103 --> 00:14:32.539 
过去 当输入NSLog时

00:14:32.773 --> 00:14:34.274 
会看到像这样的错误提示:

00:14:34.341 --> 00:14:36.310 
NS日志存在未知返回类型

00:14:38.045 --> 00:14:40.013 
这是因为
在SDK肯定会

00:14:40.080 --> 00:14:41.715 
存在NSLog的定义

00:14:42.115 --> 00:14:43.617 
但是LLDB发现

00:14:43.750 --> 00:14:46.186 
符号中只有调试信息中的内容

00:14:46.486 --> 00:14:48.188 
在本例中
它看到一个符号

00:14:48.822 --> 00:14:51.291 
这个符号 我们不知道
它的返回类型是什么

00:14:51.391 --> 00:14:53.660 
我们甚至不知道
它还用了格式字符串

00:14:55.362 --> 00:14:57.164 
好消息是
问题已经得到解决

00:14:58.131 --> 00:14:59.833 
NSLog是按照
预期的方式工作

00:15:06.773 --> 00:15:11.545 
我们再做些
更隐秘的内容

00:15:11.612 --> 00:15:13.080 
打印NSMakeRect

00:15:13.514 --> 00:15:14.348 
稍等！

00:15:14.414 --> 00:15:15.649 
为什么是隐秘的内容呢？

00:15:15.716 --> 00:15:17.251 
就在这里框架中

00:15:19.319 --> 00:15:23.090 
可惜的是
看似标识符并不存在

00:15:23.757 --> 00:15:26.693 
现在大家就会了解
如果使用NSLog

00:15:26.760 --> 00:15:28.328 
可以转换结果

00:15:28.395 --> 00:15:29.263 
对 可以这么用

00:15:30.097 --> 00:15:32.566 
但是NSMakeRect
不能这么用

00:15:33.667 --> 00:15:34.635 
这是因为

00:15:34.801 --> 00:15:37.604 
NSMakeRect
是确定的NS-Inline

00:15:37.971 --> 00:15:39.373 
没有符号

00:15:39.806 --> 00:15:42.276 
LLDB什么也看不到

00:15:44.044 --> 00:15:44.878 
不错

00:15:45.345 --> 00:15:47.014 
没问题了

00:15:53.954 --> 00:15:55.656 
还剩一个问题

00:15:56.790 --> 00:15:57.958 
我们现在来看

00:15:58.725 --> 00:16:00.961 
原先NSApplicationsh
aredApplication

00:16:01.028 --> 00:16:01.862 
的情况

00:16:01.929 --> 00:16:03.463 
当然 若你是自己运行
这个表达式

00:16:03.530 --> 00:16:05.465 
当然会在Objective-C
中运行

00:16:05.532 --> 00:16:08.035 
我们已经在为
Objective-C运行时间整合

00:16:08.101 --> 00:16:08.936 
做了很多工作

00:16:09.436 --> 00:16:12.272 
但是如果想找出
undo.Manager 

00:16:12.439 --> 00:16:14.608 
你很快会发现运行时间
并未告诉你所有内容

00:16:15.242 --> 00:16:17.744 
特别是你发现的这个
关于undo.Manager的

00:16:17.811 --> 00:16:21.548 
奇怪错误提示
在类型id对象中并未发现

00:16:22.549 --> 00:16:23.817 
是什么情况？

00:16:24.117 --> 00:16:24.952 
在SDK肯定

00:16:25.018 --> 00:16:27.154 
sharedApplication
会返回一个

00:16:27.221 --> 00:16:28.722 
NSApplication星级

00:16:28.789 --> 00:16:30.724 
但如果来看
运行时间

00:16:31.024 --> 00:16:32.693 
返回的是id

00:16:33.060 --> 00:16:33.894 
是个一般的

00:16:34.895 --> 00:16:36.563 
Objective-C对象

00:16:38.966 --> 00:16:39.800 
好消息

00:16:40.200 --> 00:16:41.568 
这不再是问题了

00:16:41.935 --> 00:16:46.607 
实际上 我们会看到
只能从SDK得到的信息

00:16:46.773 --> 00:16:48.942 
例如
指针为可空值

00:16:49.076 --> 00:16:51.879 
这就是SDK支持Swift的
最新功能

00:16:52.079 --> 00:16:54.515 
也会进入
Objective-C

00:16:57.684 --> 00:17:00.187 
不过信息就在这里

00:17:00.454 --> 00:17:02.723 
这就是我们
所应用的理念

00:17:03.524 --> 00:17:05.692 
从SDK直接读出

00:17:06.193 --> 00:17:08.494 
代码会一直
在LLDB中运行

00:17:08.694 --> 00:17:13.433 
我们了解本地变量
函数 自己的类

00:17:15.002 --> 00:17:17.171 
SDK函数
另一方面

00:17:17.671 --> 00:17:19.540 
我们还有更多
问题 如大家所见

00:17:21.241 --> 00:17:24.278 
SDK类就像NSView
和NSApplication

00:17:24.344 --> 00:17:25.746 
我们看到了 但是如你所见

00:17:25.811 --> 00:17:27.414 
因为运行时间整合

00:17:28.015 --> 00:17:29.716 
这里有个小星号

00:17:31.185 --> 00:17:33.153 
现在SDK包括
如果你试着在表达式用过

00:17:33.220 --> 00:17:35.522 
NSASCIIStringEnc
oding

00:17:35.822 --> 00:17:37.958 
就会了解这永远不行

00:17:39.126 --> 00:17:42.229 
如果使用宏 如int-max

00:17:42.429 --> 00:17:43.764 
那么 max

00:17:43.830 --> 00:17:46.200 
利用两个数字中最大值

00:17:46.600 --> 00:17:48.368 
这样也不会奏效

00:17:50.537 --> 00:17:53.140 
所有这些在
最新的LLDB中都已解决

00:18:00.280 --> 00:18:02.349 
我们也删掉了烦人的星号

00:18:05.886 --> 00:18:10.057 
大家可能会说那么
每月要付多少个39.95才能用上

00:18:10.190 --> 00:18:11.358 
这个功能呢？

00:18:11.425 --> 00:18:13.093 
好消息 这完全免费

00:18:13.160 --> 00:18:15.996 
你只需要
@import AppKit即可

00:18:17.130 --> 00:18:18.966 
运行一个表达式

00:18:19.032 --> 00:18:21.768 
表明输入
我关心的框架

00:18:22.536 --> 00:18:24.571 
如果用到AppKit 
或是在诸位中间的

00:18:24.638 --> 00:18:25.806 
两三位...

00:18:26.273 --> 00:18:28.175 
iOS程编写人员

00:18:28.242 --> 00:18:29.710 
输入UIKit...

00:18:30.878 --> 00:18:32.112 
就可以了

00:18:34.715 --> 00:18:35.549 
现在

00:18:36.917 --> 00:18:38.986 
我们并未将
Swift放在那里不管

00:18:40.153 --> 00:18:44.491 
Swift2.0可实现
强大的错误处理支持

00:18:44.658 --> 00:18:48.529 
LLDB马上就可以
支持the bat

00:18:48.862 --> 00:18:50.197 
正如大家所期待的那样

00:18:52.999 --> 00:18:55.068 
我们可以处理Swift错误

00:18:56.236 --> 00:18:58.205 
当调用可能在

00:18:58.272 --> 00:19:00.507 
表达式引发错误的函数时

00:19:00.574 --> 00:19:02.543 
你不必调用"try"

00:19:03.410 --> 00:19:04.311 
因为...

00:19:04.578 --> 00:19:07.047 
我们为大家抓取内容

00:19:08.515 --> 00:19:09.550 
如果你输入

00:19:10.083 --> 00:19:11.685 
这个函数"throws"

00:19:12.019 --> 00:19:13.387 
并把它交给表达式

00:19:13.453 --> 00:19:15.522 
注意这和p指令
完全一样

00:19:16.657 --> 00:19:17.591 
你会获得

00:19:18.225 --> 00:19:19.660 
为你生成的...

00:19:19.993 --> 00:19:21.128 
错误变量 

00:19:21.261 --> 00:19:23.797 
其中包括函数引发的错误

00:19:26.233 --> 00:19:28.735 
也可以在
REPL中...完成这些

00:19:30.571 --> 00:19:32.940 
如果从REPL提示中
你做了同样的事情

00:19:34.575 --> 00:19:36.710 
则会得到...错误变量

00:19:39.780 --> 00:19:42.649 
我们再来看看
LLDB支持的...

00:19:43.183 --> 00:19:44.218 
更多内容

00:19:45.352 --> 00:19:47.554 
也就是说 你不希望
总是看到

00:19:47.621 --> 00:19:49.423 
最后出现的是错误

00:19:49.923 --> 00:19:53.160 
你需要了解
产生错误的代码是什么

00:19:54.561 --> 00:19:56.063 
不过 在Objective-C中

00:19:56.129 --> 00:19:57.564 
你用到了断点来完成

00:19:58.699 --> 00:20:02.202 
具体而言你在Objective-C
异常中设置了断点

00:20:03.170 --> 00:20:04.505 
方法是...

00:20:04.671 --> 00:20:06.807 
你用了断点来设置指令

00:20:08.575 --> 00:20:11.178 
确定了希望为...

00:20:12.012 --> 00:20:14.314 
异常Objective-C...

00:20:15.115 --> 00:20:15.949 
设置断点

00:20:16.650 --> 00:20:18.852 
我们来为你设置了断点

00:20:19.119 --> 00:20:21.121 
那么一旦Objective-C代码

00:20:21.655 --> 00:20:22.956 
要引发异常

00:20:23.290 --> 00:20:24.124 
我们就会停下来

00:20:25.192 --> 00:20:27.494 
在Swift错误中
你可以做同样的事情

00:20:28.195 --> 00:20:30.764 
只要用Swift
替代Objective-C 

00:20:31.498 --> 00:20:33.734 
我们就会停止
程序要...

00:20:33.934 --> 00:20:34.968 
引发的...

00:20:35.335 --> 00:20:36.403 
Swift错误

00:20:37.471 --> 00:20:38.605 
但是还可以...

00:20:39.006 --> 00:20:40.974 
做另一件很酷的事

00:20:42.309 --> 00:20:45.646 
你可以停止
具体的错误类型

00:20:46.647 --> 00:20:48.549 
这是我们支持
Swift的一个功能

00:20:49.149 --> 00:20:51.151 
这么做的方法很简单

00:20:51.218 --> 00:20:54.955 
和你在设置表达式断点
非常相似

00:20:56.490 --> 00:20:58.825 
可以使用短线O参数

00:20:59.459 --> 00:21:01.628 
来明确你希望捕捉的

00:21:01.929 --> 00:21:03.497 
错误类型名称

00:21:04.831 --> 00:21:09.303 
如果这么做
那么只有在出现

00:21:10.003 --> 00:21:12.573 
你感兴趣的错误类型时

00:21:13.006 --> 00:21:13.907 
才会停下来

00:21:15.876 --> 00:21:16.844 
最后

00:21:18.312 --> 00:21:19.213 
当然

00:21:20.314 --> 00:21:22.883 
你可以按照
正常代码中...

00:21:23.217 --> 00:21:24.785 
的方法捕捉错误

00:21:24.852 --> 00:21:26.420 
毕竟 部分而言

00:21:26.653 --> 00:21:30.757 
REPL是指了解和发现语言
运行的方法

00:21:32.025 --> 00:21:33.794 
如果输入Foundation

00:21:34.127 --> 00:21:35.395 
来获取NSError

00:21:36.330 --> 00:21:39.533 
然后编写会产生
NSError的代码

00:21:40.334 --> 00:21:43.704 
就可以捕捉
NSError...并打印出来

00:21:45.439 --> 00:21:46.440 
如果这么做

00:21:46.707 --> 00:21:48.675 
结果就和你在自己的程序中

00:21:48.742 --> 00:21:50.577 
捕捉的效果完全相同

00:21:52.613 --> 00:21:54.081 
我希望大家...

00:21:54.548 --> 00:21:55.983 
记住两点

00:21:56.116 --> 00:21:57.117 
首先

00:21:57.684 --> 00:21:58.685 
添加输入...

00:21:58.886 --> 00:21:59.853 
自己的模块

00:22:00.754 --> 00:22:01.922 
第二

00:22:02.422 --> 00:22:05.359 
试着用LLDB进行错误处理

00:22:05.425 --> 00:22:06.560 
这是个不错的办法

00:22:07.694 --> 00:22:09.863 
要想了解更多详情

00:22:09.930 --> 00:22:12.132 
不是说告诉程序该做什么

00:22:12.766 --> 00:22:17.304 
而是如何在程序
产生资料完成后打印信息

00:22:17.905 --> 00:22:19.740 
有请恩里科·格拉纳塔

00:22:22.709 --> 00:22:23.544 
大家好

00:22:24.378 --> 00:22:26.246 
上午我还在实验室

00:22:26.313 --> 00:22:29.082 
我们在想办法
解决一个问题

00:22:29.816 --> 00:22:33.487 
问题是...为什么
我看不到这个变量？

00:22:33.787 --> 00:22:34.955 
出什么事了？

00:22:35.556 --> 00:22:38.125 
为了帮助大家找到问题

00:22:38.525 --> 00:22:39.860 
我们试了几个指令

00:22:39.927 --> 00:22:42.896 
试了表达式 还有
PO 我们还试了帧变量

00:22:43.564 --> 00:22:46.166 
此刻 人们通常会问

00:22:46.466 --> 00:22:49.570 
为什么有那么多指令来做几乎
相同的事情？

00:22:49.636 --> 00:22:52.072 
来看我的数据
看看程序中在发生什么

00:22:53.373 --> 00:22:56.443 
大家来这里
就是了解内部消息的

00:22:56.710 --> 00:22:59.847 
我们来看一下
LLDB让你看数据的指令

00:23:00.614 --> 00:23:02.482 
共有三个

00:23:02.850 --> 00:23:03.884 
帧变量

00:23:04.151 --> 00:23:05.485 
表达式指令

00:23:05.886 --> 00:23:07.187 
是个p指令

00:23:07.721 --> 00:23:09.790 
表达式 
短线大写O

00:23:09.857 --> 00:23:10.691 
这个...

00:23:10.757 --> 00:23:12.092 
刚才讲过

00:23:12.292 --> 00:23:15.195 
是作为PO指令

00:23:15.896 --> 00:23:16.730 
首先

00:23:16.864 --> 00:23:18.165 
帧变量指令

00:23:18.699 --> 00:23:22.402 
帧变量指令
可以缩写为frv

00:23:22.469 --> 00:23:26.106 
输入时 
基本是Xcode变量视图

00:23:26.607 --> 00:23:29.743 
它让你...看所有的
本地变量

00:23:30.410 --> 00:23:31.612 
让你看...

00:23:32.012 --> 00:23:33.947 
几个本地变量

00:23:34.748 --> 00:23:36.083 
此外

00:23:36.250 --> 00:23:37.951 
也可以应用...

00:23:38.118 --> 00:23:40.454 
带有短线 短线格式旗标的格式

00:23:41.755 --> 00:23:43.156 
要强调的一点是

00:23:43.490 --> 00:23:44.925 
因为在看到首次输出时

00:23:45.926 --> 00:23:48.729 
有Tuple的话
我会回到这里

00:23:48.996 --> 00:23:49.830 
这是个...

00:23:49.963 --> 00:23:50.864 
聚合

00:23:51.098 --> 00:23:53.800 
是包括其他对象的对象

00:23:54.134 --> 00:23:56.737 
聚合当中的内容

00:23:57.004 --> 00:23:58.005 
我们称之为...

00:23:58.572 --> 00:23:59.406 
子对象

00:24:01.241 --> 00:24:02.609 
这个表达式指令

00:24:03.577 --> 00:24:05.379 
在本次会话中你会多次看到

00:24:05.479 --> 00:24:06.580 
我会简要介绍一下

00:24:06.980 --> 00:24:07.814 
当然

00:24:08.215 --> 00:24:09.283 
有了表达式指令

00:24:09.349 --> 00:24:11.919 
可以简单算一下
正如你猜测的一样

00:24:12.519 --> 00:24:16.223 
完全可能...使用之前的结果

00:24:16.657 --> 00:24:19.259 
并用它们
完成更多内容

00:24:20.327 --> 00:24:22.462 
当然 表达式指令
也知道如何

00:24:22.529 --> 00:24:24.698 
自定义结果的格式

00:24:25.732 --> 00:24:27.968 
需要再次强调的一点是

00:24:28.836 --> 00:24:29.803 
子对象

00:24:30.771 --> 00:24:31.839 
第三个指令

00:24:32.339 --> 00:24:33.507 
po指令

00:24:34.141 --> 00:24:38.345 
这个可能是...在座各位
Objective-C开发员的指令

00:24:38.545 --> 00:24:40.914 
我猜测
在Objective-C代码之前

00:24:41.315 --> 00:24:43.383 
大家都知道是PO指令

00:24:43.784 --> 00:24:46.887 
你可以生成对象
把说明打印出来

00:24:47.788 --> 00:24:50.991 
可以生成NSArray
或打印现有的NSArray

00:24:51.058 --> 00:24:52.492 
你就会看到其中的内容

00:24:53.060 --> 00:24:54.461 
要知道

00:24:54.528 --> 00:24:56.763 
对于字符串而言非常简单

00:24:57.698 --> 00:24:58.532 
那么

00:24:58.599 --> 00:24:59.533 
三条指令

00:24:59.900 --> 00:25:02.135 
它们并非是完全一样的功能

00:25:02.202 --> 00:25:04.004 
大家估计此刻也猜到了

00:25:04.705 --> 00:25:05.539 
实际上

00:25:06.540 --> 00:25:07.941 
它们只是有些相似

00:25:08.008 --> 00:25:09.209 
但不是完全相同

00:25:09.409 --> 00:25:10.244 
例如

00:25:10.811 --> 00:25:12.880 
表达式指令和po指令

00:25:13.213 --> 00:25:15.749 
是...
"run my code"指令

00:25:16.083 --> 00:25:17.551 
无论代码类型是什么

00:25:17.618 --> 00:25:19.386 
这些指令都会运行

00:25:20.888 --> 00:25:22.990 
但是 接下来的
帧变量指令

00:25:23.056 --> 00:25:25.359 
和表达式指令
第二步则不相同

00:25:25.726 --> 00:25:27.728 
当它们不得不显示结果时

00:25:27.861 --> 00:25:30.230 
会用到LLDB格式器系统

00:25:31.331 --> 00:25:34.301 
我们在以往的WWDC
讲座中

00:25:34.368 --> 00:25:36.603 
介绍过LLDB格式器系统

00:25:37.004 --> 00:25:38.672 
大家应该都去找来看看

00:25:39.072 --> 00:25:40.240 
不过简单而言

00:25:40.641 --> 00:25:43.744 
LLDB掌握部分嵌入系统类型

00:25:43.944 --> 00:25:45.479 
并对其自动格式化

00:25:45.779 --> 00:25:48.582 
NSArray NSDictionaries
加字符串

00:25:49.116 --> 00:25:53.654 
还可以提供...在Python中
编写的自己的格式

00:25:54.688 --> 00:25:55.789 
另一方面

00:25:55.989 --> 00:25:58.392 
po指令并不使用
LLDB格式器

00:25:58.659 --> 00:26:02.930 
po指令在...后面
在幕后

00:26:03.130 --> 00:26:04.031 
运行更多的代码

00:26:04.398 --> 00:26:05.832 
实际上会生成为

00:26:05.899 --> 00:26:07.301 
为你显示的真实结果

00:26:08.202 --> 00:26:10.537 
你可能已经在
一个Objective-C类中

00:26:10.604 --> 00:26:12.272 
至少编写了一个
说明方法

00:26:12.506 --> 00:26:15.275 
然后意识到
这就是po打印的内容

00:26:16.276 --> 00:26:17.110 
现在

00:26:17.444 --> 00:26:18.946 
我希望大家想一想

00:26:19.213 --> 00:26:20.047 
这两个模型

00:26:20.113 --> 00:26:23.217 
实际上在用你的对象
并为之生产数据

00:26:24.151 --> 00:26:26.019 
LLDB格式器模型

00:26:26.220 --> 00:26:27.688 
我们称之为

00:26:27.955 --> 00:26:29.857 
"out of process"
格式模型

00:26:29.923 --> 00:26:30.757 
为什么呢

00:26:30.824 --> 00:26:33.694 
因为格式器位于进程之外

00:26:33.961 --> 00:26:36.430 
它或者将
内容构建到调试器中

00:26:36.830 --> 00:26:39.933 
或者你用部分Python
脚本表现对象

00:26:40.267 --> 00:26:42.069 
这是不同的语言
不同的文件

00:26:42.135 --> 00:26:43.904 
存在于不同的作用域中

00:26:44.638 --> 00:26:45.672 
另一方面

00:26:46.306 --> 00:26:48.742 
外部格式器位于调试器中

00:26:48.976 --> 00:26:50.978 
这就很容易...

00:26:51.178 --> 00:26:54.448 
让他访问调试器所具备
程序的所有内容

00:26:54.748 --> 00:26:57.384 
就像是可以鸟瞰所有进程

00:26:58.519 --> 00:27:02.189 
因此 这类格式器
也可以很容易...

00:27:02.523 --> 00:27:05.225 
确定程序状态并未改变

00:27:05.659 --> 00:27:08.028 
你若是看到
调试器中的数据后

00:27:08.095 --> 00:27:10.397 
不想改变程序状态

00:27:10.764 --> 00:27:12.699 
调试器相当于是阶段...

00:27:13.033 --> 00:27:13.867 
检测器

00:27:13.934 --> 00:27:16.103 
它来看内容
并试图不做改变

00:27:17.671 --> 00:27:18.839 
在另外的模型中

00:27:19.206 --> 00:27:20.240 
po模型

00:27:20.374 --> 00:27:22.743 
writeadescription
method模型

00:27:23.010 --> 00:27:25.212 
是个进程格式模型

00:27:25.612 --> 00:27:28.415 
你同时编写数据和格式器

00:27:28.682 --> 00:27:30.617 
再用相同的语言
编写一遍

00:27:31.118 --> 00:27:33.754 
可能甚至都在相同的
文件中编写

00:27:34.621 --> 00:27:36.757 
因为格式器是在应用中

00:27:36.823 --> 00:27:38.625 
运行的代码

00:27:38.692 --> 00:27:40.661 
可以轻松并完全

00:27:40.727 --> 00:27:42.829 
访问应用的对象模型

00:27:44.031 --> 00:27:45.999 
但是功能更强大

00:27:46.200 --> 00:27:47.901 
责任也更大

00:27:48.535 --> 00:27:51.071 
需要确保格式器

00:27:51.138 --> 00:27:53.040 
并没有改变程序的状态

00:27:53.540 --> 00:27:56.710 
要确保并未在
格式器中...

00:27:56.910 --> 00:27:59.680 
对准备表现的对象
做了任何改变

00:28:00.981 --> 00:28:03.750 
那好 Objective-C

00:28:03.817 --> 00:28:05.319 
具备进程进程格式模型

00:28:05.452 --> 00:28:06.787 
我可以编写说明方式

00:28:06.854 --> 00:28:08.222 
调试器会用到

00:28:08.789 --> 00:28:10.123 
那Swift会怎样？

00:28:11.358 --> 00:28:13.827 
结果是 演讲厅里
在座的各位

00:28:13.894 --> 00:28:15.195 
又一次知道了内部消息

00:28:15.462 --> 00:28:18.398 
从一开始Swift已有了

00:28:18.632 --> 00:28:20.000 
进程格式模型

00:28:20.701 --> 00:28:21.535 
但是 在哪儿呢？

00:28:21.602 --> 00:28:22.736 
怎么用呢？

00:28:23.537 --> 00:28:26.673 
希望大家
都用过Swift开发环境

00:28:27.107 --> 00:28:29.142 
如果用过Swift开发环境

00:28:29.510 --> 00:28:32.145 
那就用过进程格式模型

00:28:32.479 --> 00:28:34.147 
从一开始它就在这里

00:28:35.849 --> 00:28:36.817 
那有什么新奇的呢？

00:28:37.784 --> 00:28:41.355 
现在 在Xcode 7
我们会采取完全相同的模型

00:28:41.788 --> 00:28:44.024 
把它作为公共API

00:28:44.791 --> 00:28:46.560 
大家可以使用它

00:28:47.694 --> 00:28:50.230 
它仍然支持...开发环境

00:28:50.664 --> 00:28:54.034 
不过现在也支持
LLDB po指令

00:28:54.501 --> 00:28:56.603 
现在 你有着正确的
Swift格式器

00:28:56.670 --> 00:28:58.071 
针对Swift对象

00:28:58.705 --> 00:28:59.540 
怎么弄？

00:28:59.806 --> 00:29:01.608 
我们来详细讲一下

00:29:02.476 --> 00:29:04.144 
这个模型基于...

00:29:04.411 --> 00:29:05.746 
4个协议

00:29:06.980 --> 00:29:08.348 
这些是各自的名称

00:29:09.283 --> 00:29:11.718 
对 我说是四个协议

00:29:12.085 --> 00:29:13.954 
它们的名称相当长

00:29:14.621 --> 00:29:16.823 
但是...我不会
过分担心

00:29:16.957 --> 00:29:20.127 
可能是这个模型的可选项

00:29:20.360 --> 00:29:21.595 
4个协议

00:29:21.662 --> 00:29:23.630 
并非是指必须符合所有要求

00:29:23.964 --> 00:29:27.000 
可以选择子集
来获得所需要的结果

00:29:27.167 --> 00:29:29.203 
符合使用的协议部分

00:29:29.436 --> 00:29:30.571 
就可以了

00:29:31.471 --> 00:29:32.639 
我们来看一下协议

00:29:33.774 --> 00:29:35.809 
CustomStringConvertible

00:29:35.876 --> 00:29:37.611 
是协议名称

00:29:37.911 --> 00:29:39.046 
表示...

00:29:39.613 --> 00:29:42.482 
怎样把对象作为
字符串打印？

00:29:43.584 --> 00:29:45.419 
它并未告知LLDB

00:29:45.719 --> 00:29:47.354 
它还告知了Swift

00:29:47.855 --> 00:29:48.689 
怎么弄？

00:29:48.755 --> 00:29:50.457 
Swift打印功函数

00:29:50.824 --> 00:29:53.594 
以及Swift字符串
插值功能

00:29:53.760 --> 00:29:56.697 
二者都用了CustomString
Convertible协议

00:29:57.297 --> 00:29:58.465 
非常好用

00:29:58.599 --> 00:30:00.133 
实现这些很难吗？

00:30:01.602 --> 00:30:02.436 
非常简单

00:30:02.836 --> 00:30:05.906 
我有个数据结构
代表啤酒歌的瓶子

00:30:05.973 --> 00:30:08.041 
因为我自己正在
准备bash脚本

00:30:08.408 --> 00:30:10.210 
我想把歌词打印出来

00:30:10.878 --> 00:30:12.713 
就生成了一个实例

00:30:12.779 --> 00:30:14.781 
并看墙上有多少啤酒瓶

00:30:15.449 --> 00:30:17.451 
但是要等到
app的...

00:30:17.784 --> 00:30:19.086 
所有内容都没问题的时候

00:30:19.152 --> 00:30:21.255 
如果我做调试
也许我需要更多信息

00:30:21.788 --> 00:30:25.092 
那就需要Custom Debug
String Convertible

00:30:25.392 --> 00:30:28.729 
这是调试器对这个对象的
具体表示

00:30:29.429 --> 00:30:31.598 
调试器具体表示是什么

00:30:32.032 --> 00:30:33.834 
则要取决你的app

00:30:33.901 --> 00:30:35.769 
完全取决于对象
模型的语义

00:30:36.503 --> 00:30:37.571 
但是作为提示

00:30:37.638 --> 00:30:39.206 
debugPrint函数

00:30:39.506 --> 00:30:41.642 
将默认选择这个协议

00:30:42.242 --> 00:30:43.143 
当然

00:30:43.510 --> 00:30:45.345 
打印和debugPrint 

00:30:45.412 --> 00:30:47.814 
不会满足其他一致性要求

00:30:48.015 --> 00:30:49.683 
如果它们的兴趣点不在此

00:30:50.484 --> 00:30:51.518 
怎么运行呢？

00:30:51.885 --> 00:30:53.153 
很简单

00:30:53.954 --> 00:30:55.923 
我们把啤酒瓶进行扩展

00:30:56.423 --> 00:30:58.425 
因为我们在做调试

00:30:58.492 --> 00:31:00.360 
希望了解墙上啤酒瓶的更多信息

00:31:00.594 --> 00:31:03.230 
这样我们可以确定啤酒类型
是否正确

00:31:03.463 --> 00:31:05.766 
这就会成为不错的bash脚本
因为它们都很出色

00:31:06.967 --> 00:31:08.268 
第三个协议

00:31:08.535 --> 00:31:11.205 
是CustomPlayground
Quick Lookable

00:31:11.772 --> 00:31:13.106 
正如名称所示

00:31:13.373 --> 00:31:16.376 
这个协议是主要
为环境而定

00:31:16.977 --> 00:31:20.747 
是指为环境中的
对象提供

00:31:20.814 --> 00:31:22.916 
丰富的图形表示

00:31:23.717 --> 00:31:24.651 
想要看举例吗？

00:31:24.718 --> 00:31:26.019 
当然有

00:31:26.787 --> 00:31:29.823 
我可以编写代表一个人的
数据结构

00:31:30.157 --> 00:31:32.259 
然后我可以获得
一个人的描述

00:31:32.326 --> 00:31:34.394 
在环境的侧边工具栏显示

00:31:34.695 --> 00:31:36.930 
以此作为生成这个类型
对象的结果

00:31:38.899 --> 00:31:41.068 
不好意思
让你们失望了

00:31:41.134 --> 00:31:42.870 
我的确想做成的

00:31:43.136 --> 00:31:45.706 
但是 大会上不会销售

00:31:45.772 --> 00:31:48.008 
带有人像的T恤衫

00:31:48.342 --> 00:31:49.376 
不好意思

00:31:50.244 --> 00:31:52.379 
不过 我有个弥补的办法

00:31:52.679 --> 00:31:54.181 
其中最后的协议

00:31:54.481 --> 00:31:56.416 
Custom
Reflectable协议

00:31:56.483 --> 00:31:58.619 
它可以让我
生成完全自定义的

00:31:58.685 --> 00:31:59.786 
子对象层次

00:32:00.087 --> 00:32:03.056 
好 我说过 我会回到
"children"这里 说到做到

00:32:04.024 --> 00:32:07.227 
当我说到完全自定义
子对象层次时

00:32:08.262 --> 00:32:09.730 
我是说

00:32:10.364 --> 00:32:12.199 
我可以
做个新的...

00:32:12.266 --> 00:32:14.801 
我可以为对象
制作新的结构

00:32:15.135 --> 00:32:17.204 
可以告知语言
可以告知调试器

00:32:17.271 --> 00:32:18.338 
可以告知环境

00:32:18.639 --> 00:32:20.774 
我的对象实际上是用什么来造的

00:32:20.874 --> 00:32:22.109 
大家会看到

00:32:22.576 --> 00:32:24.044 
你做此事的方法

00:32:24.311 --> 00:32:26.580 
交易用的货币

00:32:26.880 --> 00:32:30.083 
在想要对Swift描述
对象的结构时 

00:32:30.417 --> 00:32:31.251 
被称为

00:32:31.451 --> 00:32:32.386 
Mirror

00:32:32.486 --> 00:32:33.487 
可反射的镜像

00:32:35.222 --> 00:32:37.925 
我们来看个例子
不要费时费事

00:32:38.525 --> 00:32:40.727 
我有个应用用来

00:32:40.827 --> 00:32:42.996 
搜集温度样本

00:32:43.864 --> 00:32:45.199 
它有两个数据结构

00:32:45.699 --> 00:32:46.934 
一个用来描述

00:32:47.267 --> 00:32:48.435 
此刻的时间

00:32:48.735 --> 00:32:51.205 
它说在给定的时刻

00:32:51.538 --> 00:32:53.507 
这就是我得到的温度信息

00:32:54.508 --> 00:32:56.543 
接着当然我们
获得温度样本

00:32:57.244 --> 00:32:58.745 
现在我来调试app

00:32:59.079 --> 00:33:00.781 
我想看看是什么情况

00:33:00.848 --> 00:33:02.249 
怎么来处理样本

00:33:02.683 --> 00:33:03.584 
所以我提出

00:33:04.251 --> 00:33:05.485 
po温度

00:33:06.587 --> 00:33:07.654 
我得到的是这个

00:33:08.856 --> 00:33:11.792 
实话讲 我看着它
觉得

00:33:12.025 --> 00:33:13.894 
作为默认值还不错

00:33:14.394 --> 00:33:17.297 
不过 我立刻发现
我想调整两个问题

00:33:17.931 --> 00:33:20.133 
为什么在把时间堆在两行？

00:33:20.200 --> 00:33:22.469 
我想把所有内容
都放在一行

00:33:22.836 --> 00:33:24.538 
而且如果是用a.m.
p.m.格式

00:33:24.605 --> 00:33:25.939 
表示上下午最好

00:33:26.573 --> 00:33:28.375 
还有温度

00:33:28.809 --> 00:33:29.943 
我看着它 觉得

00:33:30.043 --> 00:33:31.678 
标度是什么呢？

00:33:31.745 --> 00:33:32.579 
我不知道

00:33:32.679 --> 00:33:35.816 
是开氏
列氏还是兰氏温标？

00:33:36.016 --> 00:33:39.486 
我们在美国想用的是华氏温度

00:33:42.022 --> 00:33:45.192 
好消息是
我们可以用两步骤

00:33:45.859 --> 00:33:47.628 
解决所有这些问题

00:33:48.328 --> 00:33:49.162 
开始

00:33:49.630 --> 00:33:52.633 
第一步 我们把
时间按照一行打印

00:33:54.301 --> 00:33:56.870 
我做了这些
来实现这一点

00:33:57.171 --> 00:33:59.206 
用了NSDate格式器

00:34:00.741 --> 00:34:03.911 
因为我要在...
自己的应用中运行

00:34:04.178 --> 00:34:07.114 
因为我运行的对象格式代码

00:34:07.514 --> 00:34:09.783 
实际就是
正常的Swift代码

00:34:09.983 --> 00:34:12.553 
就是我通常编写app

00:34:12.853 --> 00:34:14.087 
所用的代码不论是什么框架

00:34:14.288 --> 00:34:15.121 
什么库

00:34:15.389 --> 00:34:18.859 
还是我的app完成任务
通常所用的技术

00:34:19.359 --> 00:34:21.428 
我在格式器中用就好了

00:34:21.862 --> 00:34:23.797 
在本例中 是NSDate格式器

00:34:24.931 --> 00:34:25.866 
第二步

00:34:26.400 --> 00:34:28.569 
选用华氏温度

00:34:29.837 --> 00:34:31.038 
怎么实现？

00:34:31.705 --> 00:34:33.172 
我们生成镜像

00:34:33.639 --> 00:34:34.507 
好了

00:34:34.875 --> 00:34:38.045 
现在我们可以说
温度数据对象

00:34:38.110 --> 00:34:41.815 
是作为包括三项内容
来构建

00:34:42.248 --> 00:34:44.251 
时间 摄氏温度

00:34:44.318 --> 00:34:45.585 
以及华氏温度

00:34:46.219 --> 00:34:48.722 
时间是存储在
对象内部的

00:34:48.922 --> 00:34:51.757 
真实时间数据的
字符串插值

00:34:52.659 --> 00:34:54.828 
因为是用字符串插值

00:34:54.895 --> 00:34:57.931 
因为我们提供了
自定义字符串可转换一致性

00:34:58.398 --> 00:35:00.567 
这些可以自动提取

00:35:01.835 --> 00:35:03.837 
这里还要
注意的一点是

00:35:04.304 --> 00:35:08.108 
当我获得两种温标
用摄氏度

00:35:08.175 --> 00:35:10.677 
和华氏度
来进行结果打印

00:35:11.278 --> 00:35:14.114 
我不能改变
存储在对象内的数值

00:35:14.715 --> 00:35:16.016 
当然 你会说 不要改

00:35:17.050 --> 00:35:19.520 
实际上 
要注意的是

00:35:19.686 --> 00:35:21.522 
不要用编写
进程格式器的

00:35:21.588 --> 00:35:23.557 
方法改变程序的状态

00:35:24.892 --> 00:35:27.661 
现在我们做了这么些工作
得到了这些东西

00:35:28.662 --> 00:35:30.697 
会怎样从中受益呢？

00:35:31.732 --> 00:35:33.967 
我们可以试着再做po

00:35:35.702 --> 00:35:36.970 
来吧

00:35:37.337 --> 00:35:38.705 
现在我再来看

00:35:38.772 --> 00:35:39.673 
我看到了对象

00:35:40.174 --> 00:35:42.109 
可以看到现在是

00:35:42.176 --> 00:35:44.444 
6:30 p.m.

00:35:44.711 --> 00:35:47.047 
是93.2度

00:35:49.049 --> 00:35:50.951 
大家可能会奇怪 的确

00:35:51.018 --> 00:35:52.753 
昨天库柏蒂诺是很热

00:35:54.821 --> 00:35:58.125 
现在我们完成了
但是这么做

00:35:58.192 --> 00:35:59.927 
是因为我们很聪明
提前完成了工作

00:36:00.594 --> 00:36:03.497 
有时 我会试着
调试一些内容

00:36:04.631 --> 00:36:07.167 
把自己的程序调试到位

00:36:07.367 --> 00:36:09.803 
结果有这样一个
很难复制的问题

00:36:10.003 --> 00:36:11.505 
最后发生了

00:36:12.406 --> 00:36:15.008 
不过现在真的
很难找到这数据

00:36:15.309 --> 00:36:17.211 
数据非常令人头痛
非常很复杂

00:36:17.277 --> 00:36:20.414 
真希望自己
之前做过这事儿

00:36:20.480 --> 00:36:23.217 
这样我就可以更简单地
看待我的数据了

00:36:24.051 --> 00:36:25.352 
不过 可惜没有

00:36:26.186 --> 00:36:27.588 
所有的希望都落空

00:36:28.622 --> 00:36:30.424 
不 没有

00:36:30.691 --> 00:36:33.427 
还可以添加一致性
和运行时间

00:36:33.493 --> 00:36:36.663 
通过表达式剖析器 
可以添加这些一致性

00:36:36.897 --> 00:36:38.866 
并运转 同时调试你的app

00:36:39.867 --> 00:36:40.701 
另一方面

00:36:41.401 --> 00:36:42.870 
你还不能改变它们

00:36:43.237 --> 00:36:45.239 
现有的一致性保留

00:36:47.207 --> 00:36:49.476 
你在REPL做尝试

00:36:50.010 --> 00:36:51.945 
你真希望自己能做po

00:36:52.179 --> 00:36:54.248 
我希望自己能
添加一致性

00:36:55.315 --> 00:36:57.017 
在REPL中也可以这么做

00:36:58.986 --> 00:37:02.089 
当然 但是我确定
大家都期望这样

00:37:02.523 --> 00:37:03.357 
为什么？

00:37:04.091 --> 00:37:05.759 
在环境中 也是如此

00:37:07.160 --> 00:37:08.428 
来看

00:37:11.298 --> 00:37:12.699 
看似...

00:37:13.967 --> 00:37:15.836 
我们在过去一年
在调试器方面

00:37:15.903 --> 00:37:17.371 
所做了许多动作

00:37:17.604 --> 00:37:20.541 
你们从凯特 西恩和我这里听到的

00:37:20.974 --> 00:37:26.713 
这些都离不开要在调试的同时
确保能够轻松访问

00:37:26.780 --> 00:37:28.815 
尽可能多的相关信息

00:37:30.284 --> 00:37:32.219 
访问Objective-C
运行时间

00:37:32.352 --> 00:37:36.156 
会让你在域无法获取之前
对之有更多了解

00:37:37.124 --> 00:37:38.659 
SDK模块

00:37:39.026 --> 00:37:44.698 
为应用所运行的操作环境

00:37:44.765 --> 00:37:47.201 
更多类型 更多函数
甚至有宏观

00:37:47.367 --> 00:37:48.669 
提供了
前所未有的访问程度

00:37:49.203 --> 00:37:51.471 
还有进程格式

00:37:52.739 --> 00:37:55.175 
进程格式是用来生成

00:37:55.242 --> 00:37:58.879 
跨界应用类型的
编译表示的

00:37:59.112 --> 00:38:00.848 
极好方法

00:38:01.181 --> 00:38:03.750 
它们可以应用在环境中
在REPL中

00:38:03.817 --> 00:38:05.352 
也可以是在调试器中

00:38:06.620 --> 00:38:08.355 
若要了解更多详情

00:38:08.755 --> 00:38:09.590 
可以随时

00:38:09.656 --> 00:38:12.392 
浏览我们的网站
Swift语言文件

00:38:12.492 --> 00:38:14.928 
或开发人员论坛
当然还有实验室

00:38:14.995 --> 00:38:17.798 
还可以给开发顾问
斯特凡发邮件

00:38:19.366 --> 00:38:22.402 
非常感谢
希望大家喜欢WWDC