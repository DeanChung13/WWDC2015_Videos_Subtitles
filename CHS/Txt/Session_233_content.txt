彼得·崔：大家好 下午好
欢迎参加《iOS高级手写输入》讲座
我是彼得
在Apple的iOS性能小组工作
今天和朋友UIKit小组的雅各布
准备给大家介绍更多有关
手写输入在iOS怎样运行 
以及怎样用它让自己的应用对手写输入更为灵敏
今天要讲的内容可是不少
正如前一个幻灯片所讲要想让自己的应用 
反应灵敏的话 
减少延迟是关键
我们将介绍延迟是什么
以及为什么要关注应用中的延迟
以及iOS中的一般性延迟问题
为了探讨延迟是来自哪里
我们将探讨并剖析iOS中
在手指下负责处理
手写输入和绘制像素图之间
对触控做出各种反应的主要内容
去年我们对iOS 9的系统
做了许多改进我们将向大家
介绍这些改进以及大家可以
用到的部分API 以便充分利用我们所做的这些改进
最后 我们会告诉大家一些技巧
和最佳实践 以便发现 分析
和解决在应用中出现的性能瓶颈
为何要关注降低应用中的延迟问题呢？
iOS手写输入是建立在直接操纵的理念上
也就是说用户实际上用手指
触碰物理对象 并在虚拟空间中做移动
例如 如果用户想要把这个圆
从A点移动到B点那么预期的结果
就是圆感觉被粘在手指指尖
你会注意到在本例中
这个圆会准确灵敏地随着
用户手指移动
但是一旦降低延迟
也就是手指移动和圆的移动
二者间的滞后这种直接
操纵的感觉就会开始被打破
在本例中 你可以看到圆在跟随手指而动而且并不像
是你是在手指周围移动圆
当用户手指移动
速度非常快时情况会越发严重
这样 手指与圆之间会形成相当距离
而且不再感觉手指与圆是处于粘合状态
圆此刻是在跟着手指移动
这类延迟会影响到iOS的各方面
从按下按钮到移动对象
到滚动任何内容甚至是网页都不可避免
但是我们可以确定有两三个应用
可以显著增加延迟作用
一种应用类型是绘图应用 
不仅是艺术家会被线条末端
和用户指尖的距离搞得心神不宁
艺术家通常要依赖应用
或用户界面的快速灵敏更新
以便及时调整物理行为
才能获得希望的结果
此外 游戏这类应用中的延迟
可能会让游戏很难继续
并会影响到应用的感知质量
这个延迟是从哪里来的呢？
是来源自许多不同地方
为了探讨哪里会产生延迟我们会聊聊
在处理触控和相应绘制 
触控当中系统中的所有不同部分
在讲座接下来的内容中
我们会用到很多这些管路图
我们要确保大家对其中的含义理解相同
在屏幕上 你会看到5个不同的盒子
每个盒子都代表显示器上
显示一帧内容所用的时间
我们的产品刷新屏幕是60赫兹
也就是每秒60次
那么每个盒子所代表的时间
大约为1/60秒
大家可能听到了每个盒子都代表显示帧
显示间隔或显示周期
这些都是一个意思
现在分割每个盒子的垂直线代表显示刷新
这个时间点上显示器上的一帧
和接下来要显示的帧进行交换
我接下来会用显示刷新
或同步刷新来表示这两个基本上也是相同内容
显示刷新在iOS中很重要
因为许多重要系统进程
都是由这个显示刷新来启动或触发
我们来具体看看在管线中在发生了些什么
管线的第一阶段是Multi-Touch
在这一个进程中硬件将扫描
显示器表面寻找触控
在我们的多数产品中这部分用时
会小于整个显示帧但在我们的部分产品中
这会占用整个显示帧
为了更直观我们用绿盒子来填充整个盒子
Multi-Touch一旦完成扫描显示器
会过滤掉屏幕上
所出现的任何噪音
UI应用的UITouch的回调将在靠近下一个
触控帧开始时被调用通常是在显示刷新开始后
这个点出现在应用应
该对手写输入做出反应时在绘图应用中
也许是标定点并连接这些点
你也许想做平滑处理令线条更流畅
在不是绘图应用的应用中
这里需要通过按下按钮或按键
来做出反应也许是生成视图 
视图控制器 并向用户呈现
这里所花费的时间是个变量
但可以占据一个显示帧
那么我再来填充整个盒子
一旦应用完成与触碰事件做出反应并相应更新状态
在下一个显示刷新时 Core Animation 就会启动
开始将视图和图层
翻译成GPU指令这可以被GPU渲染
你会注意到GPU不必等到下一个显示刷新开始的时候
它在Core Animation
给出它需要渲染帧的指令时候就会立即开始
同样 这些阶段的时间根据应用中的
视图复杂程度不同也是变量
最后一旦GPU完成渲染帧
这个帧就会在下一个显示刷新
开始时排队在显示器上显示
大家都明白在显示器上感知触控
直至画图需要占用若干帧数本例中 需要占用4帧
因此不是即刻完成
此外 这是管线
在应用处理之前正发生的触控时
其他的触控也会发生
这就是在管线不同的点经过的进程
我们来谈谈作为开发人员该怎样控制
并没有API可以改变Multi-Touch的行为
或显示器硬件图层
这是系统做出的处理
根据应用中的视图复杂程度你对Core Animation
渲染服务器和GP进行间接控制
但是你可以对应用几乎完全控制
我们就从这里开始
我刚说过在这个点上
要根据手写输入更新应用的状态
例如 在绘图应用中可以标定点
并彼此连接或是根据按下按钮创建视图
这里也许是发布OpenGL或Metal指令的位置
这里所花费的时间量是个变量
可以进行优化减少所用时间
我们鼓励大家这么做
但是当我们优化应用时你会注意到这点
Core Animation并不会进入填充UIKit
或应用所留下的空间
这是因为之前在iOS如何更新视图所导致
当你在iOS上更新视图状态时 
如果用UIMethods更新A CATransaction
视图属性的话可以显性提交
或UIKit将隐性为你生成一个
我们用红点来表示CATransaction提交
现在Core Animation 没有填入时间
是因为应用允许在一个
显示帧中多次升级状态
在本例中用第二个点表示
现在 为减少冗余任务量
或永远不会在显示器上出现的任务
Core Animation分批处理所有更新
并在显示刷新中进行一次渲染
那么我们将渲染这些
Core Animation事务的综合状态
一旦Core Animation在显示刷新时
快照视图它将会开始把所有你为之生成的逻辑视图
和图层翻译成GPU指令以便由GPU进行渲染
我刚说过一接到Core Animation
的必要指令GPU就会立刻启动
因此 如果优化Core Animation
或GPU的用时数量GPU就会填充所留下的空间
Xcode的视图调试器是理解视图层次复杂度的很好方法
也是找到可以取出的视图的很好方法从而可以优化应用
不过我们认识到 对视图的需求非常复杂
在一个显示帧中很难完全体现
那么iOS管线可以灵活处理这点
如果应用需要花费额外的时间渲染视图
我们可以把CoreAnimation
和GPU任务分到两个显示帧
当然 这增加了额外的延迟帧数
但是还可以在应用的各处获得
每秒60帧的流畅动画视图还更为复杂
并无手动触发选择快慢模式
这又是视情况而定而且是系统任意选定
所以重要的是我们理解什么内容可以触发进入更快模式
什么内容可以触发进入更慢模式
更快模式叫做双缓冲 
这么叫是因为有两个缓冲一个是为了引入GPU 
一个是为了LCD向用户显示
在显示刷新中大家回忆一下
Core Animation为自己和GPU抓取缓冲
并开始输出该帧的GPU指令
一旦GPU获得指令GPU就开始渲染
如果渲染在下一个显示刷新
发生前结束我们就把这个帧放入队列
在下一个显示刷新中显示
一旦到达显示刷新
这个帧就会进入屏幕
我们开始处理下一个帧
同样 GPU将做渲染再把这一帧放入队列
为下一个显示刷新进行显示
一旦开始显示刷新
这两个帧将交换位置
我们会回收绿色缓冲继续这一进程
只要应用有需要渲染的视图即可
现在都没问题
我们已经在一个显示帧完成Core
Core Animation和GPU任务
性能很好
可是如果无法做到所有这些 会怎样？
如果无法在一帧中完成呢？
那我们就进入了三重缓冲模式
同样Core Animation会输出GPU指令
GPU随后会渲染不过在本例中
在开始显示刷新时GPU并没有完成绿色帧的渲染
在本例中 因为我们还无法展示 
为了额外的帧蓝色帧延伸到屏幕上的情景
Core Animation现在需要分配第三个缓冲
开始处理下一个帧通过生成
第三个缓冲来实现这一点
Core Animation将开始为之输出GPU指令
同时GPU完成前一帧的渲染
然后前一帧将进入队列
在下一个显示刷新中显示
这一进程随后
和Core Animation渲染服务器输出GPU指令一起重复
GPU会对它们进行渲染
思路就是我们交换缓冲回收缓冲
然后进程重复进行
大家可能会想 所有这些幻灯片都在说Core Animation
我如果不用CoreAnimation会怎样？
如果我要优化应用
使用 Metal orOpenGL 会怎样？
大家可能会想与其让管线变成这样
让显示的帧变成4帧延迟
不如改作3帧延迟
不过这里不行
在iOS 8如果用Metal或OpenGL
Core Animation仍会作为仲裁器 确保你对...
Core Animation 内容在屏幕上所做的
任何更新 都与这些图层上的GPU 
OpenGL和Metal更新保持同步
在使用iOS 8的 OpenGL
或Metal时你仍有4帧延迟
那么我们谈到过iOS管线非常灵活
可以处理更为复杂的视图
可以实现每秒60帧动画
但是在5帧延迟中会怎样
怎样优化应用通过优化绘图 
把延迟降为4帧
但是 在本例中没有办法
可以实现更快 因为Core Animation
需要等到显示刷新开始
生成GPU指令才行
在iOS 9中我们去除了这种依赖性
现在可以在应用完成应用状态升级后 
立刻启动 CoreAnimation 任务
为了充分利用这些功能我们在iOS系统中引入了
一些新的API和新技巧
为了更多介绍这方面内容
有请雅各布
雅克布·肖：谢谢 彼得
我将向大家
介绍我们在iOS 9中新增的内容
以及怎样用它们实现app的更低延迟
今天我来讲三个问题
第一 低延迟支持Core Animation
然后是用户触控接合的新系统
最后是个很酷的系统可以在UIKit构建
触控预测
我们现在先从Core Animation低延迟开始
彼得讲过在iOS 8中
即便是最优化的app延迟的降低程度也是非常有限的
通过使用iOS 9的低延迟Core Animation
可以把app的帧和Core Animation的帧相结合
这会实现更低的延迟
这种功能的最好一点在于
它是自动发生的
你不必在app上做任何改变
除了优化你的性能表现之外
不过 还需要牢记一点
当app中的动画激活时 
低延迟模式是自动关闭的
这包括CA动画和UIKit动画
因此 如果需要app中 延迟是绝对最低水平
在显示器上触控激活时一定确保要
关闭这些动画功能
现在 系统还可以与MetalOpenGL内容配合使用
因此正如之前在iOS 8中所见
我们必须等额外的帧以便让GPU内容得以显示
但是有了新的低延迟模式 
我们可以在紧邻的下一帧
尽快显示这些内容
这些都是自动完成
使用CAeagllayer或CAMetalLayer即可
不过 如果有想和OpenGL或Metal内容
一起显示的CoreAnimation 内容的话
在app中还需要记住一点
这样 GPU内容 会尽快拉到
显示器上但是 coreAnimation内容
则需要更长时间才能过去
如果是这种情况那么默认状态
不会确保GPU内容会到达Core Animation
内容的同一帧
如果你希望二者同步的话这就会出现问题
例如如果你希望把UIKit内容绘制
在OpenGL视图上面就会出现这样的情况
这种情况下 你希望同步更新
类似这样这里有个属性
可实现这一功能
叫做PresentsWith Transaction
是在CAeagllayer和CAMetalLayer上面
当设置这个为False时这是默认值
那就可以尽快获得显示的GPU内容
但是当设置为True的时候
我们可以将GPU内容
和Core Animation内容同步 因此它们会同时
出现在显示器上
好 接下来 我们谈谈触控接合
在这之前
我先介绍一下 iPad Air 2
去年 我们推出iPad Air 2
显示屏更新速率为60赫兹
也就是说显示器每秒更新60次
和其他的iOS设备一样
它有个很酷的功能可以影响触控
和触控延迟我今天很兴奋能向大家介绍这点
这样它可实现120赫兹触控扫描更新速率
太酷了
这意味着扫描触控的速率是其他iOS设备的两倍
这非常棒因为你可以获得
用户手指和显示器互动时的更多信息
我们来看这会在实践中怎样影响app
使用60赫兹的触控扫描速率在用户手指
在显示器上移动时我们会定期采样
手指的位置并把这个信息提供给app
使用120赫兹扫描速率时也会发生同样的事情
但是因为是两倍的速率你会获得两倍的样本
这会让你掌握用户行为的更多信息
现在 一旦获得这些样本我们就会把它们转给app
通过这些 你会了解用户想要用触控做些什么
例如 在绘图app中你可能会把这些
连接起来 显示出用户想要实现的绘图
120赫兹的信息会提供更多信息量
以便会绘图有着更好的表示
现在我们看到了使用120赫兹的触控扫描速率所带来的好处
我们先来看它会怎样影响触控对显示管线的作用
这是60赫兹的触控扫描速率管线我们之前见过
我们主要来看管线的Multi-Touch阶段
在60赫兹水平上 我们每帧会获得一个新触控样本
在120赫兹水平上我们每次会获得两个样本
不过 要注意显示帧依然相同
因为显示器本身的更新速率相同
现在我们可以用这些新的触控样本 
并将其转至app而且app可以用它来更新绘图
而绘图会把在Core Animation
和显示器显示的内容做更新
但是你会注意到如果我们这么做
app的更新次数实际是显示器更新的两倍 这会导致app在做
无用功
我们介绍了触控接合系统来或者两方面的最好效果
这样可以从120赫兹触控扫描速率中获得更多信息 
但是不会在app中取消太多无用功
我们来看管线如何与接合一起改变
现在我们只能向app
每个显示帧交付一个触控
当首个触控出现时我们会把它交付给你
然后是下一帧我们会交付这一帧
的触控 同时还有上次我们发送触控
到app上时所出现的任何中间触控
每次用户要显示更多触控时这些都会重复一遍
我们提供当前的触控和任何接合触控
只要触控激活这些就会继续
现在 API使用这些接合触控就非常简单
这是UIEvent上的新方法叫做Coalesce Touches
For Touch
把这个方法转至正在看的触控
在上次我们交付 触控到app上之后
会返回一组所有的接合触控
为更好了解这个API该怎样使用
我们来看看触控处理一般在iOS上怎样运作
当用户首先触控显示屏时
我们会调用app上的Touches Began 
他们的手指移动时我们将调用Touches Moved
当手指从显示屏拿开时
我们会调用Touches Ended
现在 我们谈论这些触控回调时
另一个非常重要的回调是Touches Canceled
当通往app的触控流中断时 就会调用它
例如 如果用户从底部滑动
来激活Control Center
在这种情况下 当接收到系统手势 app将
获得部分初始触控回调
我们将获得Touches Canceled
用这种方法来清理之前的触控
回调所开始的任何内容
以及回退所做的任何改变都很重要
例如 在绘图app中你可能想清除用户所画的线条
现在我们了解了这些触控回调是怎么起作用
我们来看它们怎样和接合触控互动
我们交付给所有回调的触控我们称之为主触控
这部分在120赫兹扫描速率和60赫兹设备上都完全相同
但是 有了Coalesce
Touches For Touch方法
你可以通过这些接合触控了解更多信息
接合触控互动不仅有着中间触控的相关信息
它们还会提供主触控本身的副本
这其中最棒的一点是你可以进行选择
你可以来看主触控
如果不需要app的更高触控扫描速率
所增加的信息量
或者如果如果想要这些信息
可以来看接合触控而且你不必担心主触控
现在 我们再来看触控序列 
看它如何与主触控和接合触控相配合
随着用户手指的下滑
我们会给app一个主触控并将其副本作为接合触控
随着手指的移动
我们会交付新的主触控
和各自的一组接合触控
最后 随着手指离开
我们将提供最后的主触控
和任何其余的接合触控
这里我希望只展示每个主触控的一两个接合触控
需要注意的是app可以收到不同的数量这点很重要
如果app花费长时间处理一个触控
然后我们给你些时间跟进并等着跟进之后发送新的触控
如果出现这样的情况
那么未交付给你的触控稍后会作为接合触控发送给你
因此 确保你的代码对所收到的接合触控
数量 不存在任何依赖性
现在 在这些接合 触控的行为方式
和主触控的行为方式之间存在一些区别
其中之一与之前的位置有关
之前的位置可以通过Previous
Location In Viewfrom UITouch方法来获得
对主触控而言 这可以为app提供该触控
在交付时的最后位置
对接合触控而言其行为也非常相似
它可以提供针对app的
最后接合触控的位置
这就是需要只关注主触控
或只关注接合触控很重要的原因之一
这样 你就不会对之前的位置产生任何混淆
因此不要过界非常重要
在主触控和接合触控之间还有一个区别
就是UITouch对象本身如何行为
和主触控一起 每次触控交付
给app时 UITouch  实例就会再次使用
这样做很有用因为如果用户
立刻在显示器上使用多个手指的话这可以让你区别不同的触控
对接合触控而言这会有所不同
每次 向app交付接合触控时
我们交付一个新的具有新属性的
UITouch实例
所以你可以把这些当作是快照
而不是主触控的共享身份
现在 你理解了触控接合是如何工作的
让我们研究一下某些代码如何使用接合触控
这就是在app中可能用到的部分代码
可以用于绘图在移动的触控中可以用这类内容
这里我们会重复我们已有的触控
我们在抓取每个触控对应的代码行
然后 我们把最后的触控作为新样本加入该行的末尾
为了增加触控的接合支持我们只需要加上这一小部分代码
这里我们为给定的主触控
重复所有的接合触控
对于各个接合触控我们把它加为该行的样本
注意 我们只添加样本接合触控
而不是主触控
这就是触控接合
现在我想谈谈触控预测
这是我们刚加入UIKit中的很酷的系统
用它可以实现app中的更低延迟
正如我们交付的app新触控也会让你了解到未来
我们可以预测到用户触控在稍后会做些什么
这里的API和接合触控的API工作效果很相似
这是UIEvent上的新方法叫做Predicted Touches
For Touch
同样 经过主触控进入这个方法
然后返回一组预测触控
可以使用这些预测触控来更新绘图
或者是你用用户触控所做的其他任务
来获取更低的延迟
之前我们看到主触控和接合触控是如何相关联
而且预测触控的运行方法也非常相似
它们是与主触控相关的另一组触控
而且和接合触控一样作为快照发挥作用
现在 和接合触控相比预测触控
有一点不同那就是在发生新触控时的表现
当你获得新的主触控时你会获得一组新的
预测触控 然后你只想使用新的预测触控
任何之前的预测触控都不再有用
因为我们现在掌握了当时用户实际在哪里触控
因此 你一般想扔掉那些旧的预测触控
现在视图中之前的位置对预测触控进行类似的处理
它对其他触控类型也是如此对待
它指出之前的预测触控
所在的位置或者是针对第一个
预测触控它指出交付给app的最后位置
因此你可能会奇怪我们怎么会获得这些预测触控 其实相当简单
我们在每个iOS设备中都加上了时间机器
其实不是这样的
我们实际上是来看交付给app的
触控 并使用一套高度精密的算法来确定用户手指此刻
即将会做些什么
当我们获得新的触控样本时我们会更新预测
并把新的预测触控交付给app
现在每个预测触控都是完整的UITouch
对象 而且都填写了所有的属性
例如位置和时间标记
现在我们来看 预测触控对我们在看的管线会有什么影响
这是我们之前看到的主触控和接合触控我们可以轻松加入预测触控
每一帧 正如app获得主触控
你也可以获得一组预测触控
如果你获得主触控和接合触控
那么预测触控是可以获得的更多信息
在新触控交付时会重复这一进程
要注意的是接合触控的和预测触控是独立的
你可以用其中一个而不用另一个
60赫兹和120赫兹触控扫描速率设备
均可支持预测触控
我们先来看怎么把触控预测
加入我们刚才看的代码之中
只需要加上这一小部分代码
我们要做的是首先删除我们加入
代码行中的之前的任何预测触控
这很重要 因为我们现在有了这些触控的实际位置
然后 我们会重复运行已有的预测触控
对于每个预测触控我们把它加为代码行的样本
但是注意 我们这里加入预测样本
调用的方法不同于调用常规样本的方法
这样我们可以将样本标记为下次运行该代码时需要将之删除
这就是触控接合和触控预测
大家现在看到了所有这些技巧
我们来看看把它们结合起来会是什么效果
在iOS 8中 有个优化的app 
这就是你可以获取的触控延迟视图
在触控首次出现和显示器
更新触控信息之间 
我们测量延迟的时间
因此 你可以看到在iOS 8中
我们会有4帧延迟
通过使用低延迟Core Animation和iOS 9
我们可以从中删除一帧延迟
通过使用触控接合并在高触控
扫描速率设备上运行
你不仅可以获得用户触控的更多信息量还可以从一开始
就删除半帧延迟
但是不仅如此！
通过使用触控预测你可以获得
未来用户触控将往何处去的大约一帧延迟
这会让你为用户提供有效延迟
也可以减少一帧以上延迟
那么算在一起在 iOS 9 你可以为用户降低
约1.5帧延迟这要比iOS 8
中的4帧延迟提高很多
那么我们觉得这的确了不得
我很希望大家在app中运用这些技术
为用户提供更低的延迟体验
现在我想把讲台交回给彼得
请他来讲讲怎样调试app
彼得·崔：谢谢 雅各布
现在我们了解了一些iOS 9中的最新低延迟模式
我们还将介绍一些如何利用
这些来调试应用这样就可以满足
时间的一个显示帧的要求还可以把帧快速地显示出来
首先 要确保应用在完成最少量的任务
则要将应用需要完成的任务量最小化
通过雅各布刚介绍的接合触控API
你可以享用到iPad Air 2
高保真手写输入的好处同时确保
完成的任务量将在屏幕上显示的图像
此外 要记住用户只会关心
在设备显示器上可以看到的内容
应用可以跟踪屏幕
以外的环境状态
但是 最终 你需要确保渲染工作要仅限于
那些最终要在屏幕上
生成显示图像的必要工作
如果准备构建应用
计算应用在CPU上
所花费时间 Time Profiler是个不错的办法
Time Profiler将通过
在固定间隔取样 显示应用在CPU中所用的时间
在本例中在Time Profiler
我选用的是16毫秒间隔
这基本和一个显示帧相对应
你可以看出本例中的应用
只用了其中一小块时间 
在本例中 是3毫秒
如果是要测量并简要介绍
在CPU方面的表现这也没问题
那么GPU会怎样呢？
在Xcode调试会话中GPU
报告中的每秒传输帧数工具会为应用的GPU
表现给出高层视图
在本例中 你可以看到这个应用是60帧每秒
这是相对较低的GPU帧时
在本例中仅为3.8毫秒
不过要记住这是关于应用运行的高层概视图
其中并未提供也许会导致
掉帧的单独帧的详细信息
如果需要此类精度
可以使用新的GPU驱动工具
我们今年在Xcode中就有包括
GPU驱动工具可以在你使用应用的同时
显示GPU激活的准确时间
在本例中 你可以看到我的应用中
在顶点和片段着色器所用时间相对较少
实际上 这只是在显示器上
显示一帧内容所用时间的一小部分
注意这里只有两种颜色
这两种颜色代表着使用双缓冲方案的两个缓冲器
如果应用在Core Animation
和GPU中花费更多时间你会在这里
看到三种颜色代表系统里正在进行的三重缓冲
我们谈了很多降低延迟的内容
并让应用灵敏度更高不过最终
实现出色的iOS 体验是用户
自然和本能的体验
而让应用感觉更生动则是实现这一目标的另一种不错的方法
去年 我们对系统的每个部件都进行了认真的思考 
想方设法使其比以前更快更好
在这一过程中我们改进了API
为大家提供更多控制和信息
来了解系统的运行状况
有了OpenGL Metal和 Core Animation
的最新低延迟模式你可以在向用户显示帧 
以及如何与屏幕上的其他内容 
同步的时候 实现更多控制
利用触控接合你可以利用
所有硬件及其所有出色的功能 向用户
提供出色体验
使用触控预测我们可以让你少许窥探未来预测触控即将往何处去
最后我们构建并生成部分不错的工具
以便你了解应用的性能表现这样你可以对之进行改进 
以便向用户提供更好的体验
在Apple 我们致力于让我们的产品
使用体验比以往更出色
我们认为通过降低延迟是实现这一点的不错方法
我们愿意邀请各位朝这方面努力
大家在developer.apple.com
可以了解到我们今天探讨的技术工具和API等更多详情
我们还想邀请大家参加开发者
论坛中的开发者
技术对话
我们今天介绍了许多不同的新技术
今年和往年有过许多
与这一讲座相关话题的出色讨论
例如 如果你非常感兴趣简要介绍应用的GPU性能
如果非常非常想着手尝试
新的GPU工具我将向大家推荐
《Metal性能优化技术》讲座
这是今天早些时候的一场讲座
其中介绍了一整套不同的技术 
可以用来优化GPU运行而不只是说使用Metal
此外如果Time Profiler常出问题 可以试试去听
《深度剖析》讲座这是昨天的一场讲座
其中深度剖析了该怎样使用Time Profiler
并了解你的应用完成任务的情况
最后 如果大家的确感兴趣
在Core Animation和 管线的GPU阶段究竟在做些什么
这部分内容我们今天讲过
我将向大家推荐去年WWDC的
《高级图形和动画》讲座
所有这些讲座和许许多多其他讲座
都可以在开发人员门户网站找到developer.apple.com
希望大家今天收获很多在本周的全部环节中
我希望大家喜欢WWDC的内容
谢谢