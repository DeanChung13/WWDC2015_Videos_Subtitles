00:00:19.987 --> 00:00:21.221 
奈特·希拉德：早上好 各位 

00:00:24.625 --> 00:00:26.660 
早上好 或者我該說 “早安”

00:00:27.027 --> 00:00:28.929 
“美好的一天”“早上好”

00:00:29.162 --> 00:00:30.230 
我叫奈特·希拉德

00:00:30.664 --> 00:00:33.500 
今天我會再次介紹國際化應用的新特性

00:00:34.101 --> 00:00:36.170 
我會再次介紹我們之前
介紹過的新的API

00:00:36.270 --> 00:00:39.139 
以及對當前API所做的改進 

00:00:39.206 --> 00:00:41.808 
讓你的APP可以在全世界範圍使用

00:00:42.910 --> 00:00:45.279 
首先 這是地球

00:00:46.146 --> 00:00:48.515 
有超過70億人在地球上

00:00:49.116 --> 00:00:51.451 
對於這70億人 蘋果已經賣出了

00:00:51.518 --> 00:00:54.555 
超過10億臺iOS設備

00:00:54.988 --> 00:00:56.790 
而且 Mac OS X
的安裝數量

00:00:56.857 --> 00:00:58.525 
達到800萬臺

00:00:59.126 --> 00:01:02.963 
我們在全世界有超過450家實體店

00:01:03.530 --> 00:01:06.767 
還有140萬個以上的APP

00:01:07.234 --> 00:01:09.102 
不斷被全球範圍內的開發者

00:01:09.503 --> 00:01:11.104 
和用戶所使用着

00:01:12.105 --> 00:01:16.043 
這是一個驚人的數字但如果今天在現場

00:01:16.109 --> 00:01:18.045 
只需要一個數字 那麼是這個

00:01:19.313 --> 00:01:24.518 
69% 現在蘋果69%的
收益來自於國際市場

00:01:24.852 --> 00:01:26.286 
現在這份收益是很大的

00:01:26.353 --> 00:01:28.121 
展望一下 我們來看個圖表

00:01:28.822 --> 00:01:31.825 
蘋果現在的收益超過二分之三來自於

00:01:31.892 --> 00:01:33.193 
美國之外的地方

00:01:33.660 --> 00:01:35.295 
這些用戶對於

00:01:35.362 --> 00:01:37.397 
APP的使用有着不同的期待

00:01:37.764 --> 00:01:39.600 
包括語言的不同

00:01:39.666 --> 00:01:42.703 
地區的不同 和文化的不同
這些你要記在腦子裏

00:01:43.203 --> 00:01:44.938 
現在 我們一起細說

00:01:46.373 --> 00:01:49.409 
有趣的是 這裏 我們41%

00:01:49.476 --> 00:01:51.478 
的用戶來自中國和日本

00:01:52.346 --> 00:01:53.780 
現在 我想這裏有個常見誤會

00:01:53.847 --> 00:01:56.350 
國際化你的APP
意味着要打入歐洲市場

00:01:56.984 --> 00:02:00.087 
事實上 這點很重要

00:02:00.153 --> 00:02:01.955 
但你還要謹記中國和日本

00:02:02.322 --> 00:02:04.124 
用戶方面的挑戰

00:02:04.958 --> 00:02:07.494 
也就是 他們不使用字母文字

00:02:07.961 --> 00:02:09.630 
沒有字之間沒有空格

00:02:10.030 --> 00:02:14.701 
而且 除此之外 
UI上日文和中文會變的很短

00:02:15.435 --> 00:02:18.705 
因此 好消息是
如果你使用我們的API

00:02:19.606 --> 00:02:21.808 
我們能夠快速地
對你的APP進行國際化

00:02:22.809 --> 00:02:25.145 
所以 今天我們會在談起四個 

00:02:25.212 --> 00:02:28.715 
你必須考慮的四大塊領域：
本地化 格式化

00:02:29.049 --> 00:02:30.384 
信息處理和佈局設計

00:02:31.318 --> 00:02:35.622 
那首先 說說本土化

00:02:36.757 --> 00:02:38.425 
現在 通過本土化 我是指

00:02:38.492 --> 00:02:40.761 
讓你的APP使用用戶的語言

00:02:41.361 --> 00:02:44.631 
字面上而言就是翻譯UI文字  

00:02:44.932 --> 00:02:46.099 
進一步而言

00:02:46.533 --> 00:02:49.503 
就是翻譯出文字背後你所要表達的觀念

00:02:50.537 --> 00:02:52.906 
所以 從這點開始比較如容易入手 

00:02:52.973 --> 00:02:56.844 
觀察用戶如何操作系統

00:02:58.312 --> 00:03:01.148 
左邊我們有OS X系統
右邊是iOS系統

00:03:01.415 --> 00:03:03.050 
這裏有語言和地區面板

00:03:03.617 --> 00:03:06.253 
在左手邊這裏 在OS X截圖上

00:03:06.320 --> 00:03:07.788 
你會看到首選語言列表

00:03:08.388 --> 00:03:11.124 
事實上 這裏很重要的是
這是個有序的語言列表

00:03:11.592 --> 00:03:13.560 
用戶可以添加多種語言 並且  

00:03:13.627 --> 00:03:16.430 
如果設定語言無法用於UI的話

00:03:17.097 --> 00:03:18.866 
系統會自動選擇下一種語言

00:03:19.766 --> 00:03:23.237 
例如 用戶已經選了
瑞士德語作爲主要語言

00:03:23.670 --> 00:03:26.139 
但實際上我們沒有添加瑞士德語

00:03:26.573 --> 00:03:28.675 
因此對於這個UI它會變回英文界面

00:03:29.276 --> 00:03:30.978 
這個恢復設置事實上很普遍

00:03:31.044 --> 00:03:33.247 
所以你要從開發者的視角對此進行思考

00:03:33.981 --> 00:03:35.549 
此外    

00:03:35.616 --> 00:03:37.251 
對於APP所顯示的語言

00:03:37.851 --> 00:03:39.553 
我們有額外的地域優先

00:03:40.787 --> 00:03:42.389 
右邊的OS X系統是默認關閉的

00:03:42.689 --> 00:03:44.591 
而iOS系統中要進入下一級才能設置

00:03:45.526 --> 00:03:48.195 
現在事實上這些會應用於相關單元  

00:03:48.762 --> 00:03:52.533 
用於顯示特定地區時間 日程數據

00:03:55.335 --> 00:03:59.406 
所以說 對於目標語言

00:03:59.673 --> 00:04:02.576 
把你想翻出來的
背後含義翻譯出來並不容易

00:04:03.577 --> 00:04:05.546 
對於更多關於

00:04:05.612 --> 00:04:07.915 
優先語言和區域設置的差別

00:04:08.549 --> 00:04:11.418 
請看去年的講演 "國際化高級議題"

00:04:11.852 --> 00:04:13.120 
那有更多相關細節

00:04:14.188 --> 00:04:16.822 
所以 我們提供了
更多原來沒有的設置  

00:04:16.890 --> 00:04:19.226 
如果用戶有個人喜好

00:04:19.358 --> 00:04:21.028 
但我們也允許用戶進行自定義設置

00:04:21.695 --> 00:04:23.997 
iOS9系統和El Capitan
系統新的地方 

00:04:24.331 --> 00:04:26.266 
是我們可以自定義數字系統

00:04:27.734 --> 00:04:28.569 
正如你在這看到的

00:04:29.236 --> 00:04:31.805 
假設我們有個用戶是講烏爾都語的

00:04:32.406 --> 00:04:34.474 
他們選擇了烏爾都語
作爲他們的首要語言

00:04:34.541 --> 00:04:36.410 
那麼系統會恢復到

00:04:37.578 --> 00:04:40.480 
我們操作系統所顯示的語言 英語

00:04:41.849 --> 00:04:45.953 
默認情況下 
用戶會看到標準的阿拉伯數字

00:04:48.088 --> 00:04:52.960 
雖然我們允許在iOS 9、OS X
和 El Capitan系統中

00:04:53.026 --> 00:04:56.096 
自定義這些設置
來取代已有的數字系統

00:04:56.730 --> 00:04:59.833 
很多人沒有意識到的是
全球有很多種類的數字系統

00:05:00.434 --> 00:05:02.035 align:start position:10%
最上面有阿拉伯語數字

00:05:02.102 --> 00:05:04.738 
還有波斯-阿拉伯數字

00:05:04.805 --> 00:05:06.039 
常在中東地區使用

00:05:06.640 --> 00:05:08.075 
所以用戶可以選擇這種設置  

00:05:08.475 --> 00:05:10.811 
在整個操作系統中會有很有趣的變化

00:05:11.778 --> 00:05:13.514 
例如 我們有天氣APP

00:05:13.780 --> 00:05:16.783 
現在由於開發者還未此進行任何修改 

00:05:17.251 --> 00:05:19.720 
但是我們稱之爲“本地化格式字符”

00:05:20.187 --> 00:05:21.922 
或者是NS數字格式器的API

00:05:22.489 --> 00:05:24.992 
已經可以免費改變數字系統了

00:05:25.626 --> 00:05:27.895 
在左邊 我們有使用阿拉伯數字的用戶

00:05:28.195 --> 00:05:30.097 
在右邊 我們有
波斯-阿拉伯數字的用戶

00:05:30.797 --> 00:05:34.601 
我們發現他們每一位的數符
在UI上都改變了

00:05:35.702 --> 00:05:38.105 
包括屏幕上方的時間標記

00:05:39.406 --> 00:05:41.909 
對於一個研發人而言 這很有趣 

00:05:42.176 --> 00:05:44.878 
我們稱之爲
“本地化格式字符”這是免費的

00:05:45.879 --> 00:05:49.583 
現在 除了用戶在屏幕上看的語言外

00:05:49.983 --> 00:05:52.553 
用戶還會在你的應用上輸入文本

00:05:54.054 --> 00:05:57.991 
在新iOS9系統裏我們爲
印度語系語言添加五種新鍵盤

00:05:59.026 --> 00:06:01.094 
在右邊 這裏 
你看到泰盧固語輸入鍵盤 

00:06:02.029 --> 00:06:04.598 
而且 現在我們可以爲四種語言

00:06:04.665 --> 00:06:06.700 
進行輸入預測 包括韓語

00:06:06.834 --> 00:06:08.602 
墨西哥西班牙語 俄語和土耳其語

00:06:09.603 --> 00:06:11.939 
現在 從開發者的視角而言

00:06:12.206 --> 00:06:16.176 
我們發現通常這些字符並不是
我們通常意義上的字符

00:06:16.710 --> 00:06:19.179 
在泰盧固語輸入鍵盤
這裏我們加入了標記字符 

00:06:19.446 --> 00:06:22.683 
實際上 還有別的字符
才能輸入一個可識別單元

00:06:23.584 --> 00:06:24.751 
再往深一點說

00:06:26.220 --> 00:06:30.591 
所以現在我們已經看過了
用戶如何在你的操作系統改變設置

00:06:31.091 --> 00:06:34.795 
但本地化工具如何
把字符翻譯成用戶看到的字符呢？

00:06:35.829 --> 00:06:39.533 
本地化工具主頁面是字符串文件

00:06:40.234 --> 00:06:42.002 
字符串文有自己的格式

00:06:42.436 --> 00:06:45.405 
首先有註釋 是c語言的註釋語法  

00:06:45.772 --> 00:06:49.009 
其次是左側的開發語言

00:06:49.276 --> 00:06:50.477 
目標語言在右側

00:06:51.044 --> 00:06:53.046 
我們這裏有德文字符文件  

00:06:54.681 --> 00:06:57.651 
字符文件儲存在lproj目錄文件包

00:06:58.352 --> 00:06:59.553 
在資源目錄下

00:07:00.187 --> 00:07:03.590 
英語有自己的字符文件包 
同樣的德語也有 

00:07:04.424 --> 00:07:08.495 
我們自從
XCode 6系統就允許你們

00:07:08.762 --> 00:07:12.132 
輸出本地化設置
一般是XLIFF文件格式

00:07:12.766 --> 00:07:15.536 
然後可以以字符文件
重新輸入到你的項目中

00:07:16.036 --> 00:07:17.604 
關於這其中更多的信息

00:07:17.905 --> 00:07:19.439 
我建議你們去看上一年的講演

00:07:19.506 --> 00:07:21.108 
"XCode 6本地化"

00:07:22.476 --> 00:07:24.945 
所以 我們已經看過了
用戶是如何改變設定的

00:07:25.512 --> 00:07:27.915 
我們已經看過了本地化工具

00:07:28.182 --> 00:07:30.184 
如何把你屏幕上的字符翻譯成你想要的

00:07:30.350 --> 00:07:32.352 
但是  作爲一名開發者
你如何利用這些設置呢？

00:07:34.054 --> 00:07:34.888 
這正是...

00:07:34.955 --> 00:07:36.924 
NSLocalizedString
的功能

00:07:36.990 --> 00:07:39.026 
在Objective-C
這是項龐大的工作

00:07:39.493 --> 00:07:42.262 align:start position:10%
在Swift上 
我們將其開發成高級功能

00:07:42.329 --> 00:07:45.232 
它需要五個參數
其中三個是有默認值的  

00:07:45.766 --> 00:07:47.301 
有趣的是 在Swift中

00:07:47.367 --> 00:07:49.837 
我們做到了 
其實設置評註這是無奈之舉

00:07:50.604 --> 00:07:53.040 
我們這是要強調這是重要因素

00:07:53.106 --> 00:07:54.975 
它能夠爲你的翻譯器提供上下文

00:07:55.676 --> 00:07:58.412 
在某些情況下給定單詞
可能是模棱兩可的

00:07:58.478 --> 00:08:01.748 
這個註釋參數會幫助你進行自定義

00:08:02.983 --> 00:08:04.852 
所以 重點是你想要翻譯的字符 

00:08:05.252 --> 00:08:07.254 
註釋是來註釋解釋它的

00:08:07.888 --> 00:08:09.890 
現在 對本土化字符是起了 

00:08:09.957 --> 00:08:12.960 
除此在外 我們也允許你
可以獲得本地化格式字符串

00:08:13.427 --> 00:08:16.129 
也就是說可以
填入帶有變量參數的字符串

00:08:16.964 --> 00:08:19.132 
所以 你可以稱之爲本地化格式字符串

00:08:19.700 --> 00:08:23.637 
帶有特定格式的格式字符串

00:08:23.971 --> 00:08:26.573 
可以填入到有
參數變量的格式字符串之中

00:08:27.808 --> 00:08:29.943 
而且事實上結合使用更爲常見

00:08:30.177 --> 00:08:32.513 
根據NSLocalized-
String的叫法

00:08:32.578 --> 00:08:34.448 
我們稱之爲“本地化格式字符串”

00:08:36.049 --> 00:08:37.518 
現在 看看它的應用如何

00:08:37.951 --> 00:08:39.720 
做一個簡短的演示可能助理解

00:08:42.990 --> 00:08:46.460 
假設我們希望翻譯的字符的位置是：X

00:08:47.060 --> 00:08:49.329 align:start position:10%
現在 也假設我們有一個變量位置

00:08:49.396 --> 00:08:50.964 
且已經被翻譯器植入到

00:08:51.198 --> 00:08:52.766 
用戶的實際位置

00:08:54.101 --> 00:08:55.502 
這就是字符串文件的樣子

00:08:56.069 --> 00:08:58.372 
左手邊是等待被翻譯的字符串

00:08:58.438 --> 00:09:00.040 
右手邊是翻譯好的變量

00:09:01.141 --> 00:09:04.011 
事實上我們會發現
翻譯好的變量仍然存在變量字符串

00:09:04.511 --> 00:09:06.547 
百分比添加意味着填充字符串變量

00:09:07.781 --> 00:09:11.285 
因此 這是在英語工環境下的
我們定位在舊金山

00:09:11.752 --> 00:09:12.886 
也同樣在日語環境下生效

00:09:13.187 --> 00:09:14.188 
這就是等效字符串

00:09:15.522 --> 00:09:17.424 
因此 你知道了這些之後

00:09:18.225 --> 00:09:20.327 
你腦中可能會出現一些假設

00:09:21.195 --> 00:09:24.631 
其中一個是 本地化格式字符串的順序

00:09:25.032 --> 00:09:27.067 
應該會與英文版的相同

00:09:27.901 --> 00:09:29.369 
現在我們會看看爲什麼不是這樣

00:09:30.070 --> 00:09:32.573 
我們根據NSLocalized-
String結果

00:09:32.639 --> 00:09:33.907 
調動本地化格式字符串

00:09:34.441 --> 00:09:36.810 
我們想要翻譯
字符串 “copy X is Y”

00:09:37.211 --> 00:09:39.646 
這裏的X是用戶名
Y是我們想要複製的東西

00:09:40.447 --> 00:09:42.182 
這裏 我們通過
hairForce1

00:09:42.316 --> 00:09:45.152 
這是克雷格·費德里吉選擇
InstaMessage進行處理

00:09:45.285 --> 00:09:46.119 
以及“照片”

00:09:46.620 --> 00:09:49.156 
在我們的Iproj中
在不同的Iproj中的

00:09:49.223 --> 00:09:52.125 
字符串文件中開發者可以假設

00:09:52.192 --> 00:09:53.927 
參數將以同樣的順序出現

00:09:54.761 --> 00:09:55.896 
這可能對英語環境奏效

00:09:56.597 --> 00:09:57.931 
而事實上對德語無效

00:09:59.166 --> 00:10:02.169 
這些參數需要轉化成
德語中有意義的順序

00:10:02.903 --> 00:10:05.005 
因此 這裏就是定位器生效位置

00:10:05.405 --> 00:10:07.474 
以及可以添加位置格式參數的位置

00:10:07.741 --> 00:10:09.643 
這就使得原先的第二個參數

00:10:09.710 --> 00:10:11.245 
變爲第一個反之亦然

00:10:12.145 --> 00:10:16.984 
因此 接着 開發者
並不需要做任何事情

00:10:17.117 --> 00:10:20.254 
他們調用 本地化格式字符串 以及
NSLocalizedString

00:10:20.320 --> 00:10:23.690 
但是 重要的是要牢記
從開發者角度而言

00:10:24.157 --> 00:10:26.660 
你認爲的第一個字符也許並不是第一個

00:10:27.194 --> 00:10:31.365 
因此 假如你設定
操作會以相同的順序執行

00:10:31.665 --> 00:10:33.267 
那麼你可能需要重新考慮這個假設

00:10:34.902 --> 00:10:38.372 
因此 現在我們知道
字符串文件是如何存儲

00:10:38.639 --> 00:10:39.907 
以及存儲在哪個目錄下

00:10:40.607 --> 00:10:44.378 
但至此你可能會嘗試做如下的事情

00:10:45.279 --> 00:10:49.016 
你將語言變量設置爲
你所選擇的語言隊列的第一對象

00:10:49.516 --> 00:10:52.753 
這與我們之前看到的UI元素
即首選語言列表相一致

00:10:53.453 --> 00:10:56.990 
再者 你將後綴Iproj添加於此 

00:10:57.324 --> 00:10:58.725 
並調用資源通道

00:10:58.959 --> 00:11:02.863 
假設我們想要
本地化一個停止符號圖形

00:11:04.798 --> 00:11:08.235 
因此 我們在這裏假設
我們的單獨文件包只有唯一一個

00:11:08.302 --> 00:11:10.370 
對應西班牙語的es.lproj

00:11:11.004 --> 00:11:13.640 
但是我們假設我們
用戶的首選語言是墨西哥西班牙語

00:11:14.308 --> 00:11:17.845 
運用這種特定的方法
用戶將不會得到任何反饋

00:11:18.579 --> 00:11:19.646 
爲什麼會這樣

00:11:20.113 --> 00:11:23.350 align:start position:10%
那是因爲我們沒有運用標準的
NSBundle API

00:11:23.851 --> 00:11:26.386 
如果NSBundle不可用
系統將自動

00:11:26.753 --> 00:11:29.957 
退回到可執行位置

00:11:30.257 --> 00:11:32.492 
因此es-MX將會退回到es

00:11:33.193 --> 00:11:35.662 
另外 我們還有其它智能的回退邏輯

00:11:35.729 --> 00:11:39.733 
例如從印度英語 回退到英式英語 

00:11:40.801 --> 00:11:42.202 
即在英國使用英語

00:11:42.970 --> 00:11:46.773 
因此 假如你使用這些API

00:11:47.407 --> 00:11:49.776 
你會得到合適的資源

00:11:50.177 --> 00:11:51.345 
以及回退

00:11:51.645 --> 00:11:53.180 
“資源圖像”會給你圖像提示

00:11:53.680 --> 00:11:55.749 
“完整資源路徑”會給你完整的資源

00:11:55.816 --> 00:11:57.417 
‘URL資源’會給你

00:11:57.851 --> 00:12:00.187 
任何其他既定的文件格式

00:12:01.522 --> 00:12:03.657 
因此 我們可以看到 運用

00:12:03.724 --> 00:12:06.560 
NSBundle API可以使你
更容易地找到你感興趣的資源

00:12:07.427 --> 00:12:12.499 
另外 然而你可能會認爲
有些東西只能通過代碼實現

00:12:13.567 --> 00:12:15.269 
現在 你們當中有多少人
會寫這樣的代碼

00:12:15.702 --> 00:12:19.173 
比 你想要翻譯字符串“還剩下X天”

00:12:19.806 --> 00:12:22.142 
我們知道在英語中如果只有一天

00:12:22.442 --> 00:12:24.611 
我們會用還剩下X天  如果是兩天

00:12:24.678 --> 00:12:26.580 
或以上 我們用“還有多天”

00:12:27.347 --> 00:12:28.749 
這適用於英語

00:12:28.882 --> 00:12:30.551 
適用於一天和五天

00:12:31.051 --> 00:12:33.720 
但對於其它語言而言複數形式方面

00:12:34.121 --> 00:12:37.057 
不具有同樣的邏輯
假設一個給定的數字

00:12:37.758 --> 00:12:40.994 
例如在俄語中對於單獨一個 

00:12:41.061 --> 00:12:43.997 
我們有一種形式同樣對於少數 許多

00:12:44.298 --> 00:12:45.332 
以及更多 也有一種形式

00:12:46.233 --> 00:12:48.702 
因此 這並不適用於

00:12:48.769 --> 00:12:50.571 
不同複數規則的語言

00:12:50.637 --> 00:12:51.939 
爲了幫助你更好地瞭解此問題

00:12:52.439 --> 00:12:53.941 
我們提供了複數規則

00:12:54.374 --> 00:12:55.742 
出現已經有好幾個版本

00:12:56.109 --> 00:12:57.477 
但需要強調的是...

00:12:58.579 --> 00:13:00.480 
字符串stick文件本質上是

00:13:00.948 --> 00:13:03.050 
你存儲在項目中的一個plist文件

00:13:03.483 --> 00:13:04.618 
它是一個本地化資源

00:13:04.685 --> 00:13:06.553 
因此 它位於特定定位

00:13:07.054 --> 00:13:08.322 
Iproj目錄之下

00:13:09.022 --> 00:13:10.691 
同樣 你也有一個給定的密匙

00:13:10.924 --> 00:13:12.926 
該密匙鏈接了數字參數

00:13:13.293 --> 00:13:16.797 
取決於與不同的數字參數
就會產生不同的成果

00:13:17.497 --> 00:13:21.535 
我發現這裏有很多文本
尤其是當你在這裏添加俄語組件的時候

00:13:23.537 --> 00:13:27.207 
這就是說 你知道
英語中對一個有一種形式

00:13:27.341 --> 00:13:29.910 
對其它則有另一種形式然而 俄語中

00:13:29.977 --> 00:13:31.912 
一個 少數 許多
以及其它分別有它的各自形式

00:13:32.246 --> 00:13:34.748 align:start position:10%
現在 當你要格式化
stick文件的時候

00:13:34.815 --> 00:13:37.184 
我奉勸你查看一下
“國際化和本地化指南”

00:13:37.584 --> 00:13:39.520 
這涉及到許多我們沒有在這裏

00:13:40.220 --> 00:13:42.322 
提出來的細節 
例如如何格式化 如何創建文件夾

00:13:43.423 --> 00:13:47.060 
因此 從開發者的
角度來說非常容易上手

00:13:47.961 --> 00:13:50.030 
再次說明 我們調用的是
“本地化格式字符串”

00:13:50.097 --> 00:13:52.266 
是基於NSLocalized-
String的結果

00:13:52.332 --> 00:13:55.135 
你傳輸的字符串就是
字符串string詞典的密匙

00:13:56.103 --> 00:13:59.339 align:start position:10%
然後你傳輸一個數字參數

00:13:59.406 --> 00:14:03.877 
填充到返回的格式化字符串變量中

00:14:05.112 --> 00:14:07.748 
因此無論是對於英語
還是俄語中的一天 兩天

00:14:07.814 --> 00:14:09.816 
五天 都是正確的

00:14:10.184 --> 00:14:12.986 
在這裏我們會發現俄語中的兩天
和五天是不一樣的

00:14:14.721 --> 00:14:16.857 
讓我們再多談談字符串stick

00:14:17.691 --> 00:14:19.259 
我們在iOS 9中有新的機制

00:14:20.794 --> 00:14:24.097 
可以讓你在屏幕上
利用字符串stick來格式化字符串

00:14:25.766 --> 00:14:28.335 
應當說這同樣
存在於EI Capitan系統中

00:14:28.402 --> 00:14:31.171 
首先 讓我們一個普遍的問題

00:14:31.772 --> 00:14:34.174 
在你的Interface-
Builder應用裏

00:14:34.241 --> 00:14:36.643 
你設置了出現在你屏幕中央的字符
串 “歡迎來到商店”

00:14:37.377 --> 00:14:38.912 
這可能會在iPad Air中奏效

00:14:40.681 --> 00:14:43.183 
但它不一定也會在
IPhone 6 裏奏效

00:14:43.350 --> 00:14:45.552 
甚至在IPodTouch效果更糟

00:14:45.886 --> 00:14:49.323 
解決這個問題的一個辦法是
運用自動佈局以及特定限制

00:14:49.389 --> 00:14:51.892 
這常常是解決這類問題的辦法
我們晚一點會深究這個問題

00:14:52.326 --> 00:14:54.928 
但事實上 另一個
解決這個問題的辦法是

00:14:54.995 --> 00:14:58.465 
運用新的“可變寬度規則類型”機制

00:14:59.132 --> 00:15:01.001 align:start position:10%
這指的是在字符串
stick內添加條目

00:15:01.268 --> 00:15:03.103 
這樣可以根據可用空間的大小

00:15:03.170 --> 00:15:05.305 
而產生不同的效果

00:15:06.139 --> 00:15:09.743 
在iOS上 這是指可用屏幕寬度M 

00:15:10.143 --> 00:15:12.779 
這指的是標準系統字體中

00:15:12.846 --> 00:15:13.914 
大寫字母M的可見寬度

00:15:14.715 --> 00:15:16.583 
在這裏我們要公佈三種不同的尺寸

00:15:17.084 --> 00:15:19.119 
我們定義如果有20M可用

00:15:19.553 --> 00:15:21.622 
我們就將字符串顯示爲“你好”

00:15:22.155 --> 00:15:23.557 
如果是25 爲“歡迎”

00:15:23.757 --> 00:15:25.392 
如果是50 則爲“歡迎來到商店”

00:15:26.760 --> 00:15:28.829 
對於開發者來說這麼使用相當容易

00:15:29.196 --> 00:15:30.697 
你可以在字符串stick文件中

00:15:31.231 --> 00:15:34.101 
調用NSLocalized-
String祕鑰 

00:15:34.568 --> 00:15:36.370 
然後將它設置爲UI界面標籤對象

00:15:37.938 --> 00:15:40.841 
適用於iPad Air
iPhone 6

00:15:41.074 --> 00:15:42.075 
和iPod Touch

00:15:42.676 --> 00:15:43.744 
但效果是不同的

00:15:44.244 --> 00:15:46.647 
有趣的是 我們以英語爲例子

00:15:47.047 --> 00:15:50.684 
但事實上它對各國的用戶都有重要影響

00:15:51.251 --> 00:15:53.921 
通常將英語翻譯爲其他語言

00:15:54.021 --> 00:15:54.855 
都會比原文長

00:15:55.255 --> 00:15:58.825 
因此 這可以使你
從不同的翻譯版本中

00:15:59.126 --> 00:16:01.862 
選擇出不同語言的給定字符串
因此這是一個非常有用的工具

00:16:03.530 --> 00:16:08.569 
在OS X上情況是不一樣的

00:16:08.635 --> 00:16:12.673 
同樣的 在OS X上 你調用

00:16:13.073 --> 00:16:15.108 
然後傳輸你的
字符串stick字典密匙

00:16:15.676 --> 00:16:18.111 
然後你調用變量擬合佈局寬度

00:16:18.712 --> 00:16:22.182 
在OS X系統中 該整數變量

00:16:22.516 --> 00:16:24.618 
其實是一個任意數量

00:16:25.052 --> 00:16:27.054 
這可以是任意值因爲它被界定爲

00:16:27.120 --> 00:16:28.655 
字符串stick內的其他相對值

00:16:31.458 --> 00:16:35.062 
因此使用整數值20的效果是“您好”

00:16:35.662 --> 00:16:38.298 
25是“歡迎” 
50是“歡迎來到商店”

00:16:39.099 --> 00:16:42.169 
總體上我們
使之更加容易現在翻譯字符串

00:16:42.236 --> 00:16:44.338 align:start position:10%
更容易 更靈活了

00:16:44.705 --> 00:16:46.974 
世界上各種語言在屏幕上
顯示的字符串效果更好了

00:16:48.509 --> 00:16:50.744 
接下來 來說說格式化

00:16:51.512 --> 00:16:54.681 
簡單的轉化屏幕上的
字符串一般是不夠的

00:16:55.115 --> 00:16:57.317 
此外 你還得考慮
格式化日期 數字 時間

00:16:57.551 --> 00:17:01.722 
在iOS 9和ElCapitan
新品上還需要格式化名字

00:17:02.756 --> 00:17:05.224 
所以 首先從格式化數字開始

00:17:05.291 --> 00:17:06.993 
這裏有一個正確的方法一個錯誤的方法

00:17:07.261 --> 00:17:09.429 
假設  我們希望
向用戶顯示常數圓周率

00:17:10.497 --> 00:17:13.400 
一個天真的做法是
使用格式參數百分比3F 

00:17:13.534 --> 00:17:17.570 
也就是說用3位精確浮點數參數

00:17:17.637 --> 00:17:19.006 
來表示字符串變量

00:17:20.741 --> 00:17:22.910 
在英文中 這個是適用的 
圓周率顯示爲3.142

00:17:24.278 --> 00:17:27.915 
若你進行轉換而你的用戶
是在德國進行操作的

00:17:28.448 --> 00:17:30.484 
他們會得到這個字符串

00:17:30.551 --> 00:17:32.352 
乍一看 好像是正確的

00:17:32.819 --> 00:17:36.290 
但事實上 德國用戶
得到的圓周率是3,142

00:17:36.723 --> 00:17:39.693 
因爲在德國 十進制數字

00:17:40.227 --> 00:17:42.329 
不好意思 千位數和
十進制數字事實上會被互換

00:17:42.396 --> 00:17:44.731 
也就是說
我們在美國英語中用句號

00:17:45.032 --> 00:17:47.267 
他們則逗號 反之亦然

00:17:48.202 --> 00:17:49.603 
所以 利用這個事實

00:17:50.037 --> 00:17:52.105 
你可以調用本地化格式字符串

00:17:52.372 --> 00:17:54.708 
進入你先前用過的同一格式參數中

00:17:54.775 --> 00:17:57.911 
因爲用戶所在場所不同
實現方式也會有所不同

00:17:58.512 --> 00:18:02.049 
意思就是 現在英語用戶
和德語用戶的東西是一樣的

00:18:02.916 --> 00:18:06.520 
高級選項下本地化格式字符串
用的是NS數字格式器

00:18:07.621 --> 00:18:11.558 
Ns數字格式器也有不少
改進這些我們都會講到

00:18:12.593 --> 00:18:18.065 
在iOS9和El Capitan中
NS數字格式器的數字格式不同

00:18:18.532 --> 00:18:20.467 
除了現有的貨幣格式外

00:18:20.834 --> 00:18:22.603 
現在 我們有貨幣ISO碼格式

00:18:23.103 --> 00:18:26.540 
以及貨幣複數格式和外幣賬格式

00:18:27.307 --> 00:18:31.111 
很有趣 這裏有外幣賬格式
如果它是負數

00:18:31.612 --> 00:18:33.714 
那麼它則會在括號裏

00:18:34.081 --> 00:18:35.415 
在會計領域裏 這很正常

00:18:36.750 --> 00:18:39.720 
同樣地 我們增加順序格式

00:18:39.786 --> 00:18:41.688 
意思就是 排序列表裏數字的顯示方式

00:18:42.122 --> 00:18:44.224 
輸入42 你得到42nd

00:18:45.492 --> 00:18:48.161 
所以 除了格式化數字外

00:18:48.929 --> 00:18:51.865 
格式化日期也很容易出錯

00:18:52.266 --> 00:18:54.201 
這裏有一個用來格式
化日期的很簡單的方法

00:18:54.768 --> 00:18:57.237 
我們用這個格式參數
初始化一個NS字符串

00:18:57.738 --> 00:19:01.542 
也就是說對於美國英語用戶來說

00:19:01.608 --> 00:19:03.710 
它顯示的是今天的日期 早上9點

00:19:04.978 --> 00:19:07.247 
所以在美國英語環境下
我們會得到這個字符串

00:19:07.314 --> 00:19:08.849 
看起來是恰當且正確的

00:19:09.283 --> 00:19:12.286 
但對於意大利語用戶來說
我們得到了相同的字符串

00:19:12.686 --> 00:19:14.321 
而這個在意大利語種的意思截然相反

00:19:14.488 --> 00:19:17.191 
在意大利語中 意思是12月6日

00:19:18.492 --> 00:19:20.894 
此外可以對時間在稍微多些闡明

00:19:20.961 --> 00:19:21.895 
我們馬上會講到這點

00:19:22.496 --> 00:19:25.766 
所以試圖解決這個問題的一個方法是

00:19:25.832 --> 00:19:27.167 
創建一個NS日期格式器

00:19:27.501 --> 00:19:29.403 
事實上 NS日期格式器
是正確的解決方式

00:19:29.469 --> 00:19:30.938 
但這種使用方法是錯誤的

00:19:31.572 --> 00:19:33.307 
這裏 我們創建一個日期格式參數

00:19:33.774 --> 00:19:37.311 
現在 日期格式
蘊含字符串一個明確的順序

00:19:37.744 --> 00:19:40.514 
你在這裏提供的準確變量

00:19:40.581 --> 00:19:45.953 
將在你所在的場所擴展成
你所看到的恰當的字符順序

00:19:46.553 --> 00:19:49.323 
再一次 在意大利這個地方
收到的字符串是錯誤的

00:19:50.224 --> 00:19:51.892 
事實上 通過在你的NS日期格式器上

00:19:51.959 --> 00:19:53.994 
創建日期格式和時間格式

00:19:54.061 --> 00:19:55.395 
就可以很容易的解決這個問題

00:19:55.896 --> 00:19:58.465 
我們爲NS日期格式器
提供若干即用型的格式

00:19:58.532 --> 00:20:02.336 
這允許你指定空格數量

00:20:02.402 --> 00:20:04.438 
使其適用於對應的字符串寬度

00:20:05.172 --> 00:20:09.076 
在這裏 我們調用在這裏我們爲日期
和時間創建ShortStyle

00:20:09.776 --> 00:20:12.913 
因此 在意大利收到的反饋是...

00:20:14.615 --> 00:20:15.749 
字符串相同但是變量不同

00:20:16.216 --> 00:20:21.455 
對於意大利用戶來說
現在意思是6月12日

00:20:21.922 --> 00:20:24.157 
這和美國英語用戶看到的是一樣的

00:20:25.125 --> 00:20:29.463 
現在有時候 這些日期格式和時間格式
並未如你所需的那樣明確

00:20:30.097 --> 00:20:33.233 
爲了解決這個問題iOS 9
和El Capitan的新特性

00:20:33.300 --> 00:20:35.702 
允許你在模板裏創建本地日期格式

00:20:36.703 --> 00:20:40.274 
這裏你提供一個模板

00:20:40.407 --> 00:20:41.975 
變量視你所給的位置情況重新排列

00:20:43.043 --> 00:20:46.747 
現在這是 當個人風格
無法立即提供足夠信息

00:20:47.114 --> 00:20:50.684 
比如說 用戶希望第二個字符串也出現

00:20:51.084 --> 00:20:53.253 
但第二個字符串通常不是簡潔的格式

00:20:54.421 --> 00:20:57.824 
使用模板 我們允許你有
24個小時的時間

00:20:59.660 --> 00:21:03.630 
允許你重新安排月份和日期參數

00:21:04.798 --> 00:21:08.101 
我們已經看過如何格式化數字
如何格式化日期

00:21:08.502 --> 00:21:10.437 
但是 同樣重要的是如何格式化單位

00:21:12.172 --> 00:21:15.442 
事實上 這是個非常簡單的事例

00:21:15.509 --> 00:21:17.578 
但是卻很真實很真實的發生過

00:21:18.212 --> 00:21:21.882 
假設你想把數量6磅轉換成其它語言

00:21:22.583 --> 00:21:26.153 
一個很簡單的做法是轉化字符串

00:21:26.653 --> 00:21:28.622 
你的左手邊有X pounds

00:21:28.989 --> 00:21:31.792 
對於意大利語用戶我們將
它轉換成X chilogrammi

00:21:31.859 --> 00:21:34.928 
即kilogram的意大利語
是chilogrammi

00:21:35.629 --> 00:21:39.566 
這顯然是錯誤的在英語裏我們說6磅

00:21:40.267 --> 00:21:43.670 
在意大利語裏 變成說6千克
這個數量無法對等6磅不等於6千克

00:21:43.737 --> 00:21:47.074 
事實上 數量是不相等的
6磅作爲一個單位並不等於6千克

00:21:47.574 --> 00:21:48.909 
這樣做是錯誤的

00:21:49.676 --> 00:21:52.246 
NSMassFormatter
的方法會更簡單些

00:21:52.679 --> 00:21:54.348 
NSMassFormatter

00:21:54.414 --> 00:21:55.782 
與
NSEnergyFormatter

00:21:55.849 --> 00:21:57.484 
和
LengthFormatter一樣

00:21:57.551 --> 00:22:00.120 
假設在高級選項下你用的是公制單位

00:22:00.554 --> 00:22:03.590 
所以當你爲可變重量分配一個浮點數時

00:22:03.891 --> 00:22:05.559 
它假設你用的是千克

00:22:06.026 --> 00:22:08.395 
所以你格式化一個
NSMassFormatter

00:22:08.562 --> 00:22:10.163 
創建它的單位格式 

00:22:10.430 --> 00:22:14.835 
然後你調用string from
kilograms 重量單位是千克

00:22:15.502 --> 00:22:18.405 
在英語環境下它返回44.092

00:22:19.306 --> 00:22:22.776 
事實上這些單位
轉換成了美國常用的單位

00:22:23.544 --> 00:22:26.180 
此外 在意大利語種你得到的
是20 chilogrammi

00:22:26.380 --> 00:22:31.585 
這是正確的你所提供的
重量數量轉換的條件也是正確的

00:22:32.352 --> 00:22:34.354 
所以 使用
NSMassFormatter

00:22:34.421 --> 00:22:36.290 
可以非常容易的地顯示目標單位

00:22:37.224 --> 00:22:38.992 
iOS 9系統的新特性

00:22:39.893 --> 00:22:43.697 
允許你格式化名字
iOS 9和El Capitan

00:22:44.398 --> 00:22:47.935 
爲了理解的實用性
我們來看看並排在一起的兩個名字

00:22:48.335 --> 00:22:50.637 
第一個是Grace
Murray Hopper

00:22:51.271 --> 00:22:53.273 
這是一位著名的計算機科學家來自美國

00:22:53.674 --> 00:22:56.710 
她定義了“bug”這個術語
並開發了第一個編譯器

00:22:57.511 --> 00:23:00.414 
此外 我們來看一箇中文名字
“Wang Dongling”

00:23:01.081 --> 00:23:02.616 
這是爲著名的書法家

00:23:02.716 --> 00:23:04.818 
他在杭州
Apple Store外寫書法

00:23:05.519 --> 00:23:07.421 
這兩個名字都由三個部分組成

00:23:08.021 --> 00:23:10.490 
對它們進行說明的方法
很重要同時也是不同的

00:23:11.892 --> 00:23:16.330 
在英語裏
我們一般只稱呼名中間名和姓

00:23:16.897 --> 00:23:21.001 
在我們試圖將這個概念套用到
中國用戶上時我們來看看會發生什麼

00:23:22.169 --> 00:23:25.806 
順序從左到右先前排在最後的名字

00:23:25.873 --> 00:23:26.840 
現在是第一個

00:23:27.541 --> 00:23:29.710 
中文名完全不存在了

00:23:30.210 --> 00:23:34.781 
從左到右 原先是第一個的

00:23:36.517 --> 00:23:38.118 
現在變成最後一個了

00:23:38.719 --> 00:23:44.024 
從這裏可以看到應用
在這些概念中的術語和標籤同樣重要

00:23:44.825 --> 00:23:48.395 
所以 我們引入了NS 人名組件

00:23:48.595 --> 00:23:50.330 
和NS人名組件格式器

00:23:50.898 --> 00:23:53.233 
曾經有個笑話說推特不適合這套方法

00:23:53.333 --> 00:23:55.903 
使用方面需要花些時間也有點困難

00:23:56.203 --> 00:23:58.038 
但是 換而言之它所做的是非常精確的

00:23:58.105 --> 00:23:59.373 
它將人名格式化了

00:24:00.841 --> 00:24:01.942 
這是使用方法

00:24:02.643 --> 00:24:05.479 
你初始化一個NS人名組件對象

00:24:06.013 --> 00:24:08.849 
你填入教名中名和姓氏

00:24:08.949 --> 00:24:10.617 
這是針對美國英語用戶如何使用它

00:24:11.418 --> 00:24:13.320 
對於俄國用戶來說

00:24:13.387 --> 00:24:14.621 
你可能需要將Fyodor

00:24:14.688 --> 00:24:16.990 
Mikhailovich
Dostoyevsky

00:24:17.057 --> 00:24:18.892 
同樣的 填寫在相同的域裏

00:24:20.761 --> 00:24:22.229 
接下來是如何將它格式化

00:24:22.930 --> 00:24:25.766 
你初始化NS人名組件格式器對象

00:24:26.300 --> 00:24:29.002 
正如我們用其他
NS格式器所看到的它有一個格式組件

00:24:29.369 --> 00:24:30.704 
這裏 我們指定簡潔格式

00:24:31.405 --> 00:24:34.942 
然後 你在人名組件對象中
調用人名組件字符串

00:24:35.876 --> 00:24:37.744 
這次調用的結果如下

00:24:38.512 --> 00:24:41.014 
有五種適用的格式

00:24:41.215 --> 00:24:43.617 
默認 簡潔 中等格式  長格式
和縮寫  對每種語言來說

00:24:43.684 --> 00:24:44.651 
我們的方法是正確的

00:24:45.252 --> 00:24:46.253 
需要注意一些事情

00:24:46.386 --> 00:24:49.389 
事實上簡潔格式的變化
和下面這些有關係

00:24:49.690 --> 00:24:53.694 
即用戶的位置
以及個人用戶在郵箱 聯繫方式

00:24:53.760 --> 00:24:55.662 
日曆設置和加載設置

00:24:56.697 --> 00:24:59.199 
同樣地 對於俄語的名字來說

00:24:59.266 --> 00:25:01.435 
取名字 中名 和姓氏

00:25:01.502 --> 00:25:05.205 
第一個字符組成的縮寫名字是不存在的

00:25:05.272 --> 00:25:07.040 
所以 我們退回到簡潔格式

00:25:07.941 --> 00:25:12.179 
這真的很簡單可以立即
對用戶的名字進行格式化

00:25:14.014 --> 00:25:17.451 
這就是數字 日期 
時間 單位 和名字

00:25:18.785 --> 00:25:20.354 
我們已經知道如何轉化

00:25:20.854 --> 00:25:22.222 
如何在你的UI上轉化字符串

00:25:22.456 --> 00:25:24.791 
如何將用戶看到的單位格式化

00:25:25.359 --> 00:25:28.462 
此外 重要的是
如何處理從用戶那收到的文本

00:25:31.031 --> 00:25:33.500 
這涉及到考慮字符是什麼

00:25:33.967 --> 00:25:36.703 
在不同情況下的不同變化

00:25:36.770 --> 00:25:39.573 
你是如何搜索那個字符的

00:25:39.640 --> 00:25:42.142 
同樣地你是如何將它轉換成其他腳本的

00:25:43.177 --> 00:25:45.646 
開始這部分之前
我們來問一個哲學問題

00:25:45.913 --> 00:25:46.914 
什麼是字符

00:25:47.748 --> 00:25:51.218 
開始之前 我們來問問
這個表情符號裏有多少個字符

00:25:51.952 --> 00:25:56.256 
最近 我們在iOS中引入了這個
用鍵盤也可將其敲打出來

00:25:57.891 --> 00:25:59.626 
儘管表面上看它只包含單一的單位

00:25:59.693 --> 00:26:01.628 
但答案並不是立即就可以看出來

00:26:02.129 --> 00:26:05.265 
高級選項下 它由一 二 三 四 五

00:26:05.666 --> 00:26:09.937 
六 七 八個單獨字符表示

00:26:10.737 --> 00:26:13.874 
事實上 這些是萬國碼代碼點

00:26:14.074 --> 00:26:16.443 
並取決於你所使用的編碼
事實上它可能多於8個

00:26:16.510 --> 00:26:17.678 
比如說 可能是十一 

00:26:18.245 --> 00:26:21.582 
但是這也就是說 你不需要考慮它

00:26:23.250 --> 00:26:29.323 
現在 很明顯的一個地方是列舉字符串

00:26:29.890 --> 00:26:33.961 
假設有個字符串測試
後面緊跟着我們剛討論過的表情字符

00:26:34.661 --> 00:26:37.898 
現在你想在字符串內列舉每個字符

00:26:37.965 --> 00:26:39.900 
並調用character
at index

00:26:40.834 --> 00:26:43.737 
這將返回到包含
單獨字符串的unichar

00:26:44.338 --> 00:26:45.372 
但這並不是你想要的

00:26:45.772 --> 00:26:48.942 
事實上 這顯示的是問號字符

00:26:49.009 --> 00:26:51.512 
有時是三個不可打印字符

00:26:51.578 --> 00:26:53.714 
由於某種原因這其中有個中心

00:26:54.515 --> 00:26:56.350 
所以它不是 顯然
這個方法絕對是錯誤的

00:26:57.017 --> 00:27:00.554 
列舉字符串的正確做法是
調用“列舉子字符串隊列”

00:27:01.121 --> 00:27:03.991 
此外 並表達“組成成字符序列”

00:27:04.391 --> 00:27:06.093 
這就使得這個字符

00:27:06.159 --> 00:27:09.863 
在高級選項下的再現與視覺再現相匹配

00:27:10.464 --> 00:27:13.667 
因此 當我們在字符串上調用時
我們恰好得到六個字符

00:27:15.102 --> 00:27:17.804 
這就是列舉一個字符串的應用

00:27:18.505 --> 00:27:21.441 
但是有時你想把那個
字符串轉化成不同格式

00:27:22.776 --> 00:27:26.246 
iOS 9新特性具備這個功能

00:27:26.313 --> 00:27:28.015 
iOS 9和
El Capitan具備能

00:27:28.148 --> 00:27:29.950 
轉化字符串的功能

00:27:30.884 --> 00:27:32.753 
假設字符串是“istanbul”

00:27:33.554 --> 00:27:35.055 
首字大寫字符串的一個簡單方法是

00:27:35.122 --> 00:27:39.159 
只需調用“首字大寫字符串”屬性

00:27:39.960 --> 00:27:41.795 
對於美國英語用戶而言
這看起來是正確的

00:27:41.962 --> 00:27:44.865 
事實上 對於英語用戶來說
這是正確的大寫方式

00:27:45.232 --> 00:27:47.801 
但對於使用土耳其語的人來說

00:27:47.868 --> 00:27:49.703 
小寫字母i變成了大寫字母I

00:27:51.371 --> 00:27:53.140 
爲了能立即實現該功能

00:27:53.473 --> 00:27:57.511 
你可以簡單的在那個字符串上
調用“本地化首字大寫字符串”

00:27:57.744 --> 00:28:01.381 
因此你可以得到正確的
首字大寫的字符串

00:28:01.481 --> 00:28:03.917 
也就是說字符串的第一個字符是大寫的

00:28:04.785 --> 00:28:08.088 
除了“本地化首字大寫字符串”

00:28:08.155 --> 00:28:10.457 
我們還提供了“本地化大寫字符串”

00:28:10.524 --> 00:28:11.692 
和本地化小寫字符串

00:28:12.626 --> 00:28:13.794 
這就是它們看起來的樣子

00:28:14.695 --> 00:28:17.064 
所以 你立即就可以通過

00:28:17.130 --> 00:28:18.832 
簡單使用已經存在的
API的本地變量

00:28:19.099 --> 00:28:20.400 
善用這些字符

00:28:21.435 --> 00:28:24.605 
這就是如何轉化字符串的例子

00:28:24.805 --> 00:28:26.974 
假設你想尋找一個字符串

00:28:27.841 --> 00:28:30.410 
回到一開始的問題字符是什麼

00:28:31.678 --> 00:28:34.982 
在用戶需要搜索
一個指定的字符串時

00:28:35.048 --> 00:28:36.116 
他們期待的是什麼

00:28:36.850 --> 00:28:40.521 
假設這裏有一個變量
代表德語的 uber

00:28:41.221 --> 00:28:42.322 
其中有個字母U

00:28:42.723 --> 00:28:44.358 
剛好又是元音U

00:28:45.292 --> 00:28:48.529 
用戶可能會想
按照通常英語書寫格式

00:28:48.595 --> 00:28:51.899 
寫出小寫的uber就可以找到字符串

00:28:52.766 --> 00:28:56.570 
作爲開發者你可能調用
“字符串範圍”進行尋找

00:28:57.104 --> 00:28:58.505 
但結果是0

00:28:59.640 --> 00:29:02.609 
在iOS 9和
El Capitan新特性中

00:29:02.676 --> 00:29:05.145 
正確的搜索方法是
“本地化標準字符串範圍”

00:29:05.913 --> 00:29:10.584 
這可使你在其他對發音不敏感的
字符串和對大寫不敏感的字符串裏

00:29:11.051 --> 00:29:13.620 
搜索這個字符串

00:29:14.488 --> 00:29:17.591 
此外 它還爲指定用戶位置提供修正值

00:29:18.358 --> 00:29:20.861 
所以 在這裏
通過簡單調用這些新API

00:29:20.961 --> 00:29:25.899 
我們通過“大寫U-變音-ber”裏
找到了 uber小寫字符串

00:29:27.267 --> 00:29:30.037 
除在字符串裏進行搜索之外

00:29:30.103 --> 00:29:32.673 
有時你可能想轉化整個字符串

00:29:33.841 --> 00:29:35.475 
這就是轉換的由來

00:29:36.243 --> 00:29:40.247 
轉換允許你在整個字符串的大寫字母和
小寫字母變量之間進行轉化

00:29:40.747 --> 00:29:43.650 
此外他們允許你進行萬國碼標準化

00:29:43.784 --> 00:29:47.154 
也就是說 他們可以
元音字符拿出並將它們分開

00:29:47.221 --> 00:29:50.190 
比如帶有一個元音變音的A
變成了A加元音變音字符

00:29:51.091 --> 00:29:54.528 
此外 還允許你進行
腳本對腳本的轉化或直譯

00:29:54.595 --> 00:29:58.632 
也就是說中文漢字
字符可轉化成拉丁文字符

00:29:59.366 --> 00:30:02.102 
先前 這種轉化只能在
Core Foundation進行

00:30:03.237 --> 00:30:05.138 
因爲iOS 9 和
El Capitan新特性

00:30:05.939 --> 00:30:07.741 
你可在
Foundation裏進行轉化

00:30:09.209 --> 00:30:11.178 
你只需簡單調用“字符串應用轉化”

00:30:12.212 --> 00:30:14.414 
然後提供一個字符串或常量

00:30:15.382 --> 00:30:18.852 
表達你想要如何轉化字符串轉化成

00:30:19.453 --> 00:30:21.121 
這裏 我們想把這個表情字符翹起拇指

00:30:21.688 --> 00:30:27.060 
或 直譯成 XML 表達方式

00:30:28.595 --> 00:30:32.332 
做到這點只需調用“字符串應用轉化”

00:30:32.699 --> 00:30:35.169 
並提供“NS字符串轉
化之XML十六進制”

00:30:35.903 --> 00:30:39.373 
此外 我們也爲漢字字符與拉丁文

00:30:39.439 --> 00:30:43.810 
以及歐洲不同腳本提供了這種轉換功能

00:30:44.545 --> 00:30:46.413 
所以 很容易

00:30:46.480 --> 00:30:50.217 
就可以轉化 轉換不同腳本間的字符串

00:30:50.284 --> 00:30:54.354 
並將單個字符轉換成不同的表現方式

00:30:55.355 --> 00:30:58.926 
這就是在我們的系統內

00:30:59.293 --> 00:31:00.661 
如何處理從用戶那收到的文本

00:31:01.562 --> 00:31:04.731 
此外 重要的一點是
在屏幕布局視覺元素的方法

00:31:06.433 --> 00:31:10.237 
這就是自動佈局的由來

00:31:11.238 --> 00:31:12.973 
自動佈局很早就發佈了

00:31:13.407 --> 00:31:18.011 
最初的意圖是
在適合你的屏幕數量的基礎上

00:31:18.078 --> 00:31:20.214 
用不同的方式格式化指定UI

00:31:20.914 --> 00:31:23.817 
在我們爲iOS 和 OS X
發佈了不同的形狀因子後

00:31:23.884 --> 00:31:27.254 
自動佈局就變得越來越重要了

00:31:28.222 --> 00:31:31.592 
自動佈局有一個附加的好處

00:31:31.959 --> 00:31:34.561 
就是將應用的UI本地化

00:31:36.597 --> 00:31:38.665 
這是UI外觀的樣子

00:31:38.866 --> 00:31:42.069 
所以 假設 比如說
我們想在iCloud中增加新日曆

00:31:42.636 --> 00:31:44.338 
這是一個英文版本的UI外觀

00:31:44.872 --> 00:31:46.773 
這個UI功能或許已經相當完善

00:31:47.074 --> 00:31:50.511 
當你在不同情況下測試時
它可能會起作用

00:31:50.811 --> 00:31:53.814 
可能會與在運行時間內增加的
內容不斷地相互作用

00:31:54.915 --> 00:31:58.452 
但是對於它如何運作

00:31:58.519 --> 00:32:00.454 
你並未在其他UI或語言中設置修正值

00:32:00.821 --> 00:32:04.424 
那麼它就可能打破
你到剛纔爲止所做的這些假設

00:32:05.592 --> 00:32:11.164 
這個UI和前面的一樣 語言是希臘語
乍一看 它似乎可以用

00:32:11.765 --> 00:32:16.270 
當你再仔細看時 你會發現事實上
這個字符的長度等於3.5個字符

00:32:16.870 --> 00:32:19.039 
UI的附加部分也出現這個問題

00:32:19.806 --> 00:32:22.009 
現在 我要說的是
在不同位置進行測試時

00:32:22.075 --> 00:32:23.710 
沒有必要本地化app 

00:32:24.211 --> 00:32:26.013 
多虧了XCode皮膚菜單

00:32:26.346 --> 00:32:29.049 
現在你可以使用雙寬度僞距語言
和右至左僞距語言

00:32:29.116 --> 00:32:30.851 
測試你的app

00:32:31.418 --> 00:32:33.820 
使用這種方法可以不需要轉換

00:32:34.188 --> 00:32:36.456 
就可以在在不同的
環境中查看UI是如何操作的

00:32:37.558 --> 00:32:39.927 
假設你將使用自動佈局

00:32:40.360 --> 00:32:42.696 
並已經正確設置壓縮優先權

00:32:43.130 --> 00:32:45.098 
和抗壓縮優先權

00:32:45.566 --> 00:32:46.934 
這就是出來的UI外觀

00:32:49.203 --> 00:32:52.573 
可以看到 先前是3.5個字符
現在變成了12個

00:32:53.173 --> 00:32:55.175 
差別非常大

00:32:55.542 --> 00:32:58.278 
我們不通過指定靜態限制

00:32:59.179 --> 00:33:02.983 
而是根據它可增長限制
允許標籤擴大可用的空格

00:33:03.350 --> 00:33:06.987 
也就是說
限制少於或等於到屏幕邊的寬度

00:33:07.721 --> 00:33:11.625 
更多信息請重新看看昨天的演講

00:33:12.192 --> 00:33:14.228 
自動佈局的神祕之處 第1和第2部分

00:33:14.962 --> 00:33:16.096 
裏面有很多信息

00:33:16.430 --> 00:33:19.166 
關於如何在世界範圍內
以及不同的設備方向上

00:33:20.434 --> 00:33:22.402 
在你的app上使用自動佈局

00:33:23.570 --> 00:33:28.108 
在UI中佈局 還需要注意一點

00:33:28.442 --> 00:33:30.978 
即表格單元格會自己變動大小

00:33:31.912 --> 00:33:33.180 
這涉及到動態類型

00:33:33.480 --> 00:33:36.984 
左邊是美國英語UI
右邊是北印度語UI

00:33:37.718 --> 00:33:41.522 
注意到了吧 事實上
單獨的單元格高度並不相同

00:33:41.955 --> 00:33:43.991 
這是因爲單元格自動改變大小

00:33:44.558 --> 00:33:46.860 
我們允許單元格佔用

00:33:47.160 --> 00:33:49.363 
由於語言行高度變化而多出來的空格

00:33:50.197 --> 00:33:53.233 
若你使用標準UI控制和UI視圖

00:33:53.600 --> 00:33:55.869 
就可以看到 而且是免費的

00:33:56.603 --> 00:33:59.907 
作爲開發者 
需要注意的一點是你不能假設

00:33:59.973 --> 00:34:01.708 
提供的表格單元格 有一定的高度

00:34:02.176 --> 00:34:06.547 
在不同位置它可能擴大
以佔用不同數量的空格

00:34:08.514 --> 00:34:15.022 
在iOS 9中 很重要的關鍵一點是
我們完全支持從右到左的語言

00:34:15.322 --> 00:34:18.358 
左邊 是英語UI右邊是阿拉伯語UI

00:34:19.126 --> 00:34:20.827 
這些變化非常大

00:34:21.360 --> 00:34:23.330 
我們已經完成了標準控制和視圖

00:34:23.630 --> 00:34:26.199 
並轉化了綜合控制流

00:34:26.833 --> 00:34:31.237 
在英語中你將按照從左到
右從一個菜單轉到詳細菜單

00:34:31.839 --> 00:34:34.741 
現在 在從右到左語言裏
你按照從右到左的順序進行

00:34:35.242 --> 00:34:37.143 
可以看到這些雪佛蘭已經轉移了

00:34:37.444 --> 00:34:39.246 
附屬視圖在另一邊

00:34:40.179 --> 00:34:42.014 
大部分文本被翻轉

00:34:43.016 --> 00:34:44.818 
需要記住一點 在UI中

00:34:44.885 --> 00:34:48.922 
並不是所有的東西都可以移動
可能不是你可以自行移動的

00:34:50.991 --> 00:34:53.126 
有時你想自定義行爲

00:34:53.927 --> 00:34:58.599 
可以看到“請勿打擾”的圖標

00:34:59.233 --> 00:35:02.536 
事實上還是從左到右
拉丁文文本也還是從左到右

00:35:03.070 --> 00:35:07.307 
更多關於這部分的信息
建議你查看昨天的演講

00:35:07.374 --> 00:35:09.443 
“國際界面的新UI工具支持”

00:35:10.277 --> 00:35:13.180 
說的是在iOS9中

00:35:13.447 --> 00:35:17.851 
如何使用標準控制對完全
從右到左支持加以利用並加以利用

00:35:18.452 --> 00:35:20.387 
此外 如何在你的個人app上

00:35:20.654 --> 00:35:21.822 
對其進行自定義

00:35:23.457 --> 00:35:28.262 
總而言之 在將你的
app國際化時需要注意

00:35:28.695 --> 00:35:32.065 
第一 定位信息

00:35:32.533 --> 00:35:34.168 
字符串是如何被轉化的

00:35:34.468 --> 00:35:38.272 
隱藏在譯文裏的概念
是如何轉化成用戶所需的

00:35:38.906 --> 00:35:44.912 
此外 格式化 單位 日期 數字
時間 名字是如何格式化成用戶所要的

00:35:46.180 --> 00:35:50.584 
文本處理 你如何從用戶
那獲取文本並在文本上執行操作的

00:35:51.118 --> 00:35:53.587 
又回到這個問題字符是什麼

00:35:53.921 --> 00:35:55.956 
這是你在處理文本過程中
需要時刻牢記的

00:35:56.590 --> 00:35:59.593 
最後 我們說到佈局

00:35:59.660 --> 00:36:01.395 
如何將UI要素展示給國際用戶

00:36:02.262 --> 00:36:07.534 
很幸運地是如果你用的是現有API
本地化變量 以及標準視圖和控制

00:36:07.801 --> 00:36:09.336 
你就可以免費獲得這些功能

00:36:10.137 --> 00:36:15.042 
如果你牢記這點你就會發現
國際化爲你的應用打開了世界的大門

00:36:16.577 --> 00:36:20.881 
更多信息請查看這些幻燈片
或查看這些文檔

00:36:22.249 --> 00:36:27.221 
聯繫開發者論壇
或App框架專員 保羅·馬科斯

00:36:27.888 --> 00:36:30.057 
也可查看相關會議

00:36:31.592 --> 00:36:35.028 
這些已經都有了
你也可在你的app或在線查閱

00:36:35.596 --> 00:36:38.298 
今天從早上11:00到下午1:10

00:36:38.565 --> 00:36:41.535 
我們將提供國際化實驗室請一定要參加

00:36:42.236 --> 00:36:44.204 
我和我的團隊都將在那裏爲大家解答

00:36:44.271 --> 00:36:46.473 
關於app國際化和本地化的相關問題

00:36:47.341 --> 00:36:48.609 
謝謝