00:00:19.786 --> 00:00:25.292 
深入分析

00:00:27.861 --> 00:00:28.695 
謝謝

00:00:31.565 --> 00:00:33.367 
謝謝 我是查德·伍爾夫

00:00:33.634 --> 00:00:34.735 
我是克里斯·馬克爾

00:00:35.035 --> 00:00:37.271 
我們是蘋果的性能工具工程師

00:00:37.704 --> 00:00:39.506 
這是會議412

00:00:39.573 --> 00:00:41.208 
我們會深入談一下“分析”

00:00:42.910 --> 00:00:46.380 
也就是談一下Instruments
中的時間分析器以及如何用它

00:00:46.446 --> 00:00:49.149 
來優化你的應用程序

00:00:50.317 --> 00:00:52.886 
當你想要找出你的應用程序
把大部分時間都花在哪裏了

00:00:52.953 --> 00:00:56.089 
的時候你就可以求助於時間分析器

00:00:56.290 --> 00:00:57.124 
舉個例子

00:00:58.425 --> 00:01:00.027 
當你試圖查明應用程序在

00:01:00.093 --> 00:01:02.629 
運行時間內做了什麼事時
時間分析器就會非常有用

00:01:02.696 --> 00:01:04.364 
你想看到具體調用情況

00:01:05.999 --> 00:01:08.202 
我們的會議會這樣分成若干部分

00:01:08.268 --> 00:01:11.138 
我們將會談談爲什麼我們
想要舉辦一場專門針對

00:01:11.205 --> 00:01:13.707 
時間分析器的會議的動機

00:01:15.042 --> 00:01:18.245 
不過會議會以向你們演示
展示它的工作原理的細節

00:01:18.345 --> 00:01:22.349 
你的應用程序在源代碼級別

00:01:22.416 --> 00:01:25.886 
以下的工作原理爲中心

00:01:27.487 --> 00:01:30.090 
最後我們會就你們如何
自行使用時間分析器

00:01:30.224 --> 00:01:31.225 
給你們一些小竅門

00:01:31.291 --> 00:01:34.161 
首先快速談談我們的動機這次會議是受

00:01:34.228 --> 00:01:36.129 
“Instruments 7”的
直接啓發

00:01:36.697 --> 00:01:38.899 
“Instruments 7”的
目的是展示新的外觀新的感覺

00:01:38.966 --> 00:01:41.368 
它意味着新的工藝圖
並且還意味着我們想讓這種

00:01:41.435 --> 00:01:46.573 
新感覺更具響應性想讓
這種新感覺更流暢

00:01:46.740 --> 00:01:50.143 
我們會從在各個方面對
我們的UI進行優化

00:01:51.445 --> 00:01:53.213 
我們還想嘗試新的圖形風格

00:01:53.280 --> 00:01:55.916 
我們過去就想嘗試新的圖形風格

00:01:55.983 --> 00:02:00.554 
但是我們現有的圖形代碼的性能不足

00:02:02.022 --> 00:02:04.258 
我們知道我們不得不
把注意力放在渲染上面

00:02:04.758 --> 00:02:07.961 
因爲它是應用中的一塊硬骨頭

00:02:08.027 --> 00:02:10.964 
Instruments必須處理
成百上千

00:02:11.031 --> 00:02:14.268 
有時候甚至是數以百萬的數據點
 Instruments必須把這些

00:02:14.868 --> 00:02:18.505 
處理成一個非常容易理解的表達

00:02:18.805 --> 00:02:21.175 
那裏的算法複雜性
毫無疑問就很高了

00:02:22.676 --> 00:02:25.779 
對於我們來說 這就意味着
我們必須對我們的應用程序中

00:02:25.846 --> 00:02:29.750 
特別重要的一部分進行重寫也就是對
位於app頂部的軌跡視圖進行重寫

00:02:31.118 --> 00:02:35.322 
整個冬季 克里斯和我拿出了
新的軌跡視圖的設計

00:02:35.956 --> 00:02:38.458 
開始根據一系列的原型進行構建

00:02:38.959 --> 00:02:41.361 
我們並沒有在Instruments中
直接生成原型

00:02:41.428 --> 00:02:43.830 
而是爲了簡單起見 把它拆分
到了一個單獨的應用程序中

00:02:44.665 --> 00:02:47.935 
這就是我們最近的一個原型的樣子

00:02:49.403 --> 00:02:51.839 
當我們生成原型時
我們做了一件事 我們設置了

00:02:51.905 --> 00:02:53.207 
一項“性能預算”

00:02:53.874 --> 00:02:55.309 
當我們分層堆放功能特性的

00:02:55.375 --> 00:02:58.378 
時候 我們會依據這項
“預算” 不斷地對

00:02:58.445 --> 00:03:00.948 
我們的代碼的性能進行評估

00:03:01.815 --> 00:03:04.818 
當我們超出了“預算”時
我們就會藉助於時間分析器

00:03:04.885 --> 00:03:08.255 
看看到底是我們的
應用程序的哪一部分出了問題

00:03:09.523 --> 00:03:12.993 
有時候很容易就可以修復
而有時候則不然

00:03:13.727 --> 00:03:14.928 
因爲我們生成的是原型

00:03:15.195 --> 00:03:17.197 
所以即使我們需要進行一些
大的結構改變才能把

00:03:17.264 --> 00:03:20.100 
性能拉回正道這也是相當容易的

00:03:21.602 --> 00:03:24.338 
當我們把它集成回
Instruments時

00:03:24.638 --> 00:03:26.106 
我們會再次藉助於時間分析器

00:03:26.206 --> 00:03:28.876 
找出我們的集成點中的“熱點”

00:03:29.009 --> 00:03:32.546 
這樣經過幾次迭代後我們最終
得到了Instruments 7

00:03:32.613 --> 00:03:34.281 
這個版本實現了我們的性能目標

00:03:35.315 --> 00:03:38.051 
時間分析器幫助我們
“熬過”了這個冬天

00:03:38.118 --> 00:03:40.921 
爲此我們興奮不已
因此當蘋果全球開發者大會

00:03:40.988 --> 00:03:45.325 
來臨時 我們想開一次會議
談談時間分析器

00:03:45.659 --> 00:03:47.528 
談談它善於解決哪些問題

00:03:48.629 --> 00:03:52.900 
我們想要和你們分享
我們寫軌跡視圖時的經驗

00:03:54.001 --> 00:03:58.505 
我們今年所做的就是在iOS上
創建了一個演示應用程序

00:03:59.173 --> 00:04:02.643 
它和軌跡視圖的第一個原型看起來很像

00:04:03.544 --> 00:04:06.613 
我們也給自己設定了性能目標

00:04:06.680 --> 00:04:10.317 
我們想要繪製十萬個數據點

00:04:11.084 --> 00:04:15.222 
我們想要平移和縮放的幀速
爲完美的每秒鐘六十幀

00:04:15.989 --> 00:04:18.825 
我們還想讓它支持
第一代iPad mini

00:04:19.493 --> 00:04:22.062 
我們選擇第一代iPad mini
的原因是...

00:04:22.696 --> 00:04:24.464 
你知道我說的是什麼...

00:04:24.531 --> 00:04:27.734 
如果它能支持第一代iPad
mini 那麼它在其它的平臺上

00:04:27.801 --> 00:04:30.737 
尤其是後面的平臺上
也就沒問題

00:04:30.804 --> 00:04:32.439 
克里斯會向你們展示這個應用程序

00:04:32.706 --> 00:04:36.777 
他會對它進行時間剖析
他會向你們展示把這些東西

00:04:36.844 --> 00:04:39.580 
組合到一起時我們發現了什麼東西

00:04:41.081 --> 00:04:45.285 
謝謝 查德 這裏我有
Xcode的原型應用程序

00:04:45.586 --> 00:04:48.055 
我想點出幾樣東西

00:04:48.121 --> 00:04:51.191 
當我們初步實現時
我們發現 我們根本就處理

00:04:51.258 --> 00:04:52.826 
不了不到十萬個的數據點

00:04:53.160 --> 00:04:55.963 
一開始 我們先從一萬個數據點開始

00:04:56.396 --> 00:04:59.733 
還有一點也很重要
你應該在你的發版構建上進行

00:04:59.800 --> 00:05:02.569 
時間剖析因爲你肯定想在你進行

00:05:02.636 --> 00:05:05.906 
剖析時 把編譯器的優化利用起來

00:05:06.540 --> 00:05:09.510 
我要開始剖析應用程序了

00:05:09.710 --> 00:05:12.813 
我要從產品菜單中選擇“剖析”

00:05:13.580 --> 00:05:16.483 
這樣就會構建應用程序
把它安裝到iPad上

00:05:16.817 --> 00:05:18.952 
並且顯示出
Instrument模板用戶

00:05:19.586 --> 00:05:22.089 
這裏 時間分析器已經爲我們選擇好了

00:05:22.656 --> 00:05:24.057 
我要點擊“選擇”

00:05:24.491 --> 00:05:27.227 
這裏 你可以在我們的軌跡
視圖中看到Instruments

00:05:27.461 --> 00:05:29.296 
我們過一會兒再回來看這個

00:05:29.363 --> 00:05:31.265 
現在我要開始錄製了

00:05:31.732 --> 00:05:35.169 
點擊“錄製”按鈕
我們向你展示了app

00:05:35.235 --> 00:05:39.239 
我想要強調下 你們在這裏
看到的 這個並不是模擬器

00:05:39.306 --> 00:05:43.010 
這是QuickTime對app上已有的
東西進行的鏡像

00:05:43.810 --> 00:05:48.515 
這是我們的圖表我要開始滾動

00:05:49.183 --> 00:05:52.686 
滾動沒有什麼不好
我要通過收聚進行縮小

00:05:53.220 --> 00:05:56.390 
剛開始還不錯不過之後就開始卡了

00:05:56.924 --> 00:05:58.025 
這可不太妙

00:05:58.792 --> 00:06:02.196 
最後我要用我的手指進行

00:06:02.262 --> 00:06:04.064 
前後滾動我正在移動我的手指

00:06:04.131 --> 00:06:07.668 
但是顯示器並沒有更新太卡了

00:06:08.202 --> 00:06:10.504 
性能表現太糟糕了

00:06:11.238 --> 00:06:12.873 
我們來看看發生了什麼

00:06:13.140 --> 00:06:15.642 
讓我們回到Xcode中
回到Instruments中

00:06:15.809 --> 00:06:16.777 
我們把分析器停下來

00:06:16.910 --> 00:06:19.313 
快速讓你們看看新的軌跡視圖

00:06:19.713 --> 00:06:21.682 
這裏我們看到了CPU使用情況

00:06:22.082 --> 00:06:24.384 
它指的是在某個特定的時間單位內

00:06:24.585 --> 00:06:26.320 
平均的CPU使用情況

00:06:26.620 --> 00:06:28.722 
這裏的時間單位取決於
你當前的縮放程度

00:06:29.122 --> 00:06:31.458 
當我使用我的app時
你可以看到不同的部分

00:06:31.925 --> 00:06:33.360 
那裏消耗的時間是不同的

00:06:33.427 --> 00:06:37.798 
這是滾動 這是縮小這是
縮小時進行前後滾動

00:06:38.265 --> 00:06:41.401 
關於軌跡視圖 還有一點
很棒 就是我可以使用這個

00:06:41.468 --> 00:06:47.207 
縮小手勢來放大我感興趣的某段數據

00:06:47.774 --> 00:06:50.878 
如果你用的不是Trackpad
那麼你可以按住選項鍵

00:06:50.978 --> 00:06:54.481 
上下滾動來進行放大和縮小

00:06:55.115 --> 00:06:57.718 
我想看看這段特定的數據

00:06:57.885 --> 00:06:59.720 
就是這裏的這個活動

00:07:00.020 --> 00:07:01.388 
剛纔我在這裏進行了滾動

00:07:01.455 --> 00:07:05.592 
爲此我要使用一個過濾器
只需單擊並拖動

00:07:06.260 --> 00:07:11.265 
就可以把那些特定的樣例給選中
這樣我就可以專注於

00:07:11.331 --> 00:07:12.566 
那個特定的數據

00:07:13.567 --> 00:07:16.370 
我要在下面這裏創建更多的空白

00:07:17.070 --> 00:07:19.339 
下面這裏是我們的詳細視圖

00:07:19.940 --> 00:07:22.676 
它可以向我們顯示
我們在某個特定的函數

00:07:22.743 --> 00:07:27.481 
或者方法內擁有的時間分析器的
樣本百分比的數量

00:07:27.748 --> 00:07:28.815 
這樣我們就有了符號名

00:07:28.882 --> 00:07:31.852 
這是我們的百分比這是我們的符號

00:07:32.386 --> 00:07:37.124 
當你進行時間剖析時你通常所做的
第一件事是把這個擴展開來

00:07:37.591 --> 00:07:42.563 
然後查看某種...
在這裏對數字進行對比

00:07:42.629 --> 00:07:45.098 
這裏是具體的方法函數

00:07:45.432 --> 00:07:48.035 
看看突出來的是什麼類型的情況 

00:07:48.402 --> 00:07:50.504 
你知道的那些值得你進行
調查的情況會顯示出來

00:07:50.871 --> 00:07:53.740 
還有一個選項 如果我們
認真看看檢查器窗格

00:07:54.174 --> 00:07:58.612 
點擊擴展開的細節 我們就能
看到最厚重的堆棧蹤跡

00:07:59.146 --> 00:08:00.247 
這是針對主線程的

00:08:00.681 --> 00:08:03.984 
當我進行時間剖析希望提高性能時

00:08:04.051 --> 00:08:08.255 
我就會關注這裏因爲
這裏是最物有所值的

00:08:08.822 --> 00:08:10.290 
我們來看看發生了什麼

00:08:10.457 --> 00:08:14.428 
主線程調用了應用程序的
主線程 進行循環

00:08:14.828 --> 00:08:18.298 
核心動畫開始工作了

00:08:21.268 --> 00:08:27.574 
沒有什麼異常情況發生

00:08:28.075 --> 00:08:31.245 
實際上這就是剖析時常見的事

00:08:31.345 --> 00:08:33.780 
你想看看應用程序最常乾的事情是什麼

00:08:34.214 --> 00:08:36.850 
但是看起來它並沒有做什麼特別的事情

00:08:36.917 --> 00:08:38.485 
那裏什麼也沒有

00:08:38.552 --> 00:08:41.655 
沒有要求在這裏計算第四十個斐
波納契數也沒有做什麼其它異常的事

00:08:42.456 --> 00:08:45.425 
但是 你知道的看看這個調用棧

00:08:45.492 --> 00:08:48.829 
看看這個堆棧蹤跡
我知道了我的應用程序做了什麼事

00:08:48.896 --> 00:08:52.032 
這是一個簡單的原型
app它的作用就是

00:08:52.099 --> 00:08:54.434 
構建一個路徑並且繪製一個路徑

00:08:55.369 --> 00:08:58.972 
實際上 我能夠看到這裏有一個
調用一個CG環境路徑

00:08:59.239 --> 00:09:02.409 
它沒有被我的代碼根據堆棧蹤跡調用到

00:09:02.743 --> 00:09:05.078 
就在這裏佔據了很大一塊時間

00:09:05.145 --> 00:09:07.047 
我要點擊下那個看看它

00:09:07.881 --> 00:09:09.850 
如果我們看看我們的調用樹

00:09:10.417 --> 00:09:12.219 
我就可以看到一些有趣的事

00:09:12.286 --> 00:09:14.855 
我們可以看到根據這個調用樹

00:09:14.922 --> 00:09:16.690 
這個繪製路徑會被這個

00:09:16.757 --> 00:09:19.092 
繪製分層法在UI試圖上調用

00:09:19.626 --> 00:09:24.264 
它還會爲圖形視圖調用我們的
drawRect

00:09:24.765 --> 00:09:26.767 
這佔據了大量的時間

00:09:26.834 --> 00:09:29.536 
這就是app所做的其中一件事

00:09:29.937 --> 00:09:34.374 
如果我看看這裏的那個時間
環境繪製路徑佔據了

00:09:34.541 --> 00:09:38.812 
你知道 樣本的55%但是這個
drawRect佔據的卻非常少

00:09:39.379 --> 00:09:42.549 
這就很有趣了
如果我在drawRect方法上

00:09:42.616 --> 00:09:45.052 
右擊下我就可以看到源代碼

00:09:45.686 --> 00:09:47.821 
我知道了如果你看看底部那裏

00:09:47.955 --> 00:09:51.592 
我就可以從drawRect方法上
調用繪製路徑

00:09:52.059 --> 00:09:55.128 
但是在哪個樣例中都顯示不出來

00:09:55.429 --> 00:09:58.432 
只是在添加路徑

00:09:58.699 --> 00:10:01.635 
這可不太尋常

00:10:01.702 --> 00:10:04.738 
因爲我的預期是我的
drawRect方法

00:10:04.805 --> 00:10:05.906 
運行需要一段時間

00:10:06.540 --> 00:10:08.275 
它只是我的app完成的一半

00:10:08.709 --> 00:10:10.644 
看這個我注意到

00:10:11.078 --> 00:10:12.579 
drawRect返回了一個空白

00:10:12.846 --> 00:10:16.350 
最後調用的方法是環境繪製路徑

00:10:16.950 --> 00:10:20.521 
這可能就是所謂的“尾部調用消除”

00:10:21.388 --> 00:10:25.259 
查德會給大家講講什麼是
“尾部調用消除”

00:10:25.325 --> 00:10:27.227 
以及如何對它進行驗證

00:10:30.464 --> 00:10:34.168 
好的 要解釋剛纔克里斯看到的情況

00:10:34.234 --> 00:10:39.173 
我們就需要理解時間分析器是怎樣
知道在你的應用程序內調用什麼的

00:10:40.040 --> 00:10:42.743 
這個的技術含量就比較高了
我會一步一步向你們講解

00:10:44.411 --> 00:10:48.148 
左邊是drawRect的代碼
右邊則和你想象的堆棧

00:10:48.215 --> 00:10:54.588 
在UIKit調用drawRect
之前爲那個線程找到的一樣

00:10:56.290 --> 00:10:57.858 
當向drawRect進行調用時

00:10:58.025 --> 00:11:01.261 
和大多數函數 方法所做的事情一樣

00:11:01.328 --> 00:11:02.863 
它會建立自己的調用幀

00:11:03.864 --> 00:11:07.768 
它會首先推送鏈路寄存器以及堆棧上的

00:11:07.868 --> 00:11:11.705 
幀指針的上一個值的返回地址

00:11:12.039 --> 00:11:16.376 
現在drawRect知道了怎樣返回
它的調用程序怎樣恢復幀指針

00:11:18.078 --> 00:11:21.515 
下一件發生的事是我們
得到幀指針設置成新的基礎

00:11:23.317 --> 00:11:26.320 
然後drawRect會給它的
局部變量

00:11:26.386 --> 00:11:28.455 
編譯程序的暫存空間騰出空間

00:11:28.522 --> 00:11:30.357 
現在我們有了一個
drawRect的幀

00:11:31.325 --> 00:11:34.494 
現在代碼開始運行了
我們到繪製路徑那裏

00:11:35.796 --> 00:11:39.166 
繪製路徑做的事也相同
它把自己的幀推送到了堆棧上

00:11:40.400 --> 00:11:43.437 
時間分析器的工作方式
就是在內核中使用一項服務

00:11:43.737 --> 00:11:47.207 
以每秒1000x的速度對
CPU所做的事進行採樣

00:11:48.408 --> 00:11:50.511 
在這個例子中如果我們採一次樣

00:11:50.911 --> 00:11:53.280 
我們就可以看到 我們是在
環境繪製路徑中運行的

00:11:54.381 --> 00:11:58.252 
然後內核會看下幀指針寄存器

00:11:58.318 --> 00:12:01.488 
看看函數幀的基礎在哪裏

00:12:01.822 --> 00:12:03.657 
然後找到調用它的程序的返回地址

00:12:04.291 --> 00:12:08.362 
現在我們可以看到那個
drawRect是在繪製路徑中調用

00:12:09.263 --> 00:12:11.098 
如果我們想看看drawRect中

00:12:11.632 --> 00:12:14.268 
調用了什麼我們就可以使用我們推送到

00:12:15.035 --> 00:12:17.004 
堆棧上的幀指針來找到
drawRect的基礎

00:12:17.237 --> 00:12:20.507 
然後繼續返回堆棧直到我們到達底部

00:12:21.108 --> 00:12:22.242 
這就是一次回溯

00:12:22.876 --> 00:12:25.212 
如果我們有足夠的回溯
並且把它們放到

00:12:25.279 --> 00:12:29.183 
調用樹視圖你就可以搞清楚在你的
應用程序內發生了什麼

00:12:30.083 --> 00:12:32.152 
我想指出一點堆棧上的幀指針

00:12:32.319 --> 00:12:34.021 
是絕對必須的

00:12:34.421 --> 00:12:37.424 
如果你編譯代碼時
關閉了fomit-frame-pointer

00:12:37.524 --> 00:12:41.428 
想要進行和我們這裏一樣的時間剖析

00:12:42.996 --> 00:12:44.531 
讓我們看看這個優化實例

00:12:44.598 --> 00:12:46.967 
啓用編輯器優化後drawRect

00:12:47.034 --> 00:12:48.402 
就是進行編譯的

00:12:49.303 --> 00:12:51.271 
同樣地我們有一個drawRect幀

00:12:51.738 --> 00:12:53.273 
我們要準備調用繪製路徑了

00:12:54.074 --> 00:12:57.578 
你可以注意到 當繪製路徑
返回drawRect時就完成了

00:12:57.744 --> 00:12:58.779 
什麼也不需要做

00:12:59.279 --> 00:13:00.214 
它就會返回回來

00:13:00.280 --> 00:13:03.050 
它返回時會彈出堆棧結構

00:13:03.483 --> 00:13:06.086 
恢復幀指針的上一個值

00:13:06.520 --> 00:13:07.788 
然後回到調用程序

00:13:09.022 --> 00:13:11.191 
編譯器看到這個後會想

00:13:11.458 --> 00:13:17.397 
爲什麼繪製路徑需要用到
drawRect的堆棧結構的東西？

00:13:18.398 --> 00:13:20.834 
明明不需要的
此外返回它的調用程序時

00:13:20.901 --> 00:13:23.270 
爲什麼要返回drawRect？

00:13:23.871 --> 00:13:27.374 
那麼它就會把代碼重新整理成這樣

00:13:27.674 --> 00:13:30.811 
它會彈出堆棧結構恢復幀指針

00:13:30.878 --> 00:13:34.248 
然後直接向繪製路徑進行回調

00:13:34.414 --> 00:13:36.149 
這就意味着我們無需再跳回調用程序了

00:13:36.984 --> 00:13:39.686 
解釋這個要比讓你們直接看到更困難

00:13:39.753 --> 00:13:42.422 
讓我們想象一下 當運行
這個代碼時它會是什麼樣的

00:13:43.524 --> 00:13:46.059 
我們會彈出堆棧結構去掉局部變量

00:13:47.060 --> 00:13:49.329 
我們會把幀指針恢復成初始值

00:13:49.463 --> 00:13:50.864 
鏈路寄存器的值

00:13:51.665 --> 00:13:54.668 
然後我們跳回繪製路徑代碼的開頭

00:13:55.536 --> 00:13:58.739 
繪製路徑會使用它在
鏈路寄存器中找到的值

00:13:59.306 --> 00:14:02.843 
幀指針中找到的值把它
自己的幀推送回堆棧

00:14:03.610 --> 00:14:07.080 
從繪製路徑的透視圖中它會直接在

00:14:07.147 --> 00:14:09.149 
UIKit的環境中
從繪製層上得到調用

00:14:09.950 --> 00:14:11.685 
此時如果我們進行一次時間採樣

00:14:12.119 --> 00:14:13.754 
我們就可以看到同樣的情況

00:14:15.022 --> 00:14:16.890 
即使發生的不是實際的調用序列

00:14:16.957 --> 00:14:19.092 
時間分析器看到的就是這樣

00:14:19.660 --> 00:14:22.963 
我們在我們的調用樹上
最後看到的就是這個

00:14:23.564 --> 00:14:25.966 
這就叫“尾部調用消除”
在高度優化的代碼上

00:14:26.033 --> 00:14:29.203 
很常見也有一些好處

00:14:30.804 --> 00:14:31.972 
它能夠節省堆棧內存

00:14:32.806 --> 00:14:35.242 
節省堆棧內存時
它會讓緩存保持“熱度”

00:14:35.309 --> 00:14:38.045 
然後重新利用內存緩存和數據

00:14:39.179 --> 00:14:42.749 
它對遞歸代碼有着深刻影響

00:14:42.816 --> 00:14:45.919 
尤其是尾部調用遞歸代碼
在那裏 一個函數或者方法

00:14:45.986 --> 00:14:48.355 
會最後調用自身然後返回回來

00:14:49.223 --> 00:14:52.893 
無需推送這些幀一個遞歸函數內的

00:14:53.093 --> 00:14:56.463 
尾部調用消除
就可以讓性能和迭代版本

00:14:56.530 --> 00:15:00.200 
一樣好所以堆棧就不會增長

00:15:00.267 --> 00:15:01.735 
並且性能也很優秀

00:15:02.536 --> 00:15:06.406 
這個優化也能兼容高度遞歸代碼

00:15:07.140 --> 00:15:09.109 
如果爲了剖析你想把它關掉

00:15:09.176 --> 00:15:11.111 
顯示一個更清晰的堆棧蹤跡

00:15:12.145 --> 00:15:15.315 
你就可以到項目的構建設置中把它關掉

00:15:15.782 --> 00:15:17.684 
並且把編輯器標誌

00:15:17.751 --> 00:15:20.787 
從CFLAGS設置成
FNO-optimize-sibling-calls

00:15:20.854 --> 00:15:22.122 
關掉優化

00:15:22.422 --> 00:15:24.625 
不幸的是性能同時也會受到影響

00:15:25.092 --> 00:15:27.394 
但是這樣你可以在時間分析器
中得到更好一個的結果

00:15:28.562 --> 00:15:31.131 
如果你選擇忍受它
你想要知道是否發生了

00:15:31.298 --> 00:15:34.768 
尾部調用消除那麼你該怎麼做？

00:15:34.835 --> 00:15:38.405 
你可以看看反彙編調用最後調用的情況

00:15:39.473 --> 00:15:41.942 
如果是個普通的調用
那麼它會使用指令的

00:15:42.009 --> 00:15:44.711 
一個分支和家族鏈接
那裏是第一個實例

00:15:45.746 --> 00:15:47.614 
那就意味着它會跳到新函數

00:15:47.681 --> 00:15:50.117 
並且在鏈路寄存器內保存返回的值

00:15:51.318 --> 00:15:54.021 
如果是一個尾部調用
並且我們需要直接跳到

00:15:54.087 --> 00:15:59.893 
直接跳到新函數內 那麼
它就是一個直接的分支指令沒有BL

00:16:00.561 --> 00:16:04.665 
那就是一個指令和鏈路的調用指令

00:16:04.731 --> 00:16:06.600 
分支就是一個轉移指令

00:16:06.733 --> 00:16:09.102 
如果你看看它你會發現很眼熟

00:16:10.137 --> 00:16:14.741 
現在就由克里斯來決定了
他可以禁用優化 重新編譯

00:16:14.808 --> 00:16:17.444 
或者他也可以繼續由你決定

00:16:18.412 --> 00:16:20.747 
我要看看反彙編

00:16:20.814 --> 00:16:24.885 
在Instruments詳細視圖的
右上角那裏

00:16:24.952 --> 00:16:28.055 
有一個按鈕
查看反彙編 如果我點擊下

00:16:28.622 --> 00:16:30.858 
我就可以看到那個方法的反彙編

00:16:31.091 --> 00:16:35.395 
我們就可以確認添加路徑
環境調用是一個分支和鏈路

00:16:35.929 --> 00:16:39.166 
環境調用繪製路徑是一個簡單的分支

00:16:39.600 --> 00:16:42.669 
我確信這是一個尾部調用消除的例子

00:16:43.036 --> 00:16:48.442 
我在調用樹上看到的55%的
調用都不屬於我的drawRect

00:16:48.509 --> 00:16:51.345 
它們本來應該屬於
我的drawRect

00:16:51.845 --> 00:16:53.447 
這是個好消息

00:16:53.514 --> 00:16:57.951 
現在我知道了drawRect就是
我的最重的堆棧結構

00:16:58.018 --> 00:16:59.052 
我的最重的堆棧蹤跡

00:16:59.453 --> 00:17:02.456 
消耗了我55%到60%的時間

00:17:02.723 --> 00:17:04.724 
很好 我知道應該優化哪裏了

00:17:04.892 --> 00:17:07.594 
我要優化drawRect開始吧

00:17:08.395 --> 00:17:09.930 
我們來看看這個drawRect

00:17:11.231 --> 00:17:14.867 
看看這個drawRect 如果
有張桌子的話我早就掀了

00:17:15.702 --> 00:17:17.971 
優化的地方不多

00:17:18.172 --> 00:17:20.440 
很難想出一個能用的更簡單的

00:17:20.674 --> 00:17:22.075 
但是又能用的drawRect

00:17:22.175 --> 00:17:28.015 
我們有四個函數調用 環境
你知道的 CG調用

00:17:28.515 --> 00:17:30.584 
這個drawRect
沒有起到多少作用

00:17:31.251 --> 00:17:33.720 
那麼這個實際上就是進行剖析時

00:17:33.787 --> 00:17:35.389 
一個很常見的事

00:17:36.657 --> 00:17:41.762 
你看了下自己的“熱點”和代碼

00:17:42.062 --> 00:17:45.799 
發現你沒有多少能直接在
代碼中進行修改

00:17:45.999 --> 00:17:47.334 
提高你的性能的地方

00:17:48.068 --> 00:17:50.404 
你知道 這個節點你該做什麼？

00:17:51.305 --> 00:17:55.776 
你知道 除了掀桌子
晚上在枕頭上嚎啕大哭之外

00:17:57.277 --> 00:18:01.715 
我們所做的事 就是仔細檢查
開始查看核心圖像文檔以及其它繪圖

00:18:01.782 --> 00:18:03.517 
你知道 Cocoa繪圖資料

00:18:04.184 --> 00:18:07.087 
我們無意中發現了這裏的
這個特殊的屬性

00:18:07.921 --> 00:18:09.823 
這是
drawsAsynchrously

00:18:10.123 --> 00:18:12.926 
你瞧！這是一個
“讓我的代碼更快”按鈕

00:18:13.060 --> 00:18:17.064 
是一位蘋果工程師創建的

00:18:19.066 --> 00:18:20.334 
非常棒

00:18:20.734 --> 00:18:23.103 
在那個上面 你可以看到

00:18:23.170 --> 00:18:25.272 
我從資料中複製出來粘貼都了那裏

00:18:25.606 --> 00:18:27.541 
它說了幾件有趣的事

00:18:27.608 --> 00:18:31.645 
首先它說 它可能提高性能
也可能不會提高性能

00:18:31.712 --> 00:18:32.846 
你應該衡量得失

00:18:33.614 --> 00:18:35.749 
你懂得 好了 爸爸

00:18:36.216 --> 00:18:37.117 
我們開始度量吧

00:18:37.317 --> 00:18:39.887 
我們看看這個能否提高性能

00:18:40.420 --> 00:18:43.156 
這次 要啓動Instruments
我要給Instruments進行

00:18:43.223 --> 00:18:45.325 
運行command-I

00:18:45.726 --> 00:18:46.760 
它會做同樣的事情

00:18:47.361 --> 00:18:50.531 
它會構建應用程序安裝到設備上

00:18:51.198 --> 00:18:52.299 
顯示出模板選擇器

00:18:53.267 --> 00:18:54.368 
需要一點時間

00:18:55.802 --> 00:18:56.637 
還需要一點時間

00:18:57.771 --> 00:18:58.705 
還得再需要一點時間

00:18:59.173 --> 00:19:04.311 
好了 我還想使用另外一種
快捷方式 如果你看看下面的選擇按鈕

00:19:04.945 --> 00:19:07.548 
如果我按住選擇按鈕
它就變成了“剖析”

00:19:07.981 --> 00:19:09.850 
這就意味着着
當我點擊這個按鈕時

00:19:10.150 --> 00:19:11.852 
應用程序就會開始錄製

00:19:12.186 --> 00:19:13.787 
會替我省一兩步

00:19:14.021 --> 00:19:15.055 
我現在點了

00:19:15.822 --> 00:19:18.625 
現在時間分析器出來了

00:19:19.092 --> 00:19:20.160 
會對app進行度量

00:19:20.627 --> 00:19:22.496 
我要快速進行一些前後滾動

00:19:22.563 --> 00:19:24.698 
捕捉一些數據

00:19:25.499 --> 00:19:26.333 
我想夠了

00:19:26.400 --> 00:19:28.302 
讓我們把錄製停下來

00:19:28.769 --> 00:19:33.040 
我要進行過濾獲得具體滾動數據

00:19:33.707 --> 00:19:35.843 
如果我們到下面這裏看看細節視圖

00:19:36.310 --> 00:19:37.711 
很有希望

00:19:37.945 --> 00:19:40.714 
實際上上你們可以看到這裏有多個線程

00:19:40.881 --> 00:19:42.216 
線程正在發揮作用

00:19:42.683 --> 00:19:43.750 
這很好

00:19:43.851 --> 00:19:45.652 
如果我們繼續如果我按住選項

00:19:45.986 --> 00:19:48.055 
點擊提示三角符號
我就可以看到這個線程在

00:19:48.622 --> 00:19:52.092 
調用什麼這是一些羣調用

00:19:52.159 --> 00:19:53.493 
一些CG調用 很好

00:19:53.560 --> 00:19:54.628 
這就是繪製代碼

00:19:55.195 --> 00:19:57.097 
我們繼續一個接一個檢查下

00:19:58.265 --> 00:19:59.266 
按住這個選項鍵

00:19:59.900 --> 00:20:02.202 
羣調用 CG調用

00:20:02.503 --> 00:20:04.738 
很好 這個看起來很有希望

00:20:05.239 --> 00:20:09.142 
我是多線程
理論上我的app應該更快了

00:20:10.043 --> 00:20:13.914 
但是 多線程並不一定意味着更快

00:20:13.981 --> 00:20:17.217 
我們應該確認它真的在幫我們做事

00:20:17.751 --> 00:20:21.755 
有一種方法可以確認 我碰巧
知道這臺設備有兩個CPU

00:20:22.122 --> 00:20:24.157 
如果CPU以最大性能

00:20:24.224 --> 00:20:28.662 
並行運行 那麼我應該會看到
在我圖表上面這裏

00:20:29.096 --> 00:20:30.497 
看到200%的CPU使用情況

00:20:31.131 --> 00:20:33.634 
但是我看不到有超過100%的情況

00:20:33.700 --> 00:20:36.270 
那麼這就是某種警告信號了
它並不一定意味着兩個

00:20:36.537 --> 00:20:38.639 
CPU沒有同時工作

00:20:39.039 --> 00:20:40.541 
它只是意味着我應該進一步檢查下

00:20:41.074 --> 00:20:42.276 
那麼我們怎樣進一步檢查？

00:20:42.609 --> 00:20:44.678 
Instruments就有我們稱
之爲“策略”的東西 

00:20:44.745 --> 00:20:47.314 
它指的是對數據進行劃分的
不同方法爲的是查看數據

00:20:47.481 --> 00:20:48.415 
這裏有三個

00:20:48.849 --> 00:20:51.451 
第一個是Instrument策略
即默認值

00:20:51.652 --> 00:20:52.553 
我們在這裏看的就是

00:20:53.387 --> 00:20:55.289 
第二個是CPU策略

00:20:55.656 --> 00:20:58.926 
它顯示的是每個CPU或者CPU
的數據 相關數據

00:20:59.826 --> 00:21:01.662 
最後一個是線程策略

00:21:01.962 --> 00:21:04.531 
它給你顯示了每個線程
處理的細節情況

00:21:05.399 --> 00:21:07.467 
我們來看看CPU策略

00:21:08.569 --> 00:21:10.971 
我們可以看到我們擁有的每個CPU

00:21:11.038 --> 00:21:12.606 
我們可以看到它們做了多少功

00:21:12.673 --> 00:21:14.808 
在底部我們可以看到組合使用情況

00:21:15.242 --> 00:21:21.982 
這裏有一件很棒的事可以做
當我放大的足夠大

00:21:22.049 --> 00:21:24.251 
圖表向我顯示的細節就會發生變更

00:21:25.018 --> 00:21:27.387 
它就會顯示那個CPU是
否處於活躍狀態 

00:21:27.721 --> 00:21:29.957 
而不再顯示平均使用情況

00:21:30.023 --> 00:21:32.793 
它就會顯示活躍或者不活躍
而不再顯示平均使用情況

00:21:33.393 --> 00:21:37.130 
現在每個CPU都顯示了一個
在線狀態或者離線狀態是否處於工作中

00:21:37.831 --> 00:21:41.535 
這裏你可以注意到
CPU從來沒有一起工作中

00:21:41.602 --> 00:21:44.438 
這裏沒有並行性

00:21:44.771 --> 00:21:48.642 
你懂得 這可不好

00:21:49.276 --> 00:21:53.146 
如果我們還想試試傷口撒鹽
我們可以看看線程策略

00:21:54.181 --> 00:21:56.416 
它可以向我們顯示每個圖標

00:21:56.817 --> 00:22:00.120 
每個圖標代表了時間分析器
採集的一個樣本

00:22:00.187 --> 00:22:02.222 
你可以點擊 看看調用堆棧

00:22:02.623 --> 00:22:05.359 
這裏的這個是位於一個後臺線程上

00:22:05.726 --> 00:22:08.161 
你可以看到核心圖形調用這是主線程

00:22:08.228 --> 00:22:14.668 
你可以看到主線程...
我們在主線程上進行的工作

00:22:15.202 --> 00:22:17.204 
你可以看到 如果我放大到合適的程度

00:22:17.804 --> 00:22:18.972 
應該就是這裏了我滾動下

00:22:19.339 --> 00:22:24.611 
你可以看到兩個線程並沒有
真的同時工作過

00:22:24.811 --> 00:22:27.314 
它是從一個線程跳到另一個線程

00:22:28.682 --> 00:22:34.354 
因此drawsAsynchronously
並沒有真的爲我們做什麼事

00:22:34.421 --> 00:22:36.890 
從理論上來說它可能會拖慢我們

00:22:37.391 --> 00:22:42.429 
我們不僅進行了繪製而且還進行了管理

00:22:42.663 --> 00:22:45.065 
你懂得 核心圖形系統
對它工作的線程進行了管理

00:22:45.132 --> 00:22:48.769 
類似這種的事情 並沒有什麼實質作用

00:22:49.903 --> 00:22:51.738 
我會把它關掉

00:22:53.006 --> 00:22:56.176 
我會再掀一張桌子

00:22:56.543 --> 00:22:59.780 
不很清晰神奇按鈕沒多大作用

00:23:00.547 --> 00:23:01.682 
我們現在該怎麼做？

00:23:02.382 --> 00:23:05.485 
同樣這也是時間剖析中
一個很常見的情況

00:23:06.320 --> 00:23:08.755 
你嘗試了很多事但是大部分都不起作用

00:23:09.489 --> 00:23:11.625 
我們往回退一步

00:23:11.892 --> 00:23:12.726 
app會怎麼做？

00:23:13.060 --> 00:23:15.128 
它構建了一條路徑
然後描繪了一條路徑

00:23:15.963 --> 00:23:17.364 
我們已經看過繪製路徑代碼了

00:23:17.431 --> 00:23:19.633 
我們來考慮下構建路徑代碼

00:23:19.933 --> 00:23:23.470 
就在這裏

00:23:25.105 --> 00:23:29.109 
我們想做的事就是調查下
我們構建的實際路徑

00:23:29.643 --> 00:23:32.613 
這個代碼的作用就是循環數據元素

00:23:32.880 --> 00:23:35.949 
創建一條路徑然後爲每個
數據元素向那個路徑中一行

00:23:36.250 --> 00:23:39.319 
我們想知道我們向那個路徑中
添加了多少行

00:23:39.386 --> 00:23:42.122 
時間分析器就可以告訴我們這個信息

00:23:42.422 --> 00:23:44.291 
它不能告訴你某個特定的方法

00:23:44.558 --> 00:23:47.528 
函數被調用了多久被調用了多少次

00:23:48.228 --> 00:23:49.897 
它不知道一個被調用了僅僅

00:23:49.963 --> 00:23:52.266 
幾次的慢函數同一個被調用了
很多次的快函數之間

00:23:52.332 --> 00:23:53.934 
有什麼區別

00:23:54.535 --> 00:23:56.970 
在這個例子中 我們要藉助於
NSLog 我們就可以實現

00:23:57.404 --> 00:24:01.341 
一個情況 即我們每次添加
一個路徑 我們就放大計數器一次

00:24:01.642 --> 00:24:05.312 
然後當我們循環結束時
我們就把它錄入

00:24:05.679 --> 00:24:07.881 
重點要指出的是NSLog並不是一個

00:24:08.415 --> 00:24:10.617 
很快的函數

00:24:11.151 --> 00:24:13.387 
在高性能代碼中你不會想讓它出現的

00:24:13.520 --> 00:24:16.056 
除了收集診斷信息或者進行調試以外

00:24:16.123 --> 00:24:18.825 
你可能不會想用它做任何其它事情

00:24:19.393 --> 00:24:21.762 
當你用完後把它從代碼中刪掉

00:24:21.995 --> 00:24:23.897 
在這個例子中 我們僅僅添加
註釋 這樣你可以看到

00:24:24.665 --> 00:24:29.636 
我們發現 我們在例子中的
這個點這裏添加了十萬行

00:24:30.204 --> 00:24:32.506 
這是沒有必要的

00:24:32.573 --> 00:24:36.076 
事實上 這臺設備上無論如何
也顯示不了十萬行

00:24:37.110 --> 00:24:39.079 
尤其是當你縮的足夠小所有的數據

00:24:39.146 --> 00:24:41.682 
就都需要適合一百個屏幕點

00:24:42.015 --> 00:24:44.251 
沒理由在那裏繪製十萬行

00:24:44.318 --> 00:24:47.754 
我們繪製一百行就可以了

00:24:47.955 --> 00:24:48.956 
這樣工作就少了很多

00:24:49.923 --> 00:24:54.127 
我們繼續 創建一個執行來實現它

00:24:54.728 --> 00:24:58.065 
如果是多個數據元素
數據點位於一個單一的

00:24:58.165 --> 00:25:01.368 
屏幕點那麼它就會找出最大值

00:25:01.435 --> 00:25:02.669 
繪製一條單一的行

00:25:03.136 --> 00:25:07.341 
如果我們使用一百個屏幕點
我們就會創建一百個屏幕行

00:25:08.408 --> 00:25:11.378 
我們來切換到那個執行

00:25:12.312 --> 00:25:14.481 
我們對它的感覺很好

00:25:14.581 --> 00:25:18.352 
我們把元素數量的上限改成了十萬

00:25:18.418 --> 00:25:20.621 
而不是一萬

00:25:21.488 --> 00:25:23.790 
我們看看這對我們是否有幫助

00:25:25.559 --> 00:25:29.630 
我要使用command-I來啓動
Instruments

00:25:30.030 --> 00:25:31.899 
因爲Instruments已經打開了
它就會把它弄到

00:25:31.965 --> 00:25:35.369 
前臺立即開始錄製

00:25:37.004 --> 00:25:38.872 
好了 一個新的錄製

00:25:39.540 --> 00:25:43.243 
我們來滾動下滾動看起來沒問題

00:25:44.478 --> 00:25:45.846 
我再縮小下

00:25:46.747 --> 00:25:49.216 
縮放性能也有了非常大的提高

00:25:49.383 --> 00:25:52.085 
需要的時間更多
因爲我要縮小的數據更多了

00:25:52.853 --> 00:25:54.054 
看起來真的很好

00:25:54.888 --> 00:25:56.623 
我要進行前後滑動

00:25:56.690 --> 00:25:59.226 
現在它能很好地追蹤我的手指了

00:25:59.726 --> 00:26:02.696 
它能跟得上我的手指真棒

00:26:04.031 --> 00:26:05.799 
萬歲！都搞定了！

00:26:07.601 --> 00:26:09.536 
還差一點

00:26:11.038 --> 00:26:12.506 
當我們前後滾動時

00:26:12.573 --> 00:26:15.108 
如果我們看一下我們使用的
CPU的實際數量

00:26:15.709 --> 00:26:18.345 
我們就可以看到 你懂得
有時候會降到60%

00:26:18.412 --> 00:26:20.180 
通常是七十到八十秒

00:26:21.048 --> 00:26:23.951 
從技術上說
我們實現了我們的性能目標

00:26:24.551 --> 00:26:27.454 
我們要做的
我們接下來要對這個app

00:26:27.721 --> 00:26:28.655 
原型做什麼？

00:26:28.722 --> 00:26:30.591 
我們添加了一些附加特性

00:26:31.191 --> 00:26:36.263 
我們知道我們需要比這裏更多的淨空

00:26:36.997 --> 00:26:42.169 
我們怎樣能讓它更快？
我們怎樣能讓這個app更好？

00:26:42.236 --> 00:26:44.338 
我們怎樣實現性能目標？

00:26:45.405 --> 00:26:46.940 
我們專注下這個

00:26:47.441 --> 00:26:48.675 
我們來過濾下那個數據

00:26:50.143 --> 00:26:52.579 
我要給我自己一點空間

00:26:53.180 --> 00:26:55.282 
在這個例子中我要按住選項鍵

00:26:56.250 --> 00:26:57.985 
點擊“主要”把它展開

00:26:58.085 --> 00:27:02.222 
我就可以到這裏看到這裏的這個方法

00:27:02.890 --> 00:27:06.460 
你懂得 現在繪製路徑就足夠快了

00:27:06.527 --> 00:27:11.198 
反而是構建路徑成了瓶頸

00:27:12.266 --> 00:27:14.701 
我想關注下這個方法

00:27:15.035 --> 00:27:16.436 
我要點擊下“聚焦”按鈕

00:27:16.803 --> 00:27:21.708 
它會把方法中的所有事情移動到一邊

00:27:21.775 --> 00:27:26.480 
把這個方法中

00:27:27.080 --> 00:27:29.082 
我們的百分比標準化

00:27:29.149 --> 00:27:33.587 
這個方法把55%的時間用在了
獲取下個元素上

00:27:34.221 --> 00:27:38.892 
把10到11%的時間用在了
objc msgSend上

00:27:39.560 --> 00:27:42.930 
關於objc msgSend
我知道的是

00:27:42.996 --> 00:27:45.299 
它是一個超快的方法

00:27:45.365 --> 00:27:46.733 
它是經過極致優化的

00:27:47.134 --> 00:27:51.438 
但是如果我能把那個10%
拿回來 我還是想要

00:27:52.539 --> 00:27:58.445 
如果我們看看我們代碼裏面
我們就可以看到它已經 

00:27:58.512 --> 00:27:59.646 
很乾淨了

00:27:59.713 --> 00:28:03.383 
我們大部分的時間都花在了
獲取下個元素上

00:28:04.084 --> 00:28:06.787 
這裏的這個百分比 要比
樹狀視圖中的略微高一點

00:28:07.120 --> 00:28:09.690 
因爲它包括了
objc msgSend的時間

00:28:10.090 --> 00:28:14.795 
如果我把它去掉
這個迭代程序就更快了

00:28:15.128 --> 00:28:19.366 
希望我就可以實現我想要的性能提升

00:28:19.600 --> 00:28:23.103 
請查德給我們講講如何實現這一點

00:28:26.106 --> 00:28:29.042 
我們來談談objc msgSend

00:28:30.410 --> 00:28:35.148 
無論你何時使用方括號符號

00:28:35.349 --> 00:28:37.951 
無論你何時使用點符號
來訪問一個對象的屬性

00:28:38.552 --> 00:28:41.822 
編輯器就會把它隱式插入

00:28:43.156 --> 00:28:46.026 
它的目的是查找選擇器的實現方法

00:28:46.093 --> 00:28:48.662 
然後調用那個方法

00:28:49.029 --> 00:28:51.598 
我們如何在Objective-C中
進行動態分派

00:28:51.665 --> 00:28:52.799 
要講的東西還很多

00:28:54.101 --> 00:28:59.139 
Objc msgSend非常快
也不會推送堆棧結構

00:28:59.773 --> 00:29:02.376 
當你看你的時間剖析時

00:29:02.576 --> 00:29:04.311 
通常來說你不會看到它的效果

00:29:05.412 --> 00:29:08.549 
你能看到它的時機
就是在一個完美的例子中

00:29:08.615 --> 00:29:11.451 
就像我們在我們的
迭代程序中看到的那樣

00:29:11.518 --> 00:29:15.088 
我們要做的就是迭代超過十萬個點

00:29:15.155 --> 00:29:19.359 
用一個小的方法主體
稱之爲“獲得下一個方法”

00:29:19.426 --> 00:29:21.428 
只需增加一對值返回一個結構即可

00:29:22.529 --> 00:29:26.200 
那麼接下來要發生的
就是Objective-C消息發送

00:29:26.266 --> 00:29:30.070 
開銷時間會積累到一個可測量的程度

00:29:31.405 --> 00:29:34.074 
是否有方法可以避開開銷呢？

00:29:35.442 --> 00:29:37.544 
不一定

00:29:38.212 --> 00:29:41.181 
Objective-C從設計上
就是一種動態語言

00:29:41.481 --> 00:29:43.851 
要訪問對象和類的方法你就必須

00:29:44.117 --> 00:29:47.454 
進行objc msgSend調用

00:29:48.255 --> 00:29:52.025 
每次它都會這樣做
因爲你可以在運行時間

00:29:52.092 --> 00:29:53.694 
轉換方法執行

00:29:54.161 --> 00:29:57.631 
Objective-C內沒有
編譯時間

00:29:57.698 --> 00:29:59.600 
比如說我想調用這個特殊的方法主體

00:30:00.534 --> 00:30:04.505 
這裏唯一的異常是 如果
你進行所謂的“方法緩存”

00:30:04.905 --> 00:30:07.307 
你可以自己查找方法執行

00:30:07.774 --> 00:30:09.543 
然後通過函數指針調用它

00:30:10.244 --> 00:30:12.846 
一般來說我不推薦你們這麼做

00:30:13.347 --> 00:30:15.282 
你可以想象的到它很脆弱

00:30:15.782 --> 00:30:20.687 
一般來說 根據我的經驗它沒有給過
我期望的性能你得想想我們起初

00:30:21.255 --> 00:30:23.757 
到這裏的目的是什麼

00:30:24.124 --> 00:30:28.028 
我們到這裏的原因獲得下個
元素方法有一個小的方法主體

00:30:28.729 --> 00:30:31.565 
即使你通過函數指針調用它
你也必須對自變量

00:30:31.632 --> 00:30:34.234 
進行整理把幀推送到堆棧上

00:30:34.301 --> 00:30:35.936 
並且在你完成後把它們彈出來

00:30:36.803 --> 00:30:38.839 
你們在上一組幻燈片中看到的正是這個

00:30:38.906 --> 00:30:42.142 
開銷可能會很大增加後會再返回

00:30:43.177 --> 00:30:47.781 
我想要指出的是方法緩存並不像

00:30:47.848 --> 00:30:49.449 
直接插入那樣快在這個例子中

00:30:49.516 --> 00:30:53.120 
我們真正想實現的是
直接插入那個小的方法主體

00:30:54.488 --> 00:30:56.390 
我們在Objective-C中
該怎樣實現？

00:30:56.790 --> 00:30:59.059 
你還有其它選項

00:30:59.159 --> 00:31:01.461 
首先 你本來應該用 C

00:31:02.396 --> 00:31:04.398 
你本來應該用結構而不是一個

00:31:04.464 --> 00:31:08.001 
迭代程序舉例來說 你可以向這個
方法中傳遞一個C線

00:31:08.702 --> 00:31:13.640 
如果你想要那個OO特點
你可以使用C++

00:31:14.274 --> 00:31:16.210 
你在Objective-C中使用
C++的方法

00:31:16.276 --> 00:31:18.679 
是把文件從a .m
重命名爲a .mm

00:31:18.879 --> 00:31:20.714 
然後你就可以使用C++語法

00:31:21.448 --> 00:31:23.183 
因爲通常Arc是默認打開的

00:31:23.350 --> 00:31:27.487 
然後你取出Objective-C
對象把它們放進

00:31:27.955 --> 00:31:32.025 
STL容器內把它們放到
你的類和結構的實體變量中

00:31:33.126 --> 00:31:37.231 
這很方便
你也可以得到C++的性能好處

00:31:37.297 --> 00:31:39.766 
我在Instruments中大量用它
以便在軌跡視圖

00:31:39.833 --> 00:31:45.272 
以及Instruments
其它關鍵的地方儘可能地快

00:31:46.039 --> 00:31:50.110 
根據我的親身經驗
這個有一個主要的下降趨勢

00:31:50.677 --> 00:31:53.313 
你需要提前知道
你的代碼的哪一部分會

00:31:53.614 --> 00:31:56.783 
從C++中受益
哪一部分代碼會從

00:31:57.317 --> 00:31:59.820 
Objective-C中受益

00:32:00.487 --> 00:32:02.956 
有時候像我們在演示示例中那樣

00:32:03.156 --> 00:32:05.826 
你可能在那裏犯錯誤
並且直到進行剖析才意識到

00:32:06.193 --> 00:32:07.594 
我們是用Objective-C
寫了我們的

00:32:07.661 --> 00:32:11.832 
Objective-C沒有意識到
它在我們的時間剖析中有多慢

00:32:12.900 --> 00:32:17.538 
除了我剛剛提到的這些
你還有其它更好的選項嗎？

00:32:19.006 --> 00:32:23.210 
當然了 你知道的已經有了

00:32:26.580 --> 00:32:29.183 
Swift非常完美因爲不像
Objective-C

00:32:29.249 --> 00:32:31.652 
Swift只有在註釋爲動態時
它纔是動態的

00:32:32.386 --> 00:32:35.989 
如果你確保性能關鍵類是內部的

00:32:36.056 --> 00:32:39.760 
並且使用整體模塊優化

00:32:39.860 --> 00:32:43.130 
編譯器或者整體工具鏈
就可以確定何時只有

00:32:43.430 --> 00:32:45.199 
一個方法執行

00:32:45.432 --> 00:32:49.369 
並且把它內聯到調用點
讓你的性能有明顯的提升

00:32:49.436 --> 00:32:52.940 
尤其是對迭代程序這個例子

00:32:53.607 --> 00:32:56.944 
因爲我們是在生成原型
在Swift的視圖控制器中

00:32:57.010 --> 00:32:59.413 
重寫迭代程序就非常容易了

00:32:59.947 --> 00:33:01.181 
克里斯之前幹過這個

00:33:02.850 --> 00:33:09.623 
我有一個Swift執行已經就緒了

00:33:10.057 --> 00:33:14.862 
這是Objective-C執行的
一個簡易的接口

00:33:14.928 --> 00:33:17.164 
採用了他們在今天上午的
會議上提出的關於...

00:33:18.665 --> 00:33:22.269 
...優化Swift代碼的幾點建議

00:33:22.636 --> 00:33:24.805 
具體來說就是打開整體模塊優化

00:33:25.506 --> 00:33:28.342 
讓我們來剖析下這個
Command-I

00:33:29.042 --> 00:33:29.877 
它會開始構建

00:33:30.711 --> 00:33:33.480 
安裝到設備上

00:33:34.081 --> 00:33:36.350 
它會開始進行剖析

00:33:39.052 --> 00:33:42.823 
好的 我要把應用程序提前
這樣你們就能看到

00:33:44.124 --> 00:33:45.292 
這是滾動

00:33:45.926 --> 00:33:47.060 
看起來不錯

00:33:48.295 --> 00:33:49.162 
縮小

00:33:49.696 --> 00:33:51.298 
好了

00:33:51.932 --> 00:33:52.766 
縮小

00:33:53.033 --> 00:33:54.201 
非常棒 非常快

00:33:54.368 --> 00:33:55.936 
要縮小很多數據

00:33:57.671 --> 00:34:02.075 
現在 如果我前後移動
它移動的就非常快了

00:34:03.911 --> 00:34:04.745 
太棒了

00:34:06.647 --> 00:34:09.349 
謝謝 實際上我們可以到這裏

00:34:09.416 --> 00:34:11.385 
看看CPU使用情況

00:34:11.818 --> 00:34:15.022 
你懂得我們取得的優化超過了

00:34:15.088 --> 00:34:19.193 
我們的預期去掉
objc msgSend

00:34:19.259 --> 00:34:23.797 
我們本來預期會
有5到6%的提升 這個有點低

00:34:25.132 --> 00:34:28.402 
如果我關掉這個提示三角符號 
你就可以看到

00:34:28.902 --> 00:34:31.572 
它們兩個以此運行 你可以
看到之前的運行更低...

00:34:31.972 --> 00:34:37.010 
當前的運行很明顯更低

00:34:37.643 --> 00:34:39.580 
事實上如果我到這兒

00:34:39.646 --> 00:34:44.150 
查找我的構建路徑方法
現在我就必須進行搜索

00:34:44.384 --> 00:34:45.652 
這就是你進行搜索的方法

00:34:46.954 --> 00:34:50.424 
如果我點擊command-F
這個對話就會顯示出來

00:34:50.991 --> 00:34:53.827 
我可以輸入構建路徑 

00:34:54.995 --> 00:34:58.899 
它會在這裏給我顯示我的方法

00:34:59.967 --> 00:35:03.670 
如果我們看看這個 你就可以
在這裏看到我的Swift代碼

00:35:04.204 --> 00:35:07.674 
我的獲得下一個調用就在這裏

00:35:08.175 --> 00:35:09.810 
沒有在任何樣例中顯示出來

00:35:14.214 --> 00:35:15.749 
你懂得沒有樣例包括了這個

00:35:16.116 --> 00:35:19.186 
爲什麼？因爲Swift能夠把它內聯

00:35:19.820 --> 00:35:22.322 
鞭子意味着這裏沒有函數開銷

00:35:22.389 --> 00:35:24.191 
沒有方法調用開銷等等

00:35:24.258 --> 00:35:28.595 
因爲迭代程序的代碼
和其餘的代碼是內聯的

00:35:28.662 --> 00:35:32.132 
它就有了進一步優化
這就解釋了出現比我們預期的

00:35:32.199 --> 00:35:34.034 
更高的性能的原因

00:35:34.668 --> 00:35:37.638 
它是忽略了動態調度

00:35:39.006 --> 00:35:42.042 
查德 你還有什麼想對大家說的麼？

00:35:43.744 --> 00:35:44.878 
當然了 我們還剩五分鐘！

00:35:47.581 --> 00:35:50.751 
當你自行探索Instruments時
這裏有一些小竅門

00:35:51.385 --> 00:35:55.722 
首先要指出的是在錄製設置下面

00:35:56.190 --> 00:35:57.624 
叫做“錄製等待線程”

00:35:58.058 --> 00:35:59.293 
我提到過我們使用樣例

00:35:59.359 --> 00:36:01.528 
活躍CPU的服務和內核

00:36:01.795 --> 00:36:04.097 
但是如果你有空閒的線程
被一個加鎖阻塞或者等待

00:36:04.164 --> 00:36:07.134 
輸入/輸出
你就可以勾選這個複選框

00:36:07.467 --> 00:36:09.736 
服務就同樣也會對空閒線程進行採樣

00:36:10.370 --> 00:36:12.172 
如果你有代碼和加鎖爭奪支配權

00:36:12.239 --> 00:36:14.741 
那麼當你激活錄製等待線程時

00:36:15.142 --> 00:36:17.711 
你會看到熱區顯示出來

00:36:18.946 --> 00:36:20.781 
我還發現了另外一件有趣的事

00:36:21.448 --> 00:36:25.886 
在“顯示設置”中調用樹那裏

00:36:26.386 --> 00:36:27.454 
調用樹被反轉了過來

00:36:28.689 --> 00:36:31.658 
打個比喻就是它把調用樹顛倒了過來

00:36:31.992 --> 00:36:36.096 
在樹的底部節點看到的就不是葉子

00:36:36.196 --> 00:36:37.831 
那就是沒有被調用到任何地方的函數

00:36:38.098 --> 00:36:38.966 
它們顯示到了頂部

00:36:39.299 --> 00:36:42.302 
如果某個實用功能同時
被五六個地方調用了

00:36:42.636 --> 00:36:46.607 
你把調用樹反轉過來
看看到底是誰在調用

00:36:46.807 --> 00:36:48.375 
那個特定的函數

00:36:48.909 --> 00:36:51.211 
它給你提供了調用樹上的
數據的一個不同的視角

00:36:51.979 --> 00:36:53.847 
當你在調用樹上右鍵點擊一個節點

00:36:54.548 --> 00:36:58.852 
你就可以看到環境菜單
這也是那裏的一件有趣的事

00:36:59.086 --> 00:37:03.123 
我經常做的一件事就是給調用者記賬

00:37:03.423 --> 00:37:06.426 
那麼你就可以給調用者的方法
記一筆欠函數的賬

00:37:07.027 --> 00:37:10.130 
你可以給調用者記一筆欠
整個框架庫的賬

00:37:11.064 --> 00:37:14.635 
那裏還有一個選項可以修剪子樹

00:37:14.701 --> 00:37:16.904 
如果你當時不想處理某個具體的問題

00:37:16.970 --> 00:37:20.641 
你可以把它從數據上
修剪掉然後專注於你想專注的事情

00:37:22.543 --> 00:37:23.777 
我們從中學到了什麼？

00:37:25.679 --> 00:37:29.583 
就是通過這個我要提醒你們的第一件事

00:37:29.917 --> 00:37:32.352 
就是提前合併性能目標

00:37:33.387 --> 00:37:35.455 
如果你像我們一樣
進行了一個大的性能重寫

00:37:35.522 --> 00:37:38.859 
你要首先設好預算然後對它進行監視

00:37:38.926 --> 00:37:41.428 
因爲一旦你開始在它的頂部
分層放置大量的代碼

00:37:41.495 --> 00:37:42.963 
要改變就很難了

00:37:44.431 --> 00:37:45.499 
其次 要經常進行度量

00:37:45.832 --> 00:37:48.535 
在我們的整個演示中我們用時間
分析器進行了時間剖析

00:37:48.602 --> 00:37:52.105 
我們用那個數據來找出“熱區”

00:37:52.172 --> 00:37:56.076 
然後把它返回最後我們就
得到了一個運行良好的應用程序

00:37:56.610 --> 00:38:00.681 
如果你還是不明白 可能
你可能很幸運 直接點吧

00:38:01.081 --> 00:38:03.483 
我會從一個測量開始
然後把它當成領頭羊來追隨

00:38:05.152 --> 00:38:06.720 
第三 這個對我來說很重要

00:38:07.187 --> 00:38:09.022 
我鼓勵你們深入挖掘下去

00:38:09.790 --> 00:38:11.558 
你第一眼看到的某些性能問題可能

00:38:11.625 --> 00:38:13.827 
看上去是無解的

00:38:14.294 --> 00:38:16.763 
你說別人的的代碼中就出現過這種問題

00:38:16.830 --> 00:38:18.365 
或者是運行時間的副效應

00:38:19.166 --> 00:38:22.135 
我們給出你時間分析器
運行時間的詳細資料的

00:38:22.202 --> 00:38:24.938 
原因給出你反彙編視圖的樣子

00:38:25.506 --> 00:38:29.176 
就是想向你們展示那是一個
細節豐富的一個完整的世界

00:38:29.443 --> 00:38:34.414 
用它你就可以像我們
今天一樣解決性能問題

00:38:34.982 --> 00:38:38.619 
我鼓勵你們帶着創造性去
進一步挖掘

00:38:38.852 --> 00:38:40.854 
看看像這樣的會議

00:38:40.988 --> 00:38:44.525 
我知道你們能夠修復
問題 實現你們想要的性能目標

00:38:46.960 --> 00:38:48.896 
只要你今天開始幹就行

00:38:49.263 --> 00:38:52.599 
史蒂芬·萊塞是我們的
開發工具福音傳道者

00:38:52.666 --> 00:38:54.868 
如果你有問題的話就可以聯繫他

00:38:55.769 --> 00:39:00.641 
與我們相關的會議是
“能量調試問題”

00:39:00.941 --> 00:39:03.644 
證明瞭如果你在CPU上的代碼
是有效的 CPU耗能就會更低

00:39:03.810 --> 00:39:05.846 
那次會議是週三舉行的

00:39:06.380 --> 00:39:09.917 
明天還會有一個關於iOS
以及Watch OS的會議

00:39:10.284 --> 00:39:13.287 
好消息是 時間分析器
也能用於watch上的app

00:39:13.353 --> 00:39:14.188 
這是一項大福利

00:39:14.821 --> 00:39:16.423 
祝你們在會議剩餘的時間內過得愉快