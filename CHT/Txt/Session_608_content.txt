GameplayKit介紹
大家好 歡迎光臨
我的名字叫布魯諾·薩默是Apple公司遊戲技術工程師
今天我非常高興
能爲您介紹GameplayKit
Apple公司第一個專用的遊戲開發框架
我們有多種解決方案可以處理製作遊戲的視覺部分
在像SpriteKit SceneKit和Metal的平臺工具上
在遊戲開發難題中遊戲設置是另一個非常重要的部分
事實證明 遊戲設置方面存在難題
像AI 尋路算法和自主運動這些工具
我們堅信不應當故步自封
應當鼓勵開發人員設計出更優秀的遊戲
我們希望你們能夠更加專注爲生活帶來好點子
我們將挑起重擔在後端實現
所以開始製作GameplayKit時我們的使命非常清晰
我們想要設計一個具有遊戲設置且簡單功能強大的API解決方案
現在這就像普通的設計模式和架構因此我們開始先講講遊戲語言
另外還有一些標準的遊戲算法適用於多種多樣的遊戲類型
並且對我們很重要的是這隔斷圖形和引擎的聯繫
因此雖然GameplayKit與很多我講到的那些視覺框架分隔
它和其它框架運作得很好
它和SpriteKit SceneKit Metal及更多的軟件也運作得很好
所以此時我們有GameplayKit和七個GameplayKit的重要特性
並且這些組件可以說說是非常好可用於構建你的遊戲對象和遊戲邏輯
狀態機描述了我們遊戲中的狀態化和遊戲對象的各種狀態變化
主體是自主運動的實體由現實行爲和目標控制
路徑找尋解決了導航圖形生成和我們如何移動實體的問題
在遊戲世界的可通行區域中
我們也有一個極好的MinMax AI解決方案
它是非常好的解決方法讓反對計算機控制者看到了希望
有許多遊戲質量隨機源和隨機分佈可以任意使用
最後我們有一個規則系統也是個很好的途徑
對模擬謹慎和模糊邏輯很有用
今天還涉及到很多讓我們繼續看看接着講實體和組件
我想要提幾個繼承的經典問題
從普通遊戲對象中得到的
此時我們有一個塔防遊戲帶有簡單的彈塔和弓箭手類
這有一些共享的功能
我們有射擊 有移動還有被攻擊的目標
讓我們以射擊爲例
我們想讓塔和弓箭手都能夠射擊
那麼我們在哪放置射擊功能呢
一種選擇可能是在塔和弓箭手類之間簡單地複製並粘帖它
但現在在我的分享功能代碼中有兩個點
並且如果我想要更新這個功能
現在我也需要更新那兩個點
如果我只是更新一個那麼會導致一些很奇怪的行爲
所以在我所描述的這種繼承模型中
我們的唯一正確的選擇就是在樹狀圖中把分享功能往更高的層級放
此時我們有個射擊功能
可以將它置於遊戲對象類或某些基於普通的類
現在這種方法的問題是
當我們在遊戲中獲得越來越多的共享功能
我們不得不將它移到越來越高的層次
並且我們的基礎遊戲對象變得根本不基礎了
他們變得很大 難以理解並且很難維護 協作
讓我們看下怎麼樣用實體和組件解決這個問題
你看我們仍然有三個對象彈 塔 弓箭手
但現在取而代之的是有了功能在繼承意義上
成爲移動者 成爲射手成爲被擊中者
它們反而有這些對象我們稱之爲組件
裏麪包含遊戲邏輯的個別元素
所以此時我們有移動組件可以解決移動問題
有射擊組件可以解決射擊問題
還有目標組件這表示可命中目標
所以我們獲得這些很好的小黑盒具有特定功能鬆散結構的盒子
而不是與層次緊密結合的結構
所以我們現在看見的實體和組件是的很好方法
可用於組織我們的遊戲邏輯
舉個例說他們很容易維護
因爲他們是極好的黑盒子具有壓縮功能
他們傾向於更簡單
我們也可以讓實體和組件進行良好的協作
現在我可以讓一個開發人員在一個組件上操作
另一個開發人員在另一個組件上操作
並且他們不一定需要知道這些組件間的具體細節
我可以隨着複雜性的高低得到很好的縮放比例
我的意思是 在那個類和繼承模型中我的層級越來越寬 越高
隨着我的遊戲變得越複雜
有了實體和組件它只是在寬度中變得更寬
而不再有其他變化
真的是個好工具
無論何時想在遊戲中製作個新實體
我只要簡單地看下可用的組件
選擇合適的或執行新的組件
有了實體和組件我們可以輕易獲取動態行爲
讓我們回想塔防例子
我想要實現施放魔咒使弓箭手固定不動這樣他們不再移動
一種典型的方法可能是暫時刪除它的移動組件
間接地告訴遊戲剩下的部分
停止移動
並且在這裏還有其他的優勢即不需要知道魔咒的細節
那麼讓我們繼續往下看一下類
此時我們有GKEntity
這是基於實體的類
這是個簡單的組件集合
隨着實體功能改變
它可以動態增加和刪除組件
同時也讓我通過獨特類的類型訪問現有的組件
當我在GKEntity上調用更新時自身擁有的組件將自動更新
所以回想之前的例子 彈 塔 弓箭手都隨着GKEntities而更新
現在講GKComponent類
現在當你要在遊戲中添加功能時你可以把這編入子集
並且有多種方法可以實現
你的組件屬性成爲那些組件的狀態信息
所以你可以想象射擊組件此時很可能有一個傷害屬性
描述了炮彈能造成多大的傷害
你也可以執行自定義選擇器進行功能擴展
也可以告訴遊戲的剩餘部分如何與組件進行通訊
同樣舉個例子 移動組件此時可能有能移動到某位置的功能
你可以調用輸入或調用遊戲控制器代碼
正如我之前所提到的組件是通過它實體更新實現自動更新
並且你可以隨意地在updateWithDeltaTime中執行時間邏輯
因此你需要更好地控制命令或控制組件的更新
爲此我們提供GKComponentSystem
這是不同實體的組件集合
但他們都是同類的類型
並且在當更新命令對遊戲內部起到重要作用的情況下調用
在更新移動代碼後我可能想要更新AI
因爲我想讓我的AI處理最新的位置信息
需要留意的是放置在組件系統中的組件不會隨着實體更新而更新
而取決於在正確的時間調用組件系統更新
以便更新所有的實體
所以再一次回想我們的例子
我們可能有一個移動系統能夠移動遊戲中的組件
並且我可以用來同步多種實體間的移動
最後我有一個代碼例子 看看如何使用GameplayKit的實體和組件
你看下此處的上方我將製作我的弓箭手實體
然後我將製作三個組件構成一個弓箭手移動組件
射擊組件和目標組件
並且給我的弓箭手增加這些組件
然後我將製作談到的移動系統進入移動組件的類
指示這個組件系統只處理移動組件
然後我將增加弓箭手的移動組件到移動系統
然後繼續進行弓箭手和移動系統準備就緒可以使用了
所以接下來是實體和組件
因此讓我們轉移到狀態機
此時我將講解其它例子
讓我們想象一些遊戲遊戲中玩家被鬼魂追捕
有時他獲得力量加成然後追趕並擊敗鬼魂
這有一個狀態機的例子說明如何控制鬼魂的
此時你看 我們有四個鬼魂狀態
當鬼魂追逐玩家時可以逃跑
當玩家追逐鬼魂時可以被追趕
當鬼魂被抓住且被打敗時可以被擊敗
並且在擊敗後和復活前有時候可以復位
現在重要的事情是請注意只有一部分狀態轉換是有效的
你可以看到 我在追趕和逃跑之間轉換
根據我剛纔描述的這是合理的
有時候是鬼在追趕玩家有時候是玩家在追趕鬼
當然只有在逃跑的時候會打敗鬼
這是玩家可以真正打敗鬼的唯一時刻當獲得力量後就可以追趕鬼
然後復活再被打敗這是同樣的道理
在我們重生之後我們就開始追趕鬼
這是我們的初始狀態
當鬼重生之後它們就變回追趕玩家
因此爲什麼說狀態機對遊戲開發是如此重要
對於很多遊戲來說這是遊戲設置元素的重要部分
許多常見的遊戲設置元素都充滿了狀態
例如動畫製作AI UI 等級
想要在遊戲中賦予讓人物類角色以生命
毫無疑問地開發者必須對狀態機非常熟悉
我們通常有個IdleAnimation
和MoveAnimation及AttackAnimation
並在它們之間進行合理切換
因此由於這種模式在我們的代碼中是很普遍的
我們會執行多次
與部分樣板文件一樣採用個開關語句或者樹狀結構
是否有一些常見的方法
用於刪除樣板文件添加一些可維護性
讓我們可以在整個遊戲中從使用狀態和狀態機得益呢
這就是我們在GameplayKit裏做的
讓我們來看看類
這裏我們有GKStateMachine
這是你的總體目標限定狀態機
我的意思是說任何給定的狀態均只有一個狀態
它擁有所有的狀態
你可以調用狀態機裏的enterState進行狀態轉換
具體發生了什麼呢如果轉換是有效的 它會檢查改變
它調用許多狀態目標的回調函數
退出狀態 進入狀態等
並更新狀態機裏的現有狀態
在那個鬼的例子中我們可能有個GhostStateMachine
它將依次有四個狀態
這裏我們有GKState抽象類
然後調用回調函數執行狀態基礎邏輯
當你鍵入狀態的時候我們給你一個進入回調函數
當你離開狀態時我們給你個退出回調函數
當狀態機裏是現有狀態的時候我們給你一個更新回調函數
正如我之前所提它們會在何時的時間自動被狀態機調用
你可以選擇性地重寫isValidNextState功能
從而控制狀態圖邊緣就是那些我說的有效轉換
現在通過默認值所有這些邊緣都是有效的
但毫無疑問的是你想要調用狀態的內部動態決定哪個轉換是有效的
我們討論的四個鬼狀態追趕 被打敗 逃跑 重生
全部會隨着GKState被執行
因此我想要在這裏通過一個例子結束這個問題
讓我們執行剛剛討論的GhostStateMachine
一開始我要說說我的四個狀態
追趕 逃跑 被打敗以及重生
然後我將使我的狀態機經歷這四種狀態
這四種狀態是狀態機裏有的狀態
然後我將繼續並在例子中進入追趕的初始狀態
我們開始這個狀態機它已爲我們的遊戲做好了準備
並且鬼將做我們希望它做的
這就是狀態機
讓我們轉向主體 目標和行爲
在我們開始之前先說一些概念
我們說的主體 目標和行爲
都是真正的自主移動實體
由現實的行爲和目標所控制
它們受制於許多客觀約束如掩碼 加速度和慣性
控制這些主體的行爲反過來組成一定的目標並附上適當的權重
從而在遊戲中完成一些有意義的自主運動
因此爲什麼主體在遊戲發展中如此重要
我想許多遊戲都是以現實情況爲出發點
當我們的遊戲實體呈直線運動
然後再轉彎後撞上環境障礙物這樣看起來就不是很真實
現實世界的運動有諸如慣性
質量和加速度這類的因素
這樣它就可以準確地避開附近的障礙物和其它實體
當實體知道如何從點A到點B它們通常跟隨一條路徑
並且路徑通常是筆直的而非曲折的
以上就是對主體系統的簡單概述
我們有主體類由一個行爲控制
也有一個指派讓你可以迴應 主體中的變化
這些行爲反過來組成一定的權重目標從而實現有意義的功能
你可以設置許多目標如尋找 攔截 避免障礙物及跟隨路徑
讓我們繼續看看類
GKAgent是一個簡單的自主質點
也是個GKComponent
和實體 組件系統配合得非常出色
當你在GKAgent上調用更新它將應用當前行爲
具體的是查看組成行爲的目標
然後計算權重及所有必須的加速變化從而達成目標
然後運用加速中的變化
改變主體速度和旋轉位置
正如我說的 現在GKAgent受制於許多客觀約束
例如質量 反彈半徑最大速度和最大加速度
很重要的是請注意這些單元式無標度且只適用於遊戲世界
因此你可以想象以公里爲單位的遊戲相對於英尺爲單位的遊戲
二者將有非常大的差異
因此要確保遊戲世界選擇合適的數值
這裏我們有GKBehavior類
它是一個像字典一樣的簡單目標容器
它讓你隨着遊戲動態修改行爲
你可以添加新的行爲添加新的目標
移動已有目標改變已有目標的重量
正如我之前提過的在主體設置了一個行爲
主體將很好地執行
下次你更新主體時它將正確遵循該行爲
舉幾個關於行爲例子可能你想執行羣集行爲
以模仿現實世界中鳥類的羣集
我們可以通過合適權重將一個凝聚目標 一個分離目標
和一個匹配目標結合在一起
或者我可能正在做一個賽車遊戲我想要做一個競賽行爲控制賽車
這就像結合跟隨路徑那樣簡單
我想要我的賽車跟隨賽道
避開其他主體目標
我想要我的賽車避免和其他賽車相撞
這代碼樣本看起來像室行爲代碼的樣子
看上面 我將創建尋找行爲
我想在我的環境裏找一些敵方的主體
我將創建一個迴避目標用來避開附近的障礙
然後我將創建一個targetSpeed目標我想要我的主體加速並達到目標速度
然後用一套合適的權重讓我的行爲通過這三個目標
你可以看到我把迴避目標權重加到5
因爲我真的不想讓我的主體撞到附近的障礙
然後我將創建我的主體
初始化 設置行爲
主體已經準備好了
下次我更新主體時它將完全按照我的要求來做
現在來講講主體指派
在你需要使用基礎指派模仿
同步你的外觀事物如圖形 動畫 物理時
GKAgentDelegate就很有用了
我們提供兩個回調函數對其進行操作
在主體更新前調用agentWillUpdate
在設備更新後調用agentDidUpdate
在你的遊戲中這或許就像是SpriteKit節點
或SceneKit節點 或渲染組件
我們來看看SpriteKit遊戲中這個指派看起來像什麼
你可以看到這裏有個自定義圖形節點MyAgentSpriteNode
我將繼續操作並執行我剛說過的兩個回調函數
在agentWillUpdate中我將在循環裏設置主體的位置
它們的節點位置一樣
我想讓基礎主體模仿和我的外觀相匹配
然後我將做一些更新
然後在agentDidUpdate中做的事情剛好相反
我將在循環中設置節點位置
它的位置和循環中主體的位置一樣外觀將和基本主體模擬相匹配
我將簡要的爲你展示一下
主體運動的樣子和你可以自行處理的一些目標
有個簡單的SpriteKit情景我們用一個圓圈裏的三角形來代表主體
他們按照三角形的指向調整方向
這裏我有一個座位目標
中間的主體會試圖尋找鼠標的位置
可以看到移動看起來很流暢自然
因爲它是受真實物理約束比如質量 加速度和慣性
這裏有個相反的事例 逃跑目標
主體試圖逃離鼠標的位置
這是漫步行爲的事例
我的主體正在環境裏任意移動任意左轉 右轉
這是一個障礙迴避目標事例
我的主體又在試圖尋找鼠標的位置
但我在情景裏增加了一些循環障礙物
主體的目標之一是迴避障礙
所以在他試圖尋找鼠標位置時同時也在避免和障礙物相撞
這是一個分離目標事例
我有三個主體正在試圖尋找鼠標位置
但他們同時有一個分離目標
他們之間試圖保持最小距離
這對遊戲中編隊飛行或各組保持在一起真的很有用
這裏有個對齊目標事例
右邊的主體試圖與左邊主體的標籤相對齊
這對於在遊戲中同步單位真的很有用
這裏有一個羣集目標事例
領導主體是在場景裏漫步的紅色
但是在一個羣集行爲裏同樣還有一組藍色主體
它們結合了一個凝聚目標一個分離目標 和一個陣營目標
形成了一個集體同時試圖追逐領導實體
分離目標 維護他們之間的最小距離
凝聚目標讓它們以結合塊的形式待在一起
而對齊目標想讓它們達到一個均等狀態
最後是一個跟隨路徑的事例
我的主體正試圖跟隨簡單的多線路徑
請注意它並不會突然轉彎
他正處於我們說過的真實物理約束下比如質量和加速度
所以儘管基本路徑是固定的但是主體會被迫以曲線的跟隨目標
以上就是主體 目標 和行爲
我們現在繼續來說說搜索路徑
我很確定在遊戲開發中我們對此都很熟悉
在我的遊戲世界裏有一些實體想從A點移到B點
但路徑中有一個障礙
我不想這些實體穿過障礙我不想她碰到障礙
我想讓她像人類一樣準確地找到路徑 繞過障礙
我正在尋找的是這些東西
我想讓她找到障礙周圍最短的路線 越過障礙 繼續前往目標
我們調用遊戲設置搜索路徑
開始之前 說一些概念
導航圖上的路徑搜索操作
導航圖是一個節點集合體現的是遊戲世界裏可通行的區域
允許實體呆着以及移動的地方
這些節點依次連接在一起體現在可通行區域是如何移動的
這些連接可以是單向的也可以是雙向的
在連接圖中任何兩個節點之間總是存在最佳路徑
這是在路徑搜索中我們通常會找到的路徑
我們繼續來看看類
我們有GKGraph這是抽象圖基礎類
它僅是圖節點的容器圖節點是遊戲世界裏可通行區域的描述
在遊戲世界有變動時它有個功能可用來增加以及移除節點
它也可以讓我將新節點連接到圖上與我希望的現有的節點做恰當的連接
當然我們也可以讓你在節點和一個圖之間尋找路徑
我們提供兩個專門化
一個是GKGraph和網格配合使用一個是GKGraph和障礙配合使用
我們現在來看下這兩個東西
GKGridGraph
這是GK圖2D網格專用的
它所做的是自動創建所有節點用來代表格框
既定的初始位置網格 寬度網格以及高度網格
它將在網格節點間自動創建基本連接
同樣在在對角線之間隨意創建基本連接
它也有很簡單的功能在你的遊戲中
網格空間變得不可通行時可對其進行增加以及移除
接下來我們講GKObstacleGraph
這是GK圖遊戲世界中 障礙周圍路徑搜索專用
障礙可以是任意的多邊形
我們提供一些在遊戲世界變化時不斷地增加以及移除障礙的功能
它也可以讓你不斷地將新節點連接到圖上
對於爲一個單位尋找路徑而在圖中插入一個開始以及結束節點來說很有用
我們通過一個緩衝區半徑實現
這是障礙周圍的安全地帶
這裏我的實體是進不去的
它通常是由遊戲來決定大小
與我想要做導航的實體邊界框半徑有關
我們來說說這些障礙圖是如何被創建的
這裏是一個簡單的情景有兩個方形障礙
左下角的一個實體想要到達右下角的橋上
我的實體受一些邊界框半徑約束
我們將它當做緩衝區半徑人爲增大障礙
高級選項下障礙圖將在網格節點間創建合適的連接
它將不會創建違反障礙空間性的連接
從這裏可以看到我們找到了最短的路徑了
它將不會和障礙相撞
這是最後示例的代碼
但這個示例中只有一個障礙
在頂端我將創建一個只有四個點的簡單多邊形障礙
我將創建障礙圖進入障礙以及一些緩衝區半徑
然後我將創建一個開始和結束節點
一個是現在我的英雄所在地另一個是她想去的地方
我不斷地將這些節點連接到我的障礙圖上
它將做的是將這些節點插到圖中並再一次自動創建合理的連接
但它並不創建那些會違反障礙空間性的節點
最後我爲開始和結束節點尋找一個路徑
我取回一個簡單的圖節點NSArray
我可以用它來激活角色
GKGraphNode是圖節點類的先進節點
毫無疑問你會想對其進行劃分子類
在你執行高級或非空間操作或在需要精確控制路徑搜索時
將非常好用
你可以設想一個擁有各種版圖類型的戰略遊戲
或許你想要一個森林版圖類型
可以向其他版圖類型一樣做雙倍挪動
我需要考慮路徑搜索
我不想它返回可見的最短路徑
我只想它在森林周圍進行導航
因爲事實上在我的遊戲世界裏這是最短的路徑
在你想手動創建自己的圖時GKGraphNode同樣也很有用
你通過手動管理節點間的連接手動創建自己的圖
對於一些像抽象或非空間圖的東西這真的是好東西
或許你想要你的遊戲有個端口想要單位讓這些端口爲路徑搜索負責
儘管這些端口在空間上並不相連
Grid/GraphNode和使用障礙節點的GraphNode2D
正如你所看到的都很合適
對於這個特性我真的很興奮
我們和SpriteKit組配合做了一些工作
可讓你從現有的SpriteKit Scenes中
很容易地創建這些障礙圖
你可以爲這些類似節點邊界節點實體和節點材質的東西創建障礙圖
這個意思是說只要極少的代碼
你就可以獲得一個現有的SpriteKit場景創建一個障礙圖
並動地在其周圍路徑搜索
現在我們爲你稍微展示一下
我們用SpriteKit來搜索路徑
這裏有一個我們講過的塔防遊戲
我們將它作爲SpriteKit場景來執行
我在左邊創建實體它們想移到右邊的橋上
因爲這是個塔防遊戲
我將在右邊放置一些塔而這佔用了它們現在的路徑
我們繼續 放置一個
你將看到它們在它的周圍正確地搜索路徑
那是因爲我們正在用剛講過的SpriteKit集成
自動地從節點創建一個障礙
更基本的GKObstacleGraph
以及更新我們的路徑
我們轉向調試程序迅速的將塔移開
你可以看到從開始和結束節點間的簡單路徑
當我在這裏插入一個障礙時
我們重新計算了基本的GKObstacleGraph
這就允許我們的實體在障礙周圍找一條新路徑
我們繼續增加一些東西
因爲有那個SpriteKit集成每次我們增加或移除障礙時
基本GKObstacleGraph總能進行更新
以上就是使用SpriteKit的路徑搜索
現在有請我的同事蘿絲·德克斯特
爲我們講講MinMax AI
蘿絲
謝謝你 布魯諾
布魯諾剛講的很多特性可以用來創建AI
但它們更多的是在你的遊戲中給於實體生命
許多遊戲也需要同等的AI對手用人類玩家同樣的規則來玩整個遊戲
這對於有些遊戲來說是很關鍵的如象棋 西洋棋 一字棋等等
所以我們想爲你提供解決方案
我們選擇實現經典AI解決方案MinMax
將它當做GameplayKit關鍵部分
MinMax會查看所有適合玩家的移動
然後它根據每個移動及每個移動能產生的所有排列建立一個決策圖標
當你請求一個移動它就搜索決策圖標最大化潛在收穫
同時最小化潛在損失
在這個一字棋事例中
AI爲X玩家選擇了右邊的一步因爲是在最好的情況下 結果是勝利
在最差的情況下 結果是平局
其他兩個布則會導致失敗
MinMax AI給你控制對手的能力
當人類玩家陷入困局時它也可以爲人類玩家提供建議
這對於遊戲來說非常好甚至都不需要其他的AI請求
它尤其適合以轉彎類的遊戲
但也同樣適合對於需要玩家操作的不連續移動的遊戲
但你也可以通過改變對未來的預測程度調整AI的難度
事先預測10步
當然要比事先只預測2 3步要來的更有效
此外你可以隨意指揮它任意挑選最不適宜的一步
給它一些類似人類的錯誤
我們來看看它如何整合到遊戲之中
MinMax非常棒的地方是你不需要知道遊戲的任何細節
你不需要告訴它你的規則它也不需要知道該如何執行
所有的這些都是抽象的
你所需做的只是提供遊戲中的玩家清單
他們可能會走的步
每個玩家的分數用來顯示他們目前位置的相對強弱
當你向AI請求一步它會考慮所有這些數據 創建決策圖標
返回一個最佳策略供你使用
我們來看看類
有三個所需的關鍵協議以便與MinMax AI配合使用
第一個是GKGameModel
指的是對目前遊戲狀態進行抽象
比如你在創建一個象棋遊戲執行該類的較佳的是板類
因爲它追蹤板上所有的位置以及目前在玩的所有塊
正如我在前面的幻燈片提到的
所需做的是提供遊戲中活躍的玩家清單
目前的玩家每個玩家的分數
然後是每個玩家可能會下的每一步
同樣也需要一個應用這些步的方法
AI用這個方法創建出決策圖標
在它已經被AI選中後你也可以用它來應用每一步
當採用該步後它將改變目前遊戲狀態
可能改變玩家目前的行動
每個玩家的分數
以及適合他們的下一步
接下來的協議是GKGameModelUpdate
這是遊戲裏的動作抽象
它應該有你爲遊戲模型應用每一步的全部數據
正如我們所說的MinMax用它創建決策圖標
在它被選中後你可以用它來做出下一步行動
最後是GKGameModelPlayer
是遊戲玩家抽象
AI用它來區分不同玩家的行動
現在來說說AI它屬於GKMinMaxStrategist類
在GKGameModel上運作
在你創建MinMaxStrategist示例後
你將把它連接到gameModel屬性中
當你從AI請求下一步時maxLookAheadDepth就是能進行預測
正如我們前面提到的較高的數字比較低的數字更有效
開始使用之前這是你所需要做的
當你調用bestMoveForPlayer時AI將創建它的決策圖標
按照從優到劣的順序列出所有適合的步然後返回最優的步
這可能會出現在這些情況中
你有不止一個有利的步需要由AI作出決定
以及這些情況中你可以直接指揮AI隨機打破連接
若你想調用randomMoveForPlayer它就會出現
你有10個適合玩家的移動
但你只想從3個最佳移動中隨機挑選出一個
它將按照你的要求操作從3個最佳中隨機挑選出一個
而選出的這個可能是次優的
如果你想要讓AI看起來更人性化 會犯錯誤
這或許就是最令人滿意的結果了
bestMoveForPlayer和randomMoveForPlayer
都返回GKGameModelUpdate
你可以將GKGameModelUpdate應用到GKGameModel以創建一個移動
這是個簡單的代碼樣本
我正在創建象棋遊戲模型
不幸的是
審查你將如何執行遊戲模型細節不在這個會話範圍裏
但我們有很棒的樣本代碼
你可以用來展示將如何做這些事
我們創建象棋模型
然後創建MinMax AI
通過在gameModel屬性上設置遊戲模型將它聯繫起來
我們爲LookAheadDepth選擇6
當你創建決策圖標時你將提前看到6個轉彎
這就是我們所需做的
我們調用當前活躍玩家的bestMoveForPlayer
它將利用所給信息爲玩家找出最優移動
你可以在遊戲中應用那個移動用它來創建移動
我們來看一個簡單的演示
有一個只有兩個玩家的簡單遊戲黑色和白色
它們在棋盤上儘可能的收集和它們同顏色的塊
當它們在棋盤上放置塊時
它們將反轉兩塊之間的屬於對手的塊使之變成屬於己方顏色
我們有兩個AI控制的玩家
黑色玩家可提前預測5個移動
而白色玩家只能提前預測3個移動
在遊戲過程中使得黑色玩家可以很容易的打敗白色玩家
這裏你可以看到有雙方玩家的分數
這個很簡單
我們來看一下玩家在棋盤上擁有的塊減去對手在棋盤上的塊
再通權重碼進行調整就得到分數了
這裏你可以看到黑色玩家很容易就打敗了白色玩家
我們來詳細看下分數
看這裏
在中間的塊他們的權重是1
棋盤邊緣位置權重略高
在角落的權重就更高了
因爲對於玩家來說這些位置更有利
我們通過改變這些位置如何影響分數來指揮AI選擇這些地方
我來互換一下這些人的預測
白色將會預測4步取代先前的預測3步
儘管只是小變動這也會讓AI更有效率
事實上遊戲中白色AI略佔上風
但是黑色AI將犧牲短期利益換取長期勝利
這樣最後就可以戰勝白色
以上就是MinMax AI
現在讓我們來討論隨機源
起初這個話題可能看起來不必要
因爲我們已經有了隨機函數爲什麼我們不能僅僅使用它就好呢
好的 隨機函數給我們隨機序號
但是遊戲有獨特的隨機序號需求
隨機函數可能無法給我們想要的一切
首先每個系統中由隨機函數生成的序號可能是不相同的
不能保證不同的計算機平臺產生的結果是相同的
這對網絡遊戲來說會是一個大問題
因爲我們不能依靠任何一方以相同順序生成的數據集合
否則爲了使兩方是數據同步
我們不得不浪費關鍵帶寬
因此我們需要平臺獨立性和確定性
無論我們什麼調用隨機函數都取自單一來源
如果我對AI代碼中的隨機函數有一串請求
然後我在我的物理代碼中添加一項請求
物理代碼中的這個請求就會影響在我的AI代碼中生成的數字
這可能會導致意外行爲
我們真正想做的事情是可以把這兩個系統分開
這樣兩個系統分別生成的數字就不會互相影響
我們不僅想要控制生成的數字範圍
而且還要控制這些數字在該範圍內是如何分佈的
這就是隨機源的由來
我們爲你提供一系列具有確定性的遊戲優質隨機源
因此當你有同樣的種子時你就可以獲取相同順序號
無論你在什麼平臺上
它們是可序列化的因此它們可以爲你保存遊戲數據
這對阻止欺騙程序是非常實用的
人們用行業標準算法執行
衆所周知這些行業標準算法具有可靠性和卓越的隨機性
此外我們爲你提供一套隨機分佈槓桿
這使你可以在給定的範圍內控制序號的分佈
我們有一個真隨機它的每個值都有同等的發生可能
高斯通過平均值分佈中它的值以鐘形曲線分佈
而非邊緣值以及反聚類或恰當的隨機分佈
這樣有助於消除運行的數據
最後我們有NSArray排列
對洗牌這類事情是超級實用的
讓我們來看看類
GKRandomSource是隨機源的基礎類
採用NSSecureCoding和NSCopying以便被安全地序列化
同樣的種子保證了確定性
無論你在哪個平臺上
因此如果你想要同樣的順序號你可以依靠它生成
如果沒有種子可以從安全的系統源獲取一個
我們繼續說說共享隨機
它是系統隱含的共享隨機源
它不具有確定性但是很多例子說明它值得擁有
例如你在洗牌的時候你希望每個結果都是唯一的
讓我們看看我們爲你提供的AI隨機源運算法
我們有ARC4
它低消耗並具有卓越的隨機性並且它即將成爲你的Goldielocks隨機源
我們有線性意味它比ARC4更低消耗
但它的隨機性並不那麼好你可能會更頻繁地看見重複的順序號
最後我們有馬特賽特旋轉演算法高質量但佔用大量內存
可以發現沒有一個適合密碼系統
但Apple提供其它單獨的API來滿足這些需求
現在我們開始討論隨機分佈
在基礎類中GKRandomDistribution執行一個純粹的隨機分佈
意味着每個在最低值和最高值之間的值都有同等的發生可能性
你可以通過操縱nextInt
nextUniform及rextBool來獲取數值
我們也提供一套骰子默認構造函數用於創建6面 20面和自定義骰子
然後我們有GKGaussianDistribution
來執行鐘形曲線高斯分佈
這些值偏向於均值而距離均值較遠的值是不太可能發生
這就是在樣板分佈裏所發生的一切情況
我們已經生成了一個由1到5之間數字組成的15位順序號
我們可以看到均值3發生的可能性遠遠大於其他任意數
事實上和其它任何數字一樣它發生兩次以上
邊緣數1和5
每個只發生一次
可以發現在一個標準高斯分佈中它是無限的
但它不被隨機源需要
因此我們操縱每個均值三個標準差之外的每個值
接下來我們看看
在GKShuffledDistribution類中執行反聚類分佈
這是隨機分佈有助於減少或消除運行的數字
但它隨着時間是隨機的
你運用uniformDistance來控制這些
在0.0所有數字都有同等的發生概率
這是無法從一個隨機分佈中真隨機源中區分的
在1.0所有值都是不同的
在你開始看到任何重複值之前它會遍及範圍內的每個值
這就是在我們的分佈中的情況
再重複一下 我們生成了由1-5之間的數字組成的15爲數值
在我們開始發現任何重複值之前我們會命中每一個數值
實際上每個數值都生成了三次
讓我們來看一個簡單的代碼例子
我們可以很容易地創建一個6面骰子隨機源
你僅需運用默認構建函數GKRandomDistribution然後搖動骰子
如同調用nextInt一樣簡單
類似的創建一個20面骰子也很容易
創建自定義骰子也同樣簡單
我們正創建一個256面骰子
如果你試着在現實世界中擲這樣的骰子情況將完全不一樣
前面的三個例子都運用真隨機分佈執行
但你可以使用我們提供給你的任何分佈
我們正使用高斯分佈
創建了一個20面骰子因此它的均值大約是11
因此當你轉骰子的時候你最有可能得到一個約值
在這裏我們創建一個20面骰子使用洗牌分佈
在默認情況下統一的洗牌分佈距離是1.0
因此當我們轉動的時候
在我們看見任何重複值之前我們將擊中範圍內的每個值
我們第一次轉的時候可能得到了5
然後我們知道下一次我們轉動它的時候我們一定不會再轉到5
直到我們轉出範圍內的其他所有值
最後我們有數組洗牌
我們運用早前在GKRandomSource提到過的共享隨機源
它讓我們獲得系統隱含的隨機源
它不具有確定性
但在這個情況下是有利的
我們希望每一個卡鏟都是唯一的
你可以看到讓隨機源成爲你遊戲的一部分是很容易的
僅僅是幾行代碼就可以實現
這就是隨機源
現在我想邀請橋什·伯格斯和我們談談規則系統
謝謝 羅斯
你們好 我是橋什
我一直和布魯諾和諾斯並肩工作進行GameplayKit收尾工作
我在這裏講講這些系統中的一個規則系統
在我開始降解規則系統之前我想要說說遊戲總有的一些常見要素
遊戲往往由三個元素組成
這像是名詞之類的東西位置 速度 生命值
已經穿上身的裝備
第二是類似動詞的東西
這些玩家可執行的動作例如跑 跳
使用一件物品或者如果你在一輛車上 加速
最後是規則
規則是極其重要的因爲要界定名詞和動詞是如何相互作用
規則給你的遊戲添加了質感絕好的遊戲有絕好的規則
讓我們來看一個例子規則
在這裏我們有一項規則
司機可以用來決定什麼時候剎車什麼時候加速
運用距離的輸入屬性
玩家要麼將減速 要麼將加速
在這個例子中我們可以看到
如果距離小於5 他們將剎車
當大於或等於的時候 他們將加速
這個邏輯很不錯但這裏有一個不易察覺的問題
在距離爲5左右我們的動作非常不穩定
因爲汽車將在剎車和加速之間不斷徘徊
這將使我們的動作非常不穩定
因此想要更多自然的動作我們需要一些更加真實的東西
運用一個更加模糊的解決方法
我們輸出的情況而不是立即執行動作
我們在這裏輸出了兩種情況 近和遠
兩者都是基於距離的
重要的事情是
現在你既可以是遠也可以是近
與其執行一個或另外一個
這讓我們把兩者融合在一起獲得更加自然的動作
這對之前的例子尤爲重要現在當距離在5左右
我們可以更加自然地加速
這就是規則系統的動機作用
事實是可以劃分等級的
這允許我們用模糊的邏輯執行更加複雜的演算
模糊邏輯處理近似值
它也允許我們把我們做什麼和我們如何做分開
而不是馬上執行動作
我們只是說明關於世界的情況然後基於這些情況採取推遲操作
讓我們來看看這些類的其中之一
這裏我們有GKRule
GKRule包含一個布爾預測和一個動作
預測與事實和系統狀態相匹配如果預測爲真 將觸發動作
動作則如斷言事實那樣簡單也可以如複雜塊一樣複雜
重要的是現在可以運用
NSPredicate序列化方法進行序列化
重要的事情是記住規則系統提供近似值答案
回答類似前面的車有多遠這樣的問題
在第一個例子中
我們可以相當自信認爲我們還很遠
在其他兩個例子中事情有點模糊
我們在做出答案後真實情況是介於兩者之間的
讓我們來看看管理這些規則的系統
這裏我們有其它類GKRuleSystem
它是規則和事實的有序集合
如要陳述世界事實只需要進行調用即可
這將在序列中運行規則
這些規則將使用一個狀態字典作爲輸入
然後基於此插入事實
事實將輸入到事實序列
重要的是要了解陳述事實後
評價將返回到開端然後繼續評價
這是因爲當你明確一個事實的時候
它可能會影響其它規則的運行
這可以確保當評價結束的時候你可以有最簡明和精確的遊戲視圖
如要重新開始
比如在一個更新循環末尾或計時器上
只需調用重置
這樣你就可以重複評價
讓我們看一個代碼例子
在開始的時候我們初始化規則系統
然後我們獲取狀態並明確基於此的兩個事實
稍後在遊戲代碼中
我們抓取這兩種等級並求出兩者之和
來獲取關於我們可以加速多少的模糊近似值
然後填入遊戲代碼中
看看我們正在做的一個小例子
我們在高速公路上開車
汽車在十字路口使用一套規則而在高速公路上使用一套不同的規則
高速公路上使用的規則是基於與前方車輛的距離
決定它們要加速多少或減速多少
它們明確世界的兩個事實
分別是距離和相對速度
車輛在十字路口使用另一套規則明確誰有通行權的事實
現在綜合在一起的話
我們獲得非常複雜的仿真世界
這就是規則系統的力量
所以在我運用規則系統作一些最佳實踐之前
很重要的是請記住GKRuleSystem是孤立的
你必須使用狀態字典作爲遊戲世界的快照
你同樣必須要運用許多簡單規則並明確許多關於遊戲世界的事實
作爲對抗大型複雜規則以及少數事實
同樣重要的是請注意事實是一些近似值
如何使用它們取決於你
事實的等級是系統的置信度
這允許我們使用模糊邏輯來完成更復雜的推理
那樣 我想把這交回給我的同事布魯諾
謝謝 喬什
這就是GameplayKit
今天我們講了GameplayKit裏的七個主要系統
實體和組件是構建遊戲邏輯的好方法
狀態機處理遊戲中的狀態性及我們的目標經歷的各種各樣狀態變化
主體即自主移動的實體由真實行爲和目標控制
路徑搜索 處理導航圖的生成以及找到我們遊戲世界中的路徑
我們也討論了MinMax AI解決方法
它讓計算機控制的對手表現出生命力
同樣可以提供給你許多隨機源和分佈
最後我們討論了規則系統是用於描述謹慎和模糊邏輯的絕好方法
我們很期待發布GameplayKit
我們迫不及待地想看到你們會如何使用
一些很好的代碼例子本週發佈了
如果你想了解更多東西你一定要看看
Demobot是一個SpriteKit遊戲涵蓋了GameplayKit各種API
FourInARow是實操MinMax AI的絕佳示例
AgentsCatalog表現主體行爲和目標的好例子
因此如果你想學習一定要看看
同樣還有一些環節如果你想要了解更多相關技術
例如SpriteKit ReplayKitGame Center SceneKit
今天午飯之後有一個DemoBots的深入研究
就是我說到的那個例子
如果你想了解更多關於GameplayKit或SpriteKit的資料
就一定要來看看
我們有實驗室歡迎來遊戲控制器實驗室
今天午飯之後同樣有個關於GameplayKit實驗
大家可以來會面成員 發問討論任何關於代碼的問題
如果你需要更多信息請登錄偉大的開發者網站
有任何一般詢問聯繫我們的遊戲技術專員艾倫·沙菲爾
謝謝會議中間請休息片刻