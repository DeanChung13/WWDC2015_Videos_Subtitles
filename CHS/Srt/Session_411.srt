00:00:26.593 --> 00:00:27.728 
下午好

00:00:29.596 --> 00:00:31.064 
大家好
感谢大家能来参加讲座

00:00:31.131 --> 00:00:34.001 
我是泰德·克热梅内克
我在Apple管理Swift团队

00:00:34.067 --> 00:00:37.704 
阿莱克斯和我很高兴也很荣幸

00:00:38.138 --> 00:00:40.741 
和大家讲讲在编译时使用Swift

00:00:41.141 --> 00:00:44.444 
来发现编码的更多问题

00:00:45.212 --> 00:00:46.613 
这是个相当宽泛的话题 所以我们

00:00:46.680 --> 00:00:48.882 
所以我们决定主要谈两个问题

00:00:49.683 --> 00:00:53.654 
首先是利用Swift 2中的
新语言术语供给

00:00:54.588 --> 00:00:58.625 
以便轻松允许应用利用新的API

00:00:58.725 --> 00:01:00.160 
与此同时部署更早的版本

00:01:00.594 --> 00:01:02.596 
在更早的讲座中
我们简要谈过这个话题

00:01:02.663 --> 00:01:04.531 
我们马上要深入探讨设计

00:01:04.598 --> 00:01:06.867 
方法的理念所解决的问题

00:01:06.934 --> 00:01:08.535 
以及如何在代码中实现最佳应用

00:01:09.269 --> 00:01:11.138 
然后 阿莱克斯会谈谈如何

00:01:11.205 --> 00:01:14.441 
使用富类型系统协议和枚举

00:01:14.508 --> 00:01:18.312 
甚至还有协议扩展
以便在在自己的代码中

00:01:18.378 --> 00:01:20.581 
执行应用不变性
并定义解决许多应用开发模板

00:01:23.050 --> 00:01:24.685 
我们先来看第一个话题

00:01:24.751 --> 00:01:27.087 
利用新API

00:01:28.589 --> 00:01:34.761 
这类话题已经讲了很多遍
很多人对此都很熟悉

00:01:35.429 --> 00:01:37.397 
对Apple而言 我们继续在

00:01:37.464 --> 00:01:42.836 
每个OS版本中推出丰富的API

00:01:43.270 --> 00:01:46.673 
让大家有机会在应用中构建不错的功能

00:01:47.174 --> 00:01:50.377 
对吗？
这是我们这么做的部分原因 不是吗？

00:01:51.211 --> 00:01:55.482 
这里的谜题是app具备已有用户 
对么？

00:01:55.549 --> 00:01:56.783 
他们目前...

00:01:57.618 --> 00:01:59.353 
他们不必使用最新的OS

00:01:59.419 --> 00:02:01.922 
在iOS 有较快的使用率

00:02:02.322 --> 00:02:05.225 
但是这不是说人人都会立刻采用

00:02:05.325 --> 00:02:08.529 
还有些人出于各种原因完全不会使用

00:02:09.463 --> 00:02:13.100 
那么你会面临一系列选择
你会怎么做呢？

00:02:14.568 --> 00:02:15.502 
你是否会继续

00:02:15.569 --> 00:02:18.572 
并要求app使用最新OS？

00:02:18.639 --> 00:02:22.242 
好 那你获得所有的新API 
可这的确成问题

00:02:22.309 --> 00:02:24.411 
因为你会搞砸

00:02:24.478 --> 00:02:25.612 
要知道 你会损失用户

00:02:25.679 --> 00:02:27.281 
这些是会购买你的app的人群

00:02:29.550 --> 00:02:32.085 
你是否应该走到相反的极端

00:02:32.152 --> 00:02:34.988 
控制使用新API？

00:02:35.055 --> 00:02:37.491 
这样就会获得所支持的

00:02:37.558 --> 00:02:39.359 
最早版本OS的最小公分母

00:02:39.593 --> 00:02:42.963 
这样做很糟糕因为你会影响到

00:02:43.030 --> 00:02:45.199 
原本可以向用户提供的丰富

00:02:45.265 --> 00:02:46.099 
功能

00:02:47.167 --> 00:02:49.570 
当然 要知道有鱼和熊掌兼得的办法

00:02:49.636 --> 00:02:54.308 
可以采用新API与此同时还

00:02:54.374 --> 00:02:55.843 
可以部署更早的版本

00:02:56.844 --> 00:03:00.380 
所以很长时间以来 我们在技术上

00:03:00.480 --> 00:03:01.582 
都支持这种做法

00:03:02.482 --> 00:03:05.219 
当然 可以在Objective-C
和Swift中均可如此

00:03:05.285 --> 00:03:08.155 
可是现实中 如今这是个非常

00:03:08.222 --> 00:03:09.590 
痛苦的体验

00:03:16.029 --> 00:03:19.700 
在Swift 2中 我们尽可能
不让它这么痛苦

00:03:19.766 --> 00:03:23.437 
我们通过开发人员告知的当前问题

00:03:23.670 --> 00:03:27.074 
关于部署较早版本

00:03:27.140 --> 00:03:29.109 
并设法解决语言中的问题

00:03:29.176 --> 00:03:30.410 
来实现这一点

00:03:32.412 --> 00:03:34.848 
现在基本模型并未改变 对吧？

00:03:34.915 --> 00:03:38.919 
对于开发而言在我们的平台上

00:03:38.986 --> 00:03:40.387 
一直希望大家使用最新SDK

00:03:40.754 --> 00:03:43.624 
对吗？这会导致应用中所有可能

00:03:43.690 --> 00:03:45.792 
用到的API都混到了

00:03:46.260 --> 00:03:47.160 
一起

00:03:47.928 --> 00:03:50.430 
然后 可以切换app的部署目标

00:03:50.497 --> 00:03:52.533 
说明你想要退回的时间

00:03:53.901 --> 00:03:55.569 
从画面来看这样就非常简单

00:03:55.669 --> 00:03:57.638 
就像是版本的滑动视窗

00:03:57.704 --> 00:03:59.506 
设置最新的基底SDK

00:03:59.907 --> 00:04:02.543 
把部署目标设置到视窗的

00:04:02.809 --> 00:04:04.011 
最早版本 对么？

00:04:04.545 --> 00:04:05.612 
从概念来讲 很简单

00:04:07.080 --> 00:04:11.752 
那么在谈到在Swift 2中 

00:04:11.818 --> 00:04:15.689 
如何采用新功能和API之前
我们先来看

00:04:15.756 --> 00:04:17.757 
现有方法中的问题

00:04:18.257 --> 00:04:21.827 
基本上而言 你必须编写app

00:04:21.894 --> 00:04:26.033 
以便应对更早版本的主OS中
API缺失的问题 对吗？

00:04:26.834 --> 00:04:30.504 
还有几个问题需要单独考虑

00:04:30.938 --> 00:04:33.707 
整个框架的缺失类方法 

00:04:33.774 --> 00:04:37.611 
函数 甚至部分枚举值

00:04:37.978 --> 00:04:39.112 
在更早的版本中不得使用

00:04:39.613 --> 00:04:42.349 
但是令人烦心的是你必须逐一

00:04:42.416 --> 00:04:44.451 
解释所有这些问题

00:04:45.185 --> 00:04:47.821 
对框架而言很是麻烦 要决定

00:04:47.888 --> 00:04:50.257 
我把它连接到应用时 这个

00:04:50.557 --> 00:04:52.392 
框架是可选项

00:04:52.860 --> 00:04:56.029 
如果不这样做app就会在启动

00:04:56.096 --> 00:04:57.564 
较早版本的OS时 出现问题

00:04:59.766 --> 00:05:02.703 
然后是API本身实际运用

00:05:02.769 --> 00:05:05.272 
我们先来看类

00:05:06.139 --> 00:05:08.275 
基本上来说你是在编写app

00:05:08.342 --> 00:05:09.943 
因此它会有不同表现

00:05:10.043 --> 00:05:11.645 
这将是有条件的行为

00:05:11.712 --> 00:05:15.282 
例如当新的API
可用app就会做些不同的事情

00:05:15.782 --> 00:05:18.051 
因此条件逻辑并不是问题

00:05:18.619 --> 00:05:21.788 
问题在于怎样为行为实现条件化

00:05:22.956 --> 00:05:25.192 
在这张幻灯片上是用来检测可用性的

00:05:25.259 --> 00:05:26.593 
典型方法

00:05:26.660 --> 00:05:28.929 
你来查询
Objective-C的运行时间

00:05:28.996 --> 00:05:32.132 
这个类会在运行时间出现么？

00:05:33.367 --> 00:05:35.636 
问题是这有点谎言的味道

00:05:35.936 --> 00:05:38.238 
对吗？我是说类可以有

00:05:38.705 --> 00:05:41.475 
但是这不意味着你可以使用

00:05:42.376 --> 00:05:47.214 
API会经常开始是内部API 

00:05:47.948 --> 00:05:49.283 
在OS中 

00:05:49.716 --> 00:05:52.786 
它们会在生成和演进的
地方呆上一阵在对外发布时

00:05:53.220 --> 00:05:55.923 
API的行为

00:05:56.290 --> 00:05:58.892 
可能已经完全改变

00:05:59.359 --> 00:06:01.628 
即便这样的检测在运行时间成功了

00:06:02.462 --> 00:06:04.431 
这也不能说明实际使用

00:06:04.498 --> 00:06:06.900 
这款API时会绝对安全

00:06:07.634 --> 00:06:13.674 
而是说 如果在OS版本上
你使用的时间太过于早 

00:06:14.141 --> 00:06:16.710 
基本上会在应用中加上定时炸弹

00:06:16.777 --> 00:06:21.949 
原本你以为API会按照一定方式
表现 现在会完全遭到破坏

00:06:22.115 --> 00:06:24.351 
这会令开发人员多次受到打击

00:06:24.985 --> 00:06:27.221 
因此是个严重问题

00:06:29.189 --> 00:06:31.992 
另一个问题是太容易出错

00:06:32.659 --> 00:06:34.127 
来看这个新款API

00:06:34.661 --> 00:06:36.730 
通过几项特色功能

00:06:36.930 --> 00:06:40.834 
我的代码完全有效结果却出了差错

00:06:41.435 --> 00:06:45.305 
数据在NS数据资产之前很久引入的

00:06:45.572 --> 00:06:48.342 
代码还会编译 若在最新的OS上检测

00:06:48.408 --> 00:06:50.143 
它甚至会成功运行

00:06:50.410 --> 00:06:53.580 
那么只是在更早版本的设备上

00:06:53.914 --> 00:06:55.516 
运行代码 才会出现问题

00:06:55.616 --> 00:06:58.986 
对吗？这与通常的测试场景完全不符

00:06:59.419 --> 00:07:01.255 
在部分情况下

00:07:01.321 --> 00:07:03.123 
只需要用户来发现这个问题

00:07:03.824 --> 00:07:07.528 
即将出现的情况是
当你试图使用这个类时运行时间会崩溃

00:07:09.897 --> 00:07:15.102 
很容易因为简单的小错出现问题

00:07:16.570 --> 00:07:20.174 
方法和类的问题基本一样

00:07:20.908 --> 00:07:22.910 
可能会出现输入错误

00:07:23.177 --> 00:07:25.045 
如果检测属性的可用性

00:07:25.112 --> 00:07:27.681 
你现在必须了解属性的选择器

00:07:27.748 --> 00:07:29.650 
同时还要拼写正确

00:07:29.750 --> 00:07:32.519 
此外语法也完全不同 对吗？

00:07:32.586 --> 00:07:34.888 
来检测API但是语法不一样

00:07:36.089 --> 00:07:37.724 
函数也有着同样问题

00:07:37.791 --> 00:07:39.626 
你会犯同样的错误不过可以有

00:07:39.693 --> 00:07:41.461 
其他方式来编写

00:07:42.196 --> 00:07:45.299 
那么 如果有枚举那你就被完全骗到了

00:07:45.365 --> 00:07:47.668 
你不知道 怎样的解决方案才合适

00:07:47.734 --> 00:07:50.237 
选择器对映射完全没有反应

00:07:50.637 --> 00:07:54.274 
那就要手动OS版本检测

00:07:54.708 --> 00:07:57.778 
来看这个表格感觉就像是你希望

00:07:57.845 --> 00:07:59.079 
改正的所有簿记问题

00:07:59.146 --> 00:08:00.447 
都在这里

00:08:01.248 --> 00:08:03.717 
这是个非常伤感的故事

00:08:07.254 --> 00:08:09.456 
现在我们看到的是的确成问题的

00:08:09.523 --> 00:08:10.390 
编程模型

00:08:10.457 --> 00:08:13.227 
对吗？技术上可行但是很难做到

00:08:13.694 --> 00:08:15.329 
我们希望你利用新款API

00:08:15.395 --> 00:08:18.465 
与此同时继续支持所有的用户

00:08:19.933 --> 00:08:22.569 
我们需要解决这些问题

00:08:25.005 --> 00:08:28.108 
在Swift 2中情况有所改变

00:08:28.175 --> 00:08:29.409 
把改变构建在语言当中

00:08:30.677 --> 00:08:34.615 
要以怎样架构app为主 那么

00:08:35.048 --> 00:08:37.150 
有其他方法可行时可以考虑

00:08:37.251 --> 00:08:38.684 
使用这些API

00:08:38.751 --> 00:08:40.953 
你理解 会有条件性行为

00:08:41.355 --> 00:08:42.890 
但是你会主要关注于此

00:08:43.957 --> 00:08:45.759 
然后有编译器作为支持

00:08:46.326 --> 00:08:49.897 
如果用不安全的方式使用API 
就会出现错误

00:08:51.064 --> 00:08:53.500 
还要有统一的句法这样就不必考虑

00:08:53.567 --> 00:08:56.436 
类 方法函数甚至映射问题

00:08:56.503 --> 00:09:00.073 
这些都在所用的句法中处理好了

00:09:00.140 --> 00:09:02.676 
编译器了解你该用的句法

00:09:02.743 --> 00:09:05.546 
如果你没有做对 它会告诉你正确做法

00:09:07.681 --> 00:09:11.151 
因为编译器会一直参与其中

00:09:11.218 --> 00:09:12.886 
在Swift中我们使用模型

00:09:13.420 --> 00:09:16.123 
所有可选链接可以帮你来处理

00:09:18.759 --> 00:09:22.362 
那么这样效果如何
这里是来自核心位置的部分API

00:09:24.498 --> 00:09:26.934 
比如说 我在部署iOS 9

00:09:27.201 --> 00:09:29.469 
因此使iOS 9 SDK

00:09:29.536 --> 00:09:31.505 
并设置iOS 9的部署目标

00:09:32.773 --> 00:09:35.542 
编译器可以在SDK中看到该信息

00:09:35.609 --> 00:09:37.411 
因此这是在
Objective-C头文件中

00:09:37.477 --> 00:09:39.947 
还可以作为
Swift中生成的界面来查看

00:09:40.614 --> 00:09:42.716 
因此类被引入iOS 2中

00:09:43.450 --> 00:09:45.686 
方法稍后会引入iOS 8

00:09:46.620 --> 00:09:48.121 
因为我在运行iOS 9

00:09:48.222 --> 00:09:50.457 
可以无条件使用这款API

00:09:51.558 --> 00:09:54.795 
如果我在iOS 8
部署也仍然没有问题

00:09:55.562 --> 00:09:58.165 
但是如果我一路退回iOS 7 

00:09:58.599 --> 00:10:01.034 
编译器可以看到
正如我们可以在幻灯片上看到

00:10:02.002 --> 00:10:04.438 
使用这种方法并不安全

00:10:04.505 --> 00:10:06.373 
需要请求使用授权

00:10:09.109 --> 00:10:13.380 
编译器会告诉你这是不安全代码

00:10:14.047 --> 00:10:15.415 
是错误

00:10:15.482 --> 00:10:18.218 
它会禁止你构建这个代码

00:10:19.186 --> 00:10:20.687 
并会提供不错的安全性检测

00:10:26.660 --> 00:10:29.363 
它会提供可以解决

00:10:29.997 --> 00:10:31.932 
这一问题的不同方法

00:10:33.100 --> 00:10:35.502 
这里有注解 你是否需要安全检测？

00:10:36.203 --> 00:10:38.839 
会有附上的解决办法 如果接受

00:10:39.273 --> 00:10:40.807 
代码就重写 像这样

00:10:42.142 --> 00:10:48.382 
现在有汇编组合静态执行

00:10:48.448 --> 00:10:49.716 
和运行时间执行

00:10:51.051 --> 00:10:54.121 
这就是散列可用句法

00:10:54.821 --> 00:10:58.725 
基本上 
编译器扫描可以看到代码块中的

00:10:59.092 --> 00:11:04.364 
所有内容最新的iOS 
OS X或安全执行这些API

00:11:04.431 --> 00:11:05.666 
所需的具体版本

00:11:06.099 --> 00:11:08.235 
是什么？

00:11:09.369 --> 00:11:12.372 
然后会使用在散列可用的

00:11:12.439 --> 00:11:15.042 
所提到版本进行适当的运行时间检测

00:11:15.108 --> 00:11:16.977 
编译器会把它插入其中

00:11:17.044 --> 00:11:19.346 
你不必猜测如何完成 会高效完成

00:11:19.680 --> 00:11:22.583 
并做缓存
这样就可以安全使用

00:11:23.517 --> 00:11:26.553 
在SDK中使用该信息

00:11:26.620 --> 00:11:30.324 
会实现高保真
因此会得到真正安全的模式

00:11:32.960 --> 00:11:34.228 
有些人会问

00:11:34.595 --> 00:11:37.231 
为什么要在OS版本中
进行检测呢

00:11:37.297 --> 00:11:39.666 
不是提供过对以往内容

00:11:39.733 --> 00:11:41.201 
所做的指南么？

00:11:41.935 --> 00:11:46.273 
原因是做簿记实在太难

00:11:46.673 --> 00:11:49.776 
至少当你查询运行时间时 

00:11:50.077 --> 00:11:53.013 
你会得到部分真相 但是在很多情况下
即便是真相也会有出入

00:11:54.915 --> 00:11:58.919 
逻辑上来讲 和app开发人员交谈

00:11:59.887 --> 00:12:02.489 
要知道 你希望构建在app上的体验

00:12:02.556 --> 00:12:04.424 
都发起在用户正在

00:12:04.491 --> 00:12:07.427 
运行的主OS上 对么？

00:12:07.995 --> 00:12:11.532 
在每个OS版本中都有一批新的API

00:12:12.599 --> 00:12:14.735 
这些基本上定义了你可以执行的

00:12:15.002 --> 00:12:18.539 
各种功能而用户在使用

00:12:18.605 --> 00:12:21.608 
不同版本的OS 因此 他们在逻辑上

00:12:21.675 --> 00:12:25.245 
打破了你的app所具备的

00:12:25.312 --> 00:12:27.414 
行为类别 对么？

00:12:27.481 --> 00:12:30.951 
所有这些在逻辑一致性上都有区别

00:12:32.052 --> 00:12:35.789 
同样 它也不会检测某款API的存在

00:12:36.156 --> 00:12:39.193 
因为你通常准备同时使用若干API

00:12:39.259 --> 00:12:41.128 
这其实说不过

00:12:41.195 --> 00:12:42.863 
某款API的存在并非表明其他

00:12:42.930 --> 00:12:44.565 
也会存在

00:12:44.932 --> 00:12:47.467 
信息位于SDK中编译器可以为你

00:12:47.534 --> 00:12:48.836 
完成簿记工作

00:12:49.770 --> 00:12:52.573 
编译器涉及到真正的规则改变者

00:12:53.140 --> 00:12:55.742 
它使得可用性检测非常可靠

00:12:56.310 --> 00:12:59.813 
可以假设编译器在做着正确的事情

00:13:00.047 --> 00:13:01.715 
你尽可放心是在

00:13:01.782 --> 00:13:05.018 
通过定义解决整类问题

00:13:05.085 --> 00:13:06.920 
因为你在用编译执行

00:13:09.256 --> 00:13:13.026 
而且自然会进入多个平台

00:13:13.827 --> 00:13:17.531 
比如 
我之前有这个NSData资产实例

00:13:18.098 --> 00:13:20.968 
如果
我想让代码以OS X和iOS为目标

00:13:21.435 --> 00:13:23.971 
我可以简单扩展句法称我也在

00:13:24.037 --> 00:13:26.540 
其他平台检测其最小可用性

00:13:27.574 --> 00:13:30.344 
星级表明基本上在所有其他情况下

00:13:30.410 --> 00:13:32.513 
在本例中应该是Watch OS

00:13:33.313 --> 00:13:34.781 
我们把它放在那里显性调用

00:13:34.848 --> 00:13:36.717 
潜在的流程控制

00:13:36.783 --> 00:13:39.953 
对于其他没有明显提及的平台

00:13:40.153 --> 00:13:42.489 
会执行指定条件

00:13:42.556 --> 00:13:45.158 
基本上是真和假

00:13:45.526 --> 00:13:47.828 
我们本想调用这些分支

00:13:47.895 --> 00:13:49.196 
它们仍将被采用

00:13:49.463 --> 00:13:51.031 
因此 我们想显性调用

00:13:51.098 --> 00:13:53.100 
可读性行为

00:13:54.668 --> 00:13:58.105 
现在可读性检测会在Swift 2中

00:13:58.172 --> 00:14:00.541 
自然构成用于控制流的可供性

00:14:01.375 --> 00:14:04.845 
比如 你之前已经构建了app 希望

00:14:04.912 --> 00:14:08.582 
进行这类检测 然后执行部分功能

00:14:08.849 --> 00:14:11.451 
否则什么都不做只要摆脱困境即可

00:14:12.653 --> 00:14:14.855 
这与新的保安声明相结合

00:14:16.223 --> 00:14:18.192 
可以像这样调整编码

00:14:18.559 --> 00:14:20.761 
保安声明下面的的所有内容

00:14:20.827 --> 00:14:22.529 
都有散列可用标签提供的

00:14:22.596 --> 00:14:23.830 
可用性

00:14:29.570 --> 00:14:33.340 
因此自然会找到方法

00:14:33.407 --> 00:14:34.975 
来构成应用的因素

00:14:36.944 --> 00:14:38.812 
比如 
你之前已经在iOS 7上做过部署

00:14:39.880 --> 00:14:43.517 
我会把iOS 7中
可用的API代码染成绿色

00:14:43.917 --> 00:14:47.087 
绿色条代表代码块中

00:14:47.154 --> 00:14:50.057 
可以安全使用iOS 7或更早版本

00:14:50.123 --> 00:14:51.525 
因此这基本上是编译器

00:14:52.059 --> 00:14:53.193 
对世界的看法

00:14:54.661 --> 00:14:57.197 
如果我想用iOS 8 API
我已经把它的代码

00:14:57.264 --> 00:14:59.700 
涂成橙色 
你需要对它进行可用性检测

00:14:59.766 --> 00:15:01.268 
否则 你会从编译器收到一个错误

00:15:01.902 --> 00:15:03.937 
你可以认为在代码块中

00:15:04.004 --> 00:15:05.706 
你有特权

00:15:05.772 --> 00:15:07.574 
决定什么API可以调用

00:15:09.176 --> 00:15:11.912 
一旦我出了代码块特权就不复存在

00:15:12.045 --> 00:15:14.114 
就只能调用iOS 7 API

00:15:15.148 --> 00:15:17.885 
如果我想调用iOS 9 API
我可以进行不同的检测

00:15:17.951 --> 00:15:20.254 
这会在代码块中提供不同范围的特权

00:15:20.320 --> 00:15:22.256 
它是极具可组合能力和可读性的模型

00:15:23.690 --> 00:15:25.692 
比如 我在根据

00:15:25.759 --> 00:15:29.162 
部分API是否可用构建

00:15:29.229 --> 00:15:31.532 
具备整套不同功能的app

00:15:32.099 --> 00:15:33.033 
我想对此进行分解

00:15:33.100 --> 00:15:36.270 
我不是只把一束代码加入条件语句

00:15:36.336 --> 00:15:38.305 
我希望把它分解放入不同的函数中

00:15:39.873 --> 00:15:40.841 
这很容易做到

00:15:41.375 --> 00:15:42.843 
可以声明另一个函数

00:15:42.910 --> 00:15:46.513 
比如出于教学目的
我的函数使用iOS 8

00:15:46.880 --> 00:15:50.450 
我准备从条件代码块中调用

00:15:51.652 --> 00:15:53.987 
问题在于编译器不知道

00:15:54.054 --> 00:15:55.122 
你要做什么要知道

00:15:55.189 --> 00:15:59.126 
只有完成检测才能调用这个

00:16:00.227 --> 00:16:02.196 
在默认状态下编译器会确认

00:16:02.763 --> 00:16:04.198 
你锁定iOS 7

00:16:04.264 --> 00:16:06.767 
我假设你在这个函数中 只使用

00:16:07.601 --> 00:16:08.468 
iOS 7 API

00:16:09.903 --> 00:16:13.173 
如果你想用iOS 8
API那么就要进行检测

00:16:14.842 --> 00:16:16.076 
这不太好 对吧？

00:16:16.143 --> 00:16:18.979 
这里并未提供方法来真正分析app

00:16:19.913 --> 00:16:21.615 
还会导致冗余检测

00:16:24.251 --> 00:16:26.119 
你可以告知编译器你的意图

00:16:27.621 --> 00:16:31.725 
这样SDK本身会有这些方法和类的

00:16:31.792 --> 00:16:33.360 
添加可用适应

00:16:33.427 --> 00:16:36.897 
称这是可以用于API的最小OS

00:16:36.964 --> 00:16:40.601 
在自己的代码上
也可以使用同样的注解

00:16:41.635 --> 00:16:44.805 
表示除非已经进行过适当的

00:16:44.872 --> 00:16:46.740 
可用性检测
否则不得调用该函数

00:16:47.608 --> 00:16:48.842 
一旦出现这种情况

00:16:50.177 --> 00:16:52.312 
编译器会以不同方式看待代码

00:16:53.814 --> 00:16:56.617 
然后可以完全删除检测

00:16:56.683 --> 00:17:00.287 
即额外的可用性检测
安全使用iOS 8 API

00:17:01.588 --> 00:17:02.656 
这可以组合使用

00:17:02.723 --> 00:17:05.192 
因为其他函数也有相似注解

00:17:05.259 --> 00:17:07.227 
如果函数有着相同的API特权 

00:17:07.294 --> 00:17:10.631 
可以直接调用它们

00:17:11.431 --> 00:17:14.601 
如果在进行可用性检测时

00:17:14.701 --> 00:17:16.737 
想通过更多特权调用API

00:17:17.771 --> 00:17:20.773 
那么这样很方便构成 很容易理解

00:17:20.840 --> 00:17:22.742 
代码的构成方法

00:17:25.212 --> 00:17:27.614 
如大家的预期这也适用于方法

00:17:27.814 --> 00:17:30.150 
这样可以标注类为可用

00:17:30.417 --> 00:17:32.586 
但是具体方法 也许不可用

00:17:34.154 --> 00:17:37.958 
如果需要 你可以在调用更可用的

00:17:38.025 --> 00:17:40.260 
具体方法前 举例说明该类

00:17:40.327 --> 00:17:41.195 
你需要进行检测

00:17:43.163 --> 00:17:46.300 
在要求最小的可用性时 如果想标识

00:17:46.366 --> 00:17:48.168 
整个类的话这样会奏效 

00:17:49.102 --> 00:17:52.639 
如果这样做 除非进行过可用性检测

00:17:52.706 --> 00:17:54.274 
否则甚至连举例说明类都不可能

00:17:55.042 --> 00:17:58.612 
那你会获得API可用性

00:17:58.879 --> 00:18:01.582 
完整的全部传递闭包

00:18:02.883 --> 00:18:05.652 
这会自然引发 可以使用的更多技巧

00:18:07.521 --> 00:18:14.494 
比如 
你已有较早版本中的自定义模糊视图 

00:18:15.362 --> 00:18:21.468 
Apple会推出
更具体的UI视图子类 

00:18:21.602 --> 00:18:22.836 
你想使用新版本

00:18:22.903 --> 00:18:25.806 
在主OS上使用它们

00:18:27.641 --> 00:18:30.377 
你想通过可用性保护实现这类

00:18:30.711 --> 00:18:34.715 
运行时间多态 那么如果你在

00:18:34.781 --> 00:18:38.151 
运行OS 要使用原生UI

00:18:38.585 --> 00:18:41.355 
否则就要使用自定义的

00:18:42.356 --> 00:18:43.790 
这样获得对象的客户端

00:18:43.857 --> 00:18:47.528 
并不需要在乎你运行的OS版本

00:18:47.861 --> 00:18:49.930 
到底是哪个

00:18:50.030 --> 00:18:52.666 
你已经完全提供了关注点的分离

00:18:54.001 --> 00:18:56.069 
当用到协议做同样的事情

00:18:56.136 --> 00:18:58.305 
效果会很好可提供不同的执行

00:18:58.372 --> 00:19:00.941 
可以有闭包不同的函数

00:19:01.275 --> 00:19:04.745 
可以实现完全不同的新方法分析代码

00:19:04.811 --> 00:19:06.346 
并获得你所期待的安全性

00:19:08.248 --> 00:19:10.651 
我们觉得可用性检测相当棒

00:19:11.251 --> 00:19:14.988 
我觉得它的确提供了具有凝结力

00:19:15.055 --> 00:19:20.460 
的安全方法来
使用新款API并部署到更早版本

00:19:21.195 --> 00:19:23.897 
统一的句法提供了真正安全的编程模型

00:19:24.665 --> 00:19:27.367 
但是更重要的是它提供了
正常分析app的方法

00:19:27.434 --> 00:19:28.635 
你可以阅读app

00:19:28.702 --> 00:19:31.572 
可以阅读代码并理解

00:19:31.638 --> 00:19:33.674 
可以期待不变性

00:19:34.441 --> 00:19:36.210 
我觉得这一点 非常强大

00:19:37.578 --> 00:19:39.413 
接下来我把讲台交给阿莱克斯

00:19:39.479 --> 00:19:42.449 
他来介绍使用
Swift强大类型系统的其他方法

00:19:42.516 --> 00:19:44.885 
以便在自己的应用中执行不变性

00:19:51.491 --> 00:19:52.392 
谢谢 泰德

00:19:52.459 --> 00:19:54.494 
大家好
我是阿莱克斯•米基科夫斯基

00:19:54.561 --> 00:19:56.063 
是Apple的示例编码员

00:19:56.797 --> 00:19:58.065 
在过去的一年半时间

00:19:58.498 --> 00:20:01.869 
我都在教开发人员如何用
Swift编写Cocoa app

00:20:03.036 --> 00:20:08.742 
我对于Swift
和Cocoa有着清晰的梦想

00:20:09.877 --> 00:20:13.046 
怎样才能让二者在一起实现安全的

00:20:13.113 --> 00:20:15.749 
编译时间 安全应用

00:20:17.150 --> 00:20:20.387 
今天我想介绍我已有部分想法 

00:20:20.787 --> 00:20:22.689 
并解释大家可以从中使用的

00:20:22.756 --> 00:20:24.958 
部分范例并把这些概念

00:20:25.025 --> 00:20:27.661 
运用到各自的应用当中

00:20:27.761 --> 00:20:30.197 
这样你也可以编译时间安全代码

00:20:31.431 --> 00:20:34.234 
现在我还没有告知大家 
但是在这些想法中

00:20:34.568 --> 00:20:36.770 
我还想到了独角兽

00:20:38.138 --> 00:20:40.007 
我开发了独角兽app来看一下

00:20:40.174 --> 00:20:45.312 
我设想的不同独角兽

00:20:47.014 --> 00:20:50.350 
首先 我想介绍我应用中的

00:20:51.018 --> 00:20:53.086 
Asset Catalog 标识符

00:20:53.153 --> 00:20:56.123 
每个人都在UIKit中用到它

00:20:57.457 --> 00:20:59.993 
我的独角兽浏览app相对简单

00:21:00.060 --> 00:21:04.398 
在Asset Catalog中
我已经加入3个独角兽图像

00:21:06.166 --> 00:21:09.136 
我现在想看看当我从
Asset Catalog生成图像

00:21:09.203 --> 00:21:12.406 
代码会是什么样

00:21:14.041 --> 00:21:15.776 
你会注意到

00:21:15.876 --> 00:21:18.312 
我在搭建的3个图像

00:21:18.812 --> 00:21:20.848 
每个图像我都向UIKit UI

00:21:20.914 --> 00:21:23.717 
图像API传递一个字符串

00:21:24.885 --> 00:21:30.190 
不知道Asset Catalog 
UIKit实际上提供了怎样的资产

00:21:30.257 --> 00:21:31.725 
所以我必须打开这些图像

00:21:31.792 --> 00:21:34.161 
才能在应用中使用它们

00:21:35.162 --> 00:21:36.463 
非常不巧

00:21:36.530 --> 00:21:40.701 
因为已在Asset Catalog
定义Asset Catalog标识

00:21:40.767 --> 00:21:44.304 
我不希望这里出现重复信息

00:21:45.405 --> 00:21:49.243 
此外 这里我只会使用3个图像

00:21:50.177 --> 00:21:53.580 
可是在整个应用中我会用到许许多多

00:21:54.314 --> 00:21:58.085 
问题是很难找到你的代码中

00:21:58.185 --> 00:21:59.920 
是否有输入错误幻灯片上是

00:21:59.987 --> 00:22:02.890 
这些错误会引发的反应

00:22:02.990 --> 00:22:05.325 
基于这些 
你可能会希望进行修改我明白

00:22:05.826 --> 00:22:10.297 
但是确实很难回去把它们都找出来

00:22:10.364 --> 00:22:12.432 
那么经典的解决方案应该是有个

00:22:12.499 --> 00:22:14.101 
全局常数

00:22:14.401 --> 00:22:16.970 
这样可以在应用的各个地方使用

00:22:17.037 --> 00:22:17.938 
同样的常数

00:22:19.206 --> 00:22:21.008 
如果使用正确那就可以把独角兽

00:22:21.074 --> 00:22:23.610 
图像按照你的想法再找回来

00:22:23.677 --> 00:22:25.579 
但还是要打开图像 因为编译器

00:22:25.913 --> 00:22:27.748 
不清楚框架也不知道

00:22:27.814 --> 00:22:29.049 
你是否会

00:22:29.149 --> 00:22:31.552 
提供有效的常数名称

00:22:32.119 --> 00:22:35.522 
此外 
可以提供随机的为API提供随机流

00:22:35.589 --> 00:22:40.060 
运行时间会出现致命错误

00:22:41.261 --> 00:22:44.298 
因为
NSUbiquity身份改变节点

00:22:44.364 --> 00:22:47.267 
通知还是字符串可以有效传递至

00:22:47.334 --> 00:22:49.469 
UI图像指定API

00:22:50.737 --> 00:22:52.840 
我们来看看怎样解决这个问题

00:22:54.174 --> 00:22:56.844 
我们要做的是严格的类型解决方案

00:22:56.910 --> 00:22:59.146 
我们在代码中将字符串传递到各处

00:22:59.746 --> 00:23:02.816 
我们希望的是强大的类型解决方案

00:23:04.551 --> 00:23:07.020 
希望可以将字符串映射到

00:23:07.087 --> 00:23:08.355 
新的类型

00:23:09.857 --> 00:23:13.026 
这会让我们编码解决

00:23:13.093 --> 00:23:15.529 
怎样搭建应用至

00:23:15.596 --> 00:23:17.064 
编辑器的信息

00:23:17.130 --> 00:23:20.434 
这样可以把非选择性UI图像

00:23:20.701 --> 00:23:21.702 
返回到代码的各处

00:23:23.203 --> 00:23:24.505 
解决方案就是

00:23:24.671 --> 00:23:28.141 
针对应用进行枚举

00:23:28.208 --> 00:23:30.544 
我们在应用中定义的枚举

00:23:31.545 --> 00:23:34.381 
如果来看之前定义的代码

00:23:35.449 --> 00:23:38.218 
我不希望代码是这幅样子

00:23:38.285 --> 00:23:42.789 
我想每次生成UI图像对象都传递枚举

00:23:42.856 --> 00:23:44.558 
这样我就不必

00:23:44.625 --> 00:23:48.095 
在代码中打开返回值

00:23:48.862 --> 00:23:50.397 
怎么实现呢？

00:23:51.665 --> 00:23:52.666 
首先我希望

00:23:52.733 --> 00:23:58.005 
定义UI图像的嵌套类型 以便在

00:23:58.071 --> 00:24:00.774 
枚举大小写
和Asset Catalog中

00:24:01.141 --> 00:24:03.544 
定义的字符串表达之间提供

00:24:03.610 --> 00:24:04.745 
映射

00:24:05.979 --> 00:24:09.416 
我们将之定义为嵌套类型

00:24:09.917 --> 00:24:12.853 
这样可以存储在Asset
Catalog的其他资产

00:24:13.120 --> 00:24:14.922 
也可以使用这种方法

00:24:16.123 --> 00:24:18.225 
一旦这么做就非常简单

00:24:18.292 --> 00:24:22.229 
我可以在枚举大小写和字符串表达之间

00:24:22.296 --> 00:24:23.664 
提供大小写映射

00:24:24.164 --> 00:24:26.900 
对所有其他的情况也可以这样

00:24:28.101 --> 00:24:31.905 
这种方法的真正好处在于

00:24:31.972 --> 00:24:34.908 
如果我不小心有输入错误 如果

00:24:34.975 --> 00:24:37.444 
我不小心从什么地方复制粘贴了字符串

00:24:37.744 --> 00:24:39.646 
出现了重复编译器就会

00:24:39.713 --> 00:24:42.282 
警告或者报错 告诉我

00:24:42.616 --> 00:24:47.955 
在枚举中出现了重复问题

00:24:49.156 --> 00:24:52.125 
编译器可以这样帮忙 实在太好了

00:24:52.926 --> 00:24:54.795 
现在我们已经定义了新类型

00:24:54.862 --> 00:24:58.265 
我所需要做的就是
返回再编写便利初始化函数

00:24:58.332 --> 00:25:01.201 
其中使用这个枚举而不是字符串

00:25:01.502 --> 00:25:04.171 
并将枚举的原始值转至UIKit

00:25:04.438 --> 00:25:07.941 
定义的UI图像命名初始化函数

00:25:09.409 --> 00:25:11.278 
如果我们回来再看代码

00:25:11.378 --> 00:25:16.049 
可以把独角兽放在所希望的任何地方

00:25:16.116 --> 00:25:19.419 
如果我们再来看像以前
那样出现输入错误会怎样

00:25:19.486 --> 00:25:22.789 
现在编译器可以告知出现了输入错误

00:25:22.990 --> 00:25:24.725 
因为我们已经把应用结构的

00:25:24.992 --> 00:25:27.794 
信息编入了代码之中

00:25:28.729 --> 00:25:31.265 
如果修复这个问题
编译器错误也不复存在

00:25:32.933 --> 00:25:35.002 
我们来谈谈这么做的好处

00:25:37.671 --> 00:25:41.308 
首先是我们的常数位于中心

00:25:41.642 --> 00:25:45.078 
如果将新的
图像加入Asset Catalog

00:25:45.145 --> 00:25:49.316 
我准确知道该在哪里添加图像常数

00:25:50.918 --> 00:25:53.053 
还有一个好处是这样做不会污染

00:25:53.120 --> 00:25:54.354 
全局命名空间

00:25:54.421 --> 00:25:58.525 
我可以有在Asset 
Catalog中定义的若干对象

00:25:58.592 --> 00:26:02.095 
可以在其中运用这个办法

00:26:03.530 --> 00:26:06.433 
最好的一点是 当构建UI图像对象时

00:26:06.500 --> 00:26:08.802 
在应用中可以只用这些

00:26:08.869 --> 00:26:11.071 
枚举情况中的一种

00:26:11.371 --> 00:26:13.340 
所以编译器可以帮你实现这点

00:26:13.707 --> 00:26:16.977 
现在你可以将非选择性图像返回到

00:26:17.044 --> 00:26:18.445 
代码中的任何地方 因此不必担心

00:26:18.512 --> 00:26:20.247 
强行打开的问题

00:26:20.547 --> 00:26:26.019 
这是我们在独角兽
浏览器app中所用的非常

00:26:26.086 --> 00:26:28.188 
独特的方式但我希望你们想想

00:26:28.255 --> 00:26:30.657 
怎样在自己的代码中使用枚举

00:26:30.724 --> 00:26:32.960 
以提供其他种类的富映射

00:26:33.961 --> 00:26:35.796 
你们可以不只是作为字符串使用

00:26:35.863 --> 00:26:37.898 
还可以使用整数甚至是选择器

00:26:38.265 --> 00:26:39.933 
有很多机会

00:26:40.000 --> 00:26:42.569 
在自己的代码中定义这些映射

00:26:44.404 --> 00:26:49.409 
现在来深入探讨枚举 但是我想

00:26:49.476 --> 00:26:52.446 
先说说联线标识符

00:26:52.513 --> 00:26:54.915 
因为在代码中始终要

00:26:54.982 --> 00:26:55.983 
使用到它

00:26:57.251 --> 00:27:00.320 
现在 我的想法越发强烈

00:27:00.387 --> 00:27:03.390 
我必须研制出一款app 
让我真正跟踪

00:27:03.824 --> 00:27:06.159 
独角兽 并在运行中下载它们

00:27:07.361 --> 00:27:09.162 
我有更复杂的应用

00:27:09.563 --> 00:27:12.032 
如果来看故事板

00:27:12.432 --> 00:27:13.901 
就会变得非常简单

00:27:14.568 --> 00:27:16.970 
我只有单独的视图控制器 可以

00:27:17.037 --> 00:27:18.739 
联线其他两个视图控制器

00:27:19.206 --> 00:27:23.544 
对于所有这些视图控制器而言

00:27:23.610 --> 00:27:25.312 
我定义了一个联线标识符

00:27:26.580 --> 00:27:29.550 
我需要看看当我们覆盖

00:27:29.616 --> 00:27:32.419 
联线准备来配置独角兽浏览器

00:27:32.486 --> 00:27:34.788 
视图将呈现的

00:27:34.922 --> 00:27:37.724 
视图控制器时 代码会是什么样

00:27:40.327 --> 00:27:43.197 
我们覆盖了这种方法 执行这一点的

00:27:43.263 --> 00:27:45.365 
经典办法是打开

00:27:45.432 --> 00:27:48.502 
联线标识符字符串

00:27:49.369 --> 00:27:53.674 
现在 在我使用完全相同的字符串之前

00:27:53.740 --> 00:27:56.810 
我是按照故事板中的联线定义的字符串

00:27:57.344 --> 00:27:59.179 
编辑器对此还一无所知

00:27:59.513 --> 00:28:02.316 
当我只打开这两个字符串时

00:28:02.482 --> 00:28:03.784 
编译器会告诉我

00:28:04.418 --> 00:28:07.454 
这并非是穷尽性检测

00:28:07.521 --> 00:28:10.891 
我必须加入默认情况
因为编译器不知道

00:28:11.558 --> 00:28:14.461 
我已经提供了有效映射

00:28:15.863 --> 00:28:18.332 
但是如果我加入了新的视图控制器

00:28:19.166 --> 00:28:22.369 
必须有个全新的联线 那会怎样？

00:28:22.870 --> 00:28:24.271 
我怎么才能知道在代码中

00:28:24.338 --> 00:28:25.939 
哪里需要改变 这个逻辑？

00:28:27.241 --> 00:28:29.810 
我们来看看再次通过枚举

00:28:29.877 --> 00:28:31.912 
该怎么解决这个问题

00:28:33.280 --> 00:28:36.917 
我定义了独角兽浏览器
视图控制器的嵌套类型

00:28:36.984 --> 00:28:38.485 
它将代表联线标识符的情况

00:28:38.552 --> 00:28:41.021 
和故事板字符串表达

00:28:41.321 --> 00:28:44.825 
之间的映射

00:28:45.459 --> 00:28:48.595 
我们来看 怎么实现用更强大的类型

00:28:48.662 --> 00:28:51.932 
联线方法准备

00:28:53.600 --> 00:28:54.801 
首先 我要做的是

00:28:54.868 --> 00:28:57.337 
从故事板联线对象抓取联线

00:28:57.404 --> 00:28:59.139 
标识符字符串

00:29:00.240 --> 00:29:02.476 
并从原始值中构建联线

00:29:02.543 --> 00:29:03.677 
识别符枚举

00:29:05.412 --> 00:29:07.181 
我还会提供部分运行时间

00:29:07.247 --> 00:29:09.883 
检测调试以防我并未

00:29:09.950 --> 00:29:13.353 
为新的联线识别符 提供有效的

00:29:13.420 --> 00:29:15.355 
枚举情况

00:29:16.290 --> 00:29:19.660 
从这里 
我可以打开枚举 而不是字符串

00:29:20.394 --> 00:29:23.564 
这非常棒 因为我必须打开

00:29:23.630 --> 00:29:27.835 
两种情况 编译器知道我在枚举中

00:29:27.901 --> 00:29:31.605 
只定义了两种情况
所以我必须在代码中打开

00:29:33.807 --> 00:29:37.711 
如果我们在枚举中
添加了新的联线标识符

00:29:38.579 --> 00:29:40.747 
编译器就会告知 我们并未

00:29:41.114 --> 00:29:45.853 
进行穷尽性转换以便我们在枚举中

00:29:45.919 --> 00:29:49.122 
打开的代码各处

00:29:49.590 --> 00:29:51.291 
编译器就会告诉我们

00:29:51.358 --> 00:29:52.826 
在哪里更新逻辑

00:29:53.327 --> 00:29:56.763 
这对字符串解决方案来说
是个极大的好处

00:29:58.665 --> 00:30:01.602 
我们可以这样重写联线准备

00:30:02.202 --> 00:30:05.305 
但是 有时需要通过标识符 

00:30:05.372 --> 00:30:06.740 
人工启动执行联线

00:30:08.242 --> 00:30:11.144 
在本例中 我想要引入一束独角兽

00:30:11.211 --> 00:30:14.214 
下载它们在Web上 下载图像

00:30:14.281 --> 00:30:15.916 
显示新的视图控制器

00:30:16.383 --> 00:30:18.485 
我们来看看 这些代码是什么样子

00:30:20.254 --> 00:30:23.690 
那么经典的解决方案是将字符串

00:30:23.757 --> 00:30:26.326 
传递至带有标识符方式的执行联线

00:30:27.694 --> 00:30:29.563 
我们已经定义了这种枚举

00:30:29.630 --> 00:30:30.964 
我们只是想使用已经提供的

00:30:31.031 --> 00:30:32.099 
这种映射

00:30:32.666 --> 00:30:34.368 
相反 我们想用枚举

00:30:35.769 --> 00:30:36.603 
怎么做呢？

00:30:36.670 --> 00:30:38.205 
其实 非常简单

00:30:38.272 --> 00:30:43.777 
我们可以通过标识符方法定义
UIKit定义执行联线

00:30:44.111 --> 00:30:46.613 
的过载其中采用了枚举
而不是字符串

00:30:47.381 --> 00:30:53.220 
然后用枚举的原始值
调用UIKit 定义方法

00:30:53.854 --> 00:30:58.025 
如果我们返回用枚举调用

00:30:58.825 --> 00:31:02.196 
方法的代码
它完全是按照我们的预期运转

00:31:03.130 --> 00:31:05.232 
这就是针对独角兽浏览器视图

00:31:05.299 --> 00:31:07.000 
控制器的绝佳解决方案

00:31:07.935 --> 00:31:09.870 
但是如果再复杂一点会怎样？

00:31:11.171 --> 00:31:13.807 
我希望看看我们刚才做的结构

00:31:13.874 --> 00:31:15.542 
看怎样才能把它应用到

00:31:15.609 --> 00:31:17.911 
独角兽浏览器以外的视图控制器

00:31:20.314 --> 00:31:22.549 
我们做的是在枚举情况

00:31:22.616 --> 00:31:25.452 
及其故事板上的字符串表达之间

00:31:25.519 --> 00:31:26.453 
提供映射

00:31:27.387 --> 00:31:30.123 
我们还增加了使用该映射的

00:31:30.257 --> 00:31:33.093 
执行 以便获得应用中

00:31:33.160 --> 00:31:36.930 
更强大的类型系统

00:31:37.831 --> 00:31:39.299 
但如果我们增添新的视图控制器

00:31:39.366 --> 00:31:40.801 
我们希望做同样的事情

00:31:40.968 --> 00:31:45.339 
需要不得不复制
所有那些工作我不希望这么做

00:31:46.840 --> 00:31:50.944 
我真正想做的是从视图控制器提取

00:31:51.211 --> 00:31:54.982 
执行 并定义松散映射
因为联线标识符的枚举

00:31:55.048 --> 00:31:59.253 
会具体针对视图控制器

00:31:59.319 --> 00:32:03.090 
通过这样做 我们可以为多种

00:32:03.156 --> 00:32:05.058 
视图控制器使用该执行

00:32:05.526 --> 00:32:09.830 
不论其类层次如何

00:32:09.897 --> 00:32:12.299 
通过重复使用这个执行
可以避免许多

00:32:13.100 --> 00:32:15.769 
糟糕的类层次

00:32:17.004 --> 00:32:20.007 
我们会通过协议 来实现这一点

00:32:20.974 --> 00:32:22.409 
所以我定义了一个新的协议

00:32:22.476 --> 00:32:24.211 
我们会称之为联线处理类型

00:32:24.745 --> 00:32:26.280 
我们的视图控制器需要与它

00:32:26.346 --> 00:32:27.181 
相一致

00:32:28.515 --> 00:32:31.518 
我希望定义刚提到的映射

00:32:32.085 --> 00:32:34.521 
现在它将成为联线标识符枚举

00:32:35.389 --> 00:32:38.325 
我们希望确保联线标识符和

00:32:38.392 --> 00:32:40.327 
原始可显示协议相一致

00:32:41.261 --> 00:32:44.831 
这个协议是个关于各类型支持的

00:32:44.898 --> 00:32:48.535 
枚举的重要执行细节

00:32:49.369 --> 00:32:52.539 
编译器可以自动为你合成

00:32:53.841 --> 00:32:56.543 
关于协议定义就是这些

00:32:57.711 --> 00:33:00.714 
我现在
需要用Swift 2.0的功能

00:33:00.781 --> 00:33:02.482 
受限制的协议扩展

00:33:02.916 --> 00:33:04.818 
来实际添加将成为我们的

00:33:05.018 --> 00:33:06.920 
泛性可重用代码的执行

00:33:07.821 --> 00:33:10.657 
我们将扩展联线处理类型

00:33:11.325 --> 00:33:12.693 
接下来我们对之加以限制

00:33:12.759 --> 00:33:15.195 
如果这些限制条件满足的话 
我们只想让执行

00:33:16.830 --> 00:33:18.799 
加入其中

00:33:19.533 --> 00:33:23.070 
第一个限制条件是满足协议的类型为

00:33:23.136 --> 00:33:26.139 
UI视图控制器子类

00:33:26.540 --> 00:33:27.841 
这将会让我们在协议扩展中

00:33:27.908 --> 00:33:30.010 
调用UI视图

00:33:30.544 --> 00:33:31.812 
控制器方法

00:33:33.013 --> 00:33:35.115 
第二点是我们想确定

00:33:35.182 --> 00:33:38.051 
联线标识符映射是位于

00:33:38.118 --> 00:33:40.821 
映射情况和字符串之间

00:33:42.689 --> 00:33:45.425 
我们已经定义了
有限制条件的协议扩展

00:33:45.492 --> 00:33:47.494 
我们所需要做的就是添加执行

00:33:48.195 --> 00:33:51.198 
我们要通过之前定义的标识符 

00:33:51.265 --> 00:33:55.002 
采用联线现有执行 

00:33:55.602 --> 00:33:58.872 
并将完全相同的执行加入代码

00:34:00.807 --> 00:34:03.277 
如果我们返回
独角兽浏览器视图控制器

00:34:03.710 --> 00:34:06.947 
我们只需在新类型中加入一致性

00:34:08.014 --> 00:34:11.217 
我们已经满足了协议的所有
相关类型限制条件

00:34:11.318 --> 00:34:15.155 
因为我们已经识别了这个联线

00:34:15.222 --> 00:34:16.056 
标识符枚举

00:34:17.591 --> 00:34:21.360 
如果我们进入处理行为方法 我们可以

00:34:21.428 --> 00:34:26.166 
用完全相同的方式调用代码 
但我们在联线处理类型中重用执行

00:34:27.568 --> 00:34:29.770 
我们可以这样通过标识符方式

00:34:29.837 --> 00:34:35.007 
重用表现联线
但是要是调用联线准备

00:34:35.242 --> 00:34:36.510 
或联线处理准备会怎样？

00:34:37.811 --> 00:34:40.547 
我需要定义便捷方式

00:34:40.614 --> 00:34:42.882 
其中会采用故事板对象

00:34:43.350 --> 00:34:46.520 
并返回联线标识符枚举

00:34:46.587 --> 00:34:47.855 
这是在协议扩展中完成

00:34:49.188 --> 00:34:53.092 
我要再次做的是使用之前定义的执行

00:34:55.295 --> 00:34:56.964 
返回我们用代码

00:34:57.030 --> 00:34:59.867 
生成的联线标识符枚举

00:35:00.901 --> 00:35:03.070 
如果来看为联线方式所做准备

00:35:03.136 --> 00:35:05.739 
结果就变得非常简单

00:35:06.807 --> 00:35:10.043 
我们所需要做的就是通过联线的

00:35:10.110 --> 00:35:13.514 
联线识别符 打开结果返回
这是我们刚定义的方法我们只需要提供

00:35:14.248 --> 00:35:19.086 
两种情况打开方法和之前的完全相同

00:35:19.987 --> 00:35:21.355 
但是我们有这个泛型解决方案

00:35:22.489 --> 00:35:24.558 
我们来谈谈这么做的好处

00:35:27.094 --> 00:35:31.965 
当我们将之添加到 
联线标识符枚举中时

00:35:32.165 --> 00:35:34.201 
编译器完全了解我们在故事板上

00:35:34.268 --> 00:35:36.069 
定义的联线

00:35:37.137 --> 00:35:38.705 
可以确保我们在代码中

00:35:38.772 --> 00:35:40.541 
处理了所有可能的情况

00:35:41.808 --> 00:35:46.113 
通过使用协议扩展
我们具有可重新使用的解决方案

00:35:46.180 --> 00:35:49.516 
我们可以在符合
新协议的任何视图

00:35:49.583 --> 00:35:51.084 
控制器上使用这个执行

00:35:52.519 --> 00:35:54.521 
我们还有便捷句法

00:35:54.922 --> 00:35:57.958 
可以在不同的

00:35:59.826 --> 00:36:01.128 
视图控制器上使用方法句法

00:36:01.195 --> 00:36:02.796 
不一定必须是 自由函数

00:36:04.064 --> 00:36:07.601 
这是在独角兽浏览器app中
可以使用协议和

00:36:07.668 --> 00:36:10.771 
有限制方式的协议扩展的 

00:36:11.104 --> 00:36:13.574 
独特方式但是大家都有
许多其他有趣应用

00:36:13.941 --> 00:36:14.908 
我想让大家做的是思考一下

00:36:14.975 --> 00:36:18.846 
怎样在自己的应用中使用协议和

00:36:19.112 --> 00:36:22.516 
相关类型限制条件来编码部分

00:36:22.583 --> 00:36:25.552 
应用的结构到编译器这样它可以帮你

00:36:26.019 --> 00:36:27.387 
实现编译时间安全性

00:36:28.488 --> 00:36:30.524 
我想让你们想想

00:36:30.591 --> 00:36:32.259 
怎样使用协议扩展

00:36:32.593 --> 00:36:35.462 
在自己的应用中分享执行

00:36:35.863 --> 00:36:39.066 
避免一系列糟糕的类层次问题

00:36:41.201 --> 00:36:45.272 
泰德和我今天说得够多了
但是希望大家从中领会到

00:36:45.339 --> 00:36:47.140 
编译器是来帮助大家的

00:36:49.142 --> 00:36:52.946 
泰德说的是如何在新API中
安全利用这一点

00:36:53.280 --> 00:36:55.649 
现在 这可以通过编译器大部分完成

00:36:56.316 --> 00:36:59.586 
编译器知道有什么这不是具体针对

00:36:59.987 --> 00:37:01.522 
哪个OS的版本

00:37:02.856 --> 00:37:05.926 
我和大家介绍的是应用的强大类型

00:37:05.993 --> 00:37:07.761 
强迫应用实现不变性

00:37:08.028 --> 00:37:09.396 
并利用编译器

00:37:09.730 --> 00:37:11.698 
让它知道应用的限制条件

00:37:11.765 --> 00:37:15.002 
并把这些信息编入代码

00:37:15.435 --> 00:37:17.971 
这样编译器可以帮你分析

00:37:18.038 --> 00:37:20.340 
编译时间的问题而不是在运行时间

00:37:21.875 --> 00:37:23.143 
若要了解更多详情

00:37:23.210 --> 00:37:29.149 
建议大家在线观看
《基于协议的Swift编程》

00:37:29.983 --> 00:37:33.620 
讲座 如果你自己对
Cocoa和Swift

00:37:33.687 --> 00:37:35.789 
有明晰的梦想建议你仔细看看
这两个示例

00:37:35.856 --> 00:37:40.093 
编目示例有联线
处理类型协议的实例

00:37:40.394 --> 00:37:41.562 
DemoBots使用了

00:37:41.628 --> 00:37:45.866 
在协议中使用
枚举的一系列有趣方法

00:37:47.100 --> 00:37:48.402 
实现编译时间安全性

00:37:49.269 --> 00:37:51.138 
若要了解更多详情可以查看

00:37:51.205 --> 00:37:53.006 
Swift Language
Documentation

00:37:53.073 --> 00:37:55.676 
我们还有开发人员论坛如有任何问题 

00:37:55.742 --> 00:37:56.877 
你们也可以联系斯特凡

00:37:57.211 --> 00:38:00.013 
感谢大家希望能在实验室见到大家