00:00:20.521 --> 00:00:23.857 
SpriteKit 新功能 

00:00:29.663 --> 00:00:32.332 
大家好歡迎來到“SpriteKit
新功能 ”講座

00:00:32.900 --> 00:00:35.536 
今天 我們將要告訴大家一系列很棒的

00:00:35.602 --> 00:00:36.470 
新功能和改進

00:00:37.171 --> 00:00:40.908 
我知道在座的各位中有很多人
是第一次來聽SpriteKit講座

00:00:40.974 --> 00:00:43.143 
首先 我想要花幾分鐘來

00:00:43.544 --> 00:00:45.679 
回顧我們所要講的是什麼

00:00:48.849 --> 00:00:52.986 
SpriteKit是蘋果2D遊戲
和圖形的框架

00:00:53.420 --> 00:00:56.290 
我們將給你提供集成的物理運動 

00:00:56.924 --> 00:00:58.825 
離子運動模擬 動作

00:00:58.892 --> 00:01:00.727 
以及動畫 當然 還有計算機子圖

00:01:01.695 --> 00:01:06.133 
我們啓動（這個項目）是想要將
SpriteKit做得不僅僅是強大

00:01:06.400 --> 00:01:08.769 
而且要非常容易上手使用

00:01:09.002 --> 00:01:12.472 
我們希望一個之前
完全沒有做過遊戲的人

00:01:13.040 --> 00:01:14.641 
能夠來到我們的平臺

00:01:14.975 --> 00:01:16.343 
開始使用SpriteKit

00:01:16.410 --> 00:01:17.911 
並且能夠花很少的時間得到提高
並熟悉（SpriteKit）

00:01:18.679 --> 00:01:20.881 
我們非常期望能夠傳達出一些東西

00:01:20.948 --> 00:01:23.217 
能夠使你專心致志地做你最擅長的事情

00:01:23.283 --> 00:01:25.319 
那就是做出最棒的遊戲

00:01:28.021 --> 00:01:29.857 
我們將SpriteKit設計成

00:01:29.923 --> 00:01:32.559 
可以在iPhone、
iPad以及Mac上工作

00:01:33.093 --> 00:01:35.863 
並且
你也能夠通過這個平臺將你的app

00:01:35.929 --> 00:01:38.599 
應用到多個平臺上
這也就意味着

00:01:38.665 --> 00:01:40.300 
你能夠
直接在Mac上設計原型

00:01:40.367 --> 00:01:42.402 
並測試你的SpriteKit遊戲

00:01:42.669 --> 00:01:44.538 
在你將它（遊戲）安裝到
一個設備上之前

00:01:47.574 --> 00:01:50.611 
可以說 有了SpriteKit 
遊戲構架的開發能夠做到事半功倍

00:01:51.211 --> 00:01:54.615 
在剛開始的時候我們花費了
大量的精力在我們的工具上

00:01:54.781 --> 00:01:57.451 
在後續的幾年裏我們
也在持續地進行投資

00:01:57.885 --> 00:01:59.186 
就是爲了能夠

00:01:59.286 --> 00:02:01.188 
讓你能夠像編輯整個畫面
一樣編輯粒子效果

00:02:01.622 --> 00:02:03.524 
直到今年年初也同樣

00:02:03.590 --> 00:02:06.326 
能夠對運動和動畫進行編輯

00:02:06.393 --> 00:02:08.095 
只需要在寫代碼前

00:02:08.161 --> 00:02:10.997 
加入一段Xcode即可

00:02:13.867 --> 00:02:15.969 
現在 我們可以開始講解
這個構架有哪些新功能了

00:02:17.037 --> 00:02:19.573 
第一點 也是開發人員強烈要求的一點

00:02:20.240 --> 00:02:22.609 
就是視窗

00:02:22.676 --> 00:02:25.279 
視窗是指

00:02:25.345 --> 00:02:27.981 
當我們在討論你的場景的時候
這部分（場景）是可見的

00:02:28.048 --> 00:02:29.850 
在任何時候
通過SpriteKit視角

00:02:31.351 --> 00:02:34.321 
現在的這種工作方式是
如果你想要移動你的鏡頭

00:02:34.821 --> 00:02:38.358 
你不得不移動
你遊戲中的每一塊幾何圖案

00:02:38.425 --> 00:02:40.994 
或者
如果你想要跟隨你的一個英雄人物

00:02:41.061 --> 00:02:42.829 
穿越你的整個遊戲界面

00:02:43.197 --> 00:02:44.765 
你就需要做這些計算

00:02:45.399 --> 00:02:46.633 
現在這樣的工作

00:02:46.700 --> 00:02:48.368 
但是它並不像我們想象中的那樣直觀

00:02:49.303 --> 00:02:51.605 
如果你想要對這些遊戲實體進行物理模
擬 

00:02:51.672 --> 00:02:54.741 
當你移動他們的實際位置時

00:02:54.808 --> 00:02:57.077 
你可以從中看到一些僞影

00:02:59.046 --> 00:03:00.914 
我們認爲我們能夠做的更好

00:03:01.982 --> 00:03:04.084 
接下來我們介紹
SKCameraNode.

00:03:05.485 --> 00:03:07.020 
通過CameraNode

00:03:07.087 --> 00:03:10.524 
我們允許你能夠簡單的指定你看到的部
分

00:03:10.591 --> 00:03:13.393 
變得可視化 鏡頭通過

00:03:13.460 --> 00:03:14.561 
展現你的場景中所包含的

00:03:14.628 --> 00:03:16.029 
可視化中心來達到這樣的效果

00:03:16.630 --> 00:03:18.332 
這樣你就可以在你的畫面中任意移動

00:03:18.398 --> 00:03:19.800 
CameraNode

00:03:20.234 --> 00:03:22.035 
同樣的
你也可以在你的畫面中移動其他的

00:03:22.102 --> 00:03:23.804 
所有的遊戲實體

00:03:24.705 --> 00:03:26.673 
我們在SKScene中
設置了一個屬性

00:03:26.740 --> 00:03:29.142 
這個屬性將允許你選擇
你想使用的包含這些場景的鏡頭

00:03:29.209 --> 00:03:31.812 
在你的場景中你可以選擇多個鏡頭

00:03:32.112 --> 00:03:34.581 
同樣你也可以通過屬性選擇活動的鏡頭

00:03:35.983 --> 00:03:38.685 
如果你不理會屬性 即其缺省值爲零

00:03:39.152 --> 00:03:41.388 
我們將會保存所有你今天的使用記錄

00:03:41.455 --> 00:03:43.390 
並且所有的
SpriteKit渲染效果

00:03:43.457 --> 00:03:44.625 
都和從前一樣不會改變

00:03:45.792 --> 00:03:48.862 
但是SKCameraNode
中最棒的功能是

00:03:49.997 --> 00:03:50.898 
它作爲一個節點存在

00:03:51.632 --> 00:03:54.301 
這就意味着你能夠
使用SpriteKit節點中

00:03:54.368 --> 00:03:55.435 
所有偉大的功能

00:03:55.702 --> 00:03:57.771 
你可以訪問我們的動作數據庫

00:03:57.838 --> 00:04:00.073 
這樣你就能夠在
鏡頭上運行這樣的動作（數據）

00:04:00.140 --> 00:04:02.009 
你也可以使用我們的約束系統

00:04:02.075 --> 00:04:03.877 
這樣你就能夠對鏡頭進行約束

00:04:04.244 --> 00:04:06.280 
你可以讓它與遊戲實體相結合

00:04:06.346 --> 00:04:08.715 
你也可以讓它總是保留在

00:04:08.782 --> 00:04:10.184 
距離你遊戲中物體的一定範圍內

00:04:10.617 --> 00:04:13.587 
除了移動鏡頭之外
你還能夠通過這些節點的屬性

00:04:13.654 --> 00:04:16.055 
來控制旋轉和尺度

00:04:17.291 --> 00:04:18.392 
例如

00:04:18.458 --> 00:04:20.560 
在這樣一個遊戲中 

00:04:20.627 --> 00:04:22.729 
我想將鏡頭放到一
旁

00:04:22.796 --> 00:04:24.698 
我可能應用一些移動動畫

00:04:24.765 --> 00:04:26.500 
來揭示我的視線中有壞人

00:04:26.567 --> 00:04:28.435 
在我將我的遊戲角色
放在視線中央之前

00:04:28.936 --> 00:04:31.104 
之後我可以應用一些尺度命令 

00:04:31.171 --> 00:04:32.506 
來實現鏡頭的變焦操作

00:04:33.440 --> 00:04:35.943 
我甚至可以使用我們的跟蹤路徑運動

00:04:36.009 --> 00:04:37.744 
如果我想要鏡頭跟蹤一個貝塞爾曲線

00:04:38.645 --> 00:04:40.547 
如果我真的非常想讓我的用戶感到噁心

00:04:40.614 --> 00:04:41.748 
我可以旋轉鏡頭

00:04:41.815 --> 00:04:43.450 
或者將鏡頭在場景中到處扔來扔去

00:04:43.750 --> 00:04:46.620 
所以現在在SpriteKit中
你完全可以控制你的遊戲

00:04:46.687 --> 00:04:48.822 
哪些部分是可見的

00:04:49.122 --> 00:04:51.425 
我認爲這將會是
你的工具中的一件很棒的新品

00:04:57.731 --> 00:04:59.266 
對鏡頭的改進

00:04:59.333 --> 00:05:01.001 
同樣的我們也針對音頻做了很多工作

00:05:01.502 --> 00:05:03.804 
我們添加了一個
SKAudioNode

00:05:03.871 --> 00:05:05.873 
允許你在你的SpriteKit
遊戲中

00:05:06.039 --> 00:05:07.975 
添加位置和環境的背景音

00:05:13.113 --> 00:05:16.316 
我們藉助了我們去年
發佈的Apple強大的

00:05:16.383 --> 00:05:18.118 
AV音頻引擎構架

00:05:18.519 --> 00:05:19.853 
如果你對這個並不熟悉

00:05:19.920 --> 00:05:22.322 
它允許你指定你的語氣音量

00:05:22.723 --> 00:05:24.892 
並能夠作爲特定環境中的聲音發射器

00:05:25.259 --> 00:05:27.828 
它可以回放你制定位置

00:05:27.895 --> 00:05:29.563 
偵聽器獲得的聲音

00:05:30.697 --> 00:05:33.600 
在SpriteKit中我們將爲
你做好所有的畫線工作

00:05:34.368 --> 00:05:37.571 
所有你需要做的工作就是
通過文件名或者URL指定

00:05:37.638 --> 00:05:40.707 
你想要播放的背景音樂

00:05:41.141 --> 00:05:44.444 
我們將會使用AudioNodes 

00:05:44.511 --> 00:05:46.747 
跟隨你指定的偵聽器的位置
在你的場景中定位

00:05:46.813 --> 00:05:50.617 
並畫出音頻曲線 讓你能夠更容易地

00:05:50.884 --> 00:05:53.086 
身臨其境地在遊戲中定位你的音頻

00:05:53.954 --> 00:05:56.557 
如果你想深入一點 親自動手

00:05:56.990 --> 00:06:00.093 
你也可以通過
底層AVAudioNode的

00:06:00.427 --> 00:06:02.796 
一個節點的屬性 去掉所有的約束

00:06:02.863 --> 00:06:04.264 
在那裏設置所有的你想要的東西

00:06:05.966 --> 00:06:07.668 
爲了掩飾這種效果

00:06:07.734 --> 00:06:09.570 
你能夠使用

00:06:09.670 --> 00:06:12.639 
最新的技術將其添加
到你的SpriteKit遊戲中

00:06:12.840 --> 00:06:14.441 
現在我又一個例子

00:06:14.775 --> 00:06:16.009 
這裏是我的製作的一個地精

00:06:16.076 --> 00:06:17.911 
我打算讓他作爲我的聽衆

00:06:18.178 --> 00:06:20.047 
所以我把我的偵聽器位置放在這裏

00:06:21.081 --> 00:06:23.050 
我已經在我的場景中添加了一個火球

00:06:23.283 --> 00:06:24.685 
這是我的音頻資源

00:06:24.751 --> 00:06:27.020 
在這裏我已經將其作爲一個
SKAudioNode添加了進來

00:06:27.287 --> 00:06:29.389 
我重新播放這個音樂的時候

00:06:29.456 --> 00:06:31.358 
注意聽這個音頻的效果怎麼樣

00:06:31.425 --> 00:06:33.360 
當火球在整個場景中來回運動的時候

00:06:33.427 --> 00:06:34.795 
你能夠注意到

00:06:34.862 --> 00:06:37.397 
它變得更加飽滿 更加集中 聲音也更
大了

00:06:37.464 --> 00:06:39.166 
當它靠近我們的偵聽器時

00:06:39.233 --> 00:06:41.502 
從遠到近

00:06:41.568 --> 00:06:44.304 
直到來到場景這一邊
現在我們聽一下

00:06:59.820 --> 00:07:00.988 
很酷 不是嗎？

00:07:05.726 --> 00:07:07.327 
除了這些額外的設置

00:07:07.394 --> 00:07:09.630 
我不需要做任何事情來處理這些特效

00:07:09.696 --> 00:07:11.698 
當他們在遊戲場景中運動的時候
他們已經和

00:07:12.065 --> 00:07:14.001 
驅動遊戲運行的邏輯聯繫在了一起

00:07:16.403 --> 00:07:20.774 
同樣的
今年我們也重點關注了引用和實例化

00:07:21.208 --> 00:07:25.512 
我們知道你花了很多時間
爲你的遊戲設計

00:07:25.746 --> 00:07:29.983 
內容和動畫 我們也希望你能夠在

00:07:30.050 --> 00:07:33.320 
任何你想用的地方重新使用這些內容

00:07:33.387 --> 00:07:36.823 
我們將允許你能夠爲你的節點
和動作創建序列化數據文件

00:07:37.257 --> 00:07:39.259 
創建序列化數據文件

00:07:39.326 --> 00:07:41.862 
並將其作爲一個引用參數添加進來

00:07:41.929 --> 00:07:44.998 
而不是簡單的加載到你的場景中

00:07:45.065 --> 00:07:45.899 
這樣

00:07:45.966 --> 00:07:48.335 
你每次對資源文件進行修改之後

00:07:48.669 --> 00:07:51.939 
將會自動地對你的遊戲內容產生影響

00:07:54.474 --> 00:07:55.909 
我怎麼做這個節點呢?

00:07:56.743 --> 00:07:59.680 
我設計了一部分場景作爲節點

00:07:59.746 --> 00:08:02.749 
可以是一個背景元素
或者是Xcode編輯器中的一些畫面

00:08:02.816 --> 00:08:07.354 
接下來我可以通過
Xcode將這些文件

00:08:07.721 --> 00:08:08.856 
拖放到主場景中

00:08:08.922 --> 00:08:10.624 
接下來它會自動地創建一個參數

00:08:10.891 --> 00:08:12.025 
這些都是爲你設置好的

00:08:13.093 --> 00:08:15.229 
如果你想寫代碼來完成這些事情
同樣可以

00:08:15.662 --> 00:08:18.699 
你可以手動構建一個
SKReferenceNode

00:08:19.066 --> 00:08:23.036 
爲其分配一個文件名或者URL

00:08:23.103 --> 00:08:25.973 
當這些內容在
你的遊戲中是第一次發佈時

00:08:26.039 --> 00:08:28.542 
我們會將你的包中
這些內容的最新版本的

00:08:28.809 --> 00:08:29.977 
文件進行上傳

00:08:31.945 --> 00:08:34.014 
我們同樣能夠這樣處理一些動作

00:08:34.515 --> 00:08:37.384 
通過這些動作作品

00:08:37.985 --> 00:08:40.654 
能夠看出我們的
新動作編輯器是多麼的偉大

00:08:40.721 --> 00:08:43.323 
同時那些你在Xcode中創作的動作
你都 有命名的權利

00:08:43.756 --> 00:08:46.059 
這些名字將是你在遊戲中
使用它們時候的關鍵字

00:08:46.727 --> 00:08:48.996 
我們在SKAction中添加了

00:08:49.329 --> 00:08:50.631 
一個名叫actionNamed
的篩選器

00:08:51.031 --> 00:08:51.932 
它的作用就像

00:08:51.999 --> 00:08:54.935 
textureNamed
對於SKTexture一樣

00:08:55.068 --> 00:08:56.770 
你可以輸入你想要的動作的名字

00:08:57.404 --> 00:09:01.008 
我們將自動在你的App包中的

00:09:01.708 --> 00:09:04.278 
序列化動作文件中 找到

00:09:04.344 --> 00:09:06.446 
一個最合適的文件

00:09:06.513 --> 00:09:07.948 
然後將其在應用程序中呈現出來

00:09:08.515 --> 00:09:11.218 
在你的遊戲中請頻繁使用這個功能

00:09:11.285 --> 00:09:14.955 
我們做了所有的關於內存的工作

00:09:15.355 --> 00:09:17.724 
我們可以保證
你的遊戲中所有相同的動作絕對不會

00:09:17.791 --> 00:09:21.428 
從硬盤中重複地加載多次

00:09:21.662 --> 00:09:24.631 
有時候你可能會想要
讓同一個動作重複多次

00:09:24.698 --> 00:09:26.867 
但它會播放得時快時慢

00:09:27.467 --> 00:09:29.536 
我們添加了一個額外的選擇器

00:09:29.603 --> 00:09:31.338 
它將允許你能夠覆蓋操作的持續時間

00:09:32.105 --> 00:09:34.007 
這是一個智能時間軸

00:09:34.107 --> 00:09:37.277 
所以即使你使用的是嵌套組和序列中的
嵌套 動作

00:09:37.344 --> 00:09:39.746 
它將動態規劃新的時間軸

00:09:39.813 --> 00:09:43.550 
這樣 每個時間區間內的動作組件

00:09:43.617 --> 00:09:45.285 
都將會是一樣的大小

00:09:46.653 --> 00:09:50.224 
這些都是爲可重複使用組件設計的工具

00:09:50.591 --> 00:09:53.560 
這些可重複使用組件你
可以在同一個遊戲的同一個場景

00:09:53.627 --> 00:09:55.095 
或者跨越多個不同的遊戲中使用

00:09:56.563 --> 00:09:58.966 
我們同樣在構架中
添加了一系列新的動作

00:09:59.032 --> 00:10:01.468 
所以現在我們有了這些位置
AudioNodes

00:10:01.535 --> 00:10:04.271 
就能夠通過動作更好的控制回放

00:10:04.471 --> 00:10:10.010 
我們已經添加了播放,暫停,回放速度

00:10:10.110 --> 00:10:12.079 
以及操作體積和立體平移等開關

00:10:13.881 --> 00:10:17.584 
我們也在幀動畫中做了一些改動

00:10:18.252 --> 00:10:21.421 
在SpriteKit中我們一直
都有通過紋理動作運動

00:10:21.488 --> 00:10:24.525 
做出來的基於幀的動畫

00:10:25.559 --> 00:10:28.395 
但是去年我們在SpriteKit中
引入了lighting

00:10:28.462 --> 00:10:29.530 
通過lighting

00:10:29.596 --> 00:10:31.899 
你不僅能夠在你的場景中爲
Sprites自動生成

00:10:32.232 --> 00:10:34.401 
也能夠自主添加常規的紋理動作

00:10:34.468 --> 00:10:37.871 
然後我們可以在運行時動態的點亮他們

00:10:37.938 --> 00:10:40.207 
通過在你的場景中移動光節點

00:10:41.608 --> 00:10:43.877 
這種做法對於穩定的元素來講很方便

00:10:43.944 --> 00:10:46.914 
但是如果我有一個基於幀的動畫
例如這個東西

00:10:47.681 --> 00:10:49.816 
我們想要這些高亮和陰影部分

00:10:49.883 --> 00:10:50.751 
在當前位置分開

00:10:50.817 --> 00:10:53.654 
我們不想要腿前面所在的區域高亮

00:10:54.655 --> 00:10:56.056 
所以 我們添加了一個

00:10:56.123 --> 00:10:58.258 
正常紋理運動的動畫

00:10:58.492 --> 00:11:01.228 
所以你可以使用這個 在正常的動畫

00:11:01.728 --> 00:11:04.598 
與每一幀之間 進行同步

00:11:04.698 --> 00:11:08.836 
如果我在我的人物上運行了這種動畫
並給場景添加了lighting

00:11:09.136 --> 00:11:11.905 
你就會看到所有的高亮區域 陰影都能
與每一幀保 持同步

00:11:11.972 --> 00:11:15.209 
無論我的人物如何跑動

00:11:24.918 --> 00:11:27.387 
這些就是我們添加到構架中的新功能

00:11:27.454 --> 00:11:29.489 
我們也做了很多其他的工作
使這些功能能夠與

00:11:29.823 --> 00:11:32.993 
系統的其他部分更好的結合在一起

00:11:33.060 --> 00:11:35.229 
更好的發揮已經添加到我們平臺上的

00:11:35.295 --> 00:11:36.797 
新硬件和構架的優勢

00:11:37.898 --> 00:11:40.133 
首先我想講的是Metal

00:11:40.767 --> 00:11:43.437 
我們正在開發SpriteKit

00:11:43.504 --> 00:11:48.041 
並且我們正準備將它直接鏈接到IOS
和 Mac的Metal平臺上

00:11:48.842 --> 00:11:51.311 
將能夠在任何
支持Metal的設備上使用

00:11:51.378 --> 00:11:53.647 
以及那些不會自動降級
到OpenGL的設備上

00:11:54.815 --> 00:11:58.285 
這意味着你的CPU使用率會降低

00:11:58.585 --> 00:12:01.188 
這意味着作爲一個開發人員
你將會得到更好的繪製調用性能

00:12:01.255 --> 00:12:02.823 
以及更好的電池使用壽命

00:12:02.890 --> 00:12:04.658 
因爲將能夠做到零運動請求

00:12:10.531 --> 00:12:12.633 
我們將自動升級所有的
SpriteKit程序

00:12:12.699 --> 00:12:13.734 
你不需要重新編譯

00:12:13.800 --> 00:12:15.269 
或重新提交

00:12:15.702 --> 00:12:17.538 
只要它支持Metal 你就能夠運行

00:12:18.505 --> 00:12:21.041 
如果你對自定義着色器感興趣的話

00:12:21.108 --> 00:12:22.442 
我們也同樣顧及到了

00:12:23.010 --> 00:12:25.579 
如果你的遊戲中有自定義着色器

00:12:25.646 --> 00:12:28.315 
我們幾乎支持
所有的Metal變體的升級

00:12:28.515 --> 00:12:30.984 
同樣能夠在
支持Metal的設備上很好地運行

00:12:36.456 --> 00:12:37.391 
接下來是Swift

00:12:38.192 --> 00:12:39.960 
我們看了整個API的文件

00:12:40.127 --> 00:12:42.362 
並且我們向其中添加了可空性限定符

00:12:42.663 --> 00:12:45.866 
我們採用了
Objective-C泛型數組類型

00:12:45.933 --> 00:12:47.701 
用作參數或者返回類型

00:12:48.368 --> 00:12:50.504 
這將是你能夠很方便的

00:12:50.571 --> 00:12:53.373 
從Swift中訪問
SpriteKit的所有功能

00:12:54.408 --> 00:12:56.243 
這也能夠給你的軟件
提供增強版的安全性

00:12:56.310 --> 00:12:58.545 
增強版的安全性
無論你是使用Swift

00:12:59.146 --> 00:13:00.347 
還是Objective C

00:13:02.049 --> 00:13:03.750 
現在我想講一下SceneKit

00:13:03.951 --> 00:13:06.486 
或許你並不知道Scenekit

00:13:06.553 --> 00:13:09.056 align:start position:10%
我們允許你用SceneKit體現
SpriteKit

00:13:09.122 --> 00:13:10.891 align:start position:10%
也可以用SpriteKit
體現SceneKit

00:13:11.325 --> 00:13:13.894 
今年我們允許你能做到的更多一點

00:13:13.961 --> 00:13:16.463 
可以直接在
SceneKits遊戲中使用

00:13:16.530 --> 00:13:18.932 
所有你知道和
你喜歡的SpriteKit過渡效果

00:13:19.933 --> 00:13:21.935 
你甚至都不需要
用SpriteKit去做

00:13:22.769 --> 00:13:26.740 
你可以像使用門一樣使用這個轉換器
剪輯

00:13:27.040 --> 00:13:29.710 
甚至你的SceneKit遊戲中
基於轉換效果的核心圖片

00:13:30.177 --> 00:13:33.180 
同樣能夠有很好的效果

00:13:34.281 --> 00:13:36.016 
這個版本的SceneKit同樣支持

00:13:36.083 --> 00:13:38.185 
Metal背景下的內容

00:13:38.886 --> 00:13:41.054 
我們可以自動匹配好

00:13:41.121 --> 00:13:43.924 
如果你有一個支持在Metal上運行
的SceneKit遊戲 

00:13:44.258 --> 00:13:45.425 
我們通過使用Metal

00:13:45.492 --> 00:13:47.227 
可以使你得到SpriteKit內容

00:13:47.294 --> 00:13:49.696 
去過你有一個支持GL上運行的
SceneKit遊戲

00:13:49.763 --> 00:13:52.466 
我們可以通過使用OpenGL使你得
到SpriteKit

00:13:52.533 --> 00:13:54.735 
你永遠不會產生額外的開銷

00:13:54.801 --> 00:13:57.337 
在兩個API之間進行轉換時

00:14:00.207 --> 00:14:03.410 
今年我們也發佈了一個全新的構架

00:14:03.610 --> 00:14:04.912 
叫做 GameplayKit

00:14:05.112 --> 00:14:06.780 
這個構架很棒

00:14:06.847 --> 00:14:09.750 
它將提供給你創建一個遊戲邏輯結構所
需的所有基礎

00:14:09.983 --> 00:14:12.920 
就像Entity/
Component系統一樣

00:14:13.587 --> 00:14:15.088 
作爲狀態機

00:14:15.155 --> 00:14:18.258 
而且還提供了非常棒的工具

00:14:18.392 --> 00:14:21.528 
例如AI對手和確定性隨機源

00:14:22.462 --> 00:14:24.498 
有一點我非常喜歡

00:14:24.565 --> 00:14:26.967 
那就是它能夠爲你的遊戲
提供一個路徑尋找的解決方案

00:14:27.034 --> 00:14:29.636 
我相信很多SpriteKit工程師
會對這個功能感興趣

00:14:30.470 --> 00:14:32.506 
GameplayKit中尋路
的工作方式是

00:14:32.573 --> 00:14:34.741 
你指定一個可穿越的導航圖

00:14:35.409 --> 00:14:37.644 
在你的遊戲世界中

00:14:38.212 --> 00:14:41.448 
之後你將會在這些節點之間連線

00:14:41.782 --> 00:14:43.350 
並給出一個相關成本

00:14:44.618 --> 00:14:46.019 
只要你給出了這個地圖

00:14:46.587 --> 00:14:48.689 
GameplayKit 
將計算出地圖上

00:14:48.822 --> 00:14:50.090 
這兩個點之間的最優路徑

00:14:50.991 --> 00:14:52.759 
我怎樣在遊戲中設置呢？

00:14:53.994 --> 00:14:56.263 
加入我這裏
有一個SpriteKit遊戲

00:14:56.330 --> 00:14:58.165 align:start position:10%
我的英雄在下面的這個角 
我...嗯…

00:14:58.632 --> 00:15:01.668 
假如我想讓他移動到某一個目的地

00:15:02.202 --> 00:15:05.806 
然後在我的地圖上指定幾個障礙物

00:15:05.873 --> 00:15:07.441 
障礙物是不可穿越的地區

00:15:07.841 --> 00:15:12.045 
將這些數據
給GameplayKit之後

00:15:12.112 --> 00:15:14.715 
給我的想要穿越地圖的角色
周圍設置一個緩衝半徑

00:15:15.048 --> 00:15:17.684 
GameplayKit 會將
緩衝半徑計算進去

00:15:17.751 --> 00:15:20.420 
自動擴展所有的障礙物

00:15:20.487 --> 00:15:22.556 
這樣我們不會
進入任何障礙物的緩衝半徑中

00:15:23.257 --> 00:15:25.359 
然後在地圖中創建有效的連接圖

00:15:25.425 --> 00:15:27.694 
並且只創建有效的連接

00:15:27.861 --> 00:15:29.863 
所以我們永遠不會穿越這些障礙物

00:15:30.430 --> 00:15:33.567 
然後你就可以在你的遊戲中
使用這些來進行

00:15:33.967 --> 00:15:35.035 
尋路操作

00:15:35.602 --> 00:15:37.704 
這個功能並不專屬於
 SpriteKit

00:15:37.771 --> 00:15:40.707 
所以你可以在SceneKit
中使用GameplayKits

00:15:40.774 --> 00:15:43.110 
SpriteKit, 
OpenGL, Metal

00:15:43.177 --> 00:15:44.378 
等等任何類型的遊戲都可以

00:15:45.212 --> 00:15:47.948 
如果你使用的是SpriteKit
我們可以使它變得更容易

00:15:48.015 --> 00:15:49.249 
你甚至都不需要創建障礙物

00:15:50.050 --> 00:15:53.687 
你可以使用Sprite界限
直接創建障礙物

00:15:55.422 --> 00:15:57.691 
你可以根據你在Sprite上
設置的物理主體

00:15:57.758 --> 00:16:01.261 
創建障礙物

00:16:01.328 --> 00:16:03.363 
甚至從與你遊戲中
Sprite相關紋理的

00:16:03.597 --> 00:16:05.999 align:start position:10%
Alpha透明度信息中創建障礙物

00:16:06.300 --> 00:16:09.203 
這給了你一種非常簡單的
在SpriteKit軟件中利用

00:16:09.469 --> 00:16:11.972 
GameplayKits尋路的方法

00:16:18.345 --> 00:16:19.813 
就像我之前說的

00:16:20.147 --> 00:16:22.182 
構架只是我們工作的一部分

00:16:22.649 --> 00:16:25.118 
今年我們對我們的工具進行了
大量非常棒的改進

00:16:25.185 --> 00:16:27.855 
接下來我想將這些交給Norman

00:16:27.921 --> 00:16:28.989 
來講解

00:16:34.761 --> 00:16:35.963 
謝謝你 提姆

00:16:37.364 --> 00:16:40.467 
開發遊戲是一個複雜
並且不斷迭代的過程

00:16:40.934 --> 00:16:44.271 
遊戲的各個部分需要
像玩遊戲一樣不斷迭代

00:16:44.872 --> 00:16:47.474 
以保證一個遊戲的趣味性

00:16:48.075 --> 00:16:50.244 
動畫 用來確保一個角色移動的流暢性

00:16:50.811 --> 00:16:53.213 
藝術性 用來保證屏幕上的像素點

00:16:53.280 --> 00:16:56.049 
能夠流行起來

00:16:56.250 --> 00:16:58.685 
作爲一個遊戲工程師
你不僅會遇到迭代問題

00:16:58.752 --> 00:17:01.522 
你還會遇到可伸縮性問題

00:17:01.922 --> 00:17:05.325 
我要怎樣才能跨越多個等級
複製我的設計呢？

00:17:06.292 --> 00:17:09.695 
在蘋果公司我們當初啓動設計
SpriteKit 的工程時

00:17:09.762 --> 00:17:13.200 
我們不僅想要爲你提供
一個高性能

00:17:13.267 --> 00:17:15.435 
且易用的API

00:17:15.502 --> 00:17:18.405 
而且要爲你提供
一個可伸縮和迭代的工具

00:17:18.872 --> 00:17:21.575 
這樣我們就能專注於
開發遊戲

00:17:22.542 --> 00:17:25.244 
從SpriteKit 構架的
第一個版本發佈

00:17:25.311 --> 00:17:26.780 
我們已經開發並

00:17:26.847 --> 00:17:28.582 
持續向Xcode中

00:17:28.649 --> 00:17:30.584 
添加了多個工具

00:17:31.051 --> 00:17:34.521 
讓我來給你們展示一下
作爲一個SpriteKit用戶

00:17:34.688 --> 00:17:36.390 
你能夠使用哪些工具

00:17:37.691 --> 00:17:40.160 
第一個要介紹的是紋理地圖集

00:17:41.161 --> 00:17:43.730 
使用texture atlas的
第一個主要好處就是

00:17:44.131 --> 00:17:45.866 
能夠提升性能

00:17:46.767 --> 00:17:49.736 
SpriteKit通過紋理地圖集將
大量的圖片調用命令最小化

00:17:49.803 --> 00:17:53.106 
併發送給GPU以達到優化效率的目的

00:17:53.740 --> 00:17:57.811 
我們不想強迫我們的用戶適應手動

00:17:58.145 --> 00:18:01.815 
創建這些紋理地圖集的過程

00:18:02.549 --> 00:18:05.018 
每次對資源進行修改的時候

00:18:05.118 --> 00:18:07.487 
這些手動的過程都必須從頭再來一遍

00:18:08.188 --> 00:18:10.591 
所以我們開發了一個
自動的紋理地圖集生成器

00:18:10.657 --> 00:18:12.159 
在Xcode中

00:18:12.793 --> 00:18:15.195 
創建一個這種地圖集

00:18:15.262 --> 00:18:17.798 
就像拖拽一個文件夾
到你的工作區中一樣簡單

00:18:18.699 --> 00:18:22.469 
同樣的我們在開發的時候
也會自動做一些事情

00:18:22.536 --> 00:18:25.138 
每一張資源圖片

00:18:25.205 --> 00:18:27.341 
都會自動經歷一個複雜的後期處理過程

00:18:27.741 --> 00:18:31.912 
例如我們會爲圖片
修剪Alpha透明像素

00:18:32.479 --> 00:18:34.381 
但是這並不會在屏幕上有任何體現

00:18:34.915 --> 00:18:38.852 
如果旋轉90度能夠讓這些圖片更緊湊

00:18:39.353 --> 00:18:41.421 
或者能得到一個更小的地圖集的話 
我們會進行這樣的旋轉

00:18:41.989 --> 00:18:43.690 
對於每一個資源圖片 

00:18:43.757 --> 00:18:47.461 
我們都會對其進行其邊緣的審查

00:18:47.895 --> 00:18:49.596 
如果其實完全不透明的

00:18:49.663 --> 00:18:51.398 
我們將會對其邊緣進行壓縮

00:18:51.465 --> 00:18:53.400 
當你在場景中堆疊這些圖片時

00:18:53.467 --> 00:18:55.736 
你不會看到任何接縫

00:18:57.237 --> 00:18:59.439 
這就是紋理地圖集自動生成器

00:19:00.440 --> 00:19:02.543 
今年我們將它做得更好了

00:19:03.277 --> 00:19:05.479 
現在你可以生成紋理地圖集

00:19:05.546 --> 00:19:07.147 
來代替資源目錄了

00:19:07.681 --> 00:19:09.116 
使用資源目錄生成地圖集

00:19:09.183 --> 00:19:11.919 
有兩個主要好處

00:19:12.286 --> 00:19:13.153 
第一

00:19:14.087 --> 00:19:15.923 
你可以精確地

00:19:15.989 --> 00:19:18.192 
爲你的目標設備

00:19:18.258 --> 00:19:19.860 
適配到合適分辨率的圖片

00:19:20.427 --> 00:19:23.730 
你不需要嚴格
按照你的圖片名字的後綴來查找

00:19:24.231 --> 00:19:28.502 
例如添加2X或者
添加2X到iphone

00:19:29.203 --> 00:19:31.538 
所有的這些都能在在UI中設計好

00:19:32.372 --> 00:19:33.640 
第二個

00:19:33.707 --> 00:19:36.343 
有點就是我們現在支持 ...

00:19:36.410 --> 00:19:37.611 
在資源目錄中

00:19:38.245 --> 00:19:41.181 
每一組的目標分辨率

00:19:41.248 --> 00:19:43.851 
將會根據他們設備的獨立紋理來生成

00:19:44.351 --> 00:19:45.786 
當用戶打開App Store

00:19:45.853 --> 00:19:48.088 
並下載下來
你的SpriteKit授權遊戲時

00:19:48.856 --> 00:19:51.124 
只有與他或她的設備

00:19:51.191 --> 00:19:53.393 
相適配的地圖集纔會被下載下來

00:19:54.061 --> 00:19:56.864 
這不僅能夠使下載時的帶寬最小

00:19:57.297 --> 00:20:01.068 
同樣能夠使其安裝到
用戶手機的時間最短

00:20:01.401 --> 00:20:04.872 
同樣能夠最小化應用程序的存儲開銷

00:20:07.241 --> 00:20:10.444 
另外 紋理地圖集支持基於命令資源

00:20:10.911 --> 00:20:13.680 align:start position:10%
基於命令的資源是一個全新的API

00:20:13.981 --> 00:20:17.317 
它使你能夠在遊戲運行的情況下

00:20:17.384 --> 00:20:19.219 
從網上下載藝術資源流

00:20:20.053 --> 00:20:22.089 
SpriteKit也集成了這種功能

00:20:22.489 --> 00:20:24.892 
這種資源是通過標籤來識別的

00:20:25.259 --> 00:20:26.126 
例如

00:20:26.193 --> 00:20:28.295 
這是我的Inspector中的Xc
ode寫的背景元素

00:20:28.362 --> 00:20:32.432 
我可以指定一個與其相關聯的標籤

00:20:33.133 --> 00:20:35.536 
我把它叫做一級背景

00:20:35.602 --> 00:20:38.505 
這些就是標籤 你可以通過這些標籤

00:20:38.572 --> 00:20:40.440 
檢索這個資源

00:20:40.507 --> 00:20:42.242 
並且開啓背景流媒體

00:20:42.476 --> 00:20:44.044 
當你的程序調用它的時候

00:20:46.813 --> 00:20:48.348 
粒子效果

00:20:48.415 --> 00:20:50.150 
可以有效地幫助你準確的建立起遊戲

00:20:52.186 --> 00:20:54.555 
我們將這個構架中的
SKEmitterNode

00:20:54.621 --> 00:20:56.924 
作爲一個強大且靈活的APIs

00:20:56.990 --> 00:20:58.692 
提供給你來使用

00:20:59.593 --> 00:21:02.196 
強大並靈活也有缺點

00:21:02.763 --> 00:21:05.832 
那就是你需要設置49個屬性

00:21:07.134 --> 00:21:09.069 
你需要對這49個屬性

00:21:09.136 --> 00:21:11.038 
進行排列組合

00:21:11.104 --> 00:21:12.739 
來達到你想要的視覺和感覺效果

00:21:12.806 --> 00:21:15.442 
你需要做的就是花費更多的時間

00:21:16.109 --> 00:21:18.045 
因爲我們在Xcode中

00:21:18.111 --> 00:21:20.314 
開發了一個粒子編輯器

00:21:20.747 --> 00:21:23.083 
它是使用同一個
SpriteKit呈現驅動

00:21:23.417 --> 00:21:25.252 
可以讓你能夠

00:21:25.319 --> 00:21:27.120 
在你的工作區中直觀的看到它

00:21:27.754 --> 00:21:31.124 
所以你無需編寫任何代碼

00:21:31.491 --> 00:21:33.227 
就能夠對這49個屬性進行調整和改變

00:21:33.293 --> 00:21:34.995 
也無需重建你的遊戲

00:21:35.863 --> 00:21:37.865 
這些粒子將作爲一個
很小的數據文件導出

00:21:37.931 --> 00:21:39.800 
並能夠被序列化

00:21:40.133 --> 00:21:44.671 
也能夠部署在多個等級或者多個項目中

00:21:47.841 --> 00:21:50.177 
SpriteKit同樣支持
Quick Look.

00:21:50.377 --> 00:21:53.180 
例如 我正在努力學習新的Swift

00:21:53.680 --> 00:21:56.617 
我創建了一個全新的場景

00:21:56.850 --> 00:21:59.987 
並努力地在
SpriteKit API中使用

00:22:00.053 --> 00:22:01.688 
全新的Swift 2.0語言

00:22:03.724 --> 00:22:06.593 
我正在做的事情就是創建一個壞蛋角色

00:22:07.261 --> 00:22:09.162 
就叫壞人 這是一個Sprite節點

00:22:09.329 --> 00:22:12.232 
它是一個叫做車罩的
單獨紋理複製出來的

00:22:13.200 --> 00:22:15.702 
另外 我創建兩個子節點 

00:22:15.769 --> 00:22:18.839 
在這個壞人節點之下

00:22:18.906 --> 00:22:21.175 
一個有屋頂的紋理

00:22:21.675 --> 00:22:23.610 
另一個有樹幹的紋理

00:22:24.711 --> 00:22:25.712 
這裏會發生什麼呢？

00:22:26.180 --> 00:22:29.249 
SpriteKit的部分屏幕中將
會呈現這些看不見的東西

00:22:29.316 --> 00:22:31.151 
當你努力去

00:22:31.218 --> 00:22:32.753 
內觀一個Sprite節點的時候

00:22:33.086 --> 00:22:36.256 
它會將結果爲你呈現在窗口中

00:22:36.323 --> 00:22:39.493 
這樣 你試着學習一個新的語言或者

00:22:39.560 --> 00:22:42.396 
更改一個對象的每一步都會呈現出來

00:22:42.796 --> 00:22:45.599 
你將會在窗口中看到實時的變化

00:22:47.534 --> 00:22:49.002 
另外SpriteKit中
的Quicklook

00:22:49.369 --> 00:22:50.737 
同樣支持

00:22:50.804 --> 00:22:52.539 
在你調試程序的時候

00:22:52.606 --> 00:22:54.274 
無論你是使用Swift

00:22:54.842 --> 00:22:56.143 
還是Objective-C

00:22:56.210 --> 00:22:57.978 
無論他們是在IOS設備上運行

00:22:58.278 --> 00:22:59.580 
還是在Mac OS X上運行

00:23:00.447 --> 00:23:03.951 
這裏我想試着去調試一個我寫的程序

00:23:05.052 --> 00:23:06.353 
我觸發了一個斷點

00:23:06.420 --> 00:23:08.856 
目標過程其實停止了 

00:23:09.223 --> 00:23:10.591 
但是我們仍然能夠

00:23:10.958 --> 00:23:14.094 
隱藏這部分顯示
並呈現出目前的紋理

00:23:14.695 --> 00:23:15.929 
並在調試器中顯示出來

00:23:16.363 --> 00:23:18.432 
所以你能夠清楚地知道

00:23:18.498 --> 00:23:20.767 
這個紋理是我之前調試的

00:23:20.834 --> 00:23:23.403 
並將它抓取出來分配給了
一個SKSpriteNode

00:23:26.440 --> 00:23:29.743 
去年 IOS
8中我們發佈了一個虛擬場景編輯器

00:23:29.810 --> 00:23:32.813 
他允許你建立一個完整的場景佈局

00:23:32.880 --> 00:23:34.114 
並不需要編寫任何代碼

00:23:38.018 --> 00:23:41.588 
你不僅可以設置場景中每一個

00:23:41.655 --> 00:23:43.991 
可選節點的位置 旋轉和尺度

00:23:44.391 --> 00:23:47.761 
你同樣可以定義其物理屬性例如

00:23:47.828 --> 00:23:51.498 
圖片 重力 質量和摩擦

00:23:53.166 --> 00:23:55.769 
你也可以進行這些物理仿真的

00:23:56.203 --> 00:23:59.072 
實時模擬

00:23:59.139 --> 00:24:01.642 
而這些並不需要你登陸遊戲
或者重新編譯你的程序

00:24:03.110 --> 00:24:06.880 
SpriteKit也將支持
一些先進的渲染技術

00:24:06.947 --> 00:24:08.081 
例如自定義着色器等

00:24:08.782 --> 00:24:12.853 
在這一層上 這個瀑布的背景和

00:24:12.920 --> 00:24:15.322 
霧的底部實際上我使用了

00:24:15.389 --> 00:24:16.256 
兩個自定義着色器

00:24:16.723 --> 00:24:20.060 
要添加着色器 

00:24:20.561 --> 00:24:22.829 
他就像打開幫助編輯器一樣簡單

00:24:22.963 --> 00:24:25.065 
它會自動在你的當前場景中顯示出來

00:24:25.632 --> 00:24:27.601 
當然這是渲染過後的

00:24:27.668 --> 00:24:30.070 
並向你展示附有源代碼的

00:24:30.137 --> 00:24:31.138 
助理編輯器

00:24:31.538 --> 00:24:32.606 
你在助理編輯器中

00:24:32.673 --> 00:24:34.208 
所做的任何實時的修改

00:24:34.274 --> 00:24:35.909 
都會自動進行編譯

00:24:35.976 --> 00:24:38.011 
打開OpenGL或者Metal

00:24:38.412 --> 00:24:41.648 
會爲你提供一個真正實時的視窗

00:24:42.015 --> 00:24:44.418 
而不是都建整個遊戲

00:24:44.952 --> 00:24:46.086 
跨越整個層

00:24:46.587 --> 00:24:48.589 
以及特定的節點

00:24:48.889 --> 00:24:52.359 
觸發這個事件來確定我是否真的發送了
一個流給OpenGL或者Metal

00:24:52.426 --> 00:24:54.294 
無論是否編譯成功

00:24:54.661 --> 00:24:56.396 
這將節省很多迭代的時間

00:24:58.398 --> 00:25:00.901 
今年我們花了大量的時間來

00:25:00.968 --> 00:25:02.569 
對虛擬場景編輯器進行改進升級

00:25:02.636 --> 00:25:05.239 
第一個請求的類型是自定義的

00:25:06.273 --> 00:25:09.710 
現在 在我的英雄角色所處的這一層

00:25:10.344 --> 00:25:12.379 
我可以將它指定爲一個類

00:25:12.446 --> 00:25:14.615 
這個類的名字叫做角色類

00:25:16.149 --> 00:25:18.652 
當場景被反序列化運行時

00:25:19.019 --> 00:25:22.489 
無論你的程序是用Objective
-C還是用Swift寫的

00:25:23.957 --> 00:25:26.860 
正確的類將會被創建並實例化

00:25:27.494 --> 00:25:30.998 
並加載到場景中 在場景運行的時候

00:25:32.900 --> 00:25:34.434 
另外

00:25:35.869 --> 00:25:38.505 
從SKNodes項目開始的第一天起

00:25:38.572 --> 00:25:41.141 
我們就一直忙於它的支撐工作

00:25:41.575 --> 00:25:44.077 
現在你能夠使用編輯其中的

00:25:44.144 --> 00:25:45.012 
鏡頭節點

00:25:45.379 --> 00:25:46.647 
音頻節點定位 

00:25:47.014 --> 00:25:48.549 
以及Referenc
eNode

00:25:48.615 --> 00:25:50.150 
來設計你的場景

00:25:50.617 --> 00:25:53.453 
能夠在編輯器中看到鏡頭髮送

00:25:53.520 --> 00:25:55.989 
準確的時間軸、縮放因子

00:25:56.056 --> 00:25:57.391 
以及動作

00:25:57.457 --> 00:25:59.092 
而並不需要

00:25:59.927 --> 00:26:01.528 
編譯整個遊戲是多麼酷炫的一件事

00:26:02.095 --> 00:26:03.363 
你也可以

00:26:03.430 --> 00:26:06.200 
設置SKAudioNode的位置

00:26:06.700 --> 00:26:08.302 
並將之移動

00:26:08.368 --> 00:26:10.304 
來親自聽實時的音效變化

00:26:11.104 --> 00:26:14.174 
以確定你在場景中
想要的效果是否設置正確

00:26:16.710 --> 00:26:20.013 
今年 前端工具中最激動人心的功能是

00:26:20.080 --> 00:26:21.348 
能夠設計

00:26:21.415 --> 00:26:23.083 
複雜的動作

00:26:23.951 --> 00:26:26.653 
你可以通過基礎構建模塊

00:26:27.054 --> 00:26:28.789 
設計出一個非常複雜的動作

00:26:28.856 --> 00:26:32.192 
我們已經將其作爲SpriteKit
的動作部分提供給了大家

00:26:33.961 --> 00:26:35.629 
它是基於時間線的

00:26:36.129 --> 00:26:39.633 
和Xcode中的其他編輯器一樣

00:26:40.133 --> 00:26:42.369 
他也支持實時可視化

00:26:43.370 --> 00:26:44.905 
你不僅可以

00:26:44.972 --> 00:26:47.107 
用它來開發2D動作

00:26:47.808 --> 00:26:50.110 
也可以用來爲
SceneKit設計3D動畫

00:26:50.277 --> 00:26:52.713 
都是同樣的編輯器

00:26:53.814 --> 00:26:56.216 
你也可以創建電影動畫

00:26:56.750 --> 00:26:59.553 
電影動畫可以作爲場景動畫的一部分

00:26:59.620 --> 00:27:02.623 
當場景加載的時候
任何包含這種動作的節點

00:27:02.689 --> 00:27:05.325 
都會自動運行起來

00:27:06.627 --> 00:27:09.596 
你也可以創建交互式動畫

00:27:10.063 --> 00:27:11.365 
例如循環動畫

00:27:11.698 --> 00:27:14.535 
或者跳轉動畫
從窗臺掉落

00:27:15.636 --> 00:27:19.006 
通過一行或兩行代碼出發摺疊動畫

00:27:19.940 --> 00:27:21.375 
在不同的遊戲場景中

00:27:25.546 --> 00:27:27.181 
這裏有一個場景

00:27:27.247 --> 00:27:28.916 
我將鏡頭設計爲移動的

00:27:28.982 --> 00:27:30.384 
現在鎖定遊戲角色

00:27:30.450 --> 00:27:32.052 
角色開始運動

00:27:32.119 --> 00:27:33.654 
運行行走動作循環

00:27:33.720 --> 00:27:35.656 
穿越整個場景 這就是開場

00:27:35.722 --> 00:27:38.625 
你也可以在五分鐘之完成這些

00:27:42.529 --> 00:27:45.432 
今年2D和3D的前端工具中

00:27:45.499 --> 00:27:48.035 
另一個主要關注點就是

00:27:48.101 --> 00:27:50.537 
能夠做引用和實例化

00:27:51.438 --> 00:27:53.307 
在SpriteKit上

00:27:53.373 --> 00:27:56.643 
一直是支持對動作或節點的引用

00:27:56.944 --> 00:28:00.280 
這些都是你場景中的藝術資源

00:28:01.381 --> 00:28:03.050 
這些都是可重複使用的組件

00:28:03.150 --> 00:28:05.385 
這些都是數據文件

00:28:05.652 --> 00:28:07.621 
能夠在不同的工程中

00:28:07.888 --> 00:28:10.057 
不同的人之間 不同的層次上共享

00:28:10.924 --> 00:28:12.359 
在使用這些引用文件時

00:28:12.426 --> 00:28:14.127 
你不需要寫任何代碼

00:28:16.930 --> 00:28:19.399 
創建引用動畫非常簡單

00:28:19.733 --> 00:28:24.171 
我們在Xcode中提供一種
全新的SK動作文件模板

00:28:24.238 --> 00:28:27.074 
你可以打包一個純粹的動畫文件

00:28:27.474 --> 00:28:30.143 
設計好所有的複雜的動畫

00:28:30.210 --> 00:28:31.144 
將之命名

00:28:31.478 --> 00:28:34.781 
使這些動作可以
被SKAction檢索

00:28:34.848 --> 00:28:36.550 
使用actionNamed選擇器

00:28:37.017 --> 00:28:39.253 
創建正確的實例
並將之添加到你的場景中

00:28:40.020 --> 00:28:44.224 
任何引用的動作
都將會被自動篩選出來

00:28:44.291 --> 00:28:46.226 
放到一個對象庫中

00:28:46.360 --> 00:28:48.629 
如果你想在不同的場景中

00:28:48.695 --> 00:28:50.931 
或者不同的層中

00:28:50.998 --> 00:28:54.034 
再次使用這些動作 這只是一個

00:28:54.101 --> 00:28:55.169 
從對象庫中拖放的問題

00:28:56.770 --> 00:28:59.406 
創建一個引用節點也很簡單

00:29:00.807 --> 00:29:04.211 
就像在你的工作區中拖一個SKS文件

00:29:04.278 --> 00:29:06.680 
放到你的場景中一樣簡單

00:29:07.681 --> 00:29:08.882 
對於這些引用

00:29:08.949 --> 00:29:10.551 
我們會自動在編輯器中

00:29:10.617 --> 00:29:12.553 
生成SKReferenceNode
實例

00:29:12.786 --> 00:29:14.621 
併爲你分配合適的URL

00:29:16.223 --> 00:29:19.893 
你同樣可以使用API創建
一個自定義節點收藏夾

00:29:20.394 --> 00:29:22.629 
例如 我有一個鳥籠

00:29:22.696 --> 00:29:24.231 
我打算用它作爲一個

00:29:24.298 --> 00:29:26.633 
不同的層之間的層道具

00:29:26.700 --> 00:29:28.802 
我可以在多個層之間建立起來

00:29:28.869 --> 00:29:31.305 
並將其實例化

00:29:31.371 --> 00:29:33.941 
任何對鳥籠原設計的修改

00:29:34.007 --> 00:29:36.443 
都會被自動地反映到

00:29:36.510 --> 00:29:39.146 
每一個引用了這個設計的實例中

00:29:42.115 --> 00:29:45.619 
這樣你就能夠在編輯器中手動地

00:29:45.686 --> 00:29:48.522 
修改和更新引用文件了

00:29:50.757 --> 00:29:54.928 
接下來
我想邀請泰勒上臺來給大家

00:29:55.062 --> 00:29:56.964 
演示一下Xcode中的這些新功能

00:30:03.136 --> 00:30:04.004 
謝謝你諾曼

00:30:04.071 --> 00:30:04.905 
就像你看到的那樣

00:30:04.972 --> 00:30:07.941 
我們爲SpriteKit和
Xcode 7增加了很多優秀的功能

00:30:08.008 --> 00:30:09.543 
我想通過展示一個簡單地例子向

00:30:09.610 --> 00:30:12.112 
你們展示它們是如何
在你的開發流中集成工作的

00:30:12.179 --> 00:30:15.249 
這個例子展示了創建一個簡單的層
添加場景

00:30:15.582 --> 00:30:17.351 
創建一些互動的遊戲等內容

00:30:22.189 --> 00:30:25.459 
好的
看這裏 我剛剛創建了一個遊戲工程

00:30:25.526 --> 00:30:28.529 
我在這個工程中添加了一個層

00:30:28.595 --> 00:30:31.565 
我們創建了一些平臺和一個角色

00:30:32.065 --> 00:30:35.669 
我想做的第一件事就是在其中創建環境

00:30:35.903 --> 00:30:39.072 
添加一些背景和前景元素

00:30:39.640 --> 00:30:42.409 
放在從前
我會直接在場景中做這些事情

00:30:42.476 --> 00:30:45.512 
然後一個個複製我所需要的實例

00:30:45.913 --> 00:30:48.615 
如果我需要修改一些東西的話
這很快就會變得非常麻煩

00:30:48.682 --> 00:30:51.018 
因爲我需要對非常多不同的點進行修改

00:30:51.318 --> 00:30:52.519 
並且很難重複使用

00:30:52.586 --> 00:30:54.388 
現在我們用
ReferenceNode

00:30:54.454 --> 00:30:55.522 
解決了這個問題

00:30:56.190 --> 00:30:58.659 
所以在這裏我創建了我的環境中

00:30:58.725 --> 00:31:00.861 
所需要的所有的元素並
將其放在單獨的文件中

00:31:01.094 --> 00:31:03.564 
這樣我就得到了一個有瀑布的背景

00:31:03.630 --> 00:31:05.632 
和一個有霧氣效果的前景

00:31:06.400 --> 00:31:08.101 
引用這些內容文件所需要進行的操作

00:31:08.168 --> 00:31:10.838 
就是將其拖放到我的層中

00:31:11.238 --> 00:31:13.373 
現在 我們自動創建一個

00:31:13.574 --> 00:31:16.276 
包含所有元素的Reference
Node你會注意到

00:31:16.343 --> 00:31:18.745 
前景的Z值被保留了下來

00:31:18.812 --> 00:31:20.447 
當我們將它添加到我的場景中的時候

00:31:21.215 --> 00:31:23.684 
接下來創建一些複製來填充起來這一層

00:31:23.750 --> 00:31:26.653 
你會注意到
我複製了ReferenceNode

00:31:26.720 --> 00:31:28.322 
其本身

00:31:28.589 --> 00:31:31.191 
而不是我所引用的場景中的

00:31:31.325 --> 00:31:33.260 
單獨的元素

00:31:33.894 --> 00:31:37.297 
這在我之後的工程中會顯得很棒

00:31:37.598 --> 00:31:39.900 
例如 當我想要跟換背景紋理時

00:31:39.967 --> 00:31:41.168 
因爲它並不是特別合適

00:31:41.235 --> 00:31:43.003 
我做的這個平臺 

00:31:43.070 --> 00:31:45.772 
我不需要改變我現有的三個實例

00:31:46.139 --> 00:31:48.141 
我可以打開我單獨的資源

00:31:48.475 --> 00:31:50.677 
只需要做一次修改

00:31:51.512 --> 00:31:53.213 
改動的地方就會自動送給所有的實例

00:31:53.280 --> 00:31:55.249 
在這個層中

00:32:01.154 --> 00:32:01.989 
接下來

00:32:02.055 --> 00:32:03.790 
我想在我的層中創建一個跳轉場景

00:32:03.857 --> 00:32:07.060 
我會使用我們剛纔介紹的

00:32:07.261 --> 00:32:08.195 
新的動作編輯器來做

00:32:08.562 --> 00:32:10.764 
放在從前 你只能在代碼中創建動作

00:32:10.831 --> 00:32:13.467 
這非常不容易看到

00:32:13.534 --> 00:32:16.637 
所以我們想要開發一中編輯器
能夠很容易的創建複雜的動作

00:32:16.703 --> 00:32:19.072 
並給你實時的

00:32:19.139 --> 00:32:20.140 
你正在創建的圖像信息

00:32:20.774 --> 00:32:22.309 
訪問動作編輯器

00:32:22.376 --> 00:32:23.944 
你可以點擊左下角的按鈕

00:32:24.011 --> 00:32:26.246 
你會看到顯示出來

00:32:26.313 --> 00:32:29.082 
你的場景中的所有節點以及時間軸

00:32:29.149 --> 00:32:30.884 
其中包含所有的動作

00:32:31.251 --> 00:32:33.353 
我們能夠看到我們的角色
已經有了一個動作

00:32:33.420 --> 00:32:35.122 
這是一個由紋理動作組成的動畫

00:32:35.656 --> 00:32:37.357 
我們將它放在一個空閒的幀內

00:32:37.491 --> 00:32:38.759 
現在點擊播放

00:32:39.026 --> 00:32:41.862 
我們可以看到我們的角色
在我們的場景中

00:32:42.162 --> 00:32:42.996 
動了起來

00:32:43.964 --> 00:32:46.300 
接下來
在我們的層中創建一個跳轉場景

00:32:46.366 --> 00:32:49.269 
我們準備讓角色穿過這一層

00:32:50.103 --> 00:32:51.939 
要做到這些

00:32:52.005 --> 00:32:54.174 
我們需要過濾出來
我們的玩家互動編輯器和

00:32:54.975 --> 00:32:57.511 
我們的對象庫中的動作

00:32:57.711 --> 00:33:01.215 
我們爲你提供了一組動作構件

00:33:01.281 --> 00:33:02.983 
可以用來創建更加複雜的動作

00:33:03.050 --> 00:33:04.651 
這正是我接下來要做到的事情

00:33:05.052 --> 00:33:07.054 
我們首先添加一個移動的動作

00:33:07.120 --> 00:33:08.155 
到我們的跳轉場景中

00:33:08.222 --> 00:33:10.958 
我需要做的所有事情就是拖放
從對象庫拖放到時間軸中

00:33:11.992 --> 00:33:13.260 
現在對於這個運動

00:33:13.327 --> 00:33:16.196 
我們可以看到在X方向上有850個單
位組成

00:33:16.263 --> 00:33:18.165 
我們想要將這個動作做得更緩慢更自然

00:33:18.565 --> 00:33:20.033 
現在點擊這個播放

00:33:20.100 --> 00:33:22.236 
我們可以看到我們的角色是這樣跑的

00:33:22.569 --> 00:33:24.605 
這有點快
所以我們需要修改持續的時間

00:33:24.671 --> 00:33:27.441 
將這個動作拖長大概2秒

00:33:27.741 --> 00:33:29.276 
我想要調整一下時間軸

00:33:29.843 --> 00:33:30.777 
所以現在運行一下

00:33:30.844 --> 00:33:32.513 
這時的運動就有了一個更合理的速率

00:33:33.780 --> 00:33:37.251 
現在我想讓角色
在穿越屏幕的時候跑起來

00:33:37.317 --> 00:33:39.520 
所以我要添加一個帶有紋理動作的動畫

00:33:40.320 --> 00:33:42.823 
要定義我們準備使用的動畫

00:33:42.990 --> 00:33:45.359 
我可以打開媒體庫

00:33:45.425 --> 00:33:46.760 
過濾下來我們的奔跑的框架

00:33:47.327 --> 00:33:49.897 
我可以選擇之後將其簡單地
拖動到我們的運動中

00:33:50.397 --> 00:33:51.298 
現在我們運行一下

00:33:52.332 --> 00:33:55.002 
可以看到角色將會做這個動作

00:33:55.402 --> 00:33:58.005 
當然 如果我們只使用一次的話

00:33:58.071 --> 00:34:00.407 
我們可以添加一個循環

00:34:00.474 --> 00:34:01.475 
這樣就能在其移動的整個
時間段中持續下來

00:34:01.542 --> 00:34:03.844 
我可以點擊角落裏的
這個循環按鈕創建一個循環

00:34:03.911 --> 00:34:05.212 
我能夠看到

00:34:05.279 --> 00:34:06.647 
循環的所有控制參數

00:34:06.947 --> 00:34:10.350 
我可以增加迭代的次數 

00:34:10.417 --> 00:34:11.784 
也可以減少 也可以自定義循環

00:34:12.186 --> 00:34:14.454 
在這個例子中我想要讓它循環兩次

00:34:14.521 --> 00:34:16.822 
接下來我將調整一下持續時間
來適應我們的運動過程

00:34:17.024 --> 00:34:19.426 
現在我們就得到了我們的角色
跑着穿越整個場景的動畫

00:34:20.360 --> 00:34:22.862 
接下來 我們在層中添加兩個溝

00:34:22.929 --> 00:34:24.565 
讓這個角色跳過它們

00:34:24.630 --> 00:34:30.003 
在動作編輯器中我們可以
定向清除我們動作中的時間點

00:34:30.070 --> 00:34:33.806 
在剛剛到達溝的旁邊的時候
我可以清除掉

00:34:33.940 --> 00:34:35.876 
然後添加一個其他的動作

00:34:36.342 --> 00:34:38.045 
我們可以正好對齊我們剛纔擦除的地方

00:34:39.913 --> 00:34:43.350 
對於這個移動
我們會在Y軸方向移動100個單位

00:34:43.417 --> 00:34:44.885 
我將其設置成緩慢輸出

00:34:45.351 --> 00:34:47.688 
這樣在到達我們跳躍的頂部的時候
角色的動作會變慢

00:34:48.422 --> 00:34:51.225 
在到達溝的中間的時候
我會再做一次擦除

00:34:51.291 --> 00:34:53.360 
調整一下持續時間 使角色能夠在

00:34:53.427 --> 00:34:56.063 
達到最高點的時候剛好到達溝的中間

00:34:56.797 --> 00:35:00.734 
然後複製我們動作的第一部分
然後翻轉

00:35:00.901 --> 00:35:02.903 
得到一個完整的跳躍運動

00:35:03.871 --> 00:35:05.405 
跳躍的最後一步

00:35:05.472 --> 00:35:07.741 
我準備再創建一個動畫

00:35:07.808 --> 00:35:11.011 
包含跳躍的構架

00:35:11.078 --> 00:35:14.081 
同樣的方法
打開媒體庫 過濾下來我們的跳躍構架

00:35:14.147 --> 00:35:15.282 
添加到動作中

00:35:16.316 --> 00:35:18.919 
現在我們的角色就能夠
從第一個溝上面跳過去

00:35:20.354 --> 00:35:23.257 
當然 我們還有一個溝

00:35:23.323 --> 00:35:25.826 
我需要做的就是複製我剛剛添加的動作

00:35:25.893 --> 00:35:28.629 
然後替換
但是接下來我們會碰到同樣的問題

00:35:28.695 --> 00:35:31.031 
那就是在地圖上的哪裏進行修改

00:35:31.098 --> 00:35:33.767 
我將要對每一個複製的實例進行修改

00:35:34.101 --> 00:35:37.037 
很可能我會在不同的層中

00:35:37.104 --> 00:35:38.005 
重複使用這些動作

00:35:38.071 --> 00:35:39.740 
甚至可能在不同的工程中

00:35:40.374 --> 00:35:41.875 
我們用同樣的方式解決了這個問題

00:35:41.942 --> 00:35:44.077 
就是允許你引用運動

00:35:44.411 --> 00:35:46.647 
我們在Xcode中引入一個新文件

00:35:46.813 --> 00:35:48.615 
這是一個
SpriteKit動作文件夾

00:35:49.416 --> 00:35:51.251 
這個文件夾中放了一些動作文件

00:35:51.318 --> 00:35:53.086 
這些動作文件的名字

00:35:53.153 --> 00:35:55.822 
你可以在場景、工程或者代碼中
全局引用

00:35:56.290 --> 00:35:57.824 
接下來 選定動作文件  

00:35:58.225 --> 00:36:00.594 
創建一個這樣的文件夾

00:36:00.661 --> 00:36:01.762 
並將其轉換成引用的形式

00:36:02.162 --> 00:36:04.798 
我準備給它命名 將其命名爲跳躍

00:36:05.232 --> 00:36:07.367 
我們可以選擇一個動作文件夾放進去

00:36:07.434 --> 00:36:09.336 
在這個例子中
我會新建一個新的文件夾

00:36:10.871 --> 00:36:13.674 
我給這個文件夾命名爲角色動作

00:36:13.740 --> 00:36:16.376 
因爲我打算將所有的跟角色有關的動作
都放進這個文件夾

00:36:17.911 --> 00:36:19.479 
將這個文件添加到我們的工程

00:36:19.546 --> 00:36:21.982 
現在你會看到我們創建的這些動作

00:36:22.049 --> 00:36:24.418 
例如跳躍已經在跳躍文件夾的下面了

00:36:24.818 --> 00:36:25.919 
並且在我們的場景中

00:36:26.620 --> 00:36:28.622 
我們可以引用
這些動作

00:36:29.690 --> 00:36:31.225 
現在你放到這個文件夾中的動作

00:36:31.291 --> 00:36:33.360 
已經完全從所有的場景
或者工程中獨立了出來

00:36:33.427 --> 00:36:35.195 
但是在一些場景中某些背景下

00:36:35.262 --> 00:36:36.897 
你經常會想要修改他們

00:36:37.431 --> 00:36:39.533 
我們允許你設置一個預覽窗口

00:36:39.600 --> 00:36:42.469 
你可以分配你文件夾中的任何動作
在你的場景中的任何節點

00:36:42.536 --> 00:36:45.372 
例如我可以在這個場景中的任何節點預
覽我 的跳躍動作

00:36:45.572 --> 00:36:46.874 
或者打開一個自己的場景

00:36:46.940 --> 00:36:48.709 
在角色的不同角度

00:36:48.976 --> 00:36:51.979 
例如 我可以預覽角色左邊或者

00:36:52.045 --> 00:36:55.115 
右邊跳躍動作是怎樣的

00:36:56.984 --> 00:36:59.119 
所以現在 在這裏 我們繼續 

00:36:59.186 --> 00:37:02.623 
回到擦除第二個溝的地方 在對象庫中

00:37:02.689 --> 00:37:04.391 
我們可以用可以引用的動作

00:37:04.458 --> 00:37:05.792 
自動填充進去

00:37:05.893 --> 00:37:08.929 
因爲我剛纔創建的跳躍動作

00:37:08.996 --> 00:37:11.565 
已經自動放在了對象庫中
我就能夠將它拖放進去

00:37:11.899 --> 00:37:14.101 
現在我們就完成了我們的跳轉場景
讓我們欣賞一下

00:37:16.937 --> 00:37:17.838 
看起來很棒

00:37:18.372 --> 00:37:20.607 
現在我想向你展示一下
怎樣在代碼中使用

00:37:20.674 --> 00:37:23.143 
而不僅僅是一個跳轉場景

00:37:23.844 --> 00:37:26.446 
我想要做的就是在每一個角色
可能存在的地圖中

00:37:26.513 --> 00:37:29.983 
都創建一個動作 然後通過代碼引用它

00:37:31.051 --> 00:37:33.654 
我要創建一個引用

00:37:33.720 --> 00:37:35.355 
這個可引用的動作叫跑

00:37:35.489 --> 00:37:36.523 
其中包含我們動畫

00:37:37.090 --> 00:37:38.992 
我也同樣對對空文件這麼處理

00:37:41.061 --> 00:37:42.129 
現在開始 刪除這些

00:37:42.196 --> 00:37:44.364 
因爲現在我們要把這些做成交互式的

00:37:44.698 --> 00:37:45.933 
現在你可以看到

00:37:45.999 --> 00:37:48.101 
我們的動作文件夾中

00:37:48.168 --> 00:37:50.270 
包含了三個地圖

00:37:50.671 --> 00:37:52.573 
現在通過代碼使用這些動作

00:37:52.639 --> 00:37:54.641 
你所要做的就是使用
我們剛纔介紹的新選擇器

00:37:54.975 --> 00:37:57.010 
動作名稱選擇器 

00:37:57.077 --> 00:37:58.946 
給它們提供我們剛剛創建的動作的名稱

00:37:59.279 --> 00:38:00.981 
空 跑 和跳躍

00:38:01.682 --> 00:38:04.451 
現在當我運行我們的遊戲時

00:38:04.518 --> 00:38:07.354 
你能夠看到我剛纔創建的動作
現在正在遊戲中使用着

00:38:08.188 --> 00:38:09.022 
交互式的

00:38:09.857 --> 00:38:11.792 
這一點最強大的地方在於

00:38:11.859 --> 00:38:12.960 
當你想要修改你的動作時

00:38:13.026 --> 00:38:14.928 
我可以直接打開動作文件夾

00:38:14.995 --> 00:38:18.065 
例如 讓角色在跳躍的時候翻個筋斗

00:38:18.131 --> 00:38:22.636 
我可以打開這裏
然後添加一個旋轉的動作到跳躍上

00:38:23.337 --> 00:38:26.406 
給它賦值負360 緩進緩出

00:38:27.007 --> 00:38:30.143 
現在我們不編譯就運行我們的遊戲

00:38:30.544 --> 00:38:32.212 
我們可以看到發生了改變

00:38:32.279 --> 00:38:33.981 
我剛做的修改已經提交給了角色

00:38:41.154 --> 00:38:42.723 
現在這一層看起來已經很棒了

00:38:42.789 --> 00:38:45.225 
所以最後要做的事情就是
創建一個漂亮的電影動畫開場

00:38:45.325 --> 00:38:47.060 
將角色引入到這一層

00:38:47.494 --> 00:38:51.698 
我可以通過創建一個SKCamera
Node到場景中的方式實現

00:38:52.199 --> 00:38:54.968 
讓我們在鏡頭節點中
定義一個Viewport

00:38:55.135 --> 00:38:57.104 
我們可以開始使用我剛添加的鏡頭

00:38:57.304 --> 00:38:59.306 
來分配我們的場景

00:39:00.174 --> 00:39:02.643 
作爲電影動畫開場
我想用從這個角落開始

00:39:02.709 --> 00:39:05.512 
使用鏡頭放大

00:39:10.450 --> 00:39:12.252 
我準備放大這裏的霧氣

00:39:12.719 --> 00:39:15.389 
最棒的是
因爲這只是一個SKNode 

00:39:15.455 --> 00:39:16.590 
我可以向鏡頭中添加動作

00:39:17.191 --> 00:39:19.159 
過濾下來適應我們的鏡頭

00:39:20.260 --> 00:39:21.929 
之後添加一個有兩個動作的移動

00:39:22.262 --> 00:39:24.698 
我準備要做的電影動畫開場

00:39:24.765 --> 00:39:26.433 
就是講鏡頭平移到這一層的中心

00:39:26.600 --> 00:39:28.001 
同時縮放

00:39:28.535 --> 00:39:30.571 
第二步我將要把X軸的值

00:39:30.637 --> 00:39:33.841 
設置爲507
作爲中 心

00:39:35.042 --> 00:39:37.177 
同時將Y軸的值設置爲
384個單位並作爲中心

00:39:37.244 --> 00:39:39.513 
並將這些設置爲

00:39:39.580 --> 00:39:40.881 
緩進緩出

00:39:41.782 --> 00:39:44.184 
我打算在我們打開我們的場景半秒鐘後

00:39:44.251 --> 00:39:46.019 
開始移動我們的動畫

00:39:46.086 --> 00:39:48.455 
並耗時3秒將其平移過去

00:39:48.922 --> 00:39:52.893 
同樣我添加了第二個動作
並給其半秒鐘從我們的動畫中抵消

00:39:52.960 --> 00:39:57.631 
在動畫結束後同時結束

00:39:58.031 --> 00:39:59.333 
現在 在短短時間內

00:39:59.399 --> 00:40:01.001 
我們創建了一個電影動畫式的開場

00:40:01.134 --> 00:40:02.236 
我們也已經結束了這一層

00:40:02.402 --> 00:40:04.004 
接下來讓我們看一下它現在什麼樣子

00:40:11.879 --> 00:40:14.481 
這就是你現在可以使用
SpriteKit和Xcode 7

00:40:14.581 --> 00:40:16.917 
做的事情了

00:40:23.657 --> 00:40:25.292 
與此同時 我想將話題重新交給提姆

00:40:25.392 --> 00:40:27.961 
讓它來爲你們總結一下

00:40:29.396 --> 00:40:30.564 
謝謝泰勒

00:40:30.664 --> 00:40:32.266 
這真的是一個非常棒的工作

00:40:32.666 --> 00:40:35.335 
我相信大家有目共睹

00:40:35.402 --> 00:40:37.237 
這對於SpriteKit工程師來講

00:40:37.304 --> 00:40:38.472 
將會是超級棒的一年

00:40:38.772 --> 00:40:41.675 
我們新增了AudioNode,
也新增了CameraNode

00:40:41.742 --> 00:40:43.243 
我們也有了可以引用的動作和節點

00:40:43.510 --> 00:40:45.345 
也有了一個全新的

00:40:45.412 --> 00:40:47.548 
基於運動編輯器的
集成在Xcode中的時間軸

00:40:47.781 --> 00:40:50.851 
我們整合了紋理地圖集和資源目錄

00:40:50.918 --> 00:40:52.619 
並給你提供了新的功能

00:40:52.853 --> 00:40:55.088 
例如基於命令的資源庫
和更加簡潔的App

00:40:55.656 --> 00:40:59.059 
同時也使SpriteKit適配
所有的支持Metal的設備

00:40:59.126 --> 00:41:01.962 
讓你能夠更容易地訪問

00:41:02.095 --> 00:41:03.830 
全新的GamePlayKit構架

00:41:06.300 --> 00:41:08.101 
如果你需要更多的信息

00:41:08.168 --> 00:41:09.837 
請訪問我們的開發者網站

00:41:09.903 --> 00:41:11.138 
或者撥打諮詢電話

00:41:11.271 --> 00:41:13.774 
聯繫我們的圖形專家Allan
Schaffer 

00:41:15.342 --> 00:41:16.543 
還有幾個與之相關的會議

00:41:16.610 --> 00:41:18.212 
如果你想對GamePlayKit

00:41:18.278 --> 00:41:19.880 
或者SceneKit瞭解更多的話

00:41:21.014 --> 00:41:22.749 
我們也有一些實驗室

00:41:22.850 --> 00:41:24.585 
第一個就是SpriteKit實驗室

00:41:24.651 --> 00:41:25.786 
現在馬上就會啓動

00:41:26.053 --> 00:41:28.689 
大家放鬆 跟我們一起下樓

00:41:28.755 --> 00:41:30.390 
我們將很樂意回答你們的所有問題

00:41:31.091 --> 00:41:32.960 
非常感謝
請享受您的會議